/**
 * lobbyEtcClientProtocols.cpp
 *
 * This file was auto-generated from lobbyEtcClientProtocols.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor lobbyEtcClientProtocols.txt
 */
 
#include "lobbyEtcClientProtocols.h"

//=================================================================
//                Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF(Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF& LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::operator=(Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::clear()
{
	errCode = 0;
	errString.clear();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::equals(const Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errString);
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errString);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errString; _jparser.validateByNameThrow("errString", errString);
	AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID(Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID&& _o)
	: clientId(std::move(_o.clientId))
	, errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID& LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::operator=(Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID&& _o)
{
	if(this != &_o)
	{
		clientId = std::move(_o.clientId);
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::clear()
{
	clientId = 0;
	errCode = 0;
	errString.clear();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::equals(const Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID& _o) const
{
	return clientId == _o.clientId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID).append(")");
	_buf.append(',');
	_buf.append("clientId=");
	_buf.appendUint(clientId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientId", clientId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientId"))
			{
				clientId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clientId);
	_msg.composeINT16(errCode);
	_msg.composeString(errString);
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clientId);
	_parser.parseINT16(errCode);
	_parser.parseStringP(errString);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientId", clientId);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientId", clientId);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clientId; _jparser.validateByNameThrow("clientId", clientId);
	AtfValidator::validateInt(_descr, "clientId", clientId, _checker, __FILE__, __LINE__);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errString; _jparser.validateByNameThrow("errString", errString);
	AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clientId; _parser.parseUINT32(clientId);
	AtfValidator::validateInt(_descr, "clientId", clientId, _checker, __FILE__, __LINE__);
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_RECONNECT
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::Protocol_MSG_LOBBYETC_CLI_RECONNECT()
{
	clear();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::clear()
{
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::equals(const Protocol_MSG_LOBBYETC_CLI_RECONNECT& _o) const
{
	return true;
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_RECONNECT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_RECONNECT*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_RECONNECT).append(")");
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_RECONNECT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_RECONNECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_RECONNECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT(Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT&& _o)
	: result(std::move(_o.result))
	, resultStr(std::move(_o.resultStr))
{
}

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT& LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::operator=(Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT&& _o)
{
	if(this != &_o)
	{
		result = std::move(_o.result);
		resultStr = std::move(_o.resultStr);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::clear()
{
	result = 0;
	resultStr.clear();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::equals(const Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT& _o) const
{
	return result == _o.result &&
		Atf::atfPStringEquals(resultStr, _o.resultStr);
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT).append(")");
	_buf.append(',');
	_buf.append("result=");
	_buf.appendUint(result);
	_buf.append(',');
	_buf.append("resultStr=");
	_buf.append(resultStr);
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("result", result, _buf);
	Atf::XmlElement::encodeAsXmlElement("resultStr", resultStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("result"))
			{
				result = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("resultStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, resultStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(result);
	_msg.composeString(resultStr);
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(result);
	_parser.parseStringP(resultStr);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("result", result);
	_jsonstr.compose("resultStr", resultStr);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("result", result);
	_jparser.parseByNameThrow("resultStr", resultStr);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 result; _jparser.validateByNameThrow("result", result);
	AtfValidator::validateInt(_descr, "result", result, _checker, __FILE__, __LINE__);
	PString resultStr; _jparser.validateByNameThrow("resultStr", resultStr);
	AtfValidator::validateInt(_descr, "resultStr", resultStr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 result; _parser.parseUINT32(result);
	AtfValidator::validateInt(_descr, "result", result, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "resultStr"); size_t szResultStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "resultStr", szResultStr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE(Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE&& _o)
	: licenseKey(std::move(_o.licenseKey))
	, geoIPReason(std::move(_o.geoIPReason))
	, encryptedUserIntId(std::move(_o.encryptedUserIntId))
	, mobileNum(std::move(_o.mobileNum))
{
}

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE& LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::operator=(Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE&& _o)
{
	if(this != &_o)
	{
		licenseKey = std::move(_o.licenseKey);
		geoIPReason = std::move(_o.geoIPReason);
		encryptedUserIntId = std::move(_o.encryptedUserIntId);
		mobileNum = std::move(_o.mobileNum);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::clear()
{
	licenseKey.clear();
	geoIPReason.clear();
	encryptedUserIntId.clear();
	mobileNum.clear();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::equals(const Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE& _o) const
{
	return Atf::atfPStringEquals(licenseKey, _o.licenseKey) &&
		Atf::atfPStringEquals(geoIPReason, _o.geoIPReason) &&
		Atf::atfPStringEquals(encryptedUserIntId, _o.encryptedUserIntId) &&
		Atf::atfPStringEquals(mobileNum, _o.mobileNum);
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GEOCOMPLY_LOCATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GEOCOMPLY_LOCATE).append(")");
	_buf.append(',');
	_buf.append("licenseKey=");
	_buf.append(licenseKey);
	_buf.append(',');
	_buf.append("geoIPReason=");
	_buf.append(geoIPReason);
	_buf.append(',');
	_buf.append("encryptedUserIntId=");
	_buf.append(encryptedUserIntId);
	_buf.append(',');
	_buf.append("mobileNum=");
	_buf.append(mobileNum);
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GEOCOMPLY_LOCATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("licenseKey", licenseKey, _buf);
	Atf::XmlElement::encodeAsXmlElement("geoIPReason", geoIPReason, _buf);
	Atf::XmlElement::encodeAsXmlElement("encryptedUserIntId", encryptedUserIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobileNum", mobileNum, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("licenseKey"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, licenseKey)) return false;
			}
			else if (_element.equals("geoIPReason"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, geoIPReason)) return false;
			}
			else if (_element.equals("encryptedUserIntId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encryptedUserIntId)) return false;
			}
			else if (_element.equals("mobileNum"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobileNum)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(licenseKey);
	_msg.composeString(geoIPReason);
	_msg.composeString(encryptedUserIntId);
	_msg.composeString(mobileNum);
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(licenseKey);
	_parser.parseStringP(geoIPReason);
	_parser.parseStringP(encryptedUserIntId);
	_parser.parseStringP(mobileNum);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("licenseKey", licenseKey);
	_jsonstr.compose("geoIPReason", geoIPReason);
	_jsonstr.compose("encryptedUserIntId", encryptedUserIntId);
	_jsonstr.compose("mobileNum", mobileNum);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("licenseKey", licenseKey);
	_jparser.parseByNameThrow("geoIPReason", geoIPReason);
	_jparser.parseByNameThrow("encryptedUserIntId", encryptedUserIntId);
	_jparser.parseByNameThrow("mobileNum", mobileNum);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GEOCOMPLY_LOCATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString licenseKey; _jparser.validateByNameThrow("licenseKey", licenseKey);
	AtfValidator::validateInt(_descr, "licenseKey", licenseKey.length(), _checker, __FILE__, __LINE__);
	PString geoIPReason; _jparser.validateByNameThrow("geoIPReason", geoIPReason);
	AtfValidator::validateInt(_descr, "geoIPReason", geoIPReason.length(), _checker, __FILE__, __LINE__);
	PString encryptedUserIntId; _jparser.validateByNameThrow("encryptedUserIntId", encryptedUserIntId);
	AtfValidator::validateInt(_descr, "encryptedUserIntId", encryptedUserIntId.length(), _checker, __FILE__, __LINE__);
	PString mobileNum; _jparser.validateByNameThrow("mobileNum", mobileNum);
	AtfValidator::validateInt(_descr, "mobileNum", mobileNum.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GEOCOMPLY_LOCATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "licenseKey"); size_t szLicenseKey = strlen(_dummy);
	AtfValidator::validateInt(_descr, "licenseKey", szLicenseKey, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "geoIPReason"); size_t szGeoIPReason = strlen(_dummy);
	AtfValidator::validateInt(_descr, "geoIPReason", szGeoIPReason, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "encryptedUserIntId"); size_t szEncryptedUserIntId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "encryptedUserIntId", szEncryptedUserIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "mobileNum"); size_t szMobileNum = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mobileNum", szMobileNum, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION(Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION&& _o)
	: countryCode(std::move(_o.countryCode))
	, phoneNumWithoutCountryCode(std::move(_o.phoneNumWithoutCountryCode))
	, needVerify(std::move(_o.needVerify))
{
}

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION& LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::operator=(Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION&& _o)
{
	if(this != &_o)
	{
		countryCode = std::move(_o.countryCode);
		phoneNumWithoutCountryCode = std::move(_o.phoneNumWithoutCountryCode);
		needVerify = std::move(_o.needVerify);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::clear()
{
	countryCode.clear();
	phoneNumWithoutCountryCode.clear();
	needVerify = false;
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::equals(const Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION& _o) const
{
	return Atf::atfPStringEquals(countryCode, _o.countryCode) &&
		Atf::atfPStringEquals(phoneNumWithoutCountryCode, _o.phoneNumWithoutCountryCode) &&
		needVerify == _o.needVerify;
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION).append(")");
	_buf.append(',');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	_buf.append(',');
	_buf.append("phoneNumWithoutCountryCode=");
	_buf.append(phoneNumWithoutCountryCode);
	_buf.append(',');
	_buf.append("needVerify=");
	_buf.appendUint(needVerify);
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("countryCode", countryCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("phoneNumWithoutCountryCode", phoneNumWithoutCountryCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("needVerify", needVerify, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("countryCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, countryCode)) return false;
			}
			else if (_element.equals("phoneNumWithoutCountryCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, phoneNumWithoutCountryCode)) return false;
			}
			else if (_element.equals("needVerify"))
			{
				needVerify = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(countryCode);
	_msg.composeString(phoneNumWithoutCountryCode);
	_msg.composeBOOL(needVerify);
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(countryCode);
	_parser.parseStringP(phoneNumWithoutCountryCode);
	_parser.parseBOOL(needVerify);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("countryCode", countryCode);
	_jsonstr.compose("phoneNumWithoutCountryCode", phoneNumWithoutCountryCode);
	_jsonstr.compose("needVerify", needVerify);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("countryCode", countryCode);
	_jparser.parseByNameThrow("phoneNumWithoutCountryCode", phoneNumWithoutCountryCode);
	_jparser.parseByNameThrow("needVerify", needVerify);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString countryCode; _jparser.validateByNameThrow("countryCode", countryCode);
	AtfValidator::validateInt(_descr, "countryCode", countryCode.length(), _checker, __FILE__, __LINE__);
	PString phoneNumWithoutCountryCode; _jparser.validateByNameThrow("phoneNumWithoutCountryCode", phoneNumWithoutCountryCode);
	AtfValidator::validateInt(_descr, "phoneNumWithoutCountryCode", phoneNumWithoutCountryCode.length(), _checker, __FILE__, __LINE__);
	bool needVerify; _jparser.validateByNameThrow("needVerify", needVerify);
	AtfValidator::validateInt(_descr, "needVerify", needVerify, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "countryCode", szCountryCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "phoneNumWithoutCountryCode"); size_t szPhoneNumWithoutCountryCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "phoneNumWithoutCountryCode", szPhoneNumWithoutCountryCode, _checker, __FILE__, __LINE__);
	bool needVerify; _parser.parseBOOL(needVerify);
	AtfValidator::validateInt(_descr, "needVerify", needVerify, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS(Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS&& _o)
	: status(std::move(_o.status))
	, statusStr(std::move(_o.statusStr))
{
}

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS& LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::operator=(Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS&& _o)
{
	if(this != &_o)
	{
		status = std::move(_o.status);
		statusStr = std::move(_o.statusStr);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::clear()
{
	status = 0;
	statusStr.clear();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::equals(const Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS& _o) const
{
	return status == _o.status &&
		Atf::atfPStringEquals(statusStr, _o.statusStr);
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS).append(")");
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("statusStr=");
	_buf.append(statusStr);
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("statusStr", statusStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("status"))
			{
				status = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("statusStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, statusStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(status);
	_msg.composeString(statusStr);
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
	_parser.parseStringP(statusStr);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	_jsonstr.compose("statusStr", statusStr);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("statusStr", statusStr);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	PString statusStr; _jparser.validateByNameThrow("statusStr", statusStr);
	AtfValidator::validateInt(_descr, "statusStr", statusStr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "statusStr"); size_t szStatusStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "statusStr", szStatusStr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT()
{
	clear();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::clear()
{
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::equals(const Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT& _o) const
{
	return true;
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT).append(")");
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ThrowableElement
//=================================================================

LobbyEtcClient::player::ThrowableElement::ThrowableElement()
{
	clear();
}

void LobbyEtcClient::player::ThrowableElement::clear()
{
	throwableTypeId = 0;
	isEnabled = 0;
}

bool LobbyEtcClient::player::ThrowableElement::equals(const ThrowableElement& _o) const
{
	return throwableTypeId == _o.throwableTypeId &&
		isEnabled == _o.isEnabled;
}

const char *LobbyEtcClient::player::ThrowableElement::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("throwableTypeId=");
	_buf.appendUint(throwableTypeId);
	_buf.append(',');
	_buf.append("isEnabled=");
	_buf.appendUint(isEnabled);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::player::ThrowableElement::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("throwableTypeId", throwableTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isEnabled", isEnabled, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::player::ThrowableElement::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("throwableTypeId"))
		{
			throwableTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isEnabled"))
		{
			isEnabled = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::player::ThrowableElement::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ThrowableElement())) // not empty
	{
		_body.composeUINT32(throwableTypeId);
		_body.composeUINT32(isEnabled);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::player::ThrowableElement::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(throwableTypeId);
	_parser0.parseUINT32(isEnabled);
}

const char *LobbyEtcClient::player::ThrowableElement::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("throwableTypeId", throwableTypeId);
	_jsonstr.compose("isEnabled", isEnabled);
	return _buf.c_str();
}

void LobbyEtcClient::player::ThrowableElement::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("throwableTypeId", throwableTypeId);
	_jparser.parseByNameThrow("isEnabled", isEnabled);
}

/* static */ void LobbyEtcClient::player::ThrowableElement::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 throwableTypeId; _jparser.validateByNameThrow("throwableTypeId", throwableTypeId);
	AtfValidator::validateInt(_descr, "throwableTypeId", throwableTypeId, _checker, __FILE__, __LINE__);
	UINT32 isEnabled; _jparser.validateByNameThrow("isEnabled", isEnabled);
	AtfValidator::validateInt(_descr, "isEnabled", isEnabled, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::ThrowableElement::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 throwableTypeId; _parser0.parseUINT32(throwableTypeId);
	AtfValidator::validateInt(_descr, "throwableTypeId", throwableTypeId, _checker, __FILE__, __LINE__);
	UINT32 isEnabled; _parser0.parseUINT32(isEnabled);
	AtfValidator::validateInt(_descr, "isEnabled", isEnabled, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UnsolicitedNotification_Throwables
//=================================================================

LobbyEtcClient::player::UnsolicitedNotification_Throwables::UnsolicitedNotification_Throwables()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::UnsolicitedNotification_Throwables::UnsolicitedNotification_Throwables(UnsolicitedNotification_Throwables&& _o)
	: throwableEnablements(std::move(_o.throwableEnablements))
	, coolDownInterval(std::move(_o.coolDownInterval))
{
}

LobbyEtcClient::player::UnsolicitedNotification_Throwables& LobbyEtcClient::player::UnsolicitedNotification_Throwables::operator=(UnsolicitedNotification_Throwables&& _o)
{
	if(this != &_o)
	{
		throwableEnablements = std::move(_o.throwableEnablements);
		coolDownInterval = std::move(_o.coolDownInterval);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::UnsolicitedNotification_Throwables::clear()
{
	throwableEnablements.clear();
	coolDownInterval = 0;
}

bool LobbyEtcClient::player::UnsolicitedNotification_Throwables::equals(const UnsolicitedNotification_Throwables& _o) const
{
	return throwableEnablements.equals(_o.throwableEnablements) &&
		coolDownInterval == _o.coolDownInterval;
}

const char *LobbyEtcClient::player::UnsolicitedNotification_Throwables::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("throwableEnablements=");
	throwableEnablements.toTraceString(_buf);
	_buf.append(',');
	_buf.append("coolDownInterval=");
	_buf.appendInt(coolDownInterval);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::player::UnsolicitedNotification_Throwables::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	throwableEnablements.toXmlString("throwableEnablements", _buf);
	Atf::XmlElement::encodeAsXmlElement("coolDownInterval", coolDownInterval, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::player::UnsolicitedNotification_Throwables::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("throwableEnablements"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ThrowableElement, 4 > >::FromXmlString(_value, throwableEnablements)) return false;
		}
		else if (_element.equals("coolDownInterval"))
		{
			coolDownInterval = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::player::UnsolicitedNotification_Throwables::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	throwableEnablements.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(coolDownInterval);
}

void LobbyEtcClient::player::UnsolicitedNotification_Throwables::parseMsg(CommMsgParser& _parser)
{
	throwableEnablements.parseMsg(_parser);
	_parser.parseINT32(coolDownInterval);
}

const char *LobbyEtcClient::player::UnsolicitedNotification_Throwables::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("throwableEnablements", throwableEnablements);
	_jsonstr.compose("coolDownInterval", coolDownInterval);
	return _buf.c_str();
}

void LobbyEtcClient::player::UnsolicitedNotification_Throwables::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("throwableEnablements", throwableEnablements);
	_jparser.parseByNameThrow("coolDownInterval", coolDownInterval);
}

/* static */ void LobbyEtcClient::player::UnsolicitedNotification_Throwables::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< ThrowableElement > throwableEnablements; _jparser.validateByNameThrow("throwableEnablements", throwableEnablements);
	AtfValidator::validateInt(_descr, "throwableEnablements", throwableEnablements.size(), _checker, __FILE__, __LINE__);
	INT32 coolDownInterval; _jparser.validateByNameThrow("coolDownInterval", coolDownInterval);
	AtfValidator::validateInt(_descr, "coolDownInterval", coolDownInterval, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::UnsolicitedNotification_Throwables::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szThrowableEnablements = Atf::LAtfVector< ThrowableElement, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("throwableEnablements"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "throwableEnablements", szThrowableEnablements, _checker, __FILE__, __LINE__);
	INT32 coolDownInterval; _parser.parseINT32(coolDownInterval);
	AtfValidator::validateInt(_descr, "coolDownInterval", coolDownInterval, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UnsolicitedNotificationType_WebNotification
//=================================================================

LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::UnsolicitedNotificationType_WebNotification()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::UnsolicitedNotificationType_WebNotification(UnsolicitedNotificationType_WebNotification&& _o)
	: payload(std::move(_o.payload))
{
}

LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification& LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::operator=(UnsolicitedNotificationType_WebNotification&& _o)
{
	if(this != &_o)
	{
		payload = std::move(_o.payload);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::clear()
{
	payload.clear();
}

bool LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::equals(const UnsolicitedNotificationType_WebNotification& _o) const
{
	return Atf::atfPStringEquals(payload, _o.payload);
}

const char *LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("payload=");
	_buf.append(payload);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("payload", payload, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("payload"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, payload)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(payload);
}

void LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(payload);
}

const char *LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("payload", payload);
	return _buf.c_str();
}

void LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("payload", payload);
}

/* static */ void LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString payload; _jparser.validateByNameThrow("payload", payload);
	AtfValidator::validateInt(_descr, "payload", payload.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::UnsolicitedNotificationType_WebNotification::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "payload"); size_t szPayload = strlen(_dummy);
	AtfValidator::validateInt(_descr, "payload", szPayload, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION(Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION&& _o)
	: notifType(std::move(_o.notifType))
	, notifMsg(std::move(_o.notifMsg))
{
}

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION& LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::operator=(Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION&& _o)
{
	if(this != &_o)
	{
		notifType = std::move(_o.notifType);
		notifMsg = std::move(_o.notifMsg);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::clear()
{
	notifType = 0;
	notifMsg.clear();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::equals(const Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION& _o) const
{
	return notifType == _o.notifType &&
		notifMsg.equals(_o.notifMsg);
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION).append(")");
	_buf.append(',');
	_buf.append("notifType=");
	_buf.appendUint(notifType);
	_buf.append(',');
	_buf.append("notifMsg=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(notifMsg, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notifType", notifType, _buf);
	Atf::XmlElement::encodeAsXmlElement("notifMsg", notifMsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notifType"))
			{
				notifType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notifMsg"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, notifMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(notifType);
	_msg.composeMsgBody(notifMsg);
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(notifType);
	_parser.parseMsgBody(notifMsg);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notifType", notifType);
	_jsonstr.compose("notifMsg", notifMsg);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notifType", notifType);
	_jparser.parseByNameThrow("notifMsg", notifMsg);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 notifType; _jparser.validateByNameThrow("notifType", notifType);
	AtfValidator::validateInt(_descr, "notifType", notifType, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody notifMsg; _jparser.validateByNameThrow("notifMsg", notifMsg);
	AtfValidator::validateInt(_descr, "notifMsg", notifMsg._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 notifType; _parser.parseUINT32(notifType);
	AtfValidator::validateInt(_descr, "notifType", notifType, _checker, __FILE__, __LINE__);
	size_t szNotifMsg; _parser.skipMsgBody(szNotifMsg);  /*notifMsg*/
	AtfValidator::validateInt(_descr, "notifMsg", szNotifMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT(Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT&& _o)
	: startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, reportFormat(std::move(_o.reportFormat))
	, password(std::move(_o.password))
	, isHtmlForClient(std::move(_o.isHtmlForClient))
{
}

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT& LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::operator=(Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT&& _o)
{
	if(this != &_o)
	{
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		reportFormat = std::move(_o.reportFormat);
		password = std::move(_o.password);
		isHtmlForClient = std::move(_o.isHtmlForClient);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::clear()
{
	startDate.setNull();
	endDate.setNull();
	reportFormat = 0;
	password.clear();
	isHtmlForClient = false;
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::equals(const Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT& _o) const
{
	return startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		reportFormat == _o.reportFormat &&
		Atf::atfPStringEquals(password, _o.password) &&
		isHtmlForClient == _o.isHtmlForClient;
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT).append(")");
	_buf.append(',');
	_buf.append("startDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
	_buf.append(',');
	_buf.append("endDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	_buf.append(',');
	_buf.append("reportFormat=");
	_buf.appendUint(reportFormat);
	_buf.append(',');
	_buf.append("password=");
	_buf.append("...");
	_buf.append(',');
	_buf.append("isHtmlForClient=");
	_buf.appendUint(isHtmlForClient);
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "startDate", startDate);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
	Atf::XmlElement::encodeAsXmlElement("reportFormat", reportFormat, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHtmlForClient", isHtmlForClient, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("startDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, startDate);
			}
			else if (_element.equals("endDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
			}
			else if (_element.equals("reportFormat"))
			{
				reportFormat = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("isHtmlForClient"))
			{
				isHtmlForClient = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvDate(startDate);
	_msg.composeSrvDate(endDate);
	_msg.composeBYTE(reportFormat);
	_msg.composeString(password);
	_msg.composeBOOL(isHtmlForClient);
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvDate(startDate);
	_parser.parseSrvDate(endDate);
	_parser.parseBYTE(reportFormat);
	_parser.parseStringP(password);
	_parser.parseBOOL(isHtmlForClient);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("startDate", startDate);
	_jsonstr.compose("endDate", endDate);
	_jsonstr.compose("reportFormat", reportFormat);
	_jsonstr.compose("password", password);
	_jsonstr.compose("isHtmlForClient", isHtmlForClient);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("startDate", startDate);
	_jparser.parseByNameThrow("endDate", endDate);
	_jparser.parseByNameThrow("reportFormat", reportFormat);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("isHtmlForClient", isHtmlForClient);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvDate startDate; _jparser.validateByNameThrow("startDate", startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	BYTE reportFormat; _jparser.validateByNameThrow("reportFormat", reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _jparser.validateByNameThrow("isHtmlForClient", isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	SrvDate startDate; _parser.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	BYTE reportFormat; _parser.parseBYTE(reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _parser.parseBOOL(isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY(Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY& LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errString);
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errString);
	}
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION
//=================================================================

LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION()
{
	clear();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::clear()
{
	boldChatType = 0;
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::equals(const Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION& _o) const
{
	return boldChatType == _o.boldChatType;
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION*)_other));
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION).append(")");
	_buf.append(',');
	_buf.append("boldChatType=");
	_buf.appendUint(boldChatType);
	return _buf.c_str();
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("boldChatType", boldChatType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("boldChatType"))
			{
				boldChatType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(boldChatType);
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(boldChatType);
}

const char *LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("boldChatType", boldChatType);
	return _buf.c_str();
}

void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("boldChatType", boldChatType);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE boldChatType; _jparser.validateByNameThrow("boldChatType", boldChatType);
	AtfValidator::validateInt(_descr, "boldChatType", boldChatType, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE boldChatType; _parser.parseBYTE(boldChatType);
	AtfValidator::validateInt(_descr, "boldChatType", boldChatType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Attributes
//=================================================================

LobbyEtcClient::MiniGameTickets::Attributes::Attributes()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::Attributes::Attributes(Attributes&& _o)
	: gameTicketName(std::move(_o.gameTicketName))
	, minigameId(std::move(_o.minigameId))
	, expiration(std::move(_o.expiration))
	, userPreferredTimeZone(std::move(_o.userPreferredTimeZone))
	, playsAvailable(std::move(_o.playsAvailable))
	, minigameType(std::move(_o.minigameType))
	, ticketTypeId(std::move(_o.ticketTypeId))
	, ticketId(std::move(_o.ticketId))
{
}

LobbyEtcClient::MiniGameTickets::Attributes& LobbyEtcClient::MiniGameTickets::Attributes::operator=(Attributes&& _o)
{
	if(this != &_o)
	{
		gameTicketName = std::move(_o.gameTicketName);
		minigameId = std::move(_o.minigameId);
		expiration = std::move(_o.expiration);
		userPreferredTimeZone = std::move(_o.userPreferredTimeZone);
		playsAvailable = std::move(_o.playsAvailable);
		minigameType = std::move(_o.minigameType);
		ticketTypeId = std::move(_o.ticketTypeId);
		ticketId = std::move(_o.ticketId);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::Attributes::clear()
{
	gameTicketName.clear();
	minigameId = 0;
	expiration.setNull();
	userPreferredTimeZone = 0;
	playsAvailable = 0;
	minigameType = 0;
	ticketTypeId = 0;
	ticketId = 0;
}

bool LobbyEtcClient::MiniGameTickets::Attributes::equals(const Attributes& _o) const
{
	return Atf::atfPStringEquals(gameTicketName, _o.gameTicketName) &&
		minigameId == _o.minigameId &&
		expiration.equals(_o.expiration) &&
		userPreferredTimeZone == _o.userPreferredTimeZone &&
		playsAvailable == _o.playsAvailable &&
		minigameType == _o.minigameType &&
		ticketTypeId == _o.ticketTypeId &&
		ticketId == _o.ticketId;
}

const char *LobbyEtcClient::MiniGameTickets::Attributes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameTicketName=");
	_buf.append(gameTicketName);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("expiration=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, expiration);
	_buf.append(',');
	_buf.append("userPreferredTimeZone=");
	_buf.appendInt(userPreferredTimeZone);
	_buf.append(',');
	_buf.append("playsAvailable=");
	_buf.appendInt(playsAvailable);
	_buf.append(',');
	_buf.append("minigameType=");
	_buf.appendUint(minigameType);
	_buf.append(',');
	_buf.append("ticketTypeId=");
	_buf.appendUint(ticketTypeId);
	_buf.append(',');
	_buf.append("ticketId=");
	_buf.appendUint64(ticketId);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::Attributes::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameTicketName", gameTicketName, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "expiration", expiration);
	Atf::XmlElement::encodeAsXmlElement("userPreferredTimeZone", userPreferredTimeZone, _buf);
	Atf::XmlElement::encodeAsXmlElement("playsAvailable", playsAvailable, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameType", minigameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketTypeId", ticketTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::Attributes::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameTicketName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, gameTicketName)) return false;
		}
		else if (_element.equals("minigameId"))
		{
			minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("expiration"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, expiration);
		}
		else if (_element.equals("userPreferredTimeZone"))
		{
			userPreferredTimeZone = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playsAvailable"))
		{
			playsAvailable = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameType"))
		{
			minigameType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketTypeId"))
		{
			ticketTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketId"))
		{
			ticketId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::Attributes::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Attributes())) // not empty
	{
		_body.composeString(gameTicketName);
		_body.composeUINT32(minigameId);
		_body.composeSrvTime(expiration);
		_body.composeINT32(userPreferredTimeZone);
		_body.composeINT32(playsAvailable);
		_body.composeUINT32(minigameType);
		_body.composeUINT32(ticketTypeId);
		_body.composeUINT64(ticketId);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::Attributes::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(gameTicketName);
	_parser0.parseUINT32(minigameId);
	_parser0.parseSrvTime(expiration);
	_parser0.parseINT32(userPreferredTimeZone);
	_parser0.parseINT32(playsAvailable);
	_parser0.parseUINT32(minigameType);
	_parser0.parseUINT32(ticketTypeId);
	_parser0.parseUINT64(ticketId);
}

const char *LobbyEtcClient::MiniGameTickets::Attributes::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameTicketName", gameTicketName);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("expiration", expiration);
	_jsonstr.compose("userPreferredTimeZone", userPreferredTimeZone);
	_jsonstr.compose("playsAvailable", playsAvailable);
	_jsonstr.compose("minigameType", minigameType);
	_jsonstr.compose("ticketTypeId", ticketTypeId);
	_jsonstr.compose("ticketId", ticketId);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::Attributes::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameTicketName", gameTicketName);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("expiration", expiration);
	_jparser.parseByNameThrow("userPreferredTimeZone", userPreferredTimeZone);
	_jparser.parseByNameThrow("playsAvailable", playsAvailable);
	_jparser.parseByNameThrow("minigameType", minigameType);
	_jparser.parseByNameThrow("ticketTypeId", ticketTypeId);
	_jparser.parseByNameThrow("ticketId", ticketId);
}

/* static */ void LobbyEtcClient::MiniGameTickets::Attributes::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString gameTicketName; _jparser.validateByNameThrow("gameTicketName", gameTicketName);
	AtfValidator::validateInt(_descr, "gameTicketName", gameTicketName.length(), _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	SrvTime expiration; _jparser.validateByNameThrow("expiration", expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	INT32 userPreferredTimeZone; _jparser.validateByNameThrow("userPreferredTimeZone", userPreferredTimeZone);
	AtfValidator::validateInt(_descr, "userPreferredTimeZone", userPreferredTimeZone, _checker, __FILE__, __LINE__);
	INT32 playsAvailable; _jparser.validateByNameThrow("playsAvailable", playsAvailable);
	AtfValidator::validateInt(_descr, "playsAvailable", playsAvailable, _checker, __FILE__, __LINE__);
	UINT32 minigameType; _jparser.validateByNameThrow("minigameType", minigameType);
	AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeId; _jparser.validateByNameThrow("ticketTypeId", ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	UINT64 ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateUint(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Attributes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "gameTicketName"); size_t szGameTicketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "gameTicketName", szGameTicketName, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	SrvTime expiration; _parser0.parseSrvTime(expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	INT32 userPreferredTimeZone; _parser0.parseINT32(userPreferredTimeZone);
	AtfValidator::validateInt(_descr, "userPreferredTimeZone", userPreferredTimeZone, _checker, __FILE__, __LINE__);
	INT32 playsAvailable; _parser0.parseINT32(playsAvailable);
	AtfValidator::validateInt(_descr, "playsAvailable", playsAvailable, _checker, __FILE__, __LINE__);
	UINT32 minigameType; _parser0.parseUINT32(minigameType);
	AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeId; _parser0.parseUINT32(ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	UINT64 ticketId; _parser0.parseUINT64(ticketId);
	AtfValidator::validateUint(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameTicketNotifMsg
//=================================================================

LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::GameTicketNotifMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::GameTicketNotifMsg(GameTicketNotifMsg&& _o)
	: type(std::move(_o.type))
	, description(std::move(_o.description))
	, moreInfo(std::move(_o.moreInfo))
	, headerImageURL(std::move(_o.headerImageURL))
	, attributes(std::move(_o.attributes))
{
}

LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg& LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::operator=(GameTicketNotifMsg&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		description = std::move(_o.description);
		moreInfo = std::move(_o.moreInfo);
		headerImageURL = std::move(_o.headerImageURL);
		attributes = std::move(_o.attributes);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::clear()
{
	type = "MiniGameTicket";
	description.clear();
	moreInfo.clear();
	headerImageURL.clear();
	attributes.clear();
}

bool LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::equals(const GameTicketNotifMsg& _o) const
{
	return Atf::atfPStringEquals(type, _o.type) &&
		Atf::atfPStringEquals(description, _o.description) &&
		Atf::atfPStringEquals(moreInfo, _o.moreInfo) &&
		Atf::atfPStringEquals(headerImageURL, _o.headerImageURL) &&
		attributes.equals(_o.attributes);
}

const char *LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.append(type);
	_buf.append(',');
	_buf.append("description=");
	_buf.append(description);
	_buf.append(',');
	_buf.append("moreInfo=");
	_buf.append(moreInfo);
	_buf.append(',');
	_buf.append("headerImageURL=");
	_buf.append(headerImageURL);
	_buf.append(',');
	_buf.append("attributes=");
	attributes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("description", description, _buf);
	Atf::XmlElement::encodeAsXmlElement("moreInfo", moreInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("headerImageURL", headerImageURL, _buf);
	attributes.toXmlString("attributes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, type)) return false;
		}
		else if (_element.equals("description"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, description)) return false;
		}
		else if (_element.equals("moreInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, moreInfo)) return false;
		}
		else if (_element.equals("headerImageURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, headerImageURL)) return false;
		}
		else if (_element.equals("attributes"))
		{
			if(!Atf::AtfTempl< Attributes >::FromXmlString(_value, attributes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(GameTicketNotifMsg())) // not empty
	{
		_body.composeString(type);
		_body.composeString(description);
		_body.composeString(moreInfo);
		_body.composeString(headerImageURL);
		attributes.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(type);
	_parser0.parseStringP(description);
	_parser0.parseStringP(moreInfo);
	_parser0.parseStringP(headerImageURL);
	attributes.parseMsg(_parser0);
}

const char *LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("description", description);
	_jsonstr.compose("moreInfo", moreInfo);
	_jsonstr.compose("headerImageURL", headerImageURL);
	_jsonstr.compose("attributes", attributes);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("description", description);
	_jparser.parseByNameThrow("moreInfo", moreInfo);
	_jparser.parseByNameThrow("headerImageURL", headerImageURL);
	_jparser.parseByNameThrow("attributes", attributes);
}

/* static */ void LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type.length(), _checker, __FILE__, __LINE__);
	PString description; _jparser.validateByNameThrow("description", description);
	AtfValidator::validateInt(_descr, "description", description.length(), _checker, __FILE__, __LINE__);
	PString moreInfo; _jparser.validateByNameThrow("moreInfo", moreInfo);
	AtfValidator::validateInt(_descr, "moreInfo", moreInfo.length(), _checker, __FILE__, __LINE__);
	PString headerImageURL; _jparser.validateByNameThrow("headerImageURL", headerImageURL);
	AtfValidator::validateInt(_descr, "headerImageURL", headerImageURL.length(), _checker, __FILE__, __LINE__);
	Attributes attributes; _jparser.validateByNameThrow("attributes", attributes);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::GameTicketNotifMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "type"); size_t szType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "type", szType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "description"); size_t szDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "description", szDescription, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "moreInfo"); size_t szMoreInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "moreInfo", szMoreInfo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "headerImageURL"); size_t szHeaderImageURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "headerImageURL", szHeaderImageURL, _checker, __FILE__, __LINE__);
	PString _descbuf;
	Attributes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("attributes"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameTicketWithTypeAndMiniGameData
//=================================================================

LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::GameTicketWithTypeAndMiniGameData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::GameTicketWithTypeAndMiniGameData(GameTicketWithTypeAndMiniGameData&& _o)
	: gameTicketId(std::move(_o.gameTicketId))
	, gameTicketTypeId(std::move(_o.gameTicketTypeId))
	, whenStarted(std::move(_o.whenStarted))
	, expiration(std::move(_o.expiration))
	, playsInitial(std::move(_o.playsInitial))
	, playsSpent(std::move(_o.playsSpent))
	, gameTicketBrandMask(std::move(_o.gameTicketBrandMask))
	, minigameId(std::move(_o.minigameId))
	, minigameType(std::move(_o.minigameType))
	, minigameClientDisplayName(std::move(_o.minigameClientDisplayName))
	, minigameClientDisplayInfo(std::move(_o.minigameClientDisplayInfo))
	, minigameBrandMask(std::move(_o.minigameBrandMask))
	, minigameSiteMask(std::move(_o.minigameSiteMask))
	, status(std::move(_o.status))
	, costFpp1(std::move(_o.costFpp1))
	, minigameSiteMaskEx(std::move(_o.minigameSiteMaskEx))
	, moreInfo(std::move(_o.moreInfo))
	, headerImageURL(std::move(_o.headerImageURL))
{
}

LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData& LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::operator=(GameTicketWithTypeAndMiniGameData&& _o)
{
	if(this != &_o)
	{
		gameTicketId = std::move(_o.gameTicketId);
		gameTicketTypeId = std::move(_o.gameTicketTypeId);
		whenStarted = std::move(_o.whenStarted);
		expiration = std::move(_o.expiration);
		playsInitial = std::move(_o.playsInitial);
		playsSpent = std::move(_o.playsSpent);
		gameTicketBrandMask = std::move(_o.gameTicketBrandMask);
		minigameId = std::move(_o.minigameId);
		minigameType = std::move(_o.minigameType);
		minigameClientDisplayName = std::move(_o.minigameClientDisplayName);
		minigameClientDisplayInfo = std::move(_o.minigameClientDisplayInfo);
		minigameBrandMask = std::move(_o.minigameBrandMask);
		minigameSiteMask = std::move(_o.minigameSiteMask);
		status = std::move(_o.status);
		costFpp1 = std::move(_o.costFpp1);
		minigameSiteMaskEx = std::move(_o.minigameSiteMaskEx);
		moreInfo = std::move(_o.moreInfo);
		headerImageURL = std::move(_o.headerImageURL);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::clear()
{
	gameTicketId = 0;
	gameTicketTypeId = 0;
	whenStarted.setNull();
	expiration.setNull();
	playsInitial = 0;
	playsSpent = 0;
	gameTicketBrandMask = 0;
	minigameId = 0;
	minigameType = 0;
	minigameClientDisplayName.clear();
	minigameClientDisplayInfo.clear();
	minigameBrandMask = 0;
	minigameSiteMask = 0;
	status = 0;
	costFpp1 = 0;
	minigameSiteMaskEx.clear();
	moreInfo.clear();
	headerImageURL.clear();
}

bool LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::equals(const GameTicketWithTypeAndMiniGameData& _o) const
{
	return gameTicketId == _o.gameTicketId &&
		gameTicketTypeId == _o.gameTicketTypeId &&
		whenStarted.equals(_o.whenStarted) &&
		expiration.equals(_o.expiration) &&
		playsInitial == _o.playsInitial &&
		playsSpent == _o.playsSpent &&
		gameTicketBrandMask == _o.gameTicketBrandMask &&
		minigameId == _o.minigameId &&
		minigameType == _o.minigameType &&
		Atf::atfPStringEquals(minigameClientDisplayName, _o.minigameClientDisplayName) &&
		Atf::atfPStringEquals(minigameClientDisplayInfo, _o.minigameClientDisplayInfo) &&
		minigameBrandMask == _o.minigameBrandMask &&
		minigameSiteMask == _o.minigameSiteMask &&
		status == _o.status &&
		costFpp1 == _o.costFpp1 &&
		minigameSiteMaskEx.equals(_o.minigameSiteMaskEx) &&
		Atf::atfPStringEquals(moreInfo, _o.moreInfo) &&
		Atf::atfPStringEquals(headerImageURL, _o.headerImageURL);
}

const char *LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint(gameTicketTypeId);
	_buf.append(',');
	_buf.append("whenStarted=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStarted);
	_buf.append(',');
	_buf.append("expiration=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, expiration);
	_buf.append(',');
	_buf.append("playsInitial=");
	_buf.appendInt(playsInitial);
	_buf.append(',');
	_buf.append("playsSpent=");
	_buf.appendInt(playsSpent);
	_buf.append(',');
	_buf.append("gameTicketBrandMask=");
	_buf.appendUint(gameTicketBrandMask);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("minigameType=");
	_buf.appendUint(minigameType);
	_buf.append(',');
	_buf.append("minigameClientDisplayName=");
	_buf.append(minigameClientDisplayName);
	_buf.append(',');
	_buf.append("minigameClientDisplayInfo=");
	_buf.append(minigameClientDisplayInfo);
	_buf.append(',');
	_buf.append("minigameBrandMask=");
	_buf.appendUint(minigameBrandMask);
	_buf.append(',');
	_buf.append("minigameSiteMask=");
	_buf.appendUint(minigameSiteMask);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("costFpp1=");
	_buf.appendInt(costFpp1);
	_buf.append(',');
	_buf.append("minigameSiteMaskEx=");
	minigameSiteMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("moreInfo=");
	_buf.append(moreInfo);
	_buf.append(',');
	_buf.append("headerImageURL=");
	_buf.append(headerImageURL);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameTicketId", gameTicketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTicketTypeId", gameTicketTypeId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStarted", whenStarted);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "expiration", expiration);
	Atf::XmlElement::encodeAsXmlElement("playsInitial", playsInitial, _buf);
	Atf::XmlElement::encodeAsXmlElement("playsSpent", playsSpent, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTicketBrandMask", gameTicketBrandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameType", minigameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameClientDisplayName", minigameClientDisplayName, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameClientDisplayInfo", minigameClientDisplayInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameBrandMask", minigameBrandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameSiteMask", minigameSiteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("costFpp1", costFpp1, _buf);
	minigameSiteMaskEx.toXmlString("minigameSiteMaskEx", _buf);
	Atf::XmlElement::encodeAsXmlElement("moreInfo", moreInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("headerImageURL", headerImageURL, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameTicketId"))
		{
			gameTicketId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameTicketTypeId"))
		{
			gameTicketTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenStarted"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStarted);
		}
		else if (_element.equals("expiration"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, expiration);
		}
		else if (_element.equals("playsInitial"))
		{
			playsInitial = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playsSpent"))
		{
			playsSpent = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameTicketBrandMask"))
		{
			gameTicketBrandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameId"))
		{
			minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameType"))
		{
			minigameType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameClientDisplayName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, minigameClientDisplayName)) return false;
		}
		else if (_element.equals("minigameClientDisplayInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, minigameClientDisplayInfo)) return false;
		}
		else if (_element.equals("minigameBrandMask"))
		{
			minigameBrandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameSiteMask"))
		{
			minigameSiteMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("costFpp1"))
		{
			costFpp1 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameSiteMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, minigameSiteMaskEx)) return false;
		}
		else if (_element.equals("moreInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, moreInfo)) return false;
		}
		else if (_element.equals("headerImageURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, headerImageURL)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(GameTicketWithTypeAndMiniGameData())) // not empty
	{
		_body.composeUINT64(gameTicketId);
		_body.composeUINT32(gameTicketTypeId);
		_body.composeSrvTime(whenStarted);
		_body.composeSrvTime(expiration);
		_body.composeINT32(playsInitial);
		_body.composeINT32(playsSpent);
		_body.composeUINT32(gameTicketBrandMask);
		_body.composeUINT32(minigameId);
		_body.composeUINT32(minigameType);
		_body.composeString(minigameClientDisplayName);
		_body.composeString(minigameClientDisplayInfo);
		_body.composeUINT32(minigameBrandMask);
		_body.composeUINT32(minigameSiteMask);
		_body.composeINT32(status);
		_body.composeINT32(costFpp1);
		minigameSiteMaskEx.composeMsg(_body, _ignoreJSON);
		_body.composeString(moreInfo);
		_body.composeString(headerImageURL);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameTicketId);
	_parser0.parseUINT32(gameTicketTypeId);
	_parser0.parseSrvTime(whenStarted);
	_parser0.parseSrvTime(expiration);
	_parser0.parseINT32(playsInitial);
	_parser0.parseINT32(playsSpent);
	_parser0.parseUINT32(gameTicketBrandMask);
	_parser0.parseUINT32(minigameId);
	_parser0.parseUINT32(minigameType);
	_parser0.parseStringP(minigameClientDisplayName);
	_parser0.parseStringP(minigameClientDisplayInfo);
	_parser0.parseUINT32(minigameBrandMask);
	_parser0.parseUINT32(minigameSiteMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(status);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(costFpp1);
	if(_parser0.parseEnded()) return;
	minigameSiteMaskEx.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(moreInfo);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(headerImageURL);
}

const char *LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameTicketId", gameTicketId);
	_jsonstr.compose("gameTicketTypeId", gameTicketTypeId);
	_jsonstr.compose("whenStarted", whenStarted);
	_jsonstr.compose("expiration", expiration);
	_jsonstr.compose("playsInitial", playsInitial);
	_jsonstr.compose("playsSpent", playsSpent);
	_jsonstr.compose("gameTicketBrandMask", gameTicketBrandMask);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("minigameType", minigameType);
	_jsonstr.compose("minigameClientDisplayName", minigameClientDisplayName);
	_jsonstr.compose("minigameClientDisplayInfo", minigameClientDisplayInfo);
	_jsonstr.compose("minigameBrandMask", minigameBrandMask);
	_jsonstr.compose("minigameSiteMask", minigameSiteMask);
	_jsonstr.compose("status", status);
	_jsonstr.compose("costFpp1", costFpp1);
	_jsonstr.compose("minigameSiteMaskEx", minigameSiteMaskEx);
	_jsonstr.compose("moreInfo", moreInfo);
	_jsonstr.compose("headerImageURL", headerImageURL);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameTicketId", gameTicketId);
	_jparser.parseByNameThrow("gameTicketTypeId", gameTicketTypeId);
	_jparser.parseByNameThrow("whenStarted", whenStarted);
	_jparser.parseByNameThrow("expiration", expiration);
	_jparser.parseByNameThrow("playsInitial", playsInitial);
	_jparser.parseByNameThrow("playsSpent", playsSpent);
	_jparser.parseByNameThrow("gameTicketBrandMask", gameTicketBrandMask);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("minigameType", minigameType);
	_jparser.parseByNameThrow("minigameClientDisplayName", minigameClientDisplayName);
	_jparser.parseByNameThrow("minigameClientDisplayInfo", minigameClientDisplayInfo);
	_jparser.parseByNameThrow("minigameBrandMask", minigameBrandMask);
	_jparser.parseByNameThrow("minigameSiteMask", minigameSiteMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("status", status);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("costFpp1", costFpp1);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("minigameSiteMaskEx", minigameSiteMaskEx);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("moreInfo", moreInfo);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("headerImageURL", headerImageURL);
}

/* static */ void LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 gameTicketId; _jparser.validateByNameThrow("gameTicketId", gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	UINT32 gameTicketTypeId; _jparser.validateByNameThrow("gameTicketTypeId", gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	SrvTime whenStarted; _jparser.validateByNameThrow("whenStarted", whenStarted);
	AtfValidator::validateSrvDateTime(_descr, "whenStarted", whenStarted, _checker, __FILE__, __LINE__);
	SrvTime expiration; _jparser.validateByNameThrow("expiration", expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	INT32 playsInitial; _jparser.validateByNameThrow("playsInitial", playsInitial);
	AtfValidator::validateInt(_descr, "playsInitial", playsInitial, _checker, __FILE__, __LINE__);
	INT32 playsSpent; _jparser.validateByNameThrow("playsSpent", playsSpent);
	AtfValidator::validateInt(_descr, "playsSpent", playsSpent, _checker, __FILE__, __LINE__);
	UINT32 gameTicketBrandMask; _jparser.validateByNameThrow("gameTicketBrandMask", gameTicketBrandMask);
	AtfValidator::validateInt(_descr, "gameTicketBrandMask", gameTicketBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT32 minigameType; _jparser.validateByNameThrow("minigameType", minigameType);
	AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
	PString minigameClientDisplayName; _jparser.validateByNameThrow("minigameClientDisplayName", minigameClientDisplayName);
	AtfValidator::validateInt(_descr, "minigameClientDisplayName", minigameClientDisplayName.length(), _checker, __FILE__, __LINE__);
	PString minigameClientDisplayInfo; _jparser.validateByNameThrow("minigameClientDisplayInfo", minigameClientDisplayInfo);
	AtfValidator::validateInt(_descr, "minigameClientDisplayInfo", minigameClientDisplayInfo.length(), _checker, __FILE__, __LINE__);
	UINT32 minigameBrandMask; _jparser.validateByNameThrow("minigameBrandMask", minigameBrandMask);
	AtfValidator::validateInt(_descr, "minigameBrandMask", minigameBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameSiteMask; _jparser.validateByNameThrow("minigameSiteMask", minigameSiteMask);
	AtfValidator::validateInt(_descr, "minigameSiteMask", minigameSiteMask, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 costFpp1; _jparser.validateByNameThrow("costFpp1", costFpp1);
	AtfValidator::validateInt(_descr, "costFpp1", costFpp1, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask minigameSiteMaskEx; _jparser.validateByNameThrow("minigameSiteMaskEx", minigameSiteMaskEx);
	if(_jparser.parseEnded()) return;
	PString moreInfo; _jparser.validateByNameThrow("moreInfo", moreInfo);
	AtfValidator::validateInt(_descr, "moreInfo", moreInfo.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString headerImageURL; _jparser.validateByNameThrow("headerImageURL", headerImageURL);
	AtfValidator::validateInt(_descr, "headerImageURL", headerImageURL.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::GameTicketWithTypeAndMiniGameData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 gameTicketId; _parser0.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	UINT32 gameTicketTypeId; _parser0.parseUINT32(gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	SrvTime whenStarted; _parser0.parseSrvTime(whenStarted);
	AtfValidator::validateSrvDateTime(_descr, "whenStarted", whenStarted, _checker, __FILE__, __LINE__);
	SrvTime expiration; _parser0.parseSrvTime(expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	INT32 playsInitial; _parser0.parseINT32(playsInitial);
	AtfValidator::validateInt(_descr, "playsInitial", playsInitial, _checker, __FILE__, __LINE__);
	INT32 playsSpent; _parser0.parseINT32(playsSpent);
	AtfValidator::validateInt(_descr, "playsSpent", playsSpent, _checker, __FILE__, __LINE__);
	UINT32 gameTicketBrandMask; _parser0.parseUINT32(gameTicketBrandMask);
	AtfValidator::validateInt(_descr, "gameTicketBrandMask", gameTicketBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT32 minigameType; _parser0.parseUINT32(minigameType);
	AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "minigameClientDisplayName"); size_t szMinigameClientDisplayName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "minigameClientDisplayName", szMinigameClientDisplayName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "minigameClientDisplayInfo"); size_t szMinigameClientDisplayInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "minigameClientDisplayInfo", szMinigameClientDisplayInfo, _checker, __FILE__, __LINE__);
	UINT32 minigameBrandMask; _parser0.parseUINT32(minigameBrandMask);
	AtfValidator::validateInt(_descr, "minigameBrandMask", minigameBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameSiteMask; _parser0.parseUINT32(minigameSiteMask);
	AtfValidator::validateInt(_descr, "minigameSiteMask", minigameSiteMask, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 status; _parser0.parseINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 costFpp1; _parser0.parseINT32(costFpp1);
	AtfValidator::validateInt(_descr, "costFpp1", costFpp1, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("minigameSiteMaskEx"), _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "moreInfo"); size_t szMoreInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "moreInfo", szMoreInfo, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "headerImageURL"); size_t szHeaderImageURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "headerImageURL", szHeaderImageURL, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE
//=================================================================

LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE()
{
	clear();
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::clear()
{
	requestId = 0;
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::equals(const Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE& _o) const
{
	return requestId == _o.requestId;
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_TICKETS_WITH_TYPE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE*)_other));
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_TICKETS_WITH_TYPE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_TICKETS_WITH_TYPE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_TICKETS_WITH_TYPE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_TICKETS_WITH_TYPE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY
//=================================================================

LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY(Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, ticketsWithMinigames(std::move(_o.ticketsWithMinigames))
{
}

LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY& LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		ticketsWithMinigames = std::move(_o.ticketsWithMinigames);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	ticketsWithMinigames.clear();
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		ticketsWithMinigames.equals(_o.ticketsWithMinigames);
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY*)_other));
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("ticketsWithMinigames=");
		ticketsWithMinigames.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		ticketsWithMinigames.toXmlString("ticketsWithMinigames", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("ticketsWithMinigames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameTicketWithTypeAndMiniGameData , 4 > >::FromXmlString(_value, ticketsWithMinigames)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		ticketsWithMinigames.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		ticketsWithMinigames.parseMsg(_parser);
	}
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("ticketsWithMinigames", ticketsWithMinigames);
	}
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("ticketsWithMinigames", ticketsWithMinigames);
	}
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< GameTicketWithTypeAndMiniGameData > ticketsWithMinigames; _jparser.validateByNameThrow("ticketsWithMinigames", ticketsWithMinigames);
		AtfValidator::validateInt(_descr, "ticketsWithMinigames", ticketsWithMinigames.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTicketsWithMinigames = Atf::LAtfVector< GameTicketWithTypeAndMiniGameData , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketsWithMinigames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ticketsWithMinigames", szTicketsWithMinigames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Prize
//=================================================================

// @Override
LobbyEtcClient::MiniGameTickets::Prize::Prize(const PString& imageURL_, const PString& prizeName_, const INT32& prizeType_,  const PString& launchURL_)
{
	imageURL = imageURL_;		
	prizeName = prizeName_;		
	prizeType = prizeType_;	
	launchURL = launchURL_;		
}

LobbyEtcClient::MiniGameTickets::Prize::Prize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::Prize::Prize(Prize&& _o)
	: imageURL(std::move(_o.imageURL))
	, prizeName(std::move(_o.prizeName))
	, prizeType(std::move(_o.prizeType))
	, launchURL(std::move(_o.launchURL))
{
}

LobbyEtcClient::MiniGameTickets::Prize& LobbyEtcClient::MiniGameTickets::Prize::operator=(Prize&& _o)
{
	if(this != &_o)
	{
		imageURL = std::move(_o.imageURL);
		prizeName = std::move(_o.prizeName);
		prizeType = std::move(_o.prizeType);
		launchURL = std::move(_o.launchURL);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::Prize::clear()
{
	imageURL.clear();
	prizeName.clear();
	prizeType = 0;
	launchURL.clear();
}

bool LobbyEtcClient::MiniGameTickets::Prize::equals(const Prize& _o) const
{
	return Atf::atfPStringEquals(imageURL, _o.imageURL) &&
		Atf::atfPStringEquals(prizeName, _o.prizeName) &&
		prizeType == _o.prizeType &&
		Atf::atfPStringEquals(launchURL, _o.launchURL);
}

const char *LobbyEtcClient::MiniGameTickets::Prize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("imageURL=");
	_buf.append(imageURL);
	_buf.append(',');
	_buf.append("prizeName=");
	_buf.append(prizeName);
	_buf.append(',');
	_buf.append("prizeType=");
	_buf.appendInt(prizeType);
	_buf.append(',');
	_buf.append("launchURL=");
	_buf.append(launchURL);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::Prize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("imageURL", imageURL, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizeName", prizeName, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizeType", prizeType, _buf);
	Atf::XmlElement::encodeAsXmlElement("launchURL", launchURL, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::Prize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("imageURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, imageURL)) return false;
		}
		else if (_element.equals("prizeName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, prizeName)) return false;
		}
		else if (_element.equals("prizeType"))
		{
			prizeType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("launchURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, launchURL)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::Prize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Prize())) // not empty
	{
		_body.composeString(imageURL);
		_body.composeString(prizeName);
		_body.composeINT32(prizeType);
		_body.composeString(launchURL);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::Prize::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(imageURL);
	_parser0.parseStringP(prizeName);
	_parser0.parseINT32(prizeType);
	_parser0.parseStringP(launchURL);
}

const char *LobbyEtcClient::MiniGameTickets::Prize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("imageURL", imageURL);
	_jsonstr.compose("prizeName", prizeName);
	_jsonstr.compose("prizeType", prizeType);
	_jsonstr.compose("launchURL", launchURL);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::Prize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("imageURL", imageURL);
	_jparser.parseByNameThrow("prizeName", prizeName);
	_jparser.parseByNameThrow("prizeType", prizeType);
	_jparser.parseByNameThrow("launchURL", launchURL);
}

/* static */ void LobbyEtcClient::MiniGameTickets::Prize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString imageURL; _jparser.validateByNameThrow("imageURL", imageURL);
	AtfValidator::validateInt(_descr, "imageURL", imageURL.length(), _checker, __FILE__, __LINE__);
	PString prizeName; _jparser.validateByNameThrow("prizeName", prizeName);
	AtfValidator::validateInt(_descr, "prizeName", prizeName.length(), _checker, __FILE__, __LINE__);
	INT32 prizeType; _jparser.validateByNameThrow("prizeType", prizeType);
	AtfValidator::validateInt(_descr, "prizeType", prizeType, _checker, __FILE__, __LINE__);
	PString launchURL; _jparser.validateByNameThrow("launchURL", launchURL);
	AtfValidator::validateInt(_descr, "launchURL", launchURL.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Prize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "imageURL"); size_t szImageURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "imageURL", szImageURL, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "prizeName"); size_t szPrizeName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "prizeName", szPrizeName, _checker, __FILE__, __LINE__);
	INT32 prizeType; _parser0.parseINT32(prizeType);
	AtfValidator::validateInt(_descr, "prizeType", prizeType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "launchURL"); size_t szLaunchURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "launchURL", szLaunchURL, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    Winner
//=================================================================

// @Override
LobbyEtcClient::MiniGameTickets::Winner::Winner(const PString& prizeTitle_, const PString& playerId_)
{
	prizeTitle = prizeTitle_;		
	playerId = playerId_;
}

LobbyEtcClient::MiniGameTickets::Winner::Winner()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::Winner::Winner(Winner&& _o)
	: prizeTitle(std::move(_o.prizeTitle))
	, playerId(std::move(_o.playerId))
{
}

LobbyEtcClient::MiniGameTickets::Winner& LobbyEtcClient::MiniGameTickets::Winner::operator=(Winner&& _o)
{
	if(this != &_o)
	{
		prizeTitle = std::move(_o.prizeTitle);
		playerId = std::move(_o.playerId);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::Winner::clear()
{
	prizeTitle.clear();
	playerId.clear();
}

bool LobbyEtcClient::MiniGameTickets::Winner::equals(const Winner& _o) const
{
	return Atf::atfPStringEquals(prizeTitle, _o.prizeTitle) &&
		Atf::atfPStringEquals(playerId, _o.playerId);
}

const char *LobbyEtcClient::MiniGameTickets::Winner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeTitle=");
	_buf.append(prizeTitle);
	_buf.append(',');
	_buf.append("playerId=");
	_buf.append(playerId);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::Winner::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("prizeTitle", prizeTitle, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerId", playerId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::Winner::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prizeTitle"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, prizeTitle)) return false;
		}
		else if (_element.equals("playerId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, playerId)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::Winner::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Winner())) // not empty
	{
		_body.composeString(prizeTitle);
		_body.composeString(playerId);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::Winner::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(prizeTitle);
	_parser0.parseStringP(playerId);
}

const char *LobbyEtcClient::MiniGameTickets::Winner::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prizeTitle", prizeTitle);
	_jsonstr.compose("playerId", playerId);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::Winner::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prizeTitle", prizeTitle);
	_jparser.parseByNameThrow("playerId", playerId);
}

/* static */ void LobbyEtcClient::MiniGameTickets::Winner::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString prizeTitle; _jparser.validateByNameThrow("prizeTitle", prizeTitle);
	AtfValidator::validateInt(_descr, "prizeTitle", prizeTitle.length(), _checker, __FILE__, __LINE__);
	PString playerId; _jparser.validateByNameThrow("playerId", playerId);
	AtfValidator::validateInt(_descr, "playerId", playerId.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Winner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "prizeTitle"); size_t szPrizeTitle = strlen(_dummy);
	AtfValidator::validateInt(_descr, "prizeTitle", szPrizeTitle, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "playerId"); size_t szPlayerId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "playerId", szPlayerId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FixedPrizeWonAttributes
//=================================================================

LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::FixedPrizeWonAttributes()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::FixedPrizeWonAttributes(FixedPrizeWonAttributes&& _o)
	: numPrizes(std::move(_o.numPrizes))
	, numWinners(std::move(_o.numWinners))
	, draw(std::move(_o.draw))
	, userPreferredTimeZone(std::move(_o.userPreferredTimeZone))
	, entryId(std::move(_o.entryId))
	, drawId(std::move(_o.drawId))
	, prizes(std::move(_o.prizes))
	, winners(std::move(_o.winners))
{
}

LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes& LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::operator=(FixedPrizeWonAttributes&& _o)
{
	if(this != &_o)
	{
		numPrizes = std::move(_o.numPrizes);
		numWinners = std::move(_o.numWinners);
		draw = std::move(_o.draw);
		userPreferredTimeZone = std::move(_o.userPreferredTimeZone);
		entryId = std::move(_o.entryId);
		drawId = std::move(_o.drawId);
		prizes = std::move(_o.prizes);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::clear()
{
	numPrizes = 0;
	numWinners = 0;
	draw.setNull();
	userPreferredTimeZone = 0;
	entryId = 0;
	drawId = 0;
	prizes.clear();
	winners.clear();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::equals(const FixedPrizeWonAttributes& _o) const
{
	return numPrizes == _o.numPrizes &&
		numWinners == _o.numWinners &&
		draw.equals(_o.draw) &&
		userPreferredTimeZone == _o.userPreferredTimeZone &&
		entryId == _o.entryId &&
		drawId == _o.drawId &&
		prizes.equals(_o.prizes) &&
		winners.equals(_o.winners);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numPrizes=");
	_buf.appendInt(numPrizes);
	_buf.append(',');
	_buf.append("numWinners=");
	_buf.appendInt(numWinners);
	_buf.append(',');
	_buf.append("draw=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, draw);
	_buf.append(',');
	_buf.append("userPreferredTimeZone=");
	_buf.appendInt(userPreferredTimeZone);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("drawId=");
	_buf.appendUint(drawId);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numPrizes", numPrizes, _buf);
	Atf::XmlElement::encodeAsXmlElement("numWinners", numWinners, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "draw", draw);
	Atf::XmlElement::encodeAsXmlElement("userPreferredTimeZone", userPreferredTimeZone, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("drawId", drawId, _buf);
	prizes.toXmlString("prizes", _buf);
	winners.toXmlString("winners", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numPrizes"))
		{
			numPrizes = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numWinners"))
		{
			numWinners = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("draw"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, draw);
		}
		else if (_element.equals("userPreferredTimeZone"))
		{
			userPreferredTimeZone = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entryId"))
		{
			entryId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("drawId"))
		{
			drawId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Prize , 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else if (_element.equals("winners"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Winner , 4 > >::FromXmlString(_value, winners)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FixedPrizeWonAttributes())) // not empty
	{
		_body.composeINT32(numPrizes);
		_body.composeINT32(numWinners);
		_body.composeSrvTime(draw);
		_body.composeINT32(userPreferredTimeZone);
		_body.composeUINT32(entryId);
		_body.composeUINT32(drawId);
		prizes.composeMsg(_body, _ignoreJSON);
		winners.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numPrizes);
	_parser0.parseINT32(numWinners);
	_parser0.parseSrvTime(draw);
	_parser0.parseINT32(userPreferredTimeZone);
	_parser0.parseUINT32(entryId);
	_parser0.parseUINT32(drawId);
	prizes.parseMsg(_parser0);
	winners.parseMsg(_parser0);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numPrizes", numPrizes);
	_jsonstr.compose("numWinners", numWinners);
	_jsonstr.compose("draw", draw);
	_jsonstr.compose("userPreferredTimeZone", userPreferredTimeZone);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("drawId", drawId);
	_jsonstr.compose("prizes", prizes);
	_jsonstr.compose("winners", winners);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numPrizes", numPrizes);
	_jparser.parseByNameThrow("numWinners", numWinners);
	_jparser.parseByNameThrow("draw", draw);
	_jparser.parseByNameThrow("userPreferredTimeZone", userPreferredTimeZone);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("drawId", drawId);
	_jparser.parseByNameThrow("prizes", prizes);
	_jparser.parseByNameThrow("winners", winners);
}

/* static */ void LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numPrizes; _jparser.validateByNameThrow("numPrizes", numPrizes);
	AtfValidator::validateInt(_descr, "numPrizes", numPrizes, _checker, __FILE__, __LINE__);
	INT32 numWinners; _jparser.validateByNameThrow("numWinners", numWinners);
	AtfValidator::validateInt(_descr, "numWinners", numWinners, _checker, __FILE__, __LINE__);
	SrvTime draw; _jparser.validateByNameThrow("draw", draw);
	AtfValidator::validateSrvDateTime(_descr, "draw", draw, _checker, __FILE__, __LINE__);
	INT32 userPreferredTimeZone; _jparser.validateByNameThrow("userPreferredTimeZone", userPreferredTimeZone);
	AtfValidator::validateInt(_descr, "userPreferredTimeZone", userPreferredTimeZone, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT32 drawId; _jparser.validateByNameThrow("drawId", drawId);
	AtfValidator::validateInt(_descr, "drawId", drawId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Prize > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Winner > winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::FixedPrizeWonAttributes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 numPrizes; _parser0.parseINT32(numPrizes);
	AtfValidator::validateInt(_descr, "numPrizes", numPrizes, _checker, __FILE__, __LINE__);
	INT32 numWinners; _parser0.parseINT32(numWinners);
	AtfValidator::validateInt(_descr, "numWinners", numWinners, _checker, __FILE__, __LINE__);
	SrvTime draw; _parser0.parseSrvTime(draw);
	AtfValidator::validateSrvDateTime(_descr, "draw", draw, _checker, __FILE__, __LINE__);
	INT32 userPreferredTimeZone; _parser0.parseINT32(userPreferredTimeZone);
	AtfValidator::validateInt(_descr, "userPreferredTimeZone", userPreferredTimeZone, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT32 drawId; _parser0.parseUINT32(drawId);
	AtfValidator::validateInt(_descr, "drawId", drawId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< Prize , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	int szWinners = Atf::LAtfVector< Winner , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FixedPrizeLostAttributes
//=================================================================

LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::FixedPrizeLostAttributes()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::FixedPrizeLostAttributes(FixedPrizeLostAttributes&& _o)
	: numPrizes(std::move(_o.numPrizes))
	, numWinners(std::move(_o.numWinners))
	, draw(std::move(_o.draw))
	, userPreferredTimeZone(std::move(_o.userPreferredTimeZone))
	, entryId(std::move(_o.entryId))
	, drawId(std::move(_o.drawId))
	, winners(std::move(_o.winners))
{
}

LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes& LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::operator=(FixedPrizeLostAttributes&& _o)
{
	if(this != &_o)
	{
		numPrizes = std::move(_o.numPrizes);
		numWinners = std::move(_o.numWinners);
		draw = std::move(_o.draw);
		userPreferredTimeZone = std::move(_o.userPreferredTimeZone);
		entryId = std::move(_o.entryId);
		drawId = std::move(_o.drawId);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::clear()
{
	numPrizes = 0;
	numWinners = 0;
	draw.setNull();
	userPreferredTimeZone = 0;
	entryId = 0;
	drawId = 0;
	winners.clear();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::equals(const FixedPrizeLostAttributes& _o) const
{
	return numPrizes == _o.numPrizes &&
		numWinners == _o.numWinners &&
		draw.equals(_o.draw) &&
		userPreferredTimeZone == _o.userPreferredTimeZone &&
		entryId == _o.entryId &&
		drawId == _o.drawId &&
		winners.equals(_o.winners);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numPrizes=");
	_buf.appendInt(numPrizes);
	_buf.append(',');
	_buf.append("numWinners=");
	_buf.appendInt(numWinners);
	_buf.append(',');
	_buf.append("draw=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, draw);
	_buf.append(',');
	_buf.append("userPreferredTimeZone=");
	_buf.appendInt(userPreferredTimeZone);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("drawId=");
	_buf.appendUint(drawId);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numPrizes", numPrizes, _buf);
	Atf::XmlElement::encodeAsXmlElement("numWinners", numWinners, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "draw", draw);
	Atf::XmlElement::encodeAsXmlElement("userPreferredTimeZone", userPreferredTimeZone, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("drawId", drawId, _buf);
	winners.toXmlString("winners", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numPrizes"))
		{
			numPrizes = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numWinners"))
		{
			numWinners = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("draw"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, draw);
		}
		else if (_element.equals("userPreferredTimeZone"))
		{
			userPreferredTimeZone = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entryId"))
		{
			entryId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("drawId"))
		{
			drawId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winners"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Winner , 4 > >::FromXmlString(_value, winners)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FixedPrizeLostAttributes())) // not empty
	{
		_body.composeINT32(numPrizes);
		_body.composeINT32(numWinners);
		_body.composeSrvTime(draw);
		_body.composeINT32(userPreferredTimeZone);
		_body.composeUINT32(entryId);
		_body.composeUINT32(drawId);
		winners.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numPrizes);
	_parser0.parseINT32(numWinners);
	_parser0.parseSrvTime(draw);
	_parser0.parseINT32(userPreferredTimeZone);
	_parser0.parseUINT32(entryId);
	_parser0.parseUINT32(drawId);
	winners.parseMsg(_parser0);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numPrizes", numPrizes);
	_jsonstr.compose("numWinners", numWinners);
	_jsonstr.compose("draw", draw);
	_jsonstr.compose("userPreferredTimeZone", userPreferredTimeZone);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("drawId", drawId);
	_jsonstr.compose("winners", winners);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numPrizes", numPrizes);
	_jparser.parseByNameThrow("numWinners", numWinners);
	_jparser.parseByNameThrow("draw", draw);
	_jparser.parseByNameThrow("userPreferredTimeZone", userPreferredTimeZone);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("drawId", drawId);
	_jparser.parseByNameThrow("winners", winners);
}

/* static */ void LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numPrizes; _jparser.validateByNameThrow("numPrizes", numPrizes);
	AtfValidator::validateInt(_descr, "numPrizes", numPrizes, _checker, __FILE__, __LINE__);
	INT32 numWinners; _jparser.validateByNameThrow("numWinners", numWinners);
	AtfValidator::validateInt(_descr, "numWinners", numWinners, _checker, __FILE__, __LINE__);
	SrvTime draw; _jparser.validateByNameThrow("draw", draw);
	AtfValidator::validateSrvDateTime(_descr, "draw", draw, _checker, __FILE__, __LINE__);
	INT32 userPreferredTimeZone; _jparser.validateByNameThrow("userPreferredTimeZone", userPreferredTimeZone);
	AtfValidator::validateInt(_descr, "userPreferredTimeZone", userPreferredTimeZone, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT32 drawId; _jparser.validateByNameThrow("drawId", drawId);
	AtfValidator::validateInt(_descr, "drawId", drawId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Winner > winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::FixedPrizeLostAttributes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 numPrizes; _parser0.parseINT32(numPrizes);
	AtfValidator::validateInt(_descr, "numPrizes", numPrizes, _checker, __FILE__, __LINE__);
	INT32 numWinners; _parser0.parseINT32(numWinners);
	AtfValidator::validateInt(_descr, "numWinners", numWinners, _checker, __FILE__, __LINE__);
	SrvTime draw; _parser0.parseSrvTime(draw);
	AtfValidator::validateSrvDateTime(_descr, "draw", draw, _checker, __FILE__, __LINE__);
	INT32 userPreferredTimeZone; _parser0.parseINT32(userPreferredTimeZone);
	AtfValidator::validateInt(_descr, "userPreferredTimeZone", userPreferredTimeZone, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT32 drawId; _parser0.parseUINT32(drawId);
	AtfValidator::validateInt(_descr, "drawId", drawId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = Atf::LAtfVector< Winner , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FixedPrizeTicketAttributes
//=================================================================

LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::FixedPrizeTicketAttributes()
{
	clear();
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::clear()
{
	entries = 0;
	draw.setNull();
	userPreferredTimeZone = 0;
	entryId = 0;
	drawId = 0;
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::equals(const FixedPrizeTicketAttributes& _o) const
{
	return entries == _o.entries &&
		draw.equals(_o.draw) &&
		userPreferredTimeZone == _o.userPreferredTimeZone &&
		entryId == _o.entryId &&
		drawId == _o.drawId;
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("entries=");
	_buf.appendInt(entries);
	_buf.append(',');
	_buf.append("draw=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, draw);
	_buf.append(',');
	_buf.append("userPreferredTimeZone=");
	_buf.appendInt(userPreferredTimeZone);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("drawId=");
	_buf.appendUint(drawId);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("entries", entries, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "draw", draw);
	Atf::XmlElement::encodeAsXmlElement("userPreferredTimeZone", userPreferredTimeZone, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("drawId", drawId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("entries"))
		{
			entries = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("draw"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, draw);
		}
		else if (_element.equals("userPreferredTimeZone"))
		{
			userPreferredTimeZone = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entryId"))
		{
			entryId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("drawId"))
		{
			drawId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FixedPrizeTicketAttributes())) // not empty
	{
		_body.composeINT32(entries);
		_body.composeSrvTime(draw);
		_body.composeINT32(userPreferredTimeZone);
		_body.composeUINT32(entryId);
		_body.composeUINT32(drawId);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(entries);
	_parser0.parseSrvTime(draw);
	_parser0.parseINT32(userPreferredTimeZone);
	_parser0.parseUINT32(entryId);
	_parser0.parseUINT32(drawId);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("entries", entries);
	_jsonstr.compose("draw", draw);
	_jsonstr.compose("userPreferredTimeZone", userPreferredTimeZone);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("drawId", drawId);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("entries", entries);
	_jparser.parseByNameThrow("draw", draw);
	_jparser.parseByNameThrow("userPreferredTimeZone", userPreferredTimeZone);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("drawId", drawId);
}

/* static */ void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 entries; _jparser.validateByNameThrow("entries", entries);
	AtfValidator::validateInt(_descr, "entries", entries, _checker, __FILE__, __LINE__);
	SrvTime draw; _jparser.validateByNameThrow("draw", draw);
	AtfValidator::validateSrvDateTime(_descr, "draw", draw, _checker, __FILE__, __LINE__);
	INT32 userPreferredTimeZone; _jparser.validateByNameThrow("userPreferredTimeZone", userPreferredTimeZone);
	AtfValidator::validateInt(_descr, "userPreferredTimeZone", userPreferredTimeZone, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT32 drawId; _jparser.validateByNameThrow("drawId", drawId);
	AtfValidator::validateInt(_descr, "drawId", drawId, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketAttributes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 entries; _parser0.parseINT32(entries);
	AtfValidator::validateInt(_descr, "entries", entries, _checker, __FILE__, __LINE__);
	SrvTime draw; _parser0.parseSrvTime(draw);
	AtfValidator::validateSrvDateTime(_descr, "draw", draw, _checker, __FILE__, __LINE__);
	INT32 userPreferredTimeZone; _parser0.parseINT32(userPreferredTimeZone);
	AtfValidator::validateInt(_descr, "userPreferredTimeZone", userPreferredTimeZone, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT32 drawId; _parser0.parseUINT32(drawId);
	AtfValidator::validateInt(_descr, "drawId", drawId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FixedPrizeTicketNotifMsg
//=================================================================

LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::FixedPrizeTicketNotifMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::FixedPrizeTicketNotifMsg(FixedPrizeTicketNotifMsg&& _o)
	: type(std::move(_o.type))
	, state(std::move(_o.state))
	, title(std::move(_o.title))
	, description(std::move(_o.description))
	, moreInfo(std::move(_o.moreInfo))
	, headerImageURL(std::move(_o.headerImageURL))
	, attributes(std::move(_o.attributes))
{
}

LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg& LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::operator=(FixedPrizeTicketNotifMsg&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		state = std::move(_o.state);
		title = std::move(_o.title);
		description = std::move(_o.description);
		moreInfo = std::move(_o.moreInfo);
		headerImageURL = std::move(_o.headerImageURL);
		attributes = std::move(_o.attributes);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::clear()
{
	type = "FixedPrizeDraw";
	state = "issued";
	title.clear();
	description.clear();
	moreInfo.clear();
	headerImageURL.clear();
	attributes.clear();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::equals(const FixedPrizeTicketNotifMsg& _o) const
{
	return Atf::atfPStringEquals(type, _o.type) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(title, _o.title) &&
		Atf::atfPStringEquals(description, _o.description) &&
		Atf::atfPStringEquals(moreInfo, _o.moreInfo) &&
		Atf::atfPStringEquals(headerImageURL, _o.headerImageURL) &&
		attributes.equals(_o.attributes);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.append(type);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("title=");
	_buf.append(title);
	_buf.append(',');
	_buf.append("description=");
	_buf.append(description);
	_buf.append(',');
	_buf.append("moreInfo=");
	_buf.append(moreInfo);
	_buf.append(',');
	_buf.append("headerImageURL=");
	_buf.append(headerImageURL);
	_buf.append(',');
	_buf.append("attributes=");
	attributes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("title", title, _buf);
	Atf::XmlElement::encodeAsXmlElement("description", description, _buf);
	Atf::XmlElement::encodeAsXmlElement("moreInfo", moreInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("headerImageURL", headerImageURL, _buf);
	attributes.toXmlString("attributes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, type)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("title"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, title)) return false;
		}
		else if (_element.equals("description"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, description)) return false;
		}
		else if (_element.equals("moreInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, moreInfo)) return false;
		}
		else if (_element.equals("headerImageURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, headerImageURL)) return false;
		}
		else if (_element.equals("attributes"))
		{
			if(!Atf::AtfTempl< FixedPrizeTicketAttributes >::FromXmlString(_value, attributes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FixedPrizeTicketNotifMsg())) // not empty
	{
		_body.composeString(type);
		_body.composeString(state);
		_body.composeString(title);
		_body.composeString(description);
		_body.composeString(moreInfo);
		_body.composeString(headerImageURL);
		attributes.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(type);
	_parser0.parseStringP(state);
	_parser0.parseStringP(title);
	_parser0.parseStringP(description);
	_parser0.parseStringP(moreInfo);
	_parser0.parseStringP(headerImageURL);
	attributes.parseMsg(_parser0);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("state", state);
	_jsonstr.compose("title", title);
	_jsonstr.compose("description", description);
	_jsonstr.compose("moreInfo", moreInfo);
	_jsonstr.compose("headerImageURL", headerImageURL);
	_jsonstr.compose("attributes", attributes);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("title", title);
	_jparser.parseByNameThrow("description", description);
	_jparser.parseByNameThrow("moreInfo", moreInfo);
	_jparser.parseByNameThrow("headerImageURL", headerImageURL);
	_jparser.parseByNameThrow("attributes", attributes);
}

/* static */ void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type.length(), _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateInt(_descr, "state", state.length(), _checker, __FILE__, __LINE__);
	PString title; _jparser.validateByNameThrow("title", title);
	AtfValidator::validateInt(_descr, "title", title.length(), _checker, __FILE__, __LINE__);
	PString description; _jparser.validateByNameThrow("description", description);
	AtfValidator::validateInt(_descr, "description", description.length(), _checker, __FILE__, __LINE__);
	PString moreInfo; _jparser.validateByNameThrow("moreInfo", moreInfo);
	AtfValidator::validateInt(_descr, "moreInfo", moreInfo.length(), _checker, __FILE__, __LINE__);
	PString headerImageURL; _jparser.validateByNameThrow("headerImageURL", headerImageURL);
	AtfValidator::validateInt(_descr, "headerImageURL", headerImageURL.length(), _checker, __FILE__, __LINE__);
	FixedPrizeTicketAttributes attributes; _jparser.validateByNameThrow("attributes", attributes);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::FixedPrizeTicketNotifMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "type"); size_t szType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "type", szType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "title"); size_t szTitle = strlen(_dummy);
	AtfValidator::validateInt(_descr, "title", szTitle, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "description"); size_t szDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "description", szDescription, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "moreInfo"); size_t szMoreInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "moreInfo", szMoreInfo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "headerImageURL"); size_t szHeaderImageURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "headerImageURL", szHeaderImageURL, _checker, __FILE__, __LINE__);
	PString _descbuf;
	FixedPrizeTicketAttributes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("attributes"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FixedPrizeWonNotifMsg
//=================================================================

LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::FixedPrizeWonNotifMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::FixedPrizeWonNotifMsg(FixedPrizeWonNotifMsg&& _o)
	: type(std::move(_o.type))
	, state(std::move(_o.state))
	, title(std::move(_o.title))
	, headerImageURL(std::move(_o.headerImageURL))
	, attributes(std::move(_o.attributes))
{
}

LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg& LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::operator=(FixedPrizeWonNotifMsg&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		state = std::move(_o.state);
		title = std::move(_o.title);
		headerImageURL = std::move(_o.headerImageURL);
		attributes = std::move(_o.attributes);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::clear()
{
	type = "FixedPrizeDraw";
	state = "won";
	title.clear();
	headerImageURL.clear();
	attributes.clear();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::equals(const FixedPrizeWonNotifMsg& _o) const
{
	return Atf::atfPStringEquals(type, _o.type) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(title, _o.title) &&
		Atf::atfPStringEquals(headerImageURL, _o.headerImageURL) &&
		attributes.equals(_o.attributes);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.append(type);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("title=");
	_buf.append(title);
	_buf.append(',');
	_buf.append("headerImageURL=");
	_buf.append(headerImageURL);
	_buf.append(',');
	_buf.append("attributes=");
	attributes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("title", title, _buf);
	Atf::XmlElement::encodeAsXmlElement("headerImageURL", headerImageURL, _buf);
	attributes.toXmlString("attributes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, type)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("title"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, title)) return false;
		}
		else if (_element.equals("headerImageURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, headerImageURL)) return false;
		}
		else if (_element.equals("attributes"))
		{
			if(!Atf::AtfTempl< FixedPrizeWonAttributes >::FromXmlString(_value, attributes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FixedPrizeWonNotifMsg())) // not empty
	{
		_body.composeString(type);
		_body.composeString(state);
		_body.composeString(title);
		_body.composeString(headerImageURL);
		attributes.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(type);
	_parser0.parseStringP(state);
	_parser0.parseStringP(title);
	_parser0.parseStringP(headerImageURL);
	attributes.parseMsg(_parser0);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("state", state);
	_jsonstr.compose("title", title);
	_jsonstr.compose("headerImageURL", headerImageURL);
	_jsonstr.compose("attributes", attributes);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("title", title);
	_jparser.parseByNameThrow("headerImageURL", headerImageURL);
	_jparser.parseByNameThrow("attributes", attributes);
}

/* static */ void LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type.length(), _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateInt(_descr, "state", state.length(), _checker, __FILE__, __LINE__);
	PString title; _jparser.validateByNameThrow("title", title);
	AtfValidator::validateInt(_descr, "title", title.length(), _checker, __FILE__, __LINE__);
	PString headerImageURL; _jparser.validateByNameThrow("headerImageURL", headerImageURL);
	AtfValidator::validateInt(_descr, "headerImageURL", headerImageURL.length(), _checker, __FILE__, __LINE__);
	FixedPrizeWonAttributes attributes; _jparser.validateByNameThrow("attributes", attributes);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::FixedPrizeWonNotifMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "type"); size_t szType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "type", szType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "title"); size_t szTitle = strlen(_dummy);
	AtfValidator::validateInt(_descr, "title", szTitle, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "headerImageURL"); size_t szHeaderImageURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "headerImageURL", szHeaderImageURL, _checker, __FILE__, __LINE__);
	PString _descbuf;
	FixedPrizeWonAttributes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("attributes"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    FixedPrizeLostNotifMsg
//=================================================================

LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::FixedPrizeLostNotifMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::FixedPrizeLostNotifMsg(FixedPrizeLostNotifMsg&& _o)
	: type(std::move(_o.type))
	, state(std::move(_o.state))
	, title(std::move(_o.title))
	, headerImageURL(std::move(_o.headerImageURL))
	, attributes(std::move(_o.attributes))
{
}

LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg& LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::operator=(FixedPrizeLostNotifMsg&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		state = std::move(_o.state);
		title = std::move(_o.title);
		headerImageURL = std::move(_o.headerImageURL);
		attributes = std::move(_o.attributes);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::clear()
{
	type = "FixedPrizeDraw";
	state = "lost";
	title.clear();
	headerImageURL.clear();
	attributes.clear();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::equals(const FixedPrizeLostNotifMsg& _o) const
{
	return Atf::atfPStringEquals(type, _o.type) &&
		Atf::atfPStringEquals(state, _o.state) &&
		Atf::atfPStringEquals(title, _o.title) &&
		Atf::atfPStringEquals(headerImageURL, _o.headerImageURL) &&
		attributes.equals(_o.attributes);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.append(type);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("title=");
	_buf.append(title);
	_buf.append(',');
	_buf.append("headerImageURL=");
	_buf.append(headerImageURL);
	_buf.append(',');
	_buf.append("attributes=");
	attributes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("title", title, _buf);
	Atf::XmlElement::encodeAsXmlElement("headerImageURL", headerImageURL, _buf);
	attributes.toXmlString("attributes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, type)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("title"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, title)) return false;
		}
		else if (_element.equals("headerImageURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, headerImageURL)) return false;
		}
		else if (_element.equals("attributes"))
		{
			if(!Atf::AtfTempl< FixedPrizeLostAttributes >::FromXmlString(_value, attributes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(FixedPrizeLostNotifMsg())) // not empty
	{
		_body.composeString(type);
		_body.composeString(state);
		_body.composeString(title);
		_body.composeString(headerImageURL);
		attributes.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(type);
	_parser0.parseStringP(state);
	_parser0.parseStringP(title);
	_parser0.parseStringP(headerImageURL);
	attributes.parseMsg(_parser0);
}

const char *LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("state", state);
	_jsonstr.compose("title", title);
	_jsonstr.compose("headerImageURL", headerImageURL);
	_jsonstr.compose("attributes", attributes);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("title", title);
	_jparser.parseByNameThrow("headerImageURL", headerImageURL);
	_jparser.parseByNameThrow("attributes", attributes);
}

/* static */ void LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type.length(), _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateInt(_descr, "state", state.length(), _checker, __FILE__, __LINE__);
	PString title; _jparser.validateByNameThrow("title", title);
	AtfValidator::validateInt(_descr, "title", title.length(), _checker, __FILE__, __LINE__);
	PString headerImageURL; _jparser.validateByNameThrow("headerImageURL", headerImageURL);
	AtfValidator::validateInt(_descr, "headerImageURL", headerImageURL.length(), _checker, __FILE__, __LINE__);
	FixedPrizeLostAttributes attributes; _jparser.validateByNameThrow("attributes", attributes);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::FixedPrizeLostNotifMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "type"); size_t szType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "type", szType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "title"); size_t szTitle = strlen(_dummy);
	AtfValidator::validateInt(_descr, "title", szTitle, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "headerImageURL"); size_t szHeaderImageURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "headerImageURL", szHeaderImageURL, _checker, __FILE__, __LINE__);
	PString _descbuf;
	FixedPrizeLostAttributes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("attributes"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MyStarsData
//=================================================================

LobbyEtcClient::MiniGameTickets::MyStarsData::MyStarsData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::MyStarsData::MyStarsData(MyStarsData&& _o)
	: type(std::move(_o.type))
	, state(std::move(_o.state))
	, tickets(std::move(_o.tickets))
	, wins(std::move(_o.wins))
	, losts(std::move(_o.losts))
{
}

LobbyEtcClient::MiniGameTickets::MyStarsData& LobbyEtcClient::MiniGameTickets::MyStarsData::operator=(MyStarsData&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		state = std::move(_o.state);
		tickets = std::move(_o.tickets);
		wins = std::move(_o.wins);
		losts = std::move(_o.losts);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::MyStarsData::clear()
{
	type = "FixedPrizeDraw";
	state = "mystars";
	tickets.clear();
	wins.clear();
	losts.clear();
}

bool LobbyEtcClient::MiniGameTickets::MyStarsData::equals(const MyStarsData& _o) const
{
	return Atf::atfPStringEquals(type, _o.type) &&
		Atf::atfPStringEquals(state, _o.state) &&
		tickets.equals(_o.tickets) &&
		wins.equals(_o.wins) &&
		losts.equals(_o.losts);
}

const char *LobbyEtcClient::MiniGameTickets::MyStarsData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.append(type);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("wins=");
	wins.toTraceString(_buf);
	_buf.append(',');
	_buf.append("losts=");
	losts.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::MyStarsData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	tickets.toXmlString("tickets", _buf);
	wins.toXmlString("wins", _buf);
	losts.toXmlString("losts", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::MyStarsData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, type)) return false;
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("tickets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< FixedPrizeTicketNotifMsg , 4 > >::FromXmlString(_value, tickets)) return false;
		}
		else if (_element.equals("wins"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< FixedPrizeWonNotifMsg , 4 > >::FromXmlString(_value, wins)) return false;
		}
		else if (_element.equals("losts"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< FixedPrizeLostNotifMsg , 4 > >::FromXmlString(_value, losts)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::MiniGameTickets::MyStarsData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MyStarsData())) // not empty
	{
		_body.composeString(type);
		_body.composeString(state);
		tickets.composeMsg(_body, _ignoreJSON);
		wins.composeMsg(_body, _ignoreJSON);
		losts.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::MiniGameTickets::MyStarsData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(type);
	_parser0.parseStringP(state);
	tickets.parseMsg(_parser0);
	wins.parseMsg(_parser0);
	losts.parseMsg(_parser0);
}

const char *LobbyEtcClient::MiniGameTickets::MyStarsData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("state", state);
	_jsonstr.compose("tickets", tickets);
	_jsonstr.compose("wins", wins);
	_jsonstr.compose("losts", losts);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::MyStarsData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("tickets", tickets);
	_jparser.parseByNameThrow("wins", wins);
	_jparser.parseByNameThrow("losts", losts);
}

/* static */ void LobbyEtcClient::MiniGameTickets::MyStarsData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type.length(), _checker, __FILE__, __LINE__);
	PString state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateInt(_descr, "state", state.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FixedPrizeTicketNotifMsg > tickets; _jparser.validateByNameThrow("tickets", tickets);
	AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FixedPrizeWonNotifMsg > wins; _jparser.validateByNameThrow("wins", wins);
	AtfValidator::validateInt(_descr, "wins", wins.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< FixedPrizeLostNotifMsg > losts; _jparser.validateByNameThrow("losts", losts);
	AtfValidator::validateInt(_descr, "losts", losts.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::MyStarsData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "type"); size_t szType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "type", szType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "state"); size_t szState = strlen(_dummy);
	AtfValidator::validateInt(_descr, "state", szState, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTickets = Atf::LAtfVector< FixedPrizeTicketNotifMsg , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	int szWins = Atf::LAtfVector< FixedPrizeWonNotifMsg , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("wins"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "wins", szWins, _checker, __FILE__, __LINE__);
	int szLosts = Atf::LAtfVector< FixedPrizeLostNotifMsg , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("losts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "losts", szLosts, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA
//=================================================================

LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA()
{
	clear();
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::clear()
{
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::equals(const Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA& _o) const
{
	return true;
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA*)_other));
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA).append(")");
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY
//=================================================================

LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY(Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY&& _o)
	: json(std::move(_o.json))
{
}

LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY& LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY&& _o)
{
	if(this != &_o)
	{
		json = std::move(_o.json);
	}
	return *this;
}

#endif

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::clear()
{
	json.clear();
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY& _o) const
{
	return Atf::atfPStringEquals(json, _o.json);
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY*)_other));
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY).append(")");
	_buf.append(',');
	_buf.append("json=");
	_buf.append(json);
	return _buf.c_str();
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("json", json, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("json"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, json)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(json);
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(json);
}

const char *LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("json", json);
	return _buf.c_str();
}

void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("json", json);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString json; _jparser.validateByNameThrow("json", json);
	AtfValidator::validateInt(_descr, "json", json.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "json"); size_t szJson = strlen(_dummy);
	AtfValidator::validateInt(_descr, "json", szJson, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY
//=================================================================

LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY()
{
	clear();
}

void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::clear()
{
	siteId = 0;
	brand = 0;
	locale = 0;
}

bool LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::equals(const Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY& _o) const
{
	return siteId == _o.siteId &&
		brand == _o.brand &&
		locale == _o.locale;
}

bool LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY*)_other));
}

const char *LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY).append(")");
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brand=");
	_buf.appendUint(brand);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brand", brand, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("brand"))
			{
				brand = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(brand);
	_msg.composeUINT32(locale);
}

void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(brand);
	_parser.parseUINT32(locale);
}

const char *LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("brand", brand);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("brand", brand);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 brand; _jparser.validateByNameThrow("brand", brand);
	AtfValidator::validateInt(_descr, "brand", brand, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 brand; _parser.parseUINT32(brand);
	AtfValidator::validateInt(_descr, "brand", brand, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    Image
//=================================================================

LobbyEtcClient::ImageGallery::Image::Image()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::ImageGallery::Image::Image(Image&& _o)
	: imageId(std::move(_o.imageId))
	, descr(std::move(_o.descr))
{
}

LobbyEtcClient::ImageGallery::Image& LobbyEtcClient::ImageGallery::Image::operator=(Image&& _o)
{
	if(this != &_o)
	{
		imageId = std::move(_o.imageId);
		descr = std::move(_o.descr);
	}
	return *this;
}

#endif

void LobbyEtcClient::ImageGallery::Image::clear()
{
	imageId = 0;
	descr.clear();
}

bool LobbyEtcClient::ImageGallery::Image::equals(const Image& _o) const
{
	return imageId == _o.imageId &&
		Atf::atfPStringEquals(descr, _o.descr);
}

const char *LobbyEtcClient::ImageGallery::Image::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("descr=");
	_buf.append(descr);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::ImageGallery::Image::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("descr", descr, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::ImageGallery::Image::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("descr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, descr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::ImageGallery::Image::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Image())) // not empty
	{
		_body.composeUINT32(imageId);
		_body.composeString(descr);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::ImageGallery::Image::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(imageId);
	_parser0.parseStringP(descr);
}

const char *LobbyEtcClient::ImageGallery::Image::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("descr", descr);
	return _buf.c_str();
}

void LobbyEtcClient::ImageGallery::Image::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("descr", descr);
}

/* static */ void LobbyEtcClient::ImageGallery::Image::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	PString descr; _jparser.validateByNameThrow("descr", descr);
	AtfValidator::validateInt(_descr, "descr", descr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::ImageGallery::Image::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "descr"); size_t szDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "descr", szDescr, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SubCategory
//=================================================================

LobbyEtcClient::ImageGallery::SubCategory::SubCategory()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::ImageGallery::SubCategory::SubCategory(SubCategory&& _o)
	: name(std::move(_o.name))
	, imageIds(std::move(_o.imageIds))
{
}

LobbyEtcClient::ImageGallery::SubCategory& LobbyEtcClient::ImageGallery::SubCategory::operator=(SubCategory&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		imageIds = std::move(_o.imageIds);
	}
	return *this;
}

#endif

void LobbyEtcClient::ImageGallery::SubCategory::clear()
{
	name.clear();
	imageIds.clear();
}

bool LobbyEtcClient::ImageGallery::SubCategory::equals(const SubCategory& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		imageIds.equals(_o.imageIds);
}

const char *LobbyEtcClient::ImageGallery::SubCategory::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("imageIds=");
	imageIds.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::ImageGallery::SubCategory::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	imageIds.toXmlString("imageIds", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::ImageGallery::SubCategory::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("imageIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, imageIds)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::ImageGallery::SubCategory::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SubCategory())) // not empty
	{
		_body.composeString(name);
		imageIds.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::ImageGallery::SubCategory::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	imageIds.parseMsg(_parser0);
}

const char *LobbyEtcClient::ImageGallery::SubCategory::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("imageIds", imageIds);
	return _buf.c_str();
}

void LobbyEtcClient::ImageGallery::SubCategory::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("imageIds", imageIds);
}

/* static */ void LobbyEtcClient::ImageGallery::SubCategory::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > imageIds; _jparser.validateByNameThrow("imageIds", imageIds);
	AtfValidator::validateInt(_descr, "imageIds", imageIds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::ImageGallery::SubCategory::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szImageIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("imageIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "imageIds", szImageIds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    Category
//=================================================================

LobbyEtcClient::ImageGallery::Category::Category()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::ImageGallery::Category::Category(Category&& _o)
	: catName(std::move(_o.catName))
	, imageIds(std::move(_o.imageIds))
	, subcategories(std::move(_o.subcategories))
{
}

LobbyEtcClient::ImageGallery::Category& LobbyEtcClient::ImageGallery::Category::operator=(Category&& _o)
{
	if(this != &_o)
	{
		catName = std::move(_o.catName);
		imageIds = std::move(_o.imageIds);
		subcategories = std::move(_o.subcategories);
	}
	return *this;
}

#endif

void LobbyEtcClient::ImageGallery::Category::clear()
{
	catName.clear();
	imageIds.clear();
	subcategories.clear();
}

bool LobbyEtcClient::ImageGallery::Category::equals(const Category& _o) const
{
	return Atf::atfPStringEquals(catName, _o.catName) &&
		imageIds.equals(_o.imageIds) &&
		subcategories.equals(_o.subcategories);
}

const char *LobbyEtcClient::ImageGallery::Category::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("catName=");
	_buf.append(catName);
	_buf.append(',');
	_buf.append("imageIds=");
	imageIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("subcategories=");
	subcategories.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtcClient::ImageGallery::Category::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("catName", catName, _buf);
	imageIds.toXmlString("imageIds", _buf);
	subcategories.toXmlString("subcategories", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtcClient::ImageGallery::Category::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("catName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, catName)) return false;
		}
		else if (_element.equals("imageIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, imageIds)) return false;
		}
		else if (_element.equals("subcategories"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SubCategory, 4 > >::FromXmlString(_value, subcategories)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtcClient::ImageGallery::Category::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Category())) // not empty
	{
		_body.composeString(catName);
		imageIds.composeMsg(_body, _ignoreJSON);
		subcategories.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtcClient::ImageGallery::Category::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(catName);
	imageIds.parseMsg(_parser0);
	subcategories.parseMsg(_parser0);
}

const char *LobbyEtcClient::ImageGallery::Category::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("catName", catName);
	_jsonstr.compose("imageIds", imageIds);
	_jsonstr.compose("subcategories", subcategories);
	return _buf.c_str();
}

void LobbyEtcClient::ImageGallery::Category::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("catName", catName);
	_jparser.parseByNameThrow("imageIds", imageIds);
	_jparser.parseByNameThrow("subcategories", subcategories);
}

/* static */ void LobbyEtcClient::ImageGallery::Category::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString catName; _jparser.validateByNameThrow("catName", catName);
	AtfValidator::validateInt(_descr, "catName", catName.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > imageIds; _jparser.validateByNameThrow("imageIds", imageIds);
	AtfValidator::validateInt(_descr, "imageIds", imageIds.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SubCategory > subcategories; _jparser.validateByNameThrow("subcategories", subcategories);
	AtfValidator::validateInt(_descr, "subcategories", subcategories.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::ImageGallery::Category::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "catName"); size_t szCatName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "catName", szCatName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szImageIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("imageIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "imageIds", szImageIds, _checker, __FILE__, __LINE__);
	int szSubcategories = Atf::LAtfVector< SubCategory, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("subcategories"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "subcategories", szSubcategories, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY
//=================================================================

LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY(Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, images(std::move(_o.images))
	, categories(std::move(_o.categories))
{
}

LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY& LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		images = std::move(_o.images);
		categories = std::move(_o.categories);
	}
	return *this;
}

#endif

void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	images.clear();
	categories.clear();
}

bool LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		images.equals(_o.images) &&
		categories.equals(_o.categories);
}

bool LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY*)_other));
}

const char *LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("images=");
		images.toTraceString(_buf);
		_buf.append(',');
		_buf.append("categories=");
		categories.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		images.toXmlString("images", _buf);
		categories.toXmlString("categories", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("images"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Image, 4 > >::FromXmlString(_value, images)) return false;
			}
			else if (_element.equals("categories"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Category, 4 > >::FromXmlString(_value, categories)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		images.composeMsg(_msg, _ignoreJSON);
		categories.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		images.parseMsg(_parser);
		categories.parseMsg(_parser);
	}
}

const char *LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("images", images);
		_jsonstr.compose("categories", categories);
	}
	return _buf.c_str();
}

void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("images", images);
		_jparser.parseByNameThrow("categories", categories);
	}
}

/*static*/ void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< Image > images; _jparser.validateByNameThrow("images", images);
		AtfValidator::validateInt(_descr, "images", images.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< Category > categories; _jparser.validateByNameThrow("categories", categories);
		AtfValidator::validateInt(_descr, "categories", categories.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtcClient::ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szImages = Atf::LAtfVector< Image, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("images"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "images", szImages, _checker, __FILE__, __LINE__);
		int szCategories = Atf::LAtfVector< Category, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("categories"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "categories", szCategories, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS
//=================================================================

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS()
{
	clear();
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::clear()
{
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::equals(const Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS& _o) const
{
	return true;
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS*)_other));
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS).append(")");
	return _buf.c_str();
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY
//=================================================================

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY(Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, status(std::move(_o.status))
	, twitchId(std::move(_o.twitchId))
{
}

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY& LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		status = std::move(_o.status);
		twitchId = std::move(_o.twitchId);
	}
	return *this;
}

#endif

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	status = false;
	twitchId.clear();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		status == _o.status &&
		Atf::atfPStringEquals(twitchId, _o.twitchId);
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY*)_other));
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendUint(status);
		_buf.append(',');
		_buf.append("twitchId=");
		_buf.append(twitchId);
	}
	return _buf.c_str();
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		Atf::XmlElement::encodeAsXmlElement("twitchId", twitchId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("status"))
			{
				status = (*_value.ptr() == '1');
			}
			else if (_element.equals("twitchId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, twitchId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeBOOL(status);
		_msg.composeString(twitchId);
	}
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseBOOL(status);
		_parser.parseStringP(twitchId);
	}
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("status", status);
		_jsonstr.compose("twitchId", twitchId);
	}
	return _buf.c_str();
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("twitchId", twitchId);
	}
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		PString twitchId; _jparser.validateByNameThrow("twitchId", twitchId);
		AtfValidator::validateInt(_descr, "twitchId", twitchId.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool status; _parser.parseBOOL(status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "twitchId"); size_t szTwitchId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "twitchId", szTwitchId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT
//=================================================================

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT(Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT&& _o)
	: authorizationCode(std::move(_o.authorizationCode))
{
}

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT& LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::operator=(Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT&& _o)
{
	if(this != &_o)
	{
		authorizationCode = std::move(_o.authorizationCode);
	}
	return *this;
}

#endif

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::clear()
{
	authorizationCode.clear();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::equals(const Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT& _o) const
{
	return Atf::atfPStringEquals(authorizationCode, _o.authorizationCode);
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_TWITCH_CONNECT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT*)_other));
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_TWITCH_CONNECT).append(")");
	_buf.append(',');
	_buf.append("authorizationCode=");
	_buf.append(authorizationCode);
	return _buf.c_str();
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_TWITCH_CONNECT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("authorizationCode", authorizationCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("authorizationCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, authorizationCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(authorizationCode);
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(authorizationCode);
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("authorizationCode", authorizationCode);
	return _buf.c_str();
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("authorizationCode", authorizationCode);
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TWITCH_CONNECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString authorizationCode; _jparser.validateByNameThrow("authorizationCode", authorizationCode);
	AtfValidator::validateInt(_descr, "authorizationCode", authorizationCode.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TWITCH_CONNECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "authorizationCode"); size_t szAuthorizationCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "authorizationCode", szAuthorizationCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY
//=================================================================

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY(Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, twitchId(std::move(_o.twitchId))
{
}

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY& LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		twitchId = std::move(_o.twitchId);
	}
	return *this;
}

#endif

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	twitchId.clear();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		Atf::atfPStringEquals(twitchId, _o.twitchId);
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY*)_other));
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("twitchId=");
		_buf.append(twitchId);
	}
	return _buf.c_str();
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("twitchId", twitchId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("twitchId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, twitchId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeString(twitchId);
	}
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseStringP(twitchId);
	}
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("twitchId", twitchId);
	}
	return _buf.c_str();
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("twitchId", twitchId);
	}
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString twitchId; _jparser.validateByNameThrow("twitchId", twitchId);
		AtfValidator::validateInt(_descr, "twitchId", twitchId.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "twitchId"); size_t szTwitchId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "twitchId", szTwitchId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT
//=================================================================

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT()
{
	clear();
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::clear()
{
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::equals(const Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT& _o) const
{
	return true;
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_TWITCH_DISCONNECT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT*)_other));
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_TWITCH_DISCONNECT).append(")");
	return _buf.c_str();
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_TWITCH_DISCONNECT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TWITCH_DISCONNECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TWITCH_DISCONNECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY
//=================================================================

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY(Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY& LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY*)_other));
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errString);
	}
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errString);
	}
}

const char *LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtcClient::Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* LobbyEtcClient::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "ImageGallery"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY: _obj = new ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY(); break;
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY: _obj = new ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "MiniGameTickets"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA: _obj = new MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA(); break;
			case MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY: _obj = new MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY(); break;
			case MSG_LOBBYETC_GET_TICKETS_WITH_TYPE: _obj = new MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE(); break;
			case MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY: _obj = new MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "Twitch"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS: _obj = new Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS(); break;
			case MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY: _obj = new Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY(); break;
			case MSG_LOBBYETC_CLI_TWITCH_CONNECT: _obj = new Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT(); break;
			case MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY: _obj = new Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY(); break;
			case MSG_LOBBYETC_CLI_TWITCH_DISCONNECT: _obj = new Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT(); break;
			case MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY: _obj = new Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT: _obj = new player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT(); break;
			case MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY: _obj = new player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY(); break;
			case MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT: _obj = new player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT(); break;
			case MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS: _obj = new player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS(); break;
			case MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION: _obj = new player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION(); break;
			case MSG_LOBBYETC_CLI_RECONNECT: _obj = new player::Protocol_MSG_LOBBYETC_CLI_RECONNECT(); break;
			case MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT: _obj = new player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT(); break;
			case MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION: _obj = new player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION(); break;
			case MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION: _obj = new player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION(); break;
			case MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF: _obj = new player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF(); break;
			case MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID: _obj = new player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID(); break;
			case MSG_LOBBYETC_GEOCOMPLY_LOCATE: _obj = new player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE(); break;
		}
	}
	
	return _obj;
}

/* static */ bool LobbyEtcClient::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "ImageGallery"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY: ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY: ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "MiniGameTickets"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA: MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY: MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_TICKETS_WITH_TYPE: MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY: MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "Twitch"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS: Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY: Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TWITCH_CONNECT: Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY: Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TWITCH_DISCONNECT: Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY: Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT: player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY: player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT: player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS: player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION: player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_RECONNECT: player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT: player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION: player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION: player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF: player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID: player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GEOCOMPLY_LOCATE: player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool LobbyEtcClient::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "ImageGallery"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY: ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY: ImageGallery::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "MiniGameTickets"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA: MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY: MiniGameTickets::Protocol_MSG_LOBBYETC_CLI_GET_MG_MY_STARS_DATA_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_TICKETS_WITH_TYPE: MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY: MiniGameTickets::Protocol_MSG_LOBBYETC_GET_TICKETS_WITH_TYPE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "Twitch"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS: Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY: Twitch::Protocol_MSG_LOBBYETC_CLI_CHECK_TWITCH_CONNECTION_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TWITCH_CONNECT: Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY: Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_CONNECT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TWITCH_DISCONNECT: Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY: Twitch::Protocol_MSG_LOBBYETC_CLI_TWITCH_DISCONNECT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT: player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY: player::Protocol_MSG_LOBBYETC_CLI_MG_SIDEBET_HISTORY_AUDIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT: player::Protocol_MSG_LOBBYETC_CLI_NOTIF_GEOIP_RESULT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS: player::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_REQUIRED_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION: player::Protocol_MSG_LOBBYETC_CLI_OUTBOUND_BOLDCHAT_NOTIFICATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_RECONNECT: player::Protocol_MSG_LOBBYETC_CLI_RECONNECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT: player::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION: player::Protocol_MSG_LOBBYETC_CLI_START_MOBILE_VERIFICATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION: player::Protocol_MSG_LOBBYETC_CLI_UNSOLICITED_NOTIFICATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF: player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_NOTIF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID: player::Protocol_MSG_LOBBYETC_GENERAL_CLIENT_ERROR_WITH_CLIENT_ID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GEOCOMPLY_LOCATE: player::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

