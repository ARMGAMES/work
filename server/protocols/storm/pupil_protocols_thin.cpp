/**
 * pupil_protocols_thin.cpp
 *
 * This file was auto-generated from pupil_protocols.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin pupil_protocols.txt
 */
 
#include "pupil_protocols_thin.h"

//=================================================================
//                    GameStaticLeaf
//=================================================================

//=================================================================
//                _VisibilityType
//=================================================================

_PupilThin::GameStaticLeaf::_VisibilityType::_VisibilityType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

_PupilThin::GameStaticLeaf::_VisibilityType::_VisibilityType(_VisibilityType&& _o)
	: brand(std::move(_o.brand))
	, siteObsolete(std::move(_o.siteObsolete))
	, excludeCountries(std::move(_o.excludeCountries))
	, countries(std::move(_o.countries))
	, criteria(std::move(_o.criteria))
	, siteMask(std::move(_o.siteMask))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

_PupilThin::GameStaticLeaf::_VisibilityType& _PupilThin::GameStaticLeaf::_VisibilityType::operator=(_VisibilityType&& _o)
{
	if(this != &_o)
	{
		brand = std::move(_o.brand);
		siteObsolete = std::move(_o.siteObsolete);
		excludeCountries = std::move(_o.excludeCountries);
		countries = std::move(_o.countries);
		criteria = std::move(_o.criteria);
		siteMask = std::move(_o.siteMask);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void _PupilThin::GameStaticLeaf::_VisibilityType::clear()
{
	brand = 0;
	siteObsolete = 0;
	excludeCountries = false;
	countries.clear();
	criteria.clear();
	siteMask.clear();
	_is_empty_internal = true;
}

bool _PupilThin::GameStaticLeaf::_VisibilityType::equals(const _VisibilityType& _o) const
{
	return brand == _o.brand &&
		siteObsolete == _o.siteObsolete &&
		excludeCountries == _o.excludeCountries &&
		countries.equals(_o.countries) &&
		criteria.equals(_o.criteria) &&
		siteMask.equals(_o.siteMask);
}

const char *_PupilThin::GameStaticLeaf::_VisibilityType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("brand=");
		_buf.appendUint(brand);
		_buf.append(',');
		_buf.append("siteObsolete=");
		_buf.appendUint(siteObsolete);
		_buf.append(',');
		_buf.append("excludeCountries=");
		_buf.appendUint(excludeCountries);
		_buf.append(',');
		_buf.append("countries=");
		countries.toTraceString(_buf);
		_buf.append(',');
		_buf.append("criteria=");
		_buf.append(criteria);
		_buf.append(',');
		_buf.append("siteMask=");
		siteMask.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void _PupilThin::GameStaticLeaf::_VisibilityType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeUINT32(brand);
		_msg0.composeUINT32(siteObsolete);
		CommMsgBody _msg1;
		_msg1.composeBOOL(excludeCountries);
		countries.composeMsg(_msg1);
		_msg0.composeMsgBody(_msg1);
		_msg0.composeString(criteria);
		siteMask.composeMsg(_msg0);
	}

	_msg.composeMsgBody(_msg0);
}

void _PupilThin::GameStaticLeaf::_VisibilityType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(brand);
	_parser0.parseUINT32(siteObsolete);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseStringP(criteria);
	siteMask.parseMsg(_parser0);
}

/*static*/ void _PupilThin::GameStaticLeaf::_VisibilityType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	UINT32 brand; _parser0.parseUINT32(brand);
	AtfValidator::validateInt(_descr, "brand", brand, _checker, __FILE__, __LINE__);
	UINT32 siteObsolete; _parser0.parseUINT32(siteObsolete);
	AtfValidator::validateInt(_descr, "siteObsolete", siteObsolete, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("siteMask"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void _PupilThin::GameStaticLeaf::_VisibilityType::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(excludeCountries);
	countries.parseMsg(_parser0);
}

/*static*/ void _PupilThin::GameStaticLeaf::_VisibilityType::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool excludeCountries; _parser0.parseBOOL(excludeCountries);
	AtfValidator::validateInt(_descr, "excludeCountries", excludeCountries, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCountries = ThinAtf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _SampleType
//=================================================================

_PupilThin::GameStaticLeaf::_SampleType::_SampleType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

_PupilThin::GameStaticLeaf::_SampleType::_SampleType(_SampleType&& _o)
	: tournId(std::move(_o.tournId))
	, serverAddr(std::move(_o.serverAddr))
	, serverObject(std::move(_o.serverObject))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

_PupilThin::GameStaticLeaf::_SampleType& _PupilThin::GameStaticLeaf::_SampleType::operator=(_SampleType&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		serverAddr = std::move(_o.serverAddr);
		serverObject = std::move(_o.serverObject);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void _PupilThin::GameStaticLeaf::_SampleType::clear()
{
	tournId = 0;
	serverAddr.clear();
	serverObject.clear();
	_is_empty_internal = true;
}

bool _PupilThin::GameStaticLeaf::_SampleType::equals(const _SampleType& _o) const
{
	return tournId == _o.tournId &&
		serverAddr.equals(_o.serverAddr) &&
		serverObject.equals(_o.serverObject);
}

const char *_PupilThin::GameStaticLeaf::_SampleType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("serverAddr=");
		_buf.append(serverAddr);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	_buf.append('}');
	return _buf.c_str();
}

void _PupilThin::GameStaticLeaf::_SampleType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeUINT32(tournId);
		_msg0.composeString(serverAddr);
		_msg0.composeString(serverObject);
	}

	_msg.composeMsgBody(_msg0);
}

void _PupilThin::GameStaticLeaf::_SampleType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(serverAddr);
	_parser0.parseStringP(serverObject);
}

/*static*/ void _PupilThin::GameStaticLeaf::_SampleType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverAddr"); size_t szServerAddr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddr", szServerAddr, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

_PupilThin::GameStaticLeaf::GameStaticLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

_PupilThin::GameStaticLeaf::GameStaticLeaf(GameStaticLeaf&& _o)
	: visible(std::move(_o.visible))
	, regOpen(std::move(_o.regOpen))
	, gameId(std::move(_o.gameId))
	, visibility(std::move(_o.visibility))
	, sample(std::move(_o.sample))
	, name(std::move(_o.name))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, speedDisplay(std::move(_o.speedDisplay))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, prizePool(std::move(_o.prizePool))
	, prizePoolUnit(std::move(_o.prizePoolUnit))
	, prizePoolMoneyValue(std::move(_o.prizePoolMoneyValue))
	, playerPerTable(std::move(_o.playerPerTable))
	, minPlayers(std::move(_o.minPlayers))
	, maxUserRequests(std::move(_o.maxUserRequests))
	, customSpeedDisplayName(std::move(_o.customSpeedDisplayName))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
{
}

_PupilThin::GameStaticLeaf& _PupilThin::GameStaticLeaf::operator=(GameStaticLeaf&& _o)
{
	if(this != &_o)
	{
		visible = std::move(_o.visible);
		regOpen = std::move(_o.regOpen);
		gameId = std::move(_o.gameId);
		visibility = std::move(_o.visibility);
		sample = std::move(_o.sample);
		name = std::move(_o.name);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		speedDisplay = std::move(_o.speedDisplay);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		prizePool = std::move(_o.prizePool);
		prizePoolUnit = std::move(_o.prizePoolUnit);
		prizePoolMoneyValue = std::move(_o.prizePoolMoneyValue);
		playerPerTable = std::move(_o.playerPerTable);
		minPlayers = std::move(_o.minPlayers);
		maxUserRequests = std::move(_o.maxUserRequests);
		customSpeedDisplayName = std::move(_o.customSpeedDisplayName);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
	}
	return *this;
}

#endif

void _PupilThin::GameStaticLeaf::clear()
{
	visible = false;
	regOpen = false;
	gameId = 0;
	visibility.clear();
	sample.clear();
	name.clear();
	handType = 0;
	structure = 0;
	isHiLo = false;
	speedDisplay = 0;
	isPlayMoney = false;
	currency.clear();
	buyIn = 0;
	rake = 0;
	prizePool = 0;
	prizePoolUnit = 0;
	prizePoolMoneyValue = 0;
	playerPerTable = 0;
	minPlayers = 0;
	maxUserRequests = 0;
	customSpeedDisplayName.clear();
	tournFlags = 0;
	tournFlags2 = 0;
	tournFlagsServInt = 0;
}

bool _PupilThin::GameStaticLeaf::equals(const GameStaticLeaf& _o) const
{
	return visible == _o.visible &&
		regOpen == _o.regOpen &&
		gameId == _o.gameId &&
		visibility.equals(_o.visibility) &&
		sample.equals(_o.sample) &&
		name.equals(_o.name) &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		speedDisplay == _o.speedDisplay &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		prizePool == _o.prizePool &&
		prizePoolUnit == _o.prizePoolUnit &&
		prizePoolMoneyValue == _o.prizePoolMoneyValue &&
		playerPerTable == _o.playerPerTable &&
		minPlayers == _o.minPlayers &&
		maxUserRequests == _o.maxUserRequests &&
		customSpeedDisplayName.equals(_o.customSpeedDisplayName) &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		tournFlagsServInt == _o.tournFlagsServInt;
}

const char *_PupilThin::GameStaticLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("visible=");
	_buf.appendUint(visible);
	if( visible )
	{
		_buf.append(',');
		_buf.append("regOpen=");
		_buf.appendUint(regOpen);
		_buf.append(',');
		_buf.append("gameId=");
		_buf.appendUint(gameId);
		_buf.append(',');
		_buf.append("visibility=");
		visibility.toTraceString(_buf);
		_buf.append(',');
		_buf.append("sample=");
		sample.toTraceString(_buf);
		_buf.append(',');
		_buf.append("name=");
		ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
		_buf.append(',');
		_buf.append("handType=");
		_buf.appendUint(handType);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendInt64(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendInt64(rake);
		_buf.append(',');
		_buf.append("prizePool=");
		_buf.appendInt64(prizePool);
		_buf.append(',');
		_buf.append("prizePoolUnit=");
		_buf.appendUint(prizePoolUnit);
		_buf.append(',');
		_buf.append("prizePoolMoneyValue=");
		_buf.appendInt64(prizePoolMoneyValue);
		_buf.append(',');
		_buf.append("playerPerTable=");
		_buf.appendUint(playerPerTable);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxUserRequests=");
		_buf.appendUint(maxUserRequests);
		_buf.append(',');
		_buf.append("customSpeedDisplayName=");
		ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, customSpeedDisplayName);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
		_buf.append(',');
		_buf.append("tournFlagsServInt=");
		_buf.appendUint(tournFlagsServInt);
	}
	_buf.append('}');
	return _buf.c_str();
}

void _PupilThin::GameStaticLeaf::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(visible);
	if( visible )
	{
		_msg.composeBOOL(regOpen);
		_msg.composeUINT32(gameId);
		visibility.composeMsg(_msg);
		sample.composeMsg(_msg);
		name.compose(_msg);
		_msg.composeBYTE(handType);
		_msg.composeBYTE(structure);
		_msg.composeBOOL(isHiLo);
		_msg.composeBYTE(speedDisplay);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeString(currency);
		_msg.composeINT64(buyIn);
		_msg.composeINT64(rake);
		_msg.composeINT64(prizePool);
		_msg.composeBYTE(prizePoolUnit);
		_msg.composeINT64(prizePoolMoneyValue);
		_msg.composeBYTE(playerPerTable);
		_msg.composeUINT32(minPlayers);
		_msg.composeBYTE(maxUserRequests);
		customSpeedDisplayName.compose(_msg);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT64(tournFlags2);
		_msg.composeUINT32(tournFlagsServInt);
	}
}

void _PupilThin::GameStaticLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(visible);
	if( visible )
	{
		_parser.parseBOOL(regOpen);
		_parser.parseUINT32(gameId);
		visibility.parseMsg(_parser);
		sample.parseMsg(_parser);
		name.parse(_parser);
		_parser.parseBYTE(handType);
		_parser.parseBYTE(structure);
		_parser.parseBOOL(isHiLo);
		_parser.parseBYTE(speedDisplay);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseStringP(currency);
		_parser.parseINT64(buyIn);
		_parser.parseINT64(rake);
		_parser.parseINT64(prizePool);
		_parser.parseBYTE(prizePoolUnit);
		_parser.parseINT64(prizePoolMoneyValue);
		_parser.parseBYTE(playerPerTable);
		_parser.parseUINT32(minPlayers);
		_parser.parseBYTE(maxUserRequests);
		customSpeedDisplayName.parse(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT64(tournFlags2);
		_parser.parseUINT32(tournFlagsServInt);
	}
}

/*static*/ void _PupilThin::GameStaticLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool visible = false;
	_parser.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	if( visible )
	{
		bool regOpen; _parser.parseBOOL(regOpen);
		AtfValidator::validateInt(_descr, "regOpen", regOpen, _checker, __FILE__, __LINE__);
		UINT32 gameId; _parser.parseUINT32(gameId);
		AtfValidator::validateInt(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
		PString _descbuf;
		_VisibilityType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibility"), _fieldsWithUnparsedContent);
		_SampleType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sample"), _fieldsWithUnparsedContent);
		I18nPString name; name.parse(_parser);
		BYTE handType; _parser.parseBYTE(handType);
		AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		INT64 buyIn; _parser.parseINT64(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		INT64 rake; _parser.parseINT64(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		INT64 prizePool; _parser.parseINT64(prizePool);
		AtfValidator::validateInt(_descr, "prizePool", prizePool, _checker, __FILE__, __LINE__);
		BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
		AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
		INT64 prizePoolMoneyValue; _parser.parseINT64(prizePoolMoneyValue);
		AtfValidator::validateInt(_descr, "prizePoolMoneyValue", prizePoolMoneyValue, _checker, __FILE__, __LINE__);
		BYTE playerPerTable; _parser.parseBYTE(playerPerTable);
		AtfValidator::validateInt(_descr, "playerPerTable", playerPerTable, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		BYTE maxUserRequests; _parser.parseBYTE(maxUserRequests);
		AtfValidator::validateInt(_descr, "maxUserRequests", maxUserRequests, _checker, __FILE__, __LINE__);
		I18nPString customSpeedDisplayName; customSpeedDisplayName.parse(_parser);
		if(_parser.parseEnded()) return;
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    GameDynamicLeaf
//=================================================================

_PupilThin::GameDynamicLeaf::GameDynamicLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

_PupilThin::GameDynamicLeaf::GameDynamicLeaf(GameDynamicLeaf&& _o)
	: numUsersWaiting(std::move(_o.numUsersWaiting))
	, numUsersPlaying(std::move(_o.numUsersPlaying))
	, numUsersRegistered(std::move(_o.numUsersRegistered))
	, numDistinctUsersWaiting(std::move(_o.numDistinctUsersWaiting))
	, numActiveGames(std::move(_o.numActiveGames))
{
}

_PupilThin::GameDynamicLeaf& _PupilThin::GameDynamicLeaf::operator=(GameDynamicLeaf&& _o)
{
	if(this != &_o)
	{
		numUsersWaiting = std::move(_o.numUsersWaiting);
		numUsersPlaying = std::move(_o.numUsersPlaying);
		numUsersRegistered = std::move(_o.numUsersRegistered);
		numDistinctUsersWaiting = std::move(_o.numDistinctUsersWaiting);
		numActiveGames = std::move(_o.numActiveGames);
	}
	return *this;
}

#endif

void _PupilThin::GameDynamicLeaf::clear()
{
	numUsersWaiting = 0;
	numUsersPlaying = 0;
	numUsersRegistered = 0;
	numDistinctUsersWaiting = 0;
	numActiveGames = 0;
}

bool _PupilThin::GameDynamicLeaf::equals(const GameDynamicLeaf& _o) const
{
	return numUsersWaiting == _o.numUsersWaiting &&
		numUsersPlaying == _o.numUsersPlaying &&
		numUsersRegistered == _o.numUsersRegistered &&
		numDistinctUsersWaiting == _o.numDistinctUsersWaiting &&
		numActiveGames == _o.numActiveGames;
}

const char *_PupilThin::GameDynamicLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsersWaiting=");
	_buf.appendUint(numUsersWaiting);
	_buf.append(',');
	_buf.append("numUsersPlaying=");
	_buf.appendUint(numUsersPlaying);
	_buf.append(',');
	_buf.append("numUsersRegistered=");
	_buf.appendUint(numUsersRegistered);
	_buf.append(',');
	_buf.append("numDistinctUsersWaiting=");
	_buf.appendUint(numDistinctUsersWaiting);
	_buf.append(',');
	_buf.append("numActiveGames=");
	_buf.appendUint(numActiveGames);
	_buf.append('}');
	return _buf.c_str();
}

void _PupilThin::GameDynamicLeaf::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(numUsersWaiting);
	_msg.composeUINT32(numUsersPlaying);
	_msg.composeUINT32(numUsersRegistered);
	_msg.composeUINT32(numDistinctUsersWaiting);
	_msg.composeUINT32(numActiveGames);
}

void _PupilThin::GameDynamicLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(numUsersWaiting);
	_parser.parseUINT32(numUsersPlaying);
	_parser.parseUINT32(numUsersRegistered);
	_parser.parseUINT32(numDistinctUsersWaiting);
	_parser.parseUINT32(numActiveGames);
}

/*static*/ void _PupilThin::GameDynamicLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 numUsersWaiting; _parser.parseUINT32(numUsersWaiting);
	AtfValidator::validateInt(_descr, "numUsersWaiting", numUsersWaiting, _checker, __FILE__, __LINE__);
	UINT32 numUsersPlaying; _parser.parseUINT32(numUsersPlaying);
	AtfValidator::validateInt(_descr, "numUsersPlaying", numUsersPlaying, _checker, __FILE__, __LINE__);
	UINT32 numUsersRegistered; _parser.parseUINT32(numUsersRegistered);
	AtfValidator::validateInt(_descr, "numUsersRegistered", numUsersRegistered, _checker, __FILE__, __LINE__);
	UINT32 numDistinctUsersWaiting; _parser.parseUINT32(numDistinctUsersWaiting);
	AtfValidator::validateInt(_descr, "numDistinctUsersWaiting", numDistinctUsersWaiting, _checker, __FILE__, __LINE__);
	UINT32 numActiveGames; _parser.parseUINT32(numActiveGames);
	AtfValidator::validateInt(_descr, "numActiveGames", numActiveGames, _checker, __FILE__, __LINE__);
}

