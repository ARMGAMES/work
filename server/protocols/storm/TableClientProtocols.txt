#include "table.h"
#include "brands.h"
#include "UserDefStructs.h"
#include "TableCommonStructs${ATF_THIN_FILENAME_SUFFIX}.h"
#include "atfgenerated/brandimgs${ATF_THIN_FILENAME_SUFFIX}.h"
#include "tournmilestoneprize.h"
#include "mtlobby/TournCommonStructs${ATF_THIN_FILENAME_SUFFIX}.h"

#define TOP_LEVEL_NAMESPACE TableClient${ATF_THIN_NAMESPACE_SUFFIX}

//  aliases list: (see https://confluence.pyrsoftware.ca/confluence/x/fF58Ag )
//
//  userId - u
//  userIntId - uI
//  seat - s
//  amount - v
//  action - a - finished here
//  min value - mn
//  max value - mx
//  seqId - sq
//  timeout - TO
//  handId - hI
//  tableId - tI
//  timebank - tb
//  handType (gameId) - gm
//  loBet - lb
//  hiBet- hb
//  smallBlind - sb
//  bigBlind - bb
//  buyIn - bI
//  potStruct (limit) - lm
//  power - p
//  powerId - pI


struct PubBoardCardPosition
{
	INT8   boardNumber; // 0..2
	INT8   cardNumber;  // 0..6

	@Override PubBoardCardPosition(int boardNum_, int cardNum_)
	{
		boardNumber = static_cast< INT8 >( boardNum_ );
		cardNumber = static_cast< INT8 >( cardNum_ );
	}
};
	
struct P_PlayerCardShown
{
	char suit;
	BYTE rank;
	BYTE shown;
};

struct P_PlayerBetOption
{
	char act;
	UINT32 amount alias v;
};

struct P_PlayerRequestAction
{
	char action alias a;
	UINT32 amountMin alias vMn;
	UINT32 amountMax alias vMx;
	UINT32 amountStep default 100 alias vStep;
	UINT32 chipQuantum default 1;

	@Override void composeMsg(CommMsgBody& _msg, bool _ignoreJSON = COMPOSEMSG_IGNORE_JSON_DEFAULT) const  // @no_thin_version
	{
		if(amountMin == amountMax)
		{
			_msg.composeINT8(action);
			_msg.composeUINT32(amountMin);
		}
		else
		{
			_msg.composeINT8('*');
			_msg.composeINT8(action);
			_msg.composeUINT32(amountMin);
			_msg.composeUINT32(amountMax);
			_msg.composeUINT32(amountStep);
			_msg.composeUINT32(chipQuantum);
		}
	}

	@Override void composeMsg(CommMsgBody& _msg) const  // @only_thin_version
	{
		if(amountMin == amountMax)
		{
			_msg.composeINT8(action);
			_msg.composeUINT32(amountMin);
		}
		else
		{
			_msg.composeINT8('*');
			_msg.composeINT8(action);
			_msg.composeUINT32(amountMin);
			_msg.composeUINT32(amountMax);
			_msg.composeUINT32(amountStep);
			_msg.composeUINT32(chipQuantum);
		}
	}

	@Override void parseMsg(CommMsgParser& _parser)
	{
		INT8 n;
		_parser.parseINT8(n);

		if (n == '*')
		{
			_parser.parseINT8(n);
			action = n;
			_parser.parseUINT32(amountMin);
			_parser.parseUINT32(amountMax);
			_parser.parseUINT32(amountStep);
			_parser.parseUINT32(chipQuantum);
		}
		else
		{
			action = n;
			_parser.parseUINT32(amountMin);
			amountMax = amountMin;
		}
	}
};


struct P_SuscrPlayerCards
{
	INT8 seat default -1 alias s;
	BYTE numOfCards;
};

struct P_PotInfo
{
	INT8 seat default -1 alias s; 
	UINT32 amount alias v;
};

struct P_BOUNTY_GREETINGS
{
    UINT32 amount alias v;
    PString bountyLoser;
};


struct CardWithPosition
{
	BYTE pos;
	TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card card;
};

struct CardInfo
{
	INT8 playerOrboard;  // 0-9: player seat, -1: board number before RIT starts, -2: first board, -3: second board 
	BYTE pos;
	TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card card;
};

MsgBodyStruct CardInfoBody
{
	CardInfo c;
};

MsgBodyStruct TotalBetInfo
{
	INT64 sumOfBets parseEndOptB4Me;
	INT64 netWon;
};
			
namespace player
{
	struct ClientMsg_TxtEx_NSF	// TODO: is this name okay?
	{
		UINT16 msgId default ClientMsg_NSF;
		INT32 minLimit;
		bool enoughMoneyInOtherCurrencies;
		BYTE clientServiceFlag;
		INT32 chips;
		PString currency;
		bool useAutoConvertBuyin;
		CommMsgBody clientCurrencyContextShort;
		CommMsgBody rebuyOrAddonData;
	};

	Message MSG_TABLE_LOGIN LGN
	{
		PString user maxlen 20 alias u;  // obsoleted by PYR-80360 
		UINT32 clientSiteId max PokerStars_Last alias site; // obsoleted by PYR-80360
		bool notShowWhenAllIn alias nshown;  // obsoleted by PYR-43014
		bool sitOutNextHand parseEndOptB4Me alias sitout;
		bool useAllInitStacks parseEndOptB4Me alias allstacks;
	};

	Message MSG_TABLE_LOGIN_REPLY LGNR
	{
		BYTE errcode;
		PString errstr;
		INT8 seat default -1 alias s;
		BYTE sittingStatus default SittingOut alias ss;
		PString clientIP ignoredInComparison alias ip;
		UINT32 waitingStatus alias ws;
		CommMsgBody clientMsg_txtEx alias m;
		INT8 autoRebuyOptions default _autoRebuyDisabled alias ar;
		UINT16 autoRebuyBigBets alias arBB;
		UINT16 autoRebuyFallUnderBigBets alias arFBB;
		UINT16 autoRebuyFallUnderPercents alias arFPct;
		bool playerRITFavored alias rit;
		bool campingPreventionEnabled alias camping;
		bool isTableDealingHands alias dealing;
		UINT16 campingCountingDownSec alias campSecs;
		bool allinCashoutNotFavored alias nco parseEndOptB4Me;
		UINT64 progressivePlusEntryId alias pppEId parseEndOptB4Me;
	};

	Message MSG_TABLE_LOGOUT LGO
	{
		// dummy message
	};

	Message MSG_TABLE_LOGOUT_REPLY LGOR
	{
		BYTE errcode;
		PString errstr;	
		TotalBetInfo totalBetInfo;  // dummy for tourn
	};
	
	Message MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE PBU
	{
		bool eligible;
		INT32 numPlayedHands;
		INT32 poolBlockMinHands;
		vector<INT32> poolBlockTimePenalty;
	};

	Message MSG_TABLE_SIT1  SIT1
	{
		INT8 seat default -1 alias s;   // default -1 // max 9 removed due to a client bug (client sends -1) described in PYR-59403
		UINT32 verifyKey; // not limited
	}; 

	Message MSG_TABLE_SIT1_REPLY SIT1R
	{
		BYTE errcode;
		PString errUser;
		UINT32 chips;
		UINT32 minLimit alias mnLim;
		UINT32 maxLimit alias mxLim;
		UINT32 chipQuantum alias cq;
		BYTE playAddedMask;
		UINT32 playAddedAmount;
		INT8 seat default -1 alias s;
		BYTE clientServiceFlag alias csf;
		CommMsgBody clientMsg_txtEx alias m;
		CommMsgBody currencyContextCli alias currency;
		UINT32 defaultBuyIn alias defaultBi;
		UINT32 ratHoleInSec alias rh; 
		UINT64 pmChips;
		UINT32 userRollId;
	};

	Message MSG_TABLE_SIT2 SIT2
	{
		INT32 chips min 0;
		PString pwd maxlen 100;		
		INT8 autoRebuyOpt min 0 max 100 alias ar;
		UINT16 autoRebuyBigBets max 1000 alias arBB;
		UINT16 autoRebuyFallUnderBigBets max 1000 alias arFBB;
		UINT16 autoRebuyFallUnderPercents max 100 alias arFPct;
		bool notShowWhenAllIn alias nshown;
		UINT32 realMoneyChips max 2000000000 alias rmChips;   // not used in Table server side
		bool runItTwice parseEndOptB4Me alias rit;
		bool allinCashoutNotFavored alias nco parseEndOptB4Me;
	};

	Message MSG_TABLE_SIT2_REPLY SIT2R
	{	
		BYTE errcode;
		PString errstr;
		BYTE sittingStatus alias ss;
		UINT32 waitingStatus alias ws;
		CommMsgBody clientMsg_txtEx alias m;
		UINT32 numOfSeats alias sz;
		INT32 chipsAfter;
	};

	Message MSG_TABLE_TIMEBANK TB
	{
		UINT32 timeBank max 1800 alias tb;
		bool hasChipsPosted parseEndOptB4Me; // MSG_TABLE_TIMEBANK could be inport or output messages, they differ
	};
	
	Message MSG_TABLE_WARNING_BELL BEL
	{
		INT32 delaySec;
	};
	
	Message MSG_TABLE_REQUESTACTION ARQ
	{
		vector01<P_PlayerRequestAction> actionOpts alias aOpts;
		UINT32 actionReqSeq alias seq;
		INT32 timeoutSec alias TO;
		bool isNewGame alias ng;
		INT32 gameRound;
	};
	
	//Message MSG_TABLE_PLAYERCARDS  // never logging   // client starts to retire this message in 2019 Main.02
	//{
	//	vector01<P_PlayerCardShown> playerCards;
	//	UINT32 specialServClient;
	//	UINT64 handId alias hI;
	//};
	
	//Message MSG_TABLE_PLAYERCARDS_DRAWSETS DRW   // client starts to retire this message in 2019 Main.02
	//{
	//	UINT64 handId alias hI;
	//	BYTE numSets;
	//	CommMsgBody	cardSetMsg;
	//
	//	@Override void composeMsg(CommMsgBody& _msg, bool _ignoreJSON = COMPOSEMSG_IGNORE_JSON_DEFAULT) const  // @no_thin_version
	//	{
	//		_msg.composeUINT64(handId);
	//		_msg.composeBYTE(numSets);
	//		_msg.merge(cardSetMsg);
	//	}
	//
	//	@Override void composeMsg(CommMsgBody& _msg) const  // @only_thin_version
	//	{
	//		_msg.composeUINT64(handId);
	//		_msg.composeBYTE(numSets);
	//		_msg.merge(cardSetMsg);
	//	}
	//
	//	@Override void parseMsg(CommMsgParser& _parser)
	//	{
	//		_parser.parseUINT64(handId);
	//		_parser.parseBYTE(numSets);
	//		cardSetMsg.copyMsgBodyFromParser(_parser);
	//		_parser.skip(cardSetMsg._size());
	//	}
	//};
	
	Message MSG_TABLE_ADDCHIPS_AUTO_REPLY ADDCHIPSAUTOR
	{
		BYTE errcode;
		PString errstr;
		UINT32 chipsAdded;
		CommMsgBody clientMsg_txtEx alias m;
		UINT32 italyReservedChips alias reserved;
	};
	
	Message MSG_TABLE_FORCE_SITOUT
	{
		BYTE errcode;
		PString errstr;
		BYTE sittingStatus;
		CommMsgBody clientMsg_txtEx alias m;
	};

	Message MSG_TABLE_ADVANCED_BET ADB 
	{
		vector01<P_PlayerBetOption> betOptions;
	};
	
	Message MSG_TABLE_STATISTIC STS
	{
		UINT32 statistic;
		UINT32 earnedVPP;
		UINT32 mileStoneAward;
		UINT64 handId alias hI;
		UINT32 vppThisHand;
	};
	
	Message MSG_TABLE_HAND_RANK  // nver logged
	{
		PString strHi;
		PString strLo;
		BYTE bestHigh;
		BYTE bestLow;
		PString strHi2 parseEndOptB4Me;
		BYTE bestHigh2; 
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cardsHigh ignoredInComparison parseEndOptB4Me;
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cardsLow ignoredInComparison;
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cardsHigh2 ignoredInComparison;
		PString strLo2 parseEndOptB4Me;
		BYTE bestLow2; 
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cardsLow2 ignoredInComparison;
	};
	
	//Message MSG_TABLE_FOLDCARDS  // never logged
	//{
	//	vector01< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > msgCards;
	//};
	
	Message MSG_TABLE_ADDCHIPS ADDCHIPS
	{
		INT32 chips min 0 max 2000000000;
		INT32 realMoneyChips min 0 max 2000000000 parseEndOptB4Me;
	};
	
	Message MSG_TABLE_ADDCHIPS_REPLY ADDCHIPSR
	{
		BYTE errcode;
		PString errstr;
		CommMsgBody clientMsg_txtEx alias m;
		UINT32 italyReservedChips alias reserved;
	};
	
	Message MSG_TABLE_REBUYCHIPS REBUYCHIPS
	{
		INT16 numRebuys default 1 min 0 max 10 parseEndOptB4Me;
	};
	
	Message MSG_TABLE_REBUYCHIPS_REPLY REBUYCHIPSR
	{
		BYTE errcode;
		if(errcode)
		{
			PString errstr;
			CommMsgBody clientMsg_txtEx alias m;
		}
		else
		{
			UINT32 chips;
			UINT32 money;
			UINT32 pChips;
			UINT32 fppTaken;
			UINT32 tChips;
			UINT32 wChips;
			UINT32 infoType; // 1==AAMS ticket
			PString info;
			UINT64 pChips64;
			UINT16 rebuysDone;
			UINT16 addonsDone;
			INT16 rebuysLeft;
			UINT32 finalFlightTournId;
			INT32 moneyAfter;
			INT32 realMoney;
			INT32 realTChips;
			INT32 tChipsAfter;
			TournCommon${ATF_THIN_NAMESPACE_SUFFIX}::TournSpendLimit tournSpendLimit parseEndOptB4Me;
		}
	};
	
	Message MSG_TABLE_ADDONCHIPS ADDON
	{
		// empty
	};
	
	Message MSG_TABLE_ADDONCHIPS_REPLY ADDONR
	{
		BYTE errcode;
		if(errcode)
		{
			PString errstr;
			CommMsgBody clientMsg_txtEx alias m;
		}
		else
		{
			UINT32 chips;
			UINT32 money;
			UINT32 pChips;
			UINT32 fppTaken;
			UINT32 tChips;
			UINT32 wChips;
			UINT32 infoType; // 1==AAMS ticket
			PString info;
			UINT64 pChips64;
			UINT16 rebuysDone;
			UINT16 addonsDone;
			INT16 rebuysLeft;
			UINT32 finalFlightTournId;
			INT32 moneyAfter;
			INT32 realMoney;
			INT32 realTChips;
			INT32 tChipsAfter;
			TournCommon${ATF_THIN_NAMESPACE_SUFFIX}::TournSpendLimit tournSpendLimit parseEndOptB4Me;
		}
	};
	
	Message MSG_TABLE_CHAT2 CHAT
	{
		PString chat maxlen 10000;
	};
	
	Message MSG_TABLE_CHAT2_REPLY CHATR
	{
		UINT16 errcode;
		CommMsgBody errMsgBody;
		PString chatmsg;
	};
	
	Message MSG_TABLE_SITIN SITIN
	{
		UINT32 flags parseEndOptB4Me;       // not used in table server; no limit
		UINT64 flagsEx;     // not used in table server; no limit
		bool isPlayMoney alias pm;   // not used in table server
	};
	
	Message MSG_TABLE_SITIN_REPLY SITINR
	{
		BYTE errcode;
		PString errstr;
		BYTE sittingStatus alias ss;
		UINT32 waitingStatus alias ws;
		CommMsgBody clientMsg_txtEx alias m;
	};
	
	Message MSG_TABLE_SITOUT SITOUT
	{
		UINT32 userFlags parseEndOptB4Me; // no limit
		UINT64 userFlagsEx; //no limit
		bool isPlayMoney;
	};
	
	Message MSG_TABLE_SITOUT_REPLY SITOUTR
	{
		BYTE errcode;
		PString errstr;
		BYTE sittingStatus alias ss;
		UINT16 campingCountingDownSec parseEndOptB4Me alias campSecs;
	};
	
	Message MSG_TABLE_SITOUT_NEXTHAND SITOUTNH
	{
		BYTE checked; // treated as bool, no limits
	};
	
	Message MSG_TABLE_CHIPSAVAIL CHIPSAVAIL
	{
		// empty
	};
	
	Message MSG_TABLE_CHIPSAVAIL_REPLY CHIPSAVAILR
	{
		BYTE errcode;
		PString errstr;
		UINT32 chips;
		UINT32 minLimit alias mnLim;
		UINT32 maxLimit alias mxLim;
		UINT32 quantum alias q;
		BYTE playAddedMask alias mask;
		UINT32 playAddedAmount alias amt;
		UINT32 chipsHandStart alias chipsHS;
		CommMsgBody clientMsg_txtEx alias m;
		CommMsgBody currencyContext alias currency;
		UINT32 ratHoleSeconds alias rh;
		UINT32 maxRebuyChips_It alias maxRebuy;
		UINT32 totalRebuys_It alias totRebuy;
		UINT64 pmChips;	//PYR-23052
		UINT32 userRollId alias rId;
	};
	
	Message MSG_TABLE_SET_AUTO_REBUY SETAREBUY
	{
		INT8 autoRebuyOpt min 0 max 100 alias ar;
		UINT16 bigBets max 1000 alias arBB;
		UINT16 underBigBets max 1000 alias arFBB;
		UINT16 underPercents max 100 alias arFPcnt;
	};
	
	Message MSG_TABLE_SET_AUTO_REBUY_REPLY SETAREBUYR
	{
		BYTE errcode;
	};
	
	Message MSG_TABLE_SET_SHOW_WHEN_ALLIN SETALLIN
	{
		bool notAllInShowAllowed alias opt;
	};
	
	Message MSG_TABLE_SET_DEAL SETDEAL
	{
		bool setOptions alias opt;
	};
	
	Message MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE SETRIT
	{
		bool runItTwice alias rit;
		bool allinCashoutNotFavored alias nco parseEndOptB4Me;
	};
	
	Message MSG_TABLE_REQUESTACTION_REPLY ARQR
	{
		// empty
	};
	
	Message MSG_TABLE_FAST_FOLD FASTFOLD
	{
		UINT64 handId alias hI; // not limited
		BYTE flags parseEndOptB4Me; // not limited
	};
	
	Message MSG_TABLE_GOTO_NEXTHAND GNEXTH
	{
		UINT64 handId alias hI; // not limited
	};
	
	Message MSG_TABLE_REFRESH REFRESH
	{
		// empty
	};
	
	Message MSG_TABLE_REFRESH_REPLY REFRESH_REPLY
	{
		UINT32 italyReservedChips;
	};
	
	Message MSG_TABLE_PLAYNOW PLAYNOW
	{
		// empty
	};
	
	Message MSG_TABLE_ENTROPY  // never logged
	{
		PBlock enthropy maxsize 8192;
	};
	
	Message MSG_TABLE_GET_DEAL GETDEAL
	{
		// empty
	};
	
	Message MSG_TABLE_GET_DEAL_REPLY GETDEALR
	{
		bool dealOptionSet;
	};
	
	Message MSG_TABLE_ACTION ACT
	{
		char action min 0x20 max 'z' alias a; // 0x20 represents ' '
		UINT32 amount max 2000000000 alias v;
		UINT32 actionId parseEndOptB4Me alias seq; // id not limited
		BYTE flags parseEndOptB4Me;
		
		@Override void composeMsg(CommMsgBody& _body, bool _ignoreJSON = true) const   // @no_thin_version
		{
			_body.composeINT8(action);
			_body.composeUINT32(amount);
			if (actionId != 0)
			{
				_body.composeUINT32(actionId);
				_body.composeBYTE(flags);
			}
		}
		
		@Override void composeMsg(CommMsgBody& _body) const   // @only_thin_version
		{
			_body.composeINT8(action);
			_body.composeUINT32(amount);
			if (actionId != 0)
			{
				_body.composeUINT32(actionId);
				_body.composeBYTE(flags);
			}
		}
	};
	
	Message MSG_TABLE_CANCELACTION CXACT
	{
		BYTE errcode;
		PString errstr;
		bool isActionTimedOut default true parseEndOptB4Me alias to;  // non-storm table server won't compose this field
	};
	
	Struct TournPlayerKickMsgExtraShared
	{
		PString socialToken alias token;
		UINT32 nextRecurringTournId alias nextId;
		if( nextRecurringTournId )
		{
			TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_ScheduledTournament nextSchedTourn;
		}
		UINT32 headBounty;
	};
	
	Struct TableSitKickMsgEx  // will be composed into clientMsg_txtEx msgbody
	{
		UINT16 msgId;

		if(msgId == ClientMsg_Tournmt_Winner)
		{
			TournPlayerKickMsgExtraShared tpkes;
			PString str_popup;
			UINT32 msgServiceBitMask;
			INT32 award;
		}
		else if(msgId == ClientMsg_Tournmt_Kicked)
		{
			UINT32 placeI;
			TournPlayerKickMsgExtraShared tpkes;
			PString str_popup;
			UINT32 msgServiceBitMask;
			INT32 award;
		}
		else if(msgId == ClientMsg_Tournmt_Flight_Winner)
		{
			UINT32 tournId;
			PString nextFlightTargetServer;
			I18nPString nextFlightTournName;
			PString str_popup;
			UINT32 msgServiceBitMask;
			INT32 award;
		}
		else if(msgId == ClientMsg_Tournmt_Kicked_Popup)
		{
			UINT32 placeI;
			PString str_popup;
			TournPlayerKickMsgExtraShared tpkes;
			PString str_popup2; // duplicated version of str_popup
			UINT32 msgServiceBitMask;
			INT32 award;
		}
		else if(msgId == ClientMsg_Tournmt_Sag_Winner_Custom_Prize)
		{
			UINT32 placeI;
			PString str_popup;
			PString socialToken;
			PString str_popup2; // duplicated version of str_popup
			UINT32 msgServiceBitMask;
			INT32 award;
		}
		else if(msgId == ClientMsg_Action_Kicked_Ante)
		{
			INT32 numMissedOrbits;
		}
		else if(msgId == ClientMsg_Action_Kicked_BBlinds)
		{
			INT32 numMissedOrbits;
		}
		//else if( msgId == ClientMsg_Action_Kicked_MultiGame)
		//{
			// empty
		//}
		//else if( msgId == ClientMsg_Kick_GeoIP_Unknown )
		//{
			// empty
		//}
		//else if( msgId == ClientMsg_Kick_Action_Kicked_ByAdmin )
		//{
			// empty
		//}
		//else if( msgId == ClientMsg_Kick_Action_Kicked_ByAdmin_Silent )
		//{
			// empty
		//}
		//else if( msgId == ClientMsg_Player_Kick_Camping_Timeout )
		//{
			// empty
		//}
		//else if( msgId == ClientMsg_Player_Kick_No_Blind_Posted )
		//{
			// empty
		//}

		INT32 bounty;
		SrvTime reEntryDeadline parseEndOptB4Me; // PYR-50362
		INT32 chips	parseEndOptB4Me; // PYR-103089
		INT32 targetChips parseEndOptB4Me; // PYR-103089
		UINT32 progressivePlusInitialBuyInTierId parseEndOptB4Me; // PYR-123713
	};

	Message MSG_TABLE_SIT_KICK SITKICK
	{
		PString kickstr;

		CommMsgBody clientMsg_txtEx alias m;

		TotalBetInfo totalBetInfo;  // dummy for tourn
		bool forceCloseTable;
	};
	
	Message MSG_TABLE_SIT2_KICK SIT2KICK
	{
		PString kickstr;
		CommMsgBody clientMsg_txtEx alias m;
	};
	
	Message MSG_TABLE_MTT_CHANGETABLE CHGTBL
	{
		BYTE errcode;
		PString msg;
	};
	
	Message MSG_TABLE_ADMIN_INFO
	{
		PString errstr;
		CommMsgBody clientMsg_txtEx alias m;
	};
	
	Message MSG_TABLE_SAGMAX_USER_DRAW SAGDRAW
	{
		INT32 action alias a;
	};

	Message MSG_TABLE_SITTING_STATUS SS
	{
		BYTE sittingStatus alias ss;
	};

	Message MSG_TABLE_BOUNTY_GREETINGS BNTY
	{
		vector04<P_BOUNTY_GREETINGS> vec;
		UINT32 goldenSngBountyStub; // obsolete
	};
	
	Message MSG_TABLE_START_CAMPING_PREVENTION STCAMP
	{
		UINT16 campingTimeOut alias campingTO;
		BYTE sittingStatus alias ss;
	};
	
	Message MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY ARSTACK
	{
		UINT32 stacksReloaded;
	};

	Message MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS CHSSTACK
	{
		INT32 unusedStacks;
	};

	Message MSG_TABLE_NSTACK_RELOAD RLDSTACK
	{
		UINT32 reqStacks max 16 alias s;
	};

	Message MSG_TABLE_NSTACK_RELOAD_REPLY RLDSTACKR
	{
		BYTE errcode;
		if(errcode)
		{
			PString errDesc;
			CommMsgBody errMsgBody;
		}
		else
		{
			INT32 unusedStacks;
		}
	};

	Message MSG_TABLE_BLITZ_MTT_KICK BMKICK
	{
		bool sittingIn;
		UINT16 rebuyLeft;
		UINT32 rebuyTimeout alias rebuyTO;
		BYTE limboAction;
		UINT16 actionAmount alias actAmount;
		UINT32 actionTimeout alias actTO;
	};
	
	struct PlayerNotifI18NMsg
	{
		I18nPString str;
		UINT32 msgSeqId alias msgSq;

		@Override bool operator<( const PlayerNotifI18NMsg& other ) const
		{
			return msgSeqId < other.msgSeqId;
		}
	};

	Message MSG_TABLE_USER_SPECIFIC_BROADCAST USERSPEC
	{
		vector<PlayerNotifI18NMsg> notifs;
	};

	Message MSG_TABLE_USER_CHAT_WARN CHATWARN
	{
		UINT16 warnMsgId;
		PString chat;
	};

	Message MSG_TABLE_USER_CHAT_BAN CHATBAN
	{
		UINT16 banMsgId;
		INT32 banTimeMins;
	};

	MsgBodyStruct HoleCardSnapshot
	{
		INT8 round;
		l1vector<TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::CardDictionaryItem> holeCards;
	};

	Message MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE  // never logged
	{
		UINT64 handId alias hI;
		l1vector<TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::CardDictionaryItem> myHoleCards;
		l1vector<TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::CardDictionaryItem> otherCards;  // could be the old hole cards mapping or sensed cards in power-up
		l1vector<HoleCardSnapshot> oldHoleCards parseEndOptB4Me;  // for draw or swap game (empty if no card drawn)
	};

	MsgBodyStruct UserDictionaryItem
	{
		PString alias;
		PString userId;
		BrandProt${ATF_THIN_NAMESPACE_SUFFIX}::BrandImageList img;
	};

	Message MSG_TABLE_USER_DICTIONARY_UPDATE
	{
		UINT64 handId;  // currently not used
		vector<UserDictionaryItem> users;
	};
		
	Message MSG_TABLE_BLITZ_KICK BKICK
	{
		UINT64 handId alias hI;
		UINT32 statistcs alias stat;
		UINT32 chips;
		UINT32 kickUserFlags alias flags;
	};


	//=====================================
	
	
	Message MSG_TABLE_POWER_CHOOSE_POWER_SLOTS
	{
		UINT32 powerActionSeqId alias pasq;
		INT32 powerId alias pI;
		UINT32 timerInterval;
		BYTE minPowersChosen;
		BYTE maxPowersChosen;
		vector< INT32 > powers;
	};
	
	Message MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK
	{
		UINT32 powerActionSeqId alias pasq;
	};

	Message MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY
	{
		UINT32 powerActionSeqId alias pasq;
		vector< INT32 > powersChosen;
	};
	
	Message MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL
	{
		UINT32 powerActionSeqId alias pasq;
	};
	
	MsgBodyStruct PowerInfoBody
	{
		INT32 powerId alias pI;
		UINT32 status;
		INT32 powerCardUniqueId alias puId;
	};
	
	Message MSG_TABLE_POWER_POSSESSION
	{
		vector< PowerInfoBody > powers;
	};
	
	MsgBodyStruct PowerStatus
	{
		INT32 powerId alias pI;
		UINT32 newStatus alias ns;
		INT32 powerCardUniqueId alias puId;
	};
		
	Message MSG_TABLE_POWER_STATUS_UPDATE T_POW_SU
	{
		vector<PowerStatus> updates;

	};
	
	Message MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD
	{
		UINT32 powerActionSeqId alias pasq;
		INT32 powerId alias pI;
		UINT32 timerInterval;
		BYTE minCardsChosen;
		BYTE maxCardsChosen;
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > holeCards;
	};
	
	Message MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK
	{
		UINT32 powerActionSeqId alias pasq;
	};

	Message MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY
	{
		UINT32 powerActionSeqId alias pasq;
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cards;
	};

	Message MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL
	{
		UINT32 powerActionSeqId alias pasq;
	};

	struct ReloadHoleCardsPowerExtInfo
	{
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cards;
	};
	
	Message MSG_TABLE_POWER_CARD_PLAY
	{
		UINT32 actionRequestId alias aRqI;   // this number could be found in MSG_TABLE_REQUESTACTION
		INT32 powerId alias pI;
		INT8 targetPlayer default -1 parseEndOptB4Me;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card targetHoleCard parseEndOptB4Me;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card targetBoardCard parseEndOptB4Me;
		INT32 powerCardUniqueId default -1 parseEndOptB4Me;
		CommMsgBody extInfo parseEndOptB4Me;
	};
	
	Message MSG_TABLE_POWER_CARD_PLAY_REPLY
	{
		BYTE errCode;
		PString errString;
		INT32 powerId alias pI;
		INT32 powerCardUniqueId;
	};

	Message MSG_TABLE_POWER_CARD_PRESELECT
	{
		INT32 powerId alias pI;
		bool selectOrUnselect;
		INT8 targetPlayer default -1 parseEndOptB4Me;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card targetHoleCard parseEndOptB4Me;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card targetBoardCard parseEndOptB4Me;
		INT32 powerCardUniqueId default -1 parseEndOptB4Me;
	};
	
	/*
	Message MSG_TABLE_POWER_DISCARD_POWERS_CANCEL
	{
	};
	*/

	Message MSG_TABLE_POWER_DETECT_HOLECARDS
	{
		INT8 targetPlayer default -1;
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cards;
	};
	
	Message MSG_TABLE_POWER_REDRAW
	{
		UINT32 seqId alias sq;
		UINT32 costChips;
		INT32 maxAllowedCardsToRedraw;
		INT32 timeoutSec alias TO;
	};

	Message MSG_TABLE_POWER_REDRAW_ACK
	{
		UINT32 seqId alias sq;
	};

	Message MSG_TABLE_POWER_REDRAW_REPLY
	{
		UINT32 seqId alias sq;
		bool isFinal;
		l2vector<INT32> powersToRedraw;
	};

	Message MSG_TABLE_POWER_REDRAW_CANCEL
	{
		UINT32 seqId alias sq;
	};

	Message MSG_TABLE_POWER_CHANGE_FUTURE
	{
		UINT32 seqId alias sq;
		l1vector < TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cards;
		INT32 timeoutSec alias TO;
		l1vector<INT16> cardVisibilityMasks;
	};

	Message MSG_TABLE_POWER_CHANGE_FUTURE_ACK
	{
		UINT32 seqId alias sq;
	};

	Message MSG_TABLE_POWER_CHANGE_FUTURE_REPLY
	{
		UINT32 seqId alias sq;
		bool discardCards;
	};

	Message MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL
	{
		UINT32 seqId alias sq;
	};
	
	Message MSG_TABLE_POWER_PLAYERS_CHOICE
	{
		UINT32 seqId alias sq;
		l1vector < TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cards;
		INT32 timeoutSec alias TO;
		l1vector<INT16> cardVisibilityMasks;
	};

	Message MSG_TABLE_POWER_PLAYERS_CHOICE_ACK
	{
		UINT32 seqId alias sq;
	};

	Message MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY
	{
		UINT32 seqId alias sq;
		INT8 selectedIndex;
	};

	Message MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL
	{
		UINT32 seqId alias sq;
	};
	
	Message MSG_TABLE_POWER_PRIVATE_EFFECT
	{
		UINT64 handId alias hI;
		UINT32 clientOrdinal;
		UINT32 powerId alias pI;
		UINT32 effectId;
		PString contents;
	};		
	
	struct SabotageTrappedCard
	{
		PubBoardCardPosition cardPosition;
		INT8   bombsCount;
	};

	Message MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS
	{
		l1vector <SabotageTrappedCard> trappedCards;
	};

	Message MSG_TABLE_USER_MINI_CHAT_REQUEST
	{
		INT16 textId;
	};

	Message MSG_TABLE_POWER_DARK_BET
	{
		UINT32 seqId alias sq;
		l1vector < INT32 > values;
		INT32 timeoutSec alias TO;
	};

	Message MSG_TABLE_POWER_DARK_BET_ACK
	{
		UINT32 seqId alias sq;
	};

	Message MSG_TABLE_POWER_DARK_BET_REPLY
	{
		UINT32 seqId alias sq;
		INT32 value;
	};

	Message MSG_TABLE_POWER_DARK_BET_CANCEL
	{
		UINT32 seqId alias sq;
	};

	Message MSG_TABLE_POWER_MOUSE_OVER
	{
		INT8 position; // Power card currently on mouseover, -1 for none.
	};


	// for player private power effect messages for animation

	Message MSG_TABLE_POWER_PRIVATE_ANIMATION
	{
		UINT64 handId alias hI;
		UINT32 powerId alias pI;
		CommMsgBody effectbody;
	};

	Struct PowerCardInfo
	{
		INT32 powerId alias pI;
		INT32 cost;
	};

	Struct PrivDealingPowerCardsAnimationEffect
	{
		INT32 numPowerCardsBeforeDealt;
		Vector<PowerCardInfo> powerCards;
	};
	
	// PYR-98733
	Message MSG_TABLE_THROW
	{
		UINT32 throwableTypeId; // enum Throwable::Type in Throwables.h
		INT8 seat default -1 alias s;
	};

	Message MSG_TABLE_THROW_REPLY
	{
		INT16 errCode;
		if(errCode)
		{
			PString errStr;
			CommMsgBody clientMsg_txtEx alias m;
		}
	};
};
	
	
	
namespace publication
{
	struct ClientExtraForTakeFromPotEvent
	{
		INT8 numWinners;
		bool isSingleWinner;
		bool winHighHand;
		INT8 maxPotLevel;  //TODO:
		BYTE bestHigh;
		vector01<INT8> kickerRanks;
		BYTE boardNum parseEndOptB4Me;

		@Override    // @no_thin_version
		void composeMsg(CommMsgBody& _msg, bool _ignoreJSON = true) const
		{
			_msg.composeINT8(numWinners);
			_msg.composeBOOL(isSingleWinner);
			_msg.composeBOOL(winHighHand);
			_msg.composeINT8(maxPotLevel);
			_msg.composeBYTE(bestHigh);
			if(kickerRanks.size() < 4)
			{
				kickerRanks.composeMsg(_msg, _ignoreJSON);
			}
			else
			{
				for(int i = 0; i < 4; ++i)
				{
					_msg.composeINT8(kickerRanks[i]);
				}
			}
			_msg.composeBYTE(boardNum);
		}

		@Override    // @only_thin_version
		void composeMsg(CommMsgBody& _msg) const
		{
			_msg.composeINT8(numWinners);
			_msg.composeBOOL(isSingleWinner);
			_msg.composeBOOL(winHighHand);
			_msg.composeINT8(maxPotLevel);
			_msg.composeBYTE(bestHigh);
			if(kickerRanks.size() < 4)
			{
				kickerRanks.composeMsg(_msg);
			}
			else
			{
				for(int i = 0; i < 4; ++i)
				{
					_msg.composeINT8(kickerRanks[i]);
				}
			}
			_msg.composeBYTE(boardNum);
		}

		@Override 
		void parseMsg(CommMsgParser& _parser)
		{
			_parser.parseINT8(numWinners);
			_parser.parseBOOL(isSingleWinner);
			_parser.parseBOOL(winHighHand);
			_parser.parseINT8(maxPotLevel);
			_parser.parseBYTE(bestHigh);
			for(int i = 0; i < 4; ++i)
			{
				INT8 t;
				_parser.parseINT8(t);
				if(t == 0) break;
				kickerRanks.push_back(t);
			}
			if(_parser.parseEnded()) return;
			_parser.parseBYTE(boardNum);
		}
	};

	Message MSG_TABLE_SUBSCR_ACTION
	{
		INT8 seat default -1 alias s;
		char action alias a;
		UINT32 amount alias v;
	};
	
	Message MSG_TABLE_SUBSCR_ACTIVESEAT
	{
		INT8 seat default -1 alias s;
		BYTE isBlindOrAnte;
	};
	
	Message MSG_TABLE_SUBSCR_BEGINHAND
	{
		INT8 dealer default -1;
	};
	
	Message MSG_TABLE_SUBSCR_CHAT_BUBBLE
	{
		INT8 seat default -1 alias s;
		PString chat;
	};
	
	Message MSG_TABLE_SUBSCR_DEALBOARD
	{
		BYTE numOfBoardCards;
		bool runItTwiceMode;
	};
	
	Message MSG_TABLE_SUBSCR_DEALBOARD_RIT
	{
		BYTE boardNumber; 
		BYTE numCardsDealt;
		BYTE numBoardCards;
	};

	Message MSG_TABLE_SUBSCR_DEALPLAYERCARDS
	{
		vector_FF<P_SuscrPlayerCards> playerCardInfos;		
		INT8 dealerPos;
	};
	
	Message MSG_TABLE_SUBSCR_ENDHAND
	{
		BYTE handStatus;
	};
	
	Message MSG_TABLE_SUBSCR_I18N_MESSAGE
	{
		I18nPString i18nString;		
		UINT16 timerValue;
		UINT32 flags;
		UINT32 chatItemId;
		UINT32 brandMask default BrandType_ALLMask;
	};
	
	struct ClientMsg_TxtEx_Tournmt_NewRound
	{
		BYTE handType;
		BYTE potStruct;
		UINT32 stakeSmall;
		UINT32 stakeBig;
		UINT32 ante;
		INT8 round;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::TableStakes tableStakes parseEndOptB4Me;
	};

	struct ClientMsg_TxtEx_Tournmt_NewStakes
	{
		BYTE handType;
		BYTE potStruct;
		UINT32 stakeSmall;
		UINT32 stakeBig;
		UINT32 ante;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::TableStakes tableStakes parseEndOptB4Me;
	};

	struct ClientMsg_TxtEx_Milestone_Hand
	{
		UINT64 handId;
	};

	struct ClientMsg_TxtEx_Milestone_Prior_Draw
	{
		TournMileStonePrize prize;
	};

	struct ClientMsg_TxtEx_Milestone_Losing_Table
	{
		INT32 numOfWinningTables;
		PString winningTableName;
		PString winningTableServerAddress;
		PString winningTableServerObject;
		UINT64 winningTableId;
		UINT32 numWinningPlayers;
		TournMileStonePrize prize;
	};

	struct ClientMsg_TxtEx_Milestone_Winners
	{
		vector< PString > tables;
		UINT32 nWinners;
		TournMileStonePrize prize;
	};

	struct ClientMsg_TxtEx_TableHistory_StartNewHand
	{
		CommSrvTime started;
		UINT32 stakeSmall;
		UINT32 stakeBig;
		UINT32 smallBlind;
		UINT32 ante;
		BYTE handType;
		BYTE isHiLo;
		BYTE potStruct;
	};

	struct ClientMsg_TxtEx_TableHistory_StartNewGame
	{
		UINT32 stakeSmall;
		UINT32 stakeBig;
		UINT32 ante;
		BYTE handType;
		BYTE isHiLo;
		BYTE potStruct;
	};

	struct ClientMsg_TxtEx_TableHistory_Dealing
	{
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > holeCardsDict;
	};

	struct ClientMsg_TxtEx_TableHistory_CardsShown
	{
		PString cards;
	};

	struct ClientMsg_TxtEx_TableHistory_WinningHand
	{
		BYTE bestHigh;
		PString bestHighHand;
		PString bestLowHand;
		BYTE bestLow;
		BYTE boardNum;
	};

	struct ClientMsg_TxtEx_TableHistory_ShownHand
	{
		INT8 cmp;
		BYTE bestHigh;
		PString bestHighHand;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card kicker;
		vector01<INT8> extraKickerRanks;
		BYTE boardNum;
	};

	struct ClientMsg_TxtEx_TableHistory_TournPrizeWon
	{
		UINT16 flags;
		UINT32 tournId;
		PString ticketAdmission;
		UINT32 headBounty;
	};

	Message MSG_TABLE_SUBSCR_MESSAGE
	{
		PString attach;
		UINT16 timerValue;
		UINT32 options;
		UINT16 cltMsgStrCode parseEndOptB4Me;
		CommMsgBody clientMsg_txtEx alias m;
		UINT32 BrandMask default BrandType_ALLMask;
	};
	
	Message MSG_TABLE_SUBSCR_MESSAGE2
	{
		PString attach;
		UINT16 timerValue;
		UINT32 flags;
		UINT32 siteObsolete;
		UINT32 BrandMask default BrandType_ALLMask;
		PSiteMask siteMask parseEndOptB4Me;
	};
	
	Message MSG_TABLE_SUBSCR_MOVEFROMPOT
	{
		BYTE potNum;
		vector_FFFF<P_PotInfo> pots;
		BYTE potCategoryId parseEndOptB4Me;
	};
	
	Message MSG_TABLE_SUBSCR_MOVETOPOT
	{
		BYTE potNum;
		vector_FFFF<P_PotInfo> pots;
		BYTE potCategoryId parseEndOptB4Me;
	};
	
	Message MSG_TABLE_SUBSCR_NEWGAME
	{
		INT32 stakeSmall;
		INT32 stakeBig;
		INT32 ante;
		BYTE handType alias gm;
		BYTE isHiLo;
		BYTE potStruct alias lm;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::TableStakes tableStakes parseEndOptB4Me;
	};
	
	Message MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE
	{
		bool pause;
	};

	Message MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE
	{
		BYTE start;
		UINT32 delayedSec;
		bool forceClose;
	};
	
	Message MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS
	{
		UINT16 playersUnfolded;   // bit mask for players who played unfold
	};

	Message MSG_TABLE_SUBSCR_SHOW_POT_WINNERS  // currently on unfold pot has this animation msg
	{
		BYTE potCategoryId;
		UINT16 winners;   // bit mask for winners from this pot category
	};

	Message MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET  // currently on unfold pot when there is only one player played unfold
	{
		BYTE potCategoryId alias pcid;
		BYTE seat default 0xFF alias s;
		UINT32 amount alias v;
	};


	// ============ for new animations ============

	Message MSG_TABLE_SUBSCR_POWER_PLAY
	{
		INT32 powerId alias pI;
		CommMsgBody baseAttr
		{
			INT8 seat default -1 alias s;
		};
		CommMsgBody powerAttr;
	};
	

	struct XRayCard
	{
		BYTE player;
		BYTE cardIndex;
		char suit;
		BYTE rank;
	};

	struct XRayAnimation
	{
		vector<XRayCard> cards;
	};

	struct DisintgrateAnimation
	{
 		PubBoardCardPosition c;
	};

	struct ScannerAnimation
	{
		bool startOrEnd;
		BYTE numCards;
		bool discarded;
	};

	struct EngineerAnimation
	{
		bool startOrEnd;
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > cards;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card chosenCard;
	};

	struct CloneAnimation
	{
		BYTE toSlotIndex;
		INT32 powerIdCopied;
		UINT32 newPowerState;
		INT32 newPowerCost;
	};

	struct UpgradeAnimation
	{
		bool startOrEnd;
	};

	Struct IntelAnimation
	{
		BYTE player;
		BYTE NumCards;
		bool isFirstEffect;
		l1Vector<TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card> sensedCardIndexes;
	};

	struct ReloadAnimation
	{
		l1vector<CardWithPosition> cardIndexes;
	};

	struct SyphonAnimation
	{
		INT8 fromPlayer;
		INT8 toPlayer;
		INT64 originManaTo;
		INT64 origManaFrom;
		INT64 amountDrained;
		INT64 amountReceived;
	};

	struct DeployPowerAnimation
	{
		BYTE boardWidth;  // max_number_of_cards_in_board_line
		l1vector<CardInfoBody> cards;
	};

	struct MorphAnimation
	{
		CardInfo c;
	};

	MsgBodyStruct PacifyAnimPlayer
	{
		INT8 seat default -1 alias s;
		INT64 chipsReturned;
		INT64 chipsRemaining;
		INT64 newBalance;
	};

	struct PacifyAnimation
	{
		l1vector<PacifyAnimPlayer> players;
	};

	struct MintAnimation
	{
		INT64 chipsMinted;
		INT64 betAmountAfterMint;
	};

	MsgBodyStruct ChaosCard
	{
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card card;
		BYTE boardNo;
		BYTE cardPos;
		bool isBlocked;
	};

	struct ChaosAnimation
	{
		l1vector<ChaosCard> chaos;
	};

	Struct DealingPowerCardsAnimation
	{
		BYTE player;
		INT32 numPowerCardsBeforeDealt;
		INT32 numPowerCardsDealt;
	};

	MsgBodyStruct WinnerInfo
	{
		INT8 seat default -1 alias s;
		INT64 winningAmount;
		BYTE handRank;  // 1 - 9
		l1vector<INT8> kickerRanks;
		l1vector<CardInfoBody> winningCards;
	};

 	Message MSG_TABLE_SUBSCR_POT_DISTRIBUTION  // for showdown animations
	{
		BYTE potNo;
		INT64 startAmount;
		INT64 endAmount;    // maybe half amount if pot is split, usually zero if no split
		l1vector<BYTE> playersInPot;  // if no showdown reached, this vector is empty
		l1vector<WinnerInfo> winners;
		BYTE boardNo;    // 0 - non RIT, 1 - RIT first board, 2 - RIT second board
		bool isLoHand;
	};


	Message MSG_TABLE_USER_MINI_CHAT_BROADCAST
	{
		INT8 seat default -1 alias s;
		INT16 textId;
	};

	Message MSG_TABLE_SUBSCR_ANIMATION
	{
		PString userId alias u;
		INT8 seat default -1 alias s;
		UINT32 animationTypeId;  // defined in upserver.h
		CommMsgBody extraInfo;
	};
	
	// PYR-98733
	Message MSG_TABLE_SUBSCR_THROW
	{
		INT8 seatFrom default -1 alias sF;
		INT8 seatTo default -1 alias sT;
		UINT32 throwableTypeId;  // enum Throwable::Type in Throwables.h
	};

	// PYR-123867
	MsgBodyStruct KnockedOutBy
	{
		INT8 seat default -1;
		INT64 bountyWon;
		INT64 spinBountyWon;
		INT64 ownBountyIncrease;
	};

	MsgBodyStruct KnockedOut
	{
		INT8 seat default -1;
		vector< KnockedOutBy > knockedOutBy;
		INT32 spinMultiplier;
		UINT32 animationType; 
	};

	Message MSG_TABLE_SUBSCR_KNOCKOUT
	{
		vector< KnockedOut > knockedOut;
	};

	// structs for publications

	struct TableSubscr_Chat     // Path {0}
	{
		UINT32 clentOrdinal;
		UINT64 handId alias hI;
		INT16 eventCode;
		INT8 seat default -1 alias s;   // not used for real chat, seat info can be determined at the eventCode
		INT8 action alias a;  // flags for real chat
		UINT32 amount alias v;   // 0 for real chat
		PString user;
		PString content;
		INT32 amount2 alias v2;
		CommMsgBody msgClientExtra ignoredInComparison;
		UINT32 timestamp ignoredInComparison;   // this is real time stamp in seconds: plib_time(NULL)
		UINT32 eventSeqId alias eventSq;
		UINT32 brandMask default BrandType_ALLMask;
	};

	struct TableSubscr_Static    // Path {1}
	{
		PString serverVersion;          // always ""
		PString protocolVersion default TABLE_PROTOCOL_VERSION;
		UINT32 tableId32Obsolete;
		BYTE handType alias gm;
		BYTE potStruct alias lm;
		BYTE tournamentType;
		BYTE isHiLo;
		BYTE isPlayMoney;
		BYTE isOneToOne;
		BYTE numOfSeats;
		PString tableName;
		PString nameSuffix;
		BYTE multiGameType;  			// if it is not mutiple game, this field is zero
		PString multiGameTypeDesc;
		INT32 stakeSmall; 				// isMultiGameFixedMixed ? LoBetGuard : StakeSmall;  // low bet
		INT32 stakeBig;   				// isMultiGameFixedMixed ? HiBetGuard : StakeBig;    // hi bet
		UINT16 chatLang;
		INT32 minChipsLimit;  			// min buyin
		INT32 maxBuyIn alias mxBI;      // max buyin
		PString currency;  				// table currency
		INT32 cap;
		PString itSessionId; 			// italy session
		UINT32 clubId;
		BYTE dealOptions;
		bool isShowCity;
		PString createdBy;
		PString cancelledBy;
		PString voiceObjectAddress;  	// voice chat
		PString voiceObjectUdpAddress;
		PString voiceObjectName; 
		UINT32 accessMask;
		UINT32 scalePM;
		CommMsgBody happyHourInfoPublMsg
		{
			l2vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_FppFactor > fppFactors parseEndOptB4Me; // TODO: to be retired
			l2vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_FppFactorEx > fppFactorSiteMasks parseEndOptB4Me;
		};
		UINT32 showObservFlags;
		UINT64 tableId alias tI;
		UINT32 noVppGainSiteId;
		UINT64 tableFlags2 parseEndOptB4Me;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::TableStakes tableStakesObsolete parseEndOptB4Me; // found to be duplicated with tableStakes in TableSubscr_Hand, so deprecated.
		vector<INT64> variableAntes parseEndOptB4Me;	// only populated if variable antes is available, indexed by "variableAnteIndex" in TableSubscr_Hand
		PSiteMask noVppGainSiteMask parseEndOptB4Me;
	};

	struct TableSubscr_Hand     // Path {2}
	{
		UINT64 handId alias hI;            // current hand id
		UINT32 stakeSmall;        // lo bet
		UINT32 stakeBig;          // hi bet
		INT8 dealer default -1;   // dealer position 
		UINT64 lastHandId alias lastHI;        // last hand id	
		PString adminMsg;  
		INT8 round default -128;   // may be break
		UINT32 ante; 
		UINT32 tableFlags;         // published table flags
		INT32 multiGameHands;      // multigame hands
		UINT16 clientMsgStrId;     // client msg string id  
		I18nPString advertiseI18n;
		UINT64 milestoneHandId alias milestoneHI;
		PString superstarShowdownResults;	// #18541 super star show down result
		INT32 banner default -1;
		CommMsgBody tournMileStoneWinMsg;
		INT8 variableAnteIndex default -1 parseEndOptB4Me;	// index into TableSubscr_Static.variableAntes
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::TableStakes tableStakes;
	};

	MsgBodyStruct SidePot
	{
		INT64 amount;
		UINT16 playersMask;  // in-hand players who are eligible to win this pot
	};

	MsgBodyStruct PotCat   // define pot category info
	{
		BYTE potCategoryId;
		l1vector<SidePot> pots;  // main pot also included here
		INT32 rake parseEndOptB4Me;
	};

	struct TableSubscr_ActivePlayer   // Path {3}
	{
		INT8 activePlayer default -1;        // display active player seat
		UINT32 rake;              // rake
		l1vector<UINT32> pots;    // pot amounts 
		l1vector<UINT32> columns; // chips columns
		UINT32 totalPot;           // total pot value including temp pot
		BYTE activeTBstate;       // active time bank status
		UINT32 activeTimeBank alias activeTb;    // active time bank balance  
		INT32 capX;               // capX
		INT32 capY ignoredInComparison;               // capY  //TODO: temporary not comparison
		BYTE actionTimeType;
		UINT32 totalActionTime;
		UINT32 remainingActionTime;
		bool isActionTimerPaused;
		UINT16 multiActivePlayersMask parseEndOptB4Me; 
		l1vector<PotCat> potCats parseEndOptB4Me ignoredInComparison;    // pot categories //TODO: temporary not comparison
	};

	struct TableSubscr_Board        // Path {4}  // this one has been phased out, it could be reused in the future
	{
		l1vector< TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card > activeBoardCards;
	};

	struct TableSubscr_PlayerChips   // Path {5,x,0}
	{
		UINT32 chips;        // chips
		UINT32 chipsBet;     // chips bet
		BYTE isSittingIn;    // sitting in
		BYTE isSeatedAndConnected;    // connected status after seated
		BYTE allInFlag;      // AllIn or Capped
		BYTE inHand;         // is player in this hand?
		BYTE seatIndicator;  // seat indicator
		INT8 connectQuality default CONNECTION_QUALITY_DISCONNECTED; // connection quality
		UINT32 timeBank alias tb;     // time bank balance
		INT16 numOfAllInsLeft default ALLIN_NOALLINTOURN;   // num of AllIns remaining 		
		INT32 capN ignoredInComparison;          // capN - //TODO: temporary not comparison
		UINT32 totalBet;     // total bet  //PYR-16708
		BYTE playerState;
		UINT32 remainingStacks;  // for n-stack tournament
		bool hasCard;
		bool hasFolded;
		INT32 totalBetInUnfoldPot parseEndOptB4Me;  // PYR-77049
		UINT64 playerState2 parseEndOptB4Me;  // PYR-95107
	};

	struct TableSubscr_PlayerProfile   // Path {5,x,1}
	{
		PString user;          // user 
		PString city;          // city
		UINT32 imageId;        // 
		UINT32 siteId;           // client site id
		UINT32 vipStatus;      // obsolete: vip status
		BYTE publProp;         // publish property flag
		UINT32 bounty;         // bounty
		PString promoImageCode; // promo image name
		PString country;       // country
		BYTE showCountry;      // actually same as NOT showCity
		UINT32 headBounty parseEndOptB4Me;
		UINT32 hallOfFame;
		UINT32 mileStoneAward;
		UINT32 clientDevice;
		CommMsgBody userPropertyMsg;
		BrandProt${ATF_THIN_NAMESPACE_SUFFIX}::BrandImageList brandImages;
		UINT64 altBounty_tournId;
		PString altBounty_admission;
		INT32 altBounty_tChips;
		INT32 earlyBirdMultiplier parseEndOptB4Me;
		INT32 earlyBirdMins;
		INT64 amountToHeadIfEliminated parseEndOptB4Me; // unscaled for PM
		INT64 baseWinIfEliminated; // unscaled for PM
		INT64 maxBonusWinIfEliminated; // unscaled for PM
	};

	//struct SubscrShowcard  // retired!
	//{
	//	BYTE showFlag;
	//	
	//	if (showFlag != Closed && showFlag != ClosedButShown)
	//	{
	//		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card card;
	//	}
	//};
	//
	//struct TableSubscr_PlayerCards    // Path {5,x,2}   // retired!
	//{
	//	l1vector<SubscrShowcard> playerCards;
	//};

	MsgBodyStruct PowerOnCard
	{
		INT32 powerId  alias pI;
		BYTE powerPlayer;
	};

	MsgBodyStruct SubscrPlayerCard
	{
		BYTE showFlag;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card cardOrIndex;
		INT16 visibilityMask;
		l1vector<PowerOnCard> powers;
	};

	struct TableSubscr_PlayerCards_Dict    // Path {5,x,3}
	{
		l1vector<SubscrPlayerCard> playerCards;
		INT8 numSwapped parseEndOptB4Me;  // for Swap Holdem only
		INT8 swapRound;                   // for Swap Holdem only
	};

	struct TableSubscr_AllBoards       // Path {6}
	{
		l1vector<TableSubscr_Board> allBoards;
	};

	struct TableSubscr_Dynamic        // Path {7}
	{
		INT32 numPublSubscribers default -1;
	};
	
	struct TableSubscr_AutoDeal        // Path {8}
	{
		INT8 autoDealState;
		INT8 numInterested;
		INT8 numRemaining;
	};

	MsgBodyStruct PowerBasicInfo  // obsoleted
	{
		INT32 powerId alias pI;
		INT32 cost;
		PString powerName;
		PString desc;
	};
	
	struct TablePowerSubscr_PowerList  // Path {9,0}
	{
		vector<PowerBasicInfo> oldPowers;  // obsoleted, no data will be populated in this vector
		INT32 maxPowersPerPlayer;
		INT32 numDiscardedPowers;
		INT32 powersLimitPerStreet;
		INT32 powersLimitPerHand;
		bool isManaEnabled;
	};
	
	struct TablePowerSubscr_PowerPot  // Path {9,1}
	{
		INT32 carryOverAmount;
	};
	
	MsgBodyStruct CardRedealt  // obsoleted
	{
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card newCard;
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card oldCard;
	};
	
	MsgBodyStruct PowerInfoOnBoardCard
	{
		l1vector<PowerOnCard> powers;
		INT8 flag;   // used for card freezing
	};

	struct TablePowerSubscr_BoardRedealt  // Path {9,2}
	{
		l1vector<CardRedealt> boardCardChangesOld;  // obsoleted
		l1vector<INT8> board1CardsFlagsOld;         // obsoleted
		l1vector<INT8> board2CardsFlagsOld;         // obsoleted
		l1vector<INT8> boardCardsStreet;
		l1vector<PowerInfoOnBoardCard> board1;
		l1vector<PowerInfoOnBoardCard> board2;
		BYTE maxBoardWidth;  // maximum number of cards in the first board
	};
	
	
	struct TablePowerSubscr_PlayerInfo   // Path {9,3,x}
	{
		BYTE numPowers;
		UINT32 currentMana;
		INT8 numOfPendingSecrets;
		UINT32 manaRewards;
	};
	

	struct TablePowerSubscr_SilenceStateInfo   // Path {9,4,0}
	{
		bool silenceIsOn;
		INT16 nonSilencedSeatsMask;
	};


	struct TablePowerSubscr_SenseStateInfo   // Path {9,4,1}
	{
		l1vector<INT16> tokensNum;
	};

	struct TablePowerSubscr_CloakedStateInfo   // Path {9,4,2}
	{
		l1vector<INT8> cloakedSeatsNow;
		l1vector<INT8> cloakedSeatsPerHand;
	};

	struct CardVisibility
	{
		INT8 seat default -1 alias s;
		INT8 position;
		INT16 visibilityMask;
	};

	MsgBodyStruct SensedCardIndex
	{
		TableCommon${ATF_THIN_NAMESPACE_SUFFIX}::P_Card cardOrIndex;  // when the sensed card visible for everybody, publish card value
		INT16 visibilityMask;
		l1vector<PowerOnCard> powers;
	};

	struct TablePowerSubscr_CardsVisibility   // Path {9,5}
	{
		l1vector<CardVisibility> visInfo;  // obsoleted, no data will be populated!
		l1vector<SensedCardIndex> sensedCards;
	};
	
	struct TablePowerSubscr_PowerStateInfo   // Path {9,6,x}
	{
		INT32 powerId alias pI;
		bool  isActive;
		INT8  playerSeat;
		CommMsgBody extInfo;
	};
	
	MsgBodyStruct PowerIndicator
	{
		INT32 powerId alias pI;
		INT32 powerCardUniqueId;
		BYTE powerPlayer;
	};

	struct TablePowerSubscr_PowerIndicators   // Path {9,7}
	{
		l1vector<PowerIndicator> powers;
	};

	struct TablePowerSubscr_PowerInfo      // Path {9,8,x}
	{
		INT32 powerId alias pI;
		INT32 cost;
		//PString powerName;  // client does not use this string 
		//PString desc;       // client does not use this string
		CommMsgBody paramBody;  // for power static parameters client needs
	};

	struct TablePowerSubscr_PowerMouseOver    // Path {9,9,x}
	{
		INT8 position; // Power card currently on mouseover, -1 for none.
	};

	Struct AppendOrUpdateLeafMsg    // @no_thin_version
	{
		l2vector<UINT16> path;
		
		if (path.size() >= 1 && path[0] == 0)
		{
			CommMsgBody path0
			{
				TableSubscr_Chat chat;
			};
		}
		else if (path.size() == 1 && path[0] == 1)
		{
			CommMsgBody path1
			{
				TableSubscr_Static staticInfo;
			};
		}
		else if (path.size() == 1 && path[0] == 2)
		{
			CommMsgBody path2
			{
				TableSubscr_Hand hand;
			};
		}
		else if (path.size() == 1 && path[0] == 3)
		{
			CommMsgBody path3
			{
				TableSubscr_ActivePlayer activePlayer;
			};
		}
		//else if (path.size() == 1 && path[0] == 4)  // retired!
		//{
		//	CommMsgBody path4
		//	{
		//		TableSubscr_Board activeBoard;
		//	};
		//}
		else if (path.size() == 3 && path[0] == 5 && path[2] == 0)
		{
			CommMsgBody path5x0
			{
				TableSubscr_PlayerChips chips;
			};
		}
		else if (path.size() == 3 && path[0] == 5 && path[2] == 1)
		{
			CommMsgBody path5x1
			{
				TableSubscr_PlayerProfile profile;
			};
		}
		//else if (path.size() == 3 && path[0] == 5 && path[2] == 2)  // retired!
		//{
		//	CommMsgBody path5x2
		//	{
		//		TableSubscr_PlayerCards cards;
		//	};
		//}
		else if (path.size() == 3 && path[0] == 5 && path[2] == 3)
		{
			CommMsgBody path5x3
			{
				TableSubscr_PlayerCards_Dict cards;
			};
		}
		else if (path.size() == 1 && path[0] == 6)
		{
			CommMsgBody path6
			{
				TableSubscr_AllBoards allBoards;
			};
		}
		else if (path.size() == 1 && path[0] == 7)
		{
			CommMsgBody path7
			{
				TableSubscr_Dynamic dynamic;
			};
		}	
		else if (path.size() == 1 && path[0] == 8)
		{
			CommMsgBody path8
			{
				TableSubscr_AutoDeal autoDeal;
			};
		}
		else if (path.size() == 2 && path[0] == 9 && path[1] == 0)
		{
			CommMsgBody path90
			{
				TablePowerSubscr_PowerList powerList;
			};
		}	
		else if (path.size() == 2 && path[0] == 9 && path[1] == 1)
		{
			CommMsgBody path91
			{
				TablePowerSubscr_PowerPot powerPot;
			};
		}	
		else if (path.size() == 2 && path[0] == 9 && path[1] == 2)
		{
			CommMsgBody path92
			{
				TablePowerSubscr_BoardRedealt boardRedealt;
			};
		}	
		else if (path.size() == 3 && path[0] == 9 && path[1] == 3)
		{
			CommMsgBody path93x
			{
				TablePowerSubscr_PlayerInfo powerPlayerInfo;
			};
		}	
		else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 0)
		{
			CommMsgBody path940
			{
				TablePowerSubscr_SilenceStateInfo silenceStateInfo;
			};
		}
		else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 1)
		{
			CommMsgBody path941
			{
				TablePowerSubscr_SenseStateInfo senseStateInfo;
			};
		}
		else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 2)
		{
			CommMsgBody path942
			{
				TablePowerSubscr_CloakedStateInfo cloakedStateInfo;
			};
		}
		else if (path.size() == 2 && path[0] == 9 && path[1] == 5)
		{
			CommMsgBody path95
			{
				TablePowerSubscr_CardsVisibility cardsVisibility;
			};
		}
		else if (path.size() == 3 && path[0] == 9 && path[1] == 6)
		{
			CommMsgBody path96x
			{
				TablePowerSubscr_PowerStateInfo powerStateInfo;
			};
		}
		else if (path.size() == 2 && path[0] == 9 && path[1] == 7)
		{
			CommMsgBody path97
			{
				TablePowerSubscr_PowerIndicators powerIndicators;
			};
		}
		else if (path.size() == 3 && path[0] == 9 && path[1] == 8)
		{
			CommMsgBody path98x
			{
				TablePowerSubscr_PowerInfo powerInfo;
			};
		}
		else if (path.size() == 3 &&  path[0] == 9 && path[1] == 9)
		{
			CommMsgBody path99x
			{
				TablePowerSubscr_PowerMouseOver powerMoouseOver;
			};
		}
	};
	
	
	Struct PublOnlineUpdateItem    // @no_thin_version
	{
		char action alias a;

		if (action == PUBLICATION_ACTION_ATTACH_MSG)
		{
			AttachedPublMsg attchedMsg;
		}
		else if(action == PUBLICATION_ACTION_APPEND_NODE)
		{
			l2vector<UINT16> path;
		}
		else if (action == PUBLICATION_ACTION_REMOVE_NODE || action == PUBLICATION_ACTION_REMOVE_LEAF)
		{
			l2vector<UINT16> path;
			UINT16 idx;
		}
		else if(action == PUBLICATION_ACTION_UPDATE_LEAF || action == PUBLICATION_ACTION_APPEND_LEAF)
		{
			AppendOrUpdateLeafMsg leaf;
		}
		
		@Override bool canBeSkippedInComparison() const
		{
			// skip path {7}: for number of the subscribers. We cannot mimic the subscriptions in the replaying mode
			if( leaf.path.size() == 1 && leaf.path[0] == 7 )
			{
				return true;
			}
			if( leaf.path.size() > 1 && leaf.path[0] == 9 )  // ignore all power related nodes comparison
			{
				return true;
			}
			return false;
		}
	};

	Message MSG_PUBLICATION_UPDATE    // @no_thin_version
	{
		UINT32 thisid;        // place holder just for underlying layer implementation 
		UINT32 peerid;        // place holder just for underlying layer implementation
		UINT32 rootRevBeforeUpdate;
		vector_30<PublOnlineUpdateItem> updates;    // 0x30 is characher '0'
		UINT32 rootRevAfterUpdate;
		
		@Override bool equals(const Protocol_MSG_PUBLICATION_UPDATE& _o) const
		{
			// when there is no subscriber, the publication message is empty with rootRevBeforeUpdate = rootRevAfterUpdate = 0
			if((rootRevBeforeUpdate == 0 && rootRevAfterUpdate == 0) || (_o.rootRevBeforeUpdate == 0 && _o.rootRevAfterUpdate == 0))
			{
				return true;
			}
			else
			{
				UINT32 _i = 0, _j = 0;
				while (_i < updates.size() && _j < _o.updates.size())
				{
					if (updates[ _i ].canBeSkippedInComparison())
					{
						++_i;
						continue;
					}
					if (_o.updates[ _j ].canBeSkippedInComparison())
					{
						++_j;
						continue;
					}
					if (! Atf::AtfTempl< PublOnlineUpdateItem >::Equals(updates[ _i ], _o.updates[ _j ]))
					{
						return false;
					}
					++_i;
					++_j;
				}
				if (_i == updates.size())
				{
					while (_j < _o.updates.size() && _o.updates[ _j ].canBeSkippedInComparison())
					{
						++_j;
					}			
					return _j == _o.updates.size();
				}
				else
				{
					while (_i < updates.size() && updates[ _i ].canBeSkippedInComparison())
					{
						++_i;
					}			
					return _i == updates.size();
				}
			}
		}


		@Override bool equals(Atf::MessageProtocol* _other) const
		{
			if (MSG_PUBLICATION_UPDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()) )
			{
				return false;
			}
			else
			{ 
				return equals(*((Protocol_MSG_PUBLICATION_UPDATE*)_other));
			}
		}
	};

	struct ClientMsg_TxtEx_TableHistory_AllInCashout
	{
		BYTE code;
	};

	struct AllInCashout_PlayerCashedOut_Data
	{
		INT64 cashoutAmount;
	};

	struct AllInCashout_ResumingHand_Data
	{
		vector01<PString> activePlayers;
	};
};
	

namespace ihh
{
	Message MSG_TABLE_IHH_GET_HANDBLOB
	{
		UINT64 handId;
	};

	Message MSG_TABLE_IHH_GET_HANDBLOB_REPLY
	{
		BYTE errcode;

		if(errcode)
		{
			PString errstr;
		}
		else
		{
			UINT64 handId;
			bool zipped;
			PBlock blob notrace;
		}
	};

};
