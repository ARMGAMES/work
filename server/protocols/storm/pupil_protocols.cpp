/**
 * pupil_protocols.cpp
 *
 * This file was auto-generated from pupil_protocols.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor pupil_protocols.txt
 */
 
#include "pupil_protocols.h"

//=================================================================
//                    GameStaticLeaf
//=================================================================

//=================================================================
//                _VisibilityType
//=================================================================

_Pupil::GameStaticLeaf::_VisibilityType::_VisibilityType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

_Pupil::GameStaticLeaf::_VisibilityType::_VisibilityType(_VisibilityType&& _o)
	: brand(std::move(_o.brand))
	, siteObsolete(std::move(_o.siteObsolete))
	, excludeCountries(std::move(_o.excludeCountries))
	, countries(std::move(_o.countries))
	, criteria(std::move(_o.criteria))
	, siteMask(std::move(_o.siteMask))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

_Pupil::GameStaticLeaf::_VisibilityType& _Pupil::GameStaticLeaf::_VisibilityType::operator=(_VisibilityType&& _o)
{
	if(this != &_o)
	{
		brand = std::move(_o.brand);
		siteObsolete = std::move(_o.siteObsolete);
		excludeCountries = std::move(_o.excludeCountries);
		countries = std::move(_o.countries);
		criteria = std::move(_o.criteria);
		siteMask = std::move(_o.siteMask);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void _Pupil::GameStaticLeaf::_VisibilityType::clear()
{
	brand = 0;
	siteObsolete = 0;
	excludeCountries = false;
	countries.clear();
	criteria.clear();
	siteMask.clear();
	_is_empty_internal = true;
}

bool _Pupil::GameStaticLeaf::_VisibilityType::equals(const _VisibilityType& _o) const
{
	return brand == _o.brand &&
		siteObsolete == _o.siteObsolete &&
		excludeCountries == _o.excludeCountries &&
		countries.equals(_o.countries) &&
		Atf::atfPStringEquals(criteria, _o.criteria) &&
		siteMask.equals(_o.siteMask);
}

const char *_Pupil::GameStaticLeaf::_VisibilityType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("brand=");
		_buf.appendUint(brand);
		_buf.append(',');
		_buf.append("siteObsolete=");
		_buf.appendUint(siteObsolete);
		_buf.append(',');
		_buf.append("excludeCountries=");
		_buf.appendUint(excludeCountries);
		_buf.append(',');
		_buf.append("countries=");
		countries.toTraceString(_buf);
		_buf.append(',');
		_buf.append("criteria=");
		_buf.append(criteria);
		_buf.append(',');
		_buf.append("siteMask=");
		siteMask.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *_Pupil::GameStaticLeaf::_VisibilityType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("brand", brand, _buf);
		Atf::XmlElement::encodeAsXmlElement("siteObsolete", siteObsolete, _buf);
		Atf::XmlElement::encodeAsXmlElement("excludeCountries", excludeCountries, _buf);
		countries.toXmlString("countries", _buf);
		Atf::XmlElement::encodeAsXmlElement("criteria", criteria, _buf);
		siteMask.toXmlString("siteMask", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool _Pupil::GameStaticLeaf::_VisibilityType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("brand"))
		{
			brand = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteObsolete"))
		{
			siteObsolete = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("excludeCountries"))
		{
			excludeCountries = (*_value.ptr() == '1');
		}
		else if (_element.equals("countries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, countries)) return false;
		}
		else if (_element.equals("criteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, criteria)) return false;
		}
		else if (_element.equals("siteMask"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, siteMask)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void _Pupil::GameStaticLeaf::_VisibilityType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeUINT32(brand);
		_msg0.composeUINT32(siteObsolete);
		CommMsgBody _msg1;
		_msg1.composeBOOL(excludeCountries);
		countries.composeMsg(_msg1, _ignoreJSON);
		_msg0.composeMsgBody(_msg1);
		_msg0.composeString(criteria);
		siteMask.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void _Pupil::GameStaticLeaf::_VisibilityType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(brand);
	_parser0.parseUINT32(siteObsolete);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseStringP(criteria);
	siteMask.parseMsg(_parser0);
}

const char *_Pupil::GameStaticLeaf::_VisibilityType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("brand", brand);
		_jsonstr.compose("siteObsolete", siteObsolete);
		_jsonstr.compose("excludeCountries", excludeCountries);
		_jsonstr.compose("countries", countries);
		_jsonstr.compose("criteria", criteria);
		_jsonstr.compose("siteMask", siteMask);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void _Pupil::GameStaticLeaf::_VisibilityType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("brand", brand);
	_jparser.parseByNameThrow("siteObsolete", siteObsolete);
	_jparser.parseByNameThrow("excludeCountries", excludeCountries);
	_jparser.parseByNameThrow("countries", countries);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("siteMask", siteMask);
}

/* static */ void _Pupil::GameStaticLeaf::_VisibilityType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 brand; _jparser.validateByNameThrow("brand", brand);
	AtfValidator::validateInt(_descr, "brand", brand, _checker, __FILE__, __LINE__);
	UINT32 siteObsolete; _jparser.validateByNameThrow("siteObsolete", siteObsolete);
	AtfValidator::validateInt(_descr, "siteObsolete", siteObsolete, _checker, __FILE__, __LINE__);
	bool excludeCountries; _jparser.validateByNameThrow("excludeCountries", excludeCountries);
	AtfValidator::validateInt(_descr, "excludeCountries", excludeCountries, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > countries; _jparser.validateByNameThrow("countries", countries);
	AtfValidator::validateInt(_descr, "countries", countries.size(), _checker, __FILE__, __LINE__);
	PString criteria; _jparser.validateByNameThrow("criteria", criteria);
	AtfValidator::validateInt(_descr, "criteria", criteria.length(), _checker, __FILE__, __LINE__);
	PSiteMask siteMask; _jparser.validateByNameThrow("siteMask", siteMask);
}

/*static*/ void _Pupil::GameStaticLeaf::_VisibilityType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	UINT32 brand; _parser0.parseUINT32(brand);
	AtfValidator::validateInt(_descr, "brand", brand, _checker, __FILE__, __LINE__);
	UINT32 siteObsolete; _parser0.parseUINT32(siteObsolete);
	AtfValidator::validateInt(_descr, "siteObsolete", siteObsolete, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("siteMask"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void _Pupil::GameStaticLeaf::_VisibilityType::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(excludeCountries);
	countries.parseMsg(_parser0);
}

/*static*/ void _Pupil::GameStaticLeaf::_VisibilityType::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool excludeCountries; _parser0.parseBOOL(excludeCountries);
	AtfValidator::validateInt(_descr, "excludeCountries", excludeCountries, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCountries = Atf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _SampleType
//=================================================================

_Pupil::GameStaticLeaf::_SampleType::_SampleType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

_Pupil::GameStaticLeaf::_SampleType::_SampleType(_SampleType&& _o)
	: tournId(std::move(_o.tournId))
	, serverAddr(std::move(_o.serverAddr))
	, serverObject(std::move(_o.serverObject))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

_Pupil::GameStaticLeaf::_SampleType& _Pupil::GameStaticLeaf::_SampleType::operator=(_SampleType&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		serverAddr = std::move(_o.serverAddr);
		serverObject = std::move(_o.serverObject);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void _Pupil::GameStaticLeaf::_SampleType::clear()
{
	tournId = 0;
	serverAddr.clear();
	serverObject.clear();
	_is_empty_internal = true;
}

bool _Pupil::GameStaticLeaf::_SampleType::equals(const _SampleType& _o) const
{
	return tournId == _o.tournId &&
		Atf::atfPStringEquals(serverAddr, _o.serverAddr) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject);
}

const char *_Pupil::GameStaticLeaf::_SampleType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("serverAddr=");
		_buf.append(serverAddr);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *_Pupil::GameStaticLeaf::_SampleType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverAddr", serverAddr, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool _Pupil::GameStaticLeaf::_SampleType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("serverAddr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverAddr)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void _Pupil::GameStaticLeaf::_SampleType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeUINT32(tournId);
		_msg0.composeString(serverAddr);
		_msg0.composeString(serverObject);
	}

	_msg.composeMsgBody(_msg0);
}

void _Pupil::GameStaticLeaf::_SampleType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(serverAddr);
	_parser0.parseStringP(serverObject);
}

const char *_Pupil::GameStaticLeaf::_SampleType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("serverAddr", serverAddr);
		_jsonstr.compose("serverObject", serverObject);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void _Pupil::GameStaticLeaf::_SampleType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("serverAddr", serverAddr);
	_jparser.parseByNameThrow("serverObject", serverObject);
}

/* static */ void _Pupil::GameStaticLeaf::_SampleType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString serverAddr; _jparser.validateByNameThrow("serverAddr", serverAddr);
	AtfValidator::validateInt(_descr, "serverAddr", serverAddr.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void _Pupil::GameStaticLeaf::_SampleType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverAddr"); size_t szServerAddr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddr", szServerAddr, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

_Pupil::GameStaticLeaf::GameStaticLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

_Pupil::GameStaticLeaf::GameStaticLeaf(GameStaticLeaf&& _o)
	: visible(std::move(_o.visible))
	, regOpen(std::move(_o.regOpen))
	, gameId(std::move(_o.gameId))
	, visibility(std::move(_o.visibility))
	, sample(std::move(_o.sample))
	, name(std::move(_o.name))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, speedDisplay(std::move(_o.speedDisplay))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, prizePool(std::move(_o.prizePool))
	, prizePoolUnit(std::move(_o.prizePoolUnit))
	, prizePoolMoneyValue(std::move(_o.prizePoolMoneyValue))
	, playerPerTable(std::move(_o.playerPerTable))
	, minPlayers(std::move(_o.minPlayers))
	, maxUserRequests(std::move(_o.maxUserRequests))
	, customSpeedDisplayName(std::move(_o.customSpeedDisplayName))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
{
}

_Pupil::GameStaticLeaf& _Pupil::GameStaticLeaf::operator=(GameStaticLeaf&& _o)
{
	if(this != &_o)
	{
		visible = std::move(_o.visible);
		regOpen = std::move(_o.regOpen);
		gameId = std::move(_o.gameId);
		visibility = std::move(_o.visibility);
		sample = std::move(_o.sample);
		name = std::move(_o.name);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		speedDisplay = std::move(_o.speedDisplay);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		prizePool = std::move(_o.prizePool);
		prizePoolUnit = std::move(_o.prizePoolUnit);
		prizePoolMoneyValue = std::move(_o.prizePoolMoneyValue);
		playerPerTable = std::move(_o.playerPerTable);
		minPlayers = std::move(_o.minPlayers);
		maxUserRequests = std::move(_o.maxUserRequests);
		customSpeedDisplayName = std::move(_o.customSpeedDisplayName);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
	}
	return *this;
}

#endif

void _Pupil::GameStaticLeaf::clear()
{
	visible = false;
	regOpen = false;
	gameId = 0;
	visibility.clear();
	sample.clear();
	name.clear();
	handType = 0;
	structure = 0;
	isHiLo = false;
	speedDisplay = 0;
	isPlayMoney = false;
	currency.clear();
	buyIn = 0;
	rake = 0;
	prizePool = 0;
	prizePoolUnit = 0;
	prizePoolMoneyValue = 0;
	playerPerTable = 0;
	minPlayers = 0;
	maxUserRequests = 0;
	customSpeedDisplayName.clear();
	tournFlags = 0;
	tournFlags2 = 0;
	tournFlagsServInt = 0;
}

bool _Pupil::GameStaticLeaf::equals(const GameStaticLeaf& _o) const
{
	return visible == _o.visible &&
		regOpen == _o.regOpen &&
		gameId == _o.gameId &&
		visibility.equals(_o.visibility) &&
		sample.equals(_o.sample) &&
		name.equals(_o.name) &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		speedDisplay == _o.speedDisplay &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		prizePool == _o.prizePool &&
		prizePoolUnit == _o.prizePoolUnit &&
		prizePoolMoneyValue == _o.prizePoolMoneyValue &&
		playerPerTable == _o.playerPerTable &&
		minPlayers == _o.minPlayers &&
		maxUserRequests == _o.maxUserRequests &&
		customSpeedDisplayName.equals(_o.customSpeedDisplayName) &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		tournFlagsServInt == _o.tournFlagsServInt;
}

const char *_Pupil::GameStaticLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("visible=");
	_buf.appendUint(visible);
	if( visible )
	{
		_buf.append(',');
		_buf.append("regOpen=");
		_buf.appendUint(regOpen);
		_buf.append(',');
		_buf.append("gameId=");
		_buf.appendUint(gameId);
		_buf.append(',');
		_buf.append("visibility=");
		visibility.toTraceString(_buf);
		_buf.append(',');
		_buf.append("sample=");
		sample.toTraceString(_buf);
		_buf.append(',');
		_buf.append("name=");
		Atf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
		_buf.append(',');
		_buf.append("handType=");
		_buf.appendUint(handType);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("speedDisplay=");
		_buf.appendUint(speedDisplay);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendInt64(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendInt64(rake);
		_buf.append(',');
		_buf.append("prizePool=");
		_buf.appendInt64(prizePool);
		_buf.append(',');
		_buf.append("prizePoolUnit=");
		_buf.appendUint(prizePoolUnit);
		_buf.append(',');
		_buf.append("prizePoolMoneyValue=");
		_buf.appendInt64(prizePoolMoneyValue);
		_buf.append(',');
		_buf.append("playerPerTable=");
		_buf.appendUint(playerPerTable);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxUserRequests=");
		_buf.appendUint(maxUserRequests);
		_buf.append(',');
		_buf.append("customSpeedDisplayName=");
		Atf::AtfTempl<I18nPString>::ToTraceString(_buf, customSpeedDisplayName);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
		_buf.append(',');
		_buf.append("tournFlagsServInt=");
		_buf.appendUint(tournFlagsServInt);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *_Pupil::GameStaticLeaf::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("visible", visible, _buf);
	if( visible )
	{
		Atf::XmlElement::encodeAsXmlElement("regOpen", regOpen, _buf);
		Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
		visibility.toXmlString("visibility", _buf);
		sample.toXmlString("sample", _buf);
		Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "name", name);
		Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("prizePool", prizePool, _buf);
		Atf::XmlElement::encodeAsXmlElement("prizePoolUnit", prizePoolUnit, _buf);
		Atf::XmlElement::encodeAsXmlElement("prizePoolMoneyValue", prizePoolMoneyValue, _buf);
		Atf::XmlElement::encodeAsXmlElement("playerPerTable", playerPerTable, _buf);
		Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxUserRequests", maxUserRequests, _buf);
		Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "customSpeedDisplayName", customSpeedDisplayName);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool _Pupil::GameStaticLeaf::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("visible"))
		{
			visible = (*_value.ptr() == '1');
		}
		else if (_element.equals("regOpen"))
		{
			regOpen = (*_value.ptr() == '1');
		}
		else if (_element.equals("gameId"))
		{
			gameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibility"))
		{
			if(!Atf::AtfTempl< _VisibilityType >::FromXmlString(_value, visibility)) return false;
		}
		else if (_element.equals("sample"))
		{
			if(!Atf::AtfTempl< _SampleType >::FromXmlString(_value, sample)) return false;
		}
		else if (_element.equals("name"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, name);
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("speedDisplay"))
		{
			speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePool"))
		{
			prizePool = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolUnit"))
		{
			prizePoolUnit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolMoneyValue"))
		{
			prizePoolMoneyValue = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerPerTable"))
		{
			playerPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPlayers"))
		{
			minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxUserRequests"))
		{
			maxUserRequests = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("customSpeedDisplayName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, customSpeedDisplayName);
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlagsServInt"))
		{
			tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void _Pupil::GameStaticLeaf::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(visible);
	if( visible )
	{
		_msg.composeBOOL(regOpen);
		_msg.composeUINT32(gameId);
		visibility.composeMsg(_msg, _ignoreJSON);
		sample.composeMsg(_msg, _ignoreJSON);
		name.compose(_msg);
		_msg.composeBYTE(handType);
		_msg.composeBYTE(structure);
		_msg.composeBOOL(isHiLo);
		_msg.composeBYTE(speedDisplay);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeString(currency);
		_msg.composeINT64(buyIn);
		_msg.composeINT64(rake);
		_msg.composeINT64(prizePool);
		_msg.composeBYTE(prizePoolUnit);
		_msg.composeINT64(prizePoolMoneyValue);
		_msg.composeBYTE(playerPerTable);
		_msg.composeUINT32(minPlayers);
		_msg.composeBYTE(maxUserRequests);
		customSpeedDisplayName.compose(_msg);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT64(tournFlags2);
		_msg.composeUINT32(tournFlagsServInt);
	}
}

void _Pupil::GameStaticLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(visible);
	if( visible )
	{
		_parser.parseBOOL(regOpen);
		_parser.parseUINT32(gameId);
		visibility.parseMsg(_parser);
		sample.parseMsg(_parser);
		name.parse(_parser);
		_parser.parseBYTE(handType);
		_parser.parseBYTE(structure);
		_parser.parseBOOL(isHiLo);
		_parser.parseBYTE(speedDisplay);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseStringP(currency);
		_parser.parseINT64(buyIn);
		_parser.parseINT64(rake);
		_parser.parseINT64(prizePool);
		_parser.parseBYTE(prizePoolUnit);
		_parser.parseINT64(prizePoolMoneyValue);
		_parser.parseBYTE(playerPerTable);
		_parser.parseUINT32(minPlayers);
		_parser.parseBYTE(maxUserRequests);
		customSpeedDisplayName.parse(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT64(tournFlags2);
		_parser.parseUINT32(tournFlagsServInt);
	}
}

const char *_Pupil::GameStaticLeaf::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("visible", visible);
	if( visible )
	{
		_jsonstr.compose("regOpen", regOpen);
		_jsonstr.compose("gameId", gameId);
		_jsonstr.compose("visibility", visibility);
		_jsonstr.compose("sample", sample);
		_jsonstr.compose("name", name);
		_jsonstr.compose("handType", handType);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("speedDisplay", speedDisplay);
		_jsonstr.compose("isPlayMoney", isPlayMoney);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("buyIn", buyIn);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("prizePool", prizePool);
		_jsonstr.compose("prizePoolUnit", prizePoolUnit);
		_jsonstr.compose("prizePoolMoneyValue", prizePoolMoneyValue);
		_jsonstr.compose("playerPerTable", playerPerTable);
		_jsonstr.compose("minPlayers", minPlayers);
		_jsonstr.compose("maxUserRequests", maxUserRequests);
		_jsonstr.compose("customSpeedDisplayName", customSpeedDisplayName);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("tournFlags2", tournFlags2);
		_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
	}
	return _buf.c_str();
}

void _Pupil::GameStaticLeaf::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("visible", visible);
	if( visible )
	{
		_jparser.parseByNameThrow("regOpen", regOpen);
		_jparser.parseByNameThrow("gameId", gameId);
		_jparser.parseByNameThrow("visibility", visibility);
		_jparser.parseByNameThrow("sample", sample);
		_jparser.parseByNameThrow("name", name);
		_jparser.parseByNameThrow("handType", handType);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("speedDisplay", speedDisplay);
		_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("buyIn", buyIn);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("prizePool", prizePool);
		_jparser.parseByNameThrow("prizePoolUnit", prizePoolUnit);
		_jparser.parseByNameThrow("prizePoolMoneyValue", prizePoolMoneyValue);
		_jparser.parseByNameThrow("playerPerTable", playerPerTable);
		_jparser.parseByNameThrow("minPlayers", minPlayers);
		_jparser.parseByNameThrow("maxUserRequests", maxUserRequests);
		_jparser.parseByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("tournFlags2", tournFlags2);
		_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
	}
}

/* static */ void _Pupil::GameStaticLeaf::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool visible = false;
	_jparser.validateByNameThrow("visible", visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	if( visible )
	{
		bool regOpen; _jparser.validateByNameThrow("regOpen", regOpen);
		AtfValidator::validateInt(_descr, "regOpen", regOpen, _checker, __FILE__, __LINE__);
		UINT32 gameId; _jparser.validateByNameThrow("gameId", gameId);
		AtfValidator::validateInt(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
		_VisibilityType visibility; _jparser.validateByNameThrow("visibility", visibility);
		_SampleType sample; _jparser.validateByNameThrow("sample", sample);
		I18nPString name; _jparser.validateByNameThrow("name", name);
		BYTE handType; _jparser.validateByNameThrow("handType", handType);
		AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		INT64 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		INT64 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		INT64 prizePool; _jparser.validateByNameThrow("prizePool", prizePool);
		AtfValidator::validateInt(_descr, "prizePool", prizePool, _checker, __FILE__, __LINE__);
		BYTE prizePoolUnit; _jparser.validateByNameThrow("prizePoolUnit", prizePoolUnit);
		AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
		INT64 prizePoolMoneyValue; _jparser.validateByNameThrow("prizePoolMoneyValue", prizePoolMoneyValue);
		AtfValidator::validateInt(_descr, "prizePoolMoneyValue", prizePoolMoneyValue, _checker, __FILE__, __LINE__);
		BYTE playerPerTable; _jparser.validateByNameThrow("playerPerTable", playerPerTable);
		AtfValidator::validateInt(_descr, "playerPerTable", playerPerTable, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		BYTE maxUserRequests; _jparser.validateByNameThrow("maxUserRequests", maxUserRequests);
		AtfValidator::validateInt(_descr, "maxUserRequests", maxUserRequests, _checker, __FILE__, __LINE__);
		I18nPString customSpeedDisplayName; _jparser.validateByNameThrow("customSpeedDisplayName", customSpeedDisplayName);
		if(_jparser.parseEnded()) return;
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void _Pupil::GameStaticLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool visible = false;
	_parser.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	if( visible )
	{
		bool regOpen; _parser.parseBOOL(regOpen);
		AtfValidator::validateInt(_descr, "regOpen", regOpen, _checker, __FILE__, __LINE__);
		UINT32 gameId; _parser.parseUINT32(gameId);
		AtfValidator::validateInt(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
		PString _descbuf;
		_VisibilityType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibility"), _fieldsWithUnparsedContent);
		_SampleType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sample"), _fieldsWithUnparsedContent);
		I18nPString name; name.parse(_parser);
		BYTE handType; _parser.parseBYTE(handType);
		AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
		AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		INT64 buyIn; _parser.parseINT64(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		INT64 rake; _parser.parseINT64(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		INT64 prizePool; _parser.parseINT64(prizePool);
		AtfValidator::validateInt(_descr, "prizePool", prizePool, _checker, __FILE__, __LINE__);
		BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
		AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
		INT64 prizePoolMoneyValue; _parser.parseINT64(prizePoolMoneyValue);
		AtfValidator::validateInt(_descr, "prizePoolMoneyValue", prizePoolMoneyValue, _checker, __FILE__, __LINE__);
		BYTE playerPerTable; _parser.parseBYTE(playerPerTable);
		AtfValidator::validateInt(_descr, "playerPerTable", playerPerTable, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		BYTE maxUserRequests; _parser.parseBYTE(maxUserRequests);
		AtfValidator::validateInt(_descr, "maxUserRequests", maxUserRequests, _checker, __FILE__, __LINE__);
		I18nPString customSpeedDisplayName; customSpeedDisplayName.parse(_parser);
		if(_parser.parseEnded()) return;
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
		AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    GameDynamicLeaf
//=================================================================

_Pupil::GameDynamicLeaf::GameDynamicLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

_Pupil::GameDynamicLeaf::GameDynamicLeaf(GameDynamicLeaf&& _o)
	: numUsersWaiting(std::move(_o.numUsersWaiting))
	, numUsersPlaying(std::move(_o.numUsersPlaying))
	, numUsersRegistered(std::move(_o.numUsersRegistered))
	, numDistinctUsersWaiting(std::move(_o.numDistinctUsersWaiting))
	, numActiveGames(std::move(_o.numActiveGames))
{
}

_Pupil::GameDynamicLeaf& _Pupil::GameDynamicLeaf::operator=(GameDynamicLeaf&& _o)
{
	if(this != &_o)
	{
		numUsersWaiting = std::move(_o.numUsersWaiting);
		numUsersPlaying = std::move(_o.numUsersPlaying);
		numUsersRegistered = std::move(_o.numUsersRegistered);
		numDistinctUsersWaiting = std::move(_o.numDistinctUsersWaiting);
		numActiveGames = std::move(_o.numActiveGames);
	}
	return *this;
}

#endif

void _Pupil::GameDynamicLeaf::clear()
{
	numUsersWaiting = 0;
	numUsersPlaying = 0;
	numUsersRegistered = 0;
	numDistinctUsersWaiting = 0;
	numActiveGames = 0;
}

bool _Pupil::GameDynamicLeaf::equals(const GameDynamicLeaf& _o) const
{
	return numUsersWaiting == _o.numUsersWaiting &&
		numUsersPlaying == _o.numUsersPlaying &&
		numUsersRegistered == _o.numUsersRegistered &&
		numDistinctUsersWaiting == _o.numDistinctUsersWaiting &&
		numActiveGames == _o.numActiveGames;
}

const char *_Pupil::GameDynamicLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsersWaiting=");
	_buf.appendUint(numUsersWaiting);
	_buf.append(',');
	_buf.append("numUsersPlaying=");
	_buf.appendUint(numUsersPlaying);
	_buf.append(',');
	_buf.append("numUsersRegistered=");
	_buf.appendUint(numUsersRegistered);
	_buf.append(',');
	_buf.append("numDistinctUsersWaiting=");
	_buf.appendUint(numDistinctUsersWaiting);
	_buf.append(',');
	_buf.append("numActiveGames=");
	_buf.appendUint(numActiveGames);
	_buf.append('}');
	return _buf.c_str();
}

const char *_Pupil::GameDynamicLeaf::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numUsersWaiting", numUsersWaiting, _buf);
	Atf::XmlElement::encodeAsXmlElement("numUsersPlaying", numUsersPlaying, _buf);
	Atf::XmlElement::encodeAsXmlElement("numUsersRegistered", numUsersRegistered, _buf);
	Atf::XmlElement::encodeAsXmlElement("numDistinctUsersWaiting", numDistinctUsersWaiting, _buf);
	Atf::XmlElement::encodeAsXmlElement("numActiveGames", numActiveGames, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool _Pupil::GameDynamicLeaf::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numUsersWaiting"))
		{
			numUsersWaiting = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numUsersPlaying"))
		{
			numUsersPlaying = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numUsersRegistered"))
		{
			numUsersRegistered = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numDistinctUsersWaiting"))
		{
			numDistinctUsersWaiting = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numActiveGames"))
		{
			numActiveGames = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void _Pupil::GameDynamicLeaf::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(numUsersWaiting);
	_msg.composeUINT32(numUsersPlaying);
	_msg.composeUINT32(numUsersRegistered);
	_msg.composeUINT32(numDistinctUsersWaiting);
	_msg.composeUINT32(numActiveGames);
}

void _Pupil::GameDynamicLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(numUsersWaiting);
	_parser.parseUINT32(numUsersPlaying);
	_parser.parseUINT32(numUsersRegistered);
	_parser.parseUINT32(numDistinctUsersWaiting);
	_parser.parseUINT32(numActiveGames);
}

const char *_Pupil::GameDynamicLeaf::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numUsersWaiting", numUsersWaiting);
	_jsonstr.compose("numUsersPlaying", numUsersPlaying);
	_jsonstr.compose("numUsersRegistered", numUsersRegistered);
	_jsonstr.compose("numDistinctUsersWaiting", numDistinctUsersWaiting);
	_jsonstr.compose("numActiveGames", numActiveGames);
	return _buf.c_str();
}

void _Pupil::GameDynamicLeaf::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numUsersWaiting", numUsersWaiting);
	_jparser.parseByNameThrow("numUsersPlaying", numUsersPlaying);
	_jparser.parseByNameThrow("numUsersRegistered", numUsersRegistered);
	_jparser.parseByNameThrow("numDistinctUsersWaiting", numDistinctUsersWaiting);
	_jparser.parseByNameThrow("numActiveGames", numActiveGames);
}

/* static */ void _Pupil::GameDynamicLeaf::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 numUsersWaiting; _jparser.validateByNameThrow("numUsersWaiting", numUsersWaiting);
	AtfValidator::validateInt(_descr, "numUsersWaiting", numUsersWaiting, _checker, __FILE__, __LINE__);
	UINT32 numUsersPlaying; _jparser.validateByNameThrow("numUsersPlaying", numUsersPlaying);
	AtfValidator::validateInt(_descr, "numUsersPlaying", numUsersPlaying, _checker, __FILE__, __LINE__);
	UINT32 numUsersRegistered; _jparser.validateByNameThrow("numUsersRegistered", numUsersRegistered);
	AtfValidator::validateInt(_descr, "numUsersRegistered", numUsersRegistered, _checker, __FILE__, __LINE__);
	UINT32 numDistinctUsersWaiting; _jparser.validateByNameThrow("numDistinctUsersWaiting", numDistinctUsersWaiting);
	AtfValidator::validateInt(_descr, "numDistinctUsersWaiting", numDistinctUsersWaiting, _checker, __FILE__, __LINE__);
	UINT32 numActiveGames; _jparser.validateByNameThrow("numActiveGames", numActiveGames);
	AtfValidator::validateInt(_descr, "numActiveGames", numActiveGames, _checker, __FILE__, __LINE__);
}

/*static*/ void _Pupil::GameDynamicLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 numUsersWaiting; _parser.parseUINT32(numUsersWaiting);
	AtfValidator::validateInt(_descr, "numUsersWaiting", numUsersWaiting, _checker, __FILE__, __LINE__);
	UINT32 numUsersPlaying; _parser.parseUINT32(numUsersPlaying);
	AtfValidator::validateInt(_descr, "numUsersPlaying", numUsersPlaying, _checker, __FILE__, __LINE__);
	UINT32 numUsersRegistered; _parser.parseUINT32(numUsersRegistered);
	AtfValidator::validateInt(_descr, "numUsersRegistered", numUsersRegistered, _checker, __FILE__, __LINE__);
	UINT32 numDistinctUsersWaiting; _parser.parseUINT32(numDistinctUsersWaiting);
	AtfValidator::validateInt(_descr, "numDistinctUsersWaiting", numDistinctUsersWaiting, _checker, __FILE__, __LINE__);
	UINT32 numActiveGames; _parser.parseUINT32(numActiveGames);
	AtfValidator::validateInt(_descr, "numActiveGames", numActiveGames, _checker, __FILE__, __LINE__);
}

