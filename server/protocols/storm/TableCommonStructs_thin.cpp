/**
 * TableCommonStructs_thin.cpp
 *
 * This file was auto-generated from TableCommonStructs.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin TableCommonStructs.txt
 */
 
#include "TableCommonStructs_thin.h"

//=================================================================
//                    P_Card
//=================================================================

// @Override
TableCommonThin::P_Card::P_Card(const Card& card)
{
	suit = card.suit;
	rank = static_cast< BYTE >( card.rank );
}

// @Override
TableCommonThin::P_Card::operator Card()
{
	Card card;
	card.suit = suit;
	card.rank = rank;
	return card;
}

// @Override
TableCommonThin::P_Card::operator const Card() const
{
	Card card;
	card.suit = suit;
	card.rank = rank;
	return card;
}

// @Override
const char *TableCommonThin::P_Card::toTraceString(PString& buf) const
{
	buf.appendUint(rank);
	if(isprint((BYTE)suit))
		buf.append(suit);
	else
		buf.append('.').appendUint((BYTE)suit);
	return buf.c_str();
}

TableCommonThin::P_Card::P_Card()
{
	clear();
}

void TableCommonThin::P_Card::clear()
{
	suit = '0';
	rank = 0;
}

bool TableCommonThin::P_Card::equals(const P_Card& _o) const
{
	return suit == _o.suit &&
		rank == _o.rank;
}

void TableCommonThin::P_Card::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT8(suit);
	_msg.composeBYTE(rank);
}

void TableCommonThin::P_Card::parseMsg(CommMsgParser& _parser)
{
	{ INT8 _n; _parser.parseINT8(_n); suit = _n; }
	_parser.parseBYTE(rank);
}

/*static*/ void TableCommonThin::P_Card::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	char suit; { INT8 _n; _parser.parseINT8(_n); suit = _n; }
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _parser.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_FppFactor
//=================================================================

TableCommonThin::P_FppFactor::P_FppFactor()
{
	clear();
}

void TableCommonThin::P_FppFactor::clear()
{
	fppFactor = 0;
	siteIds = 0;
	happyHourEndTime.setNull();
}

bool TableCommonThin::P_FppFactor::equals(const P_FppFactor& _o) const
{
	return fppFactor == _o.fppFactor &&
		siteIds == _o.siteIds &&
		happyHourEndTime.equals(_o.happyHourEndTime);
}

const char *TableCommonThin::P_FppFactor::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fppFactor=");
	_buf.appendUint(fppFactor);
	_buf.append(',');
	_buf.append("siteIds=");
	_buf.appendUint(siteIds);
	_buf.append(',');
	_buf.append("happyHourEndTime=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, happyHourEndTime);
	_buf.append('}');
	return _buf.c_str();
}

void TableCommonThin::P_FppFactor::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT16(fppFactor);
	_msg.composeUINT32(siteIds);
	_msg.composeSrvTime(happyHourEndTime);
}

void TableCommonThin::P_FppFactor::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(fppFactor);
	_parser.parseUINT32(siteIds);
	_parser.parseSrvTime(happyHourEndTime);
}

/*static*/ void TableCommonThin::P_FppFactor::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT16 fppFactor; _parser.parseUINT16(fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	UINT32 siteIds; _parser.parseUINT32(siteIds);
	AtfValidator::validateInt(_descr, "siteIds", siteIds, _checker, __FILE__, __LINE__);
	CommSrvTime happyHourEndTime; _parser.parseSrvTime(happyHourEndTime);
	AtfValidator::validateSrvDateTime(_descr, "happyHourEndTime", happyHourEndTime, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_FppFactorEx
//=================================================================

TableCommonThin::P_FppFactorEx::P_FppFactorEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommonThin::P_FppFactorEx::P_FppFactorEx(P_FppFactorEx&& _o)
	: fppFactor(std::move(_o.fppFactor))
	, siteMasks(std::move(_o.siteMasks))
	, happyHourEndTime(std::move(_o.happyHourEndTime))
{
}

TableCommonThin::P_FppFactorEx& TableCommonThin::P_FppFactorEx::operator=(P_FppFactorEx&& _o)
{
	if(this != &_o)
	{
		fppFactor = std::move(_o.fppFactor);
		siteMasks = std::move(_o.siteMasks);
		happyHourEndTime = std::move(_o.happyHourEndTime);
	}
	return *this;
}

#endif

void TableCommonThin::P_FppFactorEx::clear()
{
	fppFactor = 0;
	siteMasks.clear();
	happyHourEndTime.setNull();
}

bool TableCommonThin::P_FppFactorEx::equals(const P_FppFactorEx& _o) const
{
	return fppFactor == _o.fppFactor &&
		siteMasks.equals(_o.siteMasks) &&
		happyHourEndTime.equals(_o.happyHourEndTime);
}

const char *TableCommonThin::P_FppFactorEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fppFactor=");
	_buf.appendUint(fppFactor);
	_buf.append(',');
	_buf.append("siteMasks=");
	siteMasks.toTraceString(_buf);
	_buf.append(',');
	_buf.append("happyHourEndTime=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, happyHourEndTime);
	_buf.append('}');
	return _buf.c_str();
}

void TableCommonThin::P_FppFactorEx::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(P_FppFactorEx())) // not empty
	{
		_body.composeUINT16(fppFactor);
		siteMasks.composeMsg(_body);
		_body.composeSrvTime(happyHourEndTime);
	}

	_msg.composeMsgBody(_body);
}

void TableCommonThin::P_FppFactorEx::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT16(fppFactor);
	siteMasks.parseMsg(_parser0);
	_parser0.parseSrvTime(happyHourEndTime);
}

/*static*/ void TableCommonThin::P_FppFactorEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT16 fppFactor; _parser0.parseUINT16(fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("siteMasks"), _fieldsWithUnparsedContent);
	CommSrvTime happyHourEndTime; _parser0.parseSrvTime(happyHourEndTime);
	AtfValidator::validateSrvDateTime(_descr, "happyHourEndTime", happyHourEndTime, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_IniFile_Item
//=================================================================

// @Override
bool TableCommonThin::P_IniFile_Item::equals(const P_IniFile_Item& _o) const
{
	return name.equalsIgnoreCase(_o.name) &&
		value.equals(_o.value);
}

TableCommonThin::P_IniFile_Item::P_IniFile_Item()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommonThin::P_IniFile_Item::P_IniFile_Item(P_IniFile_Item&& _o)
	: name(std::move(_o.name))
	, value(std::move(_o.value))
{
}

TableCommonThin::P_IniFile_Item& TableCommonThin::P_IniFile_Item::operator=(P_IniFile_Item&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		value = std::move(_o.value);
	}
	return *this;
}

#endif

void TableCommonThin::P_IniFile_Item::clear()
{
	name.clear();
	value.clear();
}

const char *TableCommonThin::P_IniFile_Item::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

void TableCommonThin::P_IniFile_Item::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
	_msg.composeString(value);
}

void TableCommonThin::P_IniFile_Item::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseStringP(value);
}

/*static*/ void TableCommonThin::P_IniFile_Item::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "value"); size_t szValue = strlen(_dummy);
	AtfValidator::validateInt(_descr, "value", szValue, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_IniFile_Section
//=================================================================

// @Override
bool TableCommonThin::P_IniFile_Section::equals(const P_IniFile_Section& _o) const
{
	return name.equalsIgnoreCase(_o.name) &&
		items.equals(_o.items);
}

// @Override
const char *TableCommonThin::P_IniFile_Section::getProperty(const char *name_) const
{
	for(auto&& item : items)
	{
		if(item.name.equalsIgnoreCase(name_))
		{
			return item.value;
		}
	}
	return nullptr;
}

// @Override
const char *TableCommonThin::P_IniFile_Section::getProperty(const char *name_, const char* defvalue) const
{
	const char *v = getProperty(name_);
	return v ? v : defvalue;
}

// @Override
int TableCommonThin::P_IniFile_Section::getIntProperty(const char *name_, int defvalue) const
{
	const char *v = getProperty(name_);
	return v ? atoi(v) : defvalue;
}

// @Override
void TableCommonThin::P_IniFile_Section::setProperty(const char* name_, const char* value)
{
	for(auto&& item : items)
	{
		if(!PString::compareIgnoreCase(name_, item.name))
		{
			item.value = value;
			return;
		}
	}
	P_IniFile_Item i;
	i.name = name_;
	i.value = value;
	items.emplace_back(move(i));
}

TableCommonThin::P_IniFile_Section::P_IniFile_Section()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommonThin::P_IniFile_Section::P_IniFile_Section(P_IniFile_Section&& _o)
	: name(std::move(_o.name))
	, items(std::move(_o.items))
{
}

TableCommonThin::P_IniFile_Section& TableCommonThin::P_IniFile_Section::operator=(P_IniFile_Section&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		items = std::move(_o.items);
	}
	return *this;
}

#endif

void TableCommonThin::P_IniFile_Section::clear()
{
	name.clear();
	items.clear();
}

const char *TableCommonThin::P_IniFile_Section::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("items=");
	items.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TableCommonThin::P_IniFile_Section::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
	items.composeMsg(_msg);
}

void TableCommonThin::P_IniFile_Section::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	items.parseMsg(_parser);
}

/*static*/ void TableCommonThin::P_IniFile_Section::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szItems = ThinAtf::LAtfVector< P_IniFile_Item, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("items"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "items", szItems, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardDictionaryItem
//=================================================================

TableCommonThin::CardDictionaryItem::CardDictionaryItem()
{
	clear();
}

void TableCommonThin::CardDictionaryItem::clear()
{
	index.clear();
	card.clear();
}

bool TableCommonThin::CardDictionaryItem::equals(const CardDictionaryItem& _o) const
{
	return index.equals(_o.index) &&
		card.equals(_o.card);
}

const char *TableCommonThin::CardDictionaryItem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("index=");
	index.toTraceString(_buf);
	_buf.append(',');
	_buf.append("card=");
	card.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TableCommonThin::CardDictionaryItem::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CardDictionaryItem())) // not empty
	{
		index.composeMsg(_body);
		card.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void TableCommonThin::CardDictionaryItem::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	index.parseMsg(_parser0);
	card.parseMsg(_parser0);
}

/*static*/ void TableCommonThin::CardDictionaryItem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	P_Card::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("index"), _fieldsWithUnparsedContent);
	P_Card::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("card"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_IniFile
//=================================================================

// @Override
const TableCommonThin::P_IniFile_Section* TableCommonThin::P_IniFile::getSection( const char * name ) const
{
	for(auto&& sec : sections)
	{
		if(sec.name.equalsIgnoreCase(name))
		{
			return &sec;
		}
	}

	return nullptr;
}

TableCommonThin::P_IniFile::P_IniFile()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommonThin::P_IniFile::P_IniFile(P_IniFile&& _o)
	: sections(std::move(_o.sections))
{
}

TableCommonThin::P_IniFile& TableCommonThin::P_IniFile::operator=(P_IniFile&& _o)
{
	if(this != &_o)
	{
		sections = std::move(_o.sections);
	}
	return *this;
}

#endif

void TableCommonThin::P_IniFile::clear()
{
	sections.clear();
}

bool TableCommonThin::P_IniFile::equals(const P_IniFile& _o) const
{
	return sections.equals(_o.sections);
}

const char *TableCommonThin::P_IniFile::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sections=");
	sections.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TableCommonThin::P_IniFile::composeMsg(CommMsgBody& _msg) const
{
	sections.composeMsg(_msg);
}

void TableCommonThin::P_IniFile::parseMsg(CommMsgParser& _parser)
{
	sections.parseMsg(_parser);
}

/*static*/ void TableCommonThin::P_IniFile::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szSections = ThinAtf::LAtfVector< P_IniFile_Section, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sections"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sections", szSections, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_ScheduledTournament
//=================================================================

TableCommonThin::P_ScheduledTournament::P_ScheduledTournament()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommonThin::P_ScheduledTournament::P_ScheduledTournament(P_ScheduledTournament&& _o)
	: startTime(std::move(_o.startTime))
	, clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
	, tournId(std::move(_o.tournId))
	, tournName(std::move(_o.tournName))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, knockoutBounty(std::move(_o.knockoutBounty))
	, numPlayers(std::move(_o.numPlayers))
	, isRegistered(std::move(_o.isRegistered))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, maxPlayers(std::move(_o.maxPlayers))
	, tournState(std::move(_o.tournState))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, flags(std::move(_o.flags))
	, scalePM(std::move(_o.scalePM))
{
}

TableCommonThin::P_ScheduledTournament& TableCommonThin::P_ScheduledTournament::operator=(P_ScheduledTournament&& _o)
{
	if(this != &_o)
	{
		startTime = std::move(_o.startTime);
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
		tournId = std::move(_o.tournId);
		tournName = std::move(_o.tournName);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		knockoutBounty = std::move(_o.knockoutBounty);
		numPlayers = std::move(_o.numPlayers);
		isRegistered = std::move(_o.isRegistered);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
		isPlayMoney = std::move(_o.isPlayMoney);
		maxPlayers = std::move(_o.maxPlayers);
		tournState = std::move(_o.tournState);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		flags = std::move(_o.flags);
		scalePM = std::move(_o.scalePM);
	}
	return *this;
}

#endif

void TableCommonThin::P_ScheduledTournament::clear()
{
	startTime.setNull();
	clubId = 0;
	clubName.clear();
	tournId = 0;
	tournName.clear();
	gameType = 0;
	isHiLo = false;
	buyin = 0;
	rake = 0;
	knockoutBounty = 0;
	numPlayers = 0;
	isRegistered = false;
	limit = 0;
	currency.clear();
	isPlayMoney = false;
	maxPlayers = 0;
	tournState = 0;
	server.clear();
	serverObject.clear();
	flags = 0;
	scalePM = 0;
}

bool TableCommonThin::P_ScheduledTournament::equals(const P_ScheduledTournament& _o) const
{
	return startTime.equals(_o.startTime) &&
		clubId == _o.clubId &&
		clubName.equals(_o.clubName) &&
		tournId == _o.tournId &&
		tournName.equals(_o.tournName) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		knockoutBounty == _o.knockoutBounty &&
		numPlayers == _o.numPlayers &&
		isRegistered == _o.isRegistered &&
		limit == _o.limit &&
		currency.equals(_o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		maxPlayers == _o.maxPlayers &&
		tournState == _o.tournState &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		flags == _o.flags &&
		scalePM == _o.scalePM;
}

const char *TableCommonThin::P_ScheduledTournament::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startTime=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("buyin=");
	_buf.appendUint(buyin);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("knockoutBounty=");
	_buf.appendUint(knockoutBounty);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("isRegistered=");
	_buf.appendUint(isRegistered);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("tournState=");
	_buf.appendUint(tournState);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

void TableCommonThin::P_ScheduledTournament::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(startTime);
	_msg.composeUINT32(clubId);
	_msg.composeString(clubName);
	_msg.composeUINT32(tournId);
	_msg.composeString(tournName);
	_msg.composeBYTE(gameType);
	_msg.composeBOOL(isHiLo);
	_msg.composeUINT32(buyin);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(knockoutBounty);
	_msg.composeUINT32(numPlayers);
	_msg.composeBOOL(isRegistered);
	_msg.composeBYTE(limit);
	_msg.composeString(currency);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(maxPlayers);
	_msg.composeUINT32(tournState);
	_msg.composeString(server);
	_msg.composeString(serverObject);
	_msg.composeUINT32(flags);
	_msg.composeINT32(scalePM);
}

void TableCommonThin::P_ScheduledTournament::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(startTime);
	_parser.parseUINT32(clubId);
	_parser.parseStringP(clubName);
	_parser.parseUINT32(tournId);
	_parser.parseStringP(tournName);
	_parser.parseBYTE(gameType);
	_parser.parseBOOL(isHiLo);
	_parser.parseUINT32(buyin);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(knockoutBounty);
	_parser.parseUINT32(numPlayers);
	_parser.parseBOOL(isRegistered);
	_parser.parseBYTE(limit);
	_parser.parseStringP(currency);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(maxPlayers);
	_parser.parseUINT32(tournState);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObject);
	_parser.parseUINT32(flags);
	_parser.parseINT32(scalePM);
}

/*static*/ void TableCommonThin::P_ScheduledTournament::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	CommSrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 buyin; _parser.parseUINT32(buyin);
	AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockoutBounty; _parser.parseUINT32(knockoutBounty);
	AtfValidator::validateInt(_descr, "knockoutBounty", knockoutBounty, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	bool isRegistered; _parser.parseBOOL(isRegistered);
	AtfValidator::validateInt(_descr, "isRegistered", isRegistered, _checker, __FILE__, __LINE__);
	BYTE limit; _parser.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournState; _parser.parseUINT32(tournState);
	AtfValidator::validateInt(_descr, "tournState", tournState, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableStakes
//=================================================================

TableCommonThin::TableStakes::TableStakes()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommonThin::TableStakes::TableStakes(TableStakes&& _o)
	: antes(std::move(_o.antes))
	, blinds(std::move(_o.blinds))
	, stakes(std::move(_o.stakes))
	, bringIns(std::move(_o.bringIns))
{
}

TableCommonThin::TableStakes& TableCommonThin::TableStakes::operator=(TableStakes&& _o)
{
	if(this != &_o)
	{
		antes = std::move(_o.antes);
		blinds = std::move(_o.blinds);
		stakes = std::move(_o.stakes);
		bringIns = std::move(_o.bringIns);
	}
	return *this;
}

#endif

void TableCommonThin::TableStakes::clear()
{
	antes.clear();
	blinds.clear();
	stakes.clear();
	bringIns.clear();
}

bool TableCommonThin::TableStakes::equals(const TableStakes& _o) const
{
	return antes.equals(_o.antes) &&
		blinds.equals(_o.blinds) &&
		stakes.equals(_o.stakes) &&
		bringIns.equals(_o.bringIns);
}

const char *TableCommonThin::TableStakes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("antes=");
	antes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("blinds=");
	blinds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("stakes=");
	stakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bringIns=");
	bringIns.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TableCommonThin::TableStakes::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TableStakes())) // not empty
	{
		antes.composeMsg(_body);
		blinds.composeMsg(_body);
		stakes.composeMsg(_body);
		bringIns.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void TableCommonThin::TableStakes::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	antes.parseMsg(_parser0);
	blinds.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	stakes.parseMsg(_parser0);
	bringIns.parseMsg(_parser0);
}

/*static*/ void TableCommonThin::TableStakes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szAntes = ThinAtf::LAtfVector< INT64 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("antes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "antes", szAntes, _checker, __FILE__, __LINE__);
	int szBlinds = ThinAtf::LAtfVector< INT64 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("blinds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "blinds", szBlinds, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	int szStakes = ThinAtf::LAtfVector< INT64 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("stakes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "stakes", szStakes, _checker, __FILE__, __LINE__);
	int szBringIns = ThinAtf::LAtfVector< INT64 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("bringIns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "bringIns", szBringIns, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

