/**
 * TableCommonStructs.cpp
 *
 * This file was auto-generated from TableCommonStructs.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor TableCommonStructs.txt
 */
 
#include "TableCommonStructs.h"

//=================================================================
//                    P_Card
//=================================================================

// @Override
TableCommon::P_Card::P_Card(const Card& card)
{
	suit = card.suit;
	rank = static_cast< BYTE >( card.rank );
}

// @Override
TableCommon::P_Card::operator Card()
{
	Card card;
	card.suit = suit;
	card.rank = rank;
	return card;
}

// @Override
TableCommon::P_Card::operator const Card() const
{
	Card card;
	card.suit = suit;
	card.rank = rank;
	return card;
}

// @Override
const char *TableCommon::P_Card::toTraceString(PString& buf) const
{
	buf.appendUint(rank);
	if(isprint((BYTE)suit))
		buf.append(suit);
	else
		buf.append('.').appendUint((BYTE)suit);
	return buf.c_str();
}

TableCommon::P_Card::P_Card()
{
	clear();
}

void TableCommon::P_Card::clear()
{
	suit = '0';
	rank = 0;
}

bool TableCommon::P_Card::equals(const P_Card& _o) const
{
	return suit == _o.suit &&
		rank == _o.rank;
}

const char *TableCommon::P_Card::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("suit", suit, _buf);
	Atf::XmlElement::encodeAsXmlElement("rank", rank, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableCommon::P_Card::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("suit"))
		{
			suit = *_value.ptr();
		}
		else if (_element.equals("rank"))
		{
			rank = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableCommon::P_Card::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(suit);
	_msg.composeBYTE(rank);
}

void TableCommon::P_Card::parseMsg(CommMsgParser& _parser)
{
	{ INT8 _n; _parser.parseINT8(_n); suit = _n; }
	_parser.parseBYTE(rank);
}

const char *TableCommon::P_Card::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("suit", suit);
	_jsonstr.compose("rank", rank);
	return _buf.c_str();
}

void TableCommon::P_Card::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("suit", suit);
	_jparser.parseByNameThrow("rank", rank);
}

/* static */ void TableCommon::P_Card::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	char suit; _jparser.validateByNameThrow("suit", suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _jparser.validateByNameThrow("rank", rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
}

/*static*/ void TableCommon::P_Card::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	char suit; { INT8 _n; _parser.parseINT8(_n); suit = _n; }
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _parser.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_FppFactor
//=================================================================

TableCommon::P_FppFactor::P_FppFactor()
{
	clear();
}

void TableCommon::P_FppFactor::clear()
{
	fppFactor = 0;
	siteIds = 0;
	happyHourEndTime.setNull();
}

bool TableCommon::P_FppFactor::equals(const P_FppFactor& _o) const
{
	return fppFactor == _o.fppFactor &&
		siteIds == _o.siteIds &&
		happyHourEndTime.equals(_o.happyHourEndTime);
}

const char *TableCommon::P_FppFactor::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fppFactor=");
	_buf.appendUint(fppFactor);
	_buf.append(',');
	_buf.append("siteIds=");
	_buf.appendUint(siteIds);
	_buf.append(',');
	_buf.append("happyHourEndTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, happyHourEndTime);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableCommon::P_FppFactor::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fppFactor", fppFactor, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteIds", siteIds, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "happyHourEndTime", happyHourEndTime);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableCommon::P_FppFactor::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fppFactor"))
		{
			fppFactor = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteIds"))
		{
			siteIds = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("happyHourEndTime"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, happyHourEndTime);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableCommon::P_FppFactor::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(fppFactor);
	_msg.composeUINT32(siteIds);
	_msg.composeSrvTime(happyHourEndTime);
}

void TableCommon::P_FppFactor::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(fppFactor);
	_parser.parseUINT32(siteIds);
	_parser.parseSrvTime(happyHourEndTime);
}

const char *TableCommon::P_FppFactor::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fppFactor", fppFactor);
	_jsonstr.compose("siteIds", siteIds);
	_jsonstr.compose("happyHourEndTime", happyHourEndTime);
	return _buf.c_str();
}

void TableCommon::P_FppFactor::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fppFactor", fppFactor);
	_jparser.parseByNameThrow("siteIds", siteIds);
	_jparser.parseByNameThrow("happyHourEndTime", happyHourEndTime);
}

/* static */ void TableCommon::P_FppFactor::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 fppFactor; _jparser.validateByNameThrow("fppFactor", fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	UINT32 siteIds; _jparser.validateByNameThrow("siteIds", siteIds);
	AtfValidator::validateInt(_descr, "siteIds", siteIds, _checker, __FILE__, __LINE__);
	CommSrvTime happyHourEndTime; _jparser.validateByNameThrow("happyHourEndTime", happyHourEndTime);
	AtfValidator::validateSrvDateTime(_descr, "happyHourEndTime", happyHourEndTime, _checker, __FILE__, __LINE__);
}

/*static*/ void TableCommon::P_FppFactor::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT16 fppFactor; _parser.parseUINT16(fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	UINT32 siteIds; _parser.parseUINT32(siteIds);
	AtfValidator::validateInt(_descr, "siteIds", siteIds, _checker, __FILE__, __LINE__);
	CommSrvTime happyHourEndTime; _parser.parseSrvTime(happyHourEndTime);
	AtfValidator::validateSrvDateTime(_descr, "happyHourEndTime", happyHourEndTime, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_FppFactorEx
//=================================================================

TableCommon::P_FppFactorEx::P_FppFactorEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommon::P_FppFactorEx::P_FppFactorEx(P_FppFactorEx&& _o)
	: fppFactor(std::move(_o.fppFactor))
	, siteMasks(std::move(_o.siteMasks))
	, happyHourEndTime(std::move(_o.happyHourEndTime))
{
}

TableCommon::P_FppFactorEx& TableCommon::P_FppFactorEx::operator=(P_FppFactorEx&& _o)
{
	if(this != &_o)
	{
		fppFactor = std::move(_o.fppFactor);
		siteMasks = std::move(_o.siteMasks);
		happyHourEndTime = std::move(_o.happyHourEndTime);
	}
	return *this;
}

#endif

void TableCommon::P_FppFactorEx::clear()
{
	fppFactor = 0;
	siteMasks.clear();
	happyHourEndTime.setNull();
}

bool TableCommon::P_FppFactorEx::equals(const P_FppFactorEx& _o) const
{
	return fppFactor == _o.fppFactor &&
		siteMasks.equals(_o.siteMasks) &&
		happyHourEndTime.equals(_o.happyHourEndTime);
}

const char *TableCommon::P_FppFactorEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fppFactor=");
	_buf.appendUint(fppFactor);
	_buf.append(',');
	_buf.append("siteMasks=");
	siteMasks.toTraceString(_buf);
	_buf.append(',');
	_buf.append("happyHourEndTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, happyHourEndTime);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableCommon::P_FppFactorEx::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fppFactor", fppFactor, _buf);
	siteMasks.toXmlString("siteMasks", _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "happyHourEndTime", happyHourEndTime);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableCommon::P_FppFactorEx::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fppFactor"))
		{
			fppFactor = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteMasks"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, siteMasks)) return false;
		}
		else if (_element.equals("happyHourEndTime"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, happyHourEndTime);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableCommon::P_FppFactorEx::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(P_FppFactorEx())) // not empty
	{
		_body.composeUINT16(fppFactor);
		siteMasks.composeMsg(_body, _ignoreJSON);
		_body.composeSrvTime(happyHourEndTime);
	}

	_msg.composeMsgBody(_body);
}

void TableCommon::P_FppFactorEx::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT16(fppFactor);
	siteMasks.parseMsg(_parser0);
	_parser0.parseSrvTime(happyHourEndTime);
}

const char *TableCommon::P_FppFactorEx::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fppFactor", fppFactor);
	_jsonstr.compose("siteMasks", siteMasks);
	_jsonstr.compose("happyHourEndTime", happyHourEndTime);
	return _buf.c_str();
}

void TableCommon::P_FppFactorEx::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fppFactor", fppFactor);
	_jparser.parseByNameThrow("siteMasks", siteMasks);
	_jparser.parseByNameThrow("happyHourEndTime", happyHourEndTime);
}

/* static */ void TableCommon::P_FppFactorEx::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 fppFactor; _jparser.validateByNameThrow("fppFactor", fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	PSiteMask siteMasks; _jparser.validateByNameThrow("siteMasks", siteMasks);
	CommSrvTime happyHourEndTime; _jparser.validateByNameThrow("happyHourEndTime", happyHourEndTime);
	AtfValidator::validateSrvDateTime(_descr, "happyHourEndTime", happyHourEndTime, _checker, __FILE__, __LINE__);
}

/*static*/ void TableCommon::P_FppFactorEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT16 fppFactor; _parser0.parseUINT16(fppFactor);
	AtfValidator::validateInt(_descr, "fppFactor", fppFactor, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("siteMasks"), _fieldsWithUnparsedContent);
	CommSrvTime happyHourEndTime; _parser0.parseSrvTime(happyHourEndTime);
	AtfValidator::validateSrvDateTime(_descr, "happyHourEndTime", happyHourEndTime, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_IniFile_Item
//=================================================================

// @Override
bool TableCommon::P_IniFile_Item::equals(const P_IniFile_Item& _o) const
{
	return name.equalsIgnoreCase(_o.name) &&
		value.equals(_o.value);
}

TableCommon::P_IniFile_Item::P_IniFile_Item()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommon::P_IniFile_Item::P_IniFile_Item(P_IniFile_Item&& _o)
	: name(std::move(_o.name))
	, value(std::move(_o.value))
{
}

TableCommon::P_IniFile_Item& TableCommon::P_IniFile_Item::operator=(P_IniFile_Item&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		value = std::move(_o.value);
	}
	return *this;
}

#endif

void TableCommon::P_IniFile_Item::clear()
{
	name.clear();
	value.clear();
}

const char *TableCommon::P_IniFile_Item::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableCommon::P_IniFile_Item::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableCommon::P_IniFile_Item::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("value"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, value)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableCommon::P_IniFile_Item::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
	_msg.composeString(value);
}

void TableCommon::P_IniFile_Item::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseStringP(value);
}

const char *TableCommon::P_IniFile_Item::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("value", value);
	return _buf.c_str();
}

void TableCommon::P_IniFile_Item::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("value", value);
}

/* static */ void TableCommon::P_IniFile_Item::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableCommon::P_IniFile_Item::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "value"); size_t szValue = strlen(_dummy);
	AtfValidator::validateInt(_descr, "value", szValue, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_IniFile_Section
//=================================================================

// @Override
bool TableCommon::P_IniFile_Section::equals(const P_IniFile_Section& _o) const
{
	return name.equalsIgnoreCase(_o.name) &&
		items.equals(_o.items);
}

// @Override
const char *TableCommon::P_IniFile_Section::getProperty(const char *name_) const
{
	for(auto&& item : items)
	{
		if(item.name.equalsIgnoreCase(name_))
		{
			return item.value;
		}
	}
	return nullptr;
}

// @Override
const char *TableCommon::P_IniFile_Section::getProperty(const char *name_, const char* defvalue) const
{
	const char *v = getProperty(name_);
	return v ? v : defvalue;
}

// @Override
int TableCommon::P_IniFile_Section::getIntProperty(const char *name_, int defvalue) const
{
	const char *v = getProperty(name_);
	return v ? atoi(v) : defvalue;
}

// @Override
void TableCommon::P_IniFile_Section::setProperty(const char* name_, const char* value)
{
	for(auto&& item : items)
	{
		if(!PString::compareIgnoreCase(name_, item.name))
		{
			item.value = value;
			return;
		}
	}
	P_IniFile_Item i;
	i.name = name_;
	i.value = value;
	items.emplace_back(move(i));
}

TableCommon::P_IniFile_Section::P_IniFile_Section()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommon::P_IniFile_Section::P_IniFile_Section(P_IniFile_Section&& _o)
	: name(std::move(_o.name))
	, items(std::move(_o.items))
{
}

TableCommon::P_IniFile_Section& TableCommon::P_IniFile_Section::operator=(P_IniFile_Section&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		items = std::move(_o.items);
	}
	return *this;
}

#endif

void TableCommon::P_IniFile_Section::clear()
{
	name.clear();
	items.clear();
}

const char *TableCommon::P_IniFile_Section::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("items=");
	items.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableCommon::P_IniFile_Section::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	items.toXmlString("items", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableCommon::P_IniFile_Section::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("items"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< P_IniFile_Item, 4 > >::FromXmlString(_value, items)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableCommon::P_IniFile_Section::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
	items.composeMsg(_msg, _ignoreJSON);
}

void TableCommon::P_IniFile_Section::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	items.parseMsg(_parser);
}

const char *TableCommon::P_IniFile_Section::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("items", items);
	return _buf.c_str();
}

void TableCommon::P_IniFile_Section::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("items", items);
}

/* static */ void TableCommon::P_IniFile_Section::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_IniFile_Item > items; _jparser.validateByNameThrow("items", items);
	AtfValidator::validateInt(_descr, "items", items.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableCommon::P_IniFile_Section::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szItems = Atf::LAtfVector< P_IniFile_Item, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("items"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "items", szItems, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardDictionaryItem
//=================================================================

TableCommon::CardDictionaryItem::CardDictionaryItem()
{
	clear();
}

void TableCommon::CardDictionaryItem::clear()
{
	index.clear();
	card.clear();
}

bool TableCommon::CardDictionaryItem::equals(const CardDictionaryItem& _o) const
{
	return index.equals(_o.index) &&
		card.equals(_o.card);
}

const char *TableCommon::CardDictionaryItem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("index=");
	index.toTraceString(_buf);
	_buf.append(',');
	_buf.append("card=");
	card.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableCommon::CardDictionaryItem::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	index.toXmlString("index", _buf);
	card.toXmlString("card", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableCommon::CardDictionaryItem::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("index"))
		{
			if(!Atf::AtfTempl< P_Card >::FromXmlString(_value, index)) return false;
		}
		else if (_element.equals("card"))
		{
			if(!Atf::AtfTempl< P_Card >::FromXmlString(_value, card)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableCommon::CardDictionaryItem::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CardDictionaryItem())) // not empty
	{
		index.composeMsg(_body, _ignoreJSON);
		card.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TableCommon::CardDictionaryItem::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	index.parseMsg(_parser0);
	card.parseMsg(_parser0);
}

const char *TableCommon::CardDictionaryItem::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("index", index);
	_jsonstr.compose("card", card);
	return _buf.c_str();
}

void TableCommon::CardDictionaryItem::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("index", index);
	_jparser.parseByNameThrow("card", card);
}

/* static */ void TableCommon::CardDictionaryItem::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	P_Card index; _jparser.validateByNameThrow("index", index);
	P_Card card; _jparser.validateByNameThrow("card", card);
}

/*static*/ void TableCommon::CardDictionaryItem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	P_Card::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("index"), _fieldsWithUnparsedContent);
	P_Card::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("card"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_IniFile
//=================================================================

// @Override
const TableCommon::P_IniFile_Section* TableCommon::P_IniFile::getSection( const char * name ) const
{
	for(auto&& sec : sections)
	{
		if(sec.name.equalsIgnoreCase(name))
		{
			return &sec;
		}
	}

	return nullptr;
}

TableCommon::P_IniFile::P_IniFile()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommon::P_IniFile::P_IniFile(P_IniFile&& _o)
	: sections(std::move(_o.sections))
{
}

TableCommon::P_IniFile& TableCommon::P_IniFile::operator=(P_IniFile&& _o)
{
	if(this != &_o)
	{
		sections = std::move(_o.sections);
	}
	return *this;
}

#endif

void TableCommon::P_IniFile::clear()
{
	sections.clear();
}

bool TableCommon::P_IniFile::equals(const P_IniFile& _o) const
{
	return sections.equals(_o.sections);
}

const char *TableCommon::P_IniFile::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sections=");
	sections.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableCommon::P_IniFile::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	sections.toXmlString("sections", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableCommon::P_IniFile::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sections"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< P_IniFile_Section, 4 > >::FromXmlString(_value, sections)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableCommon::P_IniFile::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	sections.composeMsg(_msg, _ignoreJSON);
}

void TableCommon::P_IniFile::parseMsg(CommMsgParser& _parser)
{
	sections.parseMsg(_parser);
}

const char *TableCommon::P_IniFile::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sections", sections);
	return _buf.c_str();
}

void TableCommon::P_IniFile::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sections", sections);
}

/* static */ void TableCommon::P_IniFile::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< P_IniFile_Section > sections; _jparser.validateByNameThrow("sections", sections);
	AtfValidator::validateInt(_descr, "sections", sections.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableCommon::P_IniFile::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szSections = Atf::LAtfVector< P_IniFile_Section, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sections"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sections", szSections, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_ScheduledTournament
//=================================================================

TableCommon::P_ScheduledTournament::P_ScheduledTournament()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommon::P_ScheduledTournament::P_ScheduledTournament(P_ScheduledTournament&& _o)
	: startTime(std::move(_o.startTime))
	, clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
	, tournId(std::move(_o.tournId))
	, tournName(std::move(_o.tournName))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, knockoutBounty(std::move(_o.knockoutBounty))
	, numPlayers(std::move(_o.numPlayers))
	, isRegistered(std::move(_o.isRegistered))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, maxPlayers(std::move(_o.maxPlayers))
	, tournState(std::move(_o.tournState))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, flags(std::move(_o.flags))
	, scalePM(std::move(_o.scalePM))
{
}

TableCommon::P_ScheduledTournament& TableCommon::P_ScheduledTournament::operator=(P_ScheduledTournament&& _o)
{
	if(this != &_o)
	{
		startTime = std::move(_o.startTime);
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
		tournId = std::move(_o.tournId);
		tournName = std::move(_o.tournName);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		knockoutBounty = std::move(_o.knockoutBounty);
		numPlayers = std::move(_o.numPlayers);
		isRegistered = std::move(_o.isRegistered);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
		isPlayMoney = std::move(_o.isPlayMoney);
		maxPlayers = std::move(_o.maxPlayers);
		tournState = std::move(_o.tournState);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		flags = std::move(_o.flags);
		scalePM = std::move(_o.scalePM);
	}
	return *this;
}

#endif

void TableCommon::P_ScheduledTournament::clear()
{
	startTime.setNull();
	clubId = 0;
	clubName.clear();
	tournId = 0;
	tournName.clear();
	gameType = 0;
	isHiLo = false;
	buyin = 0;
	rake = 0;
	knockoutBounty = 0;
	numPlayers = 0;
	isRegistered = false;
	limit = 0;
	currency.clear();
	isPlayMoney = false;
	maxPlayers = 0;
	tournState = 0;
	server.clear();
	serverObject.clear();
	flags = 0;
	scalePM = 0;
}

bool TableCommon::P_ScheduledTournament::equals(const P_ScheduledTournament& _o) const
{
	return startTime.equals(_o.startTime) &&
		clubId == _o.clubId &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(tournName, _o.tournName) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		knockoutBounty == _o.knockoutBounty &&
		numPlayers == _o.numPlayers &&
		isRegistered == _o.isRegistered &&
		limit == _o.limit &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		maxPlayers == _o.maxPlayers &&
		tournState == _o.tournState &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		flags == _o.flags &&
		scalePM == _o.scalePM;
}

const char *TableCommon::P_ScheduledTournament::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("buyin=");
	_buf.appendUint(buyin);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("knockoutBounty=");
	_buf.appendUint(knockoutBounty);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("isRegistered=");
	_buf.appendUint(isRegistered);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("tournState=");
	_buf.appendUint(tournState);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableCommon::P_ScheduledTournament::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "startTime", startTime);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournName", tournName, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyin", buyin, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockoutBounty", knockoutBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRegistered", isRegistered, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournState", tournState, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableCommon::P_ScheduledTournament::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("startTime"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, startTime);
		}
		else if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clubName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournName)) return false;
		}
		else if (_element.equals("gameType"))
		{
			gameType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("buyin"))
		{
			buyin = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockoutBounty"))
		{
			knockoutBounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isRegistered"))
		{
			isRegistered = (*_value.ptr() == '1');
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournState"))
		{
			tournState = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableCommon::P_ScheduledTournament::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(startTime);
	_msg.composeUINT32(clubId);
	_msg.composeString(clubName);
	_msg.composeUINT32(tournId);
	_msg.composeString(tournName);
	_msg.composeBYTE(gameType);
	_msg.composeBOOL(isHiLo);
	_msg.composeUINT32(buyin);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(knockoutBounty);
	_msg.composeUINT32(numPlayers);
	_msg.composeBOOL(isRegistered);
	_msg.composeBYTE(limit);
	_msg.composeString(currency);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(maxPlayers);
	_msg.composeUINT32(tournState);
	_msg.composeString(server);
	_msg.composeString(serverObject);
	_msg.composeUINT32(flags);
	_msg.composeINT32(scalePM);
}

void TableCommon::P_ScheduledTournament::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(startTime);
	_parser.parseUINT32(clubId);
	_parser.parseStringP(clubName);
	_parser.parseUINT32(tournId);
	_parser.parseStringP(tournName);
	_parser.parseBYTE(gameType);
	_parser.parseBOOL(isHiLo);
	_parser.parseUINT32(buyin);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(knockoutBounty);
	_parser.parseUINT32(numPlayers);
	_parser.parseBOOL(isRegistered);
	_parser.parseBYTE(limit);
	_parser.parseStringP(currency);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(maxPlayers);
	_parser.parseUINT32(tournState);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObject);
	_parser.parseUINT32(flags);
	_parser.parseINT32(scalePM);
}

const char *TableCommon::P_ScheduledTournament::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("startTime", startTime);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("clubName", clubName);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("tournName", tournName);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("buyin", buyin);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("knockoutBounty", knockoutBounty);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("isRegistered", isRegistered);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("tournState", tournState);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObject", serverObject);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("scalePM", scalePM);
	return _buf.c_str();
}

void TableCommon::P_ScheduledTournament::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("startTime", startTime);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("clubName", clubName);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("tournName", tournName);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("buyin", buyin);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("knockoutBounty", knockoutBounty);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("isRegistered", isRegistered);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("tournState", tournState);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObject", serverObject);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("scalePM", scalePM);
}

/* static */ void TableCommon::P_ScheduledTournament::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CommSrvTime startTime; _jparser.validateByNameThrow("startTime", startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString clubName; _jparser.validateByNameThrow("clubName", clubName);
	AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString tournName; _jparser.validateByNameThrow("tournName", tournName);
	AtfValidator::validateInt(_descr, "tournName", tournName.length(), _checker, __FILE__, __LINE__);
	BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 buyin; _jparser.validateByNameThrow("buyin", buyin);
	AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockoutBounty; _jparser.validateByNameThrow("knockoutBounty", knockoutBounty);
	AtfValidator::validateInt(_descr, "knockoutBounty", knockoutBounty, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	bool isRegistered; _jparser.validateByNameThrow("isRegistered", isRegistered);
	AtfValidator::validateInt(_descr, "isRegistered", isRegistered, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournState; _jparser.validateByNameThrow("tournState", tournState);
	AtfValidator::validateInt(_descr, "tournState", tournState, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
}

/*static*/ void TableCommon::P_ScheduledTournament::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	CommSrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 buyin; _parser.parseUINT32(buyin);
	AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockoutBounty; _parser.parseUINT32(knockoutBounty);
	AtfValidator::validateInt(_descr, "knockoutBounty", knockoutBounty, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	bool isRegistered; _parser.parseBOOL(isRegistered);
	AtfValidator::validateInt(_descr, "isRegistered", isRegistered, _checker, __FILE__, __LINE__);
	BYTE limit; _parser.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournState; _parser.parseUINT32(tournState);
	AtfValidator::validateInt(_descr, "tournState", tournState, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableStakes
//=================================================================

TableCommon::TableStakes::TableStakes()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableCommon::TableStakes::TableStakes(TableStakes&& _o)
	: antes(std::move(_o.antes))
	, blinds(std::move(_o.blinds))
	, stakes(std::move(_o.stakes))
	, bringIns(std::move(_o.bringIns))
{
}

TableCommon::TableStakes& TableCommon::TableStakes::operator=(TableStakes&& _o)
{
	if(this != &_o)
	{
		antes = std::move(_o.antes);
		blinds = std::move(_o.blinds);
		stakes = std::move(_o.stakes);
		bringIns = std::move(_o.bringIns);
	}
	return *this;
}

#endif

void TableCommon::TableStakes::clear()
{
	antes.clear();
	blinds.clear();
	stakes.clear();
	bringIns.clear();
}

bool TableCommon::TableStakes::equals(const TableStakes& _o) const
{
	return antes.equals(_o.antes) &&
		blinds.equals(_o.blinds) &&
		stakes.equals(_o.stakes) &&
		bringIns.equals(_o.bringIns);
}

const char *TableCommon::TableStakes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("antes=");
	antes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("blinds=");
	blinds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("stakes=");
	stakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bringIns=");
	bringIns.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableCommon::TableStakes::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	antes.toXmlString("antes", _buf);
	blinds.toXmlString("blinds", _buf);
	stakes.toXmlString("stakes", _buf);
	bringIns.toXmlString("bringIns", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableCommon::TableStakes::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("antes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64 , 4 > >::FromXmlString(_value, antes)) return false;
		}
		else if (_element.equals("blinds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64 , 4 > >::FromXmlString(_value, blinds)) return false;
		}
		else if (_element.equals("stakes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64 , 4 > >::FromXmlString(_value, stakes)) return false;
		}
		else if (_element.equals("bringIns"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64 , 4 > >::FromXmlString(_value, bringIns)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableCommon::TableStakes::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableStakes())) // not empty
	{
		antes.composeMsg(_body, _ignoreJSON);
		blinds.composeMsg(_body, _ignoreJSON);
		stakes.composeMsg(_body, _ignoreJSON);
		bringIns.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TableCommon::TableStakes::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	antes.parseMsg(_parser0);
	blinds.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	stakes.parseMsg(_parser0);
	bringIns.parseMsg(_parser0);
}

const char *TableCommon::TableStakes::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("antes", antes);
	_jsonstr.compose("blinds", blinds);
	_jsonstr.compose("stakes", stakes);
	_jsonstr.compose("bringIns", bringIns);
	return _buf.c_str();
}

void TableCommon::TableStakes::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("antes", antes);
	_jparser.parseByNameThrow("blinds", blinds);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("stakes", stakes);
	_jparser.parseByNameThrow("bringIns", bringIns);
}

/* static */ void TableCommon::TableStakes::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > antes; _jparser.validateByNameThrow("antes", antes);
	AtfValidator::validateInt(_descr, "antes", antes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT64 > blinds; _jparser.validateByNameThrow("blinds", blinds);
	AtfValidator::validateInt(_descr, "blinds", blinds.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > stakes; _jparser.validateByNameThrow("stakes", stakes);
	AtfValidator::validateInt(_descr, "stakes", stakes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT64 > bringIns; _jparser.validateByNameThrow("bringIns", bringIns);
	AtfValidator::validateInt(_descr, "bringIns", bringIns.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableCommon::TableStakes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szAntes = Atf::LAtfVector< INT64 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("antes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "antes", szAntes, _checker, __FILE__, __LINE__);
	int szBlinds = Atf::LAtfVector< INT64 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("blinds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "blinds", szBlinds, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	int szStakes = Atf::LAtfVector< INT64 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("stakes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "stakes", szStakes, _checker, __FILE__, __LINE__);
	int szBringIns = Atf::LAtfVector< INT64 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("bringIns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "bringIns", szBringIns, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

