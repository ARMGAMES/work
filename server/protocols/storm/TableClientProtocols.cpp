/**
 * TableClientProtocols.cpp
 *
 * This file was auto-generated from TableClientProtocols.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor TableClientProtocols.txt
 */
 
#include "TableClientProtocols.h"

//=================================================================
//                    PubBoardCardPosition
//=================================================================

// @Override
TableClient::PubBoardCardPosition::PubBoardCardPosition(int boardNum_, int cardNum_)
{
	boardNumber = static_cast< INT8 >( boardNum_ );
	cardNumber = static_cast< INT8 >( cardNum_ );
}

TableClient::PubBoardCardPosition::PubBoardCardPosition()
{
	clear();
}

void TableClient::PubBoardCardPosition::clear()
{
	boardNumber = 0;
	cardNumber = 0;
}

bool TableClient::PubBoardCardPosition::equals(const PubBoardCardPosition& _o) const
{
	return boardNumber == _o.boardNumber &&
		cardNumber == _o.cardNumber;
}

const char *TableClient::PubBoardCardPosition::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("boardNumber=");
	_buf.appendInt(boardNumber);
	_buf.append(',');
	_buf.append("cardNumber=");
	_buf.appendInt(cardNumber);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::PubBoardCardPosition::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("boardNumber", boardNumber, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardNumber", cardNumber, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::PubBoardCardPosition::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("boardNumber"))
		{
			boardNumber = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardNumber"))
		{
			cardNumber = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::PubBoardCardPosition::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(boardNumber);
	_msg.composeINT8(cardNumber);
}

void TableClient::PubBoardCardPosition::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(boardNumber);
	_parser.parseINT8(cardNumber);
}

const char *TableClient::PubBoardCardPosition::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("boardNumber", boardNumber);
	_jsonstr.compose("cardNumber", cardNumber);
	return _buf.c_str();
}

void TableClient::PubBoardCardPosition::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("boardNumber", boardNumber);
	_jparser.parseByNameThrow("cardNumber", cardNumber);
}

/* static */ void TableClient::PubBoardCardPosition::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 boardNumber; _jparser.validateByNameThrow("boardNumber", boardNumber);
	AtfValidator::validateInt(_descr, "boardNumber", boardNumber, _checker, __FILE__, __LINE__);
	INT8 cardNumber; _jparser.validateByNameThrow("cardNumber", cardNumber);
	AtfValidator::validateInt(_descr, "cardNumber", cardNumber, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::PubBoardCardPosition::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 boardNumber; _parser.parseINT8(boardNumber);
	AtfValidator::validateInt(_descr, "boardNumber", boardNumber, _checker, __FILE__, __LINE__);
	INT8 cardNumber; _parser.parseINT8(cardNumber);
	AtfValidator::validateInt(_descr, "cardNumber", cardNumber, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_PlayerCardShown
//=================================================================

TableClient::P_PlayerCardShown::P_PlayerCardShown()
{
	clear();
}

void TableClient::P_PlayerCardShown::clear()
{
	suit = '0';
	rank = 0;
	shown = 0;
}

bool TableClient::P_PlayerCardShown::equals(const P_PlayerCardShown& _o) const
{
	return suit == _o.suit &&
		rank == _o.rank &&
		shown == _o.shown;
}

const char *TableClient::P_PlayerCardShown::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("suit=");
	_buf.append(suit);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append(',');
	_buf.append("shown=");
	_buf.appendUint(shown);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::P_PlayerCardShown::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("suit", suit, _buf);
	Atf::XmlElement::encodeAsXmlElement("rank", rank, _buf);
	Atf::XmlElement::encodeAsXmlElement("shown", shown, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::P_PlayerCardShown::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("suit"))
		{
			suit = *_value.ptr();
		}
		else if (_element.equals("rank"))
		{
			rank = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("shown"))
		{
			shown = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::P_PlayerCardShown::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(suit);
	_msg.composeBYTE(rank);
	_msg.composeBYTE(shown);
}

void TableClient::P_PlayerCardShown::parseMsg(CommMsgParser& _parser)
{
	{ INT8 _n; _parser.parseINT8(_n); suit = _n; }
	_parser.parseBYTE(rank);
	_parser.parseBYTE(shown);
}

const char *TableClient::P_PlayerCardShown::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("suit", suit);
	_jsonstr.compose("rank", rank);
	_jsonstr.compose("shown", shown);
	return _buf.c_str();
}

void TableClient::P_PlayerCardShown::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("suit", suit);
	_jparser.parseByNameThrow("rank", rank);
	_jparser.parseByNameThrow("shown", shown);
}

/* static */ void TableClient::P_PlayerCardShown::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	char suit; _jparser.validateByNameThrow("suit", suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _jparser.validateByNameThrow("rank", rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	BYTE shown; _jparser.validateByNameThrow("shown", shown);
	AtfValidator::validateInt(_descr, "shown", shown, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::P_PlayerCardShown::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	char suit; { INT8 _n; _parser.parseINT8(_n); suit = _n; }
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _parser.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	BYTE shown; _parser.parseBYTE(shown);
	AtfValidator::validateInt(_descr, "shown", shown, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_PlayerBetOption
//=================================================================

TableClient::P_PlayerBetOption::P_PlayerBetOption()
{
	clear();
}

void TableClient::P_PlayerBetOption::clear()
{
	act = '0';
	amount = 0;
}

bool TableClient::P_PlayerBetOption::equals(const P_PlayerBetOption& _o) const
{
	return act == _o.act &&
		amount == _o.amount;
}

const char *TableClient::P_PlayerBetOption::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("act=");
	_buf.append(act);
	_buf.append(',');
	_buf.append("v=");
	_buf.appendUint(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::P_PlayerBetOption::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("act", act, _buf);
	Atf::XmlElement::encodeAsXmlElement("v", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::P_PlayerBetOption::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("act"))
		{
			act = *_value.ptr();
		}
		else if (_element.equals("v") || _element.equals("amount"))
		{
			amount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::P_PlayerBetOption::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(act);
	_msg.composeUINT32(amount);
}

void TableClient::P_PlayerBetOption::parseMsg(CommMsgParser& _parser)
{
	{ INT8 _n; _parser.parseINT8(_n); act = _n; }
	_parser.parseUINT32(amount);
}

const char *TableClient::P_PlayerBetOption::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("act", act);
	_jsonstr.compose("v", amount);
	return _buf.c_str();
}

void TableClient::P_PlayerBetOption::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("act", act);
	if(!_jparser.parseByName("v", amount)) _jparser.parseByNameThrow("amount", amount);
}

/* static */ void TableClient::P_PlayerBetOption::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	char act; _jparser.validateByNameThrow("act", act);
	AtfValidator::validateInt(_descr, "act", act, _checker, __FILE__, __LINE__);
	UINT32 amount; if(!_jparser.validateByName("v", amount)) _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::P_PlayerBetOption::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	char act; { INT8 _n; _parser.parseINT8(_n); act = _n; }
	AtfValidator::validateInt(_descr, "act", act, _checker, __FILE__, __LINE__);
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_PlayerRequestAction
//=================================================================

// @Override
void TableClient::P_PlayerRequestAction::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	if(amountMin == amountMax)
	{
		_msg.composeINT8(action);
		_msg.composeUINT32(amountMin);
	}
	else
	{
		_msg.composeINT8('*');
		_msg.composeINT8(action);
		_msg.composeUINT32(amountMin);
		_msg.composeUINT32(amountMax);
		_msg.composeUINT32(amountStep);
		_msg.composeUINT32(chipQuantum);
	}
}

// @Override
void TableClient::P_PlayerRequestAction::parseMsg(CommMsgParser& _parser)
{
	INT8 n;
	_parser.parseINT8(n);

	if (n == '*')
	{
		_parser.parseINT8(n);
		action = n;
		_parser.parseUINT32(amountMin);
		_parser.parseUINT32(amountMax);
		_parser.parseUINT32(amountStep);
		_parser.parseUINT32(chipQuantum);
	}
	else
	{
		action = n;
		_parser.parseUINT32(amountMin);
		amountMax = amountMin;
	}
}

TableClient::P_PlayerRequestAction::P_PlayerRequestAction()
{
	clear();
}

void TableClient::P_PlayerRequestAction::clear()
{
	action = '0';
	amountMin = 0;
	amountMax = 0;
	amountStep = 100;
	chipQuantum = 1;
}

bool TableClient::P_PlayerRequestAction::equals(const P_PlayerRequestAction& _o) const
{
	return action == _o.action &&
		amountMin == _o.amountMin &&
		amountMax == _o.amountMax &&
		amountStep == _o.amountStep &&
		chipQuantum == _o.chipQuantum;
}

const char *TableClient::P_PlayerRequestAction::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("a=");
	_buf.append(action);
	_buf.append(',');
	_buf.append("vMn=");
	_buf.appendUint(amountMin);
	_buf.append(',');
	_buf.append("vMx=");
	_buf.appendUint(amountMax);
	_buf.append(',');
	_buf.append("vStep=");
	_buf.appendUint(amountStep);
	_buf.append(',');
	_buf.append("chipQuantum=");
	_buf.appendUint(chipQuantum);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::P_PlayerRequestAction::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("a", action, _buf);
	Atf::XmlElement::encodeAsXmlElement("vMn", amountMin, _buf);
	Atf::XmlElement::encodeAsXmlElement("vMx", amountMax, _buf);
	Atf::XmlElement::encodeAsXmlElement("vStep", amountStep, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipQuantum", chipQuantum, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::P_PlayerRequestAction::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("a") || _element.equals("action"))
		{
			action = *_value.ptr();
		}
		else if (_element.equals("vMn") || _element.equals("amountMin"))
		{
			amountMin = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vMx") || _element.equals("amountMax"))
		{
			amountMax = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vStep") || _element.equals("amountStep"))
		{
			amountStep = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chipQuantum"))
		{
			chipQuantum = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

const char *TableClient::P_PlayerRequestAction::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("a", action);
	_jsonstr.compose("vMn", amountMin);
	_jsonstr.compose("vMx", amountMax);
	_jsonstr.compose("vStep", amountStep);
	_jsonstr.compose("chipQuantum", chipQuantum);
	return _buf.c_str();
}

void TableClient::P_PlayerRequestAction::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("a", action)) _jparser.parseByNameThrow("action", action);
	if(!_jparser.parseByName("vMn", amountMin)) _jparser.parseByNameThrow("amountMin", amountMin);
	if(!_jparser.parseByName("vMx", amountMax)) _jparser.parseByNameThrow("amountMax", amountMax);
	if(!_jparser.parseByName("vStep", amountStep)) _jparser.parseByNameThrow("amountStep", amountStep);
	_jparser.parseByNameThrow("chipQuantum", chipQuantum);
}

/* static */ void TableClient::P_PlayerRequestAction::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	char action; if(!_jparser.validateByName("a", action)) _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT32 amountMin; if(!_jparser.validateByName("vMn", amountMin)) _jparser.validateByNameThrow("amountMin", amountMin);
	AtfValidator::validateInt(_descr, "amountMin", amountMin, _checker, __FILE__, __LINE__);
	UINT32 amountMax; if(!_jparser.validateByName("vMx", amountMax)) _jparser.validateByNameThrow("amountMax", amountMax);
	AtfValidator::validateInt(_descr, "amountMax", amountMax, _checker, __FILE__, __LINE__);
	UINT32 amountStep; if(!_jparser.validateByName("vStep", amountStep)) _jparser.validateByNameThrow("amountStep", amountStep);
	AtfValidator::validateInt(_descr, "amountStep", amountStep, _checker, __FILE__, __LINE__);
	UINT32 chipQuantum; _jparser.validateByNameThrow("chipQuantum", chipQuantum);
	AtfValidator::validateInt(_descr, "chipQuantum", chipQuantum, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::P_PlayerRequestAction::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	char action; { INT8 _n; _parser.parseINT8(_n); action = _n; }
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT32 amountMin; _parser.parseUINT32(amountMin);
	AtfValidator::validateInt(_descr, "amountMin", amountMin, _checker, __FILE__, __LINE__);
	UINT32 amountMax; _parser.parseUINT32(amountMax);
	AtfValidator::validateInt(_descr, "amountMax", amountMax, _checker, __FILE__, __LINE__);
	UINT32 amountStep; _parser.parseUINT32(amountStep);
	AtfValidator::validateInt(_descr, "amountStep", amountStep, _checker, __FILE__, __LINE__);
	UINT32 chipQuantum; _parser.parseUINT32(chipQuantum);
	AtfValidator::validateInt(_descr, "chipQuantum", chipQuantum, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_SuscrPlayerCards
//=================================================================

TableClient::P_SuscrPlayerCards::P_SuscrPlayerCards()
{
	clear();
}

void TableClient::P_SuscrPlayerCards::clear()
{
	seat = -1;
	numOfCards = 0;
}

bool TableClient::P_SuscrPlayerCards::equals(const P_SuscrPlayerCards& _o) const
{
	return seat == _o.seat &&
		numOfCards == _o.numOfCards;
}

const char *TableClient::P_SuscrPlayerCards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("numOfCards=");
	_buf.appendUint(numOfCards);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::P_SuscrPlayerCards::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("numOfCards", numOfCards, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::P_SuscrPlayerCards::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("s") || _element.equals("seat"))
		{
			seat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numOfCards"))
		{
			numOfCards = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::P_SuscrPlayerCards::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(seat);
	_msg.composeBYTE(numOfCards);
}

void TableClient::P_SuscrPlayerCards::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(seat);
	_parser.parseBYTE(numOfCards);
}

const char *TableClient::P_SuscrPlayerCards::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("numOfCards", numOfCards);
	return _buf.c_str();
}

void TableClient::P_SuscrPlayerCards::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("numOfCards", numOfCards);
}

/* static */ void TableClient::P_SuscrPlayerCards::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE numOfCards; _jparser.validateByNameThrow("numOfCards", numOfCards);
	AtfValidator::validateInt(_descr, "numOfCards", numOfCards, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::P_SuscrPlayerCards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE numOfCards; _parser.parseBYTE(numOfCards);
	AtfValidator::validateInt(_descr, "numOfCards", numOfCards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_PotInfo
//=================================================================

TableClient::P_PotInfo::P_PotInfo()
{
	clear();
}

void TableClient::P_PotInfo::clear()
{
	seat = -1;
	amount = 0;
}

bool TableClient::P_PotInfo::equals(const P_PotInfo& _o) const
{
	return seat == _o.seat &&
		amount == _o.amount;
}

const char *TableClient::P_PotInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("v=");
	_buf.appendUint(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::P_PotInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("v", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::P_PotInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("s") || _element.equals("seat"))
		{
			seat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("v") || _element.equals("amount"))
		{
			amount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::P_PotInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(seat);
	_msg.composeUINT32(amount);
}

void TableClient::P_PotInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(seat);
	_parser.parseUINT32(amount);
}

const char *TableClient::P_PotInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("v", amount);
	return _buf.c_str();
}

void TableClient::P_PotInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	if(!_jparser.parseByName("v", amount)) _jparser.parseByNameThrow("amount", amount);
}

/* static */ void TableClient::P_PotInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	UINT32 amount; if(!_jparser.validateByName("v", amount)) _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::P_PotInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_BOUNTY_GREETINGS
//=================================================================

TableClient::P_BOUNTY_GREETINGS::P_BOUNTY_GREETINGS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::P_BOUNTY_GREETINGS::P_BOUNTY_GREETINGS(P_BOUNTY_GREETINGS&& _o)
	: amount(std::move(_o.amount))
	, bountyLoser(std::move(_o.bountyLoser))
{
}

TableClient::P_BOUNTY_GREETINGS& TableClient::P_BOUNTY_GREETINGS::operator=(P_BOUNTY_GREETINGS&& _o)
{
	if(this != &_o)
	{
		amount = std::move(_o.amount);
		bountyLoser = std::move(_o.bountyLoser);
	}
	return *this;
}

#endif

void TableClient::P_BOUNTY_GREETINGS::clear()
{
	amount = 0;
	bountyLoser.clear();
}

bool TableClient::P_BOUNTY_GREETINGS::equals(const P_BOUNTY_GREETINGS& _o) const
{
	return amount == _o.amount &&
		Atf::atfPStringEquals(bountyLoser, _o.bountyLoser);
}

const char *TableClient::P_BOUNTY_GREETINGS::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("v=");
	_buf.appendUint(amount);
	_buf.append(',');
	_buf.append("bountyLoser=");
	_buf.append(bountyLoser);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::P_BOUNTY_GREETINGS::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("v", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("bountyLoser", bountyLoser, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::P_BOUNTY_GREETINGS::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("v") || _element.equals("amount"))
		{
			amount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bountyLoser"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bountyLoser)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::P_BOUNTY_GREETINGS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(amount);
	_msg.composeString(bountyLoser);
}

void TableClient::P_BOUNTY_GREETINGS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(amount);
	_parser.parseStringP(bountyLoser);
}

const char *TableClient::P_BOUNTY_GREETINGS::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("v", amount);
	_jsonstr.compose("bountyLoser", bountyLoser);
	return _buf.c_str();
}

void TableClient::P_BOUNTY_GREETINGS::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("v", amount)) _jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("bountyLoser", bountyLoser);
}

/* static */ void TableClient::P_BOUNTY_GREETINGS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 amount; if(!_jparser.validateByName("v", amount)) _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	PString bountyLoser; _jparser.validateByNameThrow("bountyLoser", bountyLoser);
	AtfValidator::validateInt(_descr, "bountyLoser", bountyLoser.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::P_BOUNTY_GREETINGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bountyLoser"); size_t szBountyLoser = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bountyLoser", szBountyLoser, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardWithPosition
//=================================================================

TableClient::CardWithPosition::CardWithPosition()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::CardWithPosition::CardWithPosition(CardWithPosition&& _o)
	: pos(std::move(_o.pos))
	, card(std::move(_o.card))
{
}

TableClient::CardWithPosition& TableClient::CardWithPosition::operator=(CardWithPosition&& _o)
{
	if(this != &_o)
	{
		pos = std::move(_o.pos);
		card = std::move(_o.card);
	}
	return *this;
}

#endif

void TableClient::CardWithPosition::clear()
{
	pos = 0;
	card.clear();
}

bool TableClient::CardWithPosition::equals(const CardWithPosition& _o) const
{
	return pos == _o.pos &&
		card.equals(_o.card);
}

const char *TableClient::CardWithPosition::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pos=");
	_buf.appendUint(pos);
	_buf.append(',');
	_buf.append("card=");
	card.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::CardWithPosition::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pos", pos, _buf);
	card.toXmlString("card", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::CardWithPosition::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pos"))
		{
			pos = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("card"))
		{
			if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, card)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::CardWithPosition::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(pos);
	card.composeMsg(_msg, _ignoreJSON);
}

void TableClient::CardWithPosition::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(pos);
	card.parseMsg(_parser);
}

const char *TableClient::CardWithPosition::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pos", pos);
	_jsonstr.compose("card", card);
	return _buf.c_str();
}

void TableClient::CardWithPosition::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pos", pos);
	_jparser.parseByNameThrow("card", card);
}

/* static */ void TableClient::CardWithPosition::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE pos; _jparser.validateByNameThrow("pos", pos);
	AtfValidator::validateInt(_descr, "pos", pos, _checker, __FILE__, __LINE__);
	TableCommon::P_Card card; _jparser.validateByNameThrow("card", card);
}

/*static*/ void TableClient::CardWithPosition::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE pos; _parser.parseBYTE(pos);
	AtfValidator::validateInt(_descr, "pos", pos, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableCommon::P_Card::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("card"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    CardInfo
//=================================================================

TableClient::CardInfo::CardInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::CardInfo::CardInfo(CardInfo&& _o)
	: playerOrboard(std::move(_o.playerOrboard))
	, pos(std::move(_o.pos))
	, card(std::move(_o.card))
{
}

TableClient::CardInfo& TableClient::CardInfo::operator=(CardInfo&& _o)
{
	if(this != &_o)
	{
		playerOrboard = std::move(_o.playerOrboard);
		pos = std::move(_o.pos);
		card = std::move(_o.card);
	}
	return *this;
}

#endif

void TableClient::CardInfo::clear()
{
	playerOrboard = 0;
	pos = 0;
	card.clear();
}

bool TableClient::CardInfo::equals(const CardInfo& _o) const
{
	return playerOrboard == _o.playerOrboard &&
		pos == _o.pos &&
		card.equals(_o.card);
}

const char *TableClient::CardInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("playerOrboard=");
	_buf.appendInt(playerOrboard);
	_buf.append(',');
	_buf.append("pos=");
	_buf.appendUint(pos);
	_buf.append(',');
	_buf.append("card=");
	card.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::CardInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("playerOrboard", playerOrboard, _buf);
	Atf::XmlElement::encodeAsXmlElement("pos", pos, _buf);
	card.toXmlString("card", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::CardInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("playerOrboard"))
		{
			playerOrboard = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("pos"))
		{
			pos = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("card"))
		{
			if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, card)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::CardInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(playerOrboard);
	_msg.composeBYTE(pos);
	card.composeMsg(_msg, _ignoreJSON);
}

void TableClient::CardInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(playerOrboard);
	_parser.parseBYTE(pos);
	card.parseMsg(_parser);
}

const char *TableClient::CardInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playerOrboard", playerOrboard);
	_jsonstr.compose("pos", pos);
	_jsonstr.compose("card", card);
	return _buf.c_str();
}

void TableClient::CardInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playerOrboard", playerOrboard);
	_jparser.parseByNameThrow("pos", pos);
	_jparser.parseByNameThrow("card", card);
}

/* static */ void TableClient::CardInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 playerOrboard; _jparser.validateByNameThrow("playerOrboard", playerOrboard);
	AtfValidator::validateInt(_descr, "playerOrboard", playerOrboard, _checker, __FILE__, __LINE__);
	BYTE pos; _jparser.validateByNameThrow("pos", pos);
	AtfValidator::validateInt(_descr, "pos", pos, _checker, __FILE__, __LINE__);
	TableCommon::P_Card card; _jparser.validateByNameThrow("card", card);
}

/*static*/ void TableClient::CardInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 playerOrboard; _parser.parseINT8(playerOrboard);
	AtfValidator::validateInt(_descr, "playerOrboard", playerOrboard, _checker, __FILE__, __LINE__);
	BYTE pos; _parser.parseBYTE(pos);
	AtfValidator::validateInt(_descr, "pos", pos, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableCommon::P_Card::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("card"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    CardInfoBody
//=================================================================

TableClient::CardInfoBody::CardInfoBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::CardInfoBody::CardInfoBody(CardInfoBody&& _o)
	: c(std::move(_o.c))
{
}

TableClient::CardInfoBody& TableClient::CardInfoBody::operator=(CardInfoBody&& _o)
{
	if(this != &_o)
	{
		c = std::move(_o.c);
	}
	return *this;
}

#endif

void TableClient::CardInfoBody::clear()
{
	c.clear();
}

bool TableClient::CardInfoBody::equals(const CardInfoBody& _o) const
{
	return c.equals(_o.c);
}

const char *TableClient::CardInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("c=");
	c.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::CardInfoBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	c.toXmlString("c", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::CardInfoBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("c"))
		{
			if(!Atf::AtfTempl< CardInfo >::FromXmlString(_value, c)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::CardInfoBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CardInfoBody())) // not empty
	{
		c.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::CardInfoBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	c.parseMsg(_parser0);
}

const char *TableClient::CardInfoBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("c", c);
	return _buf.c_str();
}

void TableClient::CardInfoBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("c", c);
}

/* static */ void TableClient::CardInfoBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CardInfo c; _jparser.validateByNameThrow("c", c);
}

/*static*/ void TableClient::CardInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	CardInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("c"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TotalBetInfo
//=================================================================

TableClient::TotalBetInfo::TotalBetInfo()
{
	clear();
}

void TableClient::TotalBetInfo::clear()
{
	sumOfBets = 0;
	netWon = 0;
}

bool TableClient::TotalBetInfo::equals(const TotalBetInfo& _o) const
{
	return sumOfBets == _o.sumOfBets &&
		netWon == _o.netWon;
}

const char *TableClient::TotalBetInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sumOfBets=");
	_buf.appendInt64(sumOfBets);
	_buf.append(',');
	_buf.append("netWon=");
	_buf.appendInt64(netWon);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::TotalBetInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("sumOfBets", sumOfBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("netWon", netWon, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::TotalBetInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sumOfBets"))
		{
			sumOfBets = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("netWon"))
		{
			netWon = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::TotalBetInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TotalBetInfo())) // not empty
	{
		_body.composeINT64(sumOfBets);
		_body.composeINT64(netWon);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::TotalBetInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(sumOfBets);
	_parser0.parseINT64(netWon);
}

const char *TableClient::TotalBetInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sumOfBets", sumOfBets);
	_jsonstr.compose("netWon", netWon);
	return _buf.c_str();
}

void TableClient::TotalBetInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("sumOfBets", sumOfBets);
	_jparser.parseByNameThrow("netWon", netWon);
}

/* static */ void TableClient::TotalBetInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	INT64 sumOfBets; _jparser.validateByNameThrow("sumOfBets", sumOfBets);
	AtfValidator::validateInt(_descr, "sumOfBets", sumOfBets, _checker, __FILE__, __LINE__);
	INT64 netWon; _jparser.validateByNameThrow("netWon", netWon);
	AtfValidator::validateInt(_descr, "netWon", netWon, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::TotalBetInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	INT64 sumOfBets; _parser0.parseINT64(sumOfBets);
	AtfValidator::validateInt(_descr, "sumOfBets", sumOfBets, _checker, __FILE__, __LINE__);
	INT64 netWon; _parser0.parseINT64(netWon);
	AtfValidator::validateInt(_descr, "netWon", netWon, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ClientMsg_TxtEx_NSF
//=================================================================

TableClient::player::ClientMsg_TxtEx_NSF::ClientMsg_TxtEx_NSF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::ClientMsg_TxtEx_NSF::ClientMsg_TxtEx_NSF(ClientMsg_TxtEx_NSF&& _o)
	: msgId(std::move(_o.msgId))
	, minLimit(std::move(_o.minLimit))
	, enoughMoneyInOtherCurrencies(std::move(_o.enoughMoneyInOtherCurrencies))
	, clientServiceFlag(std::move(_o.clientServiceFlag))
	, chips(std::move(_o.chips))
	, currency(std::move(_o.currency))
	, useAutoConvertBuyin(std::move(_o.useAutoConvertBuyin))
	, clientCurrencyContextShort(std::move(_o.clientCurrencyContextShort))
	, rebuyOrAddonData(std::move(_o.rebuyOrAddonData))
{
}

TableClient::player::ClientMsg_TxtEx_NSF& TableClient::player::ClientMsg_TxtEx_NSF::operator=(ClientMsg_TxtEx_NSF&& _o)
{
	if(this != &_o)
	{
		msgId = std::move(_o.msgId);
		minLimit = std::move(_o.minLimit);
		enoughMoneyInOtherCurrencies = std::move(_o.enoughMoneyInOtherCurrencies);
		clientServiceFlag = std::move(_o.clientServiceFlag);
		chips = std::move(_o.chips);
		currency = std::move(_o.currency);
		useAutoConvertBuyin = std::move(_o.useAutoConvertBuyin);
		clientCurrencyContextShort = std::move(_o.clientCurrencyContextShort);
		rebuyOrAddonData = std::move(_o.rebuyOrAddonData);
	}
	return *this;
}

#endif

void TableClient::player::ClientMsg_TxtEx_NSF::clear()
{
	msgId = ClientMsg_NSF;
	minLimit = 0;
	enoughMoneyInOtherCurrencies = false;
	clientServiceFlag = 0;
	chips = 0;
	currency.clear();
	useAutoConvertBuyin = false;
	clientCurrencyContextShort.clear();
	rebuyOrAddonData.clear();
}

bool TableClient::player::ClientMsg_TxtEx_NSF::equals(const ClientMsg_TxtEx_NSF& _o) const
{
	return msgId == _o.msgId &&
		minLimit == _o.minLimit &&
		enoughMoneyInOtherCurrencies == _o.enoughMoneyInOtherCurrencies &&
		clientServiceFlag == _o.clientServiceFlag &&
		chips == _o.chips &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		useAutoConvertBuyin == _o.useAutoConvertBuyin &&
		clientCurrencyContextShort.equals(_o.clientCurrencyContextShort) &&
		rebuyOrAddonData.equals(_o.rebuyOrAddonData);
}

const char *TableClient::player::ClientMsg_TxtEx_NSF::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("msgId=");
	_buf.appendUint(msgId);
	_buf.append(',');
	_buf.append("minLimit=");
	_buf.appendInt(minLimit);
	_buf.append(',');
	_buf.append("enoughMoneyInOtherCurrencies=");
	_buf.appendUint(enoughMoneyInOtherCurrencies);
	_buf.append(',');
	_buf.append("clientServiceFlag=");
	_buf.appendUint(clientServiceFlag);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("useAutoConvertBuyin=");
	_buf.appendUint(useAutoConvertBuyin);
	_buf.append(',');
	_buf.append("clientCurrencyContextShort=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientCurrencyContextShort, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("rebuyOrAddonData=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(rebuyOrAddonData, _buf); _buf.append('}');
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::ClientMsg_TxtEx_NSF::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("msgId", msgId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minLimit", minLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientServiceFlag", clientServiceFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("useAutoConvertBuyin", useAutoConvertBuyin, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientCurrencyContextShort", clientCurrencyContextShort, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyOrAddonData", rebuyOrAddonData, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::ClientMsg_TxtEx_NSF::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("msgId"))
		{
			msgId = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minLimit"))
		{
			minLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("enoughMoneyInOtherCurrencies"))
		{
			enoughMoneyInOtherCurrencies = (*_value.ptr() == '1');
		}
		else if (_element.equals("clientServiceFlag"))
		{
			clientServiceFlag = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chips"))
		{
			chips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("useAutoConvertBuyin"))
		{
			useAutoConvertBuyin = (*_value.ptr() == '1');
		}
		else if (_element.equals("clientCurrencyContextShort"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientCurrencyContextShort)) return false;
		}
		else if (_element.equals("rebuyOrAddonData"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, rebuyOrAddonData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::ClientMsg_TxtEx_NSF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(msgId);
	_msg.composeINT32(minLimit);
	_msg.composeBOOL(enoughMoneyInOtherCurrencies);
	_msg.composeBYTE(clientServiceFlag);
	_msg.composeINT32(chips);
	_msg.composeString(currency);
	_msg.composeBOOL(useAutoConvertBuyin);
	_msg.composeMsgBody(clientCurrencyContextShort);
	_msg.composeMsgBody(rebuyOrAddonData);
}

void TableClient::player::ClientMsg_TxtEx_NSF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(msgId);
	_parser.parseINT32(minLimit);
	_parser.parseBOOL(enoughMoneyInOtherCurrencies);
	_parser.parseBYTE(clientServiceFlag);
	_parser.parseINT32(chips);
	_parser.parseStringP(currency);
	_parser.parseBOOL(useAutoConvertBuyin);
	_parser.parseMsgBody(clientCurrencyContextShort);
	_parser.parseMsgBody(rebuyOrAddonData);
}

const char *TableClient::player::ClientMsg_TxtEx_NSF::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("msgId", msgId);
	_jsonstr.compose("minLimit", minLimit);
	_jsonstr.compose("enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies);
	_jsonstr.compose("clientServiceFlag", clientServiceFlag);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("useAutoConvertBuyin", useAutoConvertBuyin);
	_jsonstr.compose("clientCurrencyContextShort", clientCurrencyContextShort);
	_jsonstr.compose("rebuyOrAddonData", rebuyOrAddonData);
	return _buf.c_str();
}

void TableClient::player::ClientMsg_TxtEx_NSF::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("msgId", msgId);
	_jparser.parseByNameThrow("minLimit", minLimit);
	_jparser.parseByNameThrow("enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies);
	_jparser.parseByNameThrow("clientServiceFlag", clientServiceFlag);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("useAutoConvertBuyin", useAutoConvertBuyin);
	_jparser.parseByNameThrow("clientCurrencyContextShort", clientCurrencyContextShort);
	_jparser.parseByNameThrow("rebuyOrAddonData", rebuyOrAddonData);
}

/* static */ void TableClient::player::ClientMsg_TxtEx_NSF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 msgId; _jparser.validateByNameThrow("msgId", msgId);
	AtfValidator::validateInt(_descr, "msgId", msgId, _checker, __FILE__, __LINE__);
	INT32 minLimit; _jparser.validateByNameThrow("minLimit", minLimit);
	AtfValidator::validateInt(_descr, "minLimit", minLimit, _checker, __FILE__, __LINE__);
	bool enoughMoneyInOtherCurrencies; _jparser.validateByNameThrow("enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies);
	AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; _jparser.validateByNameThrow("clientServiceFlag", clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	bool useAutoConvertBuyin; _jparser.validateByNameThrow("useAutoConvertBuyin", useAutoConvertBuyin);
	AtfValidator::validateInt(_descr, "useAutoConvertBuyin", useAutoConvertBuyin, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientCurrencyContextShort; _jparser.validateByNameThrow("clientCurrencyContextShort", clientCurrencyContextShort);
	AtfValidator::validateInt(_descr, "clientCurrencyContextShort", clientCurrencyContextShort._size(), _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody rebuyOrAddonData; _jparser.validateByNameThrow("rebuyOrAddonData", rebuyOrAddonData);
	AtfValidator::validateInt(_descr, "rebuyOrAddonData", rebuyOrAddonData._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::ClientMsg_TxtEx_NSF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT16 msgId; _parser.parseUINT16(msgId);
	AtfValidator::validateInt(_descr, "msgId", msgId, _checker, __FILE__, __LINE__);
	INT32 minLimit; _parser.parseINT32(minLimit);
	AtfValidator::validateInt(_descr, "minLimit", minLimit, _checker, __FILE__, __LINE__);
	bool enoughMoneyInOtherCurrencies; _parser.parseBOOL(enoughMoneyInOtherCurrencies);
	AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	INT32 chips; _parser.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	bool useAutoConvertBuyin; _parser.parseBOOL(useAutoConvertBuyin);
	AtfValidator::validateInt(_descr, "useAutoConvertBuyin", useAutoConvertBuyin, _checker, __FILE__, __LINE__);
	size_t szClientCurrencyContextShort; _parser.skipMsgBody(szClientCurrencyContextShort);  /*clientCurrencyContextShort*/
	AtfValidator::validateInt(_descr, "clientCurrencyContextShort", szClientCurrencyContextShort, _checker, __FILE__, __LINE__);
	size_t szRebuyOrAddonData; _parser.skipMsgBody(szRebuyOrAddonData);  /*rebuyOrAddonData*/
	AtfValidator::validateInt(_descr, "rebuyOrAddonData", szRebuyOrAddonData, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_TABLE_LOGIN
//=================================================================

TableClient::player::Protocol_MSG_TABLE_LOGIN::Protocol_MSG_TABLE_LOGIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_LOGIN::Protocol_MSG_TABLE_LOGIN(Protocol_MSG_TABLE_LOGIN&& _o)
	: user(std::move(_o.user))
	, clientSiteId(std::move(_o.clientSiteId))
	, notShowWhenAllIn(std::move(_o.notShowWhenAllIn))
	, sitOutNextHand(std::move(_o.sitOutNextHand))
	, useAllInitStacks(std::move(_o.useAllInitStacks))
{
}

TableClient::player::Protocol_MSG_TABLE_LOGIN& TableClient::player::Protocol_MSG_TABLE_LOGIN::operator=(Protocol_MSG_TABLE_LOGIN&& _o)
{
	if(this != &_o)
	{
		user = std::move(_o.user);
		clientSiteId = std::move(_o.clientSiteId);
		notShowWhenAllIn = std::move(_o.notShowWhenAllIn);
		sitOutNextHand = std::move(_o.sitOutNextHand);
		useAllInitStacks = std::move(_o.useAllInitStacks);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_LOGIN::clear()
{
	user.clear();
	clientSiteId = 0;
	notShowWhenAllIn = false;
	sitOutNextHand = false;
	useAllInitStacks = false;
}

bool TableClient::player::Protocol_MSG_TABLE_LOGIN::equals(const Protocol_MSG_TABLE_LOGIN& _o) const
{
	return Atf::atfPStringEquals(user, _o.user) &&
		clientSiteId == _o.clientSiteId &&
		notShowWhenAllIn == _o.notShowWhenAllIn &&
		sitOutNextHand == _o.sitOutNextHand &&
		useAllInitStacks == _o.useAllInitStacks;
}

bool TableClient::player::Protocol_MSG_TABLE_LOGIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGIN*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGIN).append(")");
	_buf.append(',');
	_buf.append("u=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("site=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("nshown=");
	_buf.appendUint(notShowWhenAllIn);
	_buf.append(',');
	_buf.append("sitout=");
	_buf.appendUint(sitOutNextHand);
	_buf.append(',');
	_buf.append("allstacks=");
	_buf.appendUint(useAllInitStacks);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("u", user, _buf);
	Atf::XmlElement::encodeAsXmlElement("site", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("nshown", notShowWhenAllIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("sitout", sitOutNextHand, _buf);
	Atf::XmlElement::encodeAsXmlElement("allstacks", useAllInitStacks, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_LOGIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("u") || _element.equals("user"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, user)) return false;
			}
			else if (_element.equals("site") || _element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nshown") || _element.equals("notShowWhenAllIn"))
			{
				notShowWhenAllIn = (*_value.ptr() == '1');
			}
			else if (_element.equals("sitout") || _element.equals("sitOutNextHand"))
			{
				sitOutNextHand = (*_value.ptr() == '1');
			}
			else if (_element.equals("allstacks") || _element.equals("useAllInitStacks"))
			{
				useAllInitStacks = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_LOGIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(user);
	_msg.composeUINT32(clientSiteId);
	_msg.composeBOOL(notShowWhenAllIn);
	_msg.composeBOOL(sitOutNextHand);
	_msg.composeBOOL(useAllInitStacks);
}

void TableClient::player::Protocol_MSG_TABLE_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseUINT32(clientSiteId);
	_parser.parseBOOL(notShowWhenAllIn);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(sitOutNextHand);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useAllInitStacks);
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("u", user);
	_jsonstr.compose("site", clientSiteId);
	_jsonstr.compose("nshown", notShowWhenAllIn);
	_jsonstr.compose("sitout", sitOutNextHand);
	_jsonstr.compose("allstacks", useAllInitStacks);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_LOGIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("u", user)) _jparser.parseByNameThrow("user", user);
	if(!_jparser.parseByName("site", clientSiteId)) _jparser.parseByNameThrow("clientSiteId", clientSiteId);
	if(!_jparser.parseByName("nshown", notShowWhenAllIn)) _jparser.parseByNameThrow("notShowWhenAllIn", notShowWhenAllIn);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("sitout", sitOutNextHand)) _jparser.parseByNameThrow("sitOutNextHand", sitOutNextHand);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("allstacks", useAllInitStacks)) _jparser.parseByNameThrow("useAllInitStacks", useAllInitStacks);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_LOGIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString user; if(!_jparser.validateByName("u", user)) _jparser.validateByNameThrow("user", user);
	AtfValidator::validateIntMax(_descr, "user", user.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; if(!_jparser.validateByName("site", clientSiteId)) _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateIntMax(_descr, "clientSiteId", clientSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	bool notShowWhenAllIn; if(!_jparser.validateByName("nshown", notShowWhenAllIn)) _jparser.validateByNameThrow("notShowWhenAllIn", notShowWhenAllIn);
	AtfValidator::validateInt(_descr, "notShowWhenAllIn", notShowWhenAllIn, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool sitOutNextHand; if(!_jparser.validateByName("sitout", sitOutNextHand)) _jparser.validateByNameThrow("sitOutNextHand", sitOutNextHand);
	AtfValidator::validateInt(_descr, "sitOutNextHand", sitOutNextHand, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool useAllInitStacks; if(!_jparser.validateByName("allstacks", useAllInitStacks)) _jparser.validateByNameThrow("useAllInitStacks", useAllInitStacks);
	AtfValidator::validateInt(_descr, "useAllInitStacks", useAllInitStacks, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "user", szUser, 20, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateIntMax(_descr, "clientSiteId", clientSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	bool notShowWhenAllIn; _parser.parseBOOL(notShowWhenAllIn);
	AtfValidator::validateInt(_descr, "notShowWhenAllIn", notShowWhenAllIn, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool sitOutNextHand; _parser.parseBOOL(sitOutNextHand);
	AtfValidator::validateInt(_descr, "sitOutNextHand", sitOutNextHand, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useAllInitStacks; _parser.parseBOOL(useAllInitStacks);
	AtfValidator::validateInt(_descr, "useAllInitStacks", useAllInitStacks, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_LOGIN_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::Protocol_MSG_TABLE_LOGIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::Protocol_MSG_TABLE_LOGIN_REPLY(Protocol_MSG_TABLE_LOGIN_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, seat(std::move(_o.seat))
	, sittingStatus(std::move(_o.sittingStatus))
	, clientIP(std::move(_o.clientIP))
	, waitingStatus(std::move(_o.waitingStatus))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, autoRebuyOptions(std::move(_o.autoRebuyOptions))
	, autoRebuyBigBets(std::move(_o.autoRebuyBigBets))
	, autoRebuyFallUnderBigBets(std::move(_o.autoRebuyFallUnderBigBets))
	, autoRebuyFallUnderPercents(std::move(_o.autoRebuyFallUnderPercents))
	, playerRITFavored(std::move(_o.playerRITFavored))
	, campingPreventionEnabled(std::move(_o.campingPreventionEnabled))
	, isTableDealingHands(std::move(_o.isTableDealingHands))
	, campingCountingDownSec(std::move(_o.campingCountingDownSec))
	, allinCashoutNotFavored(std::move(_o.allinCashoutNotFavored))
	, progressivePlusEntryId(std::move(_o.progressivePlusEntryId))
{
}

TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY& TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::operator=(Protocol_MSG_TABLE_LOGIN_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		seat = std::move(_o.seat);
		sittingStatus = std::move(_o.sittingStatus);
		clientIP = std::move(_o.clientIP);
		waitingStatus = std::move(_o.waitingStatus);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		autoRebuyOptions = std::move(_o.autoRebuyOptions);
		autoRebuyBigBets = std::move(_o.autoRebuyBigBets);
		autoRebuyFallUnderBigBets = std::move(_o.autoRebuyFallUnderBigBets);
		autoRebuyFallUnderPercents = std::move(_o.autoRebuyFallUnderPercents);
		playerRITFavored = std::move(_o.playerRITFavored);
		campingPreventionEnabled = std::move(_o.campingPreventionEnabled);
		isTableDealingHands = std::move(_o.isTableDealingHands);
		campingCountingDownSec = std::move(_o.campingCountingDownSec);
		allinCashoutNotFavored = std::move(_o.allinCashoutNotFavored);
		progressivePlusEntryId = std::move(_o.progressivePlusEntryId);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	seat = -1;
	sittingStatus = SittingOut;
	clientIP.clear();
	waitingStatus = 0;
	clientMsg_txtEx.clear();
	autoRebuyOptions = _autoRebuyDisabled;
	autoRebuyBigBets = 0;
	autoRebuyFallUnderBigBets = 0;
	autoRebuyFallUnderPercents = 0;
	playerRITFavored = false;
	campingPreventionEnabled = false;
	isTableDealingHands = false;
	campingCountingDownSec = 0;
	allinCashoutNotFavored = false;
	progressivePlusEntryId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::equals(const Protocol_MSG_TABLE_LOGIN_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		seat == _o.seat &&
		sittingStatus == _o.sittingStatus &&
		waitingStatus == _o.waitingStatus &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		autoRebuyOptions == _o.autoRebuyOptions &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		autoRebuyFallUnderBigBets == _o.autoRebuyFallUnderBigBets &&
		autoRebuyFallUnderPercents == _o.autoRebuyFallUnderPercents &&
		playerRITFavored == _o.playerRITFavored &&
		campingPreventionEnabled == _o.campingPreventionEnabled &&
		isTableDealingHands == _o.isTableDealingHands &&
		campingCountingDownSec == _o.campingCountingDownSec &&
		allinCashoutNotFavored == _o.allinCashoutNotFavored &&
		progressivePlusEntryId == _o.progressivePlusEntryId;
}

bool TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGIN_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("ss=");
	_buf.appendUint(sittingStatus);
	_buf.append(',');
	_buf.append("ip=");
	_buf.append(clientIP);
	_buf.append(',');
	_buf.append("ws=");
	_buf.appendUint(waitingStatus);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("ar=");
	_buf.appendInt(autoRebuyOptions);
	_buf.append(',');
	_buf.append("arBB=");
	_buf.appendUint(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("arFBB=");
	_buf.appendUint(autoRebuyFallUnderBigBets);
	_buf.append(',');
	_buf.append("arFPct=");
	_buf.appendUint(autoRebuyFallUnderPercents);
	_buf.append(',');
	_buf.append("rit=");
	_buf.appendUint(playerRITFavored);
	_buf.append(',');
	_buf.append("camping=");
	_buf.appendUint(campingPreventionEnabled);
	_buf.append(',');
	_buf.append("dealing=");
	_buf.appendUint(isTableDealingHands);
	_buf.append(',');
	_buf.append("campSecs=");
	_buf.appendUint(campingCountingDownSec);
	_buf.append(',');
	_buf.append("nco=");
	_buf.appendUint(allinCashoutNotFavored);
	_buf.append(',');
	_buf.append("pppEId=");
	_buf.appendUint64(progressivePlusEntryId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("ss", sittingStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("ip", clientIP, _buf);
	Atf::XmlElement::encodeAsXmlElement("ws", waitingStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("ar", autoRebuyOptions, _buf);
	Atf::XmlElement::encodeAsXmlElement("arBB", autoRebuyBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("arFBB", autoRebuyFallUnderBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("arFPct", autoRebuyFallUnderPercents, _buf);
	Atf::XmlElement::encodeAsXmlElement("rit", playerRITFavored, _buf);
	Atf::XmlElement::encodeAsXmlElement("camping", campingPreventionEnabled, _buf);
	Atf::XmlElement::encodeAsXmlElement("dealing", isTableDealingHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("campSecs", campingCountingDownSec, _buf);
	Atf::XmlElement::encodeAsXmlElement("nco", allinCashoutNotFavored, _buf);
	Atf::XmlElement::encodeAsXmlElement("pppEId", progressivePlusEntryId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ss") || _element.equals("sittingStatus"))
			{
				sittingStatus = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ip") || _element.equals("clientIP"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientIP)) return false;
			}
			else if (_element.equals("ws") || _element.equals("waitingStatus"))
			{
				waitingStatus = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("ar") || _element.equals("autoRebuyOptions"))
			{
				autoRebuyOptions = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("arBB") || _element.equals("autoRebuyBigBets"))
			{
				autoRebuyBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("arFBB") || _element.equals("autoRebuyFallUnderBigBets"))
			{
				autoRebuyFallUnderBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("arFPct") || _element.equals("autoRebuyFallUnderPercents"))
			{
				autoRebuyFallUnderPercents = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rit") || _element.equals("playerRITFavored"))
			{
				playerRITFavored = (*_value.ptr() == '1');
			}
			else if (_element.equals("camping") || _element.equals("campingPreventionEnabled"))
			{
				campingPreventionEnabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("dealing") || _element.equals("isTableDealingHands"))
			{
				isTableDealingHands = (*_value.ptr() == '1');
			}
			else if (_element.equals("campSecs") || _element.equals("campingCountingDownSec"))
			{
				campingCountingDownSec = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nco") || _element.equals("allinCashoutNotFavored"))
			{
				allinCashoutNotFavored = (*_value.ptr() == '1');
			}
			else if (_element.equals("pppEId") || _element.equals("progressivePlusEntryId"))
			{
				progressivePlusEntryId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	_msg.composeINT8(seat);
	_msg.composeBYTE(sittingStatus);
	_msg.composeString(clientIP);
	_msg.composeUINT32(waitingStatus);
	_msg.composeMsgBody(clientMsg_txtEx);
	_msg.composeINT8(autoRebuyOptions);
	_msg.composeUINT16(autoRebuyBigBets);
	_msg.composeUINT16(autoRebuyFallUnderBigBets);
	_msg.composeUINT16(autoRebuyFallUnderPercents);
	_msg.composeBOOL(playerRITFavored);
	_msg.composeBOOL(campingPreventionEnabled);
	_msg.composeBOOL(isTableDealingHands);
	_msg.composeUINT16(campingCountingDownSec);
	_msg.composeBOOL(allinCashoutNotFavored);
	_msg.composeUINT64(progressivePlusEntryId);
}

void TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	_parser.parseINT8(seat);
	_parser.parseBYTE(sittingStatus);
	_parser.parseStringP(clientIP);
	_parser.parseUINT32(waitingStatus);
	_parser.parseMsgBody(clientMsg_txtEx);
	_parser.parseINT8(autoRebuyOptions);
	_parser.parseUINT16(autoRebuyBigBets);
	_parser.parseUINT16(autoRebuyFallUnderBigBets);
	_parser.parseUINT16(autoRebuyFallUnderPercents);
	_parser.parseBOOL(playerRITFavored);
	_parser.parseBOOL(campingPreventionEnabled);
	_parser.parseBOOL(isTableDealingHands);
	_parser.parseUINT16(campingCountingDownSec);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(allinCashoutNotFavored);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(progressivePlusEntryId);
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("ss", sittingStatus);
	_jsonstr.compose("ip", clientIP);
	_jsonstr.compose("ws", waitingStatus);
	_jsonstr.compose("m", clientMsg_txtEx);
	_jsonstr.compose("ar", autoRebuyOptions);
	_jsonstr.compose("arBB", autoRebuyBigBets);
	_jsonstr.compose("arFBB", autoRebuyFallUnderBigBets);
	_jsonstr.compose("arFPct", autoRebuyFallUnderPercents);
	_jsonstr.compose("rit", playerRITFavored);
	_jsonstr.compose("camping", campingPreventionEnabled);
	_jsonstr.compose("dealing", isTableDealingHands);
	_jsonstr.compose("campSecs", campingCountingDownSec);
	_jsonstr.compose("nco", allinCashoutNotFavored);
	_jsonstr.compose("pppEId", progressivePlusEntryId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	if(!_jparser.parseByName("ss", sittingStatus)) _jparser.parseByNameThrow("sittingStatus", sittingStatus);
	if(!_jparser.parseByName("ip", clientIP)) _jparser.parseByNameThrow("clientIP", clientIP);
	if(!_jparser.parseByName("ws", waitingStatus)) _jparser.parseByNameThrow("waitingStatus", waitingStatus);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	if(!_jparser.parseByName("ar", autoRebuyOptions)) _jparser.parseByNameThrow("autoRebuyOptions", autoRebuyOptions);
	if(!_jparser.parseByName("arBB", autoRebuyBigBets)) _jparser.parseByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	if(!_jparser.parseByName("arFBB", autoRebuyFallUnderBigBets)) _jparser.parseByNameThrow("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	if(!_jparser.parseByName("arFPct", autoRebuyFallUnderPercents)) _jparser.parseByNameThrow("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	if(!_jparser.parseByName("rit", playerRITFavored)) _jparser.parseByNameThrow("playerRITFavored", playerRITFavored);
	if(!_jparser.parseByName("camping", campingPreventionEnabled)) _jparser.parseByNameThrow("campingPreventionEnabled", campingPreventionEnabled);
	if(!_jparser.parseByName("dealing", isTableDealingHands)) _jparser.parseByNameThrow("isTableDealingHands", isTableDealingHands);
	if(!_jparser.parseByName("campSecs", campingCountingDownSec)) _jparser.parseByNameThrow("campingCountingDownSec", campingCountingDownSec);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("nco", allinCashoutNotFavored)) _jparser.parseByNameThrow("allinCashoutNotFavored", allinCashoutNotFavored);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("pppEId", progressivePlusEntryId)) _jparser.parseByNameThrow("progressivePlusEntryId", progressivePlusEntryId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE sittingStatus; if(!_jparser.validateByName("ss", sittingStatus)) _jparser.validateByNameThrow("sittingStatus", sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	PString clientIP; if(!_jparser.validateByName("ip", clientIP)) _jparser.validateByNameThrow("clientIP", clientIP);
	AtfValidator::validateInt(_descr, "clientIP", clientIP.length(), _checker, __FILE__, __LINE__);
	UINT32 waitingStatus; if(!_jparser.validateByName("ws", waitingStatus)) _jparser.validateByNameThrow("waitingStatus", waitingStatus);
	AtfValidator::validateInt(_descr, "waitingStatus", waitingStatus, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	INT8 autoRebuyOptions; if(!_jparser.validateByName("ar", autoRebuyOptions)) _jparser.validateByNameThrow("autoRebuyOptions", autoRebuyOptions);
	AtfValidator::validateInt(_descr, "autoRebuyOptions", autoRebuyOptions, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; if(!_jparser.validateByName("arBB", autoRebuyBigBets)) _jparser.validateByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyBigBets", autoRebuyBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderBigBets; if(!_jparser.validateByName("arFBB", autoRebuyFallUnderBigBets)) _jparser.validateByNameThrow("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderPercents; if(!_jparser.validateByName("arFPct", autoRebuyFallUnderPercents)) _jparser.validateByNameThrow("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, _checker, __FILE__, __LINE__);
	bool playerRITFavored; if(!_jparser.validateByName("rit", playerRITFavored)) _jparser.validateByNameThrow("playerRITFavored", playerRITFavored);
	AtfValidator::validateInt(_descr, "playerRITFavored", playerRITFavored, _checker, __FILE__, __LINE__);
	bool campingPreventionEnabled; if(!_jparser.validateByName("camping", campingPreventionEnabled)) _jparser.validateByNameThrow("campingPreventionEnabled", campingPreventionEnabled);
	AtfValidator::validateInt(_descr, "campingPreventionEnabled", campingPreventionEnabled, _checker, __FILE__, __LINE__);
	bool isTableDealingHands; if(!_jparser.validateByName("dealing", isTableDealingHands)) _jparser.validateByNameThrow("isTableDealingHands", isTableDealingHands);
	AtfValidator::validateInt(_descr, "isTableDealingHands", isTableDealingHands, _checker, __FILE__, __LINE__);
	UINT16 campingCountingDownSec; if(!_jparser.validateByName("campSecs", campingCountingDownSec)) _jparser.validateByNameThrow("campingCountingDownSec", campingCountingDownSec);
	AtfValidator::validateInt(_descr, "campingCountingDownSec", campingCountingDownSec, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool allinCashoutNotFavored; if(!_jparser.validateByName("nco", allinCashoutNotFavored)) _jparser.validateByNameThrow("allinCashoutNotFavored", allinCashoutNotFavored);
	AtfValidator::validateInt(_descr, "allinCashoutNotFavored", allinCashoutNotFavored, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 progressivePlusEntryId; if(!_jparser.validateByName("pppEId", progressivePlusEntryId)) _jparser.validateByNameThrow("progressivePlusEntryId", progressivePlusEntryId);
	AtfValidator::validateUint(_descr, "progressivePlusEntryId", progressivePlusEntryId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_LOGIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE sittingStatus; _parser.parseBYTE(sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clientIP"); size_t szClientIP = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientIP", szClientIP, _checker, __FILE__, __LINE__);
	UINT32 waitingStatus; _parser.parseUINT32(waitingStatus);
	AtfValidator::validateInt(_descr, "waitingStatus", waitingStatus, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOptions; _parser.parseINT8(autoRebuyOptions);
	AtfValidator::validateInt(_descr, "autoRebuyOptions", autoRebuyOptions, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _parser.parseUINT16(autoRebuyBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyBigBets", autoRebuyBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderBigBets; _parser.parseUINT16(autoRebuyFallUnderBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderPercents; _parser.parseUINT16(autoRebuyFallUnderPercents);
	AtfValidator::validateInt(_descr, "autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, _checker, __FILE__, __LINE__);
	bool playerRITFavored; _parser.parseBOOL(playerRITFavored);
	AtfValidator::validateInt(_descr, "playerRITFavored", playerRITFavored, _checker, __FILE__, __LINE__);
	bool campingPreventionEnabled; _parser.parseBOOL(campingPreventionEnabled);
	AtfValidator::validateInt(_descr, "campingPreventionEnabled", campingPreventionEnabled, _checker, __FILE__, __LINE__);
	bool isTableDealingHands; _parser.parseBOOL(isTableDealingHands);
	AtfValidator::validateInt(_descr, "isTableDealingHands", isTableDealingHands, _checker, __FILE__, __LINE__);
	UINT16 campingCountingDownSec; _parser.parseUINT16(campingCountingDownSec);
	AtfValidator::validateInt(_descr, "campingCountingDownSec", campingCountingDownSec, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool allinCashoutNotFavored; _parser.parseBOOL(allinCashoutNotFavored);
	AtfValidator::validateInt(_descr, "allinCashoutNotFavored", allinCashoutNotFavored, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 progressivePlusEntryId; _parser.parseUINT64(progressivePlusEntryId);
	AtfValidator::validateUint(_descr, "progressivePlusEntryId", progressivePlusEntryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_LOGOUT
//=================================================================

TableClient::player::Protocol_MSG_TABLE_LOGOUT::Protocol_MSG_TABLE_LOGOUT()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_LOGOUT::clear()
{
}

bool TableClient::player::Protocol_MSG_TABLE_LOGOUT::equals(const Protocol_MSG_TABLE_LOGOUT& _o) const
{
	return true;
}

bool TableClient::player::Protocol_MSG_TABLE_LOGOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGOUT*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGOUT).append(")");
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_LOGOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_LOGOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void TableClient::player::Protocol_MSG_TABLE_LOGOUT::parseMsg(CommMsgParser& _parser)
{
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_LOGOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_LOGOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_LOGOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_LOGOUT_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::Protocol_MSG_TABLE_LOGOUT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::Protocol_MSG_TABLE_LOGOUT_REPLY(Protocol_MSG_TABLE_LOGOUT_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, totalBetInfo(std::move(_o.totalBetInfo))
{
}

TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY& TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::operator=(Protocol_MSG_TABLE_LOGOUT_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		totalBetInfo = std::move(_o.totalBetInfo);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	totalBetInfo.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::equals(const Protocol_MSG_TABLE_LOGOUT_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		totalBetInfo.equals(_o.totalBetInfo);
}

bool TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_LOGOUT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_LOGOUT_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_LOGOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("totalBetInfo=");
	totalBetInfo.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_LOGOUT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	totalBetInfo.toXmlString("totalBetInfo", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("totalBetInfo"))
			{
				if(!Atf::AtfTempl< TotalBetInfo >::FromXmlString(_value, totalBetInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	totalBetInfo.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	totalBetInfo.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("totalBetInfo", totalBetInfo);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	_jparser.parseByNameThrow("totalBetInfo", totalBetInfo);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	TotalBetInfo totalBetInfo; _jparser.validateByNameThrow("totalBetInfo", totalBetInfo);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_LOGOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_LOGOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TotalBetInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("totalBetInfo"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE
//=================================================================

TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE(Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE&& _o)
	: eligible(std::move(_o.eligible))
	, numPlayedHands(std::move(_o.numPlayedHands))
	, poolBlockMinHands(std::move(_o.poolBlockMinHands))
	, poolBlockTimePenalty(std::move(_o.poolBlockTimePenalty))
{
}

TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE& TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::operator=(Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE&& _o)
{
	if(this != &_o)
	{
		eligible = std::move(_o.eligible);
		numPlayedHands = std::move(_o.numPlayedHands);
		poolBlockMinHands = std::move(_o.poolBlockMinHands);
		poolBlockTimePenalty = std::move(_o.poolBlockTimePenalty);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::clear()
{
	eligible = false;
	numPlayedHands = 0;
	poolBlockMinHands = 0;
	poolBlockTimePenalty.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::equals(const Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE& _o) const
{
	return eligible == _o.eligible &&
		numPlayedHands == _o.numPlayedHands &&
		poolBlockMinHands == _o.poolBlockMinHands &&
		poolBlockTimePenalty.equals(_o.poolBlockTimePenalty);
}

bool TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE).append(")");
	_buf.append(',');
	_buf.append("eligible=");
	_buf.appendUint(eligible);
	_buf.append(',');
	_buf.append("numPlayedHands=");
	_buf.appendInt(numPlayedHands);
	_buf.append(',');
	_buf.append("poolBlockMinHands=");
	_buf.appendInt(poolBlockMinHands);
	_buf.append(',');
	_buf.append("poolBlockTimePenalty=");
	poolBlockTimePenalty.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("eligible", eligible, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayedHands", numPlayedHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("poolBlockMinHands", poolBlockMinHands, _buf);
	poolBlockTimePenalty.toXmlString("poolBlockTimePenalty", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("eligible"))
			{
				eligible = (*_value.ptr() == '1');
			}
			else if (_element.equals("numPlayedHands"))
			{
				numPlayedHands = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("poolBlockMinHands"))
			{
				poolBlockMinHands = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("poolBlockTimePenalty"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, poolBlockTimePenalty)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(eligible);
	_msg.composeINT32(numPlayedHands);
	_msg.composeINT32(poolBlockMinHands);
	poolBlockTimePenalty.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(eligible);
	_parser.parseINT32(numPlayedHands);
	_parser.parseINT32(poolBlockMinHands);
	poolBlockTimePenalty.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("eligible", eligible);
	_jsonstr.compose("numPlayedHands", numPlayedHands);
	_jsonstr.compose("poolBlockMinHands", poolBlockMinHands);
	_jsonstr.compose("poolBlockTimePenalty", poolBlockTimePenalty);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("eligible", eligible);
	_jparser.parseByNameThrow("numPlayedHands", numPlayedHands);
	_jparser.parseByNameThrow("poolBlockMinHands", poolBlockMinHands);
	_jparser.parseByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool eligible; _jparser.validateByNameThrow("eligible", eligible);
	AtfValidator::validateInt(_descr, "eligible", eligible, _checker, __FILE__, __LINE__);
	INT32 numPlayedHands; _jparser.validateByNameThrow("numPlayedHands", numPlayedHands);
	AtfValidator::validateInt(_descr, "numPlayedHands", numPlayedHands, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _jparser.validateByNameThrow("poolBlockMinHands", poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > poolBlockTimePenalty; _jparser.validateByNameThrow("poolBlockTimePenalty", poolBlockTimePenalty);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", poolBlockTimePenalty.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool eligible; _parser.parseBOOL(eligible);
	AtfValidator::validateInt(_descr, "eligible", eligible, _checker, __FILE__, __LINE__);
	INT32 numPlayedHands; _parser.parseINT32(numPlayedHands);
	AtfValidator::validateInt(_descr, "numPlayedHands", numPlayedHands, _checker, __FILE__, __LINE__);
	INT32 poolBlockMinHands; _parser.parseINT32(poolBlockMinHands);
	AtfValidator::validateInt(_descr, "poolBlockMinHands", poolBlockMinHands, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPoolBlockTimePenalty = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("poolBlockTimePenalty"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "poolBlockTimePenalty", szPoolBlockTimePenalty, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SIT1
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SIT1::Protocol_MSG_TABLE_SIT1()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SIT1::clear()
{
	seat = -1;
	verifyKey = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT1::equals(const Protocol_MSG_TABLE_SIT1& _o) const
{
	return seat == _o.seat &&
		verifyKey == _o.verifyKey;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT1::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SIT1 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SIT1*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT1::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SIT1).append(")");
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("verifyKey=");
	_buf.appendUint(verifyKey);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT1::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT1::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SIT1).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("verifyKey", verifyKey, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SIT1::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("verifyKey"))
			{
				verifyKey = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SIT1::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(seat);
	_msg.composeUINT32(verifyKey);
}

void TableClient::player::Protocol_MSG_TABLE_SIT1::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(seat);
	_parser.parseUINT32(verifyKey);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT1::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("verifyKey", verifyKey);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SIT1::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("verifyKey", verifyKey);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT1::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT1";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	UINT32 verifyKey; _jparser.validateByNameThrow("verifyKey", verifyKey);
	AtfValidator::validateInt(_descr, "verifyKey", verifyKey, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT1::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT1";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	UINT32 verifyKey; _parser.parseUINT32(verifyKey);
	AtfValidator::validateInt(_descr, "verifyKey", verifyKey, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SIT1_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::Protocol_MSG_TABLE_SIT1_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::Protocol_MSG_TABLE_SIT1_REPLY(Protocol_MSG_TABLE_SIT1_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errUser(std::move(_o.errUser))
	, chips(std::move(_o.chips))
	, minLimit(std::move(_o.minLimit))
	, maxLimit(std::move(_o.maxLimit))
	, chipQuantum(std::move(_o.chipQuantum))
	, playAddedMask(std::move(_o.playAddedMask))
	, playAddedAmount(std::move(_o.playAddedAmount))
	, seat(std::move(_o.seat))
	, clientServiceFlag(std::move(_o.clientServiceFlag))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, currencyContextCli(std::move(_o.currencyContextCli))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
	, ratHoleInSec(std::move(_o.ratHoleInSec))
	, pmChips(std::move(_o.pmChips))
	, userRollId(std::move(_o.userRollId))
{
}

TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY& TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::operator=(Protocol_MSG_TABLE_SIT1_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errUser = std::move(_o.errUser);
		chips = std::move(_o.chips);
		minLimit = std::move(_o.minLimit);
		maxLimit = std::move(_o.maxLimit);
		chipQuantum = std::move(_o.chipQuantum);
		playAddedMask = std::move(_o.playAddedMask);
		playAddedAmount = std::move(_o.playAddedAmount);
		seat = std::move(_o.seat);
		clientServiceFlag = std::move(_o.clientServiceFlag);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		currencyContextCli = std::move(_o.currencyContextCli);
		defaultBuyIn = std::move(_o.defaultBuyIn);
		ratHoleInSec = std::move(_o.ratHoleInSec);
		pmChips = std::move(_o.pmChips);
		userRollId = std::move(_o.userRollId);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::clear()
{
	errcode = 0;
	errUser.clear();
	chips = 0;
	minLimit = 0;
	maxLimit = 0;
	chipQuantum = 0;
	playAddedMask = 0;
	playAddedAmount = 0;
	seat = -1;
	clientServiceFlag = 0;
	clientMsg_txtEx.clear();
	currencyContextCli.clear();
	defaultBuyIn = 0;
	ratHoleInSec = 0;
	pmChips = 0;
	userRollId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::equals(const Protocol_MSG_TABLE_SIT1_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errUser, _o.errUser) &&
		chips == _o.chips &&
		minLimit == _o.minLimit &&
		maxLimit == _o.maxLimit &&
		chipQuantum == _o.chipQuantum &&
		playAddedMask == _o.playAddedMask &&
		playAddedAmount == _o.playAddedAmount &&
		seat == _o.seat &&
		clientServiceFlag == _o.clientServiceFlag &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		currencyContextCli.equals(_o.currencyContextCli) &&
		defaultBuyIn == _o.defaultBuyIn &&
		ratHoleInSec == _o.ratHoleInSec &&
		pmChips == _o.pmChips &&
		userRollId == _o.userRollId;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SIT1_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SIT1_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SIT1_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errUser=");
	_buf.append(errUser);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("mnLim=");
	_buf.appendUint(minLimit);
	_buf.append(',');
	_buf.append("mxLim=");
	_buf.appendUint(maxLimit);
	_buf.append(',');
	_buf.append("cq=");
	_buf.appendUint(chipQuantum);
	_buf.append(',');
	_buf.append("playAddedMask=");
	_buf.appendUint(playAddedMask);
	_buf.append(',');
	_buf.append("playAddedAmount=");
	_buf.appendUint(playAddedAmount);
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("csf=");
	_buf.appendUint(clientServiceFlag);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("currency=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContextCli, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("defaultBi=");
	_buf.appendUint(defaultBuyIn);
	_buf.append(',');
	_buf.append("rh=");
	_buf.appendUint(ratHoleInSec);
	_buf.append(',');
	_buf.append("pmChips=");
	_buf.appendUint64(pmChips);
	_buf.append(',');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SIT1_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errUser", errUser, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("mnLim", minLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("mxLim", maxLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("cq", chipQuantum, _buf);
	Atf::XmlElement::encodeAsXmlElement("playAddedMask", playAddedMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("playAddedAmount", playAddedAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("csf", clientServiceFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currencyContextCli, _buf);
	Atf::XmlElement::encodeAsXmlElement("defaultBi", defaultBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rh", ratHoleInSec, _buf);
	Atf::XmlElement::encodeAsXmlElement("pmChips", pmChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("userRollId", userRollId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errUser"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errUser)) return false;
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mnLim") || _element.equals("minLimit"))
			{
				minLimit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mxLim") || _element.equals("maxLimit"))
			{
				maxLimit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cq") || _element.equals("chipQuantum"))
			{
				chipQuantum = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playAddedMask"))
			{
				playAddedMask = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playAddedAmount"))
			{
				playAddedAmount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("csf") || _element.equals("clientServiceFlag"))
			{
				clientServiceFlag = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("currency") || _element.equals("currencyContextCli"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContextCli)) return false;
			}
			else if (_element.equals("defaultBi") || _element.equals("defaultBuyIn"))
			{
				defaultBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rh") || _element.equals("ratHoleInSec"))
			{
				ratHoleInSec = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pmChips"))
			{
				pmChips = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userRollId"))
			{
				userRollId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errUser);
	_msg.composeUINT32(chips);
	_msg.composeUINT32(minLimit);
	_msg.composeUINT32(maxLimit);
	_msg.composeUINT32(chipQuantum);
	_msg.composeBYTE(playAddedMask);
	_msg.composeUINT32(playAddedAmount);
	_msg.composeINT8(seat);
	_msg.composeBYTE(clientServiceFlag);
	_msg.composeMsgBody(clientMsg_txtEx);
	_msg.composeMsgBody(currencyContextCli);
	_msg.composeUINT32(defaultBuyIn);
	_msg.composeUINT32(ratHoleInSec);
	_msg.composeUINT64(pmChips);
	_msg.composeUINT32(userRollId);
}

void TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errUser);
	_parser.parseUINT32(chips);
	_parser.parseUINT32(minLimit);
	_parser.parseUINT32(maxLimit);
	_parser.parseUINT32(chipQuantum);
	_parser.parseBYTE(playAddedMask);
	_parser.parseUINT32(playAddedAmount);
	_parser.parseINT8(seat);
	_parser.parseBYTE(clientServiceFlag);
	_parser.parseMsgBody(clientMsg_txtEx);
	_parser.parseMsgBody(currencyContextCli);
	_parser.parseUINT32(defaultBuyIn);
	_parser.parseUINT32(ratHoleInSec);
	_parser.parseUINT64(pmChips);
	_parser.parseUINT32(userRollId);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errUser", errUser);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("mnLim", minLimit);
	_jsonstr.compose("mxLim", maxLimit);
	_jsonstr.compose("cq", chipQuantum);
	_jsonstr.compose("playAddedMask", playAddedMask);
	_jsonstr.compose("playAddedAmount", playAddedAmount);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("csf", clientServiceFlag);
	_jsonstr.compose("m", clientMsg_txtEx);
	_jsonstr.compose("currency", currencyContextCli);
	_jsonstr.compose("defaultBi", defaultBuyIn);
	_jsonstr.compose("rh", ratHoleInSec);
	_jsonstr.compose("pmChips", pmChips);
	_jsonstr.compose("userRollId", userRollId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errUser", errUser);
	_jparser.parseByNameThrow("chips", chips);
	if(!_jparser.parseByName("mnLim", minLimit)) _jparser.parseByNameThrow("minLimit", minLimit);
	if(!_jparser.parseByName("mxLim", maxLimit)) _jparser.parseByNameThrow("maxLimit", maxLimit);
	if(!_jparser.parseByName("cq", chipQuantum)) _jparser.parseByNameThrow("chipQuantum", chipQuantum);
	_jparser.parseByNameThrow("playAddedMask", playAddedMask);
	_jparser.parseByNameThrow("playAddedAmount", playAddedAmount);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	if(!_jparser.parseByName("csf", clientServiceFlag)) _jparser.parseByNameThrow("clientServiceFlag", clientServiceFlag);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	if(!_jparser.parseByName("currency", currencyContextCli)) _jparser.parseByNameThrow("currencyContextCli", currencyContextCli);
	if(!_jparser.parseByName("defaultBi", defaultBuyIn)) _jparser.parseByNameThrow("defaultBuyIn", defaultBuyIn);
	if(!_jparser.parseByName("rh", ratHoleInSec)) _jparser.parseByNameThrow("ratHoleInSec", ratHoleInSec);
	_jparser.parseByNameThrow("pmChips", pmChips);
	_jparser.parseByNameThrow("userRollId", userRollId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT1_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errUser; _jparser.validateByNameThrow("errUser", errUser);
	AtfValidator::validateInt(_descr, "errUser", errUser.length(), _checker, __FILE__, __LINE__);
	UINT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT32 minLimit; if(!_jparser.validateByName("mnLim", minLimit)) _jparser.validateByNameThrow("minLimit", minLimit);
	AtfValidator::validateInt(_descr, "minLimit", minLimit, _checker, __FILE__, __LINE__);
	UINT32 maxLimit; if(!_jparser.validateByName("mxLim", maxLimit)) _jparser.validateByNameThrow("maxLimit", maxLimit);
	AtfValidator::validateInt(_descr, "maxLimit", maxLimit, _checker, __FILE__, __LINE__);
	UINT32 chipQuantum; if(!_jparser.validateByName("cq", chipQuantum)) _jparser.validateByNameThrow("chipQuantum", chipQuantum);
	AtfValidator::validateInt(_descr, "chipQuantum", chipQuantum, _checker, __FILE__, __LINE__);
	BYTE playAddedMask; _jparser.validateByNameThrow("playAddedMask", playAddedMask);
	AtfValidator::validateInt(_descr, "playAddedMask", playAddedMask, _checker, __FILE__, __LINE__);
	UINT32 playAddedAmount; _jparser.validateByNameThrow("playAddedAmount", playAddedAmount);
	AtfValidator::validateInt(_descr, "playAddedAmount", playAddedAmount, _checker, __FILE__, __LINE__);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; if(!_jparser.validateByName("csf", clientServiceFlag)) _jparser.validateByNameThrow("clientServiceFlag", clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody currencyContextCli; if(!_jparser.validateByName("currency", currencyContextCli)) _jparser.validateByNameThrow("currencyContextCli", currencyContextCli);
	AtfValidator::validateInt(_descr, "currencyContextCli", currencyContextCli._size(), _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; if(!_jparser.validateByName("defaultBi", defaultBuyIn)) _jparser.validateByNameThrow("defaultBuyIn", defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 ratHoleInSec; if(!_jparser.validateByName("rh", ratHoleInSec)) _jparser.validateByNameThrow("ratHoleInSec", ratHoleInSec);
	AtfValidator::validateInt(_descr, "ratHoleInSec", ratHoleInSec, _checker, __FILE__, __LINE__);
	UINT64 pmChips; _jparser.validateByNameThrow("pmChips", pmChips);
	AtfValidator::validateUint(_descr, "pmChips", pmChips, _checker, __FILE__, __LINE__);
	UINT32 userRollId; _jparser.validateByNameThrow("userRollId", userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT1_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT1_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errUser"); size_t szErrUser = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errUser", szErrUser, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT32 minLimit; _parser.parseUINT32(minLimit);
	AtfValidator::validateInt(_descr, "minLimit", minLimit, _checker, __FILE__, __LINE__);
	UINT32 maxLimit; _parser.parseUINT32(maxLimit);
	AtfValidator::validateInt(_descr, "maxLimit", maxLimit, _checker, __FILE__, __LINE__);
	UINT32 chipQuantum; _parser.parseUINT32(chipQuantum);
	AtfValidator::validateInt(_descr, "chipQuantum", chipQuantum, _checker, __FILE__, __LINE__);
	BYTE playAddedMask; _parser.parseBYTE(playAddedMask);
	AtfValidator::validateInt(_descr, "playAddedMask", playAddedMask, _checker, __FILE__, __LINE__);
	UINT32 playAddedAmount; _parser.parseUINT32(playAddedAmount);
	AtfValidator::validateInt(_descr, "playAddedAmount", playAddedAmount, _checker, __FILE__, __LINE__);
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	size_t szCurrencyContextCli; _parser.skipMsgBody(szCurrencyContextCli);  /*currencyContextCli*/
	AtfValidator::validateInt(_descr, "currencyContextCli", szCurrencyContextCli, _checker, __FILE__, __LINE__);
	UINT32 defaultBuyIn; _parser.parseUINT32(defaultBuyIn);
	AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	UINT32 ratHoleInSec; _parser.parseUINT32(ratHoleInSec);
	AtfValidator::validateInt(_descr, "ratHoleInSec", ratHoleInSec, _checker, __FILE__, __LINE__);
	UINT64 pmChips; _parser.parseUINT64(pmChips);
	AtfValidator::validateUint(_descr, "pmChips", pmChips, _checker, __FILE__, __LINE__);
	UINT32 userRollId; _parser.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SIT2
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SIT2::Protocol_MSG_TABLE_SIT2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_SIT2::Protocol_MSG_TABLE_SIT2(Protocol_MSG_TABLE_SIT2&& _o)
	: chips(std::move(_o.chips))
	, pwd(std::move(_o.pwd))
	, autoRebuyOpt(std::move(_o.autoRebuyOpt))
	, autoRebuyBigBets(std::move(_o.autoRebuyBigBets))
	, autoRebuyFallUnderBigBets(std::move(_o.autoRebuyFallUnderBigBets))
	, autoRebuyFallUnderPercents(std::move(_o.autoRebuyFallUnderPercents))
	, notShowWhenAllIn(std::move(_o.notShowWhenAllIn))
	, realMoneyChips(std::move(_o.realMoneyChips))
	, runItTwice(std::move(_o.runItTwice))
	, allinCashoutNotFavored(std::move(_o.allinCashoutNotFavored))
{
}

TableClient::player::Protocol_MSG_TABLE_SIT2& TableClient::player::Protocol_MSG_TABLE_SIT2::operator=(Protocol_MSG_TABLE_SIT2&& _o)
{
	if(this != &_o)
	{
		chips = std::move(_o.chips);
		pwd = std::move(_o.pwd);
		autoRebuyOpt = std::move(_o.autoRebuyOpt);
		autoRebuyBigBets = std::move(_o.autoRebuyBigBets);
		autoRebuyFallUnderBigBets = std::move(_o.autoRebuyFallUnderBigBets);
		autoRebuyFallUnderPercents = std::move(_o.autoRebuyFallUnderPercents);
		notShowWhenAllIn = std::move(_o.notShowWhenAllIn);
		realMoneyChips = std::move(_o.realMoneyChips);
		runItTwice = std::move(_o.runItTwice);
		allinCashoutNotFavored = std::move(_o.allinCashoutNotFavored);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_SIT2::clear()
{
	chips = 0;
	pwd.clear();
	autoRebuyOpt = 0;
	autoRebuyBigBets = 0;
	autoRebuyFallUnderBigBets = 0;
	autoRebuyFallUnderPercents = 0;
	notShowWhenAllIn = false;
	realMoneyChips = 0;
	runItTwice = false;
	allinCashoutNotFavored = false;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT2::equals(const Protocol_MSG_TABLE_SIT2& _o) const
{
	return chips == _o.chips &&
		Atf::atfPStringEquals(pwd, _o.pwd) &&
		autoRebuyOpt == _o.autoRebuyOpt &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		autoRebuyFallUnderBigBets == _o.autoRebuyFallUnderBigBets &&
		autoRebuyFallUnderPercents == _o.autoRebuyFallUnderPercents &&
		notShowWhenAllIn == _o.notShowWhenAllIn &&
		realMoneyChips == _o.realMoneyChips &&
		runItTwice == _o.runItTwice &&
		allinCashoutNotFavored == _o.allinCashoutNotFavored;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SIT2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SIT2*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SIT2).append(")");
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("pwd=");
	_buf.append(pwd);
	_buf.append(',');
	_buf.append("ar=");
	_buf.appendInt(autoRebuyOpt);
	_buf.append(',');
	_buf.append("arBB=");
	_buf.appendUint(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("arFBB=");
	_buf.appendUint(autoRebuyFallUnderBigBets);
	_buf.append(',');
	_buf.append("arFPct=");
	_buf.appendUint(autoRebuyFallUnderPercents);
	_buf.append(',');
	_buf.append("nshown=");
	_buf.appendUint(notShowWhenAllIn);
	_buf.append(',');
	_buf.append("rmChips=");
	_buf.appendUint(realMoneyChips);
	_buf.append(',');
	_buf.append("rit=");
	_buf.appendUint(runItTwice);
	_buf.append(',');
	_buf.append("nco=");
	_buf.appendUint(allinCashoutNotFavored);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SIT2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("pwd", pwd, _buf);
	Atf::XmlElement::encodeAsXmlElement("ar", autoRebuyOpt, _buf);
	Atf::XmlElement::encodeAsXmlElement("arBB", autoRebuyBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("arFBB", autoRebuyFallUnderBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("arFPct", autoRebuyFallUnderPercents, _buf);
	Atf::XmlElement::encodeAsXmlElement("nshown", notShowWhenAllIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rmChips", realMoneyChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("rit", runItTwice, _buf);
	Atf::XmlElement::encodeAsXmlElement("nco", allinCashoutNotFavored, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SIT2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("chips"))
			{
				chips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pwd"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, pwd)) return false;
			}
			else if (_element.equals("ar") || _element.equals("autoRebuyOpt"))
			{
				autoRebuyOpt = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("arBB") || _element.equals("autoRebuyBigBets"))
			{
				autoRebuyBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("arFBB") || _element.equals("autoRebuyFallUnderBigBets"))
			{
				autoRebuyFallUnderBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("arFPct") || _element.equals("autoRebuyFallUnderPercents"))
			{
				autoRebuyFallUnderPercents = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nshown") || _element.equals("notShowWhenAllIn"))
			{
				notShowWhenAllIn = (*_value.ptr() == '1');
			}
			else if (_element.equals("rmChips") || _element.equals("realMoneyChips"))
			{
				realMoneyChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rit") || _element.equals("runItTwice"))
			{
				runItTwice = (*_value.ptr() == '1');
			}
			else if (_element.equals("nco") || _element.equals("allinCashoutNotFavored"))
			{
				allinCashoutNotFavored = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SIT2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(chips);
	_msg.composeString(pwd);
	_msg.composeINT8(autoRebuyOpt);
	_msg.composeUINT16(autoRebuyBigBets);
	_msg.composeUINT16(autoRebuyFallUnderBigBets);
	_msg.composeUINT16(autoRebuyFallUnderPercents);
	_msg.composeBOOL(notShowWhenAllIn);
	_msg.composeUINT32(realMoneyChips);
	_msg.composeBOOL(runItTwice);
	_msg.composeBOOL(allinCashoutNotFavored);
}

void TableClient::player::Protocol_MSG_TABLE_SIT2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(chips);
	_parser.parseStringP(pwd);
	_parser.parseINT8(autoRebuyOpt);
	_parser.parseUINT16(autoRebuyBigBets);
	_parser.parseUINT16(autoRebuyFallUnderBigBets);
	_parser.parseUINT16(autoRebuyFallUnderPercents);
	_parser.parseBOOL(notShowWhenAllIn);
	_parser.parseUINT32(realMoneyChips);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(runItTwice);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(allinCashoutNotFavored);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("pwd", pwd);
	_jsonstr.compose("ar", autoRebuyOpt);
	_jsonstr.compose("arBB", autoRebuyBigBets);
	_jsonstr.compose("arFBB", autoRebuyFallUnderBigBets);
	_jsonstr.compose("arFPct", autoRebuyFallUnderPercents);
	_jsonstr.compose("nshown", notShowWhenAllIn);
	_jsonstr.compose("rmChips", realMoneyChips);
	_jsonstr.compose("rit", runItTwice);
	_jsonstr.compose("nco", allinCashoutNotFavored);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SIT2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("pwd", pwd);
	if(!_jparser.parseByName("ar", autoRebuyOpt)) _jparser.parseByNameThrow("autoRebuyOpt", autoRebuyOpt);
	if(!_jparser.parseByName("arBB", autoRebuyBigBets)) _jparser.parseByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	if(!_jparser.parseByName("arFBB", autoRebuyFallUnderBigBets)) _jparser.parseByNameThrow("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	if(!_jparser.parseByName("arFPct", autoRebuyFallUnderPercents)) _jparser.parseByNameThrow("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	if(!_jparser.parseByName("nshown", notShowWhenAllIn)) _jparser.parseByNameThrow("notShowWhenAllIn", notShowWhenAllIn);
	if(!_jparser.parseByName("rmChips", realMoneyChips)) _jparser.parseByNameThrow("realMoneyChips", realMoneyChips);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("rit", runItTwice)) _jparser.parseByNameThrow("runItTwice", runItTwice);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("nco", allinCashoutNotFavored)) _jparser.parseByNameThrow("allinCashoutNotFavored", allinCashoutNotFavored);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateIntMin(_descr, "chips", chips, 0, _checker, __FILE__, __LINE__);
	PString pwd; _jparser.validateByNameThrow("pwd", pwd);
	AtfValidator::validateIntMax(_descr, "pwd", pwd.length(), 100, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; if(!_jparser.validateByName("ar", autoRebuyOpt)) _jparser.validateByNameThrow("autoRebuyOpt", autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, 0, 100, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; if(!_jparser.validateByName("arBB", autoRebuyBigBets)) _jparser.validateByNameThrow("autoRebuyBigBets", autoRebuyBigBets);
	AtfValidator::validateIntMax(_descr, "autoRebuyBigBets", autoRebuyBigBets, 1000, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderBigBets; if(!_jparser.validateByName("arFBB", autoRebuyFallUnderBigBets)) _jparser.validateByNameThrow("autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets);
	AtfValidator::validateIntMax(_descr, "autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, 1000, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderPercents; if(!_jparser.validateByName("arFPct", autoRebuyFallUnderPercents)) _jparser.validateByNameThrow("autoRebuyFallUnderPercents", autoRebuyFallUnderPercents);
	AtfValidator::validateIntMax(_descr, "autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, 100, _checker, __FILE__, __LINE__);
	bool notShowWhenAllIn; if(!_jparser.validateByName("nshown", notShowWhenAllIn)) _jparser.validateByNameThrow("notShowWhenAllIn", notShowWhenAllIn);
	AtfValidator::validateInt(_descr, "notShowWhenAllIn", notShowWhenAllIn, _checker, __FILE__, __LINE__);
	UINT32 realMoneyChips; if(!_jparser.validateByName("rmChips", realMoneyChips)) _jparser.validateByNameThrow("realMoneyChips", realMoneyChips);
	AtfValidator::validateIntMax(_descr, "realMoneyChips", realMoneyChips, 2000000000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool runItTwice; if(!_jparser.validateByName("rit", runItTwice)) _jparser.validateByNameThrow("runItTwice", runItTwice);
	AtfValidator::validateInt(_descr, "runItTwice", runItTwice, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool allinCashoutNotFavored; if(!_jparser.validateByName("nco", allinCashoutNotFavored)) _jparser.validateByNameThrow("allinCashoutNotFavored", allinCashoutNotFavored);
	AtfValidator::validateInt(_descr, "allinCashoutNotFavored", allinCashoutNotFavored, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 chips; _parser.parseINT32(chips);
	AtfValidator::validateIntMin(_descr, "chips", chips, 0, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pwd"); size_t szPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, 100, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _parser.parseINT8(autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, 0, 100, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _parser.parseUINT16(autoRebuyBigBets);
	AtfValidator::validateIntMax(_descr, "autoRebuyBigBets", autoRebuyBigBets, 1000, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderBigBets; _parser.parseUINT16(autoRebuyFallUnderBigBets);
	AtfValidator::validateIntMax(_descr, "autoRebuyFallUnderBigBets", autoRebuyFallUnderBigBets, 1000, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyFallUnderPercents; _parser.parseUINT16(autoRebuyFallUnderPercents);
	AtfValidator::validateIntMax(_descr, "autoRebuyFallUnderPercents", autoRebuyFallUnderPercents, 100, _checker, __FILE__, __LINE__);
	bool notShowWhenAllIn; _parser.parseBOOL(notShowWhenAllIn);
	AtfValidator::validateInt(_descr, "notShowWhenAllIn", notShowWhenAllIn, _checker, __FILE__, __LINE__);
	UINT32 realMoneyChips; _parser.parseUINT32(realMoneyChips);
	AtfValidator::validateIntMax(_descr, "realMoneyChips", realMoneyChips, 2000000000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool runItTwice; _parser.parseBOOL(runItTwice);
	AtfValidator::validateInt(_descr, "runItTwice", runItTwice, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool allinCashoutNotFavored; _parser.parseBOOL(allinCashoutNotFavored);
	AtfValidator::validateInt(_descr, "allinCashoutNotFavored", allinCashoutNotFavored, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SIT2_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::Protocol_MSG_TABLE_SIT2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::Protocol_MSG_TABLE_SIT2_REPLY(Protocol_MSG_TABLE_SIT2_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, sittingStatus(std::move(_o.sittingStatus))
	, waitingStatus(std::move(_o.waitingStatus))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, numOfSeats(std::move(_o.numOfSeats))
	, chipsAfter(std::move(_o.chipsAfter))
{
}

TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY& TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::operator=(Protocol_MSG_TABLE_SIT2_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		sittingStatus = std::move(_o.sittingStatus);
		waitingStatus = std::move(_o.waitingStatus);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		numOfSeats = std::move(_o.numOfSeats);
		chipsAfter = std::move(_o.chipsAfter);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	sittingStatus = 0;
	waitingStatus = 0;
	clientMsg_txtEx.clear();
	numOfSeats = 0;
	chipsAfter = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::equals(const Protocol_MSG_TABLE_SIT2_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		sittingStatus == _o.sittingStatus &&
		waitingStatus == _o.waitingStatus &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		numOfSeats == _o.numOfSeats &&
		chipsAfter == _o.chipsAfter;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SIT2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SIT2_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SIT2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("ss=");
	_buf.appendUint(sittingStatus);
	_buf.append(',');
	_buf.append("ws=");
	_buf.appendUint(waitingStatus);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("sz=");
	_buf.appendUint(numOfSeats);
	_buf.append(',');
	_buf.append("chipsAfter=");
	_buf.appendInt(chipsAfter);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SIT2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("ss", sittingStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("ws", waitingStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("sz", numOfSeats, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsAfter", chipsAfter, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("ss") || _element.equals("sittingStatus"))
			{
				sittingStatus = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ws") || _element.equals("waitingStatus"))
			{
				waitingStatus = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("sz") || _element.equals("numOfSeats"))
			{
				numOfSeats = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chipsAfter"))
			{
				chipsAfter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	_msg.composeBYTE(sittingStatus);
	_msg.composeUINT32(waitingStatus);
	_msg.composeMsgBody(clientMsg_txtEx);
	_msg.composeUINT32(numOfSeats);
	_msg.composeINT32(chipsAfter);
}

void TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	_parser.parseBYTE(sittingStatus);
	_parser.parseUINT32(waitingStatus);
	_parser.parseMsgBody(clientMsg_txtEx);
	_parser.parseUINT32(numOfSeats);
	_parser.parseINT32(chipsAfter);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("ss", sittingStatus);
	_jsonstr.compose("ws", waitingStatus);
	_jsonstr.compose("m", clientMsg_txtEx);
	_jsonstr.compose("sz", numOfSeats);
	_jsonstr.compose("chipsAfter", chipsAfter);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	if(!_jparser.parseByName("ss", sittingStatus)) _jparser.parseByNameThrow("sittingStatus", sittingStatus);
	if(!_jparser.parseByName("ws", waitingStatus)) _jparser.parseByNameThrow("waitingStatus", waitingStatus);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	if(!_jparser.parseByName("sz", numOfSeats)) _jparser.parseByNameThrow("numOfSeats", numOfSeats);
	_jparser.parseByNameThrow("chipsAfter", chipsAfter);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	BYTE sittingStatus; if(!_jparser.validateByName("ss", sittingStatus)) _jparser.validateByNameThrow("sittingStatus", sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	UINT32 waitingStatus; if(!_jparser.validateByName("ws", waitingStatus)) _jparser.validateByNameThrow("waitingStatus", waitingStatus);
	AtfValidator::validateInt(_descr, "waitingStatus", waitingStatus, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	UINT32 numOfSeats; if(!_jparser.validateByName("sz", numOfSeats)) _jparser.validateByNameThrow("numOfSeats", numOfSeats);
	AtfValidator::validateInt(_descr, "numOfSeats", numOfSeats, _checker, __FILE__, __LINE__);
	INT32 chipsAfter; _jparser.validateByNameThrow("chipsAfter", chipsAfter);
	AtfValidator::validateInt(_descr, "chipsAfter", chipsAfter, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	BYTE sittingStatus; _parser.parseBYTE(sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	UINT32 waitingStatus; _parser.parseUINT32(waitingStatus);
	AtfValidator::validateInt(_descr, "waitingStatus", waitingStatus, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	UINT32 numOfSeats; _parser.parseUINT32(numOfSeats);
	AtfValidator::validateInt(_descr, "numOfSeats", numOfSeats, _checker, __FILE__, __LINE__);
	INT32 chipsAfter; _parser.parseINT32(chipsAfter);
	AtfValidator::validateInt(_descr, "chipsAfter", chipsAfter, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_TIMEBANK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_TIMEBANK::Protocol_MSG_TABLE_TIMEBANK()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_TIMEBANK::clear()
{
	timeBank = 0;
	hasChipsPosted = false;
}

bool TableClient::player::Protocol_MSG_TABLE_TIMEBANK::equals(const Protocol_MSG_TABLE_TIMEBANK& _o) const
{
	return timeBank == _o.timeBank &&
		hasChipsPosted == _o.hasChipsPosted;
}

bool TableClient::player::Protocol_MSG_TABLE_TIMEBANK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_TIMEBANK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_TIMEBANK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_TIMEBANK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_TIMEBANK).append(")");
	_buf.append(',');
	_buf.append("tb=");
	_buf.appendUint(timeBank);
	_buf.append(',');
	_buf.append("hasChipsPosted=");
	_buf.appendUint(hasChipsPosted);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_TIMEBANK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_TIMEBANK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_TIMEBANK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tb", timeBank, _buf);
	Atf::XmlElement::encodeAsXmlElement("hasChipsPosted", hasChipsPosted, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_TIMEBANK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tb") || _element.equals("timeBank"))
			{
				timeBank = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hasChipsPosted"))
			{
				hasChipsPosted = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_TIMEBANK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(timeBank);
	_msg.composeBOOL(hasChipsPosted);
}

void TableClient::player::Protocol_MSG_TABLE_TIMEBANK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(timeBank);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(hasChipsPosted);
}

const char *TableClient::player::Protocol_MSG_TABLE_TIMEBANK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tb", timeBank);
	_jsonstr.compose("hasChipsPosted", hasChipsPosted);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_TIMEBANK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("tb", timeBank)) _jparser.parseByNameThrow("timeBank", timeBank);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("hasChipsPosted", hasChipsPosted);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_TIMEBANK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_TIMEBANK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 timeBank; if(!_jparser.validateByName("tb", timeBank)) _jparser.validateByNameThrow("timeBank", timeBank);
	AtfValidator::validateIntMax(_descr, "timeBank", timeBank, 1800, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool hasChipsPosted; _jparser.validateByNameThrow("hasChipsPosted", hasChipsPosted);
	AtfValidator::validateInt(_descr, "hasChipsPosted", hasChipsPosted, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_TIMEBANK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_TIMEBANK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 timeBank; _parser.parseUINT32(timeBank);
	AtfValidator::validateIntMax(_descr, "timeBank", timeBank, 1800, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool hasChipsPosted; _parser.parseBOOL(hasChipsPosted);
	AtfValidator::validateInt(_descr, "hasChipsPosted", hasChipsPosted, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_WARNING_BELL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::Protocol_MSG_TABLE_WARNING_BELL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::clear()
{
	delaySec = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::equals(const Protocol_MSG_TABLE_WARNING_BELL& _o) const
{
	return delaySec == _o.delaySec;
}

bool TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_WARNING_BELL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_WARNING_BELL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_WARNING_BELL).append(")");
	_buf.append(',');
	_buf.append("delaySec=");
	_buf.appendInt(delaySec);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_WARNING_BELL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("delaySec", delaySec, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("delaySec"))
			{
				delaySec = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(delaySec);
}

void TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(delaySec);
}

const char *TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("delaySec", delaySec);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("delaySec", delaySec);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_WARNING_BELL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 delaySec; _jparser.validateByNameThrow("delaySec", delaySec);
	AtfValidator::validateInt(_descr, "delaySec", delaySec, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_WARNING_BELL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_WARNING_BELL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 delaySec; _parser.parseINT32(delaySec);
	AtfValidator::validateInt(_descr, "delaySec", delaySec, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_REQUESTACTION
//=================================================================

TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::Protocol_MSG_TABLE_REQUESTACTION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::Protocol_MSG_TABLE_REQUESTACTION(Protocol_MSG_TABLE_REQUESTACTION&& _o)
	: actionOpts(std::move(_o.actionOpts))
	, actionReqSeq(std::move(_o.actionReqSeq))
	, timeoutSec(std::move(_o.timeoutSec))
	, isNewGame(std::move(_o.isNewGame))
	, gameRound(std::move(_o.gameRound))
{
}

TableClient::player::Protocol_MSG_TABLE_REQUESTACTION& TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::operator=(Protocol_MSG_TABLE_REQUESTACTION&& _o)
{
	if(this != &_o)
	{
		actionOpts = std::move(_o.actionOpts);
		actionReqSeq = std::move(_o.actionReqSeq);
		timeoutSec = std::move(_o.timeoutSec);
		isNewGame = std::move(_o.isNewGame);
		gameRound = std::move(_o.gameRound);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::clear()
{
	actionOpts.clear();
	actionReqSeq = 0;
	timeoutSec = 0;
	isNewGame = false;
	gameRound = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::equals(const Protocol_MSG_TABLE_REQUESTACTION& _o) const
{
	return actionOpts.equals(_o.actionOpts) &&
		actionReqSeq == _o.actionReqSeq &&
		timeoutSec == _o.timeoutSec &&
		isNewGame == _o.isNewGame &&
		gameRound == _o.gameRound;
}

bool TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_REQUESTACTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_REQUESTACTION*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_REQUESTACTION).append(")");
	_buf.append(',');
	_buf.append("aOpts=");
	actionOpts.toTraceString(_buf);
	_buf.append(',');
	_buf.append("seq=");
	_buf.appendUint(actionReqSeq);
	_buf.append(',');
	_buf.append("TO=");
	_buf.appendInt(timeoutSec);
	_buf.append(',');
	_buf.append("ng=");
	_buf.appendUint(isNewGame);
	_buf.append(',');
	_buf.append("gameRound=");
	_buf.appendInt(gameRound);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_REQUESTACTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	actionOpts.toXmlString("aOpts", _buf);
	Atf::XmlElement::encodeAsXmlElement("seq", actionReqSeq, _buf);
	Atf::XmlElement::encodeAsXmlElement("TO", timeoutSec, _buf);
	Atf::XmlElement::encodeAsXmlElement("ng", isNewGame, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameRound", gameRound, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("aOpts") || _element.equals("actionOpts"))
			{
				if(!Atf::AtfTempl< Atf::AtfVector0< P_PlayerRequestAction, 1 > >::FromXmlString(_value, actionOpts)) return false;
			}
			else if (_element.equals("seq") || _element.equals("actionReqSeq"))
			{
				actionReqSeq = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("TO") || _element.equals("timeoutSec"))
			{
				timeoutSec = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ng") || _element.equals("isNewGame"))
			{
				isNewGame = (*_value.ptr() == '1');
			}
			else if (_element.equals("gameRound"))
			{
				gameRound = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	actionOpts.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(actionReqSeq);
	_msg.composeINT32(timeoutSec);
	_msg.composeBOOL(isNewGame);
	_msg.composeINT32(gameRound);
}

void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::parseMsg(CommMsgParser& _parser)
{
	actionOpts.parseMsg(_parser);
	_parser.parseUINT32(actionReqSeq);
	_parser.parseINT32(timeoutSec);
	_parser.parseBOOL(isNewGame);
	_parser.parseINT32(gameRound);
}

const char *TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("aOpts", actionOpts);
	_jsonstr.compose("seq", actionReqSeq);
	_jsonstr.compose("TO", timeoutSec);
	_jsonstr.compose("ng", isNewGame);
	_jsonstr.compose("gameRound", gameRound);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("aOpts", actionOpts)) _jparser.parseByNameThrow("actionOpts", actionOpts);
	if(!_jparser.parseByName("seq", actionReqSeq)) _jparser.parseByNameThrow("actionReqSeq", actionReqSeq);
	if(!_jparser.parseByName("TO", timeoutSec)) _jparser.parseByNameThrow("timeoutSec", timeoutSec);
	if(!_jparser.parseByName("ng", isNewGame)) _jparser.parseByNameThrow("isNewGame", isNewGame);
	_jparser.parseByNameThrow("gameRound", gameRound);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REQUESTACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< P_PlayerRequestAction > actionOpts; if(!_jparser.validateByName("aOpts", actionOpts)) _jparser.validateByNameThrow("actionOpts", actionOpts);
	AtfValidator::validateInt(_descr, "actionOpts", actionOpts.size(), _checker, __FILE__, __LINE__);
	UINT32 actionReqSeq; if(!_jparser.validateByName("seq", actionReqSeq)) _jparser.validateByNameThrow("actionReqSeq", actionReqSeq);
	AtfValidator::validateInt(_descr, "actionReqSeq", actionReqSeq, _checker, __FILE__, __LINE__);
	INT32 timeoutSec; if(!_jparser.validateByName("TO", timeoutSec)) _jparser.validateByNameThrow("timeoutSec", timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
	bool isNewGame; if(!_jparser.validateByName("ng", isNewGame)) _jparser.validateByNameThrow("isNewGame", isNewGame);
	AtfValidator::validateInt(_descr, "isNewGame", isNewGame, _checker, __FILE__, __LINE__);
	INT32 gameRound; _jparser.validateByNameThrow("gameRound", gameRound);
	AtfValidator::validateInt(_descr, "gameRound", gameRound, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REQUESTACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szActionOpts = Atf::AtfVector0< P_PlayerRequestAction, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("actionOpts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "actionOpts", szActionOpts, _checker, __FILE__, __LINE__);
	UINT32 actionReqSeq; _parser.parseUINT32(actionReqSeq);
	AtfValidator::validateInt(_descr, "actionReqSeq", actionReqSeq, _checker, __FILE__, __LINE__);
	INT32 timeoutSec; _parser.parseINT32(timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
	bool isNewGame; _parser.parseBOOL(isNewGame);
	AtfValidator::validateInt(_descr, "isNewGame", isNewGame, _checker, __FILE__, __LINE__);
	INT32 gameRound; _parser.parseINT32(gameRound);
	AtfValidator::validateInt(_descr, "gameRound", gameRound, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY(Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, chipsAdded(std::move(_o.chipsAdded))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, italyReservedChips(std::move(_o.italyReservedChips))
{
}

TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY& TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::operator=(Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		chipsAdded = std::move(_o.chipsAdded);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		italyReservedChips = std::move(_o.italyReservedChips);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	chipsAdded = 0;
	clientMsg_txtEx.clear();
	italyReservedChips = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::equals(const Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		chipsAdded == _o.chipsAdded &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		italyReservedChips == _o.italyReservedChips;
}

bool TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_ADDCHIPS_AUTO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_ADDCHIPS_AUTO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("chipsAdded=");
	_buf.appendUint(chipsAdded);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(italyReservedChips);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_ADDCHIPS_AUTO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsAdded", chipsAdded, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("reserved", italyReservedChips, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("chipsAdded"))
			{
				chipsAdded = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("reserved") || _element.equals("italyReservedChips"))
			{
				italyReservedChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	_msg.composeUINT32(chipsAdded);
	_msg.composeMsgBody(clientMsg_txtEx);
	_msg.composeUINT32(italyReservedChips);
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	_parser.parseUINT32(chipsAdded);
	_parser.parseMsgBody(clientMsg_txtEx);
	_parser.parseUINT32(italyReservedChips);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("chipsAdded", chipsAdded);
	_jsonstr.compose("m", clientMsg_txtEx);
	_jsonstr.compose("reserved", italyReservedChips);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	_jparser.parseByNameThrow("chipsAdded", chipsAdded);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	if(!_jparser.parseByName("reserved", italyReservedChips)) _jparser.parseByNameThrow("italyReservedChips", italyReservedChips);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDCHIPS_AUTO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	UINT32 chipsAdded; _jparser.validateByNameThrow("chipsAdded", chipsAdded);
	AtfValidator::validateInt(_descr, "chipsAdded", chipsAdded, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	UINT32 italyReservedChips; if(!_jparser.validateByName("reserved", italyReservedChips)) _jparser.validateByNameThrow("italyReservedChips", italyReservedChips);
	AtfValidator::validateInt(_descr, "italyReservedChips", italyReservedChips, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDCHIPS_AUTO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	UINT32 chipsAdded; _parser.parseUINT32(chipsAdded);
	AtfValidator::validateInt(_descr, "chipsAdded", chipsAdded, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	UINT32 italyReservedChips; _parser.parseUINT32(italyReservedChips);
	AtfValidator::validateInt(_descr, "italyReservedChips", italyReservedChips, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_FORCE_SITOUT
//=================================================================

TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::Protocol_MSG_TABLE_FORCE_SITOUT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::Protocol_MSG_TABLE_FORCE_SITOUT(Protocol_MSG_TABLE_FORCE_SITOUT&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, sittingStatus(std::move(_o.sittingStatus))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
{
}

TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT& TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::operator=(Protocol_MSG_TABLE_FORCE_SITOUT&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		sittingStatus = std::move(_o.sittingStatus);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::clear()
{
	errcode = 0;
	errstr.clear();
	sittingStatus = 0;
	clientMsg_txtEx.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::equals(const Protocol_MSG_TABLE_FORCE_SITOUT& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		sittingStatus == _o.sittingStatus &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx);
}

bool TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_FORCE_SITOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_FORCE_SITOUT*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_FORCE_SITOUT).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("sittingStatus=");
	_buf.appendUint(sittingStatus);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_FORCE_SITOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("sittingStatus", sittingStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("sittingStatus"))
			{
				sittingStatus = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	_msg.composeBYTE(sittingStatus);
	_msg.composeMsgBody(clientMsg_txtEx);
}

void TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	_parser.parseBYTE(sittingStatus);
	_parser.parseMsgBody(clientMsg_txtEx);
}

const char *TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("sittingStatus", sittingStatus);
	_jsonstr.compose("m", clientMsg_txtEx);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	_jparser.parseByNameThrow("sittingStatus", sittingStatus);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_FORCE_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	BYTE sittingStatus; _jparser.validateByNameThrow("sittingStatus", sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_FORCE_SITOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_FORCE_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	BYTE sittingStatus; _parser.parseBYTE(sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_ADVANCED_BET
//=================================================================

TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::Protocol_MSG_TABLE_ADVANCED_BET()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::Protocol_MSG_TABLE_ADVANCED_BET(Protocol_MSG_TABLE_ADVANCED_BET&& _o)
	: betOptions(std::move(_o.betOptions))
{
}

TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET& TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::operator=(Protocol_MSG_TABLE_ADVANCED_BET&& _o)
{
	if(this != &_o)
	{
		betOptions = std::move(_o.betOptions);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::clear()
{
	betOptions.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::equals(const Protocol_MSG_TABLE_ADVANCED_BET& _o) const
{
	return betOptions.equals(_o.betOptions);
}

bool TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_ADVANCED_BET != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_ADVANCED_BET*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_ADVANCED_BET).append(")");
	_buf.append(',');
	_buf.append("betOptions=");
	betOptions.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_ADVANCED_BET).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	betOptions.toXmlString("betOptions", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("betOptions"))
			{
				if(!Atf::AtfTempl< Atf::AtfVector0< P_PlayerBetOption, 1 > >::FromXmlString(_value, betOptions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	betOptions.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::parseMsg(CommMsgParser& _parser)
{
	betOptions.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("betOptions", betOptions);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("betOptions", betOptions);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADVANCED_BET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< P_PlayerBetOption > betOptions; _jparser.validateByNameThrow("betOptions", betOptions);
	AtfValidator::validateInt(_descr, "betOptions", betOptions.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADVANCED_BET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADVANCED_BET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szBetOptions = Atf::AtfVector0< P_PlayerBetOption, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("betOptions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "betOptions", szBetOptions, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_STATISTIC
//=================================================================

TableClient::player::Protocol_MSG_TABLE_STATISTIC::Protocol_MSG_TABLE_STATISTIC()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_STATISTIC::clear()
{
	statistic = 0;
	earnedVPP = 0;
	mileStoneAward = 0;
	handId = 0;
	vppThisHand = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_STATISTIC::equals(const Protocol_MSG_TABLE_STATISTIC& _o) const
{
	return statistic == _o.statistic &&
		earnedVPP == _o.earnedVPP &&
		mileStoneAward == _o.mileStoneAward &&
		handId == _o.handId &&
		vppThisHand == _o.vppThisHand;
}

bool TableClient::player::Protocol_MSG_TABLE_STATISTIC::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_STATISTIC != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_STATISTIC*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_STATISTIC::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_STATISTIC).append(")");
	_buf.append(',');
	_buf.append("statistic=");
	_buf.appendUint(statistic);
	_buf.append(',');
	_buf.append("earnedVPP=");
	_buf.appendUint(earnedVPP);
	_buf.append(',');
	_buf.append("mileStoneAward=");
	_buf.appendUint(mileStoneAward);
	_buf.append(',');
	_buf.append("hI=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("vppThisHand=");
	_buf.appendUint(vppThisHand);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_STATISTIC::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_STATISTIC::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_STATISTIC).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("statistic", statistic, _buf);
	Atf::XmlElement::encodeAsXmlElement("earnedVPP", earnedVPP, _buf);
	Atf::XmlElement::encodeAsXmlElement("mileStoneAward", mileStoneAward, _buf);
	Atf::XmlElement::encodeAsXmlElement("hI", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("vppThisHand", vppThisHand, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_STATISTIC::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("statistic"))
			{
				statistic = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("earnedVPP"))
			{
				earnedVPP = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mileStoneAward"))
			{
				mileStoneAward = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hI") || _element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vppThisHand"))
			{
				vppThisHand = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_STATISTIC::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(statistic);
	_msg.composeUINT32(earnedVPP);
	_msg.composeUINT32(mileStoneAward);
	_msg.composeUINT64(handId);
	_msg.composeUINT32(vppThisHand);
}

void TableClient::player::Protocol_MSG_TABLE_STATISTIC::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(statistic);
	_parser.parseUINT32(earnedVPP);
	_parser.parseUINT32(mileStoneAward);
	_parser.parseUINT64(handId);
	_parser.parseUINT32(vppThisHand);
}

const char *TableClient::player::Protocol_MSG_TABLE_STATISTIC::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("statistic", statistic);
	_jsonstr.compose("earnedVPP", earnedVPP);
	_jsonstr.compose("mileStoneAward", mileStoneAward);
	_jsonstr.compose("hI", handId);
	_jsonstr.compose("vppThisHand", vppThisHand);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_STATISTIC::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("statistic", statistic);
	_jparser.parseByNameThrow("earnedVPP", earnedVPP);
	_jparser.parseByNameThrow("mileStoneAward", mileStoneAward);
	if(!_jparser.parseByName("hI", handId)) _jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("vppThisHand", vppThisHand);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_STATISTIC::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_STATISTIC";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 statistic; _jparser.validateByNameThrow("statistic", statistic);
	AtfValidator::validateInt(_descr, "statistic", statistic, _checker, __FILE__, __LINE__);
	UINT32 earnedVPP; _jparser.validateByNameThrow("earnedVPP", earnedVPP);
	AtfValidator::validateInt(_descr, "earnedVPP", earnedVPP, _checker, __FILE__, __LINE__);
	UINT32 mileStoneAward; _jparser.validateByNameThrow("mileStoneAward", mileStoneAward);
	AtfValidator::validateInt(_descr, "mileStoneAward", mileStoneAward, _checker, __FILE__, __LINE__);
	UINT64 handId; if(!_jparser.validateByName("hI", handId)) _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 vppThisHand; _jparser.validateByNameThrow("vppThisHand", vppThisHand);
	AtfValidator::validateInt(_descr, "vppThisHand", vppThisHand, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_STATISTIC::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_STATISTIC";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 statistic; _parser.parseUINT32(statistic);
	AtfValidator::validateInt(_descr, "statistic", statistic, _checker, __FILE__, __LINE__);
	UINT32 earnedVPP; _parser.parseUINT32(earnedVPP);
	AtfValidator::validateInt(_descr, "earnedVPP", earnedVPP, _checker, __FILE__, __LINE__);
	UINT32 mileStoneAward; _parser.parseUINT32(mileStoneAward);
	AtfValidator::validateInt(_descr, "mileStoneAward", mileStoneAward, _checker, __FILE__, __LINE__);
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 vppThisHand; _parser.parseUINT32(vppThisHand);
	AtfValidator::validateInt(_descr, "vppThisHand", vppThisHand, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_HAND_RANK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_HAND_RANK::Protocol_MSG_TABLE_HAND_RANK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_HAND_RANK::Protocol_MSG_TABLE_HAND_RANK(Protocol_MSG_TABLE_HAND_RANK&& _o)
	: strHi(std::move(_o.strHi))
	, strLo(std::move(_o.strLo))
	, bestHigh(std::move(_o.bestHigh))
	, bestLow(std::move(_o.bestLow))
	, strHi2(std::move(_o.strHi2))
	, bestHigh2(std::move(_o.bestHigh2))
	, cardsHigh(std::move(_o.cardsHigh))
	, cardsLow(std::move(_o.cardsLow))
	, cardsHigh2(std::move(_o.cardsHigh2))
	, strLo2(std::move(_o.strLo2))
	, bestLow2(std::move(_o.bestLow2))
	, cardsLow2(std::move(_o.cardsLow2))
{
}

TableClient::player::Protocol_MSG_TABLE_HAND_RANK& TableClient::player::Protocol_MSG_TABLE_HAND_RANK::operator=(Protocol_MSG_TABLE_HAND_RANK&& _o)
{
	if(this != &_o)
	{
		strHi = std::move(_o.strHi);
		strLo = std::move(_o.strLo);
		bestHigh = std::move(_o.bestHigh);
		bestLow = std::move(_o.bestLow);
		strHi2 = std::move(_o.strHi2);
		bestHigh2 = std::move(_o.bestHigh2);
		cardsHigh = std::move(_o.cardsHigh);
		cardsLow = std::move(_o.cardsLow);
		cardsHigh2 = std::move(_o.cardsHigh2);
		strLo2 = std::move(_o.strLo2);
		bestLow2 = std::move(_o.bestLow2);
		cardsLow2 = std::move(_o.cardsLow2);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_HAND_RANK::clear()
{
	strHi.clear();
	strLo.clear();
	bestHigh = 0;
	bestLow = 0;
	strHi2.clear();
	bestHigh2 = 0;
	cardsHigh.clear();
	cardsLow.clear();
	cardsHigh2.clear();
	strLo2.clear();
	bestLow2 = 0;
	cardsLow2.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_HAND_RANK::equals(const Protocol_MSG_TABLE_HAND_RANK& _o) const
{
	return Atf::atfPStringEquals(strHi, _o.strHi) &&
		Atf::atfPStringEquals(strLo, _o.strLo) &&
		bestHigh == _o.bestHigh &&
		bestLow == _o.bestLow &&
		Atf::atfPStringEquals(strHi2, _o.strHi2) &&
		bestHigh2 == _o.bestHigh2 &&
		Atf::atfPStringEquals(strLo2, _o.strLo2) &&
		bestLow2 == _o.bestLow2;
}

bool TableClient::player::Protocol_MSG_TABLE_HAND_RANK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_HAND_RANK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_HAND_RANK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_HAND_RANK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_HAND_RANK).append(")");
	_buf.append(',');
	_buf.append("strHi=");
	_buf.append(strHi);
	_buf.append(',');
	_buf.append("strLo=");
	_buf.append(strLo);
	_buf.append(',');
	_buf.append("bestHigh=");
	_buf.appendUint(bestHigh);
	_buf.append(',');
	_buf.append("bestLow=");
	_buf.appendUint(bestLow);
	_buf.append(',');
	_buf.append("strHi2=");
	_buf.append(strHi2);
	_buf.append(',');
	_buf.append("bestHigh2=");
	_buf.appendUint(bestHigh2);
	_buf.append(',');
	_buf.append("cardsHigh=");
	cardsHigh.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cardsLow=");
	cardsLow.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cardsHigh2=");
	cardsHigh2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("strLo2=");
	_buf.append(strLo2);
	_buf.append(',');
	_buf.append("bestLow2=");
	_buf.appendUint(bestLow2);
	_buf.append(',');
	_buf.append("cardsLow2=");
	cardsLow2.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_HAND_RANK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_HAND_RANK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_HAND_RANK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("strHi", strHi, _buf);
	Atf::XmlElement::encodeAsXmlElement("strLo", strLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestHigh", bestHigh, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestLow", bestLow, _buf);
	Atf::XmlElement::encodeAsXmlElement("strHi2", strHi2, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestHigh2", bestHigh2, _buf);
	cardsHigh.toXmlString("cardsHigh", _buf);
	cardsLow.toXmlString("cardsLow", _buf);
	cardsHigh2.toXmlString("cardsHigh2", _buf);
	Atf::XmlElement::encodeAsXmlElement("strLo2", strLo2, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestLow2", bestLow2, _buf);
	cardsLow2.toXmlString("cardsLow2", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_HAND_RANK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("strHi"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, strHi)) return false;
			}
			else if (_element.equals("strLo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, strLo)) return false;
			}
			else if (_element.equals("bestHigh"))
			{
				bestHigh = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bestLow"))
			{
				bestLow = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("strHi2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, strHi2)) return false;
			}
			else if (_element.equals("bestHigh2"))
			{
				bestHigh2 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardsHigh"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cardsHigh)) return false;
			}
			else if (_element.equals("cardsLow"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cardsLow)) return false;
			}
			else if (_element.equals("cardsHigh2"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cardsHigh2)) return false;
			}
			else if (_element.equals("strLo2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, strLo2)) return false;
			}
			else if (_element.equals("bestLow2"))
			{
				bestLow2 = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardsLow2"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cardsLow2)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_HAND_RANK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(strHi);
	_msg.composeString(strLo);
	_msg.composeBYTE(bestHigh);
	_msg.composeBYTE(bestLow);
	_msg.composeString(strHi2);
	_msg.composeBYTE(bestHigh2);
	cardsHigh.composeMsg(_msg, _ignoreJSON);
	cardsLow.composeMsg(_msg, _ignoreJSON);
	cardsHigh2.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(strLo2);
	_msg.composeBYTE(bestLow2);
	cardsLow2.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_HAND_RANK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(strHi);
	_parser.parseStringP(strLo);
	_parser.parseBYTE(bestHigh);
	_parser.parseBYTE(bestLow);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(strHi2);
	_parser.parseBYTE(bestHigh2);
	if(_parser.parseEnded()) return;
	cardsHigh.parseMsg(_parser);
	cardsLow.parseMsg(_parser);
	cardsHigh2.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(strLo2);
	_parser.parseBYTE(bestLow2);
	cardsLow2.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_HAND_RANK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("strHi", strHi);
	_jsonstr.compose("strLo", strLo);
	_jsonstr.compose("bestHigh", bestHigh);
	_jsonstr.compose("bestLow", bestLow);
	_jsonstr.compose("strHi2", strHi2);
	_jsonstr.compose("bestHigh2", bestHigh2);
	_jsonstr.compose("cardsHigh", cardsHigh);
	_jsonstr.compose("cardsLow", cardsLow);
	_jsonstr.compose("cardsHigh2", cardsHigh2);
	_jsonstr.compose("strLo2", strLo2);
	_jsonstr.compose("bestLow2", bestLow2);
	_jsonstr.compose("cardsLow2", cardsLow2);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_HAND_RANK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("strHi", strHi);
	_jparser.parseByNameThrow("strLo", strLo);
	_jparser.parseByNameThrow("bestHigh", bestHigh);
	_jparser.parseByNameThrow("bestLow", bestLow);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("strHi2", strHi2);
	_jparser.parseByNameThrow("bestHigh2", bestHigh2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cardsHigh", cardsHigh);
	_jparser.parseByNameThrow("cardsLow", cardsLow);
	_jparser.parseByNameThrow("cardsHigh2", cardsHigh2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("strLo2", strLo2);
	_jparser.parseByNameThrow("bestLow2", bestLow2);
	_jparser.parseByNameThrow("cardsLow2", cardsLow2);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_HAND_RANK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_HAND_RANK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString strHi; _jparser.validateByNameThrow("strHi", strHi);
	AtfValidator::validateInt(_descr, "strHi", strHi.length(), _checker, __FILE__, __LINE__);
	PString strLo; _jparser.validateByNameThrow("strLo", strLo);
	AtfValidator::validateInt(_descr, "strLo", strLo.length(), _checker, __FILE__, __LINE__);
	BYTE bestHigh; _jparser.validateByNameThrow("bestHigh", bestHigh);
	AtfValidator::validateInt(_descr, "bestHigh", bestHigh, _checker, __FILE__, __LINE__);
	BYTE bestLow; _jparser.validateByNameThrow("bestLow", bestLow);
	AtfValidator::validateInt(_descr, "bestLow", bestLow, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString strHi2; _jparser.validateByNameThrow("strHi2", strHi2);
	AtfValidator::validateInt(_descr, "strHi2", strHi2.length(), _checker, __FILE__, __LINE__);
	BYTE bestHigh2; _jparser.validateByNameThrow("bestHigh2", bestHigh2);
	AtfValidator::validateInt(_descr, "bestHigh2", bestHigh2, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< TableCommon::P_Card > cardsHigh; _jparser.validateByNameThrow("cardsHigh", cardsHigh);
	AtfValidator::validateInt(_descr, "cardsHigh", cardsHigh.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > cardsLow; _jparser.validateByNameThrow("cardsLow", cardsLow);
	AtfValidator::validateInt(_descr, "cardsLow", cardsLow.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > cardsHigh2; _jparser.validateByNameThrow("cardsHigh2", cardsHigh2);
	AtfValidator::validateInt(_descr, "cardsHigh2", cardsHigh2.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString strLo2; _jparser.validateByNameThrow("strLo2", strLo2);
	AtfValidator::validateInt(_descr, "strLo2", strLo2.length(), _checker, __FILE__, __LINE__);
	BYTE bestLow2; _jparser.validateByNameThrow("bestLow2", bestLow2);
	AtfValidator::validateInt(_descr, "bestLow2", bestLow2, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > cardsLow2; _jparser.validateByNameThrow("cardsLow2", cardsLow2);
	AtfValidator::validateInt(_descr, "cardsLow2", cardsLow2.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_HAND_RANK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_HAND_RANK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "strHi"); size_t szStrHi = strlen(_dummy);
	AtfValidator::validateInt(_descr, "strHi", szStrHi, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "strLo"); size_t szStrLo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "strLo", szStrLo, _checker, __FILE__, __LINE__);
	BYTE bestHigh; _parser.parseBYTE(bestHigh);
	AtfValidator::validateInt(_descr, "bestHigh", bestHigh, _checker, __FILE__, __LINE__);
	BYTE bestLow; _parser.parseBYTE(bestLow);
	AtfValidator::validateInt(_descr, "bestLow", bestLow, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "strHi2"); size_t szStrHi2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "strHi2", szStrHi2, _checker, __FILE__, __LINE__);
	BYTE bestHigh2; _parser.parseBYTE(bestHigh2);
	AtfValidator::validateInt(_descr, "bestHigh2", bestHigh2, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	int szCardsHigh = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardsHigh"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cardsHigh", szCardsHigh, _checker, __FILE__, __LINE__);
	int szCardsLow = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardsLow"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cardsLow", szCardsLow, _checker, __FILE__, __LINE__);
	int szCardsHigh2 = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardsHigh2"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cardsHigh2", szCardsHigh2, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "strLo2"); size_t szStrLo2 = strlen(_dummy);
	AtfValidator::validateInt(_descr, "strLo2", szStrLo2, _checker, __FILE__, __LINE__);
	BYTE bestLow2; _parser.parseBYTE(bestLow2);
	AtfValidator::validateInt(_descr, "bestLow2", bestLow2, _checker, __FILE__, __LINE__);
	int szCardsLow2 = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardsLow2"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cardsLow2", szCardsLow2, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_ADDCHIPS
//=================================================================

TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::Protocol_MSG_TABLE_ADDCHIPS()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::clear()
{
	chips = 0;
	realMoneyChips = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::equals(const Protocol_MSG_TABLE_ADDCHIPS& _o) const
{
	return chips == _o.chips &&
		realMoneyChips == _o.realMoneyChips;
}

bool TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_ADDCHIPS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_ADDCHIPS*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_ADDCHIPS).append(")");
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("realMoneyChips=");
	_buf.appendInt(realMoneyChips);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_ADDCHIPS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("realMoneyChips", realMoneyChips, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("chips"))
			{
				chips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("realMoneyChips"))
			{
				realMoneyChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(chips);
	_msg.composeINT32(realMoneyChips);
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(chips);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(realMoneyChips);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("realMoneyChips", realMoneyChips);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chips", chips);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("realMoneyChips", realMoneyChips);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDCHIPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateIntRange(_descr, "chips", chips, 0, 2000000000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 realMoneyChips; _jparser.validateByNameThrow("realMoneyChips", realMoneyChips);
	AtfValidator::validateIntRange(_descr, "realMoneyChips", realMoneyChips, 0, 2000000000, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDCHIPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 chips; _parser.parseINT32(chips);
	AtfValidator::validateIntRange(_descr, "chips", chips, 0, 2000000000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 realMoneyChips; _parser.parseINT32(realMoneyChips);
	AtfValidator::validateIntRange(_descr, "realMoneyChips", realMoneyChips, 0, 2000000000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_ADDCHIPS_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::Protocol_MSG_TABLE_ADDCHIPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::Protocol_MSG_TABLE_ADDCHIPS_REPLY(Protocol_MSG_TABLE_ADDCHIPS_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, italyReservedChips(std::move(_o.italyReservedChips))
{
}

TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY& TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::operator=(Protocol_MSG_TABLE_ADDCHIPS_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		italyReservedChips = std::move(_o.italyReservedChips);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	clientMsg_txtEx.clear();
	italyReservedChips = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::equals(const Protocol_MSG_TABLE_ADDCHIPS_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		italyReservedChips == _o.italyReservedChips;
}

bool TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_ADDCHIPS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_ADDCHIPS_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_ADDCHIPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(italyReservedChips);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_ADDCHIPS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("reserved", italyReservedChips, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("reserved") || _element.equals("italyReservedChips"))
			{
				italyReservedChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	_msg.composeMsgBody(clientMsg_txtEx);
	_msg.composeUINT32(italyReservedChips);
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	_parser.parseMsgBody(clientMsg_txtEx);
	_parser.parseUINT32(italyReservedChips);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("m", clientMsg_txtEx);
	_jsonstr.compose("reserved", italyReservedChips);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	if(!_jparser.parseByName("reserved", italyReservedChips)) _jparser.parseByNameThrow("italyReservedChips", italyReservedChips);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDCHIPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	UINT32 italyReservedChips; if(!_jparser.validateByName("reserved", italyReservedChips)) _jparser.validateByNameThrow("italyReservedChips", italyReservedChips);
	AtfValidator::validateInt(_descr, "italyReservedChips", italyReservedChips, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDCHIPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	UINT32 italyReservedChips; _parser.parseUINT32(italyReservedChips);
	AtfValidator::validateInt(_descr, "italyReservedChips", italyReservedChips, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_REBUYCHIPS
//=================================================================

TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::Protocol_MSG_TABLE_REBUYCHIPS()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::clear()
{
	numRebuys = 1;
}

bool TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::equals(const Protocol_MSG_TABLE_REBUYCHIPS& _o) const
{
	return numRebuys == _o.numRebuys;
}

bool TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_REBUYCHIPS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_REBUYCHIPS*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_REBUYCHIPS).append(")");
	_buf.append(',');
	_buf.append("numRebuys=");
	_buf.appendInt(numRebuys);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_REBUYCHIPS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("numRebuys", numRebuys, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("numRebuys"))
			{
				numRebuys = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(numRebuys);
}

void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseINT16(numRebuys);
}

const char *TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numRebuys", numRebuys);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("numRebuys", numRebuys);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REBUYCHIPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	INT16 numRebuys; _jparser.validateByNameThrow("numRebuys", numRebuys);
	AtfValidator::validateIntRange(_descr, "numRebuys", numRebuys, 0, 10, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REBUYCHIPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	INT16 numRebuys; _parser.parseINT16(numRebuys);
	AtfValidator::validateIntRange(_descr, "numRebuys", numRebuys, 0, 10, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_REBUYCHIPS_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::Protocol_MSG_TABLE_REBUYCHIPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::Protocol_MSG_TABLE_REBUYCHIPS_REPLY(Protocol_MSG_TABLE_REBUYCHIPS_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, chips(std::move(_o.chips))
	, money(std::move(_o.money))
	, pChips(std::move(_o.pChips))
	, fppTaken(std::move(_o.fppTaken))
	, tChips(std::move(_o.tChips))
	, wChips(std::move(_o.wChips))
	, infoType(std::move(_o.infoType))
	, info(std::move(_o.info))
	, pChips64(std::move(_o.pChips64))
	, rebuysDone(std::move(_o.rebuysDone))
	, addonsDone(std::move(_o.addonsDone))
	, rebuysLeft(std::move(_o.rebuysLeft))
	, finalFlightTournId(std::move(_o.finalFlightTournId))
	, moneyAfter(std::move(_o.moneyAfter))
	, realMoney(std::move(_o.realMoney))
	, realTChips(std::move(_o.realTChips))
	, tChipsAfter(std::move(_o.tChipsAfter))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
{
}

TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY& TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::operator=(Protocol_MSG_TABLE_REBUYCHIPS_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		chips = std::move(_o.chips);
		money = std::move(_o.money);
		pChips = std::move(_o.pChips);
		fppTaken = std::move(_o.fppTaken);
		tChips = std::move(_o.tChips);
		wChips = std::move(_o.wChips);
		infoType = std::move(_o.infoType);
		info = std::move(_o.info);
		pChips64 = std::move(_o.pChips64);
		rebuysDone = std::move(_o.rebuysDone);
		addonsDone = std::move(_o.addonsDone);
		rebuysLeft = std::move(_o.rebuysLeft);
		finalFlightTournId = std::move(_o.finalFlightTournId);
		moneyAfter = std::move(_o.moneyAfter);
		realMoney = std::move(_o.realMoney);
		realTChips = std::move(_o.realTChips);
		tChipsAfter = std::move(_o.tChipsAfter);
		tournSpendLimit = std::move(_o.tournSpendLimit);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	clientMsg_txtEx.clear();
	chips = 0;
	money = 0;
	pChips = 0;
	fppTaken = 0;
	tChips = 0;
	wChips = 0;
	infoType = 0;
	info.clear();
	pChips64 = 0;
	rebuysDone = 0;
	addonsDone = 0;
	rebuysLeft = 0;
	finalFlightTournId = 0;
	moneyAfter = 0;
	realMoney = 0;
	realTChips = 0;
	tChipsAfter = 0;
	tournSpendLimit.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::equals(const Protocol_MSG_TABLE_REBUYCHIPS_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		chips == _o.chips &&
		money == _o.money &&
		pChips == _o.pChips &&
		fppTaken == _o.fppTaken &&
		tChips == _o.tChips &&
		wChips == _o.wChips &&
		infoType == _o.infoType &&
		Atf::atfPStringEquals(info, _o.info) &&
		pChips64 == _o.pChips64 &&
		rebuysDone == _o.rebuysDone &&
		addonsDone == _o.addonsDone &&
		rebuysLeft == _o.rebuysLeft &&
		finalFlightTournId == _o.finalFlightTournId &&
		moneyAfter == _o.moneyAfter &&
		realMoney == _o.realMoney &&
		realTChips == _o.realTChips &&
		tChipsAfter == _o.tChipsAfter &&
		tournSpendLimit.equals(_o.tournSpendLimit);
}

bool TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_REBUYCHIPS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_REBUYCHIPS_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_REBUYCHIPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	if(errcode)
	{
		_buf.append(',');
		_buf.append("errstr=");
		_buf.append(errstr);
		_buf.append(',');
		_buf.append("m=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	}
	else
	{
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("money=");
		_buf.appendUint(money);
		_buf.append(',');
		_buf.append("pChips=");
		_buf.appendUint(pChips);
		_buf.append(',');
		_buf.append("fppTaken=");
		_buf.appendUint(fppTaken);
		_buf.append(',');
		_buf.append("tChips=");
		_buf.appendUint(tChips);
		_buf.append(',');
		_buf.append("wChips=");
		_buf.appendUint(wChips);
		_buf.append(',');
		_buf.append("infoType=");
		_buf.appendUint(infoType);
		_buf.append(',');
		_buf.append("info=");
		_buf.append(info);
		_buf.append(',');
		_buf.append("pChips64=");
		_buf.appendUint64(pChips64);
		_buf.append(',');
		_buf.append("rebuysDone=");
		_buf.appendUint(rebuysDone);
		_buf.append(',');
		_buf.append("addonsDone=");
		_buf.appendUint(addonsDone);
		_buf.append(',');
		_buf.append("rebuysLeft=");
		_buf.appendInt(rebuysLeft);
		_buf.append(',');
		_buf.append("finalFlightTournId=");
		_buf.appendUint(finalFlightTournId);
		_buf.append(',');
		_buf.append("moneyAfter=");
		_buf.appendInt(moneyAfter);
		_buf.append(',');
		_buf.append("realMoney=");
		_buf.appendInt(realMoney);
		_buf.append(',');
		_buf.append("realTChips=");
		_buf.appendInt(realTChips);
		_buf.append(',');
		_buf.append("tChipsAfter=");
		_buf.appendInt(tChipsAfter);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_REBUYCHIPS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	if(errcode)
	{
		Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
		Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
		Atf::XmlElement::encodeAsXmlElement("money", money, _buf);
		Atf::XmlElement::encodeAsXmlElement("pChips", pChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppTaken", fppTaken, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("wChips", wChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("infoType", infoType, _buf);
		Atf::XmlElement::encodeAsXmlElement("info", info, _buf);
		Atf::XmlElement::encodeAsXmlElement("pChips64", pChips64, _buf);
		Atf::XmlElement::encodeAsXmlElement("rebuysDone", rebuysDone, _buf);
		Atf::XmlElement::encodeAsXmlElement("addonsDone", addonsDone, _buf);
		Atf::XmlElement::encodeAsXmlElement("rebuysLeft", rebuysLeft, _buf);
		Atf::XmlElement::encodeAsXmlElement("finalFlightTournId", finalFlightTournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("moneyAfter", moneyAfter, _buf);
		Atf::XmlElement::encodeAsXmlElement("realMoney", realMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("realTChips", realTChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChipsAfter", tChipsAfter, _buf);
		tournSpendLimit.toXmlString("tournSpendLimit", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("money"))
			{
				money = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pChips"))
			{
				pChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppTaken"))
			{
				fppTaken = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tChips"))
			{
				tChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wChips"))
			{
				wChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("infoType"))
			{
				infoType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("info"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, info)) return false;
			}
			else if (_element.equals("pChips64"))
			{
				pChips64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuysDone"))
			{
				rebuysDone = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addonsDone"))
			{
				addonsDone = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuysLeft"))
			{
				rebuysLeft = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("finalFlightTournId"))
			{
				finalFlightTournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("moneyAfter"))
			{
				moneyAfter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("realMoney"))
			{
				realMoney = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("realTChips"))
			{
				realTChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tChipsAfter"))
			{
				tChipsAfter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournSpendLimit"))
			{
				if(!Atf::AtfTempl< TournCommon::TournSpendLimit >::FromXmlString(_value, tournSpendLimit)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	if(errcode)
	{
		_msg.composeString(errstr);
		_msg.composeMsgBody(clientMsg_txtEx);
	}
	else
	{
		_msg.composeUINT32(chips);
		_msg.composeUINT32(money);
		_msg.composeUINT32(pChips);
		_msg.composeUINT32(fppTaken);
		_msg.composeUINT32(tChips);
		_msg.composeUINT32(wChips);
		_msg.composeUINT32(infoType);
		_msg.composeString(info);
		_msg.composeUINT64(pChips64);
		_msg.composeUINT16(rebuysDone);
		_msg.composeUINT16(addonsDone);
		_msg.composeINT16(rebuysLeft);
		_msg.composeUINT32(finalFlightTournId);
		_msg.composeINT32(moneyAfter);
		_msg.composeINT32(realMoney);
		_msg.composeINT32(realTChips);
		_msg.composeINT32(tChipsAfter);
		tournSpendLimit.composeMsg(_msg, _ignoreJSON);
	}
}

void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	if(errcode)
	{
		_parser.parseStringP(errstr);
		_parser.parseMsgBody(clientMsg_txtEx);
	}
	else
	{
		_parser.parseUINT32(chips);
		_parser.parseUINT32(money);
		_parser.parseUINT32(pChips);
		_parser.parseUINT32(fppTaken);
		_parser.parseUINT32(tChips);
		_parser.parseUINT32(wChips);
		_parser.parseUINT32(infoType);
		_parser.parseStringP(info);
		_parser.parseUINT64(pChips64);
		_parser.parseUINT16(rebuysDone);
		_parser.parseUINT16(addonsDone);
		_parser.parseINT16(rebuysLeft);
		_parser.parseUINT32(finalFlightTournId);
		_parser.parseINT32(moneyAfter);
		_parser.parseINT32(realMoney);
		_parser.parseINT32(realTChips);
		_parser.parseINT32(tChipsAfter);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

const char *TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	if(errcode)
	{
		_jsonstr.compose("errstr", errstr);
		_jsonstr.compose("m", clientMsg_txtEx);
	}
	else
	{
		_jsonstr.compose("chips", chips);
		_jsonstr.compose("money", money);
		_jsonstr.compose("pChips", pChips);
		_jsonstr.compose("fppTaken", fppTaken);
		_jsonstr.compose("tChips", tChips);
		_jsonstr.compose("wChips", wChips);
		_jsonstr.compose("infoType", infoType);
		_jsonstr.compose("info", info);
		_jsonstr.compose("pChips64", pChips64);
		_jsonstr.compose("rebuysDone", rebuysDone);
		_jsonstr.compose("addonsDone", addonsDone);
		_jsonstr.compose("rebuysLeft", rebuysLeft);
		_jsonstr.compose("finalFlightTournId", finalFlightTournId);
		_jsonstr.compose("moneyAfter", moneyAfter);
		_jsonstr.compose("realMoney", realMoney);
		_jsonstr.compose("realTChips", realTChips);
		_jsonstr.compose("tChipsAfter", tChipsAfter);
		_jsonstr.compose("tournSpendLimit", tournSpendLimit);
	}
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	if(errcode)
	{
		_jparser.parseByNameThrow("errstr", errstr);
		if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	}
	else
	{
		_jparser.parseByNameThrow("chips", chips);
		_jparser.parseByNameThrow("money", money);
		_jparser.parseByNameThrow("pChips", pChips);
		_jparser.parseByNameThrow("fppTaken", fppTaken);
		_jparser.parseByNameThrow("tChips", tChips);
		_jparser.parseByNameThrow("wChips", wChips);
		_jparser.parseByNameThrow("infoType", infoType);
		_jparser.parseByNameThrow("info", info);
		_jparser.parseByNameThrow("pChips64", pChips64);
		_jparser.parseByNameThrow("rebuysDone", rebuysDone);
		_jparser.parseByNameThrow("addonsDone", addonsDone);
		_jparser.parseByNameThrow("rebuysLeft", rebuysLeft);
		_jparser.parseByNameThrow("finalFlightTournId", finalFlightTournId);
		_jparser.parseByNameThrow("moneyAfter", moneyAfter);
		_jparser.parseByNameThrow("realMoney", realMoney);
		_jparser.parseByNameThrow("realTChips", realTChips);
		_jparser.parseByNameThrow("tChipsAfter", tChipsAfter);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REBUYCHIPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode = 0;
	_jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if(errcode)
	{
		PString errstr; _jparser.validateByNameThrow("errstr", errstr);
		AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
		AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chips; _jparser.validateByNameThrow("chips", chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 money; _jparser.validateByNameThrow("money", money);
		AtfValidator::validateInt(_descr, "money", money, _checker, __FILE__, __LINE__);
		UINT32 pChips; _jparser.validateByNameThrow("pChips", pChips);
		AtfValidator::validateInt(_descr, "pChips", pChips, _checker, __FILE__, __LINE__);
		UINT32 fppTaken; _jparser.validateByNameThrow("fppTaken", fppTaken);
		AtfValidator::validateInt(_descr, "fppTaken", fppTaken, _checker, __FILE__, __LINE__);
		UINT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _jparser.validateByNameThrow("wChips", wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		UINT32 infoType; _jparser.validateByNameThrow("infoType", infoType);
		AtfValidator::validateInt(_descr, "infoType", infoType, _checker, __FILE__, __LINE__);
		PString info; _jparser.validateByNameThrow("info", info);
		AtfValidator::validateInt(_descr, "info", info.length(), _checker, __FILE__, __LINE__);
		UINT64 pChips64; _jparser.validateByNameThrow("pChips64", pChips64);
		AtfValidator::validateUint(_descr, "pChips64", pChips64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _jparser.validateByNameThrow("rebuysDone", rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _jparser.validateByNameThrow("addonsDone", addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysLeft; _jparser.validateByNameThrow("rebuysLeft", rebuysLeft);
		AtfValidator::validateInt(_descr, "rebuysLeft", rebuysLeft, _checker, __FILE__, __LINE__);
		UINT32 finalFlightTournId; _jparser.validateByNameThrow("finalFlightTournId", finalFlightTournId);
		AtfValidator::validateInt(_descr, "finalFlightTournId", finalFlightTournId, _checker, __FILE__, __LINE__);
		INT32 moneyAfter; _jparser.validateByNameThrow("moneyAfter", moneyAfter);
		AtfValidator::validateInt(_descr, "moneyAfter", moneyAfter, _checker, __FILE__, __LINE__);
		INT32 realMoney; _jparser.validateByNameThrow("realMoney", realMoney);
		AtfValidator::validateInt(_descr, "realMoney", realMoney, _checker, __FILE__, __LINE__);
		INT32 realTChips; _jparser.validateByNameThrow("realTChips", realTChips);
		AtfValidator::validateInt(_descr, "realTChips", realTChips, _checker, __FILE__, __LINE__);
		INT32 tChipsAfter; _jparser.validateByNameThrow("tChipsAfter", tChipsAfter);
		AtfValidator::validateInt(_descr, "tChipsAfter", tChipsAfter, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		TournCommon::TournSpendLimit tournSpendLimit; _jparser.validateByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REBUYCHIPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode = 0;
	_parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if(errcode)
	{
		_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
		size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
		AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 money; _parser.parseUINT32(money);
		AtfValidator::validateInt(_descr, "money", money, _checker, __FILE__, __LINE__);
		UINT32 pChips; _parser.parseUINT32(pChips);
		AtfValidator::validateInt(_descr, "pChips", pChips, _checker, __FILE__, __LINE__);
		UINT32 fppTaken; _parser.parseUINT32(fppTaken);
		AtfValidator::validateInt(_descr, "fppTaken", fppTaken, _checker, __FILE__, __LINE__);
		UINT32 tChips; _parser.parseUINT32(tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _parser.parseUINT32(wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		UINT32 infoType; _parser.parseUINT32(infoType);
		AtfValidator::validateInt(_descr, "infoType", infoType, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
		UINT64 pChips64; _parser.parseUINT64(pChips64);
		AtfValidator::validateUint(_descr, "pChips64", pChips64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _parser.parseUINT16(rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _parser.parseUINT16(addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysLeft; _parser.parseINT16(rebuysLeft);
		AtfValidator::validateInt(_descr, "rebuysLeft", rebuysLeft, _checker, __FILE__, __LINE__);
		UINT32 finalFlightTournId; _parser.parseUINT32(finalFlightTournId);
		AtfValidator::validateInt(_descr, "finalFlightTournId", finalFlightTournId, _checker, __FILE__, __LINE__);
		INT32 moneyAfter; _parser.parseINT32(moneyAfter);
		AtfValidator::validateInt(_descr, "moneyAfter", moneyAfter, _checker, __FILE__, __LINE__);
		INT32 realMoney; _parser.parseINT32(realMoney);
		AtfValidator::validateInt(_descr, "realMoney", realMoney, _checker, __FILE__, __LINE__);
		INT32 realTChips; _parser.parseINT32(realTChips);
		AtfValidator::validateInt(_descr, "realTChips", realTChips, _checker, __FILE__, __LINE__);
		INT32 tChipsAfter; _parser.parseINT32(tChipsAfter);
		AtfValidator::validateInt(_descr, "tChipsAfter", tChipsAfter, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		TournCommon::TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_ADDONCHIPS
//=================================================================

TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::Protocol_MSG_TABLE_ADDONCHIPS()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::clear()
{
}

bool TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::equals(const Protocol_MSG_TABLE_ADDONCHIPS& _o) const
{
	return true;
}

bool TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_ADDONCHIPS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_ADDONCHIPS*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_ADDONCHIPS).append(")");
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_ADDONCHIPS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::parseMsg(CommMsgParser& _parser)
{
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDONCHIPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDONCHIPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_ADDONCHIPS_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::Protocol_MSG_TABLE_ADDONCHIPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::Protocol_MSG_TABLE_ADDONCHIPS_REPLY(Protocol_MSG_TABLE_ADDONCHIPS_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, chips(std::move(_o.chips))
	, money(std::move(_o.money))
	, pChips(std::move(_o.pChips))
	, fppTaken(std::move(_o.fppTaken))
	, tChips(std::move(_o.tChips))
	, wChips(std::move(_o.wChips))
	, infoType(std::move(_o.infoType))
	, info(std::move(_o.info))
	, pChips64(std::move(_o.pChips64))
	, rebuysDone(std::move(_o.rebuysDone))
	, addonsDone(std::move(_o.addonsDone))
	, rebuysLeft(std::move(_o.rebuysLeft))
	, finalFlightTournId(std::move(_o.finalFlightTournId))
	, moneyAfter(std::move(_o.moneyAfter))
	, realMoney(std::move(_o.realMoney))
	, realTChips(std::move(_o.realTChips))
	, tChipsAfter(std::move(_o.tChipsAfter))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
{
}

TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY& TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::operator=(Protocol_MSG_TABLE_ADDONCHIPS_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		chips = std::move(_o.chips);
		money = std::move(_o.money);
		pChips = std::move(_o.pChips);
		fppTaken = std::move(_o.fppTaken);
		tChips = std::move(_o.tChips);
		wChips = std::move(_o.wChips);
		infoType = std::move(_o.infoType);
		info = std::move(_o.info);
		pChips64 = std::move(_o.pChips64);
		rebuysDone = std::move(_o.rebuysDone);
		addonsDone = std::move(_o.addonsDone);
		rebuysLeft = std::move(_o.rebuysLeft);
		finalFlightTournId = std::move(_o.finalFlightTournId);
		moneyAfter = std::move(_o.moneyAfter);
		realMoney = std::move(_o.realMoney);
		realTChips = std::move(_o.realTChips);
		tChipsAfter = std::move(_o.tChipsAfter);
		tournSpendLimit = std::move(_o.tournSpendLimit);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	clientMsg_txtEx.clear();
	chips = 0;
	money = 0;
	pChips = 0;
	fppTaken = 0;
	tChips = 0;
	wChips = 0;
	infoType = 0;
	info.clear();
	pChips64 = 0;
	rebuysDone = 0;
	addonsDone = 0;
	rebuysLeft = 0;
	finalFlightTournId = 0;
	moneyAfter = 0;
	realMoney = 0;
	realTChips = 0;
	tChipsAfter = 0;
	tournSpendLimit.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::equals(const Protocol_MSG_TABLE_ADDONCHIPS_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		chips == _o.chips &&
		money == _o.money &&
		pChips == _o.pChips &&
		fppTaken == _o.fppTaken &&
		tChips == _o.tChips &&
		wChips == _o.wChips &&
		infoType == _o.infoType &&
		Atf::atfPStringEquals(info, _o.info) &&
		pChips64 == _o.pChips64 &&
		rebuysDone == _o.rebuysDone &&
		addonsDone == _o.addonsDone &&
		rebuysLeft == _o.rebuysLeft &&
		finalFlightTournId == _o.finalFlightTournId &&
		moneyAfter == _o.moneyAfter &&
		realMoney == _o.realMoney &&
		realTChips == _o.realTChips &&
		tChipsAfter == _o.tChipsAfter &&
		tournSpendLimit.equals(_o.tournSpendLimit);
}

bool TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_ADDONCHIPS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_ADDONCHIPS_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_ADDONCHIPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	if(errcode)
	{
		_buf.append(',');
		_buf.append("errstr=");
		_buf.append(errstr);
		_buf.append(',');
		_buf.append("m=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	}
	else
	{
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("money=");
		_buf.appendUint(money);
		_buf.append(',');
		_buf.append("pChips=");
		_buf.appendUint(pChips);
		_buf.append(',');
		_buf.append("fppTaken=");
		_buf.appendUint(fppTaken);
		_buf.append(',');
		_buf.append("tChips=");
		_buf.appendUint(tChips);
		_buf.append(',');
		_buf.append("wChips=");
		_buf.appendUint(wChips);
		_buf.append(',');
		_buf.append("infoType=");
		_buf.appendUint(infoType);
		_buf.append(',');
		_buf.append("info=");
		_buf.append(info);
		_buf.append(',');
		_buf.append("pChips64=");
		_buf.appendUint64(pChips64);
		_buf.append(',');
		_buf.append("rebuysDone=");
		_buf.appendUint(rebuysDone);
		_buf.append(',');
		_buf.append("addonsDone=");
		_buf.appendUint(addonsDone);
		_buf.append(',');
		_buf.append("rebuysLeft=");
		_buf.appendInt(rebuysLeft);
		_buf.append(',');
		_buf.append("finalFlightTournId=");
		_buf.appendUint(finalFlightTournId);
		_buf.append(',');
		_buf.append("moneyAfter=");
		_buf.appendInt(moneyAfter);
		_buf.append(',');
		_buf.append("realMoney=");
		_buf.appendInt(realMoney);
		_buf.append(',');
		_buf.append("realTChips=");
		_buf.appendInt(realTChips);
		_buf.append(',');
		_buf.append("tChipsAfter=");
		_buf.appendInt(tChipsAfter);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_ADDONCHIPS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	if(errcode)
	{
		Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
		Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
		Atf::XmlElement::encodeAsXmlElement("money", money, _buf);
		Atf::XmlElement::encodeAsXmlElement("pChips", pChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("fppTaken", fppTaken, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("wChips", wChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("infoType", infoType, _buf);
		Atf::XmlElement::encodeAsXmlElement("info", info, _buf);
		Atf::XmlElement::encodeAsXmlElement("pChips64", pChips64, _buf);
		Atf::XmlElement::encodeAsXmlElement("rebuysDone", rebuysDone, _buf);
		Atf::XmlElement::encodeAsXmlElement("addonsDone", addonsDone, _buf);
		Atf::XmlElement::encodeAsXmlElement("rebuysLeft", rebuysLeft, _buf);
		Atf::XmlElement::encodeAsXmlElement("finalFlightTournId", finalFlightTournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("moneyAfter", moneyAfter, _buf);
		Atf::XmlElement::encodeAsXmlElement("realMoney", realMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("realTChips", realTChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChipsAfter", tChipsAfter, _buf);
		tournSpendLimit.toXmlString("tournSpendLimit", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("money"))
			{
				money = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pChips"))
			{
				pChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppTaken"))
			{
				fppTaken = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tChips"))
			{
				tChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wChips"))
			{
				wChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("infoType"))
			{
				infoType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("info"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, info)) return false;
			}
			else if (_element.equals("pChips64"))
			{
				pChips64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuysDone"))
			{
				rebuysDone = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addonsDone"))
			{
				addonsDone = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuysLeft"))
			{
				rebuysLeft = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("finalFlightTournId"))
			{
				finalFlightTournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("moneyAfter"))
			{
				moneyAfter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("realMoney"))
			{
				realMoney = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("realTChips"))
			{
				realTChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tChipsAfter"))
			{
				tChipsAfter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournSpendLimit"))
			{
				if(!Atf::AtfTempl< TournCommon::TournSpendLimit >::FromXmlString(_value, tournSpendLimit)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	if(errcode)
	{
		_msg.composeString(errstr);
		_msg.composeMsgBody(clientMsg_txtEx);
	}
	else
	{
		_msg.composeUINT32(chips);
		_msg.composeUINT32(money);
		_msg.composeUINT32(pChips);
		_msg.composeUINT32(fppTaken);
		_msg.composeUINT32(tChips);
		_msg.composeUINT32(wChips);
		_msg.composeUINT32(infoType);
		_msg.composeString(info);
		_msg.composeUINT64(pChips64);
		_msg.composeUINT16(rebuysDone);
		_msg.composeUINT16(addonsDone);
		_msg.composeINT16(rebuysLeft);
		_msg.composeUINT32(finalFlightTournId);
		_msg.composeINT32(moneyAfter);
		_msg.composeINT32(realMoney);
		_msg.composeINT32(realTChips);
		_msg.composeINT32(tChipsAfter);
		tournSpendLimit.composeMsg(_msg, _ignoreJSON);
	}
}

void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	if(errcode)
	{
		_parser.parseStringP(errstr);
		_parser.parseMsgBody(clientMsg_txtEx);
	}
	else
	{
		_parser.parseUINT32(chips);
		_parser.parseUINT32(money);
		_parser.parseUINT32(pChips);
		_parser.parseUINT32(fppTaken);
		_parser.parseUINT32(tChips);
		_parser.parseUINT32(wChips);
		_parser.parseUINT32(infoType);
		_parser.parseStringP(info);
		_parser.parseUINT64(pChips64);
		_parser.parseUINT16(rebuysDone);
		_parser.parseUINT16(addonsDone);
		_parser.parseINT16(rebuysLeft);
		_parser.parseUINT32(finalFlightTournId);
		_parser.parseINT32(moneyAfter);
		_parser.parseINT32(realMoney);
		_parser.parseINT32(realTChips);
		_parser.parseINT32(tChipsAfter);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

const char *TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	if(errcode)
	{
		_jsonstr.compose("errstr", errstr);
		_jsonstr.compose("m", clientMsg_txtEx);
	}
	else
	{
		_jsonstr.compose("chips", chips);
		_jsonstr.compose("money", money);
		_jsonstr.compose("pChips", pChips);
		_jsonstr.compose("fppTaken", fppTaken);
		_jsonstr.compose("tChips", tChips);
		_jsonstr.compose("wChips", wChips);
		_jsonstr.compose("infoType", infoType);
		_jsonstr.compose("info", info);
		_jsonstr.compose("pChips64", pChips64);
		_jsonstr.compose("rebuysDone", rebuysDone);
		_jsonstr.compose("addonsDone", addonsDone);
		_jsonstr.compose("rebuysLeft", rebuysLeft);
		_jsonstr.compose("finalFlightTournId", finalFlightTournId);
		_jsonstr.compose("moneyAfter", moneyAfter);
		_jsonstr.compose("realMoney", realMoney);
		_jsonstr.compose("realTChips", realTChips);
		_jsonstr.compose("tChipsAfter", tChipsAfter);
		_jsonstr.compose("tournSpendLimit", tournSpendLimit);
	}
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	if(errcode)
	{
		_jparser.parseByNameThrow("errstr", errstr);
		if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	}
	else
	{
		_jparser.parseByNameThrow("chips", chips);
		_jparser.parseByNameThrow("money", money);
		_jparser.parseByNameThrow("pChips", pChips);
		_jparser.parseByNameThrow("fppTaken", fppTaken);
		_jparser.parseByNameThrow("tChips", tChips);
		_jparser.parseByNameThrow("wChips", wChips);
		_jparser.parseByNameThrow("infoType", infoType);
		_jparser.parseByNameThrow("info", info);
		_jparser.parseByNameThrow("pChips64", pChips64);
		_jparser.parseByNameThrow("rebuysDone", rebuysDone);
		_jparser.parseByNameThrow("addonsDone", addonsDone);
		_jparser.parseByNameThrow("rebuysLeft", rebuysLeft);
		_jparser.parseByNameThrow("finalFlightTournId", finalFlightTournId);
		_jparser.parseByNameThrow("moneyAfter", moneyAfter);
		_jparser.parseByNameThrow("realMoney", realMoney);
		_jparser.parseByNameThrow("realTChips", realTChips);
		_jparser.parseByNameThrow("tChipsAfter", tChipsAfter);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDONCHIPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode = 0;
	_jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if(errcode)
	{
		PString errstr; _jparser.validateByNameThrow("errstr", errstr);
		AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
		AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chips; _jparser.validateByNameThrow("chips", chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 money; _jparser.validateByNameThrow("money", money);
		AtfValidator::validateInt(_descr, "money", money, _checker, __FILE__, __LINE__);
		UINT32 pChips; _jparser.validateByNameThrow("pChips", pChips);
		AtfValidator::validateInt(_descr, "pChips", pChips, _checker, __FILE__, __LINE__);
		UINT32 fppTaken; _jparser.validateByNameThrow("fppTaken", fppTaken);
		AtfValidator::validateInt(_descr, "fppTaken", fppTaken, _checker, __FILE__, __LINE__);
		UINT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _jparser.validateByNameThrow("wChips", wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		UINT32 infoType; _jparser.validateByNameThrow("infoType", infoType);
		AtfValidator::validateInt(_descr, "infoType", infoType, _checker, __FILE__, __LINE__);
		PString info; _jparser.validateByNameThrow("info", info);
		AtfValidator::validateInt(_descr, "info", info.length(), _checker, __FILE__, __LINE__);
		UINT64 pChips64; _jparser.validateByNameThrow("pChips64", pChips64);
		AtfValidator::validateUint(_descr, "pChips64", pChips64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _jparser.validateByNameThrow("rebuysDone", rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _jparser.validateByNameThrow("addonsDone", addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysLeft; _jparser.validateByNameThrow("rebuysLeft", rebuysLeft);
		AtfValidator::validateInt(_descr, "rebuysLeft", rebuysLeft, _checker, __FILE__, __LINE__);
		UINT32 finalFlightTournId; _jparser.validateByNameThrow("finalFlightTournId", finalFlightTournId);
		AtfValidator::validateInt(_descr, "finalFlightTournId", finalFlightTournId, _checker, __FILE__, __LINE__);
		INT32 moneyAfter; _jparser.validateByNameThrow("moneyAfter", moneyAfter);
		AtfValidator::validateInt(_descr, "moneyAfter", moneyAfter, _checker, __FILE__, __LINE__);
		INT32 realMoney; _jparser.validateByNameThrow("realMoney", realMoney);
		AtfValidator::validateInt(_descr, "realMoney", realMoney, _checker, __FILE__, __LINE__);
		INT32 realTChips; _jparser.validateByNameThrow("realTChips", realTChips);
		AtfValidator::validateInt(_descr, "realTChips", realTChips, _checker, __FILE__, __LINE__);
		INT32 tChipsAfter; _jparser.validateByNameThrow("tChipsAfter", tChipsAfter);
		AtfValidator::validateInt(_descr, "tChipsAfter", tChipsAfter, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		TournCommon::TournSpendLimit tournSpendLimit; _jparser.validateByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADDONCHIPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode = 0;
	_parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if(errcode)
	{
		_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
		size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
		AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		UINT32 money; _parser.parseUINT32(money);
		AtfValidator::validateInt(_descr, "money", money, _checker, __FILE__, __LINE__);
		UINT32 pChips; _parser.parseUINT32(pChips);
		AtfValidator::validateInt(_descr, "pChips", pChips, _checker, __FILE__, __LINE__);
		UINT32 fppTaken; _parser.parseUINT32(fppTaken);
		AtfValidator::validateInt(_descr, "fppTaken", fppTaken, _checker, __FILE__, __LINE__);
		UINT32 tChips; _parser.parseUINT32(tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _parser.parseUINT32(wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		UINT32 infoType; _parser.parseUINT32(infoType);
		AtfValidator::validateInt(_descr, "infoType", infoType, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "info"); size_t szInfo = strlen(_dummy);
		AtfValidator::validateInt(_descr, "info", szInfo, _checker, __FILE__, __LINE__);
		UINT64 pChips64; _parser.parseUINT64(pChips64);
		AtfValidator::validateUint(_descr, "pChips64", pChips64, _checker, __FILE__, __LINE__);
		UINT16 rebuysDone; _parser.parseUINT16(rebuysDone);
		AtfValidator::validateInt(_descr, "rebuysDone", rebuysDone, _checker, __FILE__, __LINE__);
		UINT16 addonsDone; _parser.parseUINT16(addonsDone);
		AtfValidator::validateInt(_descr, "addonsDone", addonsDone, _checker, __FILE__, __LINE__);
		INT16 rebuysLeft; _parser.parseINT16(rebuysLeft);
		AtfValidator::validateInt(_descr, "rebuysLeft", rebuysLeft, _checker, __FILE__, __LINE__);
		UINT32 finalFlightTournId; _parser.parseUINT32(finalFlightTournId);
		AtfValidator::validateInt(_descr, "finalFlightTournId", finalFlightTournId, _checker, __FILE__, __LINE__);
		INT32 moneyAfter; _parser.parseINT32(moneyAfter);
		AtfValidator::validateInt(_descr, "moneyAfter", moneyAfter, _checker, __FILE__, __LINE__);
		INT32 realMoney; _parser.parseINT32(realMoney);
		AtfValidator::validateInt(_descr, "realMoney", realMoney, _checker, __FILE__, __LINE__);
		INT32 realTChips; _parser.parseINT32(realTChips);
		AtfValidator::validateInt(_descr, "realTChips", realTChips, _checker, __FILE__, __LINE__);
		INT32 tChipsAfter; _parser.parseINT32(tChipsAfter);
		AtfValidator::validateInt(_descr, "tChipsAfter", tChipsAfter, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		TournCommon::TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CHAT2
//=================================================================

TableClient::player::Protocol_MSG_TABLE_CHAT2::Protocol_MSG_TABLE_CHAT2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_CHAT2::Protocol_MSG_TABLE_CHAT2(Protocol_MSG_TABLE_CHAT2&& _o)
	: chat(std::move(_o.chat))
{
}

TableClient::player::Protocol_MSG_TABLE_CHAT2& TableClient::player::Protocol_MSG_TABLE_CHAT2::operator=(Protocol_MSG_TABLE_CHAT2&& _o)
{
	if(this != &_o)
	{
		chat = std::move(_o.chat);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_CHAT2::clear()
{
	chat.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_CHAT2::equals(const Protocol_MSG_TABLE_CHAT2& _o) const
{
	return Atf::atfPStringEquals(chat, _o.chat);
}

bool TableClient::player::Protocol_MSG_TABLE_CHAT2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CHAT2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CHAT2*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_CHAT2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CHAT2).append(")");
	_buf.append(',');
	_buf.append("chat=");
	_buf.append(chat);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_CHAT2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_CHAT2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CHAT2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("chat", chat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_CHAT2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("chat"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chat)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_CHAT2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(chat);
}

void TableClient::player::Protocol_MSG_TABLE_CHAT2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(chat);
}

const char *TableClient::player::Protocol_MSG_TABLE_CHAT2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chat", chat);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_CHAT2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chat", chat);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CHAT2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString chat; _jparser.validateByNameThrow("chat", chat);
	AtfValidator::validateIntMax(_descr, "chat", chat.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CHAT2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "chat"); size_t szChat = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "chat", szChat, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CHAT2_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::Protocol_MSG_TABLE_CHAT2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::Protocol_MSG_TABLE_CHAT2_REPLY(Protocol_MSG_TABLE_CHAT2_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errMsgBody(std::move(_o.errMsgBody))
	, chatmsg(std::move(_o.chatmsg))
{
}

TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY& TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::operator=(Protocol_MSG_TABLE_CHAT2_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errMsgBody = std::move(_o.errMsgBody);
		chatmsg = std::move(_o.chatmsg);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::clear()
{
	errcode = 0;
	errMsgBody.clear();
	chatmsg.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::equals(const Protocol_MSG_TABLE_CHAT2_REPLY& _o) const
{
	return errcode == _o.errcode &&
		errMsgBody.equals(_o.errMsgBody) &&
		Atf::atfPStringEquals(chatmsg, _o.chatmsg);
}

bool TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CHAT2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CHAT2_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CHAT2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errMsgBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(errMsgBody, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("chatmsg=");
	_buf.append(chatmsg);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CHAT2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errMsgBody", errMsgBody, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatmsg", chatmsg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsgBody"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, errMsgBody)) return false;
			}
			else if (_element.equals("chatmsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chatmsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(errcode);
	_msg.composeMsgBody(errMsgBody);
	_msg.composeString(chatmsg);
}

void TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(errcode);
	_parser.parseMsgBody(errMsgBody);
	_parser.parseStringP(chatmsg);
}

const char *TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errMsgBody", errMsgBody);
	_jsonstr.compose("chatmsg", chatmsg);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errMsgBody", errMsgBody);
	_jparser.parseByNameThrow("chatmsg", chatmsg);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody errMsgBody; _jparser.validateByNameThrow("errMsgBody", errMsgBody);
	AtfValidator::validateInt(_descr, "errMsgBody", errMsgBody._size(), _checker, __FILE__, __LINE__);
	PString chatmsg; _jparser.validateByNameThrow("chatmsg", chatmsg);
	AtfValidator::validateInt(_descr, "chatmsg", chatmsg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CHAT2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHAT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 errcode; _parser.parseUINT16(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
	AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "chatmsg"); size_t szChatmsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "chatmsg", szChatmsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SITIN
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SITIN::Protocol_MSG_TABLE_SITIN()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SITIN::clear()
{
	flags = 0;
	flagsEx = 0;
	isPlayMoney = false;
}

bool TableClient::player::Protocol_MSG_TABLE_SITIN::equals(const Protocol_MSG_TABLE_SITIN& _o) const
{
	return flags == _o.flags &&
		flagsEx == _o.flagsEx &&
		isPlayMoney == _o.isPlayMoney;
}

bool TableClient::player::Protocol_MSG_TABLE_SITIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SITIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SITIN*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SITIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SITIN).append(")");
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flagsEx=");
	_buf.appendUint64(flagsEx);
	_buf.append(',');
	_buf.append("pm=");
	_buf.appendUint(isPlayMoney);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SITIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SITIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flagsEx", flagsEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("pm", isPlayMoney, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SITIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flagsEx"))
			{
				flagsEx = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pm") || _element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SITIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(flags);
	_msg.composeUINT64(flagsEx);
	_msg.composeBOOL(isPlayMoney);
}

void TableClient::player::Protocol_MSG_TABLE_SITIN::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(flags);
	_parser.parseUINT64(flagsEx);
	_parser.parseBOOL(isPlayMoney);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flagsEx", flagsEx);
	_jsonstr.compose("pm", isPlayMoney);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SITIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("flagsEx", flagsEx);
	if(!_jparser.parseByName("pm", isPlayMoney)) _jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flagsEx; _jparser.validateByNameThrow("flagsEx", flagsEx);
	AtfValidator::validateUint(_descr, "flagsEx", flagsEx, _checker, __FILE__, __LINE__);
	bool isPlayMoney; if(!_jparser.validateByName("pm", isPlayMoney)) _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flagsEx; _parser.parseUINT64(flagsEx);
	AtfValidator::validateUint(_descr, "flagsEx", flagsEx, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SITIN_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::Protocol_MSG_TABLE_SITIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::Protocol_MSG_TABLE_SITIN_REPLY(Protocol_MSG_TABLE_SITIN_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, sittingStatus(std::move(_o.sittingStatus))
	, waitingStatus(std::move(_o.waitingStatus))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
{
}

TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY& TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::operator=(Protocol_MSG_TABLE_SITIN_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		sittingStatus = std::move(_o.sittingStatus);
		waitingStatus = std::move(_o.waitingStatus);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	sittingStatus = 0;
	waitingStatus = 0;
	clientMsg_txtEx.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::equals(const Protocol_MSG_TABLE_SITIN_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		sittingStatus == _o.sittingStatus &&
		waitingStatus == _o.waitingStatus &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx);
}

bool TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SITIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SITIN_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SITIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("ss=");
	_buf.appendUint(sittingStatus);
	_buf.append(',');
	_buf.append("ws=");
	_buf.appendUint(waitingStatus);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SITIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("ss", sittingStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("ws", waitingStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("ss") || _element.equals("sittingStatus"))
			{
				sittingStatus = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ws") || _element.equals("waitingStatus"))
			{
				waitingStatus = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	_msg.composeBYTE(sittingStatus);
	_msg.composeUINT32(waitingStatus);
	_msg.composeMsgBody(clientMsg_txtEx);
}

void TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	_parser.parseBYTE(sittingStatus);
	_parser.parseUINT32(waitingStatus);
	_parser.parseMsgBody(clientMsg_txtEx);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("ss", sittingStatus);
	_jsonstr.compose("ws", waitingStatus);
	_jsonstr.compose("m", clientMsg_txtEx);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	if(!_jparser.parseByName("ss", sittingStatus)) _jparser.parseByNameThrow("sittingStatus", sittingStatus);
	if(!_jparser.parseByName("ws", waitingStatus)) _jparser.parseByNameThrow("waitingStatus", waitingStatus);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	BYTE sittingStatus; if(!_jparser.validateByName("ss", sittingStatus)) _jparser.validateByNameThrow("sittingStatus", sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	UINT32 waitingStatus; if(!_jparser.validateByName("ws", waitingStatus)) _jparser.validateByNameThrow("waitingStatus", waitingStatus);
	AtfValidator::validateInt(_descr, "waitingStatus", waitingStatus, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	BYTE sittingStatus; _parser.parseBYTE(sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	UINT32 waitingStatus; _parser.parseUINT32(waitingStatus);
	AtfValidator::validateInt(_descr, "waitingStatus", waitingStatus, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SITOUT
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SITOUT::Protocol_MSG_TABLE_SITOUT()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT::clear()
{
	userFlags = 0;
	userFlagsEx = 0;
	isPlayMoney = false;
}

bool TableClient::player::Protocol_MSG_TABLE_SITOUT::equals(const Protocol_MSG_TABLE_SITOUT& _o) const
{
	return userFlags == _o.userFlags &&
		userFlagsEx == _o.userFlagsEx &&
		isPlayMoney == _o.isPlayMoney;
}

bool TableClient::player::Protocol_MSG_TABLE_SITOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SITOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SITOUT*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SITOUT).append(")");
	_buf.append(',');
	_buf.append("userFlags=");
	_buf.appendUint(userFlags);
	_buf.append(',');
	_buf.append("userFlagsEx=");
	_buf.appendUint64(userFlagsEx);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SITOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userFlags", userFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("userFlagsEx", userFlagsEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SITOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userFlags"))
			{
				userFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userFlagsEx"))
			{
				userFlagsEx = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userFlags);
	_msg.composeUINT64(userFlagsEx);
	_msg.composeBOOL(isPlayMoney);
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(userFlags);
	_parser.parseUINT64(userFlagsEx);
	_parser.parseBOOL(isPlayMoney);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userFlags", userFlags);
	_jsonstr.compose("userFlagsEx", userFlagsEx);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("userFlags", userFlags);
	_jparser.parseByNameThrow("userFlagsEx", userFlagsEx);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	UINT32 userFlags; _jparser.validateByNameThrow("userFlags", userFlags);
	AtfValidator::validateInt(_descr, "userFlags", userFlags, _checker, __FILE__, __LINE__);
	UINT64 userFlagsEx; _jparser.validateByNameThrow("userFlagsEx", userFlagsEx);
	AtfValidator::validateUint(_descr, "userFlagsEx", userFlagsEx, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 userFlags; _parser.parseUINT32(userFlags);
	AtfValidator::validateInt(_descr, "userFlags", userFlags, _checker, __FILE__, __LINE__);
	UINT64 userFlagsEx; _parser.parseUINT64(userFlagsEx);
	AtfValidator::validateUint(_descr, "userFlagsEx", userFlagsEx, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SITOUT_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::Protocol_MSG_TABLE_SITOUT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::Protocol_MSG_TABLE_SITOUT_REPLY(Protocol_MSG_TABLE_SITOUT_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, sittingStatus(std::move(_o.sittingStatus))
	, campingCountingDownSec(std::move(_o.campingCountingDownSec))
{
}

TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY& TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::operator=(Protocol_MSG_TABLE_SITOUT_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		sittingStatus = std::move(_o.sittingStatus);
		campingCountingDownSec = std::move(_o.campingCountingDownSec);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	sittingStatus = 0;
	campingCountingDownSec = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::equals(const Protocol_MSG_TABLE_SITOUT_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		sittingStatus == _o.sittingStatus &&
		campingCountingDownSec == _o.campingCountingDownSec;
}

bool TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SITOUT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SITOUT_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SITOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("ss=");
	_buf.appendUint(sittingStatus);
	_buf.append(',');
	_buf.append("campSecs=");
	_buf.appendUint(campingCountingDownSec);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SITOUT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("ss", sittingStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("campSecs", campingCountingDownSec, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("ss") || _element.equals("sittingStatus"))
			{
				sittingStatus = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("campSecs") || _element.equals("campingCountingDownSec"))
			{
				campingCountingDownSec = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	_msg.composeBYTE(sittingStatus);
	_msg.composeUINT16(campingCountingDownSec);
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	_parser.parseBYTE(sittingStatus);
	if(_parser.parseEnded()) return;
	_parser.parseUINT16(campingCountingDownSec);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("ss", sittingStatus);
	_jsonstr.compose("campSecs", campingCountingDownSec);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	if(!_jparser.parseByName("ss", sittingStatus)) _jparser.parseByNameThrow("sittingStatus", sittingStatus);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("campSecs", campingCountingDownSec)) _jparser.parseByNameThrow("campingCountingDownSec", campingCountingDownSec);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	BYTE sittingStatus; if(!_jparser.validateByName("ss", sittingStatus)) _jparser.validateByNameThrow("sittingStatus", sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT16 campingCountingDownSec; if(!_jparser.validateByName("campSecs", campingCountingDownSec)) _jparser.validateByNameThrow("campingCountingDownSec", campingCountingDownSec);
	AtfValidator::validateInt(_descr, "campingCountingDownSec", campingCountingDownSec, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	BYTE sittingStatus; _parser.parseBYTE(sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT16 campingCountingDownSec; _parser.parseUINT16(campingCountingDownSec);
	AtfValidator::validateInt(_descr, "campingCountingDownSec", campingCountingDownSec, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SITOUT_NEXTHAND
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::Protocol_MSG_TABLE_SITOUT_NEXTHAND()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::clear()
{
	checked = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::equals(const Protocol_MSG_TABLE_SITOUT_NEXTHAND& _o) const
{
	return checked == _o.checked;
}

bool TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SITOUT_NEXTHAND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SITOUT_NEXTHAND*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SITOUT_NEXTHAND).append(")");
	_buf.append(',');
	_buf.append("checked=");
	_buf.appendUint(checked);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SITOUT_NEXTHAND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("checked", checked, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("checked"))
			{
				checked = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(checked);
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(checked);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("checked", checked);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("checked", checked);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITOUT_NEXTHAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE checked; _jparser.validateByNameThrow("checked", checked);
	AtfValidator::validateInt(_descr, "checked", checked, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITOUT_NEXTHAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE checked; _parser.parseBYTE(checked);
	AtfValidator::validateInt(_descr, "checked", checked, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CHIPSAVAIL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::Protocol_MSG_TABLE_CHIPSAVAIL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::clear()
{
}

bool TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::equals(const Protocol_MSG_TABLE_CHIPSAVAIL& _o) const
{
	return true;
}

bool TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CHIPSAVAIL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CHIPSAVAIL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CHIPSAVAIL).append(")");
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CHIPSAVAIL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::parseMsg(CommMsgParser& _parser)
{
}

const char *TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHIPSAVAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHIPSAVAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CHIPSAVAIL_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY(Protocol_MSG_TABLE_CHIPSAVAIL_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, chips(std::move(_o.chips))
	, minLimit(std::move(_o.minLimit))
	, maxLimit(std::move(_o.maxLimit))
	, quantum(std::move(_o.quantum))
	, playAddedMask(std::move(_o.playAddedMask))
	, playAddedAmount(std::move(_o.playAddedAmount))
	, chipsHandStart(std::move(_o.chipsHandStart))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, currencyContext(std::move(_o.currencyContext))
	, ratHoleSeconds(std::move(_o.ratHoleSeconds))
	, maxRebuyChips_It(std::move(_o.maxRebuyChips_It))
	, totalRebuys_It(std::move(_o.totalRebuys_It))
	, pmChips(std::move(_o.pmChips))
	, userRollId(std::move(_o.userRollId))
{
}

TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY& TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::operator=(Protocol_MSG_TABLE_CHIPSAVAIL_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		chips = std::move(_o.chips);
		minLimit = std::move(_o.minLimit);
		maxLimit = std::move(_o.maxLimit);
		quantum = std::move(_o.quantum);
		playAddedMask = std::move(_o.playAddedMask);
		playAddedAmount = std::move(_o.playAddedAmount);
		chipsHandStart = std::move(_o.chipsHandStart);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		currencyContext = std::move(_o.currencyContext);
		ratHoleSeconds = std::move(_o.ratHoleSeconds);
		maxRebuyChips_It = std::move(_o.maxRebuyChips_It);
		totalRebuys_It = std::move(_o.totalRebuys_It);
		pmChips = std::move(_o.pmChips);
		userRollId = std::move(_o.userRollId);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	chips = 0;
	minLimit = 0;
	maxLimit = 0;
	quantum = 0;
	playAddedMask = 0;
	playAddedAmount = 0;
	chipsHandStart = 0;
	clientMsg_txtEx.clear();
	currencyContext.clear();
	ratHoleSeconds = 0;
	maxRebuyChips_It = 0;
	totalRebuys_It = 0;
	pmChips = 0;
	userRollId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::equals(const Protocol_MSG_TABLE_CHIPSAVAIL_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		chips == _o.chips &&
		minLimit == _o.minLimit &&
		maxLimit == _o.maxLimit &&
		quantum == _o.quantum &&
		playAddedMask == _o.playAddedMask &&
		playAddedAmount == _o.playAddedAmount &&
		chipsHandStart == _o.chipsHandStart &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		currencyContext.equals(_o.currencyContext) &&
		ratHoleSeconds == _o.ratHoleSeconds &&
		maxRebuyChips_It == _o.maxRebuyChips_It &&
		totalRebuys_It == _o.totalRebuys_It &&
		pmChips == _o.pmChips &&
		userRollId == _o.userRollId;
}

bool TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CHIPSAVAIL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CHIPSAVAIL_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CHIPSAVAIL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("mnLim=");
	_buf.appendUint(minLimit);
	_buf.append(',');
	_buf.append("mxLim=");
	_buf.appendUint(maxLimit);
	_buf.append(',');
	_buf.append("q=");
	_buf.appendUint(quantum);
	_buf.append(',');
	_buf.append("mask=");
	_buf.appendUint(playAddedMask);
	_buf.append(',');
	_buf.append("amt=");
	_buf.appendUint(playAddedAmount);
	_buf.append(',');
	_buf.append("chipsHS=");
	_buf.appendUint(chipsHandStart);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("currency=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("rh=");
	_buf.appendUint(ratHoleSeconds);
	_buf.append(',');
	_buf.append("maxRebuy=");
	_buf.appendUint(maxRebuyChips_It);
	_buf.append(',');
	_buf.append("totRebuy=");
	_buf.appendUint(totalRebuys_It);
	_buf.append(',');
	_buf.append("pmChips=");
	_buf.appendUint64(pmChips);
	_buf.append(',');
	_buf.append("rId=");
	_buf.appendUint(userRollId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CHIPSAVAIL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("mnLim", minLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("mxLim", maxLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("q", quantum, _buf);
	Atf::XmlElement::encodeAsXmlElement("mask", playAddedMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("amt", playAddedAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsHS", chipsHandStart, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currencyContext, _buf);
	Atf::XmlElement::encodeAsXmlElement("rh", ratHoleSeconds, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxRebuy", maxRebuyChips_It, _buf);
	Atf::XmlElement::encodeAsXmlElement("totRebuy", totalRebuys_It, _buf);
	Atf::XmlElement::encodeAsXmlElement("pmChips", pmChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("rId", userRollId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mnLim") || _element.equals("minLimit"))
			{
				minLimit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mxLim") || _element.equals("maxLimit"))
			{
				maxLimit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("q") || _element.equals("quantum"))
			{
				quantum = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mask") || _element.equals("playAddedMask"))
			{
				playAddedMask = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("amt") || _element.equals("playAddedAmount"))
			{
				playAddedAmount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chipsHS") || _element.equals("chipsHandStart"))
			{
				chipsHandStart = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("currency") || _element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("rh") || _element.equals("ratHoleSeconds"))
			{
				ratHoleSeconds = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxRebuy") || _element.equals("maxRebuyChips_It"))
			{
				maxRebuyChips_It = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totRebuy") || _element.equals("totalRebuys_It"))
			{
				totalRebuys_It = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pmChips"))
			{
				pmChips = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rId") || _element.equals("userRollId"))
			{
				userRollId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	_msg.composeUINT32(chips);
	_msg.composeUINT32(minLimit);
	_msg.composeUINT32(maxLimit);
	_msg.composeUINT32(quantum);
	_msg.composeBYTE(playAddedMask);
	_msg.composeUINT32(playAddedAmount);
	_msg.composeUINT32(chipsHandStart);
	_msg.composeMsgBody(clientMsg_txtEx);
	_msg.composeMsgBody(currencyContext);
	_msg.composeUINT32(ratHoleSeconds);
	_msg.composeUINT32(maxRebuyChips_It);
	_msg.composeUINT32(totalRebuys_It);
	_msg.composeUINT64(pmChips);
	_msg.composeUINT32(userRollId);
}

void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	_parser.parseUINT32(chips);
	_parser.parseUINT32(minLimit);
	_parser.parseUINT32(maxLimit);
	_parser.parseUINT32(quantum);
	_parser.parseBYTE(playAddedMask);
	_parser.parseUINT32(playAddedAmount);
	_parser.parseUINT32(chipsHandStart);
	_parser.parseMsgBody(clientMsg_txtEx);
	_parser.parseMsgBody(currencyContext);
	_parser.parseUINT32(ratHoleSeconds);
	_parser.parseUINT32(maxRebuyChips_It);
	_parser.parseUINT32(totalRebuys_It);
	_parser.parseUINT64(pmChips);
	_parser.parseUINT32(userRollId);
}

const char *TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("mnLim", minLimit);
	_jsonstr.compose("mxLim", maxLimit);
	_jsonstr.compose("q", quantum);
	_jsonstr.compose("mask", playAddedMask);
	_jsonstr.compose("amt", playAddedAmount);
	_jsonstr.compose("chipsHS", chipsHandStart);
	_jsonstr.compose("m", clientMsg_txtEx);
	_jsonstr.compose("currency", currencyContext);
	_jsonstr.compose("rh", ratHoleSeconds);
	_jsonstr.compose("maxRebuy", maxRebuyChips_It);
	_jsonstr.compose("totRebuy", totalRebuys_It);
	_jsonstr.compose("pmChips", pmChips);
	_jsonstr.compose("rId", userRollId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	_jparser.parseByNameThrow("chips", chips);
	if(!_jparser.parseByName("mnLim", minLimit)) _jparser.parseByNameThrow("minLimit", minLimit);
	if(!_jparser.parseByName("mxLim", maxLimit)) _jparser.parseByNameThrow("maxLimit", maxLimit);
	if(!_jparser.parseByName("q", quantum)) _jparser.parseByNameThrow("quantum", quantum);
	if(!_jparser.parseByName("mask", playAddedMask)) _jparser.parseByNameThrow("playAddedMask", playAddedMask);
	if(!_jparser.parseByName("amt", playAddedAmount)) _jparser.parseByNameThrow("playAddedAmount", playAddedAmount);
	if(!_jparser.parseByName("chipsHS", chipsHandStart)) _jparser.parseByNameThrow("chipsHandStart", chipsHandStart);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	if(!_jparser.parseByName("currency", currencyContext)) _jparser.parseByNameThrow("currencyContext", currencyContext);
	if(!_jparser.parseByName("rh", ratHoleSeconds)) _jparser.parseByNameThrow("ratHoleSeconds", ratHoleSeconds);
	if(!_jparser.parseByName("maxRebuy", maxRebuyChips_It)) _jparser.parseByNameThrow("maxRebuyChips_It", maxRebuyChips_It);
	if(!_jparser.parseByName("totRebuy", totalRebuys_It)) _jparser.parseByNameThrow("totalRebuys_It", totalRebuys_It);
	_jparser.parseByNameThrow("pmChips", pmChips);
	if(!_jparser.parseByName("rId", userRollId)) _jparser.parseByNameThrow("userRollId", userRollId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHIPSAVAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	UINT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT32 minLimit; if(!_jparser.validateByName("mnLim", minLimit)) _jparser.validateByNameThrow("minLimit", minLimit);
	AtfValidator::validateInt(_descr, "minLimit", minLimit, _checker, __FILE__, __LINE__);
	UINT32 maxLimit; if(!_jparser.validateByName("mxLim", maxLimit)) _jparser.validateByNameThrow("maxLimit", maxLimit);
	AtfValidator::validateInt(_descr, "maxLimit", maxLimit, _checker, __FILE__, __LINE__);
	UINT32 quantum; if(!_jparser.validateByName("q", quantum)) _jparser.validateByNameThrow("quantum", quantum);
	AtfValidator::validateInt(_descr, "quantum", quantum, _checker, __FILE__, __LINE__);
	BYTE playAddedMask; if(!_jparser.validateByName("mask", playAddedMask)) _jparser.validateByNameThrow("playAddedMask", playAddedMask);
	AtfValidator::validateInt(_descr, "playAddedMask", playAddedMask, _checker, __FILE__, __LINE__);
	UINT32 playAddedAmount; if(!_jparser.validateByName("amt", playAddedAmount)) _jparser.validateByNameThrow("playAddedAmount", playAddedAmount);
	AtfValidator::validateInt(_descr, "playAddedAmount", playAddedAmount, _checker, __FILE__, __LINE__);
	UINT32 chipsHandStart; if(!_jparser.validateByName("chipsHS", chipsHandStart)) _jparser.validateByNameThrow("chipsHandStart", chipsHandStart);
	AtfValidator::validateInt(_descr, "chipsHandStart", chipsHandStart, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody currencyContext; if(!_jparser.validateByName("currency", currencyContext)) _jparser.validateByNameThrow("currencyContext", currencyContext);
	AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
	UINT32 ratHoleSeconds; if(!_jparser.validateByName("rh", ratHoleSeconds)) _jparser.validateByNameThrow("ratHoleSeconds", ratHoleSeconds);
	AtfValidator::validateInt(_descr, "ratHoleSeconds", ratHoleSeconds, _checker, __FILE__, __LINE__);
	UINT32 maxRebuyChips_It; if(!_jparser.validateByName("maxRebuy", maxRebuyChips_It)) _jparser.validateByNameThrow("maxRebuyChips_It", maxRebuyChips_It);
	AtfValidator::validateInt(_descr, "maxRebuyChips_It", maxRebuyChips_It, _checker, __FILE__, __LINE__);
	UINT32 totalRebuys_It; if(!_jparser.validateByName("totRebuy", totalRebuys_It)) _jparser.validateByNameThrow("totalRebuys_It", totalRebuys_It);
	AtfValidator::validateInt(_descr, "totalRebuys_It", totalRebuys_It, _checker, __FILE__, __LINE__);
	UINT64 pmChips; _jparser.validateByNameThrow("pmChips", pmChips);
	AtfValidator::validateUint(_descr, "pmChips", pmChips, _checker, __FILE__, __LINE__);
	UINT32 userRollId; if(!_jparser.validateByName("rId", userRollId)) _jparser.validateByNameThrow("userRollId", userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CHIPSAVAIL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT32 minLimit; _parser.parseUINT32(minLimit);
	AtfValidator::validateInt(_descr, "minLimit", minLimit, _checker, __FILE__, __LINE__);
	UINT32 maxLimit; _parser.parseUINT32(maxLimit);
	AtfValidator::validateInt(_descr, "maxLimit", maxLimit, _checker, __FILE__, __LINE__);
	UINT32 quantum; _parser.parseUINT32(quantum);
	AtfValidator::validateInt(_descr, "quantum", quantum, _checker, __FILE__, __LINE__);
	BYTE playAddedMask; _parser.parseBYTE(playAddedMask);
	AtfValidator::validateInt(_descr, "playAddedMask", playAddedMask, _checker, __FILE__, __LINE__);
	UINT32 playAddedAmount; _parser.parseUINT32(playAddedAmount);
	AtfValidator::validateInt(_descr, "playAddedAmount", playAddedAmount, _checker, __FILE__, __LINE__);
	UINT32 chipsHandStart; _parser.parseUINT32(chipsHandStart);
	AtfValidator::validateInt(_descr, "chipsHandStart", chipsHandStart, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
	UINT32 ratHoleSeconds; _parser.parseUINT32(ratHoleSeconds);
	AtfValidator::validateInt(_descr, "ratHoleSeconds", ratHoleSeconds, _checker, __FILE__, __LINE__);
	UINT32 maxRebuyChips_It; _parser.parseUINT32(maxRebuyChips_It);
	AtfValidator::validateInt(_descr, "maxRebuyChips_It", maxRebuyChips_It, _checker, __FILE__, __LINE__);
	UINT32 totalRebuys_It; _parser.parseUINT32(totalRebuys_It);
	AtfValidator::validateInt(_descr, "totalRebuys_It", totalRebuys_It, _checker, __FILE__, __LINE__);
	UINT64 pmChips; _parser.parseUINT64(pmChips);
	AtfValidator::validateUint(_descr, "pmChips", pmChips, _checker, __FILE__, __LINE__);
	UINT32 userRollId; _parser.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SET_AUTO_REBUY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::Protocol_MSG_TABLE_SET_AUTO_REBUY()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::clear()
{
	autoRebuyOpt = 0;
	bigBets = 0;
	underBigBets = 0;
	underPercents = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::equals(const Protocol_MSG_TABLE_SET_AUTO_REBUY& _o) const
{
	return autoRebuyOpt == _o.autoRebuyOpt &&
		bigBets == _o.bigBets &&
		underBigBets == _o.underBigBets &&
		underPercents == _o.underPercents;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SET_AUTO_REBUY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SET_AUTO_REBUY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SET_AUTO_REBUY).append(")");
	_buf.append(',');
	_buf.append("ar=");
	_buf.appendInt(autoRebuyOpt);
	_buf.append(',');
	_buf.append("arBB=");
	_buf.appendUint(bigBets);
	_buf.append(',');
	_buf.append("arFBB=");
	_buf.appendUint(underBigBets);
	_buf.append(',');
	_buf.append("arFPcnt=");
	_buf.appendUint(underPercents);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SET_AUTO_REBUY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("ar", autoRebuyOpt, _buf);
	Atf::XmlElement::encodeAsXmlElement("arBB", bigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("arFBB", underBigBets, _buf);
	Atf::XmlElement::encodeAsXmlElement("arFPcnt", underPercents, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("ar") || _element.equals("autoRebuyOpt"))
			{
				autoRebuyOpt = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("arBB") || _element.equals("bigBets"))
			{
				bigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("arFBB") || _element.equals("underBigBets"))
			{
				underBigBets = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("arFPcnt") || _element.equals("underPercents"))
			{
				underPercents = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(autoRebuyOpt);
	_msg.composeUINT16(bigBets);
	_msg.composeUINT16(underBigBets);
	_msg.composeUINT16(underPercents);
}

void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(autoRebuyOpt);
	_parser.parseUINT16(bigBets);
	_parser.parseUINT16(underBigBets);
	_parser.parseUINT16(underPercents);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ar", autoRebuyOpt);
	_jsonstr.compose("arBB", bigBets);
	_jsonstr.compose("arFBB", underBigBets);
	_jsonstr.compose("arFPcnt", underPercents);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("ar", autoRebuyOpt)) _jparser.parseByNameThrow("autoRebuyOpt", autoRebuyOpt);
	if(!_jparser.parseByName("arBB", bigBets)) _jparser.parseByNameThrow("bigBets", bigBets);
	if(!_jparser.parseByName("arFBB", underBigBets)) _jparser.parseByNameThrow("underBigBets", underBigBets);
	if(!_jparser.parseByName("arFPcnt", underPercents)) _jparser.parseByNameThrow("underPercents", underPercents);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_AUTO_REBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 autoRebuyOpt; if(!_jparser.validateByName("ar", autoRebuyOpt)) _jparser.validateByNameThrow("autoRebuyOpt", autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, 0, 100, _checker, __FILE__, __LINE__);
	UINT16 bigBets; if(!_jparser.validateByName("arBB", bigBets)) _jparser.validateByNameThrow("bigBets", bigBets);
	AtfValidator::validateIntMax(_descr, "bigBets", bigBets, 1000, _checker, __FILE__, __LINE__);
	UINT16 underBigBets; if(!_jparser.validateByName("arFBB", underBigBets)) _jparser.validateByNameThrow("underBigBets", underBigBets);
	AtfValidator::validateIntMax(_descr, "underBigBets", underBigBets, 1000, _checker, __FILE__, __LINE__);
	UINT16 underPercents; if(!_jparser.validateByName("arFPcnt", underPercents)) _jparser.validateByNameThrow("underPercents", underPercents);
	AtfValidator::validateIntMax(_descr, "underPercents", underPercents, 100, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_AUTO_REBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT8 autoRebuyOpt; _parser.parseINT8(autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, 0, 100, _checker, __FILE__, __LINE__);
	UINT16 bigBets; _parser.parseUINT16(bigBets);
	AtfValidator::validateIntMax(_descr, "bigBets", bigBets, 1000, _checker, __FILE__, __LINE__);
	UINT16 underBigBets; _parser.parseUINT16(underBigBets);
	AtfValidator::validateIntMax(_descr, "underBigBets", underBigBets, 1000, _checker, __FILE__, __LINE__);
	UINT16 underPercents; _parser.parseUINT16(underPercents);
	AtfValidator::validateIntMax(_descr, "underPercents", underPercents, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::clear()
{
	errcode = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::equals(const Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY& _o) const
{
	return errcode == _o.errcode;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SET_AUTO_REBUY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SET_AUTO_REBUY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SET_AUTO_REBUY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
}

void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_AUTO_REBUY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_AUTO_REBUY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::clear()
{
	notAllInShowAllowed = false;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::equals(const Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN& _o) const
{
	return notAllInShowAllowed == _o.notAllInShowAllowed;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SET_SHOW_WHEN_ALLIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SET_SHOW_WHEN_ALLIN).append(")");
	_buf.append(',');
	_buf.append("opt=");
	_buf.appendUint(notAllInShowAllowed);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SET_SHOW_WHEN_ALLIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("opt", notAllInShowAllowed, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("opt") || _element.equals("notAllInShowAllowed"))
			{
				notAllInShowAllowed = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(notAllInShowAllowed);
}

void TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(notAllInShowAllowed);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("opt", notAllInShowAllowed);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("opt", notAllInShowAllowed)) _jparser.parseByNameThrow("notAllInShowAllowed", notAllInShowAllowed);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_SHOW_WHEN_ALLIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool notAllInShowAllowed; if(!_jparser.validateByName("opt", notAllInShowAllowed)) _jparser.validateByNameThrow("notAllInShowAllowed", notAllInShowAllowed);
	AtfValidator::validateInt(_descr, "notAllInShowAllowed", notAllInShowAllowed, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_SHOW_WHEN_ALLIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool notAllInShowAllowed; _parser.parseBOOL(notAllInShowAllowed);
	AtfValidator::validateInt(_descr, "notAllInShowAllowed", notAllInShowAllowed, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SET_DEAL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SET_DEAL::Protocol_MSG_TABLE_SET_DEAL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SET_DEAL::clear()
{
	setOptions = false;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_DEAL::equals(const Protocol_MSG_TABLE_SET_DEAL& _o) const
{
	return setOptions == _o.setOptions;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_DEAL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SET_DEAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SET_DEAL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_DEAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SET_DEAL).append(")");
	_buf.append(',');
	_buf.append("opt=");
	_buf.appendUint(setOptions);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_DEAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_DEAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SET_DEAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("opt", setOptions, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SET_DEAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("opt") || _element.equals("setOptions"))
			{
				setOptions = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SET_DEAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(setOptions);
}

void TableClient::player::Protocol_MSG_TABLE_SET_DEAL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(setOptions);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_DEAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("opt", setOptions);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SET_DEAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("opt", setOptions)) _jparser.parseByNameThrow("setOptions", setOptions);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_DEAL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_DEAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool setOptions; if(!_jparser.validateByName("opt", setOptions)) _jparser.validateByNameThrow("setOptions", setOptions);
	AtfValidator::validateInt(_descr, "setOptions", setOptions, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_DEAL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_DEAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool setOptions; _parser.parseBOOL(setOptions);
	AtfValidator::validateInt(_descr, "setOptions", setOptions, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::clear()
{
	runItTwice = false;
	allinCashoutNotFavored = false;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::equals(const Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE& _o) const
{
	return runItTwice == _o.runItTwice &&
		allinCashoutNotFavored == _o.allinCashoutNotFavored;
}

bool TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE).append(")");
	_buf.append(',');
	_buf.append("rit=");
	_buf.appendUint(runItTwice);
	_buf.append(',');
	_buf.append("nco=");
	_buf.appendUint(allinCashoutNotFavored);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("rit", runItTwice, _buf);
	Atf::XmlElement::encodeAsXmlElement("nco", allinCashoutNotFavored, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("rit") || _element.equals("runItTwice"))
			{
				runItTwice = (*_value.ptr() == '1');
			}
			else if (_element.equals("nco") || _element.equals("allinCashoutNotFavored"))
			{
				allinCashoutNotFavored = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(runItTwice);
	_msg.composeBOOL(allinCashoutNotFavored);
}

void TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(runItTwice);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(allinCashoutNotFavored);
}

const char *TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("rit", runItTwice);
	_jsonstr.compose("nco", allinCashoutNotFavored);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("rit", runItTwice)) _jparser.parseByNameThrow("runItTwice", runItTwice);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("nco", allinCashoutNotFavored)) _jparser.parseByNameThrow("allinCashoutNotFavored", allinCashoutNotFavored);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool runItTwice; if(!_jparser.validateByName("rit", runItTwice)) _jparser.validateByNameThrow("runItTwice", runItTwice);
	AtfValidator::validateInt(_descr, "runItTwice", runItTwice, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool allinCashoutNotFavored; if(!_jparser.validateByName("nco", allinCashoutNotFavored)) _jparser.validateByNameThrow("allinCashoutNotFavored", allinCashoutNotFavored);
	AtfValidator::validateInt(_descr, "allinCashoutNotFavored", allinCashoutNotFavored, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool runItTwice; _parser.parseBOOL(runItTwice);
	AtfValidator::validateInt(_descr, "runItTwice", runItTwice, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool allinCashoutNotFavored; _parser.parseBOOL(allinCashoutNotFavored);
	AtfValidator::validateInt(_descr, "allinCashoutNotFavored", allinCashoutNotFavored, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_REQUESTACTION_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::Protocol_MSG_TABLE_REQUESTACTION_REPLY()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::clear()
{
}

bool TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::equals(const Protocol_MSG_TABLE_REQUESTACTION_REPLY& _o) const
{
	return true;
}

bool TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_REQUESTACTION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_REQUESTACTION_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_REQUESTACTION_REPLY).append(")");
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_REQUESTACTION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REQUESTACTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REQUESTACTION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_FAST_FOLD
//=================================================================

TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::Protocol_MSG_TABLE_FAST_FOLD()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::clear()
{
	handId = 0;
	flags = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::equals(const Protocol_MSG_TABLE_FAST_FOLD& _o) const
{
	return handId == _o.handId &&
		flags == _o.flags;
}

bool TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_FAST_FOLD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_FAST_FOLD*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_FAST_FOLD).append(")");
	_buf.append(',');
	_buf.append("hI=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_FAST_FOLD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("hI", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("hI") || _element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
	_msg.composeBYTE(flags);
}

void TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(flags);
}

const char *TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("hI", handId);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("hI", handId)) _jparser.parseByNameThrow("handId", handId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flags", flags);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_FAST_FOLD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; if(!_jparser.validateByName("hI", handId)) _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_FAST_FOLD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_FAST_FOLD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE flags; _parser.parseBYTE(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_GOTO_NEXTHAND
//=================================================================

TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::Protocol_MSG_TABLE_GOTO_NEXTHAND()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::clear()
{
	handId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::equals(const Protocol_MSG_TABLE_GOTO_NEXTHAND& _o) const
{
	return handId == _o.handId;
}

bool TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_GOTO_NEXTHAND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_GOTO_NEXTHAND*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_GOTO_NEXTHAND).append(")");
	_buf.append(',');
	_buf.append("hI=");
	_buf.appendUint64(handId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_GOTO_NEXTHAND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("hI", handId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("hI") || _element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
}

void TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
}

const char *TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("hI", handId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("hI", handId)) _jparser.parseByNameThrow("handId", handId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_GOTO_NEXTHAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; if(!_jparser.validateByName("hI", handId)) _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_GOTO_NEXTHAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_GOTO_NEXTHAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_REFRESH
//=================================================================

TableClient::player::Protocol_MSG_TABLE_REFRESH::Protocol_MSG_TABLE_REFRESH()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_REFRESH::clear()
{
}

bool TableClient::player::Protocol_MSG_TABLE_REFRESH::equals(const Protocol_MSG_TABLE_REFRESH& _o) const
{
	return true;
}

bool TableClient::player::Protocol_MSG_TABLE_REFRESH::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_REFRESH != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_REFRESH*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_REFRESH::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_REFRESH).append(")");
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_REFRESH::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_REFRESH::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_REFRESH).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_REFRESH::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_REFRESH::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void TableClient::player::Protocol_MSG_TABLE_REFRESH::parseMsg(CommMsgParser& _parser)
{
}

const char *TableClient::player::Protocol_MSG_TABLE_REFRESH::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_REFRESH::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REFRESH::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REFRESH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REFRESH::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REFRESH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_REFRESH_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::Protocol_MSG_TABLE_REFRESH_REPLY()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::clear()
{
	italyReservedChips = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::equals(const Protocol_MSG_TABLE_REFRESH_REPLY& _o) const
{
	return italyReservedChips == _o.italyReservedChips;
}

bool TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_REFRESH_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_REFRESH_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_REFRESH_REPLY).append(")");
	_buf.append(',');
	_buf.append("italyReservedChips=");
	_buf.appendUint(italyReservedChips);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_REFRESH_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("italyReservedChips", italyReservedChips, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("italyReservedChips"))
			{
				italyReservedChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(italyReservedChips);
}

void TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(italyReservedChips);
}

const char *TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("italyReservedChips", italyReservedChips);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("italyReservedChips", italyReservedChips);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REFRESH_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 italyReservedChips; _jparser.validateByNameThrow("italyReservedChips", italyReservedChips);
	AtfValidator::validateInt(_descr, "italyReservedChips", italyReservedChips, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_REFRESH_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_REFRESH_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 italyReservedChips; _parser.parseUINT32(italyReservedChips);
	AtfValidator::validateInt(_descr, "italyReservedChips", italyReservedChips, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_PLAYNOW
//=================================================================

TableClient::player::Protocol_MSG_TABLE_PLAYNOW::Protocol_MSG_TABLE_PLAYNOW()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_PLAYNOW::clear()
{
}

bool TableClient::player::Protocol_MSG_TABLE_PLAYNOW::equals(const Protocol_MSG_TABLE_PLAYNOW& _o) const
{
	return true;
}

bool TableClient::player::Protocol_MSG_TABLE_PLAYNOW::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_PLAYNOW != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_PLAYNOW*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_PLAYNOW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_PLAYNOW).append(")");
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_PLAYNOW::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_PLAYNOW::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_PLAYNOW).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_PLAYNOW::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_PLAYNOW::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void TableClient::player::Protocol_MSG_TABLE_PLAYNOW::parseMsg(CommMsgParser& _parser)
{
}

const char *TableClient::player::Protocol_MSG_TABLE_PLAYNOW::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_PLAYNOW::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_PLAYNOW::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_PLAYNOW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_PLAYNOW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_PLAYNOW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_ENTROPY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_ENTROPY::Protocol_MSG_TABLE_ENTROPY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_ENTROPY::Protocol_MSG_TABLE_ENTROPY(Protocol_MSG_TABLE_ENTROPY&& _o)
	: enthropy(std::move(_o.enthropy))
{
}

TableClient::player::Protocol_MSG_TABLE_ENTROPY& TableClient::player::Protocol_MSG_TABLE_ENTROPY::operator=(Protocol_MSG_TABLE_ENTROPY&& _o)
{
	if(this != &_o)
	{
		enthropy = std::move(_o.enthropy);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_ENTROPY::clear()
{
	enthropy.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_ENTROPY::equals(const Protocol_MSG_TABLE_ENTROPY& _o) const
{
	return enthropy.size() == _o.enthropy.size() && memcmp(enthropy.ptr(), _o.enthropy.ptr(), enthropy.size()) == 0;
}

bool TableClient::player::Protocol_MSG_TABLE_ENTROPY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_ENTROPY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_ENTROPY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_ENTROPY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_ENTROPY).append(")");
	_buf.append(',');
	_buf.append("enthropy=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, enthropy);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_ENTROPY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_ENTROPY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_ENTROPY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("enthropy", enthropy, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_ENTROPY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("enthropy"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, enthropy);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_ENTROPY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg._composeVarBlock(enthropy.ptr(), enthropy.size());
}

void TableClient::player::Protocol_MSG_TABLE_ENTROPY::parseMsg(CommMsgParser& _parser)
{
	_parser.parsePBlock(enthropy);
}

const char *TableClient::player::Protocol_MSG_TABLE_ENTROPY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("enthropy", enthropy);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_ENTROPY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("enthropy", enthropy);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ENTROPY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ENTROPY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PBlock enthropy; _jparser.validateByNameThrow("enthropy", enthropy);
	AtfValidator::validateIntMax(_descr, "enthropy", enthropy.size(), 8192, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ENTROPY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ENTROPY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const BYTE* enthropy; size_t szEnthropy; _parser._parseVarBlock(enthropy, szEnthropy);  /*enthropy*/
	AtfValidator::validateIntMax(_descr, "enthropy", szEnthropy, 8192, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_GET_DEAL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_GET_DEAL::Protocol_MSG_TABLE_GET_DEAL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_GET_DEAL::clear()
{
}

bool TableClient::player::Protocol_MSG_TABLE_GET_DEAL::equals(const Protocol_MSG_TABLE_GET_DEAL& _o) const
{
	return true;
}

bool TableClient::player::Protocol_MSG_TABLE_GET_DEAL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_GET_DEAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_GET_DEAL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_GET_DEAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_GET_DEAL).append(")");
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_GET_DEAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_GET_DEAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_GET_DEAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_GET_DEAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_GET_DEAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void TableClient::player::Protocol_MSG_TABLE_GET_DEAL::parseMsg(CommMsgParser& _parser)
{
}

const char *TableClient::player::Protocol_MSG_TABLE_GET_DEAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_GET_DEAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_GET_DEAL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_GET_DEAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_GET_DEAL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_GET_DEAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_GET_DEAL_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::Protocol_MSG_TABLE_GET_DEAL_REPLY()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::clear()
{
	dealOptionSet = false;
}

bool TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::equals(const Protocol_MSG_TABLE_GET_DEAL_REPLY& _o) const
{
	return dealOptionSet == _o.dealOptionSet;
}

bool TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_GET_DEAL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_GET_DEAL_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_GET_DEAL_REPLY).append(")");
	_buf.append(',');
	_buf.append("dealOptionSet=");
	_buf.appendUint(dealOptionSet);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_GET_DEAL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("dealOptionSet", dealOptionSet, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("dealOptionSet"))
			{
				dealOptionSet = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(dealOptionSet);
}

void TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(dealOptionSet);
}

const char *TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dealOptionSet", dealOptionSet);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dealOptionSet", dealOptionSet);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_GET_DEAL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool dealOptionSet; _jparser.validateByNameThrow("dealOptionSet", dealOptionSet);
	AtfValidator::validateInt(_descr, "dealOptionSet", dealOptionSet, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_GET_DEAL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_GET_DEAL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool dealOptionSet; _parser.parseBOOL(dealOptionSet);
	AtfValidator::validateInt(_descr, "dealOptionSet", dealOptionSet, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_ACTION
//=================================================================

// @Override
void TableClient::player::Protocol_MSG_TABLE_ACTION::composeMsg(CommMsgBody& _body, bool _ignoreJSON) const
{
	_body.composeINT8(action);
	_body.composeUINT32(amount);
	if (actionId != 0)
	{
		_body.composeUINT32(actionId);
		_body.composeBYTE(flags);
	}
}

TableClient::player::Protocol_MSG_TABLE_ACTION::Protocol_MSG_TABLE_ACTION()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_ACTION::clear()
{
	action = '0';
	amount = 0;
	actionId = 0;
	flags = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_ACTION::equals(const Protocol_MSG_TABLE_ACTION& _o) const
{
	return action == _o.action &&
		amount == _o.amount &&
		actionId == _o.actionId &&
		flags == _o.flags;
}

bool TableClient::player::Protocol_MSG_TABLE_ACTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_ACTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_ACTION*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_ACTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_ACTION).append(")");
	_buf.append(',');
	_buf.append("a=");
	_buf.append(action);
	_buf.append(',');
	_buf.append("v=");
	_buf.appendUint(amount);
	_buf.append(',');
	_buf.append("seq=");
	_buf.appendUint(actionId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_ACTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_ACTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_ACTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("a", action, _buf);
	Atf::XmlElement::encodeAsXmlElement("v", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("seq", actionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_ACTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("a") || _element.equals("action"))
			{
				action = *_value.ptr();
			}
			else if (_element.equals("v") || _element.equals("amount"))
			{
				amount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seq") || _element.equals("actionId"))
			{
				actionId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_ACTION::parseMsg(CommMsgParser& _parser)
{
	{ INT8 _n; _parser.parseINT8(_n); action = _n; }
	_parser.parseUINT32(amount);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(actionId);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(flags);
}

const char *TableClient::player::Protocol_MSG_TABLE_ACTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("a", action);
	_jsonstr.compose("v", amount);
	_jsonstr.compose("seq", actionId);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_ACTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("a", action)) _jparser.parseByNameThrow("action", action);
	if(!_jparser.parseByName("v", amount)) _jparser.parseByNameThrow("amount", amount);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("seq", actionId)) _jparser.parseByNameThrow("actionId", actionId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("flags", flags);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ACTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	char action; if(!_jparser.validateByName("a", action)) _jparser.validateByNameThrow("action", action);
	AtfValidator::validateIntRange(_descr, "action", action, 0x20, 'z', _checker, __FILE__, __LINE__);
	UINT32 amount; if(!_jparser.validateByName("v", amount)) _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntMax(_descr, "amount", amount, 2000000000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 actionId; if(!_jparser.validateByName("seq", actionId)) _jparser.validateByNameThrow("actionId", actionId);
	AtfValidator::validateInt(_descr, "actionId", actionId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ACTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	char action; { INT8 _n; _parser.parseINT8(_n); action = _n; }
	AtfValidator::validateIntRange(_descr, "action", action, 0x20, 'z', _checker, __FILE__, __LINE__);
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateIntMax(_descr, "amount", amount, 2000000000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 actionId; _parser.parseUINT32(actionId);
	AtfValidator::validateInt(_descr, "actionId", actionId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE flags; _parser.parseBYTE(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_CANCELACTION
//=================================================================

TableClient::player::Protocol_MSG_TABLE_CANCELACTION::Protocol_MSG_TABLE_CANCELACTION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_CANCELACTION::Protocol_MSG_TABLE_CANCELACTION(Protocol_MSG_TABLE_CANCELACTION&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, isActionTimedOut(std::move(_o.isActionTimedOut))
{
}

TableClient::player::Protocol_MSG_TABLE_CANCELACTION& TableClient::player::Protocol_MSG_TABLE_CANCELACTION::operator=(Protocol_MSG_TABLE_CANCELACTION&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		isActionTimedOut = std::move(_o.isActionTimedOut);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_CANCELACTION::clear()
{
	errcode = 0;
	errstr.clear();
	isActionTimedOut = true;
}

bool TableClient::player::Protocol_MSG_TABLE_CANCELACTION::equals(const Protocol_MSG_TABLE_CANCELACTION& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		isActionTimedOut == _o.isActionTimedOut;
}

bool TableClient::player::Protocol_MSG_TABLE_CANCELACTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_CANCELACTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_CANCELACTION*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_CANCELACTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_CANCELACTION).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("to=");
	_buf.appendUint(isActionTimedOut);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_CANCELACTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_CANCELACTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_CANCELACTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("to", isActionTimedOut, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_CANCELACTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("to") || _element.equals("isActionTimedOut"))
			{
				isActionTimedOut = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_CANCELACTION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(errstr);
	_msg.composeBOOL(isActionTimedOut);
}

void TableClient::player::Protocol_MSG_TABLE_CANCELACTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(errstr);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isActionTimedOut);
}

const char *TableClient::player::Protocol_MSG_TABLE_CANCELACTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("to", isActionTimedOut);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_CANCELACTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("errstr", errstr);
	if(_jparser.parseEnded()) return;
	if(!_jparser.parseByName("to", isActionTimedOut)) _jparser.parseByNameThrow("isActionTimedOut", isActionTimedOut);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CANCELACTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CANCELACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isActionTimedOut; if(!_jparser.validateByName("to", isActionTimedOut)) _jparser.validateByNameThrow("isActionTimedOut", isActionTimedOut);
	AtfValidator::validateInt(_descr, "isActionTimedOut", isActionTimedOut, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_CANCELACTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_CANCELACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isActionTimedOut; _parser.parseBOOL(isActionTimedOut);
	AtfValidator::validateInt(_descr, "isActionTimedOut", isActionTimedOut, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TournPlayerKickMsgExtraShared
//=================================================================

TableClient::player::TournPlayerKickMsgExtraShared::TournPlayerKickMsgExtraShared()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::TournPlayerKickMsgExtraShared::TournPlayerKickMsgExtraShared(TournPlayerKickMsgExtraShared&& _o)
	: socialToken(std::move(_o.socialToken))
	, nextRecurringTournId(std::move(_o.nextRecurringTournId))
	, nextSchedTourn(std::move(_o.nextSchedTourn))
	, headBounty(std::move(_o.headBounty))
{
}

TableClient::player::TournPlayerKickMsgExtraShared& TableClient::player::TournPlayerKickMsgExtraShared::operator=(TournPlayerKickMsgExtraShared&& _o)
{
	if(this != &_o)
	{
		socialToken = std::move(_o.socialToken);
		nextRecurringTournId = std::move(_o.nextRecurringTournId);
		nextSchedTourn = std::move(_o.nextSchedTourn);
		headBounty = std::move(_o.headBounty);
	}
	return *this;
}

#endif

void TableClient::player::TournPlayerKickMsgExtraShared::clear()
{
	socialToken.clear();
	nextRecurringTournId = 0;
	nextSchedTourn.clear();
	headBounty = 0;
}

bool TableClient::player::TournPlayerKickMsgExtraShared::equals(const TournPlayerKickMsgExtraShared& _o) const
{
	return Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		nextRecurringTournId == _o.nextRecurringTournId &&
		nextSchedTourn.equals(_o.nextSchedTourn) &&
		headBounty == _o.headBounty;
}

const char *TableClient::player::TournPlayerKickMsgExtraShared::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("token=");
	_buf.append(socialToken);
	_buf.append(',');
	_buf.append("nextId=");
	_buf.appendUint(nextRecurringTournId);
	if( nextRecurringTournId )
	{
		_buf.append(',');
		_buf.append("nextSchedTourn=");
		nextSchedTourn.toTraceString(_buf);
	}
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendUint(headBounty);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::TournPlayerKickMsgExtraShared::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("token", socialToken, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextId", nextRecurringTournId, _buf);
	if( nextRecurringTournId )
	{
		nextSchedTourn.toXmlString("nextSchedTourn", _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("headBounty", headBounty, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::TournPlayerKickMsgExtraShared::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("token") || _element.equals("socialToken"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
		}
		else if (_element.equals("nextId") || _element.equals("nextRecurringTournId"))
		{
			nextRecurringTournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextSchedTourn"))
		{
			if(!Atf::AtfTempl< TableCommon::P_ScheduledTournament >::FromXmlString(_value, nextSchedTourn)) return false;
		}
		else if (_element.equals("headBounty"))
		{
			headBounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::TournPlayerKickMsgExtraShared::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(socialToken);
	_msg.composeUINT32(nextRecurringTournId);
	if( nextRecurringTournId )
	{
		nextSchedTourn.composeMsg(_msg, _ignoreJSON);
	}
	_msg.composeUINT32(headBounty);
}

void TableClient::player::TournPlayerKickMsgExtraShared::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(socialToken);
	_parser.parseUINT32(nextRecurringTournId);
	if( nextRecurringTournId )
	{
		nextSchedTourn.parseMsg(_parser);
	}
	_parser.parseUINT32(headBounty);
}

const char *TableClient::player::TournPlayerKickMsgExtraShared::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("token", socialToken);
	_jsonstr.compose("nextId", nextRecurringTournId);
	if( nextRecurringTournId )
	{
		_jsonstr.compose("nextSchedTourn", nextSchedTourn);
	}
	_jsonstr.compose("headBounty", headBounty);
	return _buf.c_str();
}

void TableClient::player::TournPlayerKickMsgExtraShared::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("token", socialToken)) _jparser.parseByNameThrow("socialToken", socialToken);
	if(!_jparser.parseByName("nextId", nextRecurringTournId)) _jparser.parseByNameThrow("nextRecurringTournId", nextRecurringTournId);
	if( nextRecurringTournId )
	{
		_jparser.parseByNameThrow("nextSchedTourn", nextSchedTourn);
	}
	_jparser.parseByNameThrow("headBounty", headBounty);
}

/* static */ void TableClient::player::TournPlayerKickMsgExtraShared::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 nextRecurringTournId = 0;
	PString socialToken; if(!_jparser.validateByName("token", socialToken)) _jparser.validateByNameThrow("socialToken", socialToken);
	AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
	if(!_jparser.validateByName("nextId", nextRecurringTournId)) _jparser.validateByNameThrow("nextRecurringTournId", nextRecurringTournId);
	AtfValidator::validateInt(_descr, "nextRecurringTournId", nextRecurringTournId, _checker, __FILE__, __LINE__);
	if( nextRecurringTournId )
	{
		TableCommon::P_ScheduledTournament nextSchedTourn; _jparser.validateByNameThrow("nextSchedTourn", nextSchedTourn);
	}
	UINT32 headBounty; _jparser.validateByNameThrow("headBounty", headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::TournPlayerKickMsgExtraShared::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 nextRecurringTournId = 0;
	_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
	AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	_parser.parseUINT32(nextRecurringTournId);
	AtfValidator::validateInt(_descr, "nextRecurringTournId", nextRecurringTournId, _checker, __FILE__, __LINE__);
	if( nextRecurringTournId )
	{
		PString _descbuf;
		TableCommon::P_ScheduledTournament::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nextSchedTourn"), _fieldsWithUnparsedContent);
	}
	UINT32 headBounty; _parser.parseUINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSitKickMsgEx
//=================================================================

TableClient::player::TableSitKickMsgEx::TableSitKickMsgEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::TableSitKickMsgEx::TableSitKickMsgEx(TableSitKickMsgEx&& _o)
	: msgId(std::move(_o.msgId))
	, tpkes(std::move(_o.tpkes))
	, str_popup(std::move(_o.str_popup))
	, msgServiceBitMask(std::move(_o.msgServiceBitMask))
	, award(std::move(_o.award))
	, placeI(std::move(_o.placeI))
	, tournId(std::move(_o.tournId))
	, nextFlightTargetServer(std::move(_o.nextFlightTargetServer))
	, nextFlightTournName(std::move(_o.nextFlightTournName))
	, str_popup2(std::move(_o.str_popup2))
	, socialToken(std::move(_o.socialToken))
	, numMissedOrbits(std::move(_o.numMissedOrbits))
	, bounty(std::move(_o.bounty))
	, reEntryDeadline(std::move(_o.reEntryDeadline))
	, chips(std::move(_o.chips))
	, targetChips(std::move(_o.targetChips))
	, progressivePlusInitialBuyInTierId(std::move(_o.progressivePlusInitialBuyInTierId))
{
}

TableClient::player::TableSitKickMsgEx& TableClient::player::TableSitKickMsgEx::operator=(TableSitKickMsgEx&& _o)
{
	if(this != &_o)
	{
		msgId = std::move(_o.msgId);
		tpkes = std::move(_o.tpkes);
		str_popup = std::move(_o.str_popup);
		msgServiceBitMask = std::move(_o.msgServiceBitMask);
		award = std::move(_o.award);
		placeI = std::move(_o.placeI);
		tournId = std::move(_o.tournId);
		nextFlightTargetServer = std::move(_o.nextFlightTargetServer);
		nextFlightTournName = std::move(_o.nextFlightTournName);
		str_popup2 = std::move(_o.str_popup2);
		socialToken = std::move(_o.socialToken);
		numMissedOrbits = std::move(_o.numMissedOrbits);
		bounty = std::move(_o.bounty);
		reEntryDeadline = std::move(_o.reEntryDeadline);
		chips = std::move(_o.chips);
		targetChips = std::move(_o.targetChips);
		progressivePlusInitialBuyInTierId = std::move(_o.progressivePlusInitialBuyInTierId);
	}
	return *this;
}

#endif

void TableClient::player::TableSitKickMsgEx::clear()
{
	msgId = 0;
	tpkes.clear();
	str_popup.clear();
	msgServiceBitMask = 0;
	award = 0;
	placeI = 0;
	tournId = 0;
	nextFlightTargetServer.clear();
	nextFlightTournName.clear();
	str_popup2.clear();
	socialToken.clear();
	numMissedOrbits = 0;
	bounty = 0;
	reEntryDeadline.setNull();
	chips = 0;
	targetChips = 0;
	progressivePlusInitialBuyInTierId = 0;
}

bool TableClient::player::TableSitKickMsgEx::equals(const TableSitKickMsgEx& _o) const
{
	return msgId == _o.msgId &&
		tpkes.equals(_o.tpkes) &&
		Atf::atfPStringEquals(str_popup, _o.str_popup) &&
		msgServiceBitMask == _o.msgServiceBitMask &&
		award == _o.award &&
		placeI == _o.placeI &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(nextFlightTargetServer, _o.nextFlightTargetServer) &&
		nextFlightTournName.equals(_o.nextFlightTournName) &&
		Atf::atfPStringEquals(str_popup2, _o.str_popup2) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		numMissedOrbits == _o.numMissedOrbits &&
		bounty == _o.bounty &&
		reEntryDeadline.equals(_o.reEntryDeadline) &&
		chips == _o.chips &&
		targetChips == _o.targetChips &&
		progressivePlusInitialBuyInTierId == _o.progressivePlusInitialBuyInTierId;
}

const char *TableClient::player::TableSitKickMsgEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("msgId=");
	_buf.appendUint(msgId);
	if(msgId == ClientMsg_Tournmt_Winner)
	{
		_buf.append(',');
		_buf.append("tpkes=");
		tpkes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("str_popup=");
		_buf.append(str_popup);
		_buf.append(',');
		_buf.append("msgServiceBitMask=");
		_buf.appendUint(msgServiceBitMask);
		_buf.append(',');
		_buf.append("award=");
		_buf.appendInt(award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked)
	{
		_buf.append(',');
		_buf.append("placeI=");
		_buf.appendUint(placeI);
		_buf.append(',');
		_buf.append("tpkes=");
		tpkes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("str_popup=");
		_buf.append(str_popup);
		_buf.append(',');
		_buf.append("msgServiceBitMask=");
		_buf.appendUint(msgServiceBitMask);
		_buf.append(',');
		_buf.append("award=");
		_buf.appendInt(award);
	}
	else if(msgId == ClientMsg_Tournmt_Flight_Winner)
	{
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("nextFlightTargetServer=");
		_buf.append(nextFlightTargetServer);
		_buf.append(',');
		_buf.append("nextFlightTournName=");
		Atf::AtfTempl<I18nPString>::ToTraceString(_buf, nextFlightTournName);
		_buf.append(',');
		_buf.append("str_popup=");
		_buf.append(str_popup);
		_buf.append(',');
		_buf.append("msgServiceBitMask=");
		_buf.appendUint(msgServiceBitMask);
		_buf.append(',');
		_buf.append("award=");
		_buf.appendInt(award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked_Popup)
	{
		_buf.append(',');
		_buf.append("placeI=");
		_buf.appendUint(placeI);
		_buf.append(',');
		_buf.append("str_popup=");
		_buf.append(str_popup);
		_buf.append(',');
		_buf.append("tpkes=");
		tpkes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("str_popup2=");
		_buf.append(str_popup2);
		_buf.append(',');
		_buf.append("msgServiceBitMask=");
		_buf.appendUint(msgServiceBitMask);
		_buf.append(',');
		_buf.append("award=");
		_buf.appendInt(award);
	}
	else if(msgId == ClientMsg_Tournmt_Sag_Winner_Custom_Prize)
	{
		_buf.append(',');
		_buf.append("placeI=");
		_buf.appendUint(placeI);
		_buf.append(',');
		_buf.append("str_popup=");
		_buf.append(str_popup);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("str_popup2=");
		_buf.append(str_popup2);
		_buf.append(',');
		_buf.append("msgServiceBitMask=");
		_buf.appendUint(msgServiceBitMask);
		_buf.append(',');
		_buf.append("award=");
		_buf.appendInt(award);
	}
	else if(msgId == ClientMsg_Action_Kicked_Ante)
	{
		_buf.append(',');
		_buf.append("numMissedOrbits=");
		_buf.appendInt(numMissedOrbits);
	}
	else if(msgId == ClientMsg_Action_Kicked_BBlinds)
	{
		_buf.append(',');
		_buf.append("numMissedOrbits=");
		_buf.appendInt(numMissedOrbits);
	}
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt(bounty);
	_buf.append(',');
	_buf.append("reEntryDeadline=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, reEntryDeadline);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("targetChips=");
	_buf.appendInt(targetChips);
	_buf.append(',');
	_buf.append("progressivePlusInitialBuyInTierId=");
	_buf.appendUint(progressivePlusInitialBuyInTierId);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::TableSitKickMsgEx::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("msgId", msgId, _buf);
	if(msgId == ClientMsg_Tournmt_Winner)
	{
		tpkes.toXmlString("tpkes", _buf);
		Atf::XmlElement::encodeAsXmlElement("str_popup", str_popup, _buf);
		Atf::XmlElement::encodeAsXmlElement("msgServiceBitMask", msgServiceBitMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked)
	{
		Atf::XmlElement::encodeAsXmlElement("placeI", placeI, _buf);
		tpkes.toXmlString("tpkes", _buf);
		Atf::XmlElement::encodeAsXmlElement("str_popup", str_popup, _buf);
		Atf::XmlElement::encodeAsXmlElement("msgServiceBitMask", msgServiceBitMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	}
	else if(msgId == ClientMsg_Tournmt_Flight_Winner)
	{
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextFlightTargetServer", nextFlightTargetServer, _buf);
		Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "nextFlightTournName", nextFlightTournName);
		Atf::XmlElement::encodeAsXmlElement("str_popup", str_popup, _buf);
		Atf::XmlElement::encodeAsXmlElement("msgServiceBitMask", msgServiceBitMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked_Popup)
	{
		Atf::XmlElement::encodeAsXmlElement("placeI", placeI, _buf);
		Atf::XmlElement::encodeAsXmlElement("str_popup", str_popup, _buf);
		tpkes.toXmlString("tpkes", _buf);
		Atf::XmlElement::encodeAsXmlElement("str_popup2", str_popup2, _buf);
		Atf::XmlElement::encodeAsXmlElement("msgServiceBitMask", msgServiceBitMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	}
	else if(msgId == ClientMsg_Tournmt_Sag_Winner_Custom_Prize)
	{
		Atf::XmlElement::encodeAsXmlElement("placeI", placeI, _buf);
		Atf::XmlElement::encodeAsXmlElement("str_popup", str_popup, _buf);
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
		Atf::XmlElement::encodeAsXmlElement("str_popup2", str_popup2, _buf);
		Atf::XmlElement::encodeAsXmlElement("msgServiceBitMask", msgServiceBitMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	}
	else if(msgId == ClientMsg_Action_Kicked_Ante)
	{
		Atf::XmlElement::encodeAsXmlElement("numMissedOrbits", numMissedOrbits, _buf);
	}
	else if(msgId == ClientMsg_Action_Kicked_BBlinds)
	{
		Atf::XmlElement::encodeAsXmlElement("numMissedOrbits", numMissedOrbits, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "reEntryDeadline", reEntryDeadline);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetChips", targetChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::TableSitKickMsgEx::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("msgId"))
		{
			msgId = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tpkes"))
		{
			if(!Atf::AtfTempl< TournPlayerKickMsgExtraShared >::FromXmlString(_value, tpkes)) return false;
		}
		else if (_element.equals("str_popup"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, str_popup)) return false;
		}
		else if (_element.equals("msgServiceBitMask"))
		{
			msgServiceBitMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("award"))
		{
			award = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("placeI"))
		{
			placeI = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextFlightTargetServer"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, nextFlightTargetServer)) return false;
		}
		else if (_element.equals("nextFlightTournName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, nextFlightTournName);
		}
		else if (_element.equals("str_popup2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, str_popup2)) return false;
		}
		else if (_element.equals("socialToken"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
		}
		else if (_element.equals("numMissedOrbits"))
		{
			numMissedOrbits = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reEntryDeadline"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, reEntryDeadline);
		}
		else if (_element.equals("chips"))
		{
			chips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("targetChips"))
		{
			targetChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("progressivePlusInitialBuyInTierId"))
		{
			progressivePlusInitialBuyInTierId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::TableSitKickMsgEx::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(msgId);
	if(msgId == ClientMsg_Tournmt_Winner)
	{
		tpkes.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(str_popup);
		_msg.composeUINT32(msgServiceBitMask);
		_msg.composeINT32(award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked)
	{
		_msg.composeUINT32(placeI);
		tpkes.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(str_popup);
		_msg.composeUINT32(msgServiceBitMask);
		_msg.composeINT32(award);
	}
	else if(msgId == ClientMsg_Tournmt_Flight_Winner)
	{
		_msg.composeUINT32(tournId);
		_msg.composeString(nextFlightTargetServer);
		nextFlightTournName.compose(_msg);
		_msg.composeString(str_popup);
		_msg.composeUINT32(msgServiceBitMask);
		_msg.composeINT32(award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked_Popup)
	{
		_msg.composeUINT32(placeI);
		_msg.composeString(str_popup);
		tpkes.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(str_popup2);
		_msg.composeUINT32(msgServiceBitMask);
		_msg.composeINT32(award);
	}
	else if(msgId == ClientMsg_Tournmt_Sag_Winner_Custom_Prize)
	{
		_msg.composeUINT32(placeI);
		_msg.composeString(str_popup);
		_msg.composeString(socialToken);
		_msg.composeString(str_popup2);
		_msg.composeUINT32(msgServiceBitMask);
		_msg.composeINT32(award);
	}
	else if(msgId == ClientMsg_Action_Kicked_Ante)
	{
		_msg.composeINT32(numMissedOrbits);
	}
	else if(msgId == ClientMsg_Action_Kicked_BBlinds)
	{
		_msg.composeINT32(numMissedOrbits);
	}
	_msg.composeINT32(bounty);
	_msg.composeSrvTime(reEntryDeadline);
	_msg.composeINT32(chips);
	_msg.composeINT32(targetChips);
	_msg.composeUINT32(progressivePlusInitialBuyInTierId);
}

void TableClient::player::TableSitKickMsgEx::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(msgId);
	if(msgId == ClientMsg_Tournmt_Winner)
	{
		tpkes.parseMsg(_parser);
		_parser.parseStringP(str_popup);
		_parser.parseUINT32(msgServiceBitMask);
		_parser.parseINT32(award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked)
	{
		_parser.parseUINT32(placeI);
		tpkes.parseMsg(_parser);
		_parser.parseStringP(str_popup);
		_parser.parseUINT32(msgServiceBitMask);
		_parser.parseINT32(award);
	}
	else if(msgId == ClientMsg_Tournmt_Flight_Winner)
	{
		_parser.parseUINT32(tournId);
		_parser.parseStringP(nextFlightTargetServer);
		nextFlightTournName.parse(_parser);
		_parser.parseStringP(str_popup);
		_parser.parseUINT32(msgServiceBitMask);
		_parser.parseINT32(award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked_Popup)
	{
		_parser.parseUINT32(placeI);
		_parser.parseStringP(str_popup);
		tpkes.parseMsg(_parser);
		_parser.parseStringP(str_popup2);
		_parser.parseUINT32(msgServiceBitMask);
		_parser.parseINT32(award);
	}
	else if(msgId == ClientMsg_Tournmt_Sag_Winner_Custom_Prize)
	{
		_parser.parseUINT32(placeI);
		_parser.parseStringP(str_popup);
		_parser.parseStringP(socialToken);
		_parser.parseStringP(str_popup2);
		_parser.parseUINT32(msgServiceBitMask);
		_parser.parseINT32(award);
	}
	else if(msgId == ClientMsg_Action_Kicked_Ante)
	{
		_parser.parseINT32(numMissedOrbits);
	}
	else if(msgId == ClientMsg_Action_Kicked_BBlinds)
	{
		_parser.parseINT32(numMissedOrbits);
	}
	_parser.parseINT32(bounty);
	if(_parser.parseEnded()) return;
	_parser.parseSrvTime(reEntryDeadline);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(chips);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(targetChips);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(progressivePlusInitialBuyInTierId);
}

const char *TableClient::player::TableSitKickMsgEx::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("msgId", msgId);
	if(msgId == ClientMsg_Tournmt_Winner)
	{
		_jsonstr.compose("tpkes", tpkes);
		_jsonstr.compose("str_popup", str_popup);
		_jsonstr.compose("msgServiceBitMask", msgServiceBitMask);
		_jsonstr.compose("award", award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked)
	{
		_jsonstr.compose("placeI", placeI);
		_jsonstr.compose("tpkes", tpkes);
		_jsonstr.compose("str_popup", str_popup);
		_jsonstr.compose("msgServiceBitMask", msgServiceBitMask);
		_jsonstr.compose("award", award);
	}
	else if(msgId == ClientMsg_Tournmt_Flight_Winner)
	{
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("nextFlightTargetServer", nextFlightTargetServer);
		_jsonstr.compose("nextFlightTournName", nextFlightTournName);
		_jsonstr.compose("str_popup", str_popup);
		_jsonstr.compose("msgServiceBitMask", msgServiceBitMask);
		_jsonstr.compose("award", award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked_Popup)
	{
		_jsonstr.compose("placeI", placeI);
		_jsonstr.compose("str_popup", str_popup);
		_jsonstr.compose("tpkes", tpkes);
		_jsonstr.compose("str_popup2", str_popup2);
		_jsonstr.compose("msgServiceBitMask", msgServiceBitMask);
		_jsonstr.compose("award", award);
	}
	else if(msgId == ClientMsg_Tournmt_Sag_Winner_Custom_Prize)
	{
		_jsonstr.compose("placeI", placeI);
		_jsonstr.compose("str_popup", str_popup);
		_jsonstr.compose("socialToken", socialToken);
		_jsonstr.compose("str_popup2", str_popup2);
		_jsonstr.compose("msgServiceBitMask", msgServiceBitMask);
		_jsonstr.compose("award", award);
	}
	else if(msgId == ClientMsg_Action_Kicked_Ante)
	{
		_jsonstr.compose("numMissedOrbits", numMissedOrbits);
	}
	else if(msgId == ClientMsg_Action_Kicked_BBlinds)
	{
		_jsonstr.compose("numMissedOrbits", numMissedOrbits);
	}
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("reEntryDeadline", reEntryDeadline);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("targetChips", targetChips);
	_jsonstr.compose("progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId);
	return _buf.c_str();
}

void TableClient::player::TableSitKickMsgEx::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("msgId", msgId);
	if(msgId == ClientMsg_Tournmt_Winner)
	{
		_jparser.parseByNameThrow("tpkes", tpkes);
		_jparser.parseByNameThrow("str_popup", str_popup);
		_jparser.parseByNameThrow("msgServiceBitMask", msgServiceBitMask);
		_jparser.parseByNameThrow("award", award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked)
	{
		_jparser.parseByNameThrow("placeI", placeI);
		_jparser.parseByNameThrow("tpkes", tpkes);
		_jparser.parseByNameThrow("str_popup", str_popup);
		_jparser.parseByNameThrow("msgServiceBitMask", msgServiceBitMask);
		_jparser.parseByNameThrow("award", award);
	}
	else if(msgId == ClientMsg_Tournmt_Flight_Winner)
	{
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("nextFlightTargetServer", nextFlightTargetServer);
		_jparser.parseByNameThrow("nextFlightTournName", nextFlightTournName);
		_jparser.parseByNameThrow("str_popup", str_popup);
		_jparser.parseByNameThrow("msgServiceBitMask", msgServiceBitMask);
		_jparser.parseByNameThrow("award", award);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked_Popup)
	{
		_jparser.parseByNameThrow("placeI", placeI);
		_jparser.parseByNameThrow("str_popup", str_popup);
		_jparser.parseByNameThrow("tpkes", tpkes);
		_jparser.parseByNameThrow("str_popup2", str_popup2);
		_jparser.parseByNameThrow("msgServiceBitMask", msgServiceBitMask);
		_jparser.parseByNameThrow("award", award);
	}
	else if(msgId == ClientMsg_Tournmt_Sag_Winner_Custom_Prize)
	{
		_jparser.parseByNameThrow("placeI", placeI);
		_jparser.parseByNameThrow("str_popup", str_popup);
		_jparser.parseByNameThrow("socialToken", socialToken);
		_jparser.parseByNameThrow("str_popup2", str_popup2);
		_jparser.parseByNameThrow("msgServiceBitMask", msgServiceBitMask);
		_jparser.parseByNameThrow("award", award);
	}
	else if(msgId == ClientMsg_Action_Kicked_Ante)
	{
		_jparser.parseByNameThrow("numMissedOrbits", numMissedOrbits);
	}
	else if(msgId == ClientMsg_Action_Kicked_BBlinds)
	{
		_jparser.parseByNameThrow("numMissedOrbits", numMissedOrbits);
	}
	_jparser.parseByNameThrow("bounty", bounty);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("reEntryDeadline", reEntryDeadline);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("chips", chips);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("targetChips", targetChips);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId);
}

/* static */ void TableClient::player::TableSitKickMsgEx::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 msgId = 0;
	_jparser.validateByNameThrow("msgId", msgId);
	AtfValidator::validateInt(_descr, "msgId", msgId, _checker, __FILE__, __LINE__);
	if(msgId == ClientMsg_Tournmt_Winner)
	{
		TournPlayerKickMsgExtraShared tpkes; _jparser.validateByNameThrow("tpkes", tpkes);
		PString str_popup; _jparser.validateByNameThrow("str_popup", str_popup);
		AtfValidator::validateInt(_descr, "str_popup", str_popup.length(), _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _jparser.validateByNameThrow("msgServiceBitMask", msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _jparser.validateByNameThrow("award", award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked)
	{
		UINT32 placeI; _jparser.validateByNameThrow("placeI", placeI);
		AtfValidator::validateInt(_descr, "placeI", placeI, _checker, __FILE__, __LINE__);
		TournPlayerKickMsgExtraShared tpkes; _jparser.validateByNameThrow("tpkes", tpkes);
		PString str_popup; _jparser.validateByNameThrow("str_popup", str_popup);
		AtfValidator::validateInt(_descr, "str_popup", str_popup.length(), _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _jparser.validateByNameThrow("msgServiceBitMask", msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _jparser.validateByNameThrow("award", award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Tournmt_Flight_Winner)
	{
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString nextFlightTargetServer; _jparser.validateByNameThrow("nextFlightTargetServer", nextFlightTargetServer);
		AtfValidator::validateInt(_descr, "nextFlightTargetServer", nextFlightTargetServer.length(), _checker, __FILE__, __LINE__);
		I18nPString nextFlightTournName; _jparser.validateByNameThrow("nextFlightTournName", nextFlightTournName);
		PString str_popup; _jparser.validateByNameThrow("str_popup", str_popup);
		AtfValidator::validateInt(_descr, "str_popup", str_popup.length(), _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _jparser.validateByNameThrow("msgServiceBitMask", msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _jparser.validateByNameThrow("award", award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked_Popup)
	{
		UINT32 placeI; _jparser.validateByNameThrow("placeI", placeI);
		AtfValidator::validateInt(_descr, "placeI", placeI, _checker, __FILE__, __LINE__);
		PString str_popup; _jparser.validateByNameThrow("str_popup", str_popup);
		AtfValidator::validateInt(_descr, "str_popup", str_popup.length(), _checker, __FILE__, __LINE__);
		TournPlayerKickMsgExtraShared tpkes; _jparser.validateByNameThrow("tpkes", tpkes);
		PString str_popup2; _jparser.validateByNameThrow("str_popup2", str_popup2);
		AtfValidator::validateInt(_descr, "str_popup2", str_popup2.length(), _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _jparser.validateByNameThrow("msgServiceBitMask", msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _jparser.validateByNameThrow("award", award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Tournmt_Sag_Winner_Custom_Prize)
	{
		UINT32 placeI; _jparser.validateByNameThrow("placeI", placeI);
		AtfValidator::validateInt(_descr, "placeI", placeI, _checker, __FILE__, __LINE__);
		PString str_popup; _jparser.validateByNameThrow("str_popup", str_popup);
		AtfValidator::validateInt(_descr, "str_popup", str_popup.length(), _checker, __FILE__, __LINE__);
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
		PString str_popup2; _jparser.validateByNameThrow("str_popup2", str_popup2);
		AtfValidator::validateInt(_descr, "str_popup2", str_popup2.length(), _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _jparser.validateByNameThrow("msgServiceBitMask", msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _jparser.validateByNameThrow("award", award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Action_Kicked_Ante)
	{
		INT32 numMissedOrbits; _jparser.validateByNameThrow("numMissedOrbits", numMissedOrbits);
		AtfValidator::validateInt(_descr, "numMissedOrbits", numMissedOrbits, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Action_Kicked_BBlinds)
	{
		INT32 numMissedOrbits; _jparser.validateByNameThrow("numMissedOrbits", numMissedOrbits);
		AtfValidator::validateInt(_descr, "numMissedOrbits", numMissedOrbits, _checker, __FILE__, __LINE__);
	}
	INT32 bounty; _jparser.validateByNameThrow("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	SrvTime reEntryDeadline; _jparser.validateByNameThrow("reEntryDeadline", reEntryDeadline);
	AtfValidator::validateSrvDateTime(_descr, "reEntryDeadline", reEntryDeadline, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 targetChips; _jparser.validateByNameThrow("targetChips", targetChips);
	AtfValidator::validateInt(_descr, "targetChips", targetChips, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 progressivePlusInitialBuyInTierId; _jparser.validateByNameThrow("progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId);
	AtfValidator::validateInt(_descr, "progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::TableSitKickMsgEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT16 msgId = 0;
	_parser.parseUINT16(msgId);
	AtfValidator::validateInt(_descr, "msgId", msgId, _checker, __FILE__, __LINE__);
	if(msgId == ClientMsg_Tournmt_Winner)
	{
		PString _descbuf;
		TournPlayerKickMsgExtraShared::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tpkes"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "str_popup"); size_t szStr_popup = strlen(_dummy);
		AtfValidator::validateInt(_descr, "str_popup", szStr_popup, _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _parser.parseUINT32(msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _parser.parseINT32(award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked)
	{
		UINT32 placeI; _parser.parseUINT32(placeI);
		AtfValidator::validateInt(_descr, "placeI", placeI, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournPlayerKickMsgExtraShared::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tpkes"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "str_popup"); size_t szStr_popup = strlen(_dummy);
		AtfValidator::validateInt(_descr, "str_popup", szStr_popup, _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _parser.parseUINT32(msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _parser.parseINT32(award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Tournmt_Flight_Winner)
	{
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "nextFlightTargetServer"); size_t szNextFlightTargetServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "nextFlightTargetServer", szNextFlightTargetServer, _checker, __FILE__, __LINE__);
		I18nPString nextFlightTournName; nextFlightTournName.parse(_parser);
		_parser.parseStringN(_dummy, 0, "str_popup"); size_t szStr_popup = strlen(_dummy);
		AtfValidator::validateInt(_descr, "str_popup", szStr_popup, _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _parser.parseUINT32(msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _parser.parseINT32(award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Tournmt_Kicked_Popup)
	{
		UINT32 placeI; _parser.parseUINT32(placeI);
		AtfValidator::validateInt(_descr, "placeI", placeI, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "str_popup"); size_t szStr_popup = strlen(_dummy);
		AtfValidator::validateInt(_descr, "str_popup", szStr_popup, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournPlayerKickMsgExtraShared::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tpkes"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "str_popup2"); size_t szStr_popup2 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "str_popup2", szStr_popup2, _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _parser.parseUINT32(msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _parser.parseINT32(award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Tournmt_Sag_Winner_Custom_Prize)
	{
		UINT32 placeI; _parser.parseUINT32(placeI);
		AtfValidator::validateInt(_descr, "placeI", placeI, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "str_popup"); size_t szStr_popup = strlen(_dummy);
		AtfValidator::validateInt(_descr, "str_popup", szStr_popup, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "str_popup2"); size_t szStr_popup2 = strlen(_dummy);
		AtfValidator::validateInt(_descr, "str_popup2", szStr_popup2, _checker, __FILE__, __LINE__);
		UINT32 msgServiceBitMask; _parser.parseUINT32(msgServiceBitMask);
		AtfValidator::validateInt(_descr, "msgServiceBitMask", msgServiceBitMask, _checker, __FILE__, __LINE__);
		INT32 award; _parser.parseINT32(award);
		AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Action_Kicked_Ante)
	{
		INT32 numMissedOrbits; _parser.parseINT32(numMissedOrbits);
		AtfValidator::validateInt(_descr, "numMissedOrbits", numMissedOrbits, _checker, __FILE__, __LINE__);
	}
	else if(msgId == ClientMsg_Action_Kicked_BBlinds)
	{
		INT32 numMissedOrbits; _parser.parseINT32(numMissedOrbits);
		AtfValidator::validateInt(_descr, "numMissedOrbits", numMissedOrbits, _checker, __FILE__, __LINE__);
	}
	INT32 bounty; _parser.parseINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	SrvTime reEntryDeadline; _parser.parseSrvTime(reEntryDeadline);
	AtfValidator::validateSrvDateTime(_descr, "reEntryDeadline", reEntryDeadline, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 chips; _parser.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 targetChips; _parser.parseINT32(targetChips);
	AtfValidator::validateInt(_descr, "targetChips", targetChips, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 progressivePlusInitialBuyInTierId; _parser.parseUINT32(progressivePlusInitialBuyInTierId);
	AtfValidator::validateInt(_descr, "progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_TABLE_SIT_KICK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SIT_KICK::Protocol_MSG_TABLE_SIT_KICK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_SIT_KICK::Protocol_MSG_TABLE_SIT_KICK(Protocol_MSG_TABLE_SIT_KICK&& _o)
	: kickstr(std::move(_o.kickstr))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, totalBetInfo(std::move(_o.totalBetInfo))
	, forceCloseTable(std::move(_o.forceCloseTable))
{
}

TableClient::player::Protocol_MSG_TABLE_SIT_KICK& TableClient::player::Protocol_MSG_TABLE_SIT_KICK::operator=(Protocol_MSG_TABLE_SIT_KICK&& _o)
{
	if(this != &_o)
	{
		kickstr = std::move(_o.kickstr);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		totalBetInfo = std::move(_o.totalBetInfo);
		forceCloseTable = std::move(_o.forceCloseTable);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_SIT_KICK::clear()
{
	kickstr.clear();
	clientMsg_txtEx.clear();
	totalBetInfo.clear();
	forceCloseTable = false;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT_KICK::equals(const Protocol_MSG_TABLE_SIT_KICK& _o) const
{
	return Atf::atfPStringEquals(kickstr, _o.kickstr) &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		totalBetInfo.equals(_o.totalBetInfo) &&
		forceCloseTable == _o.forceCloseTable;
}

bool TableClient::player::Protocol_MSG_TABLE_SIT_KICK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SIT_KICK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SIT_KICK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT_KICK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SIT_KICK).append(")");
	_buf.append(',');
	_buf.append("kickstr=");
	_buf.append(kickstr);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("totalBetInfo=");
	totalBetInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("forceCloseTable=");
	_buf.appendUint(forceCloseTable);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT_KICK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT_KICK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SIT_KICK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("kickstr", kickstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	totalBetInfo.toXmlString("totalBetInfo", _buf);
	Atf::XmlElement::encodeAsXmlElement("forceCloseTable", forceCloseTable, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SIT_KICK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("kickstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, kickstr)) return false;
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("totalBetInfo"))
			{
				if(!Atf::AtfTempl< TotalBetInfo >::FromXmlString(_value, totalBetInfo)) return false;
			}
			else if (_element.equals("forceCloseTable"))
			{
				forceCloseTable = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SIT_KICK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(kickstr);
	_msg.composeMsgBody(clientMsg_txtEx);
	totalBetInfo.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(forceCloseTable);
}

void TableClient::player::Protocol_MSG_TABLE_SIT_KICK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(kickstr);
	_parser.parseMsgBody(clientMsg_txtEx);
	totalBetInfo.parseMsg(_parser);
	_parser.parseBOOL(forceCloseTable);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT_KICK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("kickstr", kickstr);
	_jsonstr.compose("m", clientMsg_txtEx);
	_jsonstr.compose("totalBetInfo", totalBetInfo);
	_jsonstr.compose("forceCloseTable", forceCloseTable);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SIT_KICK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("kickstr", kickstr);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	_jparser.parseByNameThrow("totalBetInfo", totalBetInfo);
	_jparser.parseByNameThrow("forceCloseTable", forceCloseTable);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT_KICK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT_KICK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString kickstr; _jparser.validateByNameThrow("kickstr", kickstr);
	AtfValidator::validateInt(_descr, "kickstr", kickstr.length(), _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	TotalBetInfo totalBetInfo; _jparser.validateByNameThrow("totalBetInfo", totalBetInfo);
	bool forceCloseTable; _jparser.validateByNameThrow("forceCloseTable", forceCloseTable);
	AtfValidator::validateInt(_descr, "forceCloseTable", forceCloseTable, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT_KICK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT_KICK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "kickstr"); size_t szKickstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "kickstr", szKickstr, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TotalBetInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("totalBetInfo"), _fieldsWithUnparsedContent);
	bool forceCloseTable; _parser.parseBOOL(forceCloseTable);
	AtfValidator::validateInt(_descr, "forceCloseTable", forceCloseTable, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SIT2_KICK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::Protocol_MSG_TABLE_SIT2_KICK()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::Protocol_MSG_TABLE_SIT2_KICK(Protocol_MSG_TABLE_SIT2_KICK&& _o)
	: kickstr(std::move(_o.kickstr))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
{
}

TableClient::player::Protocol_MSG_TABLE_SIT2_KICK& TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::operator=(Protocol_MSG_TABLE_SIT2_KICK&& _o)
{
	if(this != &_o)
	{
		kickstr = std::move(_o.kickstr);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::clear()
{
	kickstr.clear();
	clientMsg_txtEx.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::equals(const Protocol_MSG_TABLE_SIT2_KICK& _o) const
{
	return Atf::atfPStringEquals(kickstr, _o.kickstr) &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx);
}

bool TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SIT2_KICK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SIT2_KICK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SIT2_KICK).append(")");
	_buf.append(',');
	_buf.append("kickstr=");
	_buf.append(kickstr);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SIT2_KICK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("kickstr", kickstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("kickstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, kickstr)) return false;
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(kickstr);
	_msg.composeMsgBody(clientMsg_txtEx);
}

void TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(kickstr);
	_parser.parseMsgBody(clientMsg_txtEx);
}

const char *TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("kickstr", kickstr);
	_jsonstr.compose("m", clientMsg_txtEx);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("kickstr", kickstr);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT2_KICK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString kickstr; _jparser.validateByNameThrow("kickstr", kickstr);
	AtfValidator::validateInt(_descr, "kickstr", kickstr.length(), _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SIT2_KICK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SIT2_KICK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "kickstr"); size_t szKickstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "kickstr", szKickstr, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_MTT_CHANGETABLE
//=================================================================

TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::Protocol_MSG_TABLE_MTT_CHANGETABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::Protocol_MSG_TABLE_MTT_CHANGETABLE(Protocol_MSG_TABLE_MTT_CHANGETABLE&& _o)
	: errcode(std::move(_o.errcode))
	, msg(std::move(_o.msg))
{
}

TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE& TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::operator=(Protocol_MSG_TABLE_MTT_CHANGETABLE&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		msg = std::move(_o.msg);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::clear()
{
	errcode = 0;
	msg.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::equals(const Protocol_MSG_TABLE_MTT_CHANGETABLE& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(msg, _o.msg);
}

bool TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_MTT_CHANGETABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_MTT_CHANGETABLE*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_MTT_CHANGETABLE).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	_buf.append(',');
	_buf.append("msg=");
	_buf.append(msg);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_MTT_CHANGETABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	Atf::XmlElement::encodeAsXmlElement("msg", msg, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("msg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, msg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	_msg.composeString(msg);
}

void TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	_parser.parseStringP(msg);
}

const char *TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	_jsonstr.compose("msg", msg);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	_jparser.parseByNameThrow("msg", msg);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_MTT_CHANGETABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode; _jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	PString msg; _jparser.validateByNameThrow("msg", msg);
	AtfValidator::validateInt(_descr, "msg", msg.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_MTT_CHANGETABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_MTT_CHANGETABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode; _parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "msg"); size_t szMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "msg", szMsg, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_ADMIN_INFO
//=================================================================

TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::Protocol_MSG_TABLE_ADMIN_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::Protocol_MSG_TABLE_ADMIN_INFO(Protocol_MSG_TABLE_ADMIN_INFO&& _o)
	: errstr(std::move(_o.errstr))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
{
}

TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO& TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::operator=(Protocol_MSG_TABLE_ADMIN_INFO&& _o)
{
	if(this != &_o)
	{
		errstr = std::move(_o.errstr);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::clear()
{
	errstr.clear();
	clientMsg_txtEx.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::equals(const Protocol_MSG_TABLE_ADMIN_INFO& _o) const
{
	return Atf::atfPStringEquals(errstr, _o.errstr) &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx);
}

bool TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_ADMIN_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_ADMIN_INFO*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_ADMIN_INFO).append(")");
	_buf.append(',');
	_buf.append("errstr=");
	_buf.append(errstr);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_ADMIN_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(errstr);
	_msg.composeMsgBody(clientMsg_txtEx);
}

void TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(errstr);
	_parser.parseMsgBody(clientMsg_txtEx);
}

const char *TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errstr", errstr);
	_jsonstr.compose("m", clientMsg_txtEx);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errstr", errstr);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADMIN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString errstr; _jparser.validateByNameThrow("errstr", errstr);
	AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_ADMIN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_ADMIN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SAGMAX_USER_DRAW
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::Protocol_MSG_TABLE_SAGMAX_USER_DRAW()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::clear()
{
	action = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::equals(const Protocol_MSG_TABLE_SAGMAX_USER_DRAW& _o) const
{
	return action == _o.action;
}

bool TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SAGMAX_USER_DRAW != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SAGMAX_USER_DRAW*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SAGMAX_USER_DRAW).append(")");
	_buf.append(',');
	_buf.append("a=");
	_buf.appendInt(action);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SAGMAX_USER_DRAW).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("a", action, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("a") || _element.equals("action"))
			{
				action = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(action);
}

void TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(action);
}

const char *TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("a", action);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("a", action)) _jparser.parseByNameThrow("action", action);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SAGMAX_USER_DRAW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 action; if(!_jparser.validateByName("a", action)) _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SAGMAX_USER_DRAW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 action; _parser.parseINT32(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SITTING_STATUS
//=================================================================

TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::Protocol_MSG_TABLE_SITTING_STATUS()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::clear()
{
	sittingStatus = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::equals(const Protocol_MSG_TABLE_SITTING_STATUS& _o) const
{
	return sittingStatus == _o.sittingStatus;
}

bool TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SITTING_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SITTING_STATUS*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SITTING_STATUS).append(")");
	_buf.append(',');
	_buf.append("ss=");
	_buf.appendUint(sittingStatus);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SITTING_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("ss", sittingStatus, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("ss") || _element.equals("sittingStatus"))
			{
				sittingStatus = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(sittingStatus);
}

void TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(sittingStatus);
}

const char *TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ss", sittingStatus);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("ss", sittingStatus)) _jparser.parseByNameThrow("sittingStatus", sittingStatus);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITTING_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE sittingStatus; if(!_jparser.validateByName("ss", sittingStatus)) _jparser.validateByNameThrow("sittingStatus", sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_SITTING_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SITTING_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE sittingStatus; _parser.parseBYTE(sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_BOUNTY_GREETINGS
//=================================================================

TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::Protocol_MSG_TABLE_BOUNTY_GREETINGS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::Protocol_MSG_TABLE_BOUNTY_GREETINGS(Protocol_MSG_TABLE_BOUNTY_GREETINGS&& _o)
	: vec(std::move(_o.vec))
	, goldenSngBountyStub(std::move(_o.goldenSngBountyStub))
{
}

TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS& TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::operator=(Protocol_MSG_TABLE_BOUNTY_GREETINGS&& _o)
{
	if(this != &_o)
	{
		vec = std::move(_o.vec);
		goldenSngBountyStub = std::move(_o.goldenSngBountyStub);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::clear()
{
	vec.clear();
	goldenSngBountyStub = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::equals(const Protocol_MSG_TABLE_BOUNTY_GREETINGS& _o) const
{
	return vec.equals(_o.vec) &&
		goldenSngBountyStub == _o.goldenSngBountyStub;
}

bool TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_BOUNTY_GREETINGS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_BOUNTY_GREETINGS*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_BOUNTY_GREETINGS).append(")");
	_buf.append(',');
	_buf.append("vec=");
	vec.toTraceString(_buf);
	_buf.append(',');
	_buf.append("goldenSngBountyStub=");
	_buf.appendUint(goldenSngBountyStub);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_BOUNTY_GREETINGS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	vec.toXmlString("vec", _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSngBountyStub", goldenSngBountyStub, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("vec"))
			{
				if(!Atf::AtfTempl< Atf::AtfVector0< P_BOUNTY_GREETINGS, 4 > >::FromXmlString(_value, vec)) return false;
			}
			else if (_element.equals("goldenSngBountyStub"))
			{
				goldenSngBountyStub = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	vec.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(goldenSngBountyStub);
}

void TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::parseMsg(CommMsgParser& _parser)
{
	vec.parseMsg(_parser);
	_parser.parseUINT32(goldenSngBountyStub);
}

const char *TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("vec", vec);
	_jsonstr.compose("goldenSngBountyStub", goldenSngBountyStub);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("vec", vec);
	_jparser.parseByNameThrow("goldenSngBountyStub", goldenSngBountyStub);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_BOUNTY_GREETINGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< P_BOUNTY_GREETINGS > vec; _jparser.validateByNameThrow("vec", vec);
	AtfValidator::validateInt(_descr, "vec", vec.size(), _checker, __FILE__, __LINE__);
	UINT32 goldenSngBountyStub; _jparser.validateByNameThrow("goldenSngBountyStub", goldenSngBountyStub);
	AtfValidator::validateInt(_descr, "goldenSngBountyStub", goldenSngBountyStub, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_BOUNTY_GREETINGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szVec = Atf::AtfVector0< P_BOUNTY_GREETINGS, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("vec"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "vec", szVec, _checker, __FILE__, __LINE__);
	UINT32 goldenSngBountyStub; _parser.parseUINT32(goldenSngBountyStub);
	AtfValidator::validateInt(_descr, "goldenSngBountyStub", goldenSngBountyStub, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_START_CAMPING_PREVENTION
//=================================================================

TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::Protocol_MSG_TABLE_START_CAMPING_PREVENTION()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::clear()
{
	campingTimeOut = 0;
	sittingStatus = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::equals(const Protocol_MSG_TABLE_START_CAMPING_PREVENTION& _o) const
{
	return campingTimeOut == _o.campingTimeOut &&
		sittingStatus == _o.sittingStatus;
}

bool TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_START_CAMPING_PREVENTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_START_CAMPING_PREVENTION*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_START_CAMPING_PREVENTION).append(")");
	_buf.append(',');
	_buf.append("campingTO=");
	_buf.appendUint(campingTimeOut);
	_buf.append(',');
	_buf.append("ss=");
	_buf.appendUint(sittingStatus);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_START_CAMPING_PREVENTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("campingTO", campingTimeOut, _buf);
	Atf::XmlElement::encodeAsXmlElement("ss", sittingStatus, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("campingTO") || _element.equals("campingTimeOut"))
			{
				campingTimeOut = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ss") || _element.equals("sittingStatus"))
			{
				sittingStatus = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(campingTimeOut);
	_msg.composeBYTE(sittingStatus);
}

void TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(campingTimeOut);
	_parser.parseBYTE(sittingStatus);
}

const char *TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("campingTO", campingTimeOut);
	_jsonstr.compose("ss", sittingStatus);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("campingTO", campingTimeOut)) _jparser.parseByNameThrow("campingTimeOut", campingTimeOut);
	if(!_jparser.parseByName("ss", sittingStatus)) _jparser.parseByNameThrow("sittingStatus", sittingStatus);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_START_CAMPING_PREVENTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 campingTimeOut; if(!_jparser.validateByName("campingTO", campingTimeOut)) _jparser.validateByNameThrow("campingTimeOut", campingTimeOut);
	AtfValidator::validateInt(_descr, "campingTimeOut", campingTimeOut, _checker, __FILE__, __LINE__);
	BYTE sittingStatus; if(!_jparser.validateByName("ss", sittingStatus)) _jparser.validateByNameThrow("sittingStatus", sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_START_CAMPING_PREVENTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT16 campingTimeOut; _parser.parseUINT16(campingTimeOut);
	AtfValidator::validateInt(_descr, "campingTimeOut", campingTimeOut, _checker, __FILE__, __LINE__);
	BYTE sittingStatus; _parser.parseBYTE(sittingStatus);
	AtfValidator::validateInt(_descr, "sittingStatus", sittingStatus, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::clear()
{
	stacksReloaded = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::equals(const Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY& _o) const
{
	return stacksReloaded == _o.stacksReloaded;
}

bool TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY).append(")");
	_buf.append(',');
	_buf.append("stacksReloaded=");
	_buf.appendUint(stacksReloaded);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("stacksReloaded", stacksReloaded, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("stacksReloaded"))
			{
				stacksReloaded = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(stacksReloaded);
}

void TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(stacksReloaded);
}

const char *TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("stacksReloaded", stacksReloaded);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stacksReloaded", stacksReloaded);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 stacksReloaded; _jparser.validateByNameThrow("stacksReloaded", stacksReloaded);
	AtfValidator::validateInt(_descr, "stacksReloaded", stacksReloaded, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 stacksReloaded; _parser.parseUINT32(stacksReloaded);
	AtfValidator::validateInt(_descr, "stacksReloaded", stacksReloaded, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS
//=================================================================

TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::clear()
{
	unusedStacks = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::equals(const Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS& _o) const
{
	return unusedStacks == _o.unusedStacks;
}

bool TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS).append(")");
	_buf.append(',');
	_buf.append("unusedStacks=");
	_buf.appendInt(unusedStacks);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("unusedStacks", unusedStacks, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("unusedStacks"))
			{
				unusedStacks = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(unusedStacks);
}

void TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(unusedStacks);
}

const char *TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("unusedStacks", unusedStacks);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("unusedStacks", unusedStacks);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 unusedStacks; _jparser.validateByNameThrow("unusedStacks", unusedStacks);
	AtfValidator::validateInt(_descr, "unusedStacks", unusedStacks, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 unusedStacks; _parser.parseINT32(unusedStacks);
	AtfValidator::validateInt(_descr, "unusedStacks", unusedStacks, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_NSTACK_RELOAD
//=================================================================

TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::Protocol_MSG_TABLE_NSTACK_RELOAD()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::clear()
{
	reqStacks = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::equals(const Protocol_MSG_TABLE_NSTACK_RELOAD& _o) const
{
	return reqStacks == _o.reqStacks;
}

bool TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_NSTACK_RELOAD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_NSTACK_RELOAD*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_NSTACK_RELOAD).append(")");
	_buf.append(',');
	_buf.append("s=");
	_buf.appendUint(reqStacks);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_NSTACK_RELOAD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("s", reqStacks, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("s") || _element.equals("reqStacks"))
			{
				reqStacks = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reqStacks);
}

void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reqStacks);
}

const char *TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", reqStacks);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", reqStacks)) _jparser.parseByNameThrow("reqStacks", reqStacks);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_NSTACK_RELOAD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 reqStacks; if(!_jparser.validateByName("s", reqStacks)) _jparser.validateByNameThrow("reqStacks", reqStacks);
	AtfValidator::validateIntMax(_descr, "reqStacks", reqStacks, 16, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_NSTACK_RELOAD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 reqStacks; _parser.parseUINT32(reqStacks);
	AtfValidator::validateIntMax(_descr, "reqStacks", reqStacks, 16, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY(Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errDesc(std::move(_o.errDesc))
	, errMsgBody(std::move(_o.errMsgBody))
	, unusedStacks(std::move(_o.unusedStacks))
{
}

TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY& TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::operator=(Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errDesc = std::move(_o.errDesc);
		errMsgBody = std::move(_o.errMsgBody);
		unusedStacks = std::move(_o.unusedStacks);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::clear()
{
	errcode = 0;
	errDesc.clear();
	errMsgBody.clear();
	unusedStacks = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::equals(const Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		errMsgBody.equals(_o.errMsgBody) &&
		unusedStacks == _o.unusedStacks;
}

bool TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_NSTACK_RELOAD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_NSTACK_RELOAD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	if(errcode)
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
		_buf.append(',');
		_buf.append("errMsgBody=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(errMsgBody, _buf); _buf.append('}');
	}
	else
	{
		_buf.append(',');
		_buf.append("unusedStacks=");
		_buf.appendInt(unusedStacks);
	}
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_NSTACK_RELOAD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	if(errcode)
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
		Atf::XmlElement::encodeAsXmlElement("errMsgBody", errMsgBody, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("unusedStacks", unusedStacks, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("errMsgBody"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, errMsgBody)) return false;
			}
			else if (_element.equals("unusedStacks"))
			{
				unusedStacks = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	if(errcode)
	{
		_msg.composeString(errDesc);
		_msg.composeMsgBody(errMsgBody);
	}
	else
	{
		_msg.composeINT32(unusedStacks);
	}
}

void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	if(errcode)
	{
		_parser.parseStringP(errDesc);
		_parser.parseMsgBody(errMsgBody);
	}
	else
	{
		_parser.parseINT32(unusedStacks);
	}
}

const char *TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	if(errcode)
	{
		_jsonstr.compose("errDesc", errDesc);
		_jsonstr.compose("errMsgBody", errMsgBody);
	}
	else
	{
		_jsonstr.compose("unusedStacks", unusedStacks);
	}
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	if(errcode)
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
		_jparser.parseByNameThrow("errMsgBody", errMsgBody);
	}
	else
	{
		_jparser.parseByNameThrow("unusedStacks", unusedStacks);
	}
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_NSTACK_RELOAD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode = 0;
	_jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if(errcode)
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody errMsgBody; _jparser.validateByNameThrow("errMsgBody", errMsgBody);
		AtfValidator::validateInt(_descr, "errMsgBody", errMsgBody._size(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 unusedStacks; _jparser.validateByNameThrow("unusedStacks", unusedStacks);
		AtfValidator::validateInt(_descr, "unusedStacks", unusedStacks, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_NSTACK_RELOAD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode = 0;
	_parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if(errcode)
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
		size_t szErrMsgBody; _parser.skipMsgBody(szErrMsgBody);  /*errMsgBody*/
		AtfValidator::validateInt(_descr, "errMsgBody", szErrMsgBody, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 unusedStacks; _parser.parseINT32(unusedStacks);
		AtfValidator::validateInt(_descr, "unusedStacks", unusedStacks, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_BLITZ_MTT_KICK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::Protocol_MSG_TABLE_BLITZ_MTT_KICK()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::clear()
{
	sittingIn = false;
	rebuyLeft = 0;
	rebuyTimeout = 0;
	limboAction = 0;
	actionAmount = 0;
	actionTimeout = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::equals(const Protocol_MSG_TABLE_BLITZ_MTT_KICK& _o) const
{
	return sittingIn == _o.sittingIn &&
		rebuyLeft == _o.rebuyLeft &&
		rebuyTimeout == _o.rebuyTimeout &&
		limboAction == _o.limboAction &&
		actionAmount == _o.actionAmount &&
		actionTimeout == _o.actionTimeout;
}

bool TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_BLITZ_MTT_KICK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_BLITZ_MTT_KICK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_BLITZ_MTT_KICK).append(")");
	_buf.append(',');
	_buf.append("sittingIn=");
	_buf.appendUint(sittingIn);
	_buf.append(',');
	_buf.append("rebuyLeft=");
	_buf.appendUint(rebuyLeft);
	_buf.append(',');
	_buf.append("rebuyTO=");
	_buf.appendUint(rebuyTimeout);
	_buf.append(',');
	_buf.append("limboAction=");
	_buf.appendUint(limboAction);
	_buf.append(',');
	_buf.append("actAmount=");
	_buf.appendUint(actionAmount);
	_buf.append(',');
	_buf.append("actTO=");
	_buf.appendUint(actionTimeout);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_BLITZ_MTT_KICK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sittingIn", sittingIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyLeft", rebuyLeft, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyTO", rebuyTimeout, _buf);
	Atf::XmlElement::encodeAsXmlElement("limboAction", limboAction, _buf);
	Atf::XmlElement::encodeAsXmlElement("actAmount", actionAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("actTO", actionTimeout, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sittingIn"))
			{
				sittingIn = (*_value.ptr() == '1');
			}
			else if (_element.equals("rebuyLeft"))
			{
				rebuyLeft = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuyTO") || _element.equals("rebuyTimeout"))
			{
				rebuyTimeout = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limboAction"))
			{
				limboAction = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("actAmount") || _element.equals("actionAmount"))
			{
				actionAmount = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("actTO") || _element.equals("actionTimeout"))
			{
				actionTimeout = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(sittingIn);
	_msg.composeUINT16(rebuyLeft);
	_msg.composeUINT32(rebuyTimeout);
	_msg.composeBYTE(limboAction);
	_msg.composeUINT16(actionAmount);
	_msg.composeUINT32(actionTimeout);
}

void TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(sittingIn);
	_parser.parseUINT16(rebuyLeft);
	_parser.parseUINT32(rebuyTimeout);
	_parser.parseBYTE(limboAction);
	_parser.parseUINT16(actionAmount);
	_parser.parseUINT32(actionTimeout);
}

const char *TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sittingIn", sittingIn);
	_jsonstr.compose("rebuyLeft", rebuyLeft);
	_jsonstr.compose("rebuyTO", rebuyTimeout);
	_jsonstr.compose("limboAction", limboAction);
	_jsonstr.compose("actAmount", actionAmount);
	_jsonstr.compose("actTO", actionTimeout);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sittingIn", sittingIn);
	_jparser.parseByNameThrow("rebuyLeft", rebuyLeft);
	if(!_jparser.parseByName("rebuyTO", rebuyTimeout)) _jparser.parseByNameThrow("rebuyTimeout", rebuyTimeout);
	_jparser.parseByNameThrow("limboAction", limboAction);
	if(!_jparser.parseByName("actAmount", actionAmount)) _jparser.parseByNameThrow("actionAmount", actionAmount);
	if(!_jparser.parseByName("actTO", actionTimeout)) _jparser.parseByNameThrow("actionTimeout", actionTimeout);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_BLITZ_MTT_KICK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool sittingIn; _jparser.validateByNameThrow("sittingIn", sittingIn);
	AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	UINT16 rebuyLeft; _jparser.validateByNameThrow("rebuyLeft", rebuyLeft);
	AtfValidator::validateInt(_descr, "rebuyLeft", rebuyLeft, _checker, __FILE__, __LINE__);
	UINT32 rebuyTimeout; if(!_jparser.validateByName("rebuyTO", rebuyTimeout)) _jparser.validateByNameThrow("rebuyTimeout", rebuyTimeout);
	AtfValidator::validateInt(_descr, "rebuyTimeout", rebuyTimeout, _checker, __FILE__, __LINE__);
	BYTE limboAction; _jparser.validateByNameThrow("limboAction", limboAction);
	AtfValidator::validateInt(_descr, "limboAction", limboAction, _checker, __FILE__, __LINE__);
	UINT16 actionAmount; if(!_jparser.validateByName("actAmount", actionAmount)) _jparser.validateByNameThrow("actionAmount", actionAmount);
	AtfValidator::validateInt(_descr, "actionAmount", actionAmount, _checker, __FILE__, __LINE__);
	UINT32 actionTimeout; if(!_jparser.validateByName("actTO", actionTimeout)) _jparser.validateByNameThrow("actionTimeout", actionTimeout);
	AtfValidator::validateInt(_descr, "actionTimeout", actionTimeout, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_BLITZ_MTT_KICK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool sittingIn; _parser.parseBOOL(sittingIn);
	AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	UINT16 rebuyLeft; _parser.parseUINT16(rebuyLeft);
	AtfValidator::validateInt(_descr, "rebuyLeft", rebuyLeft, _checker, __FILE__, __LINE__);
	UINT32 rebuyTimeout; _parser.parseUINT32(rebuyTimeout);
	AtfValidator::validateInt(_descr, "rebuyTimeout", rebuyTimeout, _checker, __FILE__, __LINE__);
	BYTE limboAction; _parser.parseBYTE(limboAction);
	AtfValidator::validateInt(_descr, "limboAction", limboAction, _checker, __FILE__, __LINE__);
	UINT16 actionAmount; _parser.parseUINT16(actionAmount);
	AtfValidator::validateInt(_descr, "actionAmount", actionAmount, _checker, __FILE__, __LINE__);
	UINT32 actionTimeout; _parser.parseUINT32(actionTimeout);
	AtfValidator::validateInt(_descr, "actionTimeout", actionTimeout, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PlayerNotifI18NMsg
//=================================================================

// @Override
bool TableClient::player::PlayerNotifI18NMsg::operator<( const PlayerNotifI18NMsg& other ) const
{
	return msgSeqId < other.msgSeqId;
}

TableClient::player::PlayerNotifI18NMsg::PlayerNotifI18NMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::PlayerNotifI18NMsg::PlayerNotifI18NMsg(PlayerNotifI18NMsg&& _o)
	: str(std::move(_o.str))
	, msgSeqId(std::move(_o.msgSeqId))
{
}

TableClient::player::PlayerNotifI18NMsg& TableClient::player::PlayerNotifI18NMsg::operator=(PlayerNotifI18NMsg&& _o)
{
	if(this != &_o)
	{
		str = std::move(_o.str);
		msgSeqId = std::move(_o.msgSeqId);
	}
	return *this;
}

#endif

void TableClient::player::PlayerNotifI18NMsg::clear()
{
	str.clear();
	msgSeqId = 0;
}

bool TableClient::player::PlayerNotifI18NMsg::equals(const PlayerNotifI18NMsg& _o) const
{
	return str.equals(_o.str) &&
		msgSeqId == _o.msgSeqId;
}

const char *TableClient::player::PlayerNotifI18NMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("str=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, str);
	_buf.append(',');
	_buf.append("msgSq=");
	_buf.appendUint(msgSeqId);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::PlayerNotifI18NMsg::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "str", str);
	Atf::XmlElement::encodeAsXmlElement("msgSq", msgSeqId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::PlayerNotifI18NMsg::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("str"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, str);
		}
		else if (_element.equals("msgSq") || _element.equals("msgSeqId"))
		{
			msgSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::PlayerNotifI18NMsg::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	str.compose(_msg);
	_msg.composeUINT32(msgSeqId);
}

void TableClient::player::PlayerNotifI18NMsg::parseMsg(CommMsgParser& _parser)
{
	str.parse(_parser);
	_parser.parseUINT32(msgSeqId);
}

const char *TableClient::player::PlayerNotifI18NMsg::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("str", str);
	_jsonstr.compose("msgSq", msgSeqId);
	return _buf.c_str();
}

void TableClient::player::PlayerNotifI18NMsg::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("str", str);
	if(!_jparser.parseByName("msgSq", msgSeqId)) _jparser.parseByNameThrow("msgSeqId", msgSeqId);
}

/* static */ void TableClient::player::PlayerNotifI18NMsg::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	I18nPString str; _jparser.validateByNameThrow("str", str);
	UINT32 msgSeqId; if(!_jparser.validateByName("msgSq", msgSeqId)) _jparser.validateByNameThrow("msgSeqId", msgSeqId);
	AtfValidator::validateInt(_descr, "msgSeqId", msgSeqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::PlayerNotifI18NMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	I18nPString str; str.parse(_parser);
	UINT32 msgSeqId; _parser.parseUINT32(msgSeqId);
	AtfValidator::validateInt(_descr, "msgSeqId", msgSeqId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST
//=================================================================

TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST(Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST&& _o)
	: notifs(std::move(_o.notifs))
{
}

TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST& TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::operator=(Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST&& _o)
{
	if(this != &_o)
	{
		notifs = std::move(_o.notifs);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::clear()
{
	notifs.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::equals(const Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST& _o) const
{
	return notifs.equals(_o.notifs);
}

bool TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_USER_SPECIFIC_BROADCAST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_USER_SPECIFIC_BROADCAST).append(")");
	_buf.append(',');
	_buf.append("notifs=");
	notifs.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_USER_SPECIFIC_BROADCAST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	notifs.toXmlString("notifs", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notifs"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerNotifI18NMsg, 4 > >::FromXmlString(_value, notifs)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	notifs.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::parseMsg(CommMsgParser& _parser)
{
	notifs.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notifs", notifs);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notifs", notifs);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_SPECIFIC_BROADCAST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PlayerNotifI18NMsg > notifs; _jparser.validateByNameThrow("notifs", notifs);
	AtfValidator::validateInt(_descr, "notifs", notifs.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_SPECIFIC_BROADCAST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szNotifs = Atf::LAtfVector< PlayerNotifI18NMsg, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("notifs"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "notifs", szNotifs, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_USER_CHAT_WARN
//=================================================================

TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::Protocol_MSG_TABLE_USER_CHAT_WARN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::Protocol_MSG_TABLE_USER_CHAT_WARN(Protocol_MSG_TABLE_USER_CHAT_WARN&& _o)
	: warnMsgId(std::move(_o.warnMsgId))
	, chat(std::move(_o.chat))
{
}

TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN& TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::operator=(Protocol_MSG_TABLE_USER_CHAT_WARN&& _o)
{
	if(this != &_o)
	{
		warnMsgId = std::move(_o.warnMsgId);
		chat = std::move(_o.chat);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::clear()
{
	warnMsgId = 0;
	chat.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::equals(const Protocol_MSG_TABLE_USER_CHAT_WARN& _o) const
{
	return warnMsgId == _o.warnMsgId &&
		Atf::atfPStringEquals(chat, _o.chat);
}

bool TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_USER_CHAT_WARN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_USER_CHAT_WARN*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_USER_CHAT_WARN).append(")");
	_buf.append(',');
	_buf.append("warnMsgId=");
	_buf.appendUint(warnMsgId);
	_buf.append(',');
	_buf.append("chat=");
	_buf.append(chat);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_USER_CHAT_WARN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("warnMsgId", warnMsgId, _buf);
	Atf::XmlElement::encodeAsXmlElement("chat", chat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("warnMsgId"))
			{
				warnMsgId = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chat"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chat)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(warnMsgId);
	_msg.composeString(chat);
}

void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(warnMsgId);
	_parser.parseStringP(chat);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("warnMsgId", warnMsgId);
	_jsonstr.compose("chat", chat);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("warnMsgId", warnMsgId);
	_jparser.parseByNameThrow("chat", chat);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_CHAT_WARN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 warnMsgId; _jparser.validateByNameThrow("warnMsgId", warnMsgId);
	AtfValidator::validateInt(_descr, "warnMsgId", warnMsgId, _checker, __FILE__, __LINE__);
	PString chat; _jparser.validateByNameThrow("chat", chat);
	AtfValidator::validateInt(_descr, "chat", chat.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_WARN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_CHAT_WARN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT16 warnMsgId; _parser.parseUINT16(warnMsgId);
	AtfValidator::validateInt(_descr, "warnMsgId", warnMsgId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "chat"); size_t szChat = strlen(_dummy);
	AtfValidator::validateInt(_descr, "chat", szChat, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_USER_CHAT_BAN
//=================================================================

TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::Protocol_MSG_TABLE_USER_CHAT_BAN()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::clear()
{
	banMsgId = 0;
	banTimeMins = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::equals(const Protocol_MSG_TABLE_USER_CHAT_BAN& _o) const
{
	return banMsgId == _o.banMsgId &&
		banTimeMins == _o.banTimeMins;
}

bool TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_USER_CHAT_BAN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_USER_CHAT_BAN*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_USER_CHAT_BAN).append(")");
	_buf.append(',');
	_buf.append("banMsgId=");
	_buf.appendUint(banMsgId);
	_buf.append(',');
	_buf.append("banTimeMins=");
	_buf.appendInt(banTimeMins);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_USER_CHAT_BAN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("banMsgId", banMsgId, _buf);
	Atf::XmlElement::encodeAsXmlElement("banTimeMins", banTimeMins, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("banMsgId"))
			{
				banMsgId = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("banTimeMins"))
			{
				banTimeMins = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(banMsgId);
	_msg.composeINT32(banTimeMins);
}

void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(banMsgId);
	_parser.parseINT32(banTimeMins);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("banMsgId", banMsgId);
	_jsonstr.compose("banTimeMins", banTimeMins);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("banMsgId", banMsgId);
	_jparser.parseByNameThrow("banTimeMins", banTimeMins);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_CHAT_BAN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 banMsgId; _jparser.validateByNameThrow("banMsgId", banMsgId);
	AtfValidator::validateInt(_descr, "banMsgId", banMsgId, _checker, __FILE__, __LINE__);
	INT32 banTimeMins; _jparser.validateByNameThrow("banTimeMins", banTimeMins);
	AtfValidator::validateInt(_descr, "banTimeMins", banTimeMins, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_CHAT_BAN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_CHAT_BAN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT16 banMsgId; _parser.parseUINT16(banMsgId);
	AtfValidator::validateInt(_descr, "banMsgId", banMsgId, _checker, __FILE__, __LINE__);
	INT32 banTimeMins; _parser.parseINT32(banTimeMins);
	AtfValidator::validateInt(_descr, "banTimeMins", banTimeMins, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    HoleCardSnapshot
//=================================================================

TableClient::player::HoleCardSnapshot::HoleCardSnapshot()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::HoleCardSnapshot::HoleCardSnapshot(HoleCardSnapshot&& _o)
	: round(std::move(_o.round))
	, holeCards(std::move(_o.holeCards))
{
}

TableClient::player::HoleCardSnapshot& TableClient::player::HoleCardSnapshot::operator=(HoleCardSnapshot&& _o)
{
	if(this != &_o)
	{
		round = std::move(_o.round);
		holeCards = std::move(_o.holeCards);
	}
	return *this;
}

#endif

void TableClient::player::HoleCardSnapshot::clear()
{
	round = 0;
	holeCards.clear();
}

bool TableClient::player::HoleCardSnapshot::equals(const HoleCardSnapshot& _o) const
{
	return round == _o.round &&
		holeCards.equals(_o.holeCards);
}

const char *TableClient::player::HoleCardSnapshot::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("round=");
	_buf.appendInt(round);
	_buf.append(',');
	_buf.append("holeCards=");
	holeCards.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::HoleCardSnapshot::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("round", round, _buf);
	holeCards.toXmlString("holeCards", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::HoleCardSnapshot::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("round"))
		{
			round = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("holeCards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::CardDictionaryItem, 1 > >::FromXmlString(_value, holeCards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::HoleCardSnapshot::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(HoleCardSnapshot())) // not empty
	{
		_body.composeINT8(round);
		holeCards.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::player::HoleCardSnapshot::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT8(round);
	holeCards.parseMsg(_parser0);
}

const char *TableClient::player::HoleCardSnapshot::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("round", round);
	_jsonstr.compose("holeCards", holeCards);
	return _buf.c_str();
}

void TableClient::player::HoleCardSnapshot::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("round", round);
	_jparser.parseByNameThrow("holeCards", holeCards);
}

/* static */ void TableClient::player::HoleCardSnapshot::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 round; _jparser.validateByNameThrow("round", round);
	AtfValidator::validateInt(_descr, "round", round, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::CardDictionaryItem > holeCards; _jparser.validateByNameThrow("holeCards", holeCards);
	AtfValidator::validateInt(_descr, "holeCards", holeCards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::HoleCardSnapshot::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT8 round; _parser0.parseINT8(round);
	AtfValidator::validateInt(_descr, "round", round, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szHoleCards = Atf::LAtfVector< TableCommon::CardDictionaryItem, 1 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("holeCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "holeCards", szHoleCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE
//=================================================================

TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE(Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE&& _o)
	: handId(std::move(_o.handId))
	, myHoleCards(std::move(_o.myHoleCards))
	, otherCards(std::move(_o.otherCards))
	, oldHoleCards(std::move(_o.oldHoleCards))
{
}

TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE& TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::operator=(Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE&& _o)
{
	if(this != &_o)
	{
		handId = std::move(_o.handId);
		myHoleCards = std::move(_o.myHoleCards);
		otherCards = std::move(_o.otherCards);
		oldHoleCards = std::move(_o.oldHoleCards);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::clear()
{
	handId = 0;
	myHoleCards.clear();
	otherCards.clear();
	oldHoleCards.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::equals(const Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE& _o) const
{
	return handId == _o.handId &&
		myHoleCards.equals(_o.myHoleCards) &&
		otherCards.equals(_o.otherCards) &&
		oldHoleCards.equals(_o.oldHoleCards);
}

bool TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE).append(")");
	_buf.append(',');
	_buf.append("hI=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("myHoleCards=");
	myHoleCards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("otherCards=");
	otherCards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("oldHoleCards=");
	oldHoleCards.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("hI", handId, _buf);
	myHoleCards.toXmlString("myHoleCards", _buf);
	otherCards.toXmlString("otherCards", _buf);
	oldHoleCards.toXmlString("oldHoleCards", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("hI") || _element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("myHoleCards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::CardDictionaryItem, 1 > >::FromXmlString(_value, myHoleCards)) return false;
			}
			else if (_element.equals("otherCards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::CardDictionaryItem, 1 > >::FromXmlString(_value, otherCards)) return false;
			}
			else if (_element.equals("oldHoleCards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< HoleCardSnapshot, 1 > >::FromXmlString(_value, oldHoleCards)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
	myHoleCards.composeMsg(_msg, _ignoreJSON);
	otherCards.composeMsg(_msg, _ignoreJSON);
	oldHoleCards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	myHoleCards.parseMsg(_parser);
	otherCards.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	oldHoleCards.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("hI", handId);
	_jsonstr.compose("myHoleCards", myHoleCards);
	_jsonstr.compose("otherCards", otherCards);
	_jsonstr.compose("oldHoleCards", oldHoleCards);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("hI", handId)) _jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("myHoleCards", myHoleCards);
	_jparser.parseByNameThrow("otherCards", otherCards);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("oldHoleCards", oldHoleCards);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; if(!_jparser.validateByName("hI", handId)) _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::CardDictionaryItem > myHoleCards; _jparser.validateByNameThrow("myHoleCards", myHoleCards);
	AtfValidator::validateInt(_descr, "myHoleCards", myHoleCards.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::CardDictionaryItem > otherCards; _jparser.validateByNameThrow("otherCards", otherCards);
	AtfValidator::validateInt(_descr, "otherCards", otherCards.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< HoleCardSnapshot > oldHoleCards; _jparser.validateByNameThrow("oldHoleCards", oldHoleCards);
	AtfValidator::validateInt(_descr, "oldHoleCards", oldHoleCards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szMyHoleCards = Atf::LAtfVector< TableCommon::CardDictionaryItem, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("myHoleCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "myHoleCards", szMyHoleCards, _checker, __FILE__, __LINE__);
	int szOtherCards = Atf::LAtfVector< TableCommon::CardDictionaryItem, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("otherCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "otherCards", szOtherCards, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szOldHoleCards = Atf::LAtfVector< HoleCardSnapshot, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("oldHoleCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "oldHoleCards", szOldHoleCards, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserDictionaryItem
//=================================================================

TableClient::player::UserDictionaryItem::UserDictionaryItem()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::UserDictionaryItem::UserDictionaryItem(UserDictionaryItem&& _o)
	: alias(std::move(_o.alias))
	, userId(std::move(_o.userId))
	, img(std::move(_o.img))
{
}

TableClient::player::UserDictionaryItem& TableClient::player::UserDictionaryItem::operator=(UserDictionaryItem&& _o)
{
	if(this != &_o)
	{
		alias = std::move(_o.alias);
		userId = std::move(_o.userId);
		img = std::move(_o.img);
	}
	return *this;
}

#endif

void TableClient::player::UserDictionaryItem::clear()
{
	alias.clear();
	userId.clear();
	img.clear();
}

bool TableClient::player::UserDictionaryItem::equals(const UserDictionaryItem& _o) const
{
	return Atf::atfPStringEquals(alias, _o.alias) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		img.equals(_o.img);
}

const char *TableClient::player::UserDictionaryItem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("alias=");
	_buf.append(alias);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("img=");
	img.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::UserDictionaryItem::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("alias", alias, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	img.toXmlString("img", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::UserDictionaryItem::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("alias"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, alias)) return false;
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("img"))
		{
			if(!Atf::AtfTempl< BrandProt::BrandImageList >::FromXmlString(_value, img)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::UserDictionaryItem::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserDictionaryItem())) // not empty
	{
		_body.composeString(alias);
		_body.composeString(userId);
		img.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::player::UserDictionaryItem::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(alias);
	_parser0.parseStringP(userId);
	img.parseMsg(_parser0);
}

const char *TableClient::player::UserDictionaryItem::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("alias", alias);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("img", img);
	return _buf.c_str();
}

void TableClient::player::UserDictionaryItem::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("alias", alias);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("img", img);
}

/* static */ void TableClient::player::UserDictionaryItem::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString alias; _jparser.validateByNameThrow("alias", alias);
	AtfValidator::validateInt(_descr, "alias", alias.length(), _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	BrandProt::BrandImageList img; _jparser.validateByNameThrow("img", img);
}

/*static*/ void TableClient::player::UserDictionaryItem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "alias"); size_t szAlias = strlen(_dummy);
	AtfValidator::validateInt(_descr, "alias", szAlias, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BrandProt::BrandImageList::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("img"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE
//=================================================================

TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE(Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE&& _o)
	: handId(std::move(_o.handId))
	, users(std::move(_o.users))
{
}

TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE& TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::operator=(Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE&& _o)
{
	if(this != &_o)
	{
		handId = std::move(_o.handId);
		users = std::move(_o.users);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::clear()
{
	handId = 0;
	users.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::equals(const Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE& _o) const
{
	return handId == _o.handId &&
		users.equals(_o.users);
}

bool TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_USER_DICTIONARY_UPDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_USER_DICTIONARY_UPDATE).append(")");
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("users=");
	users.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_USER_DICTIONARY_UPDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
	users.toXmlString("users", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("users"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserDictionaryItem, 4 > >::FromXmlString(_value, users)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
	users.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	users.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handId", handId);
	_jsonstr.compose("users", users);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("users", users);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_DICTIONARY_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UserDictionaryItem > users; _jparser.validateByNameThrow("users", users);
	AtfValidator::validateInt(_descr, "users", users.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_DICTIONARY_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szUsers = Atf::LAtfVector< UserDictionaryItem, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("users"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "users", szUsers, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_BLITZ_KICK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::Protocol_MSG_TABLE_BLITZ_KICK()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::clear()
{
	handId = 0;
	statistcs = 0;
	chips = 0;
	kickUserFlags = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::equals(const Protocol_MSG_TABLE_BLITZ_KICK& _o) const
{
	return handId == _o.handId &&
		statistcs == _o.statistcs &&
		chips == _o.chips &&
		kickUserFlags == _o.kickUserFlags;
}

bool TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_BLITZ_KICK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_BLITZ_KICK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_BLITZ_KICK).append(")");
	_buf.append(',');
	_buf.append("hI=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("stat=");
	_buf.appendUint(statistcs);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(kickUserFlags);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_BLITZ_KICK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("hI", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("stat", statistcs, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", kickUserFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("hI") || _element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("stat") || _element.equals("statistcs"))
			{
				statistcs = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags") || _element.equals("kickUserFlags"))
			{
				kickUserFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
	_msg.composeUINT32(statistcs);
	_msg.composeUINT32(chips);
	_msg.composeUINT32(kickUserFlags);
}

void TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	_parser.parseUINT32(statistcs);
	_parser.parseUINT32(chips);
	_parser.parseUINT32(kickUserFlags);
}

const char *TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("hI", handId);
	_jsonstr.compose("stat", statistcs);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("flags", kickUserFlags);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("hI", handId)) _jparser.parseByNameThrow("handId", handId);
	if(!_jparser.parseByName("stat", statistcs)) _jparser.parseByNameThrow("statistcs", statistcs);
	_jparser.parseByNameThrow("chips", chips);
	if(!_jparser.parseByName("flags", kickUserFlags)) _jparser.parseByNameThrow("kickUserFlags", kickUserFlags);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_BLITZ_KICK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; if(!_jparser.validateByName("hI", handId)) _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 statistcs; if(!_jparser.validateByName("stat", statistcs)) _jparser.validateByNameThrow("statistcs", statistcs);
	AtfValidator::validateInt(_descr, "statistcs", statistcs, _checker, __FILE__, __LINE__);
	UINT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT32 kickUserFlags; if(!_jparser.validateByName("flags", kickUserFlags)) _jparser.validateByNameThrow("kickUserFlags", kickUserFlags);
	AtfValidator::validateInt(_descr, "kickUserFlags", kickUserFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_BLITZ_KICK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_BLITZ_KICK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 statistcs; _parser.parseUINT32(statistcs);
	AtfValidator::validateInt(_descr, "statistcs", statistcs, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT32 kickUserFlags; _parser.parseUINT32(kickUserFlags);
	AtfValidator::validateInt(_descr, "kickUserFlags", kickUserFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS(Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS&& _o)
	: powerActionSeqId(std::move(_o.powerActionSeqId))
	, powerId(std::move(_o.powerId))
	, timerInterval(std::move(_o.timerInterval))
	, minPowersChosen(std::move(_o.minPowersChosen))
	, maxPowersChosen(std::move(_o.maxPowersChosen))
	, powers(std::move(_o.powers))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS& TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::operator=(Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS&& _o)
{
	if(this != &_o)
	{
		powerActionSeqId = std::move(_o.powerActionSeqId);
		powerId = std::move(_o.powerId);
		timerInterval = std::move(_o.timerInterval);
		minPowersChosen = std::move(_o.minPowersChosen);
		maxPowersChosen = std::move(_o.maxPowersChosen);
		powers = std::move(_o.powers);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::clear()
{
	powerActionSeqId = 0;
	powerId = 0;
	timerInterval = 0;
	minPowersChosen = 0;
	maxPowersChosen = 0;
	powers.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::equals(const Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS& _o) const
{
	return powerActionSeqId == _o.powerActionSeqId &&
		powerId == _o.powerId &&
		timerInterval == _o.timerInterval &&
		minPowersChosen == _o.minPowersChosen &&
		maxPowersChosen == _o.maxPowersChosen &&
		powers.equals(_o.powers);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHOOSE_POWER_SLOTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHOOSE_POWER_SLOTS).append(")");
	_buf.append(',');
	_buf.append("pasq=");
	_buf.appendUint(powerActionSeqId);
	_buf.append(',');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("timerInterval=");
	_buf.appendUint(timerInterval);
	_buf.append(',');
	_buf.append("minPowersChosen=");
	_buf.appendUint(minPowersChosen);
	_buf.append(',');
	_buf.append("maxPowersChosen=");
	_buf.appendUint(maxPowersChosen);
	_buf.append(',');
	_buf.append("powers=");
	powers.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHOOSE_POWER_SLOTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pasq", powerActionSeqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("timerInterval", timerInterval, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPowersChosen", minPowersChosen, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPowersChosen", maxPowersChosen, _buf);
	powers.toXmlString("powers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pasq") || _element.equals("powerActionSeqId"))
			{
				powerActionSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pI") || _element.equals("powerId"))
			{
				powerId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timerInterval"))
			{
				timerInterval = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPowersChosen"))
			{
				minPowersChosen = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPowersChosen"))
			{
				maxPowersChosen = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("powers"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT32 , 4 > >::FromXmlString(_value, powers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(powerActionSeqId);
	_msg.composeINT32(powerId);
	_msg.composeUINT32(timerInterval);
	_msg.composeBYTE(minPowersChosen);
	_msg.composeBYTE(maxPowersChosen);
	powers.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(powerActionSeqId);
	_parser.parseINT32(powerId);
	_parser.parseUINT32(timerInterval);
	_parser.parseBYTE(minPowersChosen);
	_parser.parseBYTE(maxPowersChosen);
	powers.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pasq", powerActionSeqId);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("timerInterval", timerInterval);
	_jsonstr.compose("minPowersChosen", minPowersChosen);
	_jsonstr.compose("maxPowersChosen", maxPowersChosen);
	_jsonstr.compose("powers", powers);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pasq", powerActionSeqId)) _jparser.parseByNameThrow("powerActionSeqId", powerActionSeqId);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("timerInterval", timerInterval);
	_jparser.parseByNameThrow("minPowersChosen", minPowersChosen);
	_jparser.parseByNameThrow("maxPowersChosen", maxPowersChosen);
	_jparser.parseByNameThrow("powers", powers);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_POWER_SLOTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 powerActionSeqId; if(!_jparser.validateByName("pasq", powerActionSeqId)) _jparser.validateByNameThrow("powerActionSeqId", powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 timerInterval; _jparser.validateByNameThrow("timerInterval", timerInterval);
	AtfValidator::validateInt(_descr, "timerInterval", timerInterval, _checker, __FILE__, __LINE__);
	BYTE minPowersChosen; _jparser.validateByNameThrow("minPowersChosen", minPowersChosen);
	AtfValidator::validateInt(_descr, "minPowersChosen", minPowersChosen, _checker, __FILE__, __LINE__);
	BYTE maxPowersChosen; _jparser.validateByNameThrow("maxPowersChosen", maxPowersChosen);
	AtfValidator::validateInt(_descr, "maxPowersChosen", maxPowersChosen, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > powers; _jparser.validateByNameThrow("powers", powers);
	AtfValidator::validateInt(_descr, "powers", powers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_POWER_SLOTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 powerActionSeqId; _parser.parseUINT32(powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	INT32 powerId; _parser.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 timerInterval; _parser.parseUINT32(timerInterval);
	AtfValidator::validateInt(_descr, "timerInterval", timerInterval, _checker, __FILE__, __LINE__);
	BYTE minPowersChosen; _parser.parseBYTE(minPowersChosen);
	AtfValidator::validateInt(_descr, "minPowersChosen", minPowersChosen, _checker, __FILE__, __LINE__);
	BYTE maxPowersChosen; _parser.parseBYTE(maxPowersChosen);
	AtfValidator::validateInt(_descr, "maxPowersChosen", maxPowersChosen, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPowers = Atf::LAtfVector< INT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powers", szPowers, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::clear()
{
	powerActionSeqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::equals(const Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK& _o) const
{
	return powerActionSeqId == _o.powerActionSeqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK).append(")");
	_buf.append(',');
	_buf.append("pasq=");
	_buf.appendUint(powerActionSeqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pasq", powerActionSeqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pasq") || _element.equals("powerActionSeqId"))
			{
				powerActionSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(powerActionSeqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(powerActionSeqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pasq", powerActionSeqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pasq", powerActionSeqId)) _jparser.parseByNameThrow("powerActionSeqId", powerActionSeqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 powerActionSeqId; if(!_jparser.validateByName("pasq", powerActionSeqId)) _jparser.validateByNameThrow("powerActionSeqId", powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 powerActionSeqId; _parser.parseUINT32(powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY(Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY&& _o)
	: powerActionSeqId(std::move(_o.powerActionSeqId))
	, powersChosen(std::move(_o.powersChosen))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY& TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::operator=(Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY&& _o)
{
	if(this != &_o)
	{
		powerActionSeqId = std::move(_o.powerActionSeqId);
		powersChosen = std::move(_o.powersChosen);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::clear()
{
	powerActionSeqId = 0;
	powersChosen.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::equals(const Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY& _o) const
{
	return powerActionSeqId == _o.powerActionSeqId &&
		powersChosen.equals(_o.powersChosen);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("pasq=");
	_buf.appendUint(powerActionSeqId);
	_buf.append(',');
	_buf.append("powersChosen=");
	powersChosen.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pasq", powerActionSeqId, _buf);
	powersChosen.toXmlString("powersChosen", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pasq") || _element.equals("powerActionSeqId"))
			{
				powerActionSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("powersChosen"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT32 , 4 > >::FromXmlString(_value, powersChosen)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(powerActionSeqId);
	powersChosen.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(powerActionSeqId);
	powersChosen.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pasq", powerActionSeqId);
	_jsonstr.compose("powersChosen", powersChosen);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pasq", powerActionSeqId)) _jparser.parseByNameThrow("powerActionSeqId", powerActionSeqId);
	_jparser.parseByNameThrow("powersChosen", powersChosen);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 powerActionSeqId; if(!_jparser.validateByName("pasq", powerActionSeqId)) _jparser.validateByNameThrow("powerActionSeqId", powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > powersChosen; _jparser.validateByNameThrow("powersChosen", powersChosen);
	AtfValidator::validateInt(_descr, "powersChosen", powersChosen.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 powerActionSeqId; _parser.parseUINT32(powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPowersChosen = Atf::LAtfVector< INT32 , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powersChosen"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powersChosen", szPowersChosen, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::clear()
{
	powerActionSeqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::equals(const Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL& _o) const
{
	return powerActionSeqId == _o.powerActionSeqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL).append(")");
	_buf.append(',');
	_buf.append("pasq=");
	_buf.appendUint(powerActionSeqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pasq", powerActionSeqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pasq") || _element.equals("powerActionSeqId"))
			{
				powerActionSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(powerActionSeqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(powerActionSeqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pasq", powerActionSeqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pasq", powerActionSeqId)) _jparser.parseByNameThrow("powerActionSeqId", powerActionSeqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 powerActionSeqId; if(!_jparser.validateByName("pasq", powerActionSeqId)) _jparser.validateByNameThrow("powerActionSeqId", powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 powerActionSeqId; _parser.parseUINT32(powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PowerInfoBody
//=================================================================

TableClient::player::PowerInfoBody::PowerInfoBody()
{
	clear();
}

void TableClient::player::PowerInfoBody::clear()
{
	powerId = 0;
	status = 0;
	powerCardUniqueId = 0;
}

bool TableClient::player::PowerInfoBody::equals(const PowerInfoBody& _o) const
{
	return powerId == _o.powerId &&
		status == _o.status &&
		powerCardUniqueId == _o.powerCardUniqueId;
}

const char *TableClient::player::PowerInfoBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("puId=");
	_buf.appendInt(powerCardUniqueId);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::PowerInfoBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("puId", powerCardUniqueId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::PowerInfoBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pI") || _element.equals("powerId"))
		{
			powerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("puId") || _element.equals("powerCardUniqueId"))
		{
			powerCardUniqueId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::PowerInfoBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PowerInfoBody())) // not empty
	{
		_body.composeINT32(powerId);
		_body.composeUINT32(status);
		_body.composeINT32(powerCardUniqueId);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::player::PowerInfoBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerId);
	_parser0.parseUINT32(status);
	_parser0.parseINT32(powerCardUniqueId);
}

const char *TableClient::player::PowerInfoBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("status", status);
	_jsonstr.compose("puId", powerCardUniqueId);
	return _buf.c_str();
}

void TableClient::player::PowerInfoBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("status", status);
	if(!_jparser.parseByName("puId", powerCardUniqueId)) _jparser.parseByNameThrow("powerCardUniqueId", powerCardUniqueId);
}

/* static */ void TableClient::player::PowerInfoBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	INT32 powerCardUniqueId; if(!_jparser.validateByName("puId", powerCardUniqueId)) _jparser.validateByNameThrow("powerCardUniqueId", powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::PowerInfoBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 powerId; _parser0.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	INT32 powerCardUniqueId; _parser0.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_POSSESSION
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::Protocol_MSG_TABLE_POWER_POSSESSION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::Protocol_MSG_TABLE_POWER_POSSESSION(Protocol_MSG_TABLE_POWER_POSSESSION&& _o)
	: powers(std::move(_o.powers))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION& TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::operator=(Protocol_MSG_TABLE_POWER_POSSESSION&& _o)
{
	if(this != &_o)
	{
		powers = std::move(_o.powers);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::clear()
{
	powers.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::equals(const Protocol_MSG_TABLE_POWER_POSSESSION& _o) const
{
	return powers.equals(_o.powers);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_POSSESSION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_POSSESSION*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_POSSESSION).append(")");
	_buf.append(',');
	_buf.append("powers=");
	powers.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_POSSESSION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	powers.toXmlString("powers", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("powers"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PowerInfoBody , 4 > >::FromXmlString(_value, powers)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	powers.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::parseMsg(CommMsgParser& _parser)
{
	powers.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("powers", powers);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powers", powers);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_POSSESSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PowerInfoBody > powers; _jparser.validateByNameThrow("powers", powers);
	AtfValidator::validateInt(_descr, "powers", powers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_POSSESSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_POSSESSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szPowers = Atf::LAtfVector< PowerInfoBody , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powers", szPowers, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PowerStatus
//=================================================================

TableClient::player::PowerStatus::PowerStatus()
{
	clear();
}

void TableClient::player::PowerStatus::clear()
{
	powerId = 0;
	newStatus = 0;
	powerCardUniqueId = 0;
}

bool TableClient::player::PowerStatus::equals(const PowerStatus& _o) const
{
	return powerId == _o.powerId &&
		newStatus == _o.newStatus &&
		powerCardUniqueId == _o.powerCardUniqueId;
}

const char *TableClient::player::PowerStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("ns=");
	_buf.appendUint(newStatus);
	_buf.append(',');
	_buf.append("puId=");
	_buf.appendInt(powerCardUniqueId);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::PowerStatus::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ns", newStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("puId", powerCardUniqueId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::PowerStatus::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pI") || _element.equals("powerId"))
		{
			powerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ns") || _element.equals("newStatus"))
		{
			newStatus = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("puId") || _element.equals("powerCardUniqueId"))
		{
			powerCardUniqueId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::PowerStatus::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PowerStatus())) // not empty
	{
		_body.composeINT32(powerId);
		_body.composeUINT32(newStatus);
		_body.composeINT32(powerCardUniqueId);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::player::PowerStatus::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerId);
	_parser0.parseUINT32(newStatus);
	_parser0.parseINT32(powerCardUniqueId);
}

const char *TableClient::player::PowerStatus::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("ns", newStatus);
	_jsonstr.compose("puId", powerCardUniqueId);
	return _buf.c_str();
}

void TableClient::player::PowerStatus::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	if(!_jparser.parseByName("ns", newStatus)) _jparser.parseByNameThrow("newStatus", newStatus);
	if(!_jparser.parseByName("puId", powerCardUniqueId)) _jparser.parseByNameThrow("powerCardUniqueId", powerCardUniqueId);
}

/* static */ void TableClient::player::PowerStatus::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 newStatus; if(!_jparser.validateByName("ns", newStatus)) _jparser.validateByNameThrow("newStatus", newStatus);
	AtfValidator::validateInt(_descr, "newStatus", newStatus, _checker, __FILE__, __LINE__);
	INT32 powerCardUniqueId; if(!_jparser.validateByName("puId", powerCardUniqueId)) _jparser.validateByNameThrow("powerCardUniqueId", powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::PowerStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 powerId; _parser0.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 newStatus; _parser0.parseUINT32(newStatus);
	AtfValidator::validateInt(_descr, "newStatus", newStatus, _checker, __FILE__, __LINE__);
	INT32 powerCardUniqueId; _parser0.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_STATUS_UPDATE
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::Protocol_MSG_TABLE_POWER_STATUS_UPDATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::Protocol_MSG_TABLE_POWER_STATUS_UPDATE(Protocol_MSG_TABLE_POWER_STATUS_UPDATE&& _o)
	: updates(std::move(_o.updates))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE& TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::operator=(Protocol_MSG_TABLE_POWER_STATUS_UPDATE&& _o)
{
	if(this != &_o)
	{
		updates = std::move(_o.updates);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::clear()
{
	updates.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::equals(const Protocol_MSG_TABLE_POWER_STATUS_UPDATE& _o) const
{
	return updates.equals(_o.updates);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_STATUS_UPDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_STATUS_UPDATE*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_STATUS_UPDATE).append(")");
	_buf.append(',');
	_buf.append("updates=");
	updates.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_STATUS_UPDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	updates.toXmlString("updates", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("updates"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PowerStatus, 4 > >::FromXmlString(_value, updates)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	updates.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::parseMsg(CommMsgParser& _parser)
{
	updates.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("updates", updates);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("updates", updates);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_STATUS_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PowerStatus > updates; _jparser.validateByNameThrow("updates", updates);
	AtfValidator::validateInt(_descr, "updates", updates.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_STATUS_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUpdates = Atf::LAtfVector< PowerStatus, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("updates"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "updates", szUpdates, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD(Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD&& _o)
	: powerActionSeqId(std::move(_o.powerActionSeqId))
	, powerId(std::move(_o.powerId))
	, timerInterval(std::move(_o.timerInterval))
	, minCardsChosen(std::move(_o.minCardsChosen))
	, maxCardsChosen(std::move(_o.maxCardsChosen))
	, holeCards(std::move(_o.holeCards))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD& TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::operator=(Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD&& _o)
{
	if(this != &_o)
	{
		powerActionSeqId = std::move(_o.powerActionSeqId);
		powerId = std::move(_o.powerId);
		timerInterval = std::move(_o.timerInterval);
		minCardsChosen = std::move(_o.minCardsChosen);
		maxCardsChosen = std::move(_o.maxCardsChosen);
		holeCards = std::move(_o.holeCards);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::clear()
{
	powerActionSeqId = 0;
	powerId = 0;
	timerInterval = 0;
	minCardsChosen = 0;
	maxCardsChosen = 0;
	holeCards.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::equals(const Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD& _o) const
{
	return powerActionSeqId == _o.powerActionSeqId &&
		powerId == _o.powerId &&
		timerInterval == _o.timerInterval &&
		minCardsChosen == _o.minCardsChosen &&
		maxCardsChosen == _o.maxCardsChosen &&
		holeCards.equals(_o.holeCards);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD).append(")");
	_buf.append(',');
	_buf.append("pasq=");
	_buf.appendUint(powerActionSeqId);
	_buf.append(',');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("timerInterval=");
	_buf.appendUint(timerInterval);
	_buf.append(',');
	_buf.append("minCardsChosen=");
	_buf.appendUint(minCardsChosen);
	_buf.append(',');
	_buf.append("maxCardsChosen=");
	_buf.appendUint(maxCardsChosen);
	_buf.append(',');
	_buf.append("holeCards=");
	holeCards.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pasq", powerActionSeqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("timerInterval", timerInterval, _buf);
	Atf::XmlElement::encodeAsXmlElement("minCardsChosen", minCardsChosen, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxCardsChosen", maxCardsChosen, _buf);
	holeCards.toXmlString("holeCards", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pasq") || _element.equals("powerActionSeqId"))
			{
				powerActionSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pI") || _element.equals("powerId"))
			{
				powerId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timerInterval"))
			{
				timerInterval = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minCardsChosen"))
			{
				minCardsChosen = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxCardsChosen"))
			{
				maxCardsChosen = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("holeCards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, holeCards)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(powerActionSeqId);
	_msg.composeINT32(powerId);
	_msg.composeUINT32(timerInterval);
	_msg.composeBYTE(minCardsChosen);
	_msg.composeBYTE(maxCardsChosen);
	holeCards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(powerActionSeqId);
	_parser.parseINT32(powerId);
	_parser.parseUINT32(timerInterval);
	_parser.parseBYTE(minCardsChosen);
	_parser.parseBYTE(maxCardsChosen);
	holeCards.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pasq", powerActionSeqId);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("timerInterval", timerInterval);
	_jsonstr.compose("minCardsChosen", minCardsChosen);
	_jsonstr.compose("maxCardsChosen", maxCardsChosen);
	_jsonstr.compose("holeCards", holeCards);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pasq", powerActionSeqId)) _jparser.parseByNameThrow("powerActionSeqId", powerActionSeqId);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("timerInterval", timerInterval);
	_jparser.parseByNameThrow("minCardsChosen", minCardsChosen);
	_jparser.parseByNameThrow("maxCardsChosen", maxCardsChosen);
	_jparser.parseByNameThrow("holeCards", holeCards);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 powerActionSeqId; if(!_jparser.validateByName("pasq", powerActionSeqId)) _jparser.validateByNameThrow("powerActionSeqId", powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 timerInterval; _jparser.validateByNameThrow("timerInterval", timerInterval);
	AtfValidator::validateInt(_descr, "timerInterval", timerInterval, _checker, __FILE__, __LINE__);
	BYTE minCardsChosen; _jparser.validateByNameThrow("minCardsChosen", minCardsChosen);
	AtfValidator::validateInt(_descr, "minCardsChosen", minCardsChosen, _checker, __FILE__, __LINE__);
	BYTE maxCardsChosen; _jparser.validateByNameThrow("maxCardsChosen", maxCardsChosen);
	AtfValidator::validateInt(_descr, "maxCardsChosen", maxCardsChosen, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > holeCards; _jparser.validateByNameThrow("holeCards", holeCards);
	AtfValidator::validateInt(_descr, "holeCards", holeCards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 powerActionSeqId; _parser.parseUINT32(powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	INT32 powerId; _parser.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 timerInterval; _parser.parseUINT32(timerInterval);
	AtfValidator::validateInt(_descr, "timerInterval", timerInterval, _checker, __FILE__, __LINE__);
	BYTE minCardsChosen; _parser.parseBYTE(minCardsChosen);
	AtfValidator::validateInt(_descr, "minCardsChosen", minCardsChosen, _checker, __FILE__, __LINE__);
	BYTE maxCardsChosen; _parser.parseBYTE(maxCardsChosen);
	AtfValidator::validateInt(_descr, "maxCardsChosen", maxCardsChosen, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szHoleCards = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("holeCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "holeCards", szHoleCards, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::clear()
{
	powerActionSeqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::equals(const Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK& _o) const
{
	return powerActionSeqId == _o.powerActionSeqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK).append(")");
	_buf.append(',');
	_buf.append("pasq=");
	_buf.appendUint(powerActionSeqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pasq", powerActionSeqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pasq") || _element.equals("powerActionSeqId"))
			{
				powerActionSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(powerActionSeqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(powerActionSeqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pasq", powerActionSeqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pasq", powerActionSeqId)) _jparser.parseByNameThrow("powerActionSeqId", powerActionSeqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 powerActionSeqId; if(!_jparser.validateByName("pasq", powerActionSeqId)) _jparser.validateByNameThrow("powerActionSeqId", powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 powerActionSeqId; _parser.parseUINT32(powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY(Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY&& _o)
	: powerActionSeqId(std::move(_o.powerActionSeqId))
	, cards(std::move(_o.cards))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY& TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::operator=(Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY&& _o)
{
	if(this != &_o)
	{
		powerActionSeqId = std::move(_o.powerActionSeqId);
		cards = std::move(_o.cards);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::clear()
{
	powerActionSeqId = 0;
	cards.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::equals(const Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY& _o) const
{
	return powerActionSeqId == _o.powerActionSeqId &&
		cards.equals(_o.cards);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY).append(")");
	_buf.append(',');
	_buf.append("pasq=");
	_buf.appendUint(powerActionSeqId);
	_buf.append(',');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pasq", powerActionSeqId, _buf);
	cards.toXmlString("cards", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pasq") || _element.equals("powerActionSeqId"))
			{
				powerActionSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cards)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(powerActionSeqId);
	cards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(powerActionSeqId);
	cards.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pasq", powerActionSeqId);
	_jsonstr.compose("cards", cards);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pasq", powerActionSeqId)) _jparser.parseByNameThrow("powerActionSeqId", powerActionSeqId);
	_jparser.parseByNameThrow("cards", cards);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 powerActionSeqId; if(!_jparser.validateByName("pasq", powerActionSeqId)) _jparser.validateByNameThrow("powerActionSeqId", powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 powerActionSeqId; _parser.parseUINT32(powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCards = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::clear()
{
	powerActionSeqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::equals(const Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL& _o) const
{
	return powerActionSeqId == _o.powerActionSeqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL).append(")");
	_buf.append(',');
	_buf.append("pasq=");
	_buf.appendUint(powerActionSeqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pasq", powerActionSeqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pasq") || _element.equals("powerActionSeqId"))
			{
				powerActionSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(powerActionSeqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(powerActionSeqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pasq", powerActionSeqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pasq", powerActionSeqId)) _jparser.parseByNameThrow("powerActionSeqId", powerActionSeqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 powerActionSeqId; if(!_jparser.validateByName("pasq", powerActionSeqId)) _jparser.validateByNameThrow("powerActionSeqId", powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 powerActionSeqId; _parser.parseUINT32(powerActionSeqId);
	AtfValidator::validateInt(_descr, "powerActionSeqId", powerActionSeqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ReloadHoleCardsPowerExtInfo
//=================================================================

TableClient::player::ReloadHoleCardsPowerExtInfo::ReloadHoleCardsPowerExtInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::ReloadHoleCardsPowerExtInfo::ReloadHoleCardsPowerExtInfo(ReloadHoleCardsPowerExtInfo&& _o)
	: cards(std::move(_o.cards))
{
}

TableClient::player::ReloadHoleCardsPowerExtInfo& TableClient::player::ReloadHoleCardsPowerExtInfo::operator=(ReloadHoleCardsPowerExtInfo&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
	}
	return *this;
}

#endif

void TableClient::player::ReloadHoleCardsPowerExtInfo::clear()
{
	cards.clear();
}

bool TableClient::player::ReloadHoleCardsPowerExtInfo::equals(const ReloadHoleCardsPowerExtInfo& _o) const
{
	return cards.equals(_o.cards);
}

const char *TableClient::player::ReloadHoleCardsPowerExtInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::ReloadHoleCardsPowerExtInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	cards.toXmlString("cards", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::ReloadHoleCardsPowerExtInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::ReloadHoleCardsPowerExtInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	cards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::ReloadHoleCardsPowerExtInfo::parseMsg(CommMsgParser& _parser)
{
	cards.parseMsg(_parser);
}

const char *TableClient::player::ReloadHoleCardsPowerExtInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cards", cards);
	return _buf.c_str();
}

void TableClient::player::ReloadHoleCardsPowerExtInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cards", cards);
}

/* static */ void TableClient::player::ReloadHoleCardsPowerExtInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TableCommon::P_Card > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::ReloadHoleCardsPowerExtInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szCards = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CARD_PLAY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::Protocol_MSG_TABLE_POWER_CARD_PLAY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::Protocol_MSG_TABLE_POWER_CARD_PLAY(Protocol_MSG_TABLE_POWER_CARD_PLAY&& _o)
	: actionRequestId(std::move(_o.actionRequestId))
	, powerId(std::move(_o.powerId))
	, targetPlayer(std::move(_o.targetPlayer))
	, targetHoleCard(std::move(_o.targetHoleCard))
	, targetBoardCard(std::move(_o.targetBoardCard))
	, powerCardUniqueId(std::move(_o.powerCardUniqueId))
	, extInfo(std::move(_o.extInfo))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY& TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::operator=(Protocol_MSG_TABLE_POWER_CARD_PLAY&& _o)
{
	if(this != &_o)
	{
		actionRequestId = std::move(_o.actionRequestId);
		powerId = std::move(_o.powerId);
		targetPlayer = std::move(_o.targetPlayer);
		targetHoleCard = std::move(_o.targetHoleCard);
		targetBoardCard = std::move(_o.targetBoardCard);
		powerCardUniqueId = std::move(_o.powerCardUniqueId);
		extInfo = std::move(_o.extInfo);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::clear()
{
	actionRequestId = 0;
	powerId = 0;
	targetPlayer = -1;
	targetHoleCard.clear();
	targetBoardCard.clear();
	powerCardUniqueId = -1;
	extInfo.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::equals(const Protocol_MSG_TABLE_POWER_CARD_PLAY& _o) const
{
	return actionRequestId == _o.actionRequestId &&
		powerId == _o.powerId &&
		targetPlayer == _o.targetPlayer &&
		targetHoleCard.equals(_o.targetHoleCard) &&
		targetBoardCard.equals(_o.targetBoardCard) &&
		powerCardUniqueId == _o.powerCardUniqueId &&
		extInfo.equals(_o.extInfo);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CARD_PLAY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CARD_PLAY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CARD_PLAY).append(")");
	_buf.append(',');
	_buf.append("aRqI=");
	_buf.appendUint(actionRequestId);
	_buf.append(',');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("targetPlayer=");
	_buf.appendInt(targetPlayer);
	_buf.append(',');
	_buf.append("targetHoleCard=");
	targetHoleCard.toTraceString(_buf);
	_buf.append(',');
	_buf.append("targetBoardCard=");
	targetBoardCard.toTraceString(_buf);
	_buf.append(',');
	_buf.append("powerCardUniqueId=");
	_buf.appendInt(powerCardUniqueId);
	_buf.append(',');
	_buf.append("extInfo=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(extInfo, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CARD_PLAY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("aRqI", actionRequestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetPlayer", targetPlayer, _buf);
	targetHoleCard.toXmlString("targetHoleCard", _buf);
	targetBoardCard.toXmlString("targetBoardCard", _buf);
	Atf::XmlElement::encodeAsXmlElement("powerCardUniqueId", powerCardUniqueId, _buf);
	Atf::XmlElement::encodeAsXmlElement("extInfo", extInfo, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("aRqI") || _element.equals("actionRequestId"))
			{
				actionRequestId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pI") || _element.equals("powerId"))
			{
				powerId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetPlayer"))
			{
				targetPlayer = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetHoleCard"))
			{
				if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, targetHoleCard)) return false;
			}
			else if (_element.equals("targetBoardCard"))
			{
				if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, targetBoardCard)) return false;
			}
			else if (_element.equals("powerCardUniqueId"))
			{
				powerCardUniqueId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("extInfo"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, extInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(actionRequestId);
	_msg.composeINT32(powerId);
	_msg.composeINT8(targetPlayer);
	targetHoleCard.composeMsg(_msg, _ignoreJSON);
	targetBoardCard.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(powerCardUniqueId);
	_msg.composeMsgBody(extInfo);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(actionRequestId);
	_parser.parseINT32(powerId);
	if(_parser.parseEnded()) return;
	_parser.parseINT8(targetPlayer);
	if(_parser.parseEnded()) return;
	targetHoleCard.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	targetBoardCard.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(powerCardUniqueId);
	if(_parser.parseEnded()) return;
	_parser.parseMsgBody(extInfo);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("aRqI", actionRequestId);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("targetPlayer", targetPlayer);
	_jsonstr.compose("targetHoleCard", targetHoleCard);
	_jsonstr.compose("targetBoardCard", targetBoardCard);
	_jsonstr.compose("powerCardUniqueId", powerCardUniqueId);
	_jsonstr.compose("extInfo", extInfo);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("aRqI", actionRequestId)) _jparser.parseByNameThrow("actionRequestId", actionRequestId);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("targetPlayer", targetPlayer);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("targetHoleCard", targetHoleCard);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("targetBoardCard", targetBoardCard);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("powerCardUniqueId", powerCardUniqueId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("extInfo", extInfo);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CARD_PLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 actionRequestId; if(!_jparser.validateByName("aRqI", actionRequestId)) _jparser.validateByNameThrow("actionRequestId", actionRequestId);
	AtfValidator::validateInt(_descr, "actionRequestId", actionRequestId, _checker, __FILE__, __LINE__);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT8 targetPlayer; _jparser.validateByNameThrow("targetPlayer", targetPlayer);
	AtfValidator::validateInt(_descr, "targetPlayer", targetPlayer, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::P_Card targetHoleCard; _jparser.validateByNameThrow("targetHoleCard", targetHoleCard);
	if(_jparser.parseEnded()) return;
	TableCommon::P_Card targetBoardCard; _jparser.validateByNameThrow("targetBoardCard", targetBoardCard);
	if(_jparser.parseEnded()) return;
	INT32 powerCardUniqueId; _jparser.validateByNameThrow("powerCardUniqueId", powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::CopyableMsgBody extInfo; _jparser.validateByNameThrow("extInfo", extInfo);
	AtfValidator::validateInt(_descr, "extInfo", extInfo._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CARD_PLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 actionRequestId; _parser.parseUINT32(actionRequestId);
	AtfValidator::validateInt(_descr, "actionRequestId", actionRequestId, _checker, __FILE__, __LINE__);
	INT32 powerId; _parser.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT8 targetPlayer; _parser.parseINT8(targetPlayer);
	AtfValidator::validateInt(_descr, "targetPlayer", targetPlayer, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	TableCommon::P_Card::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("targetHoleCard"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	TableCommon::P_Card::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("targetBoardCard"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	INT32 powerCardUniqueId; _parser.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	size_t szExtInfo; _parser.skipMsgBody(szExtInfo);  /*extInfo*/
	AtfValidator::validateInt(_descr, "extInfo", szExtInfo, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY(Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, powerId(std::move(_o.powerId))
	, powerCardUniqueId(std::move(_o.powerCardUniqueId))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY& TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::operator=(Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		powerId = std::move(_o.powerId);
		powerCardUniqueId = std::move(_o.powerCardUniqueId);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	powerId = 0;
	powerCardUniqueId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::equals(const Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		powerId == _o.powerId &&
		powerCardUniqueId == _o.powerCardUniqueId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CARD_PLAY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CARD_PLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendUint(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	_buf.append(',');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("powerCardUniqueId=");
	_buf.appendInt(powerCardUniqueId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CARD_PLAY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("powerCardUniqueId", powerCardUniqueId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("pI") || _element.equals("powerId"))
			{
				powerId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("powerCardUniqueId"))
			{
				powerCardUniqueId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errCode);
	_msg.composeString(errString);
	_msg.composeINT32(powerId);
	_msg.composeINT32(powerCardUniqueId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errCode);
	_parser.parseStringP(errString);
	_parser.parseINT32(powerId);
	_parser.parseINT32(powerCardUniqueId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("powerCardUniqueId", powerCardUniqueId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("powerCardUniqueId", powerCardUniqueId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CARD_PLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errString; _jparser.validateByNameThrow("errString", errString);
	AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 powerCardUniqueId; _jparser.validateByNameThrow("powerCardUniqueId", powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CARD_PLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errCode; _parser.parseBYTE(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	INT32 powerId; _parser.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 powerCardUniqueId; _parser.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CARD_PRESELECT
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::Protocol_MSG_TABLE_POWER_CARD_PRESELECT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::Protocol_MSG_TABLE_POWER_CARD_PRESELECT(Protocol_MSG_TABLE_POWER_CARD_PRESELECT&& _o)
	: powerId(std::move(_o.powerId))
	, selectOrUnselect(std::move(_o.selectOrUnselect))
	, targetPlayer(std::move(_o.targetPlayer))
	, targetHoleCard(std::move(_o.targetHoleCard))
	, targetBoardCard(std::move(_o.targetBoardCard))
	, powerCardUniqueId(std::move(_o.powerCardUniqueId))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT& TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::operator=(Protocol_MSG_TABLE_POWER_CARD_PRESELECT&& _o)
{
	if(this != &_o)
	{
		powerId = std::move(_o.powerId);
		selectOrUnselect = std::move(_o.selectOrUnselect);
		targetPlayer = std::move(_o.targetPlayer);
		targetHoleCard = std::move(_o.targetHoleCard);
		targetBoardCard = std::move(_o.targetBoardCard);
		powerCardUniqueId = std::move(_o.powerCardUniqueId);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::clear()
{
	powerId = 0;
	selectOrUnselect = false;
	targetPlayer = -1;
	targetHoleCard.clear();
	targetBoardCard.clear();
	powerCardUniqueId = -1;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::equals(const Protocol_MSG_TABLE_POWER_CARD_PRESELECT& _o) const
{
	return powerId == _o.powerId &&
		selectOrUnselect == _o.selectOrUnselect &&
		targetPlayer == _o.targetPlayer &&
		targetHoleCard.equals(_o.targetHoleCard) &&
		targetBoardCard.equals(_o.targetBoardCard) &&
		powerCardUniqueId == _o.powerCardUniqueId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CARD_PRESELECT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CARD_PRESELECT*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CARD_PRESELECT).append(")");
	_buf.append(',');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("selectOrUnselect=");
	_buf.appendUint(selectOrUnselect);
	_buf.append(',');
	_buf.append("targetPlayer=");
	_buf.appendInt(targetPlayer);
	_buf.append(',');
	_buf.append("targetHoleCard=");
	targetHoleCard.toTraceString(_buf);
	_buf.append(',');
	_buf.append("targetBoardCard=");
	targetBoardCard.toTraceString(_buf);
	_buf.append(',');
	_buf.append("powerCardUniqueId=");
	_buf.appendInt(powerCardUniqueId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CARD_PRESELECT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("selectOrUnselect", selectOrUnselect, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetPlayer", targetPlayer, _buf);
	targetHoleCard.toXmlString("targetHoleCard", _buf);
	targetBoardCard.toXmlString("targetBoardCard", _buf);
	Atf::XmlElement::encodeAsXmlElement("powerCardUniqueId", powerCardUniqueId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pI") || _element.equals("powerId"))
			{
				powerId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("selectOrUnselect"))
			{
				selectOrUnselect = (*_value.ptr() == '1');
			}
			else if (_element.equals("targetPlayer"))
			{
				targetPlayer = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetHoleCard"))
			{
				if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, targetHoleCard)) return false;
			}
			else if (_element.equals("targetBoardCard"))
			{
				if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, targetBoardCard)) return false;
			}
			else if (_element.equals("powerCardUniqueId"))
			{
				powerCardUniqueId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(powerId);
	_msg.composeBOOL(selectOrUnselect);
	_msg.composeINT8(targetPlayer);
	targetHoleCard.composeMsg(_msg, _ignoreJSON);
	targetBoardCard.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(powerCardUniqueId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(powerId);
	_parser.parseBOOL(selectOrUnselect);
	if(_parser.parseEnded()) return;
	_parser.parseINT8(targetPlayer);
	if(_parser.parseEnded()) return;
	targetHoleCard.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	targetBoardCard.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(powerCardUniqueId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("selectOrUnselect", selectOrUnselect);
	_jsonstr.compose("targetPlayer", targetPlayer);
	_jsonstr.compose("targetHoleCard", targetHoleCard);
	_jsonstr.compose("targetBoardCard", targetBoardCard);
	_jsonstr.compose("powerCardUniqueId", powerCardUniqueId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("selectOrUnselect", selectOrUnselect);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("targetPlayer", targetPlayer);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("targetHoleCard", targetHoleCard);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("targetBoardCard", targetBoardCard);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("powerCardUniqueId", powerCardUniqueId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CARD_PRESELECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	bool selectOrUnselect; _jparser.validateByNameThrow("selectOrUnselect", selectOrUnselect);
	AtfValidator::validateInt(_descr, "selectOrUnselect", selectOrUnselect, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT8 targetPlayer; _jparser.validateByNameThrow("targetPlayer", targetPlayer);
	AtfValidator::validateInt(_descr, "targetPlayer", targetPlayer, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::P_Card targetHoleCard; _jparser.validateByNameThrow("targetHoleCard", targetHoleCard);
	if(_jparser.parseEnded()) return;
	TableCommon::P_Card targetBoardCard; _jparser.validateByNameThrow("targetBoardCard", targetBoardCard);
	if(_jparser.parseEnded()) return;
	INT32 powerCardUniqueId; _jparser.validateByNameThrow("powerCardUniqueId", powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CARD_PRESELECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 powerId; _parser.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	bool selectOrUnselect; _parser.parseBOOL(selectOrUnselect);
	AtfValidator::validateInt(_descr, "selectOrUnselect", selectOrUnselect, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT8 targetPlayer; _parser.parseINT8(targetPlayer);
	AtfValidator::validateInt(_descr, "targetPlayer", targetPlayer, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	TableCommon::P_Card::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("targetHoleCard"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	TableCommon::P_Card::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("targetBoardCard"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	INT32 powerCardUniqueId; _parser.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS(Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS&& _o)
	: targetPlayer(std::move(_o.targetPlayer))
	, cards(std::move(_o.cards))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS& TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::operator=(Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS&& _o)
{
	if(this != &_o)
	{
		targetPlayer = std::move(_o.targetPlayer);
		cards = std::move(_o.cards);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::clear()
{
	targetPlayer = -1;
	cards.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::equals(const Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS& _o) const
{
	return targetPlayer == _o.targetPlayer &&
		cards.equals(_o.cards);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_DETECT_HOLECARDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_DETECT_HOLECARDS).append(")");
	_buf.append(',');
	_buf.append("targetPlayer=");
	_buf.appendInt(targetPlayer);
	_buf.append(',');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_DETECT_HOLECARDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("targetPlayer", targetPlayer, _buf);
	cards.toXmlString("cards", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("targetPlayer"))
			{
				targetPlayer = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cards)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(targetPlayer);
	cards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(targetPlayer);
	cards.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("targetPlayer", targetPlayer);
	_jsonstr.compose("cards", cards);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("targetPlayer", targetPlayer);
	_jparser.parseByNameThrow("cards", cards);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DETECT_HOLECARDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 targetPlayer; _jparser.validateByNameThrow("targetPlayer", targetPlayer);
	AtfValidator::validateInt(_descr, "targetPlayer", targetPlayer, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DETECT_HOLECARDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT8 targetPlayer; _parser.parseINT8(targetPlayer);
	AtfValidator::validateInt(_descr, "targetPlayer", targetPlayer, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCards = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_REDRAW
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::Protocol_MSG_TABLE_POWER_REDRAW()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::clear()
{
	seqId = 0;
	costChips = 0;
	maxAllowedCardsToRedraw = 0;
	timeoutSec = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::equals(const Protocol_MSG_TABLE_POWER_REDRAW& _o) const
{
	return seqId == _o.seqId &&
		costChips == _o.costChips &&
		maxAllowedCardsToRedraw == _o.maxAllowedCardsToRedraw &&
		timeoutSec == _o.timeoutSec;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_REDRAW != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_REDRAW*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_REDRAW).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("costChips=");
	_buf.appendUint(costChips);
	_buf.append(',');
	_buf.append("maxAllowedCardsToRedraw=");
	_buf.appendInt(maxAllowedCardsToRedraw);
	_buf.append(',');
	_buf.append("TO=");
	_buf.appendInt(timeoutSec);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_REDRAW).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("costChips", costChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxAllowedCardsToRedraw", maxAllowedCardsToRedraw, _buf);
	Atf::XmlElement::encodeAsXmlElement("TO", timeoutSec, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("costChips"))
			{
				costChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxAllowedCardsToRedraw"))
			{
				maxAllowedCardsToRedraw = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("TO") || _element.equals("timeoutSec"))
			{
				timeoutSec = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
	_msg.composeUINT32(costChips);
	_msg.composeINT32(maxAllowedCardsToRedraw);
	_msg.composeINT32(timeoutSec);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
	_parser.parseUINT32(costChips);
	_parser.parseINT32(maxAllowedCardsToRedraw);
	_parser.parseINT32(timeoutSec);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	_jsonstr.compose("costChips", costChips);
	_jsonstr.compose("maxAllowedCardsToRedraw", maxAllowedCardsToRedraw);
	_jsonstr.compose("TO", timeoutSec);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("costChips", costChips);
	_jparser.parseByNameThrow("maxAllowedCardsToRedraw", maxAllowedCardsToRedraw);
	if(!_jparser.parseByName("TO", timeoutSec)) _jparser.parseByNameThrow("timeoutSec", timeoutSec);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_REDRAW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	UINT32 costChips; _jparser.validateByNameThrow("costChips", costChips);
	AtfValidator::validateInt(_descr, "costChips", costChips, _checker, __FILE__, __LINE__);
	INT32 maxAllowedCardsToRedraw; _jparser.validateByNameThrow("maxAllowedCardsToRedraw", maxAllowedCardsToRedraw);
	AtfValidator::validateInt(_descr, "maxAllowedCardsToRedraw", maxAllowedCardsToRedraw, _checker, __FILE__, __LINE__);
	INT32 timeoutSec; if(!_jparser.validateByName("TO", timeoutSec)) _jparser.validateByNameThrow("timeoutSec", timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_REDRAW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	UINT32 costChips; _parser.parseUINT32(costChips);
	AtfValidator::validateInt(_descr, "costChips", costChips, _checker, __FILE__, __LINE__);
	INT32 maxAllowedCardsToRedraw; _parser.parseINT32(maxAllowedCardsToRedraw);
	AtfValidator::validateInt(_descr, "maxAllowedCardsToRedraw", maxAllowedCardsToRedraw, _checker, __FILE__, __LINE__);
	INT32 timeoutSec; _parser.parseINT32(timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_REDRAW_ACK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::Protocol_MSG_TABLE_POWER_REDRAW_ACK()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::clear()
{
	seqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::equals(const Protocol_MSG_TABLE_POWER_REDRAW_ACK& _o) const
{
	return seqId == _o.seqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_REDRAW_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_REDRAW_ACK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_REDRAW_ACK).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_REDRAW_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_REDRAW_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_REDRAW_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_REDRAW_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::Protocol_MSG_TABLE_POWER_REDRAW_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::Protocol_MSG_TABLE_POWER_REDRAW_REPLY(Protocol_MSG_TABLE_POWER_REDRAW_REPLY&& _o)
	: seqId(std::move(_o.seqId))
	, isFinal(std::move(_o.isFinal))
	, powersToRedraw(std::move(_o.powersToRedraw))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY& TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::operator=(Protocol_MSG_TABLE_POWER_REDRAW_REPLY&& _o)
{
	if(this != &_o)
	{
		seqId = std::move(_o.seqId);
		isFinal = std::move(_o.isFinal);
		powersToRedraw = std::move(_o.powersToRedraw);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::clear()
{
	seqId = 0;
	isFinal = false;
	powersToRedraw.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::equals(const Protocol_MSG_TABLE_POWER_REDRAW_REPLY& _o) const
{
	return seqId == _o.seqId &&
		isFinal == _o.isFinal &&
		powersToRedraw.equals(_o.powersToRedraw);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_REDRAW_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_REDRAW_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_REDRAW_REPLY).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("isFinal=");
	_buf.appendUint(isFinal);
	_buf.append(',');
	_buf.append("powersToRedraw=");
	powersToRedraw.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_REDRAW_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isFinal", isFinal, _buf);
	powersToRedraw.toXmlString("powersToRedraw", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isFinal"))
			{
				isFinal = (*_value.ptr() == '1');
			}
			else if (_element.equals("powersToRedraw"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 2 > >::FromXmlString(_value, powersToRedraw)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
	_msg.composeBOOL(isFinal);
	powersToRedraw.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
	_parser.parseBOOL(isFinal);
	powersToRedraw.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	_jsonstr.compose("isFinal", isFinal);
	_jsonstr.compose("powersToRedraw", powersToRedraw);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("isFinal", isFinal);
	_jparser.parseByNameThrow("powersToRedraw", powersToRedraw);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_REDRAW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	bool isFinal; _jparser.validateByNameThrow("isFinal", isFinal);
	AtfValidator::validateInt(_descr, "isFinal", isFinal, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > powersToRedraw; _jparser.validateByNameThrow("powersToRedraw", powersToRedraw);
	AtfValidator::validateInt(_descr, "powersToRedraw", powersToRedraw.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_REDRAW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	bool isFinal; _parser.parseBOOL(isFinal);
	AtfValidator::validateInt(_descr, "isFinal", isFinal, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPowersToRedraw = Atf::LAtfVector< INT32, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powersToRedraw"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powersToRedraw", szPowersToRedraw, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_REDRAW_CANCEL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::clear()
{
	seqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::equals(const Protocol_MSG_TABLE_POWER_REDRAW_CANCEL& _o) const
{
	return seqId == _o.seqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_REDRAW_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_REDRAW_CANCEL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_REDRAW_CANCEL).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_REDRAW_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_REDRAW_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_REDRAW_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHANGE_FUTURE
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE(Protocol_MSG_TABLE_POWER_CHANGE_FUTURE&& _o)
	: seqId(std::move(_o.seqId))
	, cards(std::move(_o.cards))
	, timeoutSec(std::move(_o.timeoutSec))
	, cardVisibilityMasks(std::move(_o.cardVisibilityMasks))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE& TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::operator=(Protocol_MSG_TABLE_POWER_CHANGE_FUTURE&& _o)
{
	if(this != &_o)
	{
		seqId = std::move(_o.seqId);
		cards = std::move(_o.cards);
		timeoutSec = std::move(_o.timeoutSec);
		cardVisibilityMasks = std::move(_o.cardVisibilityMasks);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::clear()
{
	seqId = 0;
	cards.clear();
	timeoutSec = 0;
	cardVisibilityMasks.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::equals(const Protocol_MSG_TABLE_POWER_CHANGE_FUTURE& _o) const
{
	return seqId == _o.seqId &&
		cards.equals(_o.cards) &&
		timeoutSec == _o.timeoutSec &&
		cardVisibilityMasks.equals(_o.cardVisibilityMasks);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHANGE_FUTURE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHANGE_FUTURE*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHANGE_FUTURE).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("TO=");
	_buf.appendInt(timeoutSec);
	_buf.append(',');
	_buf.append("cardVisibilityMasks=");
	cardVisibilityMasks.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHANGE_FUTURE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	cards.toXmlString("cards", _buf);
	Atf::XmlElement::encodeAsXmlElement("TO", timeoutSec, _buf);
	cardVisibilityMasks.toXmlString("cardVisibilityMasks", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cards)) return false;
			}
			else if (_element.equals("TO") || _element.equals("timeoutSec"))
			{
				timeoutSec = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardVisibilityMasks"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT16, 1 > >::FromXmlString(_value, cardVisibilityMasks)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
	cards.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(timeoutSec);
	cardVisibilityMasks.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
	cards.parseMsg(_parser);
	_parser.parseINT32(timeoutSec);
	cardVisibilityMasks.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	_jsonstr.compose("cards", cards);
	_jsonstr.compose("TO", timeoutSec);
	_jsonstr.compose("cardVisibilityMasks", cardVisibilityMasks);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("cards", cards);
	if(!_jparser.parseByName("TO", timeoutSec)) _jparser.parseByNameThrow("timeoutSec", timeoutSec);
	_jparser.parseByNameThrow("cardVisibilityMasks", cardVisibilityMasks);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHANGE_FUTURE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
	INT32 timeoutSec; if(!_jparser.validateByName("TO", timeoutSec)) _jparser.validateByNameThrow("timeoutSec", timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT16 > cardVisibilityMasks; _jparser.validateByNameThrow("cardVisibilityMasks", cardVisibilityMasks);
	AtfValidator::validateInt(_descr, "cardVisibilityMasks", cardVisibilityMasks.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHANGE_FUTURE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCards = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	INT32 timeoutSec; _parser.parseINT32(timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
	int szCardVisibilityMasks = Atf::LAtfVector< INT16, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardVisibilityMasks"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cardVisibilityMasks", szCardVisibilityMasks, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::clear()
{
	seqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::equals(const Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK& _o) const
{
	return seqId == _o.seqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHANGE_FUTURE_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHANGE_FUTURE_ACK).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHANGE_FUTURE_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHANGE_FUTURE_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHANGE_FUTURE_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::clear()
{
	seqId = 0;
	discardCards = false;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::equals(const Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY& _o) const
{
	return seqId == _o.seqId &&
		discardCards == _o.discardCards;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHANGE_FUTURE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHANGE_FUTURE_REPLY).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("discardCards=");
	_buf.appendUint(discardCards);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHANGE_FUTURE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("discardCards", discardCards, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("discardCards"))
			{
				discardCards = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
	_msg.composeBOOL(discardCards);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
	_parser.parseBOOL(discardCards);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	_jsonstr.compose("discardCards", discardCards);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("discardCards", discardCards);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHANGE_FUTURE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	bool discardCards; _jparser.validateByNameThrow("discardCards", discardCards);
	AtfValidator::validateInt(_descr, "discardCards", discardCards, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHANGE_FUTURE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	bool discardCards; _parser.parseBOOL(discardCards);
	AtfValidator::validateInt(_descr, "discardCards", discardCards, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::clear()
{
	seqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::equals(const Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL& _o) const
{
	return seqId == _o.seqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE(Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE&& _o)
	: seqId(std::move(_o.seqId))
	, cards(std::move(_o.cards))
	, timeoutSec(std::move(_o.timeoutSec))
	, cardVisibilityMasks(std::move(_o.cardVisibilityMasks))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE& TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::operator=(Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE&& _o)
{
	if(this != &_o)
	{
		seqId = std::move(_o.seqId);
		cards = std::move(_o.cards);
		timeoutSec = std::move(_o.timeoutSec);
		cardVisibilityMasks = std::move(_o.cardVisibilityMasks);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::clear()
{
	seqId = 0;
	cards.clear();
	timeoutSec = 0;
	cardVisibilityMasks.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::equals(const Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE& _o) const
{
	return seqId == _o.seqId &&
		cards.equals(_o.cards) &&
		timeoutSec == _o.timeoutSec &&
		cardVisibilityMasks.equals(_o.cardVisibilityMasks);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_PLAYERS_CHOICE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_PLAYERS_CHOICE).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("TO=");
	_buf.appendInt(timeoutSec);
	_buf.append(',');
	_buf.append("cardVisibilityMasks=");
	cardVisibilityMasks.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_PLAYERS_CHOICE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	cards.toXmlString("cards", _buf);
	Atf::XmlElement::encodeAsXmlElement("TO", timeoutSec, _buf);
	cardVisibilityMasks.toXmlString("cardVisibilityMasks", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cards)) return false;
			}
			else if (_element.equals("TO") || _element.equals("timeoutSec"))
			{
				timeoutSec = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cardVisibilityMasks"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT16, 1 > >::FromXmlString(_value, cardVisibilityMasks)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
	cards.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(timeoutSec);
	cardVisibilityMasks.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
	cards.parseMsg(_parser);
	_parser.parseINT32(timeoutSec);
	cardVisibilityMasks.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	_jsonstr.compose("cards", cards);
	_jsonstr.compose("TO", timeoutSec);
	_jsonstr.compose("cardVisibilityMasks", cardVisibilityMasks);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("cards", cards);
	if(!_jparser.parseByName("TO", timeoutSec)) _jparser.parseByNameThrow("timeoutSec", timeoutSec);
	_jparser.parseByNameThrow("cardVisibilityMasks", cardVisibilityMasks);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PLAYERS_CHOICE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
	INT32 timeoutSec; if(!_jparser.validateByName("TO", timeoutSec)) _jparser.validateByNameThrow("timeoutSec", timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT16 > cardVisibilityMasks; _jparser.validateByNameThrow("cardVisibilityMasks", cardVisibilityMasks);
	AtfValidator::validateInt(_descr, "cardVisibilityMasks", cardVisibilityMasks.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PLAYERS_CHOICE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCards = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	INT32 timeoutSec; _parser.parseINT32(timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
	int szCardVisibilityMasks = Atf::LAtfVector< INT16, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardVisibilityMasks"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cardVisibilityMasks", szCardVisibilityMasks, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::clear()
{
	seqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::equals(const Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK& _o) const
{
	return seqId == _o.seqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_PLAYERS_CHOICE_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_PLAYERS_CHOICE_ACK).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_PLAYERS_CHOICE_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PLAYERS_CHOICE_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PLAYERS_CHOICE_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::clear()
{
	seqId = 0;
	selectedIndex = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::equals(const Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY& _o) const
{
	return seqId == _o.seqId &&
		selectedIndex == _o.selectedIndex;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("selectedIndex=");
	_buf.appendInt(selectedIndex);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("selectedIndex", selectedIndex, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("selectedIndex"))
			{
				selectedIndex = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
	_msg.composeINT8(selectedIndex);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
	_parser.parseINT8(selectedIndex);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	_jsonstr.compose("selectedIndex", selectedIndex);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("selectedIndex", selectedIndex);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	INT8 selectedIndex; _jparser.validateByNameThrow("selectedIndex", selectedIndex);
	AtfValidator::validateInt(_descr, "selectedIndex", selectedIndex, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	INT8 selectedIndex; _parser.parseINT8(selectedIndex);
	AtfValidator::validateInt(_descr, "selectedIndex", selectedIndex, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::clear()
{
	seqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::equals(const Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL& _o) const
{
	return seqId == _o.seqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT(Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT&& _o)
	: handId(std::move(_o.handId))
	, clientOrdinal(std::move(_o.clientOrdinal))
	, powerId(std::move(_o.powerId))
	, effectId(std::move(_o.effectId))
	, contents(std::move(_o.contents))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT& TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::operator=(Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT&& _o)
{
	if(this != &_o)
	{
		handId = std::move(_o.handId);
		clientOrdinal = std::move(_o.clientOrdinal);
		powerId = std::move(_o.powerId);
		effectId = std::move(_o.effectId);
		contents = std::move(_o.contents);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::clear()
{
	handId = 0;
	clientOrdinal = 0;
	powerId = 0;
	effectId = 0;
	contents.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::equals(const Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT& _o) const
{
	return handId == _o.handId &&
		clientOrdinal == _o.clientOrdinal &&
		powerId == _o.powerId &&
		effectId == _o.effectId &&
		Atf::atfPStringEquals(contents, _o.contents);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_PRIVATE_EFFECT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_PRIVATE_EFFECT).append(")");
	_buf.append(',');
	_buf.append("hI=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("clientOrdinal=");
	_buf.appendUint(clientOrdinal);
	_buf.append(',');
	_buf.append("pI=");
	_buf.appendUint(powerId);
	_buf.append(',');
	_buf.append("effectId=");
	_buf.appendUint(effectId);
	_buf.append(',');
	_buf.append("contents=");
	_buf.append(contents);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_PRIVATE_EFFECT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("hI", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientOrdinal", clientOrdinal, _buf);
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("effectId", effectId, _buf);
	Atf::XmlElement::encodeAsXmlElement("contents", contents, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("hI") || _element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientOrdinal"))
			{
				clientOrdinal = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pI") || _element.equals("powerId"))
			{
				powerId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("effectId"))
			{
				effectId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("contents"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, contents)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
	_msg.composeUINT32(clientOrdinal);
	_msg.composeUINT32(powerId);
	_msg.composeUINT32(effectId);
	_msg.composeString(contents);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	_parser.parseUINT32(clientOrdinal);
	_parser.parseUINT32(powerId);
	_parser.parseUINT32(effectId);
	_parser.parseStringP(contents);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("hI", handId);
	_jsonstr.compose("clientOrdinal", clientOrdinal);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("effectId", effectId);
	_jsonstr.compose("contents", contents);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("hI", handId)) _jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("clientOrdinal", clientOrdinal);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("effectId", effectId);
	_jparser.parseByNameThrow("contents", contents);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PRIVATE_EFFECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; if(!_jparser.validateByName("hI", handId)) _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 clientOrdinal; _jparser.validateByNameThrow("clientOrdinal", clientOrdinal);
	AtfValidator::validateInt(_descr, "clientOrdinal", clientOrdinal, _checker, __FILE__, __LINE__);
	UINT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 effectId; _jparser.validateByNameThrow("effectId", effectId);
	AtfValidator::validateInt(_descr, "effectId", effectId, _checker, __FILE__, __LINE__);
	PString contents; _jparser.validateByNameThrow("contents", contents);
	AtfValidator::validateInt(_descr, "contents", contents.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PRIVATE_EFFECT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 clientOrdinal; _parser.parseUINT32(clientOrdinal);
	AtfValidator::validateInt(_descr, "clientOrdinal", clientOrdinal, _checker, __FILE__, __LINE__);
	UINT32 powerId; _parser.parseUINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	UINT32 effectId; _parser.parseUINT32(effectId);
	AtfValidator::validateInt(_descr, "effectId", effectId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "contents"); size_t szContents = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contents", szContents, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SabotageTrappedCard
//=================================================================

TableClient::player::SabotageTrappedCard::SabotageTrappedCard()
{
	clear();
}

void TableClient::player::SabotageTrappedCard::clear()
{
	cardPosition.clear();
	bombsCount = 0;
}

bool TableClient::player::SabotageTrappedCard::equals(const SabotageTrappedCard& _o) const
{
	return cardPosition.equals(_o.cardPosition) &&
		bombsCount == _o.bombsCount;
}

const char *TableClient::player::SabotageTrappedCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardPosition=");
	cardPosition.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bombsCount=");
	_buf.appendInt(bombsCount);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::SabotageTrappedCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	cardPosition.toXmlString("cardPosition", _buf);
	Atf::XmlElement::encodeAsXmlElement("bombsCount", bombsCount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::SabotageTrappedCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardPosition"))
		{
			if(!Atf::AtfTempl< PubBoardCardPosition >::FromXmlString(_value, cardPosition)) return false;
		}
		else if (_element.equals("bombsCount"))
		{
			bombsCount = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::SabotageTrappedCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	cardPosition.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT8(bombsCount);
}

void TableClient::player::SabotageTrappedCard::parseMsg(CommMsgParser& _parser)
{
	cardPosition.parseMsg(_parser);
	_parser.parseINT8(bombsCount);
}

const char *TableClient::player::SabotageTrappedCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cardPosition", cardPosition);
	_jsonstr.compose("bombsCount", bombsCount);
	return _buf.c_str();
}

void TableClient::player::SabotageTrappedCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardPosition", cardPosition);
	_jparser.parseByNameThrow("bombsCount", bombsCount);
}

/* static */ void TableClient::player::SabotageTrappedCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PubBoardCardPosition cardPosition; _jparser.validateByNameThrow("cardPosition", cardPosition);
	INT8 bombsCount; _jparser.validateByNameThrow("bombsCount", bombsCount);
	AtfValidator::validateInt(_descr, "bombsCount", bombsCount, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::SabotageTrappedCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	PubBoardCardPosition::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardPosition"), _fieldsWithUnparsedContent);
	INT8 bombsCount; _parser.parseINT8(bombsCount);
	AtfValidator::validateInt(_descr, "bombsCount", bombsCount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS(Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS&& _o)
	: trappedCards(std::move(_o.trappedCards))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS& TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::operator=(Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS&& _o)
{
	if(this != &_o)
	{
		trappedCards = std::move(_o.trappedCards);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::clear()
{
	trappedCards.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::equals(const Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS& _o) const
{
	return trappedCards.equals(_o.trappedCards);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS).append(")");
	_buf.append(',');
	_buf.append("trappedCards=");
	trappedCards.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	trappedCards.toXmlString("trappedCards", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("trappedCards"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SabotageTrappedCard, 1 > >::FromXmlString(_value, trappedCards)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	trappedCards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::parseMsg(CommMsgParser& _parser)
{
	trappedCards.parseMsg(_parser);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("trappedCards", trappedCards);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("trappedCards", trappedCards);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< SabotageTrappedCard > trappedCards; _jparser.validateByNameThrow("trappedCards", trappedCards);
	AtfValidator::validateInt(_descr, "trappedCards", trappedCards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szTrappedCards = Atf::LAtfVector< SabotageTrappedCard, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("trappedCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "trappedCards", szTrappedCards, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST
//=================================================================

TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::clear()
{
	textId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::equals(const Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST& _o) const
{
	return textId == _o.textId;
}

bool TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_USER_MINI_CHAT_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_USER_MINI_CHAT_REQUEST).append(")");
	_buf.append(',');
	_buf.append("textId=");
	_buf.appendInt(textId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_USER_MINI_CHAT_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("textId", textId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("textId"))
			{
				textId = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(textId);
}

void TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(textId);
}

const char *TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("textId", textId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("textId", textId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_MINI_CHAT_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 textId; _jparser.validateByNameThrow("textId", textId);
	AtfValidator::validateInt(_descr, "textId", textId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_MINI_CHAT_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 textId; _parser.parseINT16(textId);
	AtfValidator::validateInt(_descr, "textId", textId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_DARK_BET
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::Protocol_MSG_TABLE_POWER_DARK_BET()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::Protocol_MSG_TABLE_POWER_DARK_BET(Protocol_MSG_TABLE_POWER_DARK_BET&& _o)
	: seqId(std::move(_o.seqId))
	, values(std::move(_o.values))
	, timeoutSec(std::move(_o.timeoutSec))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET& TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::operator=(Protocol_MSG_TABLE_POWER_DARK_BET&& _o)
{
	if(this != &_o)
	{
		seqId = std::move(_o.seqId);
		values = std::move(_o.values);
		timeoutSec = std::move(_o.timeoutSec);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::clear()
{
	seqId = 0;
	values.clear();
	timeoutSec = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::equals(const Protocol_MSG_TABLE_POWER_DARK_BET& _o) const
{
	return seqId == _o.seqId &&
		values.equals(_o.values) &&
		timeoutSec == _o.timeoutSec;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_DARK_BET != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_DARK_BET*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_DARK_BET).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("values=");
	values.toTraceString(_buf);
	_buf.append(',');
	_buf.append("TO=");
	_buf.appendInt(timeoutSec);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_DARK_BET).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	values.toXmlString("values", _buf);
	Atf::XmlElement::encodeAsXmlElement("TO", timeoutSec, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("values"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT32 , 1 > >::FromXmlString(_value, values)) return false;
			}
			else if (_element.equals("TO") || _element.equals("timeoutSec"))
			{
				timeoutSec = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
	values.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(timeoutSec);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
	values.parseMsg(_parser);
	_parser.parseINT32(timeoutSec);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	_jsonstr.compose("values", values);
	_jsonstr.compose("TO", timeoutSec);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("values", values);
	if(!_jparser.parseByName("TO", timeoutSec)) _jparser.parseByNameThrow("timeoutSec", timeoutSec);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DARK_BET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > values; _jparser.validateByNameThrow("values", values);
	AtfValidator::validateInt(_descr, "values", values.size(), _checker, __FILE__, __LINE__);
	INT32 timeoutSec; if(!_jparser.validateByName("TO", timeoutSec)) _jparser.validateByNameThrow("timeoutSec", timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DARK_BET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szValues = Atf::LAtfVector< INT32 , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("values"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "values", szValues, _checker, __FILE__, __LINE__);
	INT32 timeoutSec; _parser.parseINT32(timeoutSec);
	AtfValidator::validateInt(_descr, "timeoutSec", timeoutSec, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_DARK_BET_ACK
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::Protocol_MSG_TABLE_POWER_DARK_BET_ACK()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::clear()
{
	seqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::equals(const Protocol_MSG_TABLE_POWER_DARK_BET_ACK& _o) const
{
	return seqId == _o.seqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_DARK_BET_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_DARK_BET_ACK*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_DARK_BET_ACK).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_DARK_BET_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DARK_BET_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DARK_BET_ACK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_DARK_BET_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::clear()
{
	seqId = 0;
	value = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::equals(const Protocol_MSG_TABLE_POWER_DARK_BET_REPLY& _o) const
{
	return seqId == _o.seqId &&
		value == _o.value;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_DARK_BET_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_DARK_BET_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_DARK_BET_REPLY).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt(value);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_DARK_BET_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("value"))
			{
				value = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
	_msg.composeINT32(value);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
	_parser.parseINT32(value);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	_jsonstr.compose("value", value);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("value", value);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DARK_BET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	INT32 value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DARK_BET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	INT32 value; _parser.parseINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::clear()
{
	seqId = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::equals(const Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL& _o) const
{
	return seqId == _o.seqId;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_DARK_BET_CANCEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_DARK_BET_CANCEL).append(")");
	_buf.append(',');
	_buf.append("sq=");
	_buf.appendUint(seqId);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_DARK_BET_CANCEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sq", seqId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sq") || _element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seqId);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seqId);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sq", seqId);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sq", seqId)) _jparser.parseByNameThrow("seqId", seqId);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DARK_BET_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seqId; if(!_jparser.validateByName("sq", seqId)) _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_DARK_BET_CANCEL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_MOUSE_OVER
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::Protocol_MSG_TABLE_POWER_MOUSE_OVER()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::clear()
{
	position = 0;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::equals(const Protocol_MSG_TABLE_POWER_MOUSE_OVER& _o) const
{
	return position == _o.position;
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_MOUSE_OVER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_MOUSE_OVER*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_MOUSE_OVER).append(")");
	_buf.append(',');
	_buf.append("position=");
	_buf.appendInt(position);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_MOUSE_OVER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("position", position, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("position"))
			{
				position = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(position);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(position);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("position", position);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("position", position);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_MOUSE_OVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 position; _jparser.validateByNameThrow("position", position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_MOUSE_OVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT8 position; _parser.parseINT8(position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION
//=================================================================

TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION(Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION&& _o)
	: handId(std::move(_o.handId))
	, powerId(std::move(_o.powerId))
	, effectbody(std::move(_o.effectbody))
{
}

TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION& TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::operator=(Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION&& _o)
{
	if(this != &_o)
	{
		handId = std::move(_o.handId);
		powerId = std::move(_o.powerId);
		effectbody = std::move(_o.effectbody);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::clear()
{
	handId = 0;
	powerId = 0;
	effectbody.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::equals(const Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION& _o) const
{
	return handId == _o.handId &&
		powerId == _o.powerId &&
		effectbody.equals(_o.effectbody);
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_POWER_PRIVATE_ANIMATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_POWER_PRIVATE_ANIMATION).append(")");
	_buf.append(',');
	_buf.append("hI=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("pI=");
	_buf.appendUint(powerId);
	_buf.append(',');
	_buf.append("effectbody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(effectbody, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_POWER_PRIVATE_ANIMATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("hI", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("effectbody", effectbody, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("hI") || _element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pI") || _element.equals("powerId"))
			{
				powerId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("effectbody"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, effectbody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
	_msg.composeUINT32(powerId);
	_msg.composeMsgBody(effectbody);
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	_parser.parseUINT32(powerId);
	_parser.parseMsgBody(effectbody);
}

const char *TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("hI", handId);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("effectbody", effectbody);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("hI", handId)) _jparser.parseByNameThrow("handId", handId);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("effectbody", effectbody);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PRIVATE_ANIMATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; if(!_jparser.validateByName("hI", handId)) _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody effectbody; _jparser.validateByNameThrow("effectbody", effectbody);
	AtfValidator::validateInt(_descr, "effectbody", effectbody._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_POWER_PRIVATE_ANIMATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 powerId; _parser.parseUINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	size_t szEffectbody; _parser.skipMsgBody(szEffectbody);  /*effectbody*/
	AtfValidator::validateInt(_descr, "effectbody", szEffectbody, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PowerCardInfo
//=================================================================

TableClient::player::PowerCardInfo::PowerCardInfo()
{
	clear();
}

void TableClient::player::PowerCardInfo::clear()
{
	powerId = 0;
	cost = 0;
}

bool TableClient::player::PowerCardInfo::equals(const PowerCardInfo& _o) const
{
	return powerId == _o.powerId &&
		cost == _o.cost;
}

const char *TableClient::player::PowerCardInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("cost=");
	_buf.appendInt(cost);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::PowerCardInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("cost", cost, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::PowerCardInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pI") || _element.equals("powerId"))
		{
			powerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cost"))
		{
			cost = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::PowerCardInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(powerId);
	_msg.composeINT32(cost);
}

void TableClient::player::PowerCardInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(powerId);
	_parser.parseINT32(cost);
}

const char *TableClient::player::PowerCardInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("cost", cost);
	return _buf.c_str();
}

void TableClient::player::PowerCardInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("cost", cost);
}

/* static */ void TableClient::player::PowerCardInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 cost; _jparser.validateByNameThrow("cost", cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::PowerCardInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 powerId; _parser.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 cost; _parser.parseINT32(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PrivDealingPowerCardsAnimationEffect
//=================================================================

TableClient::player::PrivDealingPowerCardsAnimationEffect::PrivDealingPowerCardsAnimationEffect()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::PrivDealingPowerCardsAnimationEffect::PrivDealingPowerCardsAnimationEffect(PrivDealingPowerCardsAnimationEffect&& _o)
	: numPowerCardsBeforeDealt(std::move(_o.numPowerCardsBeforeDealt))
	, powerCards(std::move(_o.powerCards))
{
}

TableClient::player::PrivDealingPowerCardsAnimationEffect& TableClient::player::PrivDealingPowerCardsAnimationEffect::operator=(PrivDealingPowerCardsAnimationEffect&& _o)
{
	if(this != &_o)
	{
		numPowerCardsBeforeDealt = std::move(_o.numPowerCardsBeforeDealt);
		powerCards = std::move(_o.powerCards);
	}
	return *this;
}

#endif

void TableClient::player::PrivDealingPowerCardsAnimationEffect::clear()
{
	numPowerCardsBeforeDealt = 0;
	powerCards.clear();
}

bool TableClient::player::PrivDealingPowerCardsAnimationEffect::equals(const PrivDealingPowerCardsAnimationEffect& _o) const
{
	return numPowerCardsBeforeDealt == _o.numPowerCardsBeforeDealt &&
		powerCards.equals(_o.powerCards);
}

const char *TableClient::player::PrivDealingPowerCardsAnimationEffect::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numPowerCardsBeforeDealt=");
	_buf.appendInt(numPowerCardsBeforeDealt);
	_buf.append(',');
	_buf.append("powerCards=");
	powerCards.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::player::PrivDealingPowerCardsAnimationEffect::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numPowerCardsBeforeDealt", numPowerCardsBeforeDealt, _buf);
	powerCards.toXmlString("powerCards", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::player::PrivDealingPowerCardsAnimationEffect::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numPowerCardsBeforeDealt"))
		{
			numPowerCardsBeforeDealt = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powerCards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PowerCardInfo, 4 > >::FromXmlString(_value, powerCards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::player::PrivDealingPowerCardsAnimationEffect::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(numPowerCardsBeforeDealt);
	powerCards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::player::PrivDealingPowerCardsAnimationEffect::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(numPowerCardsBeforeDealt);
	powerCards.parseMsg(_parser);
}

const char *TableClient::player::PrivDealingPowerCardsAnimationEffect::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numPowerCardsBeforeDealt", numPowerCardsBeforeDealt);
	_jsonstr.compose("powerCards", powerCards);
	return _buf.c_str();
}

void TableClient::player::PrivDealingPowerCardsAnimationEffect::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numPowerCardsBeforeDealt", numPowerCardsBeforeDealt);
	_jparser.parseByNameThrow("powerCards", powerCards);
}

/* static */ void TableClient::player::PrivDealingPowerCardsAnimationEffect::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numPowerCardsBeforeDealt; _jparser.validateByNameThrow("numPowerCardsBeforeDealt", numPowerCardsBeforeDealt);
	AtfValidator::validateInt(_descr, "numPowerCardsBeforeDealt", numPowerCardsBeforeDealt, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PowerCardInfo > powerCards; _jparser.validateByNameThrow("powerCards", powerCards);
	AtfValidator::validateInt(_descr, "powerCards", powerCards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::PrivDealingPowerCardsAnimationEffect::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 numPowerCardsBeforeDealt; _parser.parseINT32(numPowerCardsBeforeDealt);
	AtfValidator::validateInt(_descr, "numPowerCardsBeforeDealt", numPowerCardsBeforeDealt, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPowerCards = Atf::LAtfVector< PowerCardInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powerCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powerCards", szPowerCards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_TABLE_THROW
//=================================================================

TableClient::player::Protocol_MSG_TABLE_THROW::Protocol_MSG_TABLE_THROW()
{
	clear();
}

void TableClient::player::Protocol_MSG_TABLE_THROW::clear()
{
	throwableTypeId = 0;
	seat = -1;
}

bool TableClient::player::Protocol_MSG_TABLE_THROW::equals(const Protocol_MSG_TABLE_THROW& _o) const
{
	return throwableTypeId == _o.throwableTypeId &&
		seat == _o.seat;
}

bool TableClient::player::Protocol_MSG_TABLE_THROW::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_THROW != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_THROW*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_THROW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_THROW).append(")");
	_buf.append(',');
	_buf.append("throwableTypeId=");
	_buf.appendUint(throwableTypeId);
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_THROW::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_THROW::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_THROW).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("throwableTypeId", throwableTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_THROW::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("throwableTypeId"))
			{
				throwableTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_THROW::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(throwableTypeId);
	_msg.composeINT8(seat);
}

void TableClient::player::Protocol_MSG_TABLE_THROW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(throwableTypeId);
	_parser.parseINT8(seat);
}

const char *TableClient::player::Protocol_MSG_TABLE_THROW::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("throwableTypeId", throwableTypeId);
	_jsonstr.compose("s", seat);
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_THROW::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("throwableTypeId", throwableTypeId);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_THROW::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_THROW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 throwableTypeId; _jparser.validateByNameThrow("throwableTypeId", throwableTypeId);
	AtfValidator::validateInt(_descr, "throwableTypeId", throwableTypeId, _checker, __FILE__, __LINE__);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_THROW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_THROW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 throwableTypeId; _parser.parseUINT32(throwableTypeId);
	AtfValidator::validateInt(_descr, "throwableTypeId", throwableTypeId, _checker, __FILE__, __LINE__);
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_THROW_REPLY
//=================================================================

TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::Protocol_MSG_TABLE_THROW_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::Protocol_MSG_TABLE_THROW_REPLY(Protocol_MSG_TABLE_THROW_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
{
}

TableClient::player::Protocol_MSG_TABLE_THROW_REPLY& TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::operator=(Protocol_MSG_TABLE_THROW_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
	}
	return *this;
}

#endif

void TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
	clientMsg_txtEx.clear();
}

bool TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::equals(const Protocol_MSG_TABLE_THROW_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx);
}

bool TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_THROW_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_THROW_REPLY*)_other));
}

const char *TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_THROW_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
		_buf.append(',');
		_buf.append("m=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	}
	return _buf.c_str();
}

const char *TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_THROW_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
		Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errStr);
		_msg.composeMsgBody(clientMsg_txtEx);
	}
}

void TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errStr);
		_parser.parseMsgBody(clientMsg_txtEx);
	}
}

const char *TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errStr", errStr);
		_jsonstr.compose("m", clientMsg_txtEx);
	}
	return _buf.c_str();
}

void TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errStr", errStr);
		if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	}
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_THROW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
		AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void TableClient::player::Protocol_MSG_TABLE_THROW_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_THROW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
		size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
		AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClientExtraForTakeFromPotEvent
//=================================================================

// @Override
void TableClient::publication::ClientExtraForTakeFromPotEvent::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(numWinners);
	_msg.composeBOOL(isSingleWinner);
	_msg.composeBOOL(winHighHand);
	_msg.composeINT8(maxPotLevel);
	_msg.composeBYTE(bestHigh);
	if(kickerRanks.size() < 4)
	{
		kickerRanks.composeMsg(_msg, _ignoreJSON);
	}
	else
	{
		for(int i = 0; i < 4; ++i)
		{
			_msg.composeINT8(kickerRanks[i]);
		}
	}
	_msg.composeBYTE(boardNum);
}

// @Override
void TableClient::publication::ClientExtraForTakeFromPotEvent::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(numWinners);
	_parser.parseBOOL(isSingleWinner);
	_parser.parseBOOL(winHighHand);
	_parser.parseINT8(maxPotLevel);
	_parser.parseBYTE(bestHigh);
	for(int i = 0; i < 4; ++i)
	{
		INT8 t;
		_parser.parseINT8(t);
		if(t == 0) break;
		kickerRanks.push_back(t);
	}
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(boardNum);
}

TableClient::publication::ClientExtraForTakeFromPotEvent::ClientExtraForTakeFromPotEvent()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientExtraForTakeFromPotEvent::ClientExtraForTakeFromPotEvent(ClientExtraForTakeFromPotEvent&& _o)
	: numWinners(std::move(_o.numWinners))
	, isSingleWinner(std::move(_o.isSingleWinner))
	, winHighHand(std::move(_o.winHighHand))
	, maxPotLevel(std::move(_o.maxPotLevel))
	, bestHigh(std::move(_o.bestHigh))
	, kickerRanks(std::move(_o.kickerRanks))
	, boardNum(std::move(_o.boardNum))
{
}

TableClient::publication::ClientExtraForTakeFromPotEvent& TableClient::publication::ClientExtraForTakeFromPotEvent::operator=(ClientExtraForTakeFromPotEvent&& _o)
{
	if(this != &_o)
	{
		numWinners = std::move(_o.numWinners);
		isSingleWinner = std::move(_o.isSingleWinner);
		winHighHand = std::move(_o.winHighHand);
		maxPotLevel = std::move(_o.maxPotLevel);
		bestHigh = std::move(_o.bestHigh);
		kickerRanks = std::move(_o.kickerRanks);
		boardNum = std::move(_o.boardNum);
	}
	return *this;
}

#endif

void TableClient::publication::ClientExtraForTakeFromPotEvent::clear()
{
	numWinners = 0;
	isSingleWinner = false;
	winHighHand = false;
	maxPotLevel = 0;
	bestHigh = 0;
	kickerRanks.clear();
	boardNum = 0;
}

bool TableClient::publication::ClientExtraForTakeFromPotEvent::equals(const ClientExtraForTakeFromPotEvent& _o) const
{
	return numWinners == _o.numWinners &&
		isSingleWinner == _o.isSingleWinner &&
		winHighHand == _o.winHighHand &&
		maxPotLevel == _o.maxPotLevel &&
		bestHigh == _o.bestHigh &&
		kickerRanks.equals(_o.kickerRanks) &&
		boardNum == _o.boardNum;
}

const char *TableClient::publication::ClientExtraForTakeFromPotEvent::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numWinners=");
	_buf.appendInt(numWinners);
	_buf.append(',');
	_buf.append("isSingleWinner=");
	_buf.appendUint(isSingleWinner);
	_buf.append(',');
	_buf.append("winHighHand=");
	_buf.appendUint(winHighHand);
	_buf.append(',');
	_buf.append("maxPotLevel=");
	_buf.appendInt(maxPotLevel);
	_buf.append(',');
	_buf.append("bestHigh=");
	_buf.appendUint(bestHigh);
	_buf.append(',');
	_buf.append("kickerRanks=");
	kickerRanks.toTraceString(_buf);
	_buf.append(',');
	_buf.append("boardNum=");
	_buf.appendUint(boardNum);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientExtraForTakeFromPotEvent::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numWinners", numWinners, _buf);
	Atf::XmlElement::encodeAsXmlElement("isSingleWinner", isSingleWinner, _buf);
	Atf::XmlElement::encodeAsXmlElement("winHighHand", winHighHand, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPotLevel", maxPotLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestHigh", bestHigh, _buf);
	kickerRanks.toXmlString("kickerRanks", _buf);
	Atf::XmlElement::encodeAsXmlElement("boardNum", boardNum, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientExtraForTakeFromPotEvent::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numWinners"))
		{
			numWinners = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isSingleWinner"))
		{
			isSingleWinner = (*_value.ptr() == '1');
		}
		else if (_element.equals("winHighHand"))
		{
			winHighHand = (*_value.ptr() == '1');
		}
		else if (_element.equals("maxPotLevel"))
		{
			maxPotLevel = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bestHigh"))
		{
			bestHigh = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("kickerRanks"))
		{
			if(!Atf::AtfTempl< Atf::AtfVector0< INT8, 1 > >::FromXmlString(_value, kickerRanks)) return false;
		}
		else if (_element.equals("boardNum"))
		{
			boardNum = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

const char *TableClient::publication::ClientExtraForTakeFromPotEvent::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numWinners", numWinners);
	_jsonstr.compose("isSingleWinner", isSingleWinner);
	_jsonstr.compose("winHighHand", winHighHand);
	_jsonstr.compose("maxPotLevel", maxPotLevel);
	_jsonstr.compose("bestHigh", bestHigh);
	_jsonstr.compose("kickerRanks", kickerRanks);
	_jsonstr.compose("boardNum", boardNum);
	return _buf.c_str();
}

void TableClient::publication::ClientExtraForTakeFromPotEvent::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numWinners", numWinners);
	_jparser.parseByNameThrow("isSingleWinner", isSingleWinner);
	_jparser.parseByNameThrow("winHighHand", winHighHand);
	_jparser.parseByNameThrow("maxPotLevel", maxPotLevel);
	_jparser.parseByNameThrow("bestHigh", bestHigh);
	_jparser.parseByNameThrow("kickerRanks", kickerRanks);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("boardNum", boardNum);
}

/* static */ void TableClient::publication::ClientExtraForTakeFromPotEvent::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 numWinners; _jparser.validateByNameThrow("numWinners", numWinners);
	AtfValidator::validateInt(_descr, "numWinners", numWinners, _checker, __FILE__, __LINE__);
	bool isSingleWinner; _jparser.validateByNameThrow("isSingleWinner", isSingleWinner);
	AtfValidator::validateInt(_descr, "isSingleWinner", isSingleWinner, _checker, __FILE__, __LINE__);
	bool winHighHand; _jparser.validateByNameThrow("winHighHand", winHighHand);
	AtfValidator::validateInt(_descr, "winHighHand", winHighHand, _checker, __FILE__, __LINE__);
	INT8 maxPotLevel; _jparser.validateByNameThrow("maxPotLevel", maxPotLevel);
	AtfValidator::validateInt(_descr, "maxPotLevel", maxPotLevel, _checker, __FILE__, __LINE__);
	BYTE bestHigh; _jparser.validateByNameThrow("bestHigh", bestHigh);
	AtfValidator::validateInt(_descr, "bestHigh", bestHigh, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT8 > kickerRanks; _jparser.validateByNameThrow("kickerRanks", kickerRanks);
	AtfValidator::validateInt(_descr, "kickerRanks", kickerRanks.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE boardNum; _jparser.validateByNameThrow("boardNum", boardNum);
	AtfValidator::validateInt(_descr, "boardNum", boardNum, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientExtraForTakeFromPotEvent::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 numWinners; _parser.parseINT8(numWinners);
	AtfValidator::validateInt(_descr, "numWinners", numWinners, _checker, __FILE__, __LINE__);
	bool isSingleWinner; _parser.parseBOOL(isSingleWinner);
	AtfValidator::validateInt(_descr, "isSingleWinner", isSingleWinner, _checker, __FILE__, __LINE__);
	bool winHighHand; _parser.parseBOOL(winHighHand);
	AtfValidator::validateInt(_descr, "winHighHand", winHighHand, _checker, __FILE__, __LINE__);
	INT8 maxPotLevel; _parser.parseINT8(maxPotLevel);
	AtfValidator::validateInt(_descr, "maxPotLevel", maxPotLevel, _checker, __FILE__, __LINE__);
	BYTE bestHigh; _parser.parseBYTE(bestHigh);
	AtfValidator::validateInt(_descr, "bestHigh", bestHigh, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szKickerRanks = Atf::AtfVector0< INT8, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("kickerRanks"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "kickerRanks", szKickerRanks, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE boardNum; _parser.parseBYTE(boardNum);
	AtfValidator::validateInt(_descr, "boardNum", boardNum, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_ACTION
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::Protocol_MSG_TABLE_SUBSCR_ACTION()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::clear()
{
	seat = -1;
	action = '0';
	amount = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::equals(const Protocol_MSG_TABLE_SUBSCR_ACTION& _o) const
{
	return seat == _o.seat &&
		action == _o.action &&
		amount == _o.amount;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_ACTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_ACTION*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_ACTION).append(")");
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("a=");
	_buf.append(action);
	_buf.append(',');
	_buf.append("v=");
	_buf.appendUint(amount);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_ACTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("a", action, _buf);
	Atf::XmlElement::encodeAsXmlElement("v", amount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("a") || _element.equals("action"))
			{
				action = *_value.ptr();
			}
			else if (_element.equals("v") || _element.equals("amount"))
			{
				amount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(seat);
	_msg.composeINT8(action);
	_msg.composeUINT32(amount);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(seat);
	{ INT8 _n; _parser.parseINT8(_n); action = _n; }
	_parser.parseUINT32(amount);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("a", action);
	_jsonstr.compose("v", amount);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	if(!_jparser.parseByName("a", action)) _jparser.parseByNameThrow("action", action);
	if(!_jparser.parseByName("v", amount)) _jparser.parseByNameThrow("amount", amount);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_ACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	char action; if(!_jparser.validateByName("a", action)) _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT32 amount; if(!_jparser.validateByName("v", amount)) _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_ACTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	char action; { INT8 _n; _parser.parseINT8(_n); action = _n; }
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::clear()
{
	seat = -1;
	isBlindOrAnte = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::equals(const Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT& _o) const
{
	return seat == _o.seat &&
		isBlindOrAnte == _o.isBlindOrAnte;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_ACTIVESEAT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_ACTIVESEAT).append(")");
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("isBlindOrAnte=");
	_buf.appendUint(isBlindOrAnte);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_ACTIVESEAT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("isBlindOrAnte", isBlindOrAnte, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isBlindOrAnte"))
			{
				isBlindOrAnte = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(seat);
	_msg.composeBYTE(isBlindOrAnte);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(seat);
	_parser.parseBYTE(isBlindOrAnte);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("isBlindOrAnte", isBlindOrAnte);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("isBlindOrAnte", isBlindOrAnte);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_ACTIVESEAT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE isBlindOrAnte; _jparser.validateByNameThrow("isBlindOrAnte", isBlindOrAnte);
	AtfValidator::validateInt(_descr, "isBlindOrAnte", isBlindOrAnte, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_ACTIVESEAT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	BYTE isBlindOrAnte; _parser.parseBYTE(isBlindOrAnte);
	AtfValidator::validateInt(_descr, "isBlindOrAnte", isBlindOrAnte, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_BEGINHAND
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::Protocol_MSG_TABLE_SUBSCR_BEGINHAND()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::clear()
{
	dealer = -1;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::equals(const Protocol_MSG_TABLE_SUBSCR_BEGINHAND& _o) const
{
	return dealer == _o.dealer;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_BEGINHAND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_BEGINHAND*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_BEGINHAND).append(")");
	_buf.append(',');
	_buf.append("dealer=");
	_buf.appendInt(dealer);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_BEGINHAND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("dealer", dealer, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("dealer"))
			{
				dealer = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(dealer);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(dealer);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dealer", dealer);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dealer", dealer);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_BEGINHAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 dealer; _jparser.validateByNameThrow("dealer", dealer);
	AtfValidator::validateInt(_descr, "dealer", dealer, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_BEGINHAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT8 dealer; _parser.parseINT8(dealer);
	AtfValidator::validateInt(_descr, "dealer", dealer, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE(Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE&& _o)
	: seat(std::move(_o.seat))
	, chat(std::move(_o.chat))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::operator=(Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE&& _o)
{
	if(this != &_o)
	{
		seat = std::move(_o.seat);
		chat = std::move(_o.chat);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::clear()
{
	seat = -1;
	chat.clear();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::equals(const Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE& _o) const
{
	return seat == _o.seat &&
		Atf::atfPStringEquals(chat, _o.chat);
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_CHAT_BUBBLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_CHAT_BUBBLE).append(")");
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("chat=");
	_buf.append(chat);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_CHAT_BUBBLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("chat", chat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chat"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chat)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(seat);
	_msg.composeString(chat);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(seat);
	_parser.parseStringP(chat);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("chat", chat);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("chat", chat);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_CHAT_BUBBLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	PString chat; _jparser.validateByNameThrow("chat", chat);
	AtfValidator::validateInt(_descr, "chat", chat.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_CHAT_BUBBLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "chat"); size_t szChat = strlen(_dummy);
	AtfValidator::validateInt(_descr, "chat", szChat, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_DEALBOARD
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::Protocol_MSG_TABLE_SUBSCR_DEALBOARD()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::clear()
{
	numOfBoardCards = 0;
	runItTwiceMode = false;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::equals(const Protocol_MSG_TABLE_SUBSCR_DEALBOARD& _o) const
{
	return numOfBoardCards == _o.numOfBoardCards &&
		runItTwiceMode == _o.runItTwiceMode;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_DEALBOARD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_DEALBOARD*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_DEALBOARD).append(")");
	_buf.append(',');
	_buf.append("numOfBoardCards=");
	_buf.appendUint(numOfBoardCards);
	_buf.append(',');
	_buf.append("runItTwiceMode=");
	_buf.appendUint(runItTwiceMode);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_DEALBOARD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("numOfBoardCards", numOfBoardCards, _buf);
	Atf::XmlElement::encodeAsXmlElement("runItTwiceMode", runItTwiceMode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("numOfBoardCards"))
			{
				numOfBoardCards = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("runItTwiceMode"))
			{
				runItTwiceMode = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(numOfBoardCards);
	_msg.composeBOOL(runItTwiceMode);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(numOfBoardCards);
	_parser.parseBOOL(runItTwiceMode);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numOfBoardCards", numOfBoardCards);
	_jsonstr.compose("runItTwiceMode", runItTwiceMode);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numOfBoardCards", numOfBoardCards);
	_jparser.parseByNameThrow("runItTwiceMode", runItTwiceMode);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_DEALBOARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE numOfBoardCards; _jparser.validateByNameThrow("numOfBoardCards", numOfBoardCards);
	AtfValidator::validateInt(_descr, "numOfBoardCards", numOfBoardCards, _checker, __FILE__, __LINE__);
	bool runItTwiceMode; _jparser.validateByNameThrow("runItTwiceMode", runItTwiceMode);
	AtfValidator::validateInt(_descr, "runItTwiceMode", runItTwiceMode, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_DEALBOARD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE numOfBoardCards; _parser.parseBYTE(numOfBoardCards);
	AtfValidator::validateInt(_descr, "numOfBoardCards", numOfBoardCards, _checker, __FILE__, __LINE__);
	bool runItTwiceMode; _parser.parseBOOL(runItTwiceMode);
	AtfValidator::validateInt(_descr, "runItTwiceMode", runItTwiceMode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::clear()
{
	boardNumber = 0;
	numCardsDealt = 0;
	numBoardCards = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::equals(const Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT& _o) const
{
	return boardNumber == _o.boardNumber &&
		numCardsDealt == _o.numCardsDealt &&
		numBoardCards == _o.numBoardCards;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_DEALBOARD_RIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_DEALBOARD_RIT).append(")");
	_buf.append(',');
	_buf.append("boardNumber=");
	_buf.appendUint(boardNumber);
	_buf.append(',');
	_buf.append("numCardsDealt=");
	_buf.appendUint(numCardsDealt);
	_buf.append(',');
	_buf.append("numBoardCards=");
	_buf.appendUint(numBoardCards);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_DEALBOARD_RIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("boardNumber", boardNumber, _buf);
	Atf::XmlElement::encodeAsXmlElement("numCardsDealt", numCardsDealt, _buf);
	Atf::XmlElement::encodeAsXmlElement("numBoardCards", numBoardCards, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("boardNumber"))
			{
				boardNumber = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numCardsDealt"))
			{
				numCardsDealt = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numBoardCards"))
			{
				numBoardCards = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(boardNumber);
	_msg.composeBYTE(numCardsDealt);
	_msg.composeBYTE(numBoardCards);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(boardNumber);
	_parser.parseBYTE(numCardsDealt);
	_parser.parseBYTE(numBoardCards);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("boardNumber", boardNumber);
	_jsonstr.compose("numCardsDealt", numCardsDealt);
	_jsonstr.compose("numBoardCards", numBoardCards);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("boardNumber", boardNumber);
	_jparser.parseByNameThrow("numCardsDealt", numCardsDealt);
	_jparser.parseByNameThrow("numBoardCards", numBoardCards);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_DEALBOARD_RIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE boardNumber; _jparser.validateByNameThrow("boardNumber", boardNumber);
	AtfValidator::validateInt(_descr, "boardNumber", boardNumber, _checker, __FILE__, __LINE__);
	BYTE numCardsDealt; _jparser.validateByNameThrow("numCardsDealt", numCardsDealt);
	AtfValidator::validateInt(_descr, "numCardsDealt", numCardsDealt, _checker, __FILE__, __LINE__);
	BYTE numBoardCards; _jparser.validateByNameThrow("numBoardCards", numBoardCards);
	AtfValidator::validateInt(_descr, "numBoardCards", numBoardCards, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_DEALBOARD_RIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE boardNumber; _parser.parseBYTE(boardNumber);
	AtfValidator::validateInt(_descr, "boardNumber", boardNumber, _checker, __FILE__, __LINE__);
	BYTE numCardsDealt; _parser.parseBYTE(numCardsDealt);
	AtfValidator::validateInt(_descr, "numCardsDealt", numCardsDealt, _checker, __FILE__, __LINE__);
	BYTE numBoardCards; _parser.parseBYTE(numBoardCards);
	AtfValidator::validateInt(_descr, "numBoardCards", numBoardCards, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS(): playerCardInfos("FF") 
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS(Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS&& _o)
	: playerCardInfos(std::move(_o.playerCardInfos))
	, dealerPos(std::move(_o.dealerPos))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::operator=(Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS&& _o)
{
	if(this != &_o)
	{
		playerCardInfos = std::move(_o.playerCardInfos);
		dealerPos = std::move(_o.dealerPos);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::clear()
{
	playerCardInfos.clear();
	dealerPos = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::equals(const Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS& _o) const
{
	return playerCardInfos.equals(_o.playerCardInfos) &&
		dealerPos == _o.dealerPos;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_DEALPLAYERCARDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_DEALPLAYERCARDS).append(")");
	_buf.append(',');
	_buf.append("playerCardInfos=");
	playerCardInfos.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dealerPos=");
	_buf.appendInt(dealerPos);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_DEALPLAYERCARDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	playerCardInfos.toXmlString("playerCardInfos", _buf);
	Atf::XmlElement::encodeAsXmlElement("dealerPos", dealerPos, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("playerCardInfos"))
			{
				if(!Atf::AtfTempl< Atf::AtfVectorWithSpecialTerminator< P_SuscrPlayerCards > >::FromXmlString(_value, playerCardInfos)) return false;
			}
			else if (_element.equals("dealerPos"))
			{
				dealerPos = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	playerCardInfos.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT8(dealerPos);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::parseMsg(CommMsgParser& _parser)
{
	playerCardInfos.parseMsg(_parser);
	_parser.parseINT8(dealerPos);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playerCardInfos", playerCardInfos);
	_jsonstr.compose("dealerPos", dealerPos);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playerCardInfos", playerCardInfos);
	_jparser.parseByNameThrow("dealerPos", dealerPos);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_DEALPLAYERCARDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< P_SuscrPlayerCards > playerCardInfos; _jparser.validateByNameThrow("playerCardInfos", playerCardInfos);
	AtfValidator::validateInt(_descr, "playerCardInfos", playerCardInfos.size(), _checker, __FILE__, __LINE__);
	INT8 dealerPos; _jparser.validateByNameThrow("dealerPos", dealerPos);
	AtfValidator::validateInt(_descr, "dealerPos", dealerPos, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_DEALPLAYERCARDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szPlayerCardInfos = Atf::AtfVectorWithSpecialTerminator< P_SuscrPlayerCards >::validateMsg(_parser, "FF", _checker, _descbuf.assign(_descr).append('.').append("playerCardInfos"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerCardInfos", szPlayerCardInfos, _checker, __FILE__, __LINE__);
	INT8 dealerPos; _parser.parseINT8(dealerPos);
	AtfValidator::validateInt(_descr, "dealerPos", dealerPos, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_ENDHAND
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::Protocol_MSG_TABLE_SUBSCR_ENDHAND()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::clear()
{
	handStatus = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::equals(const Protocol_MSG_TABLE_SUBSCR_ENDHAND& _o) const
{
	return handStatus == _o.handStatus;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_ENDHAND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_ENDHAND*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_ENDHAND).append(")");
	_buf.append(',');
	_buf.append("handStatus=");
	_buf.appendUint(handStatus);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_ENDHAND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("handStatus", handStatus, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("handStatus"))
			{
				handStatus = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(handStatus);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(handStatus);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handStatus", handStatus);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handStatus", handStatus);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_ENDHAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE handStatus; _jparser.validateByNameThrow("handStatus", handStatus);
	AtfValidator::validateInt(_descr, "handStatus", handStatus, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_ENDHAND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE handStatus; _parser.parseBYTE(handStatus);
	AtfValidator::validateInt(_descr, "handStatus", handStatus, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE(Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE&& _o)
	: i18nString(std::move(_o.i18nString))
	, timerValue(std::move(_o.timerValue))
	, flags(std::move(_o.flags))
	, chatItemId(std::move(_o.chatItemId))
	, brandMask(std::move(_o.brandMask))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::operator=(Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE&& _o)
{
	if(this != &_o)
	{
		i18nString = std::move(_o.i18nString);
		timerValue = std::move(_o.timerValue);
		flags = std::move(_o.flags);
		chatItemId = std::move(_o.chatItemId);
		brandMask = std::move(_o.brandMask);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::clear()
{
	i18nString.clear();
	timerValue = 0;
	flags = 0;
	chatItemId = 0;
	brandMask = BrandType_ALLMask;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::equals(const Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE& _o) const
{
	return i18nString.equals(_o.i18nString) &&
		timerValue == _o.timerValue &&
		flags == _o.flags &&
		chatItemId == _o.chatItemId &&
		brandMask == _o.brandMask;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_I18N_MESSAGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_I18N_MESSAGE).append(")");
	_buf.append(',');
	_buf.append("i18nString=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, i18nString);
	_buf.append(',');
	_buf.append("timerValue=");
	_buf.appendUint(timerValue);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("chatItemId=");
	_buf.appendUint(chatItemId);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_I18N_MESSAGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "i18nString", i18nString);
	Atf::XmlElement::encodeAsXmlElement("timerValue", timerValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatItemId", chatItemId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("i18nString"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, i18nString);
			}
			else if (_element.equals("timerValue"))
			{
				timerValue = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chatItemId"))
			{
				chatItemId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("brandMask"))
			{
				brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	i18nString.compose(_msg);
	_msg.composeUINT16(timerValue);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(chatItemId);
	_msg.composeUINT32(brandMask);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::parseMsg(CommMsgParser& _parser)
{
	i18nString.parse(_parser);
	_parser.parseUINT16(timerValue);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(chatItemId);
	_parser.parseUINT32(brandMask);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("i18nString", i18nString);
	_jsonstr.compose("timerValue", timerValue);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("chatItemId", chatItemId);
	_jsonstr.compose("brandMask", brandMask);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("i18nString", i18nString);
	_jparser.parseByNameThrow("timerValue", timerValue);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("chatItemId", chatItemId);
	_jparser.parseByNameThrow("brandMask", brandMask);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_I18N_MESSAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	I18nPString i18nString; _jparser.validateByNameThrow("i18nString", i18nString);
	UINT16 timerValue; _jparser.validateByNameThrow("timerValue", timerValue);
	AtfValidator::validateInt(_descr, "timerValue", timerValue, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 chatItemId; _jparser.validateByNameThrow("chatItemId", chatItemId);
	AtfValidator::validateInt(_descr, "chatItemId", chatItemId, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_I18N_MESSAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	I18nPString i18nString; i18nString.parse(_parser);
	UINT16 timerValue; _parser.parseUINT16(timerValue);
	AtfValidator::validateInt(_descr, "timerValue", timerValue, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 chatItemId; _parser.parseUINT32(chatItemId);
	AtfValidator::validateInt(_descr, "chatItemId", chatItemId, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClientMsg_TxtEx_Tournmt_NewRound
//=================================================================

TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::ClientMsg_TxtEx_Tournmt_NewRound()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::ClientMsg_TxtEx_Tournmt_NewRound(ClientMsg_TxtEx_Tournmt_NewRound&& _o)
	: handType(std::move(_o.handType))
	, potStruct(std::move(_o.potStruct))
	, stakeSmall(std::move(_o.stakeSmall))
	, stakeBig(std::move(_o.stakeBig))
	, ante(std::move(_o.ante))
	, round(std::move(_o.round))
	, tableStakes(std::move(_o.tableStakes))
{
}

TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound& TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::operator=(ClientMsg_TxtEx_Tournmt_NewRound&& _o)
{
	if(this != &_o)
	{
		handType = std::move(_o.handType);
		potStruct = std::move(_o.potStruct);
		stakeSmall = std::move(_o.stakeSmall);
		stakeBig = std::move(_o.stakeBig);
		ante = std::move(_o.ante);
		round = std::move(_o.round);
		tableStakes = std::move(_o.tableStakes);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::clear()
{
	handType = 0;
	potStruct = 0;
	stakeSmall = 0;
	stakeBig = 0;
	ante = 0;
	round = 0;
	tableStakes.clear();
}

bool TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::equals(const ClientMsg_TxtEx_Tournmt_NewRound& _o) const
{
	return handType == _o.handType &&
		potStruct == _o.potStruct &&
		stakeSmall == _o.stakeSmall &&
		stakeBig == _o.stakeBig &&
		ante == _o.ante &&
		round == _o.round &&
		tableStakes.equals(_o.tableStakes);
}

const char *TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("potStruct=");
	_buf.appendUint(potStruct);
	_buf.append(',');
	_buf.append("stakeSmall=");
	_buf.appendUint(stakeSmall);
	_buf.append(',');
	_buf.append("stakeBig=");
	_buf.appendUint(stakeBig);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("round=");
	_buf.appendInt(round);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("potStruct", potStruct, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeSmall", stakeSmall, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeBig", stakeBig, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("round", round, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("potStruct"))
		{
			potStruct = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeSmall"))
		{
			stakeSmall = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeBig"))
		{
			stakeBig = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("round"))
		{
			round = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(handType);
	_msg.composeBYTE(potStruct);
	_msg.composeUINT32(stakeSmall);
	_msg.composeUINT32(stakeBig);
	_msg.composeUINT32(ante);
	_msg.composeINT8(round);
	tableStakes.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(handType);
	_parser.parseBYTE(potStruct);
	_parser.parseUINT32(stakeSmall);
	_parser.parseUINT32(stakeBig);
	_parser.parseUINT32(ante);
	_parser.parseINT8(round);
	if(_parser.parseEnded()) return;
	tableStakes.parseMsg(_parser);
}

const char *TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("potStruct", potStruct);
	_jsonstr.compose("stakeSmall", stakeSmall);
	_jsonstr.compose("stakeBig", stakeBig);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("round", round);
	_jsonstr.compose("tableStakes", tableStakes);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("potStruct", potStruct);
	_jparser.parseByNameThrow("stakeSmall", stakeSmall);
	_jparser.parseByNameThrow("stakeBig", stakeBig);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("round", round);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE potStruct; _jparser.validateByNameThrow("potStruct", potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
	UINT32 stakeSmall; _jparser.validateByNameThrow("stakeSmall", stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _jparser.validateByNameThrow("stakeBig", stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT8 round; _jparser.validateByNameThrow("round", round);
	AtfValidator::validateInt(_descr, "round", round, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewRound::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
	UINT32 stakeSmall; _parser.parseUINT32(stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _parser.parseUINT32(stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	INT8 round; _parser.parseINT8(round);
	AtfValidator::validateInt(_descr, "round", round, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    ClientMsg_TxtEx_Tournmt_NewStakes
//=================================================================

TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::ClientMsg_TxtEx_Tournmt_NewStakes()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::ClientMsg_TxtEx_Tournmt_NewStakes(ClientMsg_TxtEx_Tournmt_NewStakes&& _o)
	: handType(std::move(_o.handType))
	, potStruct(std::move(_o.potStruct))
	, stakeSmall(std::move(_o.stakeSmall))
	, stakeBig(std::move(_o.stakeBig))
	, ante(std::move(_o.ante))
	, tableStakes(std::move(_o.tableStakes))
{
}

TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes& TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::operator=(ClientMsg_TxtEx_Tournmt_NewStakes&& _o)
{
	if(this != &_o)
	{
		handType = std::move(_o.handType);
		potStruct = std::move(_o.potStruct);
		stakeSmall = std::move(_o.stakeSmall);
		stakeBig = std::move(_o.stakeBig);
		ante = std::move(_o.ante);
		tableStakes = std::move(_o.tableStakes);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::clear()
{
	handType = 0;
	potStruct = 0;
	stakeSmall = 0;
	stakeBig = 0;
	ante = 0;
	tableStakes.clear();
}

bool TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::equals(const ClientMsg_TxtEx_Tournmt_NewStakes& _o) const
{
	return handType == _o.handType &&
		potStruct == _o.potStruct &&
		stakeSmall == _o.stakeSmall &&
		stakeBig == _o.stakeBig &&
		ante == _o.ante &&
		tableStakes.equals(_o.tableStakes);
}

const char *TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("potStruct=");
	_buf.appendUint(potStruct);
	_buf.append(',');
	_buf.append("stakeSmall=");
	_buf.appendUint(stakeSmall);
	_buf.append(',');
	_buf.append("stakeBig=");
	_buf.appendUint(stakeBig);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("potStruct", potStruct, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeSmall", stakeSmall, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeBig", stakeBig, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("potStruct"))
		{
			potStruct = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeSmall"))
		{
			stakeSmall = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeBig"))
		{
			stakeBig = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(handType);
	_msg.composeBYTE(potStruct);
	_msg.composeUINT32(stakeSmall);
	_msg.composeUINT32(stakeBig);
	_msg.composeUINT32(ante);
	tableStakes.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(handType);
	_parser.parseBYTE(potStruct);
	_parser.parseUINT32(stakeSmall);
	_parser.parseUINT32(stakeBig);
	_parser.parseUINT32(ante);
	if(_parser.parseEnded()) return;
	tableStakes.parseMsg(_parser);
}

const char *TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("potStruct", potStruct);
	_jsonstr.compose("stakeSmall", stakeSmall);
	_jsonstr.compose("stakeBig", stakeBig);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("tableStakes", tableStakes);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("potStruct", potStruct);
	_jparser.parseByNameThrow("stakeSmall", stakeSmall);
	_jparser.parseByNameThrow("stakeBig", stakeBig);
	_jparser.parseByNameThrow("ante", ante);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE potStruct; _jparser.validateByNameThrow("potStruct", potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
	UINT32 stakeSmall; _jparser.validateByNameThrow("stakeSmall", stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _jparser.validateByNameThrow("stakeBig", stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_Tournmt_NewStakes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
	UINT32 stakeSmall; _parser.parseUINT32(stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _parser.parseUINT32(stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    ClientMsg_TxtEx_Milestone_Hand
//=================================================================

TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::ClientMsg_TxtEx_Milestone_Hand()
{
	clear();
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::clear()
{
	handId = 0;
}

bool TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::equals(const ClientMsg_TxtEx_Milestone_Hand& _o) const
{
	return handId == _o.handId;
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handId"))
		{
			handId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handId", handId);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handId", handId);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_Milestone_Hand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ClientMsg_TxtEx_Milestone_Prior_Draw
//=================================================================

TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::ClientMsg_TxtEx_Milestone_Prior_Draw()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::ClientMsg_TxtEx_Milestone_Prior_Draw(ClientMsg_TxtEx_Milestone_Prior_Draw&& _o)
	: prize(std::move(_o.prize))
{
}

TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw& TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::operator=(ClientMsg_TxtEx_Milestone_Prior_Draw&& _o)
{
	if(this != &_o)
	{
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::clear()
{
	prize.clear();
}

bool TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::equals(const ClientMsg_TxtEx_Milestone_Prior_Draw& _o) const
{
	return prize.equals(_o.prize);
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	prize.toXmlString("prize", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prize"))
		{
			if(!Atf::AtfTempl< TournMileStonePrize >::FromXmlString(_value, prize)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	prize.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::parseMsg(CommMsgParser& _parser)
{
	prize.parseMsg(_parser);
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prize", prize);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prize", prize);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TournMileStonePrize prize; _jparser.validateByNameThrow("prize", prize);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_Milestone_Prior_Draw::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	TournMileStonePrize::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    ClientMsg_TxtEx_Milestone_Losing_Table
//=================================================================

TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::ClientMsg_TxtEx_Milestone_Losing_Table()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::ClientMsg_TxtEx_Milestone_Losing_Table(ClientMsg_TxtEx_Milestone_Losing_Table&& _o)
	: numOfWinningTables(std::move(_o.numOfWinningTables))
	, winningTableName(std::move(_o.winningTableName))
	, winningTableServerAddress(std::move(_o.winningTableServerAddress))
	, winningTableServerObject(std::move(_o.winningTableServerObject))
	, winningTableId(std::move(_o.winningTableId))
	, numWinningPlayers(std::move(_o.numWinningPlayers))
	, prize(std::move(_o.prize))
{
}

TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table& TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::operator=(ClientMsg_TxtEx_Milestone_Losing_Table&& _o)
{
	if(this != &_o)
	{
		numOfWinningTables = std::move(_o.numOfWinningTables);
		winningTableName = std::move(_o.winningTableName);
		winningTableServerAddress = std::move(_o.winningTableServerAddress);
		winningTableServerObject = std::move(_o.winningTableServerObject);
		winningTableId = std::move(_o.winningTableId);
		numWinningPlayers = std::move(_o.numWinningPlayers);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::clear()
{
	numOfWinningTables = 0;
	winningTableName.clear();
	winningTableServerAddress.clear();
	winningTableServerObject.clear();
	winningTableId = 0;
	numWinningPlayers = 0;
	prize.clear();
}

bool TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::equals(const ClientMsg_TxtEx_Milestone_Losing_Table& _o) const
{
	return numOfWinningTables == _o.numOfWinningTables &&
		Atf::atfPStringEquals(winningTableName, _o.winningTableName) &&
		Atf::atfPStringEquals(winningTableServerAddress, _o.winningTableServerAddress) &&
		Atf::atfPStringEquals(winningTableServerObject, _o.winningTableServerObject) &&
		winningTableId == _o.winningTableId &&
		numWinningPlayers == _o.numWinningPlayers &&
		prize.equals(_o.prize);
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numOfWinningTables=");
	_buf.appendInt(numOfWinningTables);
	_buf.append(',');
	_buf.append("winningTableName=");
	_buf.append(winningTableName);
	_buf.append(',');
	_buf.append("winningTableServerAddress=");
	_buf.append(winningTableServerAddress);
	_buf.append(',');
	_buf.append("winningTableServerObject=");
	_buf.append(winningTableServerObject);
	_buf.append(',');
	_buf.append("winningTableId=");
	_buf.appendUint64(winningTableId);
	_buf.append(',');
	_buf.append("numWinningPlayers=");
	_buf.appendUint(numWinningPlayers);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numOfWinningTables", numOfWinningTables, _buf);
	Atf::XmlElement::encodeAsXmlElement("winningTableName", winningTableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("winningTableServerAddress", winningTableServerAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("winningTableServerObject", winningTableServerObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("winningTableId", winningTableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("numWinningPlayers", numWinningPlayers, _buf);
	prize.toXmlString("prize", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numOfWinningTables"))
		{
			numOfWinningTables = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winningTableName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, winningTableName)) return false;
		}
		else if (_element.equals("winningTableServerAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, winningTableServerAddress)) return false;
		}
		else if (_element.equals("winningTableServerObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, winningTableServerObject)) return false;
		}
		else if (_element.equals("winningTableId"))
		{
			winningTableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numWinningPlayers"))
		{
			numWinningPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prize"))
		{
			if(!Atf::AtfTempl< TournMileStonePrize >::FromXmlString(_value, prize)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(numOfWinningTables);
	_msg.composeString(winningTableName);
	_msg.composeString(winningTableServerAddress);
	_msg.composeString(winningTableServerObject);
	_msg.composeUINT64(winningTableId);
	_msg.composeUINT32(numWinningPlayers);
	prize.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(numOfWinningTables);
	_parser.parseStringP(winningTableName);
	_parser.parseStringP(winningTableServerAddress);
	_parser.parseStringP(winningTableServerObject);
	_parser.parseUINT64(winningTableId);
	_parser.parseUINT32(numWinningPlayers);
	prize.parseMsg(_parser);
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numOfWinningTables", numOfWinningTables);
	_jsonstr.compose("winningTableName", winningTableName);
	_jsonstr.compose("winningTableServerAddress", winningTableServerAddress);
	_jsonstr.compose("winningTableServerObject", winningTableServerObject);
	_jsonstr.compose("winningTableId", winningTableId);
	_jsonstr.compose("numWinningPlayers", numWinningPlayers);
	_jsonstr.compose("prize", prize);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numOfWinningTables", numOfWinningTables);
	_jparser.parseByNameThrow("winningTableName", winningTableName);
	_jparser.parseByNameThrow("winningTableServerAddress", winningTableServerAddress);
	_jparser.parseByNameThrow("winningTableServerObject", winningTableServerObject);
	_jparser.parseByNameThrow("winningTableId", winningTableId);
	_jparser.parseByNameThrow("numWinningPlayers", numWinningPlayers);
	_jparser.parseByNameThrow("prize", prize);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numOfWinningTables; _jparser.validateByNameThrow("numOfWinningTables", numOfWinningTables);
	AtfValidator::validateInt(_descr, "numOfWinningTables", numOfWinningTables, _checker, __FILE__, __LINE__);
	PString winningTableName; _jparser.validateByNameThrow("winningTableName", winningTableName);
	AtfValidator::validateInt(_descr, "winningTableName", winningTableName.length(), _checker, __FILE__, __LINE__);
	PString winningTableServerAddress; _jparser.validateByNameThrow("winningTableServerAddress", winningTableServerAddress);
	AtfValidator::validateInt(_descr, "winningTableServerAddress", winningTableServerAddress.length(), _checker, __FILE__, __LINE__);
	PString winningTableServerObject; _jparser.validateByNameThrow("winningTableServerObject", winningTableServerObject);
	AtfValidator::validateInt(_descr, "winningTableServerObject", winningTableServerObject.length(), _checker, __FILE__, __LINE__);
	UINT64 winningTableId; _jparser.validateByNameThrow("winningTableId", winningTableId);
	AtfValidator::validateUint(_descr, "winningTableId", winningTableId, _checker, __FILE__, __LINE__);
	UINT32 numWinningPlayers; _jparser.validateByNameThrow("numWinningPlayers", numWinningPlayers);
	AtfValidator::validateInt(_descr, "numWinningPlayers", numWinningPlayers, _checker, __FILE__, __LINE__);
	TournMileStonePrize prize; _jparser.validateByNameThrow("prize", prize);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_Milestone_Losing_Table::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 numOfWinningTables; _parser.parseINT32(numOfWinningTables);
	AtfValidator::validateInt(_descr, "numOfWinningTables", numOfWinningTables, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "winningTableName"); size_t szWinningTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "winningTableName", szWinningTableName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "winningTableServerAddress"); size_t szWinningTableServerAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "winningTableServerAddress", szWinningTableServerAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "winningTableServerObject"); size_t szWinningTableServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "winningTableServerObject", szWinningTableServerObject, _checker, __FILE__, __LINE__);
	UINT64 winningTableId; _parser.parseUINT64(winningTableId);
	AtfValidator::validateUint(_descr, "winningTableId", winningTableId, _checker, __FILE__, __LINE__);
	UINT32 numWinningPlayers; _parser.parseUINT32(numWinningPlayers);
	AtfValidator::validateInt(_descr, "numWinningPlayers", numWinningPlayers, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TournMileStonePrize::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    ClientMsg_TxtEx_Milestone_Winners
//=================================================================

TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::ClientMsg_TxtEx_Milestone_Winners()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::ClientMsg_TxtEx_Milestone_Winners(ClientMsg_TxtEx_Milestone_Winners&& _o)
	: tables(std::move(_o.tables))
	, nWinners(std::move(_o.nWinners))
	, prize(std::move(_o.prize))
{
}

TableClient::publication::ClientMsg_TxtEx_Milestone_Winners& TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::operator=(ClientMsg_TxtEx_Milestone_Winners&& _o)
{
	if(this != &_o)
	{
		tables = std::move(_o.tables);
		nWinners = std::move(_o.nWinners);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::clear()
{
	tables.clear();
	nWinners = 0;
	prize.clear();
}

bool TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::equals(const ClientMsg_TxtEx_Milestone_Winners& _o) const
{
	return tables.equals(_o.tables) &&
		nWinners == _o.nWinners &&
		prize.equals(_o.prize);
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tables=");
	tables.toTraceString(_buf);
	_buf.append(',');
	_buf.append("nWinners=");
	_buf.appendUint(nWinners);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	tables.toXmlString("tables", _buf);
	Atf::XmlElement::encodeAsXmlElement("nWinners", nWinners, _buf);
	prize.toXmlString("prize", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tables"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, tables)) return false;
		}
		else if (_element.equals("nWinners"))
		{
			nWinners = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prize"))
		{
			if(!Atf::AtfTempl< TournMileStonePrize >::FromXmlString(_value, prize)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tables.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(nWinners);
	prize.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::parseMsg(CommMsgParser& _parser)
{
	tables.parseMsg(_parser);
	_parser.parseUINT32(nWinners);
	prize.parseMsg(_parser);
}

const char *TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tables", tables);
	_jsonstr.compose("nWinners", nWinners);
	_jsonstr.compose("prize", prize);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tables", tables);
	_jparser.parseByNameThrow("nWinners", nWinners);
	_jparser.parseByNameThrow("prize", prize);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PString > tables; _jparser.validateByNameThrow("tables", tables);
	AtfValidator::validateInt(_descr, "tables", tables.size(), _checker, __FILE__, __LINE__);
	UINT32 nWinners; _jparser.validateByNameThrow("nWinners", nWinners);
	AtfValidator::validateInt(_descr, "nWinners", nWinners, _checker, __FILE__, __LINE__);
	TournMileStonePrize prize; _jparser.validateByNameThrow("prize", prize);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_Milestone_Winners::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szTables = Atf::LAtfVector< PString , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tables"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tables", szTables, _checker, __FILE__, __LINE__);
	UINT32 nWinners; _parser.parseUINT32(nWinners);
	AtfValidator::validateInt(_descr, "nWinners", nWinners, _checker, __FILE__, __LINE__);
	TournMileStonePrize::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    ClientMsg_TxtEx_TableHistory_StartNewHand
//=================================================================

TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::ClientMsg_TxtEx_TableHistory_StartNewHand()
{
	clear();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::clear()
{
	started.setNull();
	stakeSmall = 0;
	stakeBig = 0;
	smallBlind = 0;
	ante = 0;
	handType = 0;
	isHiLo = 0;
	potStruct = 0;
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::equals(const ClientMsg_TxtEx_TableHistory_StartNewHand& _o) const
{
	return started.equals(_o.started) &&
		stakeSmall == _o.stakeSmall &&
		stakeBig == _o.stakeBig &&
		smallBlind == _o.smallBlind &&
		ante == _o.ante &&
		handType == _o.handType &&
		isHiLo == _o.isHiLo &&
		potStruct == _o.potStruct;
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("started=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, started);
	_buf.append(',');
	_buf.append("stakeSmall=");
	_buf.appendUint(stakeSmall);
	_buf.append(',');
	_buf.append("stakeBig=");
	_buf.appendUint(stakeBig);
	_buf.append(',');
	_buf.append("smallBlind=");
	_buf.appendUint(smallBlind);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("potStruct=");
	_buf.appendUint(potStruct);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "started", started);
	Atf::XmlElement::encodeAsXmlElement("stakeSmall", stakeSmall, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeBig", stakeBig, _buf);
	Atf::XmlElement::encodeAsXmlElement("smallBlind", smallBlind, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("potStruct", potStruct, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("started"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, started);
		}
		else if (_element.equals("stakeSmall"))
		{
			stakeSmall = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeBig"))
		{
			stakeBig = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("smallBlind"))
		{
			smallBlind = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("potStruct"))
		{
			potStruct = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(started);
	_msg.composeUINT32(stakeSmall);
	_msg.composeUINT32(stakeBig);
	_msg.composeUINT32(smallBlind);
	_msg.composeUINT32(ante);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(potStruct);
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(started);
	_parser.parseUINT32(stakeSmall);
	_parser.parseUINT32(stakeBig);
	_parser.parseUINT32(smallBlind);
	_parser.parseUINT32(ante);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(potStruct);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("started", started);
	_jsonstr.compose("stakeSmall", stakeSmall);
	_jsonstr.compose("stakeBig", stakeBig);
	_jsonstr.compose("smallBlind", smallBlind);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("potStruct", potStruct);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("started", started);
	_jparser.parseByNameThrow("stakeSmall", stakeSmall);
	_jparser.parseByNameThrow("stakeBig", stakeBig);
	_jparser.parseByNameThrow("smallBlind", smallBlind);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("potStruct", potStruct);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CommSrvTime started; _jparser.validateByNameThrow("started", started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	UINT32 stakeSmall; _jparser.validateByNameThrow("stakeSmall", stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _jparser.validateByNameThrow("stakeBig", stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT32 smallBlind; _jparser.validateByNameThrow("smallBlind", smallBlind);
	AtfValidator::validateInt(_descr, "smallBlind", smallBlind, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE potStruct; _jparser.validateByNameThrow("potStruct", potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	CommSrvTime started; _parser.parseSrvTime(started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	UINT32 stakeSmall; _parser.parseUINT32(stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _parser.parseUINT32(stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT32 smallBlind; _parser.parseUINT32(smallBlind);
	AtfValidator::validateInt(_descr, "smallBlind", smallBlind, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ClientMsg_TxtEx_TableHistory_StartNewGame
//=================================================================

TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::ClientMsg_TxtEx_TableHistory_StartNewGame()
{
	clear();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::clear()
{
	stakeSmall = 0;
	stakeBig = 0;
	ante = 0;
	handType = 0;
	isHiLo = 0;
	potStruct = 0;
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::equals(const ClientMsg_TxtEx_TableHistory_StartNewGame& _o) const
{
	return stakeSmall == _o.stakeSmall &&
		stakeBig == _o.stakeBig &&
		ante == _o.ante &&
		handType == _o.handType &&
		isHiLo == _o.isHiLo &&
		potStruct == _o.potStruct;
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("stakeSmall=");
	_buf.appendUint(stakeSmall);
	_buf.append(',');
	_buf.append("stakeBig=");
	_buf.appendUint(stakeBig);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("potStruct=");
	_buf.appendUint(potStruct);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("stakeSmall", stakeSmall, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeBig", stakeBig, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("potStruct", potStruct, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("stakeSmall"))
		{
			stakeSmall = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeBig"))
		{
			stakeBig = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("potStruct"))
		{
			potStruct = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(stakeSmall);
	_msg.composeUINT32(stakeBig);
	_msg.composeUINT32(ante);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(potStruct);
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(stakeSmall);
	_parser.parseUINT32(stakeBig);
	_parser.parseUINT32(ante);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(potStruct);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("stakeSmall", stakeSmall);
	_jsonstr.compose("stakeBig", stakeBig);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("potStruct", potStruct);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stakeSmall", stakeSmall);
	_jparser.parseByNameThrow("stakeBig", stakeBig);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("potStruct", potStruct);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 stakeSmall; _jparser.validateByNameThrow("stakeSmall", stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _jparser.validateByNameThrow("stakeBig", stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE potStruct; _jparser.validateByNameThrow("potStruct", potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_TableHistory_StartNewGame::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 stakeSmall; _parser.parseUINT32(stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _parser.parseUINT32(stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ClientMsg_TxtEx_TableHistory_Dealing
//=================================================================

TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::ClientMsg_TxtEx_TableHistory_Dealing()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::ClientMsg_TxtEx_TableHistory_Dealing(ClientMsg_TxtEx_TableHistory_Dealing&& _o)
	: holeCardsDict(std::move(_o.holeCardsDict))
{
}

TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing& TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::operator=(ClientMsg_TxtEx_TableHistory_Dealing&& _o)
{
	if(this != &_o)
	{
		holeCardsDict = std::move(_o.holeCardsDict);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::clear()
{
	holeCardsDict.clear();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::equals(const ClientMsg_TxtEx_TableHistory_Dealing& _o) const
{
	return holeCardsDict.equals(_o.holeCardsDict);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("holeCardsDict=");
	holeCardsDict.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	holeCardsDict.toXmlString("holeCardsDict", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("holeCardsDict"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, holeCardsDict)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	holeCardsDict.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::parseMsg(CommMsgParser& _parser)
{
	holeCardsDict.parseMsg(_parser);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("holeCardsDict", holeCardsDict);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("holeCardsDict", holeCardsDict);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TableCommon::P_Card > holeCardsDict; _jparser.validateByNameThrow("holeCardsDict", holeCardsDict);
	AtfValidator::validateInt(_descr, "holeCardsDict", holeCardsDict.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_TableHistory_Dealing::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szHoleCardsDict = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("holeCardsDict"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "holeCardsDict", szHoleCardsDict, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ClientMsg_TxtEx_TableHistory_CardsShown
//=================================================================

TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::ClientMsg_TxtEx_TableHistory_CardsShown()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::ClientMsg_TxtEx_TableHistory_CardsShown(ClientMsg_TxtEx_TableHistory_CardsShown&& _o)
	: cards(std::move(_o.cards))
{
}

TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown& TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::operator=(ClientMsg_TxtEx_TableHistory_CardsShown&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::clear()
{
	cards.clear();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::equals(const ClientMsg_TxtEx_TableHistory_CardsShown& _o) const
{
	return Atf::atfPStringEquals(cards, _o.cards);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cards=");
	_buf.append(cards);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cards", cards, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cards"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(cards);
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(cards);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cards", cards);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cards", cards);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_TableHistory_CardsShown::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "cards"); size_t szCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ClientMsg_TxtEx_TableHistory_WinningHand
//=================================================================

TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::ClientMsg_TxtEx_TableHistory_WinningHand()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::ClientMsg_TxtEx_TableHistory_WinningHand(ClientMsg_TxtEx_TableHistory_WinningHand&& _o)
	: bestHigh(std::move(_o.bestHigh))
	, bestHighHand(std::move(_o.bestHighHand))
	, bestLowHand(std::move(_o.bestLowHand))
	, bestLow(std::move(_o.bestLow))
	, boardNum(std::move(_o.boardNum))
{
}

TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand& TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::operator=(ClientMsg_TxtEx_TableHistory_WinningHand&& _o)
{
	if(this != &_o)
	{
		bestHigh = std::move(_o.bestHigh);
		bestHighHand = std::move(_o.bestHighHand);
		bestLowHand = std::move(_o.bestLowHand);
		bestLow = std::move(_o.bestLow);
		boardNum = std::move(_o.boardNum);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::clear()
{
	bestHigh = 0;
	bestHighHand.clear();
	bestLowHand.clear();
	bestLow = 0;
	boardNum = 0;
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::equals(const ClientMsg_TxtEx_TableHistory_WinningHand& _o) const
{
	return bestHigh == _o.bestHigh &&
		Atf::atfPStringEquals(bestHighHand, _o.bestHighHand) &&
		Atf::atfPStringEquals(bestLowHand, _o.bestLowHand) &&
		bestLow == _o.bestLow &&
		boardNum == _o.boardNum;
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bestHigh=");
	_buf.appendUint(bestHigh);
	_buf.append(',');
	_buf.append("bestHighHand=");
	_buf.append(bestHighHand);
	_buf.append(',');
	_buf.append("bestLowHand=");
	_buf.append(bestLowHand);
	_buf.append(',');
	_buf.append("bestLow=");
	_buf.appendUint(bestLow);
	_buf.append(',');
	_buf.append("boardNum=");
	_buf.appendUint(boardNum);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("bestHigh", bestHigh, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestHighHand", bestHighHand, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestLowHand", bestLowHand, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestLow", bestLow, _buf);
	Atf::XmlElement::encodeAsXmlElement("boardNum", boardNum, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("bestHigh"))
		{
			bestHigh = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bestHighHand"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bestHighHand)) return false;
		}
		else if (_element.equals("bestLowHand"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bestLowHand)) return false;
		}
		else if (_element.equals("bestLow"))
		{
			bestLow = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("boardNum"))
		{
			boardNum = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(bestHigh);
	_msg.composeString(bestHighHand);
	_msg.composeString(bestLowHand);
	_msg.composeBYTE(bestLow);
	_msg.composeBYTE(boardNum);
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(bestHigh);
	_parser.parseStringP(bestHighHand);
	_parser.parseStringP(bestLowHand);
	_parser.parseBYTE(bestLow);
	_parser.parseBYTE(boardNum);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bestHigh", bestHigh);
	_jsonstr.compose("bestHighHand", bestHighHand);
	_jsonstr.compose("bestLowHand", bestLowHand);
	_jsonstr.compose("bestLow", bestLow);
	_jsonstr.compose("boardNum", boardNum);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bestHigh", bestHigh);
	_jparser.parseByNameThrow("bestHighHand", bestHighHand);
	_jparser.parseByNameThrow("bestLowHand", bestLowHand);
	_jparser.parseByNameThrow("bestLow", bestLow);
	_jparser.parseByNameThrow("boardNum", boardNum);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE bestHigh; _jparser.validateByNameThrow("bestHigh", bestHigh);
	AtfValidator::validateInt(_descr, "bestHigh", bestHigh, _checker, __FILE__, __LINE__);
	PString bestHighHand; _jparser.validateByNameThrow("bestHighHand", bestHighHand);
	AtfValidator::validateInt(_descr, "bestHighHand", bestHighHand.length(), _checker, __FILE__, __LINE__);
	PString bestLowHand; _jparser.validateByNameThrow("bestLowHand", bestLowHand);
	AtfValidator::validateInt(_descr, "bestLowHand", bestLowHand.length(), _checker, __FILE__, __LINE__);
	BYTE bestLow; _jparser.validateByNameThrow("bestLow", bestLow);
	AtfValidator::validateInt(_descr, "bestLow", bestLow, _checker, __FILE__, __LINE__);
	BYTE boardNum; _jparser.validateByNameThrow("boardNum", boardNum);
	AtfValidator::validateInt(_descr, "boardNum", boardNum, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_TableHistory_WinningHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE bestHigh; _parser.parseBYTE(bestHigh);
	AtfValidator::validateInt(_descr, "bestHigh", bestHigh, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bestHighHand"); size_t szBestHighHand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bestHighHand", szBestHighHand, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bestLowHand"); size_t szBestLowHand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bestLowHand", szBestLowHand, _checker, __FILE__, __LINE__);
	BYTE bestLow; _parser.parseBYTE(bestLow);
	AtfValidator::validateInt(_descr, "bestLow", bestLow, _checker, __FILE__, __LINE__);
	BYTE boardNum; _parser.parseBYTE(boardNum);
	AtfValidator::validateInt(_descr, "boardNum", boardNum, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ClientMsg_TxtEx_TableHistory_ShownHand
//=================================================================

TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::ClientMsg_TxtEx_TableHistory_ShownHand()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::ClientMsg_TxtEx_TableHistory_ShownHand(ClientMsg_TxtEx_TableHistory_ShownHand&& _o)
	: cmp(std::move(_o.cmp))
	, bestHigh(std::move(_o.bestHigh))
	, bestHighHand(std::move(_o.bestHighHand))
	, kicker(std::move(_o.kicker))
	, extraKickerRanks(std::move(_o.extraKickerRanks))
	, boardNum(std::move(_o.boardNum))
{
}

TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand& TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::operator=(ClientMsg_TxtEx_TableHistory_ShownHand&& _o)
{
	if(this != &_o)
	{
		cmp = std::move(_o.cmp);
		bestHigh = std::move(_o.bestHigh);
		bestHighHand = std::move(_o.bestHighHand);
		kicker = std::move(_o.kicker);
		extraKickerRanks = std::move(_o.extraKickerRanks);
		boardNum = std::move(_o.boardNum);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::clear()
{
	cmp = 0;
	bestHigh = 0;
	bestHighHand.clear();
	kicker.clear();
	extraKickerRanks.clear();
	boardNum = 0;
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::equals(const ClientMsg_TxtEx_TableHistory_ShownHand& _o) const
{
	return cmp == _o.cmp &&
		bestHigh == _o.bestHigh &&
		Atf::atfPStringEquals(bestHighHand, _o.bestHighHand) &&
		kicker.equals(_o.kicker) &&
		extraKickerRanks.equals(_o.extraKickerRanks) &&
		boardNum == _o.boardNum;
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cmp=");
	_buf.appendInt(cmp);
	_buf.append(',');
	_buf.append("bestHigh=");
	_buf.appendUint(bestHigh);
	_buf.append(',');
	_buf.append("bestHighHand=");
	_buf.append(bestHighHand);
	_buf.append(',');
	_buf.append("kicker=");
	kicker.toTraceString(_buf);
	_buf.append(',');
	_buf.append("extraKickerRanks=");
	extraKickerRanks.toTraceString(_buf);
	_buf.append(',');
	_buf.append("boardNum=");
	_buf.appendUint(boardNum);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cmp", cmp, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestHigh", bestHigh, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestHighHand", bestHighHand, _buf);
	kicker.toXmlString("kicker", _buf);
	extraKickerRanks.toXmlString("extraKickerRanks", _buf);
	Atf::XmlElement::encodeAsXmlElement("boardNum", boardNum, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cmp"))
		{
			cmp = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bestHigh"))
		{
			bestHigh = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bestHighHand"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, bestHighHand)) return false;
		}
		else if (_element.equals("kicker"))
		{
			if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, kicker)) return false;
		}
		else if (_element.equals("extraKickerRanks"))
		{
			if(!Atf::AtfTempl< Atf::AtfVector0< INT8, 1 > >::FromXmlString(_value, extraKickerRanks)) return false;
		}
		else if (_element.equals("boardNum"))
		{
			boardNum = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(cmp);
	_msg.composeBYTE(bestHigh);
	_msg.composeString(bestHighHand);
	kicker.composeMsg(_msg, _ignoreJSON);
	extraKickerRanks.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(boardNum);
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(cmp);
	_parser.parseBYTE(bestHigh);
	_parser.parseStringP(bestHighHand);
	kicker.parseMsg(_parser);
	extraKickerRanks.parseMsg(_parser);
	_parser.parseBYTE(boardNum);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cmp", cmp);
	_jsonstr.compose("bestHigh", bestHigh);
	_jsonstr.compose("bestHighHand", bestHighHand);
	_jsonstr.compose("kicker", kicker);
	_jsonstr.compose("extraKickerRanks", extraKickerRanks);
	_jsonstr.compose("boardNum", boardNum);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cmp", cmp);
	_jparser.parseByNameThrow("bestHigh", bestHigh);
	_jparser.parseByNameThrow("bestHighHand", bestHighHand);
	_jparser.parseByNameThrow("kicker", kicker);
	_jparser.parseByNameThrow("extraKickerRanks", extraKickerRanks);
	_jparser.parseByNameThrow("boardNum", boardNum);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 cmp; _jparser.validateByNameThrow("cmp", cmp);
	AtfValidator::validateInt(_descr, "cmp", cmp, _checker, __FILE__, __LINE__);
	BYTE bestHigh; _jparser.validateByNameThrow("bestHigh", bestHigh);
	AtfValidator::validateInt(_descr, "bestHigh", bestHigh, _checker, __FILE__, __LINE__);
	PString bestHighHand; _jparser.validateByNameThrow("bestHighHand", bestHighHand);
	AtfValidator::validateInt(_descr, "bestHighHand", bestHighHand.length(), _checker, __FILE__, __LINE__);
	TableCommon::P_Card kicker; _jparser.validateByNameThrow("kicker", kicker);
	Atf::AtfVectorBase< INT8 > extraKickerRanks; _jparser.validateByNameThrow("extraKickerRanks", extraKickerRanks);
	AtfValidator::validateInt(_descr, "extraKickerRanks", extraKickerRanks.size(), _checker, __FILE__, __LINE__);
	BYTE boardNum; _jparser.validateByNameThrow("boardNum", boardNum);
	AtfValidator::validateInt(_descr, "boardNum", boardNum, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_TableHistory_ShownHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT8 cmp; _parser.parseINT8(cmp);
	AtfValidator::validateInt(_descr, "cmp", cmp, _checker, __FILE__, __LINE__);
	BYTE bestHigh; _parser.parseBYTE(bestHigh);
	AtfValidator::validateInt(_descr, "bestHigh", bestHigh, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "bestHighHand"); size_t szBestHighHand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "bestHighHand", szBestHighHand, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableCommon::P_Card::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("kicker"), _fieldsWithUnparsedContent);
	int szExtraKickerRanks = Atf::AtfVector0< INT8, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("extraKickerRanks"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "extraKickerRanks", szExtraKickerRanks, _checker, __FILE__, __LINE__);
	BYTE boardNum; _parser.parseBYTE(boardNum);
	AtfValidator::validateInt(_descr, "boardNum", boardNum, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ClientMsg_TxtEx_TableHistory_TournPrizeWon
//=================================================================

TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::ClientMsg_TxtEx_TableHistory_TournPrizeWon()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::ClientMsg_TxtEx_TableHistory_TournPrizeWon(ClientMsg_TxtEx_TableHistory_TournPrizeWon&& _o)
	: flags(std::move(_o.flags))
	, tournId(std::move(_o.tournId))
	, ticketAdmission(std::move(_o.ticketAdmission))
	, headBounty(std::move(_o.headBounty))
{
}

TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon& TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::operator=(ClientMsg_TxtEx_TableHistory_TournPrizeWon&& _o)
{
	if(this != &_o)
	{
		flags = std::move(_o.flags);
		tournId = std::move(_o.tournId);
		ticketAdmission = std::move(_o.ticketAdmission);
		headBounty = std::move(_o.headBounty);
	}
	return *this;
}

#endif

void TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::clear()
{
	flags = 0;
	tournId = 0;
	ticketAdmission.clear();
	headBounty = 0;
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::equals(const ClientMsg_TxtEx_TableHistory_TournPrizeWon& _o) const
{
	return flags == _o.flags &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(ticketAdmission, _o.ticketAdmission) &&
		headBounty == _o.headBounty;
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("ticketAdmission=");
	_buf.append(ticketAdmission);
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendUint(headBounty);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketAdmission", ticketAdmission, _buf);
	Atf::XmlElement::encodeAsXmlElement("headBounty", headBounty, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("flags"))
		{
			flags = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketAdmission"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketAdmission)) return false;
		}
		else if (_element.equals("headBounty"))
		{
			headBounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(flags);
	_msg.composeUINT32(tournId);
	_msg.composeString(ticketAdmission);
	_msg.composeUINT32(headBounty);
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(flags);
	_parser.parseUINT32(tournId);
	_parser.parseStringP(ticketAdmission);
	_parser.parseUINT32(headBounty);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("ticketAdmission", ticketAdmission);
	_jsonstr.compose("headBounty", headBounty);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("ticketAdmission", ticketAdmission);
	_jparser.parseByNameThrow("headBounty", headBounty);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString ticketAdmission; _jparser.validateByNameThrow("ticketAdmission", ticketAdmission);
	AtfValidator::validateInt(_descr, "ticketAdmission", ticketAdmission.length(), _checker, __FILE__, __LINE__);
	UINT32 headBounty; _jparser.validateByNameThrow("headBounty", headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_TableHistory_TournPrizeWon::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT16 flags; _parser.parseUINT16(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ticketAdmission"); size_t szTicketAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketAdmission", szTicketAdmission, _checker, __FILE__, __LINE__);
	UINT32 headBounty; _parser.parseUINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_MESSAGE
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::Protocol_MSG_TABLE_SUBSCR_MESSAGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::Protocol_MSG_TABLE_SUBSCR_MESSAGE(Protocol_MSG_TABLE_SUBSCR_MESSAGE&& _o)
	: attach(std::move(_o.attach))
	, timerValue(std::move(_o.timerValue))
	, options(std::move(_o.options))
	, cltMsgStrCode(std::move(_o.cltMsgStrCode))
	, clientMsg_txtEx(std::move(_o.clientMsg_txtEx))
	, BrandMask(std::move(_o.BrandMask))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::operator=(Protocol_MSG_TABLE_SUBSCR_MESSAGE&& _o)
{
	if(this != &_o)
	{
		attach = std::move(_o.attach);
		timerValue = std::move(_o.timerValue);
		options = std::move(_o.options);
		cltMsgStrCode = std::move(_o.cltMsgStrCode);
		clientMsg_txtEx = std::move(_o.clientMsg_txtEx);
		BrandMask = std::move(_o.BrandMask);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::clear()
{
	attach.clear();
	timerValue = 0;
	options = 0;
	cltMsgStrCode = 0;
	clientMsg_txtEx.clear();
	BrandMask = BrandType_ALLMask;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::equals(const Protocol_MSG_TABLE_SUBSCR_MESSAGE& _o) const
{
	return Atf::atfPStringEquals(attach, _o.attach) &&
		timerValue == _o.timerValue &&
		options == _o.options &&
		cltMsgStrCode == _o.cltMsgStrCode &&
		clientMsg_txtEx.equals(_o.clientMsg_txtEx) &&
		BrandMask == _o.BrandMask;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_MESSAGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_MESSAGE*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_MESSAGE).append(")");
	_buf.append(',');
	_buf.append("attach=");
	_buf.append(attach);
	_buf.append(',');
	_buf.append("timerValue=");
	_buf.appendUint(timerValue);
	_buf.append(',');
	_buf.append("options=");
	_buf.appendUint(options);
	_buf.append(',');
	_buf.append("cltMsgStrCode=");
	_buf.appendUint(cltMsgStrCode);
	_buf.append(',');
	_buf.append("m=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientMsg_txtEx, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("BrandMask=");
	_buf.appendUint(BrandMask);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_MESSAGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("attach", attach, _buf);
	Atf::XmlElement::encodeAsXmlElement("timerValue", timerValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("options", options, _buf);
	Atf::XmlElement::encodeAsXmlElement("cltMsgStrCode", cltMsgStrCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("m", clientMsg_txtEx, _buf);
	Atf::XmlElement::encodeAsXmlElement("BrandMask", BrandMask, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("attach"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, attach)) return false;
			}
			else if (_element.equals("timerValue"))
			{
				timerValue = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("options"))
			{
				options = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cltMsgStrCode"))
			{
				cltMsgStrCode = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("m") || _element.equals("clientMsg_txtEx"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientMsg_txtEx)) return false;
			}
			else if (_element.equals("BrandMask"))
			{
				BrandMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(attach);
	_msg.composeUINT16(timerValue);
	_msg.composeUINT32(options);
	_msg.composeUINT16(cltMsgStrCode);
	_msg.composeMsgBody(clientMsg_txtEx);
	_msg.composeUINT32(BrandMask);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(attach);
	_parser.parseUINT16(timerValue);
	_parser.parseUINT32(options);
	if(_parser.parseEnded()) return;
	_parser.parseUINT16(cltMsgStrCode);
	_parser.parseMsgBody(clientMsg_txtEx);
	_parser.parseUINT32(BrandMask);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("attach", attach);
	_jsonstr.compose("timerValue", timerValue);
	_jsonstr.compose("options", options);
	_jsonstr.compose("cltMsgStrCode", cltMsgStrCode);
	_jsonstr.compose("m", clientMsg_txtEx);
	_jsonstr.compose("BrandMask", BrandMask);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("attach", attach);
	_jparser.parseByNameThrow("timerValue", timerValue);
	_jparser.parseByNameThrow("options", options);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cltMsgStrCode", cltMsgStrCode);
	if(!_jparser.parseByName("m", clientMsg_txtEx)) _jparser.parseByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	_jparser.parseByNameThrow("BrandMask", BrandMask);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_MESSAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString attach; _jparser.validateByNameThrow("attach", attach);
	AtfValidator::validateInt(_descr, "attach", attach.length(), _checker, __FILE__, __LINE__);
	UINT16 timerValue; _jparser.validateByNameThrow("timerValue", timerValue);
	AtfValidator::validateInt(_descr, "timerValue", timerValue, _checker, __FILE__, __LINE__);
	UINT32 options; _jparser.validateByNameThrow("options", options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT16 cltMsgStrCode; _jparser.validateByNameThrow("cltMsgStrCode", cltMsgStrCode);
	AtfValidator::validateInt(_descr, "cltMsgStrCode", cltMsgStrCode, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientMsg_txtEx; if(!_jparser.validateByName("m", clientMsg_txtEx)) _jparser.validateByNameThrow("clientMsg_txtEx", clientMsg_txtEx);
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", clientMsg_txtEx._size(), _checker, __FILE__, __LINE__);
	UINT32 BrandMask; _jparser.validateByNameThrow("BrandMask", BrandMask);
	AtfValidator::validateInt(_descr, "BrandMask", BrandMask, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_MESSAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "attach"); size_t szAttach = strlen(_dummy);
	AtfValidator::validateInt(_descr, "attach", szAttach, _checker, __FILE__, __LINE__);
	UINT16 timerValue; _parser.parseUINT16(timerValue);
	AtfValidator::validateInt(_descr, "timerValue", timerValue, _checker, __FILE__, __LINE__);
	UINT32 options; _parser.parseUINT32(options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT16 cltMsgStrCode; _parser.parseUINT16(cltMsgStrCode);
	AtfValidator::validateInt(_descr, "cltMsgStrCode", cltMsgStrCode, _checker, __FILE__, __LINE__);
	size_t szClientMsg_txtEx; _parser.skipMsgBody(szClientMsg_txtEx);  /*clientMsg_txtEx*/
	AtfValidator::validateInt(_descr, "clientMsg_txtEx", szClientMsg_txtEx, _checker, __FILE__, __LINE__);
	UINT32 BrandMask; _parser.parseUINT32(BrandMask);
	AtfValidator::validateInt(_descr, "BrandMask", BrandMask, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_MESSAGE2
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::Protocol_MSG_TABLE_SUBSCR_MESSAGE2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::Protocol_MSG_TABLE_SUBSCR_MESSAGE2(Protocol_MSG_TABLE_SUBSCR_MESSAGE2&& _o)
	: attach(std::move(_o.attach))
	, timerValue(std::move(_o.timerValue))
	, flags(std::move(_o.flags))
	, siteObsolete(std::move(_o.siteObsolete))
	, BrandMask(std::move(_o.BrandMask))
	, siteMask(std::move(_o.siteMask))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::operator=(Protocol_MSG_TABLE_SUBSCR_MESSAGE2&& _o)
{
	if(this != &_o)
	{
		attach = std::move(_o.attach);
		timerValue = std::move(_o.timerValue);
		flags = std::move(_o.flags);
		siteObsolete = std::move(_o.siteObsolete);
		BrandMask = std::move(_o.BrandMask);
		siteMask = std::move(_o.siteMask);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::clear()
{
	attach.clear();
	timerValue = 0;
	flags = 0;
	siteObsolete = 0;
	BrandMask = BrandType_ALLMask;
	siteMask.clear();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::equals(const Protocol_MSG_TABLE_SUBSCR_MESSAGE2& _o) const
{
	return Atf::atfPStringEquals(attach, _o.attach) &&
		timerValue == _o.timerValue &&
		flags == _o.flags &&
		siteObsolete == _o.siteObsolete &&
		BrandMask == _o.BrandMask &&
		siteMask.equals(_o.siteMask);
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_MESSAGE2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_MESSAGE2*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_MESSAGE2).append(")");
	_buf.append(',');
	_buf.append("attach=");
	_buf.append(attach);
	_buf.append(',');
	_buf.append("timerValue=");
	_buf.appendUint(timerValue);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("siteObsolete=");
	_buf.appendUint(siteObsolete);
	_buf.append(',');
	_buf.append("BrandMask=");
	_buf.appendUint(BrandMask);
	_buf.append(',');
	_buf.append("siteMask=");
	siteMask.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_MESSAGE2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("attach", attach, _buf);
	Atf::XmlElement::encodeAsXmlElement("timerValue", timerValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteObsolete", siteObsolete, _buf);
	Atf::XmlElement::encodeAsXmlElement("BrandMask", BrandMask, _buf);
	siteMask.toXmlString("siteMask", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("attach"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, attach)) return false;
			}
			else if (_element.equals("timerValue"))
			{
				timerValue = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("siteObsolete"))
			{
				siteObsolete = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("BrandMask"))
			{
				BrandMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("siteMask"))
			{
				if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, siteMask)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(attach);
	_msg.composeUINT16(timerValue);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(siteObsolete);
	_msg.composeUINT32(BrandMask);
	siteMask.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(attach);
	_parser.parseUINT16(timerValue);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(siteObsolete);
	_parser.parseUINT32(BrandMask);
	if(_parser.parseEnded()) return;
	siteMask.parseMsg(_parser);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("attach", attach);
	_jsonstr.compose("timerValue", timerValue);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("siteObsolete", siteObsolete);
	_jsonstr.compose("BrandMask", BrandMask);
	_jsonstr.compose("siteMask", siteMask);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("attach", attach);
	_jparser.parseByNameThrow("timerValue", timerValue);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("siteObsolete", siteObsolete);
	_jparser.parseByNameThrow("BrandMask", BrandMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("siteMask", siteMask);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_MESSAGE2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString attach; _jparser.validateByNameThrow("attach", attach);
	AtfValidator::validateInt(_descr, "attach", attach.length(), _checker, __FILE__, __LINE__);
	UINT16 timerValue; _jparser.validateByNameThrow("timerValue", timerValue);
	AtfValidator::validateInt(_descr, "timerValue", timerValue, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 siteObsolete; _jparser.validateByNameThrow("siteObsolete", siteObsolete);
	AtfValidator::validateInt(_descr, "siteObsolete", siteObsolete, _checker, __FILE__, __LINE__);
	UINT32 BrandMask; _jparser.validateByNameThrow("BrandMask", BrandMask);
	AtfValidator::validateInt(_descr, "BrandMask", BrandMask, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask siteMask; _jparser.validateByNameThrow("siteMask", siteMask);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_MESSAGE2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "attach"); size_t szAttach = strlen(_dummy);
	AtfValidator::validateInt(_descr, "attach", szAttach, _checker, __FILE__, __LINE__);
	UINT16 timerValue; _parser.parseUINT16(timerValue);
	AtfValidator::validateInt(_descr, "timerValue", timerValue, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 siteObsolete; _parser.parseUINT32(siteObsolete);
	AtfValidator::validateInt(_descr, "siteObsolete", siteObsolete, _checker, __FILE__, __LINE__);
	UINT32 BrandMask; _parser.parseUINT32(BrandMask);
	AtfValidator::validateInt(_descr, "BrandMask", BrandMask, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteMask"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT(): pots("FFFF") 
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT(Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT&& _o)
	: potNum(std::move(_o.potNum))
	, pots(std::move(_o.pots))
	, potCategoryId(std::move(_o.potCategoryId))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::operator=(Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT&& _o)
{
	if(this != &_o)
	{
		potNum = std::move(_o.potNum);
		pots = std::move(_o.pots);
		potCategoryId = std::move(_o.potCategoryId);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::clear()
{
	potNum = 0;
	pots.clear();
	potCategoryId = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::equals(const Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT& _o) const
{
	return potNum == _o.potNum &&
		pots.equals(_o.pots) &&
		potCategoryId == _o.potCategoryId;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_MOVEFROMPOT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_MOVEFROMPOT).append(")");
	_buf.append(',');
	_buf.append("potNum=");
	_buf.appendUint(potNum);
	_buf.append(',');
	_buf.append("pots=");
	pots.toTraceString(_buf);
	_buf.append(',');
	_buf.append("potCategoryId=");
	_buf.appendUint(potCategoryId);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_MOVEFROMPOT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("potNum", potNum, _buf);
	pots.toXmlString("pots", _buf);
	Atf::XmlElement::encodeAsXmlElement("potCategoryId", potCategoryId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("potNum"))
			{
				potNum = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pots"))
			{
				if(!Atf::AtfTempl< Atf::AtfVectorWithSpecialTerminator< P_PotInfo > >::FromXmlString(_value, pots)) return false;
			}
			else if (_element.equals("potCategoryId"))
			{
				potCategoryId = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(potNum);
	pots.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(potCategoryId);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(potNum);
	pots.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(potCategoryId);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("potNum", potNum);
	_jsonstr.compose("pots", pots);
	_jsonstr.compose("potCategoryId", potCategoryId);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("potNum", potNum);
	_jparser.parseByNameThrow("pots", pots);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("potCategoryId", potCategoryId);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_MOVEFROMPOT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE potNum; _jparser.validateByNameThrow("potNum", potNum);
	AtfValidator::validateInt(_descr, "potNum", potNum, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_PotInfo > pots; _jparser.validateByNameThrow("pots", pots);
	AtfValidator::validateInt(_descr, "pots", pots.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE potCategoryId; _jparser.validateByNameThrow("potCategoryId", potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_MOVEFROMPOT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE potNum; _parser.parseBYTE(potNum);
	AtfValidator::validateInt(_descr, "potNum", potNum, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPots = Atf::AtfVectorWithSpecialTerminator< P_PotInfo >::validateMsg(_parser, "FFFF", _checker, _descbuf.assign(_descr).append('.').append("pots"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "pots", szPots, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE potCategoryId; _parser.parseBYTE(potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_MOVETOPOT
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT(): pots("FFFF") 
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT(Protocol_MSG_TABLE_SUBSCR_MOVETOPOT&& _o)
	: potNum(std::move(_o.potNum))
	, pots(std::move(_o.pots))
	, potCategoryId(std::move(_o.potCategoryId))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::operator=(Protocol_MSG_TABLE_SUBSCR_MOVETOPOT&& _o)
{
	if(this != &_o)
	{
		potNum = std::move(_o.potNum);
		pots = std::move(_o.pots);
		potCategoryId = std::move(_o.potCategoryId);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::clear()
{
	potNum = 0;
	pots.clear();
	potCategoryId = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::equals(const Protocol_MSG_TABLE_SUBSCR_MOVETOPOT& _o) const
{
	return potNum == _o.potNum &&
		pots.equals(_o.pots) &&
		potCategoryId == _o.potCategoryId;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_MOVETOPOT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_MOVETOPOT*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_MOVETOPOT).append(")");
	_buf.append(',');
	_buf.append("potNum=");
	_buf.appendUint(potNum);
	_buf.append(',');
	_buf.append("pots=");
	pots.toTraceString(_buf);
	_buf.append(',');
	_buf.append("potCategoryId=");
	_buf.appendUint(potCategoryId);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_MOVETOPOT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("potNum", potNum, _buf);
	pots.toXmlString("pots", _buf);
	Atf::XmlElement::encodeAsXmlElement("potCategoryId", potCategoryId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("potNum"))
			{
				potNum = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pots"))
			{
				if(!Atf::AtfTempl< Atf::AtfVectorWithSpecialTerminator< P_PotInfo > >::FromXmlString(_value, pots)) return false;
			}
			else if (_element.equals("potCategoryId"))
			{
				potCategoryId = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(potNum);
	pots.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(potCategoryId);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(potNum);
	pots.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(potCategoryId);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("potNum", potNum);
	_jsonstr.compose("pots", pots);
	_jsonstr.compose("potCategoryId", potCategoryId);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("potNum", potNum);
	_jparser.parseByNameThrow("pots", pots);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("potCategoryId", potCategoryId);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_MOVETOPOT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE potNum; _jparser.validateByNameThrow("potNum", potNum);
	AtfValidator::validateInt(_descr, "potNum", potNum, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_PotInfo > pots; _jparser.validateByNameThrow("pots", pots);
	AtfValidator::validateInt(_descr, "pots", pots.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE potCategoryId; _jparser.validateByNameThrow("potCategoryId", potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_MOVETOPOT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE potNum; _parser.parseBYTE(potNum);
	AtfValidator::validateInt(_descr, "potNum", potNum, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPots = Atf::AtfVectorWithSpecialTerminator< P_PotInfo >::validateMsg(_parser, "FFFF", _checker, _descbuf.assign(_descr).append('.').append("pots"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "pots", szPots, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE potCategoryId; _parser.parseBYTE(potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_NEWGAME
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::Protocol_MSG_TABLE_SUBSCR_NEWGAME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::Protocol_MSG_TABLE_SUBSCR_NEWGAME(Protocol_MSG_TABLE_SUBSCR_NEWGAME&& _o)
	: stakeSmall(std::move(_o.stakeSmall))
	, stakeBig(std::move(_o.stakeBig))
	, ante(std::move(_o.ante))
	, handType(std::move(_o.handType))
	, isHiLo(std::move(_o.isHiLo))
	, potStruct(std::move(_o.potStruct))
	, tableStakes(std::move(_o.tableStakes))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::operator=(Protocol_MSG_TABLE_SUBSCR_NEWGAME&& _o)
{
	if(this != &_o)
	{
		stakeSmall = std::move(_o.stakeSmall);
		stakeBig = std::move(_o.stakeBig);
		ante = std::move(_o.ante);
		handType = std::move(_o.handType);
		isHiLo = std::move(_o.isHiLo);
		potStruct = std::move(_o.potStruct);
		tableStakes = std::move(_o.tableStakes);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::clear()
{
	stakeSmall = 0;
	stakeBig = 0;
	ante = 0;
	handType = 0;
	isHiLo = 0;
	potStruct = 0;
	tableStakes.clear();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::equals(const Protocol_MSG_TABLE_SUBSCR_NEWGAME& _o) const
{
	return stakeSmall == _o.stakeSmall &&
		stakeBig == _o.stakeBig &&
		ante == _o.ante &&
		handType == _o.handType &&
		isHiLo == _o.isHiLo &&
		potStruct == _o.potStruct &&
		tableStakes.equals(_o.tableStakes);
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_NEWGAME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_NEWGAME*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_NEWGAME).append(")");
	_buf.append(',');
	_buf.append("stakeSmall=");
	_buf.appendInt(stakeSmall);
	_buf.append(',');
	_buf.append("stakeBig=");
	_buf.appendInt(stakeBig);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendInt(ante);
	_buf.append(',');
	_buf.append("gm=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("lm=");
	_buf.appendUint(potStruct);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_NEWGAME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("stakeSmall", stakeSmall, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeBig", stakeBig, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("gm", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("lm", potStruct, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("stakeSmall"))
			{
				stakeSmall = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("stakeBig"))
			{
				stakeBig = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ante"))
			{
				ante = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gm") || _element.equals("handType"))
			{
				handType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHiLo"))
			{
				isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("lm") || _element.equals("potStruct"))
			{
				potStruct = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableStakes"))
			{
				if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(stakeSmall);
	_msg.composeINT32(stakeBig);
	_msg.composeINT32(ante);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(potStruct);
	tableStakes.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(stakeSmall);
	_parser.parseINT32(stakeBig);
	_parser.parseINT32(ante);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(potStruct);
	if(_parser.parseEnded()) return;
	tableStakes.parseMsg(_parser);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("stakeSmall", stakeSmall);
	_jsonstr.compose("stakeBig", stakeBig);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("gm", handType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("lm", potStruct);
	_jsonstr.compose("tableStakes", tableStakes);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stakeSmall", stakeSmall);
	_jparser.parseByNameThrow("stakeBig", stakeBig);
	_jparser.parseByNameThrow("ante", ante);
	if(!_jparser.parseByName("gm", handType)) _jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	if(!_jparser.parseByName("lm", potStruct)) _jparser.parseByNameThrow("potStruct", potStruct);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakes", tableStakes);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_NEWGAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 stakeSmall; _jparser.validateByNameThrow("stakeSmall", stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	INT32 stakeBig; _jparser.validateByNameThrow("stakeBig", stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	INT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE handType; if(!_jparser.validateByName("gm", handType)) _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE potStruct; if(!_jparser.validateByName("lm", potStruct)) _jparser.validateByNameThrow("potStruct", potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_NEWGAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 stakeSmall; _parser.parseINT32(stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	INT32 stakeBig; _parser.parseINT32(stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	INT32 ante; _parser.parseINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::clear()
{
	pause = false;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::equals(const Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE& _o) const
{
	return pause == _o.pause;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE).append(")");
	_buf.append(',');
	_buf.append("pause=");
	_buf.appendUint(pause);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pause", pause, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pause"))
			{
				pause = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(pause);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(pause);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pause", pause);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pause", pause);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool pause; _jparser.validateByNameThrow("pause", pause);
	AtfValidator::validateInt(_descr, "pause", pause, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool pause; _parser.parseBOOL(pause);
	AtfValidator::validateInt(_descr, "pause", pause, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::clear()
{
	start = 0;
	delayedSec = 0;
	forceClose = false;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::equals(const Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE& _o) const
{
	return start == _o.start &&
		delayedSec == _o.delayedSec &&
		forceClose == _o.forceClose;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE).append(")");
	_buf.append(',');
	_buf.append("start=");
	_buf.appendUint(start);
	_buf.append(',');
	_buf.append("delayedSec=");
	_buf.appendUint(delayedSec);
	_buf.append(',');
	_buf.append("forceClose=");
	_buf.appendUint(forceClose);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("start", start, _buf);
	Atf::XmlElement::encodeAsXmlElement("delayedSec", delayedSec, _buf);
	Atf::XmlElement::encodeAsXmlElement("forceClose", forceClose, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("start"))
			{
				start = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("delayedSec"))
			{
				delayedSec = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("forceClose"))
			{
				forceClose = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(start);
	_msg.composeUINT32(delayedSec);
	_msg.composeBOOL(forceClose);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(start);
	_parser.parseUINT32(delayedSec);
	_parser.parseBOOL(forceClose);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("start", start);
	_jsonstr.compose("delayedSec", delayedSec);
	_jsonstr.compose("forceClose", forceClose);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("start", start);
	_jparser.parseByNameThrow("delayedSec", delayedSec);
	_jparser.parseByNameThrow("forceClose", forceClose);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE start; _jparser.validateByNameThrow("start", start);
	AtfValidator::validateInt(_descr, "start", start, _checker, __FILE__, __LINE__);
	UINT32 delayedSec; _jparser.validateByNameThrow("delayedSec", delayedSec);
	AtfValidator::validateInt(_descr, "delayedSec", delayedSec, _checker, __FILE__, __LINE__);
	bool forceClose; _jparser.validateByNameThrow("forceClose", forceClose);
	AtfValidator::validateInt(_descr, "forceClose", forceClose, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE start; _parser.parseBYTE(start);
	AtfValidator::validateInt(_descr, "start", start, _checker, __FILE__, __LINE__);
	UINT32 delayedSec; _parser.parseUINT32(delayedSec);
	AtfValidator::validateInt(_descr, "delayedSec", delayedSec, _checker, __FILE__, __LINE__);
	bool forceClose; _parser.parseBOOL(forceClose);
	AtfValidator::validateInt(_descr, "forceClose", forceClose, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::clear()
{
	playersUnfolded = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::equals(const Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS& _o) const
{
	return playersUnfolded == _o.playersUnfolded;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS).append(")");
	_buf.append(',');
	_buf.append("playersUnfolded=");
	_buf.appendUint(playersUnfolded);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("playersUnfolded", playersUnfolded, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("playersUnfolded"))
			{
				playersUnfolded = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(playersUnfolded);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(playersUnfolded);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playersUnfolded", playersUnfolded);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playersUnfolded", playersUnfolded);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 playersUnfolded; _jparser.validateByNameThrow("playersUnfolded", playersUnfolded);
	AtfValidator::validateInt(_descr, "playersUnfolded", playersUnfolded, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT16 playersUnfolded; _parser.parseUINT16(playersUnfolded);
	AtfValidator::validateInt(_descr, "playersUnfolded", playersUnfolded, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::clear()
{
	potCategoryId = 0;
	winners = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::equals(const Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS& _o) const
{
	return potCategoryId == _o.potCategoryId &&
		winners == _o.winners;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_SHOW_POT_WINNERS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_SHOW_POT_WINNERS).append(")");
	_buf.append(',');
	_buf.append("potCategoryId=");
	_buf.appendUint(potCategoryId);
	_buf.append(',');
	_buf.append("winners=");
	_buf.appendUint(winners);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_SHOW_POT_WINNERS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("potCategoryId", potCategoryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("winners", winners, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("potCategoryId"))
			{
				potCategoryId = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("winners"))
			{
				winners = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(potCategoryId);
	_msg.composeUINT16(winners);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(potCategoryId);
	_parser.parseUINT16(winners);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("potCategoryId", potCategoryId);
	_jsonstr.compose("winners", winners);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("potCategoryId", potCategoryId);
	_jparser.parseByNameThrow("winners", winners);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_SHOW_POT_WINNERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE potCategoryId; _jparser.validateByNameThrow("potCategoryId", potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
	UINT16 winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_SHOW_POT_WINNERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE potCategoryId; _parser.parseBYTE(potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
	UINT16 winners; _parser.parseUINT16(winners);
	AtfValidator::validateInt(_descr, "winners", winners, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::clear()
{
	potCategoryId = 0;
	seat = 0xFF;
	amount = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::equals(const Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET& _o) const
{
	return potCategoryId == _o.potCategoryId &&
		seat == _o.seat &&
		amount == _o.amount;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET).append(")");
	_buf.append(',');
	_buf.append("pcid=");
	_buf.appendUint(potCategoryId);
	_buf.append(',');
	_buf.append("s=");
	_buf.appendUint(seat);
	_buf.append(',');
	_buf.append("v=");
	_buf.appendUint(amount);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pcid", potCategoryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("v", amount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pcid") || _element.equals("potCategoryId"))
			{
				potCategoryId = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("v") || _element.equals("amount"))
			{
				amount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(potCategoryId);
	_msg.composeBYTE(seat);
	_msg.composeUINT32(amount);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(potCategoryId);
	_parser.parseBYTE(seat);
	_parser.parseUINT32(amount);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pcid", potCategoryId);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("v", amount);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pcid", potCategoryId)) _jparser.parseByNameThrow("potCategoryId", potCategoryId);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	if(!_jparser.parseByName("v", amount)) _jparser.parseByNameThrow("amount", amount);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE potCategoryId; if(!_jparser.validateByName("pcid", potCategoryId)) _jparser.validateByNameThrow("potCategoryId", potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
	BYTE seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	UINT32 amount; if(!_jparser.validateByName("v", amount)) _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE potCategoryId; _parser.parseBYTE(potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
	BYTE seat; _parser.parseBYTE(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_POWER_PLAY
//=================================================================

//=================================================================
//                _BaseAttrType
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::_BaseAttrType()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::clear()
{
	seat = -1;
	_is_empty_internal = true;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::equals(const _BaseAttrType& _o) const
{
	return seat == _o.seat;
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("s=");
		_buf.appendInt(seat);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("s") || _element.equals("seat"))
		{
			seat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT8(seat);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT8(seat);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("s", seat);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
}

/* static */ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::_BaseAttrType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT8 seat; _parser0.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY(Protocol_MSG_TABLE_SUBSCR_POWER_PLAY&& _o)
	: powerId(std::move(_o.powerId))
	, baseAttr(std::move(_o.baseAttr))
	, powerAttr(std::move(_o.powerAttr))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::operator=(Protocol_MSG_TABLE_SUBSCR_POWER_PLAY&& _o)
{
	if(this != &_o)
	{
		powerId = std::move(_o.powerId);
		baseAttr = std::move(_o.baseAttr);
		powerAttr = std::move(_o.powerAttr);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::clear()
{
	powerId = 0;
	baseAttr.clear();
	powerAttr.clear();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::equals(const Protocol_MSG_TABLE_SUBSCR_POWER_PLAY& _o) const
{
	return powerId == _o.powerId &&
		baseAttr.equals(_o.baseAttr) &&
		powerAttr.equals(_o.powerAttr);
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_POWER_PLAY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_POWER_PLAY*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_POWER_PLAY).append(")");
	_buf.append(',');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("baseAttr=");
	baseAttr.toTraceString(_buf);
	_buf.append(',');
	_buf.append("powerAttr=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(powerAttr, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_POWER_PLAY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	baseAttr.toXmlString("baseAttr", _buf);
	Atf::XmlElement::encodeAsXmlElement("powerAttr", powerAttr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pI") || _element.equals("powerId"))
			{
				powerId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("baseAttr"))
			{
				if(!Atf::AtfTempl< _BaseAttrType >::FromXmlString(_value, baseAttr)) return false;
			}
			else if (_element.equals("powerAttr"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, powerAttr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(powerId);
	baseAttr.composeMsg(_msg, _ignoreJSON);
	_msg.composeMsgBody(powerAttr);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(powerId);
	baseAttr.parseMsg(_parser);
	_parser.parseMsgBody(powerAttr);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("baseAttr", baseAttr);
	_jsonstr.compose("powerAttr", powerAttr);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("baseAttr", baseAttr);
	_jparser.parseByNameThrow("powerAttr", powerAttr);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_POWER_PLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	_BaseAttrType baseAttr; _jparser.validateByNameThrow("baseAttr", baseAttr);
	Atf::CopyableMsgBody powerAttr; _jparser.validateByNameThrow("powerAttr", powerAttr);
	AtfValidator::validateInt(_descr, "powerAttr", powerAttr._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_POWER_PLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 powerId; _parser.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	_BaseAttrType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("baseAttr"), _fieldsWithUnparsedContent);
	size_t szPowerAttr; _parser.skipMsgBody(szPowerAttr);  /*powerAttr*/
	AtfValidator::validateInt(_descr, "powerAttr", szPowerAttr, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    XRayCard
//=================================================================

TableClient::publication::XRayCard::XRayCard()
{
	clear();
}

void TableClient::publication::XRayCard::clear()
{
	player = 0;
	cardIndex = 0;
	suit = '0';
	rank = 0;
}

bool TableClient::publication::XRayCard::equals(const XRayCard& _o) const
{
	return player == _o.player &&
		cardIndex == _o.cardIndex &&
		suit == _o.suit &&
		rank == _o.rank;
}

const char *TableClient::publication::XRayCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("player=");
	_buf.appendUint(player);
	_buf.append(',');
	_buf.append("cardIndex=");
	_buf.appendUint(cardIndex);
	_buf.append(',');
	_buf.append("suit=");
	_buf.append(suit);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::XRayCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("player", player, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardIndex", cardIndex, _buf);
	Atf::XmlElement::encodeAsXmlElement("suit", suit, _buf);
	Atf::XmlElement::encodeAsXmlElement("rank", rank, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::XRayCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("player"))
		{
			player = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardIndex"))
		{
			cardIndex = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("suit"))
		{
			suit = *_value.ptr();
		}
		else if (_element.equals("rank"))
		{
			rank = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::XRayCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(player);
	_msg.composeBYTE(cardIndex);
	_msg.composeINT8(suit);
	_msg.composeBYTE(rank);
}

void TableClient::publication::XRayCard::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(player);
	_parser.parseBYTE(cardIndex);
	{ INT8 _n; _parser.parseINT8(_n); suit = _n; }
	_parser.parseBYTE(rank);
}

const char *TableClient::publication::XRayCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("player", player);
	_jsonstr.compose("cardIndex", cardIndex);
	_jsonstr.compose("suit", suit);
	_jsonstr.compose("rank", rank);
	return _buf.c_str();
}

void TableClient::publication::XRayCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("player", player);
	_jparser.parseByNameThrow("cardIndex", cardIndex);
	_jparser.parseByNameThrow("suit", suit);
	_jparser.parseByNameThrow("rank", rank);
}

/* static */ void TableClient::publication::XRayCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE player; _jparser.validateByNameThrow("player", player);
	AtfValidator::validateInt(_descr, "player", player, _checker, __FILE__, __LINE__);
	BYTE cardIndex; _jparser.validateByNameThrow("cardIndex", cardIndex);
	AtfValidator::validateInt(_descr, "cardIndex", cardIndex, _checker, __FILE__, __LINE__);
	char suit; _jparser.validateByNameThrow("suit", suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _jparser.validateByNameThrow("rank", rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::XRayCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE player; _parser.parseBYTE(player);
	AtfValidator::validateInt(_descr, "player", player, _checker, __FILE__, __LINE__);
	BYTE cardIndex; _parser.parseBYTE(cardIndex);
	AtfValidator::validateInt(_descr, "cardIndex", cardIndex, _checker, __FILE__, __LINE__);
	char suit; { INT8 _n; _parser.parseINT8(_n); suit = _n; }
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _parser.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    XRayAnimation
//=================================================================

TableClient::publication::XRayAnimation::XRayAnimation()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::XRayAnimation::XRayAnimation(XRayAnimation&& _o)
	: cards(std::move(_o.cards))
{
}

TableClient::publication::XRayAnimation& TableClient::publication::XRayAnimation::operator=(XRayAnimation&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
	}
	return *this;
}

#endif

void TableClient::publication::XRayAnimation::clear()
{
	cards.clear();
}

bool TableClient::publication::XRayAnimation::equals(const XRayAnimation& _o) const
{
	return cards.equals(_o.cards);
}

const char *TableClient::publication::XRayAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::XRayAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	cards.toXmlString("cards", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::XRayAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< XRayCard, 4 > >::FromXmlString(_value, cards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::XRayAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	cards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::XRayAnimation::parseMsg(CommMsgParser& _parser)
{
	cards.parseMsg(_parser);
}

const char *TableClient::publication::XRayAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cards", cards);
	return _buf.c_str();
}

void TableClient::publication::XRayAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cards", cards);
}

/* static */ void TableClient::publication::XRayAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< XRayCard > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::XRayAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szCards = Atf::LAtfVector< XRayCard, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    DisintgrateAnimation
//=================================================================

TableClient::publication::DisintgrateAnimation::DisintgrateAnimation()
{
	clear();
}

void TableClient::publication::DisintgrateAnimation::clear()
{
	c.clear();
}

bool TableClient::publication::DisintgrateAnimation::equals(const DisintgrateAnimation& _o) const
{
	return c.equals(_o.c);
}

const char *TableClient::publication::DisintgrateAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("c=");
	c.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::DisintgrateAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	c.toXmlString("c", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::DisintgrateAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("c"))
		{
			if(!Atf::AtfTempl< PubBoardCardPosition >::FromXmlString(_value, c)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::DisintgrateAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	c.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::DisintgrateAnimation::parseMsg(CommMsgParser& _parser)
{
	c.parseMsg(_parser);
}

const char *TableClient::publication::DisintgrateAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("c", c);
	return _buf.c_str();
}

void TableClient::publication::DisintgrateAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("c", c);
}

/* static */ void TableClient::publication::DisintgrateAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PubBoardCardPosition c; _jparser.validateByNameThrow("c", c);
}

/*static*/ void TableClient::publication::DisintgrateAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	PubBoardCardPosition::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("c"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    ScannerAnimation
//=================================================================

TableClient::publication::ScannerAnimation::ScannerAnimation()
{
	clear();
}

void TableClient::publication::ScannerAnimation::clear()
{
	startOrEnd = false;
	numCards = 0;
	discarded = false;
}

bool TableClient::publication::ScannerAnimation::equals(const ScannerAnimation& _o) const
{
	return startOrEnd == _o.startOrEnd &&
		numCards == _o.numCards &&
		discarded == _o.discarded;
}

const char *TableClient::publication::ScannerAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startOrEnd=");
	_buf.appendUint(startOrEnd);
	_buf.append(',');
	_buf.append("numCards=");
	_buf.appendUint(numCards);
	_buf.append(',');
	_buf.append("discarded=");
	_buf.appendUint(discarded);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ScannerAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("startOrEnd", startOrEnd, _buf);
	Atf::XmlElement::encodeAsXmlElement("numCards", numCards, _buf);
	Atf::XmlElement::encodeAsXmlElement("discarded", discarded, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ScannerAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("startOrEnd"))
		{
			startOrEnd = (*_value.ptr() == '1');
		}
		else if (_element.equals("numCards"))
		{
			numCards = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("discarded"))
		{
			discarded = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ScannerAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(startOrEnd);
	_msg.composeBYTE(numCards);
	_msg.composeBOOL(discarded);
}

void TableClient::publication::ScannerAnimation::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(startOrEnd);
	_parser.parseBYTE(numCards);
	_parser.parseBOOL(discarded);
}

const char *TableClient::publication::ScannerAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("startOrEnd", startOrEnd);
	_jsonstr.compose("numCards", numCards);
	_jsonstr.compose("discarded", discarded);
	return _buf.c_str();
}

void TableClient::publication::ScannerAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("startOrEnd", startOrEnd);
	_jparser.parseByNameThrow("numCards", numCards);
	_jparser.parseByNameThrow("discarded", discarded);
}

/* static */ void TableClient::publication::ScannerAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool startOrEnd; _jparser.validateByNameThrow("startOrEnd", startOrEnd);
	AtfValidator::validateInt(_descr, "startOrEnd", startOrEnd, _checker, __FILE__, __LINE__);
	BYTE numCards; _jparser.validateByNameThrow("numCards", numCards);
	AtfValidator::validateInt(_descr, "numCards", numCards, _checker, __FILE__, __LINE__);
	bool discarded; _jparser.validateByNameThrow("discarded", discarded);
	AtfValidator::validateInt(_descr, "discarded", discarded, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ScannerAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool startOrEnd; _parser.parseBOOL(startOrEnd);
	AtfValidator::validateInt(_descr, "startOrEnd", startOrEnd, _checker, __FILE__, __LINE__);
	BYTE numCards; _parser.parseBYTE(numCards);
	AtfValidator::validateInt(_descr, "numCards", numCards, _checker, __FILE__, __LINE__);
	bool discarded; _parser.parseBOOL(discarded);
	AtfValidator::validateInt(_descr, "discarded", discarded, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    EngineerAnimation
//=================================================================

TableClient::publication::EngineerAnimation::EngineerAnimation()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::EngineerAnimation::EngineerAnimation(EngineerAnimation&& _o)
	: startOrEnd(std::move(_o.startOrEnd))
	, cards(std::move(_o.cards))
	, chosenCard(std::move(_o.chosenCard))
{
}

TableClient::publication::EngineerAnimation& TableClient::publication::EngineerAnimation::operator=(EngineerAnimation&& _o)
{
	if(this != &_o)
	{
		startOrEnd = std::move(_o.startOrEnd);
		cards = std::move(_o.cards);
		chosenCard = std::move(_o.chosenCard);
	}
	return *this;
}

#endif

void TableClient::publication::EngineerAnimation::clear()
{
	startOrEnd = false;
	cards.clear();
	chosenCard.clear();
}

bool TableClient::publication::EngineerAnimation::equals(const EngineerAnimation& _o) const
{
	return startOrEnd == _o.startOrEnd &&
		cards.equals(_o.cards) &&
		chosenCard.equals(_o.chosenCard);
}

const char *TableClient::publication::EngineerAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startOrEnd=");
	_buf.appendUint(startOrEnd);
	_buf.append(',');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("chosenCard=");
	chosenCard.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::EngineerAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("startOrEnd", startOrEnd, _buf);
	cards.toXmlString("cards", _buf);
	chosenCard.toXmlString("chosenCard", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::EngineerAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("startOrEnd"))
		{
			startOrEnd = (*_value.ptr() == '1');
		}
		else if (_element.equals("cards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, cards)) return false;
		}
		else if (_element.equals("chosenCard"))
		{
			if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, chosenCard)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::EngineerAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(startOrEnd);
	cards.composeMsg(_msg, _ignoreJSON);
	chosenCard.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::EngineerAnimation::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(startOrEnd);
	cards.parseMsg(_parser);
	chosenCard.parseMsg(_parser);
}

const char *TableClient::publication::EngineerAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("startOrEnd", startOrEnd);
	_jsonstr.compose("cards", cards);
	_jsonstr.compose("chosenCard", chosenCard);
	return _buf.c_str();
}

void TableClient::publication::EngineerAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("startOrEnd", startOrEnd);
	_jparser.parseByNameThrow("cards", cards);
	_jparser.parseByNameThrow("chosenCard", chosenCard);
}

/* static */ void TableClient::publication::EngineerAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool startOrEnd; _jparser.validateByNameThrow("startOrEnd", startOrEnd);
	AtfValidator::validateInt(_descr, "startOrEnd", startOrEnd, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
	TableCommon::P_Card chosenCard; _jparser.validateByNameThrow("chosenCard", chosenCard);
}

/*static*/ void TableClient::publication::EngineerAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool startOrEnd; _parser.parseBOOL(startOrEnd);
	AtfValidator::validateInt(_descr, "startOrEnd", startOrEnd, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCards = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	TableCommon::P_Card::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("chosenCard"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    CloneAnimation
//=================================================================

TableClient::publication::CloneAnimation::CloneAnimation()
{
	clear();
}

void TableClient::publication::CloneAnimation::clear()
{
	toSlotIndex = 0;
	powerIdCopied = 0;
	newPowerState = 0;
	newPowerCost = 0;
}

bool TableClient::publication::CloneAnimation::equals(const CloneAnimation& _o) const
{
	return toSlotIndex == _o.toSlotIndex &&
		powerIdCopied == _o.powerIdCopied &&
		newPowerState == _o.newPowerState &&
		newPowerCost == _o.newPowerCost;
}

const char *TableClient::publication::CloneAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("toSlotIndex=");
	_buf.appendUint(toSlotIndex);
	_buf.append(',');
	_buf.append("powerIdCopied=");
	_buf.appendInt(powerIdCopied);
	_buf.append(',');
	_buf.append("newPowerState=");
	_buf.appendUint(newPowerState);
	_buf.append(',');
	_buf.append("newPowerCost=");
	_buf.appendInt(newPowerCost);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::CloneAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("toSlotIndex", toSlotIndex, _buf);
	Atf::XmlElement::encodeAsXmlElement("powerIdCopied", powerIdCopied, _buf);
	Atf::XmlElement::encodeAsXmlElement("newPowerState", newPowerState, _buf);
	Atf::XmlElement::encodeAsXmlElement("newPowerCost", newPowerCost, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::CloneAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("toSlotIndex"))
		{
			toSlotIndex = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powerIdCopied"))
		{
			powerIdCopied = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("newPowerState"))
		{
			newPowerState = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("newPowerCost"))
		{
			newPowerCost = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::CloneAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(toSlotIndex);
	_msg.composeINT32(powerIdCopied);
	_msg.composeUINT32(newPowerState);
	_msg.composeINT32(newPowerCost);
}

void TableClient::publication::CloneAnimation::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(toSlotIndex);
	_parser.parseINT32(powerIdCopied);
	_parser.parseUINT32(newPowerState);
	_parser.parseINT32(newPowerCost);
}

const char *TableClient::publication::CloneAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("toSlotIndex", toSlotIndex);
	_jsonstr.compose("powerIdCopied", powerIdCopied);
	_jsonstr.compose("newPowerState", newPowerState);
	_jsonstr.compose("newPowerCost", newPowerCost);
	return _buf.c_str();
}

void TableClient::publication::CloneAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("toSlotIndex", toSlotIndex);
	_jparser.parseByNameThrow("powerIdCopied", powerIdCopied);
	_jparser.parseByNameThrow("newPowerState", newPowerState);
	_jparser.parseByNameThrow("newPowerCost", newPowerCost);
}

/* static */ void TableClient::publication::CloneAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE toSlotIndex; _jparser.validateByNameThrow("toSlotIndex", toSlotIndex);
	AtfValidator::validateInt(_descr, "toSlotIndex", toSlotIndex, _checker, __FILE__, __LINE__);
	INT32 powerIdCopied; _jparser.validateByNameThrow("powerIdCopied", powerIdCopied);
	AtfValidator::validateInt(_descr, "powerIdCopied", powerIdCopied, _checker, __FILE__, __LINE__);
	UINT32 newPowerState; _jparser.validateByNameThrow("newPowerState", newPowerState);
	AtfValidator::validateInt(_descr, "newPowerState", newPowerState, _checker, __FILE__, __LINE__);
	INT32 newPowerCost; _jparser.validateByNameThrow("newPowerCost", newPowerCost);
	AtfValidator::validateInt(_descr, "newPowerCost", newPowerCost, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::CloneAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE toSlotIndex; _parser.parseBYTE(toSlotIndex);
	AtfValidator::validateInt(_descr, "toSlotIndex", toSlotIndex, _checker, __FILE__, __LINE__);
	INT32 powerIdCopied; _parser.parseINT32(powerIdCopied);
	AtfValidator::validateInt(_descr, "powerIdCopied", powerIdCopied, _checker, __FILE__, __LINE__);
	UINT32 newPowerState; _parser.parseUINT32(newPowerState);
	AtfValidator::validateInt(_descr, "newPowerState", newPowerState, _checker, __FILE__, __LINE__);
	INT32 newPowerCost; _parser.parseINT32(newPowerCost);
	AtfValidator::validateInt(_descr, "newPowerCost", newPowerCost, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    UpgradeAnimation
//=================================================================

TableClient::publication::UpgradeAnimation::UpgradeAnimation()
{
	clear();
}

void TableClient::publication::UpgradeAnimation::clear()
{
	startOrEnd = false;
}

bool TableClient::publication::UpgradeAnimation::equals(const UpgradeAnimation& _o) const
{
	return startOrEnd == _o.startOrEnd;
}

const char *TableClient::publication::UpgradeAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startOrEnd=");
	_buf.appendUint(startOrEnd);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::UpgradeAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("startOrEnd", startOrEnd, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::UpgradeAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("startOrEnd"))
		{
			startOrEnd = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::UpgradeAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(startOrEnd);
}

void TableClient::publication::UpgradeAnimation::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(startOrEnd);
}

const char *TableClient::publication::UpgradeAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("startOrEnd", startOrEnd);
	return _buf.c_str();
}

void TableClient::publication::UpgradeAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("startOrEnd", startOrEnd);
}

/* static */ void TableClient::publication::UpgradeAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool startOrEnd; _jparser.validateByNameThrow("startOrEnd", startOrEnd);
	AtfValidator::validateInt(_descr, "startOrEnd", startOrEnd, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::UpgradeAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool startOrEnd; _parser.parseBOOL(startOrEnd);
	AtfValidator::validateInt(_descr, "startOrEnd", startOrEnd, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    IntelAnimation
//=================================================================

TableClient::publication::IntelAnimation::IntelAnimation()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::IntelAnimation::IntelAnimation(IntelAnimation&& _o)
	: player(std::move(_o.player))
	, NumCards(std::move(_o.NumCards))
	, isFirstEffect(std::move(_o.isFirstEffect))
	, sensedCardIndexes(std::move(_o.sensedCardIndexes))
{
}

TableClient::publication::IntelAnimation& TableClient::publication::IntelAnimation::operator=(IntelAnimation&& _o)
{
	if(this != &_o)
	{
		player = std::move(_o.player);
		NumCards = std::move(_o.NumCards);
		isFirstEffect = std::move(_o.isFirstEffect);
		sensedCardIndexes = std::move(_o.sensedCardIndexes);
	}
	return *this;
}

#endif

void TableClient::publication::IntelAnimation::clear()
{
	player = 0;
	NumCards = 0;
	isFirstEffect = false;
	sensedCardIndexes.clear();
}

bool TableClient::publication::IntelAnimation::equals(const IntelAnimation& _o) const
{
	return player == _o.player &&
		NumCards == _o.NumCards &&
		isFirstEffect == _o.isFirstEffect &&
		sensedCardIndexes.equals(_o.sensedCardIndexes);
}

const char *TableClient::publication::IntelAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("player=");
	_buf.appendUint(player);
	_buf.append(',');
	_buf.append("NumCards=");
	_buf.appendUint(NumCards);
	_buf.append(',');
	_buf.append("isFirstEffect=");
	_buf.appendUint(isFirstEffect);
	_buf.append(',');
	_buf.append("sensedCardIndexes=");
	sensedCardIndexes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::IntelAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("player", player, _buf);
	Atf::XmlElement::encodeAsXmlElement("NumCards", NumCards, _buf);
	Atf::XmlElement::encodeAsXmlElement("isFirstEffect", isFirstEffect, _buf);
	sensedCardIndexes.toXmlString("sensedCardIndexes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::IntelAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("player"))
		{
			player = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("NumCards"))
		{
			NumCards = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isFirstEffect"))
		{
			isFirstEffect = (*_value.ptr() == '1');
		}
		else if (_element.equals("sensedCardIndexes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card, 1 > >::FromXmlString(_value, sensedCardIndexes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::IntelAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(player);
	_msg.composeBYTE(NumCards);
	_msg.composeBOOL(isFirstEffect);
	sensedCardIndexes.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::IntelAnimation::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(player);
	_parser.parseBYTE(NumCards);
	_parser.parseBOOL(isFirstEffect);
	sensedCardIndexes.parseMsg(_parser);
}

const char *TableClient::publication::IntelAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("player", player);
	_jsonstr.compose("NumCards", NumCards);
	_jsonstr.compose("isFirstEffect", isFirstEffect);
	_jsonstr.compose("sensedCardIndexes", sensedCardIndexes);
	return _buf.c_str();
}

void TableClient::publication::IntelAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("player", player);
	_jparser.parseByNameThrow("NumCards", NumCards);
	_jparser.parseByNameThrow("isFirstEffect", isFirstEffect);
	_jparser.parseByNameThrow("sensedCardIndexes", sensedCardIndexes);
}

/* static */ void TableClient::publication::IntelAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE player; _jparser.validateByNameThrow("player", player);
	AtfValidator::validateInt(_descr, "player", player, _checker, __FILE__, __LINE__);
	BYTE NumCards; _jparser.validateByNameThrow("NumCards", NumCards);
	AtfValidator::validateInt(_descr, "NumCards", NumCards, _checker, __FILE__, __LINE__);
	bool isFirstEffect; _jparser.validateByNameThrow("isFirstEffect", isFirstEffect);
	AtfValidator::validateInt(_descr, "isFirstEffect", isFirstEffect, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TableCommon::P_Card > sensedCardIndexes; _jparser.validateByNameThrow("sensedCardIndexes", sensedCardIndexes);
	AtfValidator::validateInt(_descr, "sensedCardIndexes", sensedCardIndexes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::IntelAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE player; _parser.parseBYTE(player);
	AtfValidator::validateInt(_descr, "player", player, _checker, __FILE__, __LINE__);
	BYTE NumCards; _parser.parseBYTE(NumCards);
	AtfValidator::validateInt(_descr, "NumCards", NumCards, _checker, __FILE__, __LINE__);
	bool isFirstEffect; _parser.parseBOOL(isFirstEffect);
	AtfValidator::validateInt(_descr, "isFirstEffect", isFirstEffect, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSensedCardIndexes = Atf::LAtfVector< TableCommon::P_Card, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sensedCardIndexes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sensedCardIndexes", szSensedCardIndexes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ReloadAnimation
//=================================================================

TableClient::publication::ReloadAnimation::ReloadAnimation()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ReloadAnimation::ReloadAnimation(ReloadAnimation&& _o)
	: cardIndexes(std::move(_o.cardIndexes))
{
}

TableClient::publication::ReloadAnimation& TableClient::publication::ReloadAnimation::operator=(ReloadAnimation&& _o)
{
	if(this != &_o)
	{
		cardIndexes = std::move(_o.cardIndexes);
	}
	return *this;
}

#endif

void TableClient::publication::ReloadAnimation::clear()
{
	cardIndexes.clear();
}

bool TableClient::publication::ReloadAnimation::equals(const ReloadAnimation& _o) const
{
	return cardIndexes.equals(_o.cardIndexes);
}

const char *TableClient::publication::ReloadAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardIndexes=");
	cardIndexes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ReloadAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	cardIndexes.toXmlString("cardIndexes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ReloadAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardIndexes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CardWithPosition, 1 > >::FromXmlString(_value, cardIndexes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ReloadAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	cardIndexes.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::ReloadAnimation::parseMsg(CommMsgParser& _parser)
{
	cardIndexes.parseMsg(_parser);
}

const char *TableClient::publication::ReloadAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cardIndexes", cardIndexes);
	return _buf.c_str();
}

void TableClient::publication::ReloadAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardIndexes", cardIndexes);
}

/* static */ void TableClient::publication::ReloadAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< CardWithPosition > cardIndexes; _jparser.validateByNameThrow("cardIndexes", cardIndexes);
	AtfValidator::validateInt(_descr, "cardIndexes", cardIndexes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ReloadAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szCardIndexes = Atf::LAtfVector< CardWithPosition, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cardIndexes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cardIndexes", szCardIndexes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SyphonAnimation
//=================================================================

TableClient::publication::SyphonAnimation::SyphonAnimation()
{
	clear();
}

void TableClient::publication::SyphonAnimation::clear()
{
	fromPlayer = 0;
	toPlayer = 0;
	originManaTo = 0;
	origManaFrom = 0;
	amountDrained = 0;
	amountReceived = 0;
}

bool TableClient::publication::SyphonAnimation::equals(const SyphonAnimation& _o) const
{
	return fromPlayer == _o.fromPlayer &&
		toPlayer == _o.toPlayer &&
		originManaTo == _o.originManaTo &&
		origManaFrom == _o.origManaFrom &&
		amountDrained == _o.amountDrained &&
		amountReceived == _o.amountReceived;
}

const char *TableClient::publication::SyphonAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("fromPlayer=");
	_buf.appendInt(fromPlayer);
	_buf.append(',');
	_buf.append("toPlayer=");
	_buf.appendInt(toPlayer);
	_buf.append(',');
	_buf.append("originManaTo=");
	_buf.appendInt64(originManaTo);
	_buf.append(',');
	_buf.append("origManaFrom=");
	_buf.appendInt64(origManaFrom);
	_buf.append(',');
	_buf.append("amountDrained=");
	_buf.appendInt64(amountDrained);
	_buf.append(',');
	_buf.append("amountReceived=");
	_buf.appendInt64(amountReceived);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::SyphonAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("fromPlayer", fromPlayer, _buf);
	Atf::XmlElement::encodeAsXmlElement("toPlayer", toPlayer, _buf);
	Atf::XmlElement::encodeAsXmlElement("originManaTo", originManaTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("origManaFrom", origManaFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountDrained", amountDrained, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountReceived", amountReceived, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::SyphonAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fromPlayer"))
		{
			fromPlayer = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("toPlayer"))
		{
			toPlayer = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("originManaTo"))
		{
			originManaTo = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("origManaFrom"))
		{
			origManaFrom = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amountDrained"))
		{
			amountDrained = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amountReceived"))
		{
			amountReceived = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::SyphonAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(fromPlayer);
	_msg.composeINT8(toPlayer);
	_msg.composeINT64(originManaTo);
	_msg.composeINT64(origManaFrom);
	_msg.composeINT64(amountDrained);
	_msg.composeINT64(amountReceived);
}

void TableClient::publication::SyphonAnimation::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(fromPlayer);
	_parser.parseINT8(toPlayer);
	_parser.parseINT64(originManaTo);
	_parser.parseINT64(origManaFrom);
	_parser.parseINT64(amountDrained);
	_parser.parseINT64(amountReceived);
}

const char *TableClient::publication::SyphonAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("fromPlayer", fromPlayer);
	_jsonstr.compose("toPlayer", toPlayer);
	_jsonstr.compose("originManaTo", originManaTo);
	_jsonstr.compose("origManaFrom", origManaFrom);
	_jsonstr.compose("amountDrained", amountDrained);
	_jsonstr.compose("amountReceived", amountReceived);
	return _buf.c_str();
}

void TableClient::publication::SyphonAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("fromPlayer", fromPlayer);
	_jparser.parseByNameThrow("toPlayer", toPlayer);
	_jparser.parseByNameThrow("originManaTo", originManaTo);
	_jparser.parseByNameThrow("origManaFrom", origManaFrom);
	_jparser.parseByNameThrow("amountDrained", amountDrained);
	_jparser.parseByNameThrow("amountReceived", amountReceived);
}

/* static */ void TableClient::publication::SyphonAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 fromPlayer; _jparser.validateByNameThrow("fromPlayer", fromPlayer);
	AtfValidator::validateInt(_descr, "fromPlayer", fromPlayer, _checker, __FILE__, __LINE__);
	INT8 toPlayer; _jparser.validateByNameThrow("toPlayer", toPlayer);
	AtfValidator::validateInt(_descr, "toPlayer", toPlayer, _checker, __FILE__, __LINE__);
	INT64 originManaTo; _jparser.validateByNameThrow("originManaTo", originManaTo);
	AtfValidator::validateInt(_descr, "originManaTo", originManaTo, _checker, __FILE__, __LINE__);
	INT64 origManaFrom; _jparser.validateByNameThrow("origManaFrom", origManaFrom);
	AtfValidator::validateInt(_descr, "origManaFrom", origManaFrom, _checker, __FILE__, __LINE__);
	INT64 amountDrained; _jparser.validateByNameThrow("amountDrained", amountDrained);
	AtfValidator::validateInt(_descr, "amountDrained", amountDrained, _checker, __FILE__, __LINE__);
	INT64 amountReceived; _jparser.validateByNameThrow("amountReceived", amountReceived);
	AtfValidator::validateInt(_descr, "amountReceived", amountReceived, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::SyphonAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 fromPlayer; _parser.parseINT8(fromPlayer);
	AtfValidator::validateInt(_descr, "fromPlayer", fromPlayer, _checker, __FILE__, __LINE__);
	INT8 toPlayer; _parser.parseINT8(toPlayer);
	AtfValidator::validateInt(_descr, "toPlayer", toPlayer, _checker, __FILE__, __LINE__);
	INT64 originManaTo; _parser.parseINT64(originManaTo);
	AtfValidator::validateInt(_descr, "originManaTo", originManaTo, _checker, __FILE__, __LINE__);
	INT64 origManaFrom; _parser.parseINT64(origManaFrom);
	AtfValidator::validateInt(_descr, "origManaFrom", origManaFrom, _checker, __FILE__, __LINE__);
	INT64 amountDrained; _parser.parseINT64(amountDrained);
	AtfValidator::validateInt(_descr, "amountDrained", amountDrained, _checker, __FILE__, __LINE__);
	INT64 amountReceived; _parser.parseINT64(amountReceived);
	AtfValidator::validateInt(_descr, "amountReceived", amountReceived, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    DeployPowerAnimation
//=================================================================

TableClient::publication::DeployPowerAnimation::DeployPowerAnimation()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::DeployPowerAnimation::DeployPowerAnimation(DeployPowerAnimation&& _o)
	: boardWidth(std::move(_o.boardWidth))
	, cards(std::move(_o.cards))
{
}

TableClient::publication::DeployPowerAnimation& TableClient::publication::DeployPowerAnimation::operator=(DeployPowerAnimation&& _o)
{
	if(this != &_o)
	{
		boardWidth = std::move(_o.boardWidth);
		cards = std::move(_o.cards);
	}
	return *this;
}

#endif

void TableClient::publication::DeployPowerAnimation::clear()
{
	boardWidth = 0;
	cards.clear();
}

bool TableClient::publication::DeployPowerAnimation::equals(const DeployPowerAnimation& _o) const
{
	return boardWidth == _o.boardWidth &&
		cards.equals(_o.cards);
}

const char *TableClient::publication::DeployPowerAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("boardWidth=");
	_buf.appendUint(boardWidth);
	_buf.append(',');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::DeployPowerAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("boardWidth", boardWidth, _buf);
	cards.toXmlString("cards", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::DeployPowerAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("boardWidth"))
		{
			boardWidth = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CardInfoBody, 1 > >::FromXmlString(_value, cards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::DeployPowerAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(boardWidth);
	cards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::DeployPowerAnimation::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(boardWidth);
	cards.parseMsg(_parser);
}

const char *TableClient::publication::DeployPowerAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("boardWidth", boardWidth);
	_jsonstr.compose("cards", cards);
	return _buf.c_str();
}

void TableClient::publication::DeployPowerAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("boardWidth", boardWidth);
	_jparser.parseByNameThrow("cards", cards);
}

/* static */ void TableClient::publication::DeployPowerAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE boardWidth; _jparser.validateByNameThrow("boardWidth", boardWidth);
	AtfValidator::validateInt(_descr, "boardWidth", boardWidth, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CardInfoBody > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::DeployPowerAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE boardWidth; _parser.parseBYTE(boardWidth);
	AtfValidator::validateInt(_descr, "boardWidth", boardWidth, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCards = Atf::LAtfVector< CardInfoBody, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MorphAnimation
//=================================================================

TableClient::publication::MorphAnimation::MorphAnimation()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::MorphAnimation::MorphAnimation(MorphAnimation&& _o)
	: c(std::move(_o.c))
{
}

TableClient::publication::MorphAnimation& TableClient::publication::MorphAnimation::operator=(MorphAnimation&& _o)
{
	if(this != &_o)
	{
		c = std::move(_o.c);
	}
	return *this;
}

#endif

void TableClient::publication::MorphAnimation::clear()
{
	c.clear();
}

bool TableClient::publication::MorphAnimation::equals(const MorphAnimation& _o) const
{
	return c.equals(_o.c);
}

const char *TableClient::publication::MorphAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("c=");
	c.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::MorphAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	c.toXmlString("c", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::MorphAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("c"))
		{
			if(!Atf::AtfTempl< CardInfo >::FromXmlString(_value, c)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::MorphAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	c.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::MorphAnimation::parseMsg(CommMsgParser& _parser)
{
	c.parseMsg(_parser);
}

const char *TableClient::publication::MorphAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("c", c);
	return _buf.c_str();
}

void TableClient::publication::MorphAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("c", c);
}

/* static */ void TableClient::publication::MorphAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CardInfo c; _jparser.validateByNameThrow("c", c);
}

/*static*/ void TableClient::publication::MorphAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	CardInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("c"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    PacifyAnimPlayer
//=================================================================

TableClient::publication::PacifyAnimPlayer::PacifyAnimPlayer()
{
	clear();
}

void TableClient::publication::PacifyAnimPlayer::clear()
{
	seat = -1;
	chipsReturned = 0;
	chipsRemaining = 0;
	newBalance = 0;
}

bool TableClient::publication::PacifyAnimPlayer::equals(const PacifyAnimPlayer& _o) const
{
	return seat == _o.seat &&
		chipsReturned == _o.chipsReturned &&
		chipsRemaining == _o.chipsRemaining &&
		newBalance == _o.newBalance;
}

const char *TableClient::publication::PacifyAnimPlayer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("chipsReturned=");
	_buf.appendInt64(chipsReturned);
	_buf.append(',');
	_buf.append("chipsRemaining=");
	_buf.appendInt64(chipsRemaining);
	_buf.append(',');
	_buf.append("newBalance=");
	_buf.appendInt64(newBalance);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::PacifyAnimPlayer::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsReturned", chipsReturned, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsRemaining", chipsRemaining, _buf);
	Atf::XmlElement::encodeAsXmlElement("newBalance", newBalance, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::PacifyAnimPlayer::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("s") || _element.equals("seat"))
		{
			seat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chipsReturned"))
		{
			chipsReturned = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chipsRemaining"))
		{
			chipsRemaining = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("newBalance"))
		{
			newBalance = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::PacifyAnimPlayer::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PacifyAnimPlayer())) // not empty
	{
		_body.composeINT8(seat);
		_body.composeINT64(chipsReturned);
		_body.composeINT64(chipsRemaining);
		_body.composeINT64(newBalance);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::PacifyAnimPlayer::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT8(seat);
	_parser0.parseINT64(chipsReturned);
	_parser0.parseINT64(chipsRemaining);
	_parser0.parseINT64(newBalance);
}

const char *TableClient::publication::PacifyAnimPlayer::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("chipsReturned", chipsReturned);
	_jsonstr.compose("chipsRemaining", chipsRemaining);
	_jsonstr.compose("newBalance", newBalance);
	return _buf.c_str();
}

void TableClient::publication::PacifyAnimPlayer::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("chipsReturned", chipsReturned);
	_jparser.parseByNameThrow("chipsRemaining", chipsRemaining);
	_jparser.parseByNameThrow("newBalance", newBalance);
}

/* static */ void TableClient::publication::PacifyAnimPlayer::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT64 chipsReturned; _jparser.validateByNameThrow("chipsReturned", chipsReturned);
	AtfValidator::validateInt(_descr, "chipsReturned", chipsReturned, _checker, __FILE__, __LINE__);
	INT64 chipsRemaining; _jparser.validateByNameThrow("chipsRemaining", chipsRemaining);
	AtfValidator::validateInt(_descr, "chipsRemaining", chipsRemaining, _checker, __FILE__, __LINE__);
	INT64 newBalance; _jparser.validateByNameThrow("newBalance", newBalance);
	AtfValidator::validateInt(_descr, "newBalance", newBalance, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::PacifyAnimPlayer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT8 seat; _parser0.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT64 chipsReturned; _parser0.parseINT64(chipsReturned);
	AtfValidator::validateInt(_descr, "chipsReturned", chipsReturned, _checker, __FILE__, __LINE__);
	INT64 chipsRemaining; _parser0.parseINT64(chipsRemaining);
	AtfValidator::validateInt(_descr, "chipsRemaining", chipsRemaining, _checker, __FILE__, __LINE__);
	INT64 newBalance; _parser0.parseINT64(newBalance);
	AtfValidator::validateInt(_descr, "newBalance", newBalance, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PacifyAnimation
//=================================================================

TableClient::publication::PacifyAnimation::PacifyAnimation()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::PacifyAnimation::PacifyAnimation(PacifyAnimation&& _o)
	: players(std::move(_o.players))
{
}

TableClient::publication::PacifyAnimation& TableClient::publication::PacifyAnimation::operator=(PacifyAnimation&& _o)
{
	if(this != &_o)
	{
		players = std::move(_o.players);
	}
	return *this;
}

#endif

void TableClient::publication::PacifyAnimation::clear()
{
	players.clear();
}

bool TableClient::publication::PacifyAnimation::equals(const PacifyAnimation& _o) const
{
	return players.equals(_o.players);
}

const char *TableClient::publication::PacifyAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("players=");
	players.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::PacifyAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	players.toXmlString("players", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::PacifyAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("players"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PacifyAnimPlayer, 1 > >::FromXmlString(_value, players)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::PacifyAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	players.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::PacifyAnimation::parseMsg(CommMsgParser& _parser)
{
	players.parseMsg(_parser);
}

const char *TableClient::publication::PacifyAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("players", players);
	return _buf.c_str();
}

void TableClient::publication::PacifyAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("players", players);
}

/* static */ void TableClient::publication::PacifyAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PacifyAnimPlayer > players; _jparser.validateByNameThrow("players", players);
	AtfValidator::validateInt(_descr, "players", players.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::PacifyAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szPlayers = Atf::LAtfVector< PacifyAnimPlayer, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("players"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "players", szPlayers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MintAnimation
//=================================================================

TableClient::publication::MintAnimation::MintAnimation()
{
	clear();
}

void TableClient::publication::MintAnimation::clear()
{
	chipsMinted = 0;
	betAmountAfterMint = 0;
}

bool TableClient::publication::MintAnimation::equals(const MintAnimation& _o) const
{
	return chipsMinted == _o.chipsMinted &&
		betAmountAfterMint == _o.betAmountAfterMint;
}

const char *TableClient::publication::MintAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("chipsMinted=");
	_buf.appendInt64(chipsMinted);
	_buf.append(',');
	_buf.append("betAmountAfterMint=");
	_buf.appendInt64(betAmountAfterMint);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::MintAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("chipsMinted", chipsMinted, _buf);
	Atf::XmlElement::encodeAsXmlElement("betAmountAfterMint", betAmountAfterMint, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::MintAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chipsMinted"))
		{
			chipsMinted = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("betAmountAfterMint"))
		{
			betAmountAfterMint = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::MintAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(chipsMinted);
	_msg.composeINT64(betAmountAfterMint);
}

void TableClient::publication::MintAnimation::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(chipsMinted);
	_parser.parseINT64(betAmountAfterMint);
}

const char *TableClient::publication::MintAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chipsMinted", chipsMinted);
	_jsonstr.compose("betAmountAfterMint", betAmountAfterMint);
	return _buf.c_str();
}

void TableClient::publication::MintAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chipsMinted", chipsMinted);
	_jparser.parseByNameThrow("betAmountAfterMint", betAmountAfterMint);
}

/* static */ void TableClient::publication::MintAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 chipsMinted; _jparser.validateByNameThrow("chipsMinted", chipsMinted);
	AtfValidator::validateInt(_descr, "chipsMinted", chipsMinted, _checker, __FILE__, __LINE__);
	INT64 betAmountAfterMint; _jparser.validateByNameThrow("betAmountAfterMint", betAmountAfterMint);
	AtfValidator::validateInt(_descr, "betAmountAfterMint", betAmountAfterMint, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::MintAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT64 chipsMinted; _parser.parseINT64(chipsMinted);
	AtfValidator::validateInt(_descr, "chipsMinted", chipsMinted, _checker, __FILE__, __LINE__);
	INT64 betAmountAfterMint; _parser.parseINT64(betAmountAfterMint);
	AtfValidator::validateInt(_descr, "betAmountAfterMint", betAmountAfterMint, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ChaosCard
//=================================================================

TableClient::publication::ChaosCard::ChaosCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ChaosCard::ChaosCard(ChaosCard&& _o)
	: card(std::move(_o.card))
	, boardNo(std::move(_o.boardNo))
	, cardPos(std::move(_o.cardPos))
	, isBlocked(std::move(_o.isBlocked))
{
}

TableClient::publication::ChaosCard& TableClient::publication::ChaosCard::operator=(ChaosCard&& _o)
{
	if(this != &_o)
	{
		card = std::move(_o.card);
		boardNo = std::move(_o.boardNo);
		cardPos = std::move(_o.cardPos);
		isBlocked = std::move(_o.isBlocked);
	}
	return *this;
}

#endif

void TableClient::publication::ChaosCard::clear()
{
	card.clear();
	boardNo = 0;
	cardPos = 0;
	isBlocked = false;
}

bool TableClient::publication::ChaosCard::equals(const ChaosCard& _o) const
{
	return card.equals(_o.card) &&
		boardNo == _o.boardNo &&
		cardPos == _o.cardPos &&
		isBlocked == _o.isBlocked;
}

const char *TableClient::publication::ChaosCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("card=");
	card.toTraceString(_buf);
	_buf.append(',');
	_buf.append("boardNo=");
	_buf.appendUint(boardNo);
	_buf.append(',');
	_buf.append("cardPos=");
	_buf.appendUint(cardPos);
	_buf.append(',');
	_buf.append("isBlocked=");
	_buf.appendUint(isBlocked);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ChaosCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	card.toXmlString("card", _buf);
	Atf::XmlElement::encodeAsXmlElement("boardNo", boardNo, _buf);
	Atf::XmlElement::encodeAsXmlElement("cardPos", cardPos, _buf);
	Atf::XmlElement::encodeAsXmlElement("isBlocked", isBlocked, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ChaosCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("card"))
		{
			if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, card)) return false;
		}
		else if (_element.equals("boardNo"))
		{
			boardNo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardPos"))
		{
			cardPos = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isBlocked"))
		{
			isBlocked = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ChaosCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ChaosCard())) // not empty
	{
		card.composeMsg(_body, _ignoreJSON);
		_body.composeBYTE(boardNo);
		_body.composeBYTE(cardPos);
		_body.composeBOOL(isBlocked);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::ChaosCard::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	card.parseMsg(_parser0);
	_parser0.parseBYTE(boardNo);
	_parser0.parseBYTE(cardPos);
	_parser0.parseBOOL(isBlocked);
}

const char *TableClient::publication::ChaosCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("card", card);
	_jsonstr.compose("boardNo", boardNo);
	_jsonstr.compose("cardPos", cardPos);
	_jsonstr.compose("isBlocked", isBlocked);
	return _buf.c_str();
}

void TableClient::publication::ChaosCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("card", card);
	_jparser.parseByNameThrow("boardNo", boardNo);
	_jparser.parseByNameThrow("cardPos", cardPos);
	_jparser.parseByNameThrow("isBlocked", isBlocked);
}

/* static */ void TableClient::publication::ChaosCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableCommon::P_Card card; _jparser.validateByNameThrow("card", card);
	BYTE boardNo; _jparser.validateByNameThrow("boardNo", boardNo);
	AtfValidator::validateInt(_descr, "boardNo", boardNo, _checker, __FILE__, __LINE__);
	BYTE cardPos; _jparser.validateByNameThrow("cardPos", cardPos);
	AtfValidator::validateInt(_descr, "cardPos", cardPos, _checker, __FILE__, __LINE__);
	bool isBlocked; _jparser.validateByNameThrow("isBlocked", isBlocked);
	AtfValidator::validateInt(_descr, "isBlocked", isBlocked, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ChaosCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableCommon::P_Card::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("card"), _fieldsWithUnparsedContent);
	BYTE boardNo; _parser0.parseBYTE(boardNo);
	AtfValidator::validateInt(_descr, "boardNo", boardNo, _checker, __FILE__, __LINE__);
	BYTE cardPos; _parser0.parseBYTE(cardPos);
	AtfValidator::validateInt(_descr, "cardPos", cardPos, _checker, __FILE__, __LINE__);
	bool isBlocked; _parser0.parseBOOL(isBlocked);
	AtfValidator::validateInt(_descr, "isBlocked", isBlocked, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ChaosAnimation
//=================================================================

TableClient::publication::ChaosAnimation::ChaosAnimation()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::ChaosAnimation::ChaosAnimation(ChaosAnimation&& _o)
	: chaos(std::move(_o.chaos))
{
}

TableClient::publication::ChaosAnimation& TableClient::publication::ChaosAnimation::operator=(ChaosAnimation&& _o)
{
	if(this != &_o)
	{
		chaos = std::move(_o.chaos);
	}
	return *this;
}

#endif

void TableClient::publication::ChaosAnimation::clear()
{
	chaos.clear();
}

bool TableClient::publication::ChaosAnimation::equals(const ChaosAnimation& _o) const
{
	return chaos.equals(_o.chaos);
}

const char *TableClient::publication::ChaosAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("chaos=");
	chaos.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ChaosAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	chaos.toXmlString("chaos", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ChaosAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chaos"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ChaosCard, 1 > >::FromXmlString(_value, chaos)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ChaosAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	chaos.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::ChaosAnimation::parseMsg(CommMsgParser& _parser)
{
	chaos.parseMsg(_parser);
}

const char *TableClient::publication::ChaosAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chaos", chaos);
	return _buf.c_str();
}

void TableClient::publication::ChaosAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chaos", chaos);
}

/* static */ void TableClient::publication::ChaosAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< ChaosCard > chaos; _jparser.validateByNameThrow("chaos", chaos);
	AtfValidator::validateInt(_descr, "chaos", chaos.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ChaosAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szChaos = Atf::LAtfVector< ChaosCard, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("chaos"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "chaos", szChaos, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    DealingPowerCardsAnimation
//=================================================================

TableClient::publication::DealingPowerCardsAnimation::DealingPowerCardsAnimation()
{
	clear();
}

void TableClient::publication::DealingPowerCardsAnimation::clear()
{
	player = 0;
	numPowerCardsBeforeDealt = 0;
	numPowerCardsDealt = 0;
}

bool TableClient::publication::DealingPowerCardsAnimation::equals(const DealingPowerCardsAnimation& _o) const
{
	return player == _o.player &&
		numPowerCardsBeforeDealt == _o.numPowerCardsBeforeDealt &&
		numPowerCardsDealt == _o.numPowerCardsDealt;
}

const char *TableClient::publication::DealingPowerCardsAnimation::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("player=");
	_buf.appendUint(player);
	_buf.append(',');
	_buf.append("numPowerCardsBeforeDealt=");
	_buf.appendInt(numPowerCardsBeforeDealt);
	_buf.append(',');
	_buf.append("numPowerCardsDealt=");
	_buf.appendInt(numPowerCardsDealt);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::DealingPowerCardsAnimation::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("player", player, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPowerCardsBeforeDealt", numPowerCardsBeforeDealt, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPowerCardsDealt", numPowerCardsDealt, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::DealingPowerCardsAnimation::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("player"))
		{
			player = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPowerCardsBeforeDealt"))
		{
			numPowerCardsBeforeDealt = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPowerCardsDealt"))
		{
			numPowerCardsDealt = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::DealingPowerCardsAnimation::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(player);
	_msg.composeINT32(numPowerCardsBeforeDealt);
	_msg.composeINT32(numPowerCardsDealt);
}

void TableClient::publication::DealingPowerCardsAnimation::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(player);
	_parser.parseINT32(numPowerCardsBeforeDealt);
	_parser.parseINT32(numPowerCardsDealt);
}

const char *TableClient::publication::DealingPowerCardsAnimation::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("player", player);
	_jsonstr.compose("numPowerCardsBeforeDealt", numPowerCardsBeforeDealt);
	_jsonstr.compose("numPowerCardsDealt", numPowerCardsDealt);
	return _buf.c_str();
}

void TableClient::publication::DealingPowerCardsAnimation::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("player", player);
	_jparser.parseByNameThrow("numPowerCardsBeforeDealt", numPowerCardsBeforeDealt);
	_jparser.parseByNameThrow("numPowerCardsDealt", numPowerCardsDealt);
}

/* static */ void TableClient::publication::DealingPowerCardsAnimation::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE player; _jparser.validateByNameThrow("player", player);
	AtfValidator::validateInt(_descr, "player", player, _checker, __FILE__, __LINE__);
	INT32 numPowerCardsBeforeDealt; _jparser.validateByNameThrow("numPowerCardsBeforeDealt", numPowerCardsBeforeDealt);
	AtfValidator::validateInt(_descr, "numPowerCardsBeforeDealt", numPowerCardsBeforeDealt, _checker, __FILE__, __LINE__);
	INT32 numPowerCardsDealt; _jparser.validateByNameThrow("numPowerCardsDealt", numPowerCardsDealt);
	AtfValidator::validateInt(_descr, "numPowerCardsDealt", numPowerCardsDealt, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::DealingPowerCardsAnimation::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE player; _parser.parseBYTE(player);
	AtfValidator::validateInt(_descr, "player", player, _checker, __FILE__, __LINE__);
	INT32 numPowerCardsBeforeDealt; _parser.parseINT32(numPowerCardsBeforeDealt);
	AtfValidator::validateInt(_descr, "numPowerCardsBeforeDealt", numPowerCardsBeforeDealt, _checker, __FILE__, __LINE__);
	INT32 numPowerCardsDealt; _parser.parseINT32(numPowerCardsDealt);
	AtfValidator::validateInt(_descr, "numPowerCardsDealt", numPowerCardsDealt, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    WinnerInfo
//=================================================================

TableClient::publication::WinnerInfo::WinnerInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::WinnerInfo::WinnerInfo(WinnerInfo&& _o)
	: seat(std::move(_o.seat))
	, winningAmount(std::move(_o.winningAmount))
	, handRank(std::move(_o.handRank))
	, kickerRanks(std::move(_o.kickerRanks))
	, winningCards(std::move(_o.winningCards))
{
}

TableClient::publication::WinnerInfo& TableClient::publication::WinnerInfo::operator=(WinnerInfo&& _o)
{
	if(this != &_o)
	{
		seat = std::move(_o.seat);
		winningAmount = std::move(_o.winningAmount);
		handRank = std::move(_o.handRank);
		kickerRanks = std::move(_o.kickerRanks);
		winningCards = std::move(_o.winningCards);
	}
	return *this;
}

#endif

void TableClient::publication::WinnerInfo::clear()
{
	seat = -1;
	winningAmount = 0;
	handRank = 0;
	kickerRanks.clear();
	winningCards.clear();
}

bool TableClient::publication::WinnerInfo::equals(const WinnerInfo& _o) const
{
	return seat == _o.seat &&
		winningAmount == _o.winningAmount &&
		handRank == _o.handRank &&
		kickerRanks.equals(_o.kickerRanks) &&
		winningCards.equals(_o.winningCards);
}

const char *TableClient::publication::WinnerInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("winningAmount=");
	_buf.appendInt64(winningAmount);
	_buf.append(',');
	_buf.append("handRank=");
	_buf.appendUint(handRank);
	_buf.append(',');
	_buf.append("kickerRanks=");
	kickerRanks.toTraceString(_buf);
	_buf.append(',');
	_buf.append("winningCards=");
	winningCards.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::WinnerInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("winningAmount", winningAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("handRank", handRank, _buf);
	kickerRanks.toXmlString("kickerRanks", _buf);
	winningCards.toXmlString("winningCards", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::WinnerInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("s") || _element.equals("seat"))
		{
			seat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winningAmount"))
		{
			winningAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handRank"))
		{
			handRank = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("kickerRanks"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT8, 1 > >::FromXmlString(_value, kickerRanks)) return false;
		}
		else if (_element.equals("winningCards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CardInfoBody, 1 > >::FromXmlString(_value, winningCards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::WinnerInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(WinnerInfo())) // not empty
	{
		_body.composeINT8(seat);
		_body.composeINT64(winningAmount);
		_body.composeBYTE(handRank);
		kickerRanks.composeMsg(_body, _ignoreJSON);
		winningCards.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::WinnerInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT8(seat);
	_parser0.parseINT64(winningAmount);
	_parser0.parseBYTE(handRank);
	kickerRanks.parseMsg(_parser0);
	winningCards.parseMsg(_parser0);
}

const char *TableClient::publication::WinnerInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("winningAmount", winningAmount);
	_jsonstr.compose("handRank", handRank);
	_jsonstr.compose("kickerRanks", kickerRanks);
	_jsonstr.compose("winningCards", winningCards);
	return _buf.c_str();
}

void TableClient::publication::WinnerInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("winningAmount", winningAmount);
	_jparser.parseByNameThrow("handRank", handRank);
	_jparser.parseByNameThrow("kickerRanks", kickerRanks);
	_jparser.parseByNameThrow("winningCards", winningCards);
}

/* static */ void TableClient::publication::WinnerInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT64 winningAmount; _jparser.validateByNameThrow("winningAmount", winningAmount);
	AtfValidator::validateInt(_descr, "winningAmount", winningAmount, _checker, __FILE__, __LINE__);
	BYTE handRank; _jparser.validateByNameThrow("handRank", handRank);
	AtfValidator::validateInt(_descr, "handRank", handRank, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT8 > kickerRanks; _jparser.validateByNameThrow("kickerRanks", kickerRanks);
	AtfValidator::validateInt(_descr, "kickerRanks", kickerRanks.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CardInfoBody > winningCards; _jparser.validateByNameThrow("winningCards", winningCards);
	AtfValidator::validateInt(_descr, "winningCards", winningCards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::WinnerInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT8 seat; _parser0.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT64 winningAmount; _parser0.parseINT64(winningAmount);
	AtfValidator::validateInt(_descr, "winningAmount", winningAmount, _checker, __FILE__, __LINE__);
	BYTE handRank; _parser0.parseBYTE(handRank);
	AtfValidator::validateInt(_descr, "handRank", handRank, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szKickerRanks = Atf::LAtfVector< INT8, 1 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("kickerRanks"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "kickerRanks", szKickerRanks, _checker, __FILE__, __LINE__);
	int szWinningCards = Atf::LAtfVector< CardInfoBody, 1 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("winningCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winningCards", szWinningCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION(Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION&& _o)
	: potNo(std::move(_o.potNo))
	, startAmount(std::move(_o.startAmount))
	, endAmount(std::move(_o.endAmount))
	, playersInPot(std::move(_o.playersInPot))
	, winners(std::move(_o.winners))
	, boardNo(std::move(_o.boardNo))
	, isLoHand(std::move(_o.isLoHand))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::operator=(Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION&& _o)
{
	if(this != &_o)
	{
		potNo = std::move(_o.potNo);
		startAmount = std::move(_o.startAmount);
		endAmount = std::move(_o.endAmount);
		playersInPot = std::move(_o.playersInPot);
		winners = std::move(_o.winners);
		boardNo = std::move(_o.boardNo);
		isLoHand = std::move(_o.isLoHand);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::clear()
{
	potNo = 0;
	startAmount = 0;
	endAmount = 0;
	playersInPot.clear();
	winners.clear();
	boardNo = 0;
	isLoHand = false;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::equals(const Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION& _o) const
{
	return potNo == _o.potNo &&
		startAmount == _o.startAmount &&
		endAmount == _o.endAmount &&
		playersInPot.equals(_o.playersInPot) &&
		winners.equals(_o.winners) &&
		boardNo == _o.boardNo &&
		isLoHand == _o.isLoHand;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_POT_DISTRIBUTION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_POT_DISTRIBUTION).append(")");
	_buf.append(',');
	_buf.append("potNo=");
	_buf.appendUint(potNo);
	_buf.append(',');
	_buf.append("startAmount=");
	_buf.appendInt64(startAmount);
	_buf.append(',');
	_buf.append("endAmount=");
	_buf.appendInt64(endAmount);
	_buf.append(',');
	_buf.append("playersInPot=");
	playersInPot.toTraceString(_buf);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append(',');
	_buf.append("boardNo=");
	_buf.appendUint(boardNo);
	_buf.append(',');
	_buf.append("isLoHand=");
	_buf.appendUint(isLoHand);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_POT_DISTRIBUTION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("potNo", potNo, _buf);
	Atf::XmlElement::encodeAsXmlElement("startAmount", startAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("endAmount", endAmount, _buf);
	playersInPot.toXmlString("playersInPot", _buf);
	winners.toXmlString("winners", _buf);
	Atf::XmlElement::encodeAsXmlElement("boardNo", boardNo, _buf);
	Atf::XmlElement::encodeAsXmlElement("isLoHand", isLoHand, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("potNo"))
			{
				potNo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startAmount"))
			{
				startAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("endAmount"))
			{
				endAmount = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playersInPot"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< BYTE, 1 > >::FromXmlString(_value, playersInPot)) return false;
			}
			else if (_element.equals("winners"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< WinnerInfo, 1 > >::FromXmlString(_value, winners)) return false;
			}
			else if (_element.equals("boardNo"))
			{
				boardNo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isLoHand"))
			{
				isLoHand = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(potNo);
	_msg.composeINT64(startAmount);
	_msg.composeINT64(endAmount);
	playersInPot.composeMsg(_msg, _ignoreJSON);
	winners.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(boardNo);
	_msg.composeBOOL(isLoHand);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(potNo);
	_parser.parseINT64(startAmount);
	_parser.parseINT64(endAmount);
	playersInPot.parseMsg(_parser);
	winners.parseMsg(_parser);
	_parser.parseBYTE(boardNo);
	_parser.parseBOOL(isLoHand);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("potNo", potNo);
	_jsonstr.compose("startAmount", startAmount);
	_jsonstr.compose("endAmount", endAmount);
	_jsonstr.compose("playersInPot", playersInPot);
	_jsonstr.compose("winners", winners);
	_jsonstr.compose("boardNo", boardNo);
	_jsonstr.compose("isLoHand", isLoHand);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("potNo", potNo);
	_jparser.parseByNameThrow("startAmount", startAmount);
	_jparser.parseByNameThrow("endAmount", endAmount);
	_jparser.parseByNameThrow("playersInPot", playersInPot);
	_jparser.parseByNameThrow("winners", winners);
	_jparser.parseByNameThrow("boardNo", boardNo);
	_jparser.parseByNameThrow("isLoHand", isLoHand);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_POT_DISTRIBUTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE potNo; _jparser.validateByNameThrow("potNo", potNo);
	AtfValidator::validateInt(_descr, "potNo", potNo, _checker, __FILE__, __LINE__);
	INT64 startAmount; _jparser.validateByNameThrow("startAmount", startAmount);
	AtfValidator::validateInt(_descr, "startAmount", startAmount, _checker, __FILE__, __LINE__);
	INT64 endAmount; _jparser.validateByNameThrow("endAmount", endAmount);
	AtfValidator::validateInt(_descr, "endAmount", endAmount, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< BYTE > playersInPot; _jparser.validateByNameThrow("playersInPot", playersInPot);
	AtfValidator::validateInt(_descr, "playersInPot", playersInPot.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< WinnerInfo > winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners.size(), _checker, __FILE__, __LINE__);
	BYTE boardNo; _jparser.validateByNameThrow("boardNo", boardNo);
	AtfValidator::validateInt(_descr, "boardNo", boardNo, _checker, __FILE__, __LINE__);
	bool isLoHand; _jparser.validateByNameThrow("isLoHand", isLoHand);
	AtfValidator::validateInt(_descr, "isLoHand", isLoHand, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_POT_DISTRIBUTION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE potNo; _parser.parseBYTE(potNo);
	AtfValidator::validateInt(_descr, "potNo", potNo, _checker, __FILE__, __LINE__);
	INT64 startAmount; _parser.parseINT64(startAmount);
	AtfValidator::validateInt(_descr, "startAmount", startAmount, _checker, __FILE__, __LINE__);
	INT64 endAmount; _parser.parseINT64(endAmount);
	AtfValidator::validateInt(_descr, "endAmount", endAmount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPlayersInPot = Atf::LAtfVector< BYTE, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playersInPot"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playersInPot", szPlayersInPot, _checker, __FILE__, __LINE__);
	int szWinners = Atf::LAtfVector< WinnerInfo, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
	BYTE boardNo; _parser.parseBYTE(boardNo);
	AtfValidator::validateInt(_descr, "boardNo", boardNo, _checker, __FILE__, __LINE__);
	bool isLoHand; _parser.parseBOOL(isLoHand);
	AtfValidator::validateInt(_descr, "isLoHand", isLoHand, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::clear()
{
	seat = -1;
	textId = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::equals(const Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST& _o) const
{
	return seat == _o.seat &&
		textId == _o.textId;
}

bool TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_USER_MINI_CHAT_BROADCAST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_USER_MINI_CHAT_BROADCAST).append(")");
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("textId=");
	_buf.appendInt(textId);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_USER_MINI_CHAT_BROADCAST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("textId", textId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("textId"))
			{
				textId = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(seat);
	_msg.composeINT16(textId);
}

void TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(seat);
	_parser.parseINT16(textId);
}

const char *TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("textId", textId);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("textId", textId);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_MINI_CHAT_BROADCAST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT16 textId; _jparser.validateByNameThrow("textId", textId);
	AtfValidator::validateInt(_descr, "textId", textId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_USER_MINI_CHAT_BROADCAST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT16 textId; _parser.parseINT16(textId);
	AtfValidator::validateInt(_descr, "textId", textId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_ANIMATION
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::Protocol_MSG_TABLE_SUBSCR_ANIMATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::Protocol_MSG_TABLE_SUBSCR_ANIMATION(Protocol_MSG_TABLE_SUBSCR_ANIMATION&& _o)
	: userId(std::move(_o.userId))
	, seat(std::move(_o.seat))
	, animationTypeId(std::move(_o.animationTypeId))
	, extraInfo(std::move(_o.extraInfo))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::operator=(Protocol_MSG_TABLE_SUBSCR_ANIMATION&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		seat = std::move(_o.seat);
		animationTypeId = std::move(_o.animationTypeId);
		extraInfo = std::move(_o.extraInfo);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::clear()
{
	userId.clear();
	seat = -1;
	animationTypeId = 0;
	extraInfo.clear();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::equals(const Protocol_MSG_TABLE_SUBSCR_ANIMATION& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		seat == _o.seat &&
		animationTypeId == _o.animationTypeId &&
		extraInfo.equals(_o.extraInfo);
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_ANIMATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_ANIMATION*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_ANIMATION).append(")");
	_buf.append(',');
	_buf.append("u=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("animationTypeId=");
	_buf.appendUint(animationTypeId);
	_buf.append(',');
	_buf.append("extraInfo=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(extraInfo, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_ANIMATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("u", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("animationTypeId", animationTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("extraInfo", extraInfo, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("u") || _element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("s") || _element.equals("seat"))
			{
				seat = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("animationTypeId"))
			{
				animationTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("extraInfo"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, extraInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT8(seat);
	_msg.composeUINT32(animationTypeId);
	_msg.composeMsgBody(extraInfo);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT8(seat);
	_parser.parseUINT32(animationTypeId);
	_parser.parseMsgBody(extraInfo);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("u", userId);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("animationTypeId", animationTypeId);
	_jsonstr.compose("extraInfo", extraInfo);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("u", userId)) _jparser.parseByNameThrow("userId", userId);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("animationTypeId", animationTypeId);
	_jparser.parseByNameThrow("extraInfo", extraInfo);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_ANIMATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; if(!_jparser.validateByName("u", userId)) _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	UINT32 animationTypeId; _jparser.validateByNameThrow("animationTypeId", animationTypeId);
	AtfValidator::validateInt(_descr, "animationTypeId", animationTypeId, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody extraInfo; _jparser.validateByNameThrow("extraInfo", extraInfo);
	AtfValidator::validateInt(_descr, "extraInfo", extraInfo._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_ANIMATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	UINT32 animationTypeId; _parser.parseUINT32(animationTypeId);
	AtfValidator::validateInt(_descr, "animationTypeId", animationTypeId, _checker, __FILE__, __LINE__);
	size_t szExtraInfo; _parser.skipMsgBody(szExtraInfo);  /*extraInfo*/
	AtfValidator::validateInt(_descr, "extraInfo", szExtraInfo, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_THROW
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::Protocol_MSG_TABLE_SUBSCR_THROW()
{
	clear();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::clear()
{
	seatFrom = -1;
	seatTo = -1;
	throwableTypeId = 0;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::equals(const Protocol_MSG_TABLE_SUBSCR_THROW& _o) const
{
	return seatFrom == _o.seatFrom &&
		seatTo == _o.seatTo &&
		throwableTypeId == _o.throwableTypeId;
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_THROW != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_THROW*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_THROW).append(")");
	_buf.append(',');
	_buf.append("sF=");
	_buf.appendInt(seatFrom);
	_buf.append(',');
	_buf.append("sT=");
	_buf.appendInt(seatTo);
	_buf.append(',');
	_buf.append("throwableTypeId=");
	_buf.appendUint(throwableTypeId);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_THROW).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sF", seatFrom, _buf);
	Atf::XmlElement::encodeAsXmlElement("sT", seatTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("throwableTypeId", throwableTypeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sF") || _element.equals("seatFrom"))
			{
				seatFrom = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sT") || _element.equals("seatTo"))
			{
				seatTo = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("throwableTypeId"))
			{
				throwableTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(seatFrom);
	_msg.composeINT8(seatTo);
	_msg.composeUINT32(throwableTypeId);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(seatFrom);
	_parser.parseINT8(seatTo);
	_parser.parseUINT32(throwableTypeId);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sF", seatFrom);
	_jsonstr.compose("sT", seatTo);
	_jsonstr.compose("throwableTypeId", throwableTypeId);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("sF", seatFrom)) _jparser.parseByNameThrow("seatFrom", seatFrom);
	if(!_jparser.parseByName("sT", seatTo)) _jparser.parseByNameThrow("seatTo", seatTo);
	_jparser.parseByNameThrow("throwableTypeId", throwableTypeId);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_THROW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seatFrom; if(!_jparser.validateByName("sF", seatFrom)) _jparser.validateByNameThrow("seatFrom", seatFrom);
	AtfValidator::validateInt(_descr, "seatFrom", seatFrom, _checker, __FILE__, __LINE__);
	INT8 seatTo; if(!_jparser.validateByName("sT", seatTo)) _jparser.validateByNameThrow("seatTo", seatTo);
	AtfValidator::validateInt(_descr, "seatTo", seatTo, _checker, __FILE__, __LINE__);
	UINT32 throwableTypeId; _jparser.validateByNameThrow("throwableTypeId", throwableTypeId);
	AtfValidator::validateInt(_descr, "throwableTypeId", throwableTypeId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_THROW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_THROW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT8 seatFrom; _parser.parseINT8(seatFrom);
	AtfValidator::validateInt(_descr, "seatFrom", seatFrom, _checker, __FILE__, __LINE__);
	INT8 seatTo; _parser.parseINT8(seatTo);
	AtfValidator::validateInt(_descr, "seatTo", seatTo, _checker, __FILE__, __LINE__);
	UINT32 throwableTypeId; _parser.parseUINT32(throwableTypeId);
	AtfValidator::validateInt(_descr, "throwableTypeId", throwableTypeId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    KnockedOutBy
//=================================================================

TableClient::publication::KnockedOutBy::KnockedOutBy()
{
	clear();
}

void TableClient::publication::KnockedOutBy::clear()
{
	seat = -1;
	bountyWon = 0;
	spinBountyWon = 0;
	ownBountyIncrease = 0;
}

bool TableClient::publication::KnockedOutBy::equals(const KnockedOutBy& _o) const
{
	return seat == _o.seat &&
		bountyWon == _o.bountyWon &&
		spinBountyWon == _o.spinBountyWon &&
		ownBountyIncrease == _o.ownBountyIncrease;
}

const char *TableClient::publication::KnockedOutBy::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("seat=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("bountyWon=");
	_buf.appendInt64(bountyWon);
	_buf.append(',');
	_buf.append("spinBountyWon=");
	_buf.appendInt64(spinBountyWon);
	_buf.append(',');
	_buf.append("ownBountyIncrease=");
	_buf.appendInt64(ownBountyIncrease);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::KnockedOutBy::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("seat", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("bountyWon", bountyWon, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinBountyWon", spinBountyWon, _buf);
	Atf::XmlElement::encodeAsXmlElement("ownBountyIncrease", ownBountyIncrease, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::KnockedOutBy::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("seat"))
		{
			seat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bountyWon"))
		{
			bountyWon = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinBountyWon"))
		{
			spinBountyWon = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ownBountyIncrease"))
		{
			ownBountyIncrease = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::KnockedOutBy::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(KnockedOutBy())) // not empty
	{
		_body.composeINT8(seat);
		_body.composeINT64(bountyWon);
		_body.composeINT64(spinBountyWon);
		_body.composeINT64(ownBountyIncrease);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::KnockedOutBy::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT8(seat);
	_parser0.parseINT64(bountyWon);
	_parser0.parseINT64(spinBountyWon);
	_parser0.parseINT64(ownBountyIncrease);
}

const char *TableClient::publication::KnockedOutBy::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("seat", seat);
	_jsonstr.compose("bountyWon", bountyWon);
	_jsonstr.compose("spinBountyWon", spinBountyWon);
	_jsonstr.compose("ownBountyIncrease", ownBountyIncrease);
	return _buf.c_str();
}

void TableClient::publication::KnockedOutBy::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("bountyWon", bountyWon);
	_jparser.parseByNameThrow("spinBountyWon", spinBountyWon);
	_jparser.parseByNameThrow("ownBountyIncrease", ownBountyIncrease);
}

/* static */ void TableClient::publication::KnockedOutBy::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT64 bountyWon; _jparser.validateByNameThrow("bountyWon", bountyWon);
	AtfValidator::validateInt(_descr, "bountyWon", bountyWon, _checker, __FILE__, __LINE__);
	INT64 spinBountyWon; _jparser.validateByNameThrow("spinBountyWon", spinBountyWon);
	AtfValidator::validateInt(_descr, "spinBountyWon", spinBountyWon, _checker, __FILE__, __LINE__);
	INT64 ownBountyIncrease; _jparser.validateByNameThrow("ownBountyIncrease", ownBountyIncrease);
	AtfValidator::validateInt(_descr, "ownBountyIncrease", ownBountyIncrease, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::KnockedOutBy::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT8 seat; _parser0.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT64 bountyWon; _parser0.parseINT64(bountyWon);
	AtfValidator::validateInt(_descr, "bountyWon", bountyWon, _checker, __FILE__, __LINE__);
	INT64 spinBountyWon; _parser0.parseINT64(spinBountyWon);
	AtfValidator::validateInt(_descr, "spinBountyWon", spinBountyWon, _checker, __FILE__, __LINE__);
	INT64 ownBountyIncrease; _parser0.parseINT64(ownBountyIncrease);
	AtfValidator::validateInt(_descr, "ownBountyIncrease", ownBountyIncrease, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    KnockedOut
//=================================================================

TableClient::publication::KnockedOut::KnockedOut()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::KnockedOut::KnockedOut(KnockedOut&& _o)
	: seat(std::move(_o.seat))
	, knockedOutBy(std::move(_o.knockedOutBy))
	, spinMultiplier(std::move(_o.spinMultiplier))
	, animationType(std::move(_o.animationType))
{
}

TableClient::publication::KnockedOut& TableClient::publication::KnockedOut::operator=(KnockedOut&& _o)
{
	if(this != &_o)
	{
		seat = std::move(_o.seat);
		knockedOutBy = std::move(_o.knockedOutBy);
		spinMultiplier = std::move(_o.spinMultiplier);
		animationType = std::move(_o.animationType);
	}
	return *this;
}

#endif

void TableClient::publication::KnockedOut::clear()
{
	seat = -1;
	knockedOutBy.clear();
	spinMultiplier = 0;
	animationType = 0;
}

bool TableClient::publication::KnockedOut::equals(const KnockedOut& _o) const
{
	return seat == _o.seat &&
		knockedOutBy.equals(_o.knockedOutBy) &&
		spinMultiplier == _o.spinMultiplier &&
		animationType == _o.animationType;
}

const char *TableClient::publication::KnockedOut::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("seat=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("knockedOutBy=");
	knockedOutBy.toTraceString(_buf);
	_buf.append(',');
	_buf.append("spinMultiplier=");
	_buf.appendInt(spinMultiplier);
	_buf.append(',');
	_buf.append("animationType=");
	_buf.appendUint(animationType);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::KnockedOut::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("seat", seat, _buf);
	knockedOutBy.toXmlString("knockedOutBy", _buf);
	Atf::XmlElement::encodeAsXmlElement("spinMultiplier", spinMultiplier, _buf);
	Atf::XmlElement::encodeAsXmlElement("animationType", animationType, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::KnockedOut::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("seat"))
		{
			seat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockedOutBy"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< KnockedOutBy , 4 > >::FromXmlString(_value, knockedOutBy)) return false;
		}
		else if (_element.equals("spinMultiplier"))
		{
			spinMultiplier = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("animationType"))
		{
			animationType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::KnockedOut::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(KnockedOut())) // not empty
	{
		_body.composeINT8(seat);
		knockedOutBy.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(spinMultiplier);
		_body.composeUINT32(animationType);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::KnockedOut::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT8(seat);
	knockedOutBy.parseMsg(_parser0);
	_parser0.parseINT32(spinMultiplier);
	_parser0.parseUINT32(animationType);
}

const char *TableClient::publication::KnockedOut::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("seat", seat);
	_jsonstr.compose("knockedOutBy", knockedOutBy);
	_jsonstr.compose("spinMultiplier", spinMultiplier);
	_jsonstr.compose("animationType", animationType);
	return _buf.c_str();
}

void TableClient::publication::KnockedOut::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("knockedOutBy", knockedOutBy);
	_jparser.parseByNameThrow("spinMultiplier", spinMultiplier);
	_jparser.parseByNameThrow("animationType", animationType);
}

/* static */ void TableClient::publication::KnockedOut::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< KnockedOutBy > knockedOutBy; _jparser.validateByNameThrow("knockedOutBy", knockedOutBy);
	AtfValidator::validateInt(_descr, "knockedOutBy", knockedOutBy.size(), _checker, __FILE__, __LINE__);
	INT32 spinMultiplier; _jparser.validateByNameThrow("spinMultiplier", spinMultiplier);
	AtfValidator::validateInt(_descr, "spinMultiplier", spinMultiplier, _checker, __FILE__, __LINE__);
	UINT32 animationType; _jparser.validateByNameThrow("animationType", animationType);
	AtfValidator::validateInt(_descr, "animationType", animationType, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::KnockedOut::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT8 seat; _parser0.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szKnockedOutBy = Atf::LAtfVector< KnockedOutBy , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("knockedOutBy"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "knockedOutBy", szKnockedOutBy, _checker, __FILE__, __LINE__);
	INT32 spinMultiplier; _parser0.parseINT32(spinMultiplier);
	AtfValidator::validateInt(_descr, "spinMultiplier", spinMultiplier, _checker, __FILE__, __LINE__);
	UINT32 animationType; _parser0.parseUINT32(animationType);
	AtfValidator::validateInt(_descr, "animationType", animationType, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_TABLE_SUBSCR_KNOCKOUT
//=================================================================

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT(Protocol_MSG_TABLE_SUBSCR_KNOCKOUT&& _o)
	: knockedOut(std::move(_o.knockedOut))
{
}

TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT& TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::operator=(Protocol_MSG_TABLE_SUBSCR_KNOCKOUT&& _o)
{
	if(this != &_o)
	{
		knockedOut = std::move(_o.knockedOut);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::clear()
{
	knockedOut.clear();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::equals(const Protocol_MSG_TABLE_SUBSCR_KNOCKOUT& _o) const
{
	return knockedOut.equals(_o.knockedOut);
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_SUBSCR_KNOCKOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_SUBSCR_KNOCKOUT*)_other));
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_SUBSCR_KNOCKOUT).append(")");
	_buf.append(',');
	_buf.append("knockedOut=");
	knockedOut.toTraceString(_buf);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_SUBSCR_KNOCKOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	knockedOut.toXmlString("knockedOut", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("knockedOut"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< KnockedOut , 4 > >::FromXmlString(_value, knockedOut)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	knockedOut.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::parseMsg(CommMsgParser& _parser)
{
	knockedOut.parseMsg(_parser);
}

const char *TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("knockedOut", knockedOut);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("knockedOut", knockedOut);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_KNOCKOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< KnockedOut > knockedOut; _jparser.validateByNameThrow("knockedOut", knockedOut);
	AtfValidator::validateInt(_descr, "knockedOut", knockedOut.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_SUBSCR_KNOCKOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szKnockedOut = Atf::LAtfVector< KnockedOut , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("knockedOut"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "knockedOut", szKnockedOut, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableSubscr_Chat
//=================================================================

TableClient::publication::TableSubscr_Chat::TableSubscr_Chat()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TableSubscr_Chat::TableSubscr_Chat(TableSubscr_Chat&& _o)
	: clentOrdinal(std::move(_o.clentOrdinal))
	, handId(std::move(_o.handId))
	, eventCode(std::move(_o.eventCode))
	, seat(std::move(_o.seat))
	, action(std::move(_o.action))
	, amount(std::move(_o.amount))
	, user(std::move(_o.user))
	, content(std::move(_o.content))
	, amount2(std::move(_o.amount2))
	, msgClientExtra(std::move(_o.msgClientExtra))
	, timestamp(std::move(_o.timestamp))
	, eventSeqId(std::move(_o.eventSeqId))
	, brandMask(std::move(_o.brandMask))
{
}

TableClient::publication::TableSubscr_Chat& TableClient::publication::TableSubscr_Chat::operator=(TableSubscr_Chat&& _o)
{
	if(this != &_o)
	{
		clentOrdinal = std::move(_o.clentOrdinal);
		handId = std::move(_o.handId);
		eventCode = std::move(_o.eventCode);
		seat = std::move(_o.seat);
		action = std::move(_o.action);
		amount = std::move(_o.amount);
		user = std::move(_o.user);
		content = std::move(_o.content);
		amount2 = std::move(_o.amount2);
		msgClientExtra = std::move(_o.msgClientExtra);
		timestamp = std::move(_o.timestamp);
		eventSeqId = std::move(_o.eventSeqId);
		brandMask = std::move(_o.brandMask);
	}
	return *this;
}

#endif

void TableClient::publication::TableSubscr_Chat::clear()
{
	clentOrdinal = 0;
	handId = 0;
	eventCode = 0;
	seat = -1;
	action = 0;
	amount = 0;
	user.clear();
	content.clear();
	amount2 = 0;
	msgClientExtra.clear();
	timestamp = 0;
	eventSeqId = 0;
	brandMask = BrandType_ALLMask;
}

bool TableClient::publication::TableSubscr_Chat::equals(const TableSubscr_Chat& _o) const
{
	return clentOrdinal == _o.clentOrdinal &&
		handId == _o.handId &&
		eventCode == _o.eventCode &&
		seat == _o.seat &&
		action == _o.action &&
		amount == _o.amount &&
		Atf::atfPStringEquals(user, _o.user) &&
		Atf::atfPStringEquals(content, _o.content) &&
		amount2 == _o.amount2 &&
		eventSeqId == _o.eventSeqId &&
		brandMask == _o.brandMask;
}

const char *TableClient::publication::TableSubscr_Chat::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clentOrdinal=");
	_buf.appendUint(clentOrdinal);
	_buf.append(',');
	_buf.append("hI=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("eventCode=");
	_buf.appendInt(eventCode);
	_buf.append(',');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("a=");
	_buf.appendInt(action);
	_buf.append(',');
	_buf.append("v=");
	_buf.appendUint(amount);
	_buf.append(',');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("content=");
	_buf.append(content);
	_buf.append(',');
	_buf.append("v2=");
	_buf.appendInt(amount2);
	_buf.append(',');
	_buf.append("msgClientExtra=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(msgClientExtra, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("timestamp=");
	_buf.appendUint(timestamp);
	_buf.append(',');
	_buf.append("eventSq=");
	_buf.appendUint(eventSeqId);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_Chat::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("clentOrdinal", clentOrdinal, _buf);
	Atf::XmlElement::encodeAsXmlElement("hI", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("eventCode", eventCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("a", action, _buf);
	Atf::XmlElement::encodeAsXmlElement("v", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("user", user, _buf);
	Atf::XmlElement::encodeAsXmlElement("content", content, _buf);
	Atf::XmlElement::encodeAsXmlElement("v2", amount2, _buf);
	Atf::XmlElement::encodeAsXmlElement("msgClientExtra", msgClientExtra, _buf);
	Atf::XmlElement::encodeAsXmlElement("timestamp", timestamp, _buf);
	Atf::XmlElement::encodeAsXmlElement("eventSq", eventSeqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_Chat::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("clentOrdinal"))
		{
			clentOrdinal = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hI") || _element.equals("handId"))
		{
			handId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("eventCode"))
		{
			eventCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("s") || _element.equals("seat"))
		{
			seat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("a") || _element.equals("action"))
		{
			action = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("v") || _element.equals("amount"))
		{
			amount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("user"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, user)) return false;
		}
		else if (_element.equals("content"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, content)) return false;
		}
		else if (_element.equals("v2") || _element.equals("amount2"))
		{
			amount2 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("msgClientExtra"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, msgClientExtra)) return false;
		}
		else if (_element.equals("timestamp"))
		{
			timestamp = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("eventSq") || _element.equals("eventSeqId"))
		{
			eventSeqId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_Chat::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clentOrdinal);
	_msg.composeUINT64(handId);
	_msg.composeINT16(eventCode);
	_msg.composeINT8(seat);
	_msg.composeINT8(action);
	_msg.composeUINT32(amount);
	_msg.composeString(user);
	_msg.composeString(content);
	_msg.composeINT32(amount2);
	_msg.composeMsgBody(msgClientExtra);
	_msg.composeUINT32(timestamp);
	_msg.composeUINT32(eventSeqId);
	_msg.composeUINT32(brandMask);
}

void TableClient::publication::TableSubscr_Chat::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clentOrdinal);
	_parser.parseUINT64(handId);
	_parser.parseINT16(eventCode);
	_parser.parseINT8(seat);
	_parser.parseINT8(action);
	_parser.parseUINT32(amount);
	_parser.parseStringP(user);
	_parser.parseStringP(content);
	_parser.parseINT32(amount2);
	_parser.parseMsgBody(msgClientExtra);
	_parser.parseUINT32(timestamp);
	_parser.parseUINT32(eventSeqId);
	_parser.parseUINT32(brandMask);
}

const char *TableClient::publication::TableSubscr_Chat::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clentOrdinal", clentOrdinal);
	_jsonstr.compose("hI", handId);
	_jsonstr.compose("eventCode", eventCode);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("a", action);
	_jsonstr.compose("v", amount);
	_jsonstr.compose("user", user);
	_jsonstr.compose("content", content);
	_jsonstr.compose("v2", amount2);
	_jsonstr.compose("msgClientExtra", msgClientExtra);
	_jsonstr.compose("timestamp", timestamp);
	_jsonstr.compose("eventSq", eventSeqId);
	_jsonstr.compose("brandMask", brandMask);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_Chat::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clentOrdinal", clentOrdinal);
	if(!_jparser.parseByName("hI", handId)) _jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("eventCode", eventCode);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	if(!_jparser.parseByName("a", action)) _jparser.parseByNameThrow("action", action);
	if(!_jparser.parseByName("v", amount)) _jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("user", user);
	_jparser.parseByNameThrow("content", content);
	if(!_jparser.parseByName("v2", amount2)) _jparser.parseByNameThrow("amount2", amount2);
	_jparser.parseByNameThrow("msgClientExtra", msgClientExtra);
	_jparser.parseByNameThrow("timestamp", timestamp);
	if(!_jparser.parseByName("eventSq", eventSeqId)) _jparser.parseByNameThrow("eventSeqId", eventSeqId);
	_jparser.parseByNameThrow("brandMask", brandMask);
}

/* static */ void TableClient::publication::TableSubscr_Chat::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clentOrdinal; _jparser.validateByNameThrow("clentOrdinal", clentOrdinal);
	AtfValidator::validateInt(_descr, "clentOrdinal", clentOrdinal, _checker, __FILE__, __LINE__);
	UINT64 handId; if(!_jparser.validateByName("hI", handId)) _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	INT16 eventCode; _jparser.validateByNameThrow("eventCode", eventCode);
	AtfValidator::validateInt(_descr, "eventCode", eventCode, _checker, __FILE__, __LINE__);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT8 action; if(!_jparser.validateByName("a", action)) _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT32 amount; if(!_jparser.validateByName("v", amount)) _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	PString user; _jparser.validateByNameThrow("user", user);
	AtfValidator::validateInt(_descr, "user", user.length(), _checker, __FILE__, __LINE__);
	PString content; _jparser.validateByNameThrow("content", content);
	AtfValidator::validateInt(_descr, "content", content.length(), _checker, __FILE__, __LINE__);
	INT32 amount2; if(!_jparser.validateByName("v2", amount2)) _jparser.validateByNameThrow("amount2", amount2);
	AtfValidator::validateInt(_descr, "amount2", amount2, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody msgClientExtra; _jparser.validateByNameThrow("msgClientExtra", msgClientExtra);
	AtfValidator::validateInt(_descr, "msgClientExtra", msgClientExtra._size(), _checker, __FILE__, __LINE__);
	UINT32 timestamp; _jparser.validateByNameThrow("timestamp", timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	UINT32 eventSeqId; if(!_jparser.validateByName("eventSq", eventSeqId)) _jparser.validateByNameThrow("eventSeqId", eventSeqId);
	AtfValidator::validateInt(_descr, "eventSeqId", eventSeqId, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_Chat::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 clentOrdinal; _parser.parseUINT32(clentOrdinal);
	AtfValidator::validateInt(_descr, "clentOrdinal", clentOrdinal, _checker, __FILE__, __LINE__);
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	INT16 eventCode; _parser.parseINT16(eventCode);
	AtfValidator::validateInt(_descr, "eventCode", eventCode, _checker, __FILE__, __LINE__);
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT8 action; _parser.parseINT8(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT32 amount; _parser.parseUINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateInt(_descr, "user", szUser, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "content"); size_t szContent = strlen(_dummy);
	AtfValidator::validateInt(_descr, "content", szContent, _checker, __FILE__, __LINE__);
	INT32 amount2; _parser.parseINT32(amount2);
	AtfValidator::validateInt(_descr, "amount2", amount2, _checker, __FILE__, __LINE__);
	size_t szMsgClientExtra; _parser.skipMsgBody(szMsgClientExtra);  /*msgClientExtra*/
	AtfValidator::validateInt(_descr, "msgClientExtra", szMsgClientExtra, _checker, __FILE__, __LINE__);
	UINT32 timestamp; _parser.parseUINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	UINT32 eventSeqId; _parser.parseUINT32(eventSeqId);
	AtfValidator::validateInt(_descr, "eventSeqId", eventSeqId, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSubscr_Static
//=================================================================

//=================================================================
//                _HappyHourInfoPublMsgType
//=================================================================

TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::_HappyHourInfoPublMsgType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::_HappyHourInfoPublMsgType(_HappyHourInfoPublMsgType&& _o)
	: fppFactors(std::move(_o.fppFactors))
	, fppFactorSiteMasks(std::move(_o.fppFactorSiteMasks))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType& TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::operator=(_HappyHourInfoPublMsgType&& _o)
{
	if(this != &_o)
	{
		fppFactors = std::move(_o.fppFactors);
		fppFactorSiteMasks = std::move(_o.fppFactorSiteMasks);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::clear()
{
	fppFactors.clear();
	fppFactorSiteMasks.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::equals(const _HappyHourInfoPublMsgType& _o) const
{
	return fppFactors.equals(_o.fppFactors) &&
		fppFactorSiteMasks.equals(_o.fppFactorSiteMasks);
}

const char *TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("fppFactors=");
		fppFactors.toTraceString(_buf);
		_buf.append(',');
		_buf.append("fppFactorSiteMasks=");
		fppFactorSiteMasks.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		fppFactors.toXmlString("fppFactors", _buf);
		fppFactorSiteMasks.toXmlString("fppFactorSiteMasks", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("fppFactors"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_FppFactor , 2 > >::FromXmlString(_value, fppFactors)) return false;
		}
		else if (_element.equals("fppFactorSiteMasks"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_FppFactorEx , 2 > >::FromXmlString(_value, fppFactorSiteMasks)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		fppFactors.composeMsg(_msg0, _ignoreJSON);
		fppFactorSiteMasks.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	fppFactors.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	fppFactorSiteMasks.parseMsg(_parser0);
}

const char *TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("fppFactors", fppFactors);
		_jsonstr.compose("fppFactorSiteMasks", fppFactorSiteMasks);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("fppFactors", fppFactors);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("fppFactorSiteMasks", fppFactorSiteMasks);
}

/* static */ void TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< TableCommon::P_FppFactor > fppFactors; _jparser.validateByNameThrow("fppFactors", fppFactors);
	AtfValidator::validateInt(_descr, "fppFactors", fppFactors.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< TableCommon::P_FppFactorEx > fppFactorSiteMasks; _jparser.validateByNameThrow("fppFactorSiteMasks", fppFactorSiteMasks);
	AtfValidator::validateInt(_descr, "fppFactorSiteMasks", fppFactorSiteMasks.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_Static::_HappyHourInfoPublMsgType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szFppFactors = Atf::LAtfVector< TableCommon::P_FppFactor , 2 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("fppFactors"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fppFactors", szFppFactors, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	int szFppFactorSiteMasks = Atf::LAtfVector< TableCommon::P_FppFactorEx , 2 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("fppFactorSiteMasks"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "fppFactorSiteMasks", szFppFactorSiteMasks, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

TableClient::publication::TableSubscr_Static::TableSubscr_Static()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TableSubscr_Static::TableSubscr_Static(TableSubscr_Static&& _o)
	: serverVersion(std::move(_o.serverVersion))
	, protocolVersion(std::move(_o.protocolVersion))
	, tableId32Obsolete(std::move(_o.tableId32Obsolete))
	, handType(std::move(_o.handType))
	, potStruct(std::move(_o.potStruct))
	, tournamentType(std::move(_o.tournamentType))
	, isHiLo(std::move(_o.isHiLo))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, isOneToOne(std::move(_o.isOneToOne))
	, numOfSeats(std::move(_o.numOfSeats))
	, tableName(std::move(_o.tableName))
	, nameSuffix(std::move(_o.nameSuffix))
	, multiGameType(std::move(_o.multiGameType))
	, multiGameTypeDesc(std::move(_o.multiGameTypeDesc))
	, stakeSmall(std::move(_o.stakeSmall))
	, stakeBig(std::move(_o.stakeBig))
	, chatLang(std::move(_o.chatLang))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, currency(std::move(_o.currency))
	, cap(std::move(_o.cap))
	, itSessionId(std::move(_o.itSessionId))
	, clubId(std::move(_o.clubId))
	, dealOptions(std::move(_o.dealOptions))
	, isShowCity(std::move(_o.isShowCity))
	, createdBy(std::move(_o.createdBy))
	, cancelledBy(std::move(_o.cancelledBy))
	, voiceObjectAddress(std::move(_o.voiceObjectAddress))
	, voiceObjectUdpAddress(std::move(_o.voiceObjectUdpAddress))
	, voiceObjectName(std::move(_o.voiceObjectName))
	, accessMask(std::move(_o.accessMask))
	, scalePM(std::move(_o.scalePM))
	, happyHourInfoPublMsg(std::move(_o.happyHourInfoPublMsg))
	, showObservFlags(std::move(_o.showObservFlags))
	, tableId(std::move(_o.tableId))
	, noVppGainSiteId(std::move(_o.noVppGainSiteId))
	, tableFlags2(std::move(_o.tableFlags2))
	, tableStakesObsolete(std::move(_o.tableStakesObsolete))
	, variableAntes(std::move(_o.variableAntes))
	, noVppGainSiteMask(std::move(_o.noVppGainSiteMask))
{
}

TableClient::publication::TableSubscr_Static& TableClient::publication::TableSubscr_Static::operator=(TableSubscr_Static&& _o)
{
	if(this != &_o)
	{
		serverVersion = std::move(_o.serverVersion);
		protocolVersion = std::move(_o.protocolVersion);
		tableId32Obsolete = std::move(_o.tableId32Obsolete);
		handType = std::move(_o.handType);
		potStruct = std::move(_o.potStruct);
		tournamentType = std::move(_o.tournamentType);
		isHiLo = std::move(_o.isHiLo);
		isPlayMoney = std::move(_o.isPlayMoney);
		isOneToOne = std::move(_o.isOneToOne);
		numOfSeats = std::move(_o.numOfSeats);
		tableName = std::move(_o.tableName);
		nameSuffix = std::move(_o.nameSuffix);
		multiGameType = std::move(_o.multiGameType);
		multiGameTypeDesc = std::move(_o.multiGameTypeDesc);
		stakeSmall = std::move(_o.stakeSmall);
		stakeBig = std::move(_o.stakeBig);
		chatLang = std::move(_o.chatLang);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		currency = std::move(_o.currency);
		cap = std::move(_o.cap);
		itSessionId = std::move(_o.itSessionId);
		clubId = std::move(_o.clubId);
		dealOptions = std::move(_o.dealOptions);
		isShowCity = std::move(_o.isShowCity);
		createdBy = std::move(_o.createdBy);
		cancelledBy = std::move(_o.cancelledBy);
		voiceObjectAddress = std::move(_o.voiceObjectAddress);
		voiceObjectUdpAddress = std::move(_o.voiceObjectUdpAddress);
		voiceObjectName = std::move(_o.voiceObjectName);
		accessMask = std::move(_o.accessMask);
		scalePM = std::move(_o.scalePM);
		happyHourInfoPublMsg = std::move(_o.happyHourInfoPublMsg);
		showObservFlags = std::move(_o.showObservFlags);
		tableId = std::move(_o.tableId);
		noVppGainSiteId = std::move(_o.noVppGainSiteId);
		tableFlags2 = std::move(_o.tableFlags2);
		tableStakesObsolete = std::move(_o.tableStakesObsolete);
		variableAntes = std::move(_o.variableAntes);
		noVppGainSiteMask = std::move(_o.noVppGainSiteMask);
	}
	return *this;
}

#endif

void TableClient::publication::TableSubscr_Static::clear()
{
	serverVersion.clear();
	protocolVersion = TABLE_PROTOCOL_VERSION;
	tableId32Obsolete = 0;
	handType = 0;
	potStruct = 0;
	tournamentType = 0;
	isHiLo = 0;
	isPlayMoney = 0;
	isOneToOne = 0;
	numOfSeats = 0;
	tableName.clear();
	nameSuffix.clear();
	multiGameType = 0;
	multiGameTypeDesc.clear();
	stakeSmall = 0;
	stakeBig = 0;
	chatLang = 0;
	minChipsLimit = 0;
	maxBuyIn = 0;
	currency.clear();
	cap = 0;
	itSessionId.clear();
	clubId = 0;
	dealOptions = 0;
	isShowCity = false;
	createdBy.clear();
	cancelledBy.clear();
	voiceObjectAddress.clear();
	voiceObjectUdpAddress.clear();
	voiceObjectName.clear();
	accessMask = 0;
	scalePM = 0;
	happyHourInfoPublMsg.clear();
	showObservFlags = 0;
	tableId = 0;
	noVppGainSiteId = 0;
	tableFlags2 = 0;
	tableStakesObsolete.clear();
	variableAntes.clear();
	noVppGainSiteMask.clear();
}

bool TableClient::publication::TableSubscr_Static::equals(const TableSubscr_Static& _o) const
{
	return Atf::atfPStringEquals(serverVersion, _o.serverVersion) &&
		Atf::atfPStringEquals(protocolVersion, _o.protocolVersion) &&
		tableId32Obsolete == _o.tableId32Obsolete &&
		handType == _o.handType &&
		potStruct == _o.potStruct &&
		tournamentType == _o.tournamentType &&
		isHiLo == _o.isHiLo &&
		isPlayMoney == _o.isPlayMoney &&
		isOneToOne == _o.isOneToOne &&
		numOfSeats == _o.numOfSeats &&
		Atf::atfPStringEquals(tableName, _o.tableName) &&
		Atf::atfPStringEquals(nameSuffix, _o.nameSuffix) &&
		multiGameType == _o.multiGameType &&
		Atf::atfPStringEquals(multiGameTypeDesc, _o.multiGameTypeDesc) &&
		stakeSmall == _o.stakeSmall &&
		stakeBig == _o.stakeBig &&
		chatLang == _o.chatLang &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		cap == _o.cap &&
		Atf::atfPStringEquals(itSessionId, _o.itSessionId) &&
		clubId == _o.clubId &&
		dealOptions == _o.dealOptions &&
		isShowCity == _o.isShowCity &&
		Atf::atfPStringEquals(createdBy, _o.createdBy) &&
		Atf::atfPStringEquals(cancelledBy, _o.cancelledBy) &&
		Atf::atfPStringEquals(voiceObjectAddress, _o.voiceObjectAddress) &&
		Atf::atfPStringEquals(voiceObjectUdpAddress, _o.voiceObjectUdpAddress) &&
		Atf::atfPStringEquals(voiceObjectName, _o.voiceObjectName) &&
		accessMask == _o.accessMask &&
		scalePM == _o.scalePM &&
		happyHourInfoPublMsg.equals(_o.happyHourInfoPublMsg) &&
		showObservFlags == _o.showObservFlags &&
		tableId == _o.tableId &&
		noVppGainSiteId == _o.noVppGainSiteId &&
		tableFlags2 == _o.tableFlags2 &&
		tableStakesObsolete.equals(_o.tableStakesObsolete) &&
		variableAntes.equals(_o.variableAntes) &&
		noVppGainSiteMask.equals(_o.noVppGainSiteMask);
}

const char *TableClient::publication::TableSubscr_Static::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("serverVersion=");
	_buf.append(serverVersion);
	_buf.append(',');
	_buf.append("protocolVersion=");
	_buf.append(protocolVersion);
	_buf.append(',');
	_buf.append("tableId32Obsolete=");
	_buf.appendUint(tableId32Obsolete);
	_buf.append(',');
	_buf.append("gm=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("lm=");
	_buf.appendUint(potStruct);
	_buf.append(',');
	_buf.append("tournamentType=");
	_buf.appendUint(tournamentType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("isOneToOne=");
	_buf.appendUint(isOneToOne);
	_buf.append(',');
	_buf.append("numOfSeats=");
	_buf.appendUint(numOfSeats);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("nameSuffix=");
	_buf.append(nameSuffix);
	_buf.append(',');
	_buf.append("multiGameType=");
	_buf.appendUint(multiGameType);
	_buf.append(',');
	_buf.append("multiGameTypeDesc=");
	_buf.append(multiGameTypeDesc);
	_buf.append(',');
	_buf.append("stakeSmall=");
	_buf.appendInt(stakeSmall);
	_buf.append(',');
	_buf.append("stakeBig=");
	_buf.appendInt(stakeBig);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendInt(minChipsLimit);
	_buf.append(',');
	_buf.append("mxBI=");
	_buf.appendInt(maxBuyIn);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendInt(cap);
	_buf.append(',');
	_buf.append("itSessionId=");
	_buf.append(itSessionId);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("dealOptions=");
	_buf.appendUint(dealOptions);
	_buf.append(',');
	_buf.append("isShowCity=");
	_buf.appendUint(isShowCity);
	_buf.append(',');
	_buf.append("createdBy=");
	_buf.append(createdBy);
	_buf.append(',');
	_buf.append("cancelledBy=");
	_buf.append(cancelledBy);
	_buf.append(',');
	_buf.append("voiceObjectAddress=");
	_buf.append(voiceObjectAddress);
	_buf.append(',');
	_buf.append("voiceObjectUdpAddress=");
	_buf.append(voiceObjectUdpAddress);
	_buf.append(',');
	_buf.append("voiceObjectName=");
	_buf.append(voiceObjectName);
	_buf.append(',');
	_buf.append("accessMask=");
	_buf.appendUint(accessMask);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("happyHourInfoPublMsg=");
	happyHourInfoPublMsg.toTraceString(_buf);
	_buf.append(',');
	_buf.append("showObservFlags=");
	_buf.appendUint(showObservFlags);
	_buf.append(',');
	_buf.append("tI=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("noVppGainSiteId=");
	_buf.appendUint(noVppGainSiteId);
	_buf.append(',');
	_buf.append("tableFlags2=");
	_buf.appendUint64(tableFlags2);
	_buf.append(',');
	_buf.append("tableStakesObsolete=");
	tableStakesObsolete.toTraceString(_buf);
	_buf.append(',');
	_buf.append("variableAntes=");
	variableAntes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("noVppGainSiteMask=");
	noVppGainSiteMask.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_Static::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("serverVersion", serverVersion, _buf);
	Atf::XmlElement::encodeAsXmlElement("protocolVersion", protocolVersion, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId32Obsolete", tableId32Obsolete, _buf);
	Atf::XmlElement::encodeAsXmlElement("gm", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("lm", potStruct, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournamentType", tournamentType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOneToOne", isOneToOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("numOfSeats", numOfSeats, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableName", tableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("nameSuffix", nameSuffix, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiGameType", multiGameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiGameTypeDesc", multiGameTypeDesc, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeSmall", stakeSmall, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeBig", stakeBig, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("minChipsLimit", minChipsLimit, _buf);
	Atf::XmlElement::encodeAsXmlElement("mxBI", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("itSessionId", itSessionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("dealOptions", dealOptions, _buf);
	Atf::XmlElement::encodeAsXmlElement("isShowCity", isShowCity, _buf);
	Atf::XmlElement::encodeAsXmlElement("createdBy", createdBy, _buf);
	Atf::XmlElement::encodeAsXmlElement("cancelledBy", cancelledBy, _buf);
	Atf::XmlElement::encodeAsXmlElement("voiceObjectAddress", voiceObjectAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("voiceObjectUdpAddress", voiceObjectUdpAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("voiceObjectName", voiceObjectName, _buf);
	Atf::XmlElement::encodeAsXmlElement("accessMask", accessMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	happyHourInfoPublMsg.toXmlString("happyHourInfoPublMsg", _buf);
	Atf::XmlElement::encodeAsXmlElement("showObservFlags", showObservFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("tI", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("noVppGainSiteId", noVppGainSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags2", tableFlags2, _buf);
	tableStakesObsolete.toXmlString("tableStakesObsolete", _buf);
	variableAntes.toXmlString("variableAntes", _buf);
	noVppGainSiteMask.toXmlString("noVppGainSiteMask", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_Static::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("serverVersion"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverVersion)) return false;
		}
		else if (_element.equals("protocolVersion"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, protocolVersion)) return false;
		}
		else if (_element.equals("tableId32Obsolete"))
		{
			tableId32Obsolete = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gm") || _element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lm") || _element.equals("potStruct"))
		{
			potStruct = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournamentType"))
		{
			tournamentType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isOneToOne"))
		{
			isOneToOne = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numOfSeats"))
		{
			numOfSeats = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableName)) return false;
		}
		else if (_element.equals("nameSuffix"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, nameSuffix)) return false;
		}
		else if (_element.equals("multiGameType"))
		{
			multiGameType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("multiGameTypeDesc"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, multiGameTypeDesc)) return false;
		}
		else if (_element.equals("stakeSmall"))
		{
			stakeSmall = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeBig"))
		{
			stakeBig = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chatLang"))
		{
			chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minChipsLimit"))
		{
			minChipsLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mxBI") || _element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("cap"))
		{
			cap = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("itSessionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, itSessionId)) return false;
		}
		else if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dealOptions"))
		{
			dealOptions = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isShowCity"))
		{
			isShowCity = (*_value.ptr() == '1');
		}
		else if (_element.equals("createdBy"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, createdBy)) return false;
		}
		else if (_element.equals("cancelledBy"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cancelledBy)) return false;
		}
		else if (_element.equals("voiceObjectAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, voiceObjectAddress)) return false;
		}
		else if (_element.equals("voiceObjectUdpAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, voiceObjectUdpAddress)) return false;
		}
		else if (_element.equals("voiceObjectName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, voiceObjectName)) return false;
		}
		else if (_element.equals("accessMask"))
		{
			accessMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("happyHourInfoPublMsg"))
		{
			if(!Atf::AtfTempl< _HappyHourInfoPublMsgType >::FromXmlString(_value, happyHourInfoPublMsg)) return false;
		}
		else if (_element.equals("showObservFlags"))
		{
			showObservFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tI") || _element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("noVppGainSiteId"))
		{
			noVppGainSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableFlags2"))
		{
			tableFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakesObsolete"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakesObsolete)) return false;
		}
		else if (_element.equals("variableAntes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, variableAntes)) return false;
		}
		else if (_element.equals("noVppGainSiteMask"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, noVppGainSiteMask)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_Static::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(serverVersion);
	_msg.composeString(protocolVersion);
	_msg.composeUINT32(tableId32Obsolete);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(potStruct);
	_msg.composeBYTE(tournamentType);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeBYTE(isOneToOne);
	_msg.composeBYTE(numOfSeats);
	_msg.composeString(tableName);
	_msg.composeString(nameSuffix);
	_msg.composeBYTE(multiGameType);
	_msg.composeString(multiGameTypeDesc);
	_msg.composeINT32(stakeSmall);
	_msg.composeINT32(stakeBig);
	_msg.composeUINT16(chatLang);
	_msg.composeINT32(minChipsLimit);
	_msg.composeINT32(maxBuyIn);
	_msg.composeString(currency);
	_msg.composeINT32(cap);
	_msg.composeString(itSessionId);
	_msg.composeUINT32(clubId);
	_msg.composeBYTE(dealOptions);
	_msg.composeBOOL(isShowCity);
	_msg.composeString(createdBy);
	_msg.composeString(cancelledBy);
	_msg.composeString(voiceObjectAddress);
	_msg.composeString(voiceObjectUdpAddress);
	_msg.composeString(voiceObjectName);
	_msg.composeUINT32(accessMask);
	_msg.composeUINT32(scalePM);
	happyHourInfoPublMsg.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(showObservFlags);
	_msg.composeUINT64(tableId);
	_msg.composeUINT32(noVppGainSiteId);
	_msg.composeUINT64(tableFlags2);
	tableStakesObsolete.composeMsg(_msg, _ignoreJSON);
	variableAntes.composeMsg(_msg, _ignoreJSON);
	noVppGainSiteMask.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::TableSubscr_Static::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverVersion);
	_parser.parseStringP(protocolVersion);
	_parser.parseUINT32(tableId32Obsolete);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(potStruct);
	_parser.parseBYTE(tournamentType);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseBYTE(isOneToOne);
	_parser.parseBYTE(numOfSeats);
	_parser.parseStringP(tableName);
	_parser.parseStringP(nameSuffix);
	_parser.parseBYTE(multiGameType);
	_parser.parseStringP(multiGameTypeDesc);
	_parser.parseINT32(stakeSmall);
	_parser.parseINT32(stakeBig);
	_parser.parseUINT16(chatLang);
	_parser.parseINT32(minChipsLimit);
	_parser.parseINT32(maxBuyIn);
	_parser.parseStringP(currency);
	_parser.parseINT32(cap);
	_parser.parseStringP(itSessionId);
	_parser.parseUINT32(clubId);
	_parser.parseBYTE(dealOptions);
	_parser.parseBOOL(isShowCity);
	_parser.parseStringP(createdBy);
	_parser.parseStringP(cancelledBy);
	_parser.parseStringP(voiceObjectAddress);
	_parser.parseStringP(voiceObjectUdpAddress);
	_parser.parseStringP(voiceObjectName);
	_parser.parseUINT32(accessMask);
	_parser.parseUINT32(scalePM);
	happyHourInfoPublMsg.parseMsg(_parser);
	_parser.parseUINT32(showObservFlags);
	_parser.parseUINT64(tableId);
	_parser.parseUINT32(noVppGainSiteId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableFlags2);
	if(_parser.parseEnded()) return;
	tableStakesObsolete.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	variableAntes.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	noVppGainSiteMask.parseMsg(_parser);
}

const char *TableClient::publication::TableSubscr_Static::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("serverVersion", serverVersion);
	_jsonstr.compose("protocolVersion", protocolVersion);
	_jsonstr.compose("tableId32Obsolete", tableId32Obsolete);
	_jsonstr.compose("gm", handType);
	_jsonstr.compose("lm", potStruct);
	_jsonstr.compose("tournamentType", tournamentType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("isOneToOne", isOneToOne);
	_jsonstr.compose("numOfSeats", numOfSeats);
	_jsonstr.compose("tableName", tableName);
	_jsonstr.compose("nameSuffix", nameSuffix);
	_jsonstr.compose("multiGameType", multiGameType);
	_jsonstr.compose("multiGameTypeDesc", multiGameTypeDesc);
	_jsonstr.compose("stakeSmall", stakeSmall);
	_jsonstr.compose("stakeBig", stakeBig);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("minChipsLimit", minChipsLimit);
	_jsonstr.compose("mxBI", maxBuyIn);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("itSessionId", itSessionId);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("dealOptions", dealOptions);
	_jsonstr.compose("isShowCity", isShowCity);
	_jsonstr.compose("createdBy", createdBy);
	_jsonstr.compose("cancelledBy", cancelledBy);
	_jsonstr.compose("voiceObjectAddress", voiceObjectAddress);
	_jsonstr.compose("voiceObjectUdpAddress", voiceObjectUdpAddress);
	_jsonstr.compose("voiceObjectName", voiceObjectName);
	_jsonstr.compose("accessMask", accessMask);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("happyHourInfoPublMsg", happyHourInfoPublMsg);
	_jsonstr.compose("showObservFlags", showObservFlags);
	_jsonstr.compose("tI", tableId);
	_jsonstr.compose("noVppGainSiteId", noVppGainSiteId);
	_jsonstr.compose("tableFlags2", tableFlags2);
	_jsonstr.compose("tableStakesObsolete", tableStakesObsolete);
	_jsonstr.compose("variableAntes", variableAntes);
	_jsonstr.compose("noVppGainSiteMask", noVppGainSiteMask);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_Static::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("serverVersion", serverVersion);
	_jparser.parseByNameThrow("protocolVersion", protocolVersion);
	_jparser.parseByNameThrow("tableId32Obsolete", tableId32Obsolete);
	if(!_jparser.parseByName("gm", handType)) _jparser.parseByNameThrow("handType", handType);
	if(!_jparser.parseByName("lm", potStruct)) _jparser.parseByNameThrow("potStruct", potStruct);
	_jparser.parseByNameThrow("tournamentType", tournamentType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("isOneToOne", isOneToOne);
	_jparser.parseByNameThrow("numOfSeats", numOfSeats);
	_jparser.parseByNameThrow("tableName", tableName);
	_jparser.parseByNameThrow("nameSuffix", nameSuffix);
	_jparser.parseByNameThrow("multiGameType", multiGameType);
	_jparser.parseByNameThrow("multiGameTypeDesc", multiGameTypeDesc);
	_jparser.parseByNameThrow("stakeSmall", stakeSmall);
	_jparser.parseByNameThrow("stakeBig", stakeBig);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("minChipsLimit", minChipsLimit);
	if(!_jparser.parseByName("mxBI", maxBuyIn)) _jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("itSessionId", itSessionId);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("dealOptions", dealOptions);
	_jparser.parseByNameThrow("isShowCity", isShowCity);
	_jparser.parseByNameThrow("createdBy", createdBy);
	_jparser.parseByNameThrow("cancelledBy", cancelledBy);
	_jparser.parseByNameThrow("voiceObjectAddress", voiceObjectAddress);
	_jparser.parseByNameThrow("voiceObjectUdpAddress", voiceObjectUdpAddress);
	_jparser.parseByNameThrow("voiceObjectName", voiceObjectName);
	_jparser.parseByNameThrow("accessMask", accessMask);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("happyHourInfoPublMsg", happyHourInfoPublMsg);
	_jparser.parseByNameThrow("showObservFlags", showObservFlags);
	if(!_jparser.parseByName("tI", tableId)) _jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("noVppGainSiteId", noVppGainSiteId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableFlags2", tableFlags2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableStakesObsolete", tableStakesObsolete);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAntes", variableAntes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("noVppGainSiteMask", noVppGainSiteMask);
}

/* static */ void TableClient::publication::TableSubscr_Static::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString serverVersion; _jparser.validateByNameThrow("serverVersion", serverVersion);
	AtfValidator::validateInt(_descr, "serverVersion", serverVersion.length(), _checker, __FILE__, __LINE__);
	PString protocolVersion; _jparser.validateByNameThrow("protocolVersion", protocolVersion);
	AtfValidator::validateInt(_descr, "protocolVersion", protocolVersion.length(), _checker, __FILE__, __LINE__);
	UINT32 tableId32Obsolete; _jparser.validateByNameThrow("tableId32Obsolete", tableId32Obsolete);
	AtfValidator::validateInt(_descr, "tableId32Obsolete", tableId32Obsolete, _checker, __FILE__, __LINE__);
	BYTE handType; if(!_jparser.validateByName("gm", handType)) _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE potStruct; if(!_jparser.validateByName("lm", potStruct)) _jparser.validateByNameThrow("potStruct", potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
	BYTE tournamentType; _jparser.validateByNameThrow("tournamentType", tournamentType);
	AtfValidator::validateInt(_descr, "tournamentType", tournamentType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE isOneToOne; _jparser.validateByNameThrow("isOneToOne", isOneToOne);
	AtfValidator::validateInt(_descr, "isOneToOne", isOneToOne, _checker, __FILE__, __LINE__);
	BYTE numOfSeats; _jparser.validateByNameThrow("numOfSeats", numOfSeats);
	AtfValidator::validateInt(_descr, "numOfSeats", numOfSeats, _checker, __FILE__, __LINE__);
	PString tableName; _jparser.validateByNameThrow("tableName", tableName);
	AtfValidator::validateInt(_descr, "tableName", tableName.length(), _checker, __FILE__, __LINE__);
	PString nameSuffix; _jparser.validateByNameThrow("nameSuffix", nameSuffix);
	AtfValidator::validateInt(_descr, "nameSuffix", nameSuffix.length(), _checker, __FILE__, __LINE__);
	BYTE multiGameType; _jparser.validateByNameThrow("multiGameType", multiGameType);
	AtfValidator::validateInt(_descr, "multiGameType", multiGameType, _checker, __FILE__, __LINE__);
	PString multiGameTypeDesc; _jparser.validateByNameThrow("multiGameTypeDesc", multiGameTypeDesc);
	AtfValidator::validateInt(_descr, "multiGameTypeDesc", multiGameTypeDesc.length(), _checker, __FILE__, __LINE__);
	INT32 stakeSmall; _jparser.validateByNameThrow("stakeSmall", stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	INT32 stakeBig; _jparser.validateByNameThrow("stakeBig", stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _jparser.validateByNameThrow("minChipsLimit", minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; if(!_jparser.validateByName("mxBI", maxBuyIn)) _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	PString itSessionId; _jparser.validateByNameThrow("itSessionId", itSessionId);
	AtfValidator::validateInt(_descr, "itSessionId", itSessionId.length(), _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE dealOptions; _jparser.validateByNameThrow("dealOptions", dealOptions);
	AtfValidator::validateInt(_descr, "dealOptions", dealOptions, _checker, __FILE__, __LINE__);
	bool isShowCity; _jparser.validateByNameThrow("isShowCity", isShowCity);
	AtfValidator::validateInt(_descr, "isShowCity", isShowCity, _checker, __FILE__, __LINE__);
	PString createdBy; _jparser.validateByNameThrow("createdBy", createdBy);
	AtfValidator::validateInt(_descr, "createdBy", createdBy.length(), _checker, __FILE__, __LINE__);
	PString cancelledBy; _jparser.validateByNameThrow("cancelledBy", cancelledBy);
	AtfValidator::validateInt(_descr, "cancelledBy", cancelledBy.length(), _checker, __FILE__, __LINE__);
	PString voiceObjectAddress; _jparser.validateByNameThrow("voiceObjectAddress", voiceObjectAddress);
	AtfValidator::validateInt(_descr, "voiceObjectAddress", voiceObjectAddress.length(), _checker, __FILE__, __LINE__);
	PString voiceObjectUdpAddress; _jparser.validateByNameThrow("voiceObjectUdpAddress", voiceObjectUdpAddress);
	AtfValidator::validateInt(_descr, "voiceObjectUdpAddress", voiceObjectUdpAddress.length(), _checker, __FILE__, __LINE__);
	PString voiceObjectName; _jparser.validateByNameThrow("voiceObjectName", voiceObjectName);
	AtfValidator::validateInt(_descr, "voiceObjectName", voiceObjectName.length(), _checker, __FILE__, __LINE__);
	UINT32 accessMask; _jparser.validateByNameThrow("accessMask", accessMask);
	AtfValidator::validateInt(_descr, "accessMask", accessMask, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	_HappyHourInfoPublMsgType happyHourInfoPublMsg; _jparser.validateByNameThrow("happyHourInfoPublMsg", happyHourInfoPublMsg);
	UINT32 showObservFlags; _jparser.validateByNameThrow("showObservFlags", showObservFlags);
	AtfValidator::validateInt(_descr, "showObservFlags", showObservFlags, _checker, __FILE__, __LINE__);
	UINT64 tableId; if(!_jparser.validateByName("tI", tableId)) _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 noVppGainSiteId; _jparser.validateByNameThrow("noVppGainSiteId", noVppGainSiteId);
	AtfValidator::validateInt(_descr, "noVppGainSiteId", noVppGainSiteId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableFlags2; _jparser.validateByNameThrow("tableFlags2", tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	TableCommon::TableStakes tableStakesObsolete; _jparser.validateByNameThrow("tableStakesObsolete", tableStakesObsolete);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< INT64 > variableAntes; _jparser.validateByNameThrow("variableAntes", variableAntes);
	AtfValidator::validateInt(_descr, "variableAntes", variableAntes.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask noVppGainSiteMask; _jparser.validateByNameThrow("noVppGainSiteMask", noVppGainSiteMask);
}

/*static*/ void TableClient::publication::TableSubscr_Static::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverVersion"); size_t szServerVersion = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverVersion", szServerVersion, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "protocolVersion"); size_t szProtocolVersion = strlen(_dummy);
	AtfValidator::validateInt(_descr, "protocolVersion", szProtocolVersion, _checker, __FILE__, __LINE__);
	UINT32 tableId32Obsolete; _parser.parseUINT32(tableId32Obsolete);
	AtfValidator::validateInt(_descr, "tableId32Obsolete", tableId32Obsolete, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateInt(_descr, "potStruct", potStruct, _checker, __FILE__, __LINE__);
	BYTE tournamentType; _parser.parseBYTE(tournamentType);
	AtfValidator::validateInt(_descr, "tournamentType", tournamentType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE isOneToOne; _parser.parseBYTE(isOneToOne);
	AtfValidator::validateInt(_descr, "isOneToOne", isOneToOne, _checker, __FILE__, __LINE__);
	BYTE numOfSeats; _parser.parseBYTE(numOfSeats);
	AtfValidator::validateInt(_descr, "numOfSeats", numOfSeats, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableName", szTableName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "nameSuffix"); size_t szNameSuffix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "nameSuffix", szNameSuffix, _checker, __FILE__, __LINE__);
	BYTE multiGameType; _parser.parseBYTE(multiGameType);
	AtfValidator::validateInt(_descr, "multiGameType", multiGameType, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "multiGameTypeDesc"); size_t szMultiGameTypeDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "multiGameTypeDesc", szMultiGameTypeDesc, _checker, __FILE__, __LINE__);
	INT32 stakeSmall; _parser.parseINT32(stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	INT32 stakeBig; _parser.parseINT32(stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	INT32 minChipsLimit; _parser.parseINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	INT32 maxBuyIn; _parser.parseINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 cap; _parser.parseINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "itSessionId"); size_t szItSessionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "itSessionId", szItSessionId, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE dealOptions; _parser.parseBYTE(dealOptions);
	AtfValidator::validateInt(_descr, "dealOptions", dealOptions, _checker, __FILE__, __LINE__);
	bool isShowCity; _parser.parseBOOL(isShowCity);
	AtfValidator::validateInt(_descr, "isShowCity", isShowCity, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "createdBy"); size_t szCreatedBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "createdBy", szCreatedBy, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cancelledBy"); size_t szCancelledBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cancelledBy", szCancelledBy, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "voiceObjectAddress"); size_t szVoiceObjectAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "voiceObjectAddress", szVoiceObjectAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "voiceObjectUdpAddress"); size_t szVoiceObjectUdpAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "voiceObjectUdpAddress", szVoiceObjectUdpAddress, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "voiceObjectName"); size_t szVoiceObjectName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "voiceObjectName", szVoiceObjectName, _checker, __FILE__, __LINE__);
	UINT32 accessMask; _parser.parseUINT32(accessMask);
	AtfValidator::validateInt(_descr, "accessMask", accessMask, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	PString _descbuf;
	_HappyHourInfoPublMsgType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("happyHourInfoPublMsg"), _fieldsWithUnparsedContent);
	UINT32 showObservFlags; _parser.parseUINT32(showObservFlags);
	AtfValidator::validateInt(_descr, "showObservFlags", showObservFlags, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 noVppGainSiteId; _parser.parseUINT32(noVppGainSiteId);
	AtfValidator::validateInt(_descr, "noVppGainSiteId", noVppGainSiteId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableFlags2; _parser.parseUINT64(tableFlags2);
	AtfValidator::validateUint(_descr, "tableFlags2", tableFlags2, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakesObsolete"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	int szVariableAntes = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("variableAntes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "variableAntes", szVariableAntes, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("noVppGainSiteMask"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TableSubscr_Hand
//=================================================================

TableClient::publication::TableSubscr_Hand::TableSubscr_Hand()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TableSubscr_Hand::TableSubscr_Hand(TableSubscr_Hand&& _o)
	: handId(std::move(_o.handId))
	, stakeSmall(std::move(_o.stakeSmall))
	, stakeBig(std::move(_o.stakeBig))
	, dealer(std::move(_o.dealer))
	, lastHandId(std::move(_o.lastHandId))
	, adminMsg(std::move(_o.adminMsg))
	, round(std::move(_o.round))
	, ante(std::move(_o.ante))
	, tableFlags(std::move(_o.tableFlags))
	, multiGameHands(std::move(_o.multiGameHands))
	, clientMsgStrId(std::move(_o.clientMsgStrId))
	, advertiseI18n(std::move(_o.advertiseI18n))
	, milestoneHandId(std::move(_o.milestoneHandId))
	, superstarShowdownResults(std::move(_o.superstarShowdownResults))
	, banner(std::move(_o.banner))
	, tournMileStoneWinMsg(std::move(_o.tournMileStoneWinMsg))
	, variableAnteIndex(std::move(_o.variableAnteIndex))
	, tableStakes(std::move(_o.tableStakes))
{
}

TableClient::publication::TableSubscr_Hand& TableClient::publication::TableSubscr_Hand::operator=(TableSubscr_Hand&& _o)
{
	if(this != &_o)
	{
		handId = std::move(_o.handId);
		stakeSmall = std::move(_o.stakeSmall);
		stakeBig = std::move(_o.stakeBig);
		dealer = std::move(_o.dealer);
		lastHandId = std::move(_o.lastHandId);
		adminMsg = std::move(_o.adminMsg);
		round = std::move(_o.round);
		ante = std::move(_o.ante);
		tableFlags = std::move(_o.tableFlags);
		multiGameHands = std::move(_o.multiGameHands);
		clientMsgStrId = std::move(_o.clientMsgStrId);
		advertiseI18n = std::move(_o.advertiseI18n);
		milestoneHandId = std::move(_o.milestoneHandId);
		superstarShowdownResults = std::move(_o.superstarShowdownResults);
		banner = std::move(_o.banner);
		tournMileStoneWinMsg = std::move(_o.tournMileStoneWinMsg);
		variableAnteIndex = std::move(_o.variableAnteIndex);
		tableStakes = std::move(_o.tableStakes);
	}
	return *this;
}

#endif

void TableClient::publication::TableSubscr_Hand::clear()
{
	handId = 0;
	stakeSmall = 0;
	stakeBig = 0;
	dealer = -1;
	lastHandId = 0;
	adminMsg.clear();
	round = -128;
	ante = 0;
	tableFlags = 0;
	multiGameHands = 0;
	clientMsgStrId = 0;
	advertiseI18n.clear();
	milestoneHandId = 0;
	superstarShowdownResults.clear();
	banner = -1;
	tournMileStoneWinMsg.clear();
	variableAnteIndex = -1;
	tableStakes.clear();
}

bool TableClient::publication::TableSubscr_Hand::equals(const TableSubscr_Hand& _o) const
{
	return handId == _o.handId &&
		stakeSmall == _o.stakeSmall &&
		stakeBig == _o.stakeBig &&
		dealer == _o.dealer &&
		lastHandId == _o.lastHandId &&
		Atf::atfPStringEquals(adminMsg, _o.adminMsg) &&
		round == _o.round &&
		ante == _o.ante &&
		tableFlags == _o.tableFlags &&
		multiGameHands == _o.multiGameHands &&
		clientMsgStrId == _o.clientMsgStrId &&
		advertiseI18n.equals(_o.advertiseI18n) &&
		milestoneHandId == _o.milestoneHandId &&
		Atf::atfPStringEquals(superstarShowdownResults, _o.superstarShowdownResults) &&
		banner == _o.banner &&
		tournMileStoneWinMsg.equals(_o.tournMileStoneWinMsg) &&
		variableAnteIndex == _o.variableAnteIndex &&
		tableStakes.equals(_o.tableStakes);
}

const char *TableClient::publication::TableSubscr_Hand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("hI=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("stakeSmall=");
	_buf.appendUint(stakeSmall);
	_buf.append(',');
	_buf.append("stakeBig=");
	_buf.appendUint(stakeBig);
	_buf.append(',');
	_buf.append("dealer=");
	_buf.appendInt(dealer);
	_buf.append(',');
	_buf.append("lastHI=");
	_buf.appendUint64(lastHandId);
	_buf.append(',');
	_buf.append("adminMsg=");
	_buf.append(adminMsg);
	_buf.append(',');
	_buf.append("round=");
	_buf.appendInt(round);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("multiGameHands=");
	_buf.appendInt(multiGameHands);
	_buf.append(',');
	_buf.append("clientMsgStrId=");
	_buf.appendUint(clientMsgStrId);
	_buf.append(',');
	_buf.append("advertiseI18n=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, advertiseI18n);
	_buf.append(',');
	_buf.append("milestoneHI=");
	_buf.appendUint64(milestoneHandId);
	_buf.append(',');
	_buf.append("superstarShowdownResults=");
	_buf.append(superstarShowdownResults);
	_buf.append(',');
	_buf.append("banner=");
	_buf.appendInt(banner);
	_buf.append(',');
	_buf.append("tournMileStoneWinMsg=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(tournMileStoneWinMsg, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("variableAnteIndex=");
	_buf.appendInt(variableAnteIndex);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_Hand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("hI", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeSmall", stakeSmall, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakeBig", stakeBig, _buf);
	Atf::XmlElement::encodeAsXmlElement("dealer", dealer, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastHI", lastHandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("adminMsg", adminMsg, _buf);
	Atf::XmlElement::encodeAsXmlElement("round", round, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableFlags", tableFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiGameHands", multiGameHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientMsgStrId", clientMsgStrId, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "advertiseI18n", advertiseI18n);
	Atf::XmlElement::encodeAsXmlElement("milestoneHI", milestoneHandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("superstarShowdownResults", superstarShowdownResults, _buf);
	Atf::XmlElement::encodeAsXmlElement("banner", banner, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMileStoneWinMsg", tournMileStoneWinMsg, _buf);
	Atf::XmlElement::encodeAsXmlElement("variableAnteIndex", variableAnteIndex, _buf);
	tableStakes.toXmlString("tableStakes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_Hand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("hI") || _element.equals("handId"))
		{
			handId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeSmall"))
		{
			stakeSmall = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakeBig"))
		{
			stakeBig = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dealer"))
		{
			dealer = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastHI") || _element.equals("lastHandId"))
		{
			lastHandId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("adminMsg"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, adminMsg)) return false;
		}
		else if (_element.equals("round"))
		{
			round = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableFlags"))
		{
			tableFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("multiGameHands"))
		{
			multiGameHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientMsgStrId"))
		{
			clientMsgStrId = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("advertiseI18n"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, advertiseI18n);
		}
		else if (_element.equals("milestoneHI") || _element.equals("milestoneHandId"))
		{
			milestoneHandId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("superstarShowdownResults"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, superstarShowdownResults)) return false;
		}
		else if (_element.equals("banner"))
		{
			banner = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMileStoneWinMsg"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, tournMileStoneWinMsg)) return false;
		}
		else if (_element.equals("variableAnteIndex"))
		{
			variableAnteIndex = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableStakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, tableStakes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_Hand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
	_msg.composeUINT32(stakeSmall);
	_msg.composeUINT32(stakeBig);
	_msg.composeINT8(dealer);
	_msg.composeUINT64(lastHandId);
	_msg.composeString(adminMsg);
	_msg.composeINT8(round);
	_msg.composeUINT32(ante);
	_msg.composeUINT32(tableFlags);
	_msg.composeINT32(multiGameHands);
	_msg.composeUINT16(clientMsgStrId);
	advertiseI18n.compose(_msg);
	_msg.composeUINT64(milestoneHandId);
	_msg.composeString(superstarShowdownResults);
	_msg.composeINT32(banner);
	_msg.composeMsgBody(tournMileStoneWinMsg);
	_msg.composeINT8(variableAnteIndex);
	tableStakes.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::TableSubscr_Hand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	_parser.parseUINT32(stakeSmall);
	_parser.parseUINT32(stakeBig);
	_parser.parseINT8(dealer);
	_parser.parseUINT64(lastHandId);
	_parser.parseStringP(adminMsg);
	_parser.parseINT8(round);
	_parser.parseUINT32(ante);
	_parser.parseUINT32(tableFlags);
	_parser.parseINT32(multiGameHands);
	_parser.parseUINT16(clientMsgStrId);
	advertiseI18n.parse(_parser);
	_parser.parseUINT64(milestoneHandId);
	_parser.parseStringP(superstarShowdownResults);
	_parser.parseINT32(banner);
	_parser.parseMsgBody(tournMileStoneWinMsg);
	if(_parser.parseEnded()) return;
	_parser.parseINT8(variableAnteIndex);
	tableStakes.parseMsg(_parser);
}

const char *TableClient::publication::TableSubscr_Hand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("hI", handId);
	_jsonstr.compose("stakeSmall", stakeSmall);
	_jsonstr.compose("stakeBig", stakeBig);
	_jsonstr.compose("dealer", dealer);
	_jsonstr.compose("lastHI", lastHandId);
	_jsonstr.compose("adminMsg", adminMsg);
	_jsonstr.compose("round", round);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("tableFlags", tableFlags);
	_jsonstr.compose("multiGameHands", multiGameHands);
	_jsonstr.compose("clientMsgStrId", clientMsgStrId);
	_jsonstr.compose("advertiseI18n", advertiseI18n);
	_jsonstr.compose("milestoneHI", milestoneHandId);
	_jsonstr.compose("superstarShowdownResults", superstarShowdownResults);
	_jsonstr.compose("banner", banner);
	_jsonstr.compose("tournMileStoneWinMsg", tournMileStoneWinMsg);
	_jsonstr.compose("variableAnteIndex", variableAnteIndex);
	_jsonstr.compose("tableStakes", tableStakes);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_Hand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("hI", handId)) _jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("stakeSmall", stakeSmall);
	_jparser.parseByNameThrow("stakeBig", stakeBig);
	_jparser.parseByNameThrow("dealer", dealer);
	if(!_jparser.parseByName("lastHI", lastHandId)) _jparser.parseByNameThrow("lastHandId", lastHandId);
	_jparser.parseByNameThrow("adminMsg", adminMsg);
	_jparser.parseByNameThrow("round", round);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("tableFlags", tableFlags);
	_jparser.parseByNameThrow("multiGameHands", multiGameHands);
	_jparser.parseByNameThrow("clientMsgStrId", clientMsgStrId);
	_jparser.parseByNameThrow("advertiseI18n", advertiseI18n);
	if(!_jparser.parseByName("milestoneHI", milestoneHandId)) _jparser.parseByNameThrow("milestoneHandId", milestoneHandId);
	_jparser.parseByNameThrow("superstarShowdownResults", superstarShowdownResults);
	_jparser.parseByNameThrow("banner", banner);
	_jparser.parseByNameThrow("tournMileStoneWinMsg", tournMileStoneWinMsg);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("variableAnteIndex", variableAnteIndex);
	_jparser.parseByNameThrow("tableStakes", tableStakes);
}

/* static */ void TableClient::publication::TableSubscr_Hand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; if(!_jparser.validateByName("hI", handId)) _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 stakeSmall; _jparser.validateByNameThrow("stakeSmall", stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _jparser.validateByNameThrow("stakeBig", stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	INT8 dealer; _jparser.validateByNameThrow("dealer", dealer);
	AtfValidator::validateInt(_descr, "dealer", dealer, _checker, __FILE__, __LINE__);
	UINT64 lastHandId; if(!_jparser.validateByName("lastHI", lastHandId)) _jparser.validateByNameThrow("lastHandId", lastHandId);
	AtfValidator::validateUint(_descr, "lastHandId", lastHandId, _checker, __FILE__, __LINE__);
	PString adminMsg; _jparser.validateByNameThrow("adminMsg", adminMsg);
	AtfValidator::validateInt(_descr, "adminMsg", adminMsg.length(), _checker, __FILE__, __LINE__);
	INT8 round; _jparser.validateByNameThrow("round", round);
	AtfValidator::validateInt(_descr, "round", round, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _jparser.validateByNameThrow("tableFlags", tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	INT32 multiGameHands; _jparser.validateByNameThrow("multiGameHands", multiGameHands);
	AtfValidator::validateInt(_descr, "multiGameHands", multiGameHands, _checker, __FILE__, __LINE__);
	UINT16 clientMsgStrId; _jparser.validateByNameThrow("clientMsgStrId", clientMsgStrId);
	AtfValidator::validateInt(_descr, "clientMsgStrId", clientMsgStrId, _checker, __FILE__, __LINE__);
	I18nPString advertiseI18n; _jparser.validateByNameThrow("advertiseI18n", advertiseI18n);
	UINT64 milestoneHandId; if(!_jparser.validateByName("milestoneHI", milestoneHandId)) _jparser.validateByNameThrow("milestoneHandId", milestoneHandId);
	AtfValidator::validateUint(_descr, "milestoneHandId", milestoneHandId, _checker, __FILE__, __LINE__);
	PString superstarShowdownResults; _jparser.validateByNameThrow("superstarShowdownResults", superstarShowdownResults);
	AtfValidator::validateInt(_descr, "superstarShowdownResults", superstarShowdownResults.length(), _checker, __FILE__, __LINE__);
	INT32 banner; _jparser.validateByNameThrow("banner", banner);
	AtfValidator::validateInt(_descr, "banner", banner, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody tournMileStoneWinMsg; _jparser.validateByNameThrow("tournMileStoneWinMsg", tournMileStoneWinMsg);
	AtfValidator::validateInt(_descr, "tournMileStoneWinMsg", tournMileStoneWinMsg._size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT8 variableAnteIndex; _jparser.validateByNameThrow("variableAnteIndex", variableAnteIndex);
	AtfValidator::validateInt(_descr, "variableAnteIndex", variableAnteIndex, _checker, __FILE__, __LINE__);
	TableCommon::TableStakes tableStakes; _jparser.validateByNameThrow("tableStakes", tableStakes);
}

/*static*/ void TableClient::publication::TableSubscr_Hand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 stakeSmall; _parser.parseUINT32(stakeSmall);
	AtfValidator::validateInt(_descr, "stakeSmall", stakeSmall, _checker, __FILE__, __LINE__);
	UINT32 stakeBig; _parser.parseUINT32(stakeBig);
	AtfValidator::validateInt(_descr, "stakeBig", stakeBig, _checker, __FILE__, __LINE__);
	INT8 dealer; _parser.parseINT8(dealer);
	AtfValidator::validateInt(_descr, "dealer", dealer, _checker, __FILE__, __LINE__);
	UINT64 lastHandId; _parser.parseUINT64(lastHandId);
	AtfValidator::validateUint(_descr, "lastHandId", lastHandId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "adminMsg"); size_t szAdminMsg = strlen(_dummy);
	AtfValidator::validateInt(_descr, "adminMsg", szAdminMsg, _checker, __FILE__, __LINE__);
	INT8 round; _parser.parseINT8(round);
	AtfValidator::validateInt(_descr, "round", round, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	INT32 multiGameHands; _parser.parseINT32(multiGameHands);
	AtfValidator::validateInt(_descr, "multiGameHands", multiGameHands, _checker, __FILE__, __LINE__);
	UINT16 clientMsgStrId; _parser.parseUINT16(clientMsgStrId);
	AtfValidator::validateInt(_descr, "clientMsgStrId", clientMsgStrId, _checker, __FILE__, __LINE__);
	I18nPString advertiseI18n; advertiseI18n.parse(_parser);
	UINT64 milestoneHandId; _parser.parseUINT64(milestoneHandId);
	AtfValidator::validateUint(_descr, "milestoneHandId", milestoneHandId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "superstarShowdownResults"); size_t szSuperstarShowdownResults = strlen(_dummy);
	AtfValidator::validateInt(_descr, "superstarShowdownResults", szSuperstarShowdownResults, _checker, __FILE__, __LINE__);
	INT32 banner; _parser.parseINT32(banner);
	AtfValidator::validateInt(_descr, "banner", banner, _checker, __FILE__, __LINE__);
	size_t szTournMileStoneWinMsg; _parser.skipMsgBody(szTournMileStoneWinMsg);  /*tournMileStoneWinMsg*/
	AtfValidator::validateInt(_descr, "tournMileStoneWinMsg", szTournMileStoneWinMsg, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT8 variableAnteIndex; _parser.parseINT8(variableAnteIndex);
	AtfValidator::validateInt(_descr, "variableAnteIndex", variableAnteIndex, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    SidePot
//=================================================================

TableClient::publication::SidePot::SidePot()
{
	clear();
}

void TableClient::publication::SidePot::clear()
{
	amount = 0;
	playersMask = 0;
}

bool TableClient::publication::SidePot::equals(const SidePot& _o) const
{
	return amount == _o.amount &&
		playersMask == _o.playersMask;
}

const char *TableClient::publication::SidePot::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append(',');
	_buf.append("playersMask=");
	_buf.appendUint(playersMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::SidePot::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("playersMask", playersMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::SidePot::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playersMask"))
		{
			playersMask = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::SidePot::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SidePot())) // not empty
	{
		_body.composeINT64(amount);
		_body.composeUINT16(playersMask);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::SidePot::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(amount);
	_parser0.parseUINT16(playersMask);
}

const char *TableClient::publication::SidePot::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("playersMask", playersMask);
	return _buf.c_str();
}

void TableClient::publication::SidePot::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("playersMask", playersMask);
}

/* static */ void TableClient::publication::SidePot::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	UINT16 playersMask; _jparser.validateByNameThrow("playersMask", playersMask);
	AtfValidator::validateInt(_descr, "playersMask", playersMask, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::SidePot::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	UINT16 playersMask; _parser0.parseUINT16(playersMask);
	AtfValidator::validateInt(_descr, "playersMask", playersMask, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PotCat
//=================================================================

TableClient::publication::PotCat::PotCat()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::PotCat::PotCat(PotCat&& _o)
	: potCategoryId(std::move(_o.potCategoryId))
	, pots(std::move(_o.pots))
	, rake(std::move(_o.rake))
{
}

TableClient::publication::PotCat& TableClient::publication::PotCat::operator=(PotCat&& _o)
{
	if(this != &_o)
	{
		potCategoryId = std::move(_o.potCategoryId);
		pots = std::move(_o.pots);
		rake = std::move(_o.rake);
	}
	return *this;
}

#endif

void TableClient::publication::PotCat::clear()
{
	potCategoryId = 0;
	pots.clear();
	rake = 0;
}

bool TableClient::publication::PotCat::equals(const PotCat& _o) const
{
	return potCategoryId == _o.potCategoryId &&
		pots.equals(_o.pots) &&
		rake == _o.rake;
}

const char *TableClient::publication::PotCat::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("potCategoryId=");
	_buf.appendUint(potCategoryId);
	_buf.append(',');
	_buf.append("pots=");
	pots.toTraceString(_buf);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::PotCat::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("potCategoryId", potCategoryId, _buf);
	pots.toXmlString("pots", _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::PotCat::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("potCategoryId"))
		{
			potCategoryId = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("pots"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SidePot, 1 > >::FromXmlString(_value, pots)) return false;
		}
		else if (_element.equals("rake"))
		{
			rake = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::PotCat::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PotCat())) // not empty
	{
		_body.composeBYTE(potCategoryId);
		pots.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(rake);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::PotCat::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(potCategoryId);
	pots.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(rake);
}

const char *TableClient::publication::PotCat::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("potCategoryId", potCategoryId);
	_jsonstr.compose("pots", pots);
	_jsonstr.compose("rake", rake);
	return _buf.c_str();
}

void TableClient::publication::PotCat::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("potCategoryId", potCategoryId);
	_jparser.parseByNameThrow("pots", pots);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("rake", rake);
}

/* static */ void TableClient::publication::PotCat::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE potCategoryId; _jparser.validateByNameThrow("potCategoryId", potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SidePot > pots; _jparser.validateByNameThrow("pots", pots);
	AtfValidator::validateInt(_descr, "pots", pots.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::PotCat::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE potCategoryId; _parser0.parseBYTE(potCategoryId);
	AtfValidator::validateInt(_descr, "potCategoryId", potCategoryId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPots = Atf::LAtfVector< SidePot, 1 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("pots"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "pots", szPots, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 rake; _parser0.parseINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableSubscr_ActivePlayer
//=================================================================

TableClient::publication::TableSubscr_ActivePlayer::TableSubscr_ActivePlayer()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TableSubscr_ActivePlayer::TableSubscr_ActivePlayer(TableSubscr_ActivePlayer&& _o)
	: activePlayer(std::move(_o.activePlayer))
	, rake(std::move(_o.rake))
	, pots(std::move(_o.pots))
	, columns(std::move(_o.columns))
	, totalPot(std::move(_o.totalPot))
	, activeTBstate(std::move(_o.activeTBstate))
	, activeTimeBank(std::move(_o.activeTimeBank))
	, capX(std::move(_o.capX))
	, capY(std::move(_o.capY))
	, actionTimeType(std::move(_o.actionTimeType))
	, totalActionTime(std::move(_o.totalActionTime))
	, remainingActionTime(std::move(_o.remainingActionTime))
	, isActionTimerPaused(std::move(_o.isActionTimerPaused))
	, multiActivePlayersMask(std::move(_o.multiActivePlayersMask))
	, potCats(std::move(_o.potCats))
{
}

TableClient::publication::TableSubscr_ActivePlayer& TableClient::publication::TableSubscr_ActivePlayer::operator=(TableSubscr_ActivePlayer&& _o)
{
	if(this != &_o)
	{
		activePlayer = std::move(_o.activePlayer);
		rake = std::move(_o.rake);
		pots = std::move(_o.pots);
		columns = std::move(_o.columns);
		totalPot = std::move(_o.totalPot);
		activeTBstate = std::move(_o.activeTBstate);
		activeTimeBank = std::move(_o.activeTimeBank);
		capX = std::move(_o.capX);
		capY = std::move(_o.capY);
		actionTimeType = std::move(_o.actionTimeType);
		totalActionTime = std::move(_o.totalActionTime);
		remainingActionTime = std::move(_o.remainingActionTime);
		isActionTimerPaused = std::move(_o.isActionTimerPaused);
		multiActivePlayersMask = std::move(_o.multiActivePlayersMask);
		potCats = std::move(_o.potCats);
	}
	return *this;
}

#endif

void TableClient::publication::TableSubscr_ActivePlayer::clear()
{
	activePlayer = -1;
	rake = 0;
	pots.clear();
	columns.clear();
	totalPot = 0;
	activeTBstate = 0;
	activeTimeBank = 0;
	capX = 0;
	capY = 0;
	actionTimeType = 0;
	totalActionTime = 0;
	remainingActionTime = 0;
	isActionTimerPaused = false;
	multiActivePlayersMask = 0;
	potCats.clear();
}

bool TableClient::publication::TableSubscr_ActivePlayer::equals(const TableSubscr_ActivePlayer& _o) const
{
	return activePlayer == _o.activePlayer &&
		rake == _o.rake &&
		pots.equals(_o.pots) &&
		columns.equals(_o.columns) &&
		totalPot == _o.totalPot &&
		activeTBstate == _o.activeTBstate &&
		activeTimeBank == _o.activeTimeBank &&
		capX == _o.capX &&
		actionTimeType == _o.actionTimeType &&
		totalActionTime == _o.totalActionTime &&
		remainingActionTime == _o.remainingActionTime &&
		isActionTimerPaused == _o.isActionTimerPaused &&
		multiActivePlayersMask == _o.multiActivePlayersMask;
}

const char *TableClient::publication::TableSubscr_ActivePlayer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("activePlayer=");
	_buf.appendInt(activePlayer);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("pots=");
	pots.toTraceString(_buf);
	_buf.append(',');
	_buf.append("columns=");
	columns.toTraceString(_buf);
	_buf.append(',');
	_buf.append("totalPot=");
	_buf.appendUint(totalPot);
	_buf.append(',');
	_buf.append("activeTBstate=");
	_buf.appendUint(activeTBstate);
	_buf.append(',');
	_buf.append("activeTb=");
	_buf.appendUint(activeTimeBank);
	_buf.append(',');
	_buf.append("capX=");
	_buf.appendInt(capX);
	_buf.append(',');
	_buf.append("capY=");
	_buf.appendInt(capY);
	_buf.append(',');
	_buf.append("actionTimeType=");
	_buf.appendUint(actionTimeType);
	_buf.append(',');
	_buf.append("totalActionTime=");
	_buf.appendUint(totalActionTime);
	_buf.append(',');
	_buf.append("remainingActionTime=");
	_buf.appendUint(remainingActionTime);
	_buf.append(',');
	_buf.append("isActionTimerPaused=");
	_buf.appendUint(isActionTimerPaused);
	_buf.append(',');
	_buf.append("multiActivePlayersMask=");
	_buf.appendUint(multiActivePlayersMask);
	_buf.append(',');
	_buf.append("potCats=");
	potCats.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_ActivePlayer::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("activePlayer", activePlayer, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	pots.toXmlString("pots", _buf);
	columns.toXmlString("columns", _buf);
	Atf::XmlElement::encodeAsXmlElement("totalPot", totalPot, _buf);
	Atf::XmlElement::encodeAsXmlElement("activeTBstate", activeTBstate, _buf);
	Atf::XmlElement::encodeAsXmlElement("activeTb", activeTimeBank, _buf);
	Atf::XmlElement::encodeAsXmlElement("capX", capX, _buf);
	Atf::XmlElement::encodeAsXmlElement("capY", capY, _buf);
	Atf::XmlElement::encodeAsXmlElement("actionTimeType", actionTimeType, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalActionTime", totalActionTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("remainingActionTime", remainingActionTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("isActionTimerPaused", isActionTimerPaused, _buf);
	Atf::XmlElement::encodeAsXmlElement("multiActivePlayersMask", multiActivePlayersMask, _buf);
	potCats.toXmlString("potCats", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_ActivePlayer::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("activePlayer"))
		{
			activePlayer = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("pots"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 1 > >::FromXmlString(_value, pots)) return false;
		}
		else if (_element.equals("columns"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 1 > >::FromXmlString(_value, columns)) return false;
		}
		else if (_element.equals("totalPot"))
		{
			totalPot = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("activeTBstate"))
		{
			activeTBstate = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("activeTb") || _element.equals("activeTimeBank"))
		{
			activeTimeBank = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("capX"))
		{
			capX = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("capY"))
		{
			capY = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("actionTimeType"))
		{
			actionTimeType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalActionTime"))
		{
			totalActionTime = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("remainingActionTime"))
		{
			remainingActionTime = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isActionTimerPaused"))
		{
			isActionTimerPaused = (*_value.ptr() == '1');
		}
		else if (_element.equals("multiActivePlayersMask"))
		{
			multiActivePlayersMask = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("potCats"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PotCat, 1 > >::FromXmlString(_value, potCats)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_ActivePlayer::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(activePlayer);
	_msg.composeUINT32(rake);
	pots.composeMsg(_msg, _ignoreJSON);
	columns.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(totalPot);
	_msg.composeBYTE(activeTBstate);
	_msg.composeUINT32(activeTimeBank);
	_msg.composeINT32(capX);
	_msg.composeINT32(capY);
	_msg.composeBYTE(actionTimeType);
	_msg.composeUINT32(totalActionTime);
	_msg.composeUINT32(remainingActionTime);
	_msg.composeBOOL(isActionTimerPaused);
	_msg.composeUINT16(multiActivePlayersMask);
	potCats.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::TableSubscr_ActivePlayer::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(activePlayer);
	_parser.parseUINT32(rake);
	pots.parseMsg(_parser);
	columns.parseMsg(_parser);
	_parser.parseUINT32(totalPot);
	_parser.parseBYTE(activeTBstate);
	_parser.parseUINT32(activeTimeBank);
	_parser.parseINT32(capX);
	_parser.parseINT32(capY);
	_parser.parseBYTE(actionTimeType);
	_parser.parseUINT32(totalActionTime);
	_parser.parseUINT32(remainingActionTime);
	_parser.parseBOOL(isActionTimerPaused);
	if(_parser.parseEnded()) return;
	_parser.parseUINT16(multiActivePlayersMask);
	if(_parser.parseEnded()) return;
	potCats.parseMsg(_parser);
}

const char *TableClient::publication::TableSubscr_ActivePlayer::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("activePlayer", activePlayer);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("pots", pots);
	_jsonstr.compose("columns", columns);
	_jsonstr.compose("totalPot", totalPot);
	_jsonstr.compose("activeTBstate", activeTBstate);
	_jsonstr.compose("activeTb", activeTimeBank);
	_jsonstr.compose("capX", capX);
	_jsonstr.compose("capY", capY);
	_jsonstr.compose("actionTimeType", actionTimeType);
	_jsonstr.compose("totalActionTime", totalActionTime);
	_jsonstr.compose("remainingActionTime", remainingActionTime);
	_jsonstr.compose("isActionTimerPaused", isActionTimerPaused);
	_jsonstr.compose("multiActivePlayersMask", multiActivePlayersMask);
	_jsonstr.compose("potCats", potCats);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_ActivePlayer::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("activePlayer", activePlayer);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("pots", pots);
	_jparser.parseByNameThrow("columns", columns);
	_jparser.parseByNameThrow("totalPot", totalPot);
	_jparser.parseByNameThrow("activeTBstate", activeTBstate);
	if(!_jparser.parseByName("activeTb", activeTimeBank)) _jparser.parseByNameThrow("activeTimeBank", activeTimeBank);
	_jparser.parseByNameThrow("capX", capX);
	_jparser.parseByNameThrow("capY", capY);
	_jparser.parseByNameThrow("actionTimeType", actionTimeType);
	_jparser.parseByNameThrow("totalActionTime", totalActionTime);
	_jparser.parseByNameThrow("remainingActionTime", remainingActionTime);
	_jparser.parseByNameThrow("isActionTimerPaused", isActionTimerPaused);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("multiActivePlayersMask", multiActivePlayersMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("potCats", potCats);
}

/* static */ void TableClient::publication::TableSubscr_ActivePlayer::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 activePlayer; _jparser.validateByNameThrow("activePlayer", activePlayer);
	AtfValidator::validateInt(_descr, "activePlayer", activePlayer, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > pots; _jparser.validateByNameThrow("pots", pots);
	AtfValidator::validateInt(_descr, "pots", pots.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > columns; _jparser.validateByNameThrow("columns", columns);
	AtfValidator::validateInt(_descr, "columns", columns.size(), _checker, __FILE__, __LINE__);
	UINT32 totalPot; _jparser.validateByNameThrow("totalPot", totalPot);
	AtfValidator::validateInt(_descr, "totalPot", totalPot, _checker, __FILE__, __LINE__);
	BYTE activeTBstate; _jparser.validateByNameThrow("activeTBstate", activeTBstate);
	AtfValidator::validateInt(_descr, "activeTBstate", activeTBstate, _checker, __FILE__, __LINE__);
	UINT32 activeTimeBank; if(!_jparser.validateByName("activeTb", activeTimeBank)) _jparser.validateByNameThrow("activeTimeBank", activeTimeBank);
	AtfValidator::validateInt(_descr, "activeTimeBank", activeTimeBank, _checker, __FILE__, __LINE__);
	INT32 capX; _jparser.validateByNameThrow("capX", capX);
	AtfValidator::validateInt(_descr, "capX", capX, _checker, __FILE__, __LINE__);
	INT32 capY; _jparser.validateByNameThrow("capY", capY);
	AtfValidator::validateInt(_descr, "capY", capY, _checker, __FILE__, __LINE__);
	BYTE actionTimeType; _jparser.validateByNameThrow("actionTimeType", actionTimeType);
	AtfValidator::validateInt(_descr, "actionTimeType", actionTimeType, _checker, __FILE__, __LINE__);
	UINT32 totalActionTime; _jparser.validateByNameThrow("totalActionTime", totalActionTime);
	AtfValidator::validateInt(_descr, "totalActionTime", totalActionTime, _checker, __FILE__, __LINE__);
	UINT32 remainingActionTime; _jparser.validateByNameThrow("remainingActionTime", remainingActionTime);
	AtfValidator::validateInt(_descr, "remainingActionTime", remainingActionTime, _checker, __FILE__, __LINE__);
	bool isActionTimerPaused; _jparser.validateByNameThrow("isActionTimerPaused", isActionTimerPaused);
	AtfValidator::validateInt(_descr, "isActionTimerPaused", isActionTimerPaused, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT16 multiActivePlayersMask; _jparser.validateByNameThrow("multiActivePlayersMask", multiActivePlayersMask);
	AtfValidator::validateInt(_descr, "multiActivePlayersMask", multiActivePlayersMask, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< PotCat > potCats; _jparser.validateByNameThrow("potCats", potCats);
	AtfValidator::validateInt(_descr, "potCats", potCats.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_ActivePlayer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 activePlayer; _parser.parseINT8(activePlayer);
	AtfValidator::validateInt(_descr, "activePlayer", activePlayer, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPots = Atf::LAtfVector< UINT32, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pots"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "pots", szPots, _checker, __FILE__, __LINE__);
	int szColumns = Atf::LAtfVector< UINT32, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("columns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "columns", szColumns, _checker, __FILE__, __LINE__);
	UINT32 totalPot; _parser.parseUINT32(totalPot);
	AtfValidator::validateInt(_descr, "totalPot", totalPot, _checker, __FILE__, __LINE__);
	BYTE activeTBstate; _parser.parseBYTE(activeTBstate);
	AtfValidator::validateInt(_descr, "activeTBstate", activeTBstate, _checker, __FILE__, __LINE__);
	UINT32 activeTimeBank; _parser.parseUINT32(activeTimeBank);
	AtfValidator::validateInt(_descr, "activeTimeBank", activeTimeBank, _checker, __FILE__, __LINE__);
	INT32 capX; _parser.parseINT32(capX);
	AtfValidator::validateInt(_descr, "capX", capX, _checker, __FILE__, __LINE__);
	INT32 capY; _parser.parseINT32(capY);
	AtfValidator::validateInt(_descr, "capY", capY, _checker, __FILE__, __LINE__);
	BYTE actionTimeType; _parser.parseBYTE(actionTimeType);
	AtfValidator::validateInt(_descr, "actionTimeType", actionTimeType, _checker, __FILE__, __LINE__);
	UINT32 totalActionTime; _parser.parseUINT32(totalActionTime);
	AtfValidator::validateInt(_descr, "totalActionTime", totalActionTime, _checker, __FILE__, __LINE__);
	UINT32 remainingActionTime; _parser.parseUINT32(remainingActionTime);
	AtfValidator::validateInt(_descr, "remainingActionTime", remainingActionTime, _checker, __FILE__, __LINE__);
	bool isActionTimerPaused; _parser.parseBOOL(isActionTimerPaused);
	AtfValidator::validateInt(_descr, "isActionTimerPaused", isActionTimerPaused, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT16 multiActivePlayersMask; _parser.parseUINT16(multiActivePlayersMask);
	AtfValidator::validateInt(_descr, "multiActivePlayersMask", multiActivePlayersMask, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	int szPotCats = Atf::LAtfVector< PotCat, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("potCats"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "potCats", szPotCats, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSubscr_Board
//=================================================================

TableClient::publication::TableSubscr_Board::TableSubscr_Board()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TableSubscr_Board::TableSubscr_Board(TableSubscr_Board&& _o)
	: activeBoardCards(std::move(_o.activeBoardCards))
{
}

TableClient::publication::TableSubscr_Board& TableClient::publication::TableSubscr_Board::operator=(TableSubscr_Board&& _o)
{
	if(this != &_o)
	{
		activeBoardCards = std::move(_o.activeBoardCards);
	}
	return *this;
}

#endif

void TableClient::publication::TableSubscr_Board::clear()
{
	activeBoardCards.clear();
}

bool TableClient::publication::TableSubscr_Board::equals(const TableSubscr_Board& _o) const
{
	return activeBoardCards.equals(_o.activeBoardCards);
}

const char *TableClient::publication::TableSubscr_Board::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("activeBoardCards=");
	activeBoardCards.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_Board::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	activeBoardCards.toXmlString("activeBoardCards", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_Board::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("activeBoardCards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableCommon::P_Card , 1 > >::FromXmlString(_value, activeBoardCards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_Board::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	activeBoardCards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::TableSubscr_Board::parseMsg(CommMsgParser& _parser)
{
	activeBoardCards.parseMsg(_parser);
}

const char *TableClient::publication::TableSubscr_Board::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("activeBoardCards", activeBoardCards);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_Board::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("activeBoardCards", activeBoardCards);
}

/* static */ void TableClient::publication::TableSubscr_Board::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TableCommon::P_Card > activeBoardCards; _jparser.validateByNameThrow("activeBoardCards", activeBoardCards);
	AtfValidator::validateInt(_descr, "activeBoardCards", activeBoardCards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_Board::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szActiveBoardCards = Atf::LAtfVector< TableCommon::P_Card , 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("activeBoardCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "activeBoardCards", szActiveBoardCards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSubscr_PlayerChips
//=================================================================

TableClient::publication::TableSubscr_PlayerChips::TableSubscr_PlayerChips()
{
	clear();
}

void TableClient::publication::TableSubscr_PlayerChips::clear()
{
	chips = 0;
	chipsBet = 0;
	isSittingIn = 0;
	isSeatedAndConnected = 0;
	allInFlag = 0;
	inHand = 0;
	seatIndicator = 0;
	connectQuality = CONNECTION_QUALITY_DISCONNECTED;
	timeBank = 0;
	numOfAllInsLeft = ALLIN_NOALLINTOURN;
	capN = 0;
	totalBet = 0;
	playerState = 0;
	remainingStacks = 0;
	hasCard = false;
	hasFolded = false;
	totalBetInUnfoldPot = 0;
	playerState2 = 0;
}

bool TableClient::publication::TableSubscr_PlayerChips::equals(const TableSubscr_PlayerChips& _o) const
{
	return chips == _o.chips &&
		chipsBet == _o.chipsBet &&
		isSittingIn == _o.isSittingIn &&
		isSeatedAndConnected == _o.isSeatedAndConnected &&
		allInFlag == _o.allInFlag &&
		inHand == _o.inHand &&
		seatIndicator == _o.seatIndicator &&
		connectQuality == _o.connectQuality &&
		timeBank == _o.timeBank &&
		numOfAllInsLeft == _o.numOfAllInsLeft &&
		totalBet == _o.totalBet &&
		playerState == _o.playerState &&
		remainingStacks == _o.remainingStacks &&
		hasCard == _o.hasCard &&
		hasFolded == _o.hasFolded &&
		totalBetInUnfoldPot == _o.totalBetInUnfoldPot &&
		playerState2 == _o.playerState2;
}

const char *TableClient::publication::TableSubscr_PlayerChips::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("chipsBet=");
	_buf.appendUint(chipsBet);
	_buf.append(',');
	_buf.append("isSittingIn=");
	_buf.appendUint(isSittingIn);
	_buf.append(',');
	_buf.append("isSeatedAndConnected=");
	_buf.appendUint(isSeatedAndConnected);
	_buf.append(',');
	_buf.append("allInFlag=");
	_buf.appendUint(allInFlag);
	_buf.append(',');
	_buf.append("inHand=");
	_buf.appendUint(inHand);
	_buf.append(',');
	_buf.append("seatIndicator=");
	_buf.appendUint(seatIndicator);
	_buf.append(',');
	_buf.append("connectQuality=");
	_buf.appendInt(connectQuality);
	_buf.append(',');
	_buf.append("tb=");
	_buf.appendUint(timeBank);
	_buf.append(',');
	_buf.append("numOfAllInsLeft=");
	_buf.appendInt(numOfAllInsLeft);
	_buf.append(',');
	_buf.append("capN=");
	_buf.appendInt(capN);
	_buf.append(',');
	_buf.append("totalBet=");
	_buf.appendUint(totalBet);
	_buf.append(',');
	_buf.append("playerState=");
	_buf.appendUint(playerState);
	_buf.append(',');
	_buf.append("remainingStacks=");
	_buf.appendUint(remainingStacks);
	_buf.append(',');
	_buf.append("hasCard=");
	_buf.appendUint(hasCard);
	_buf.append(',');
	_buf.append("hasFolded=");
	_buf.appendUint(hasFolded);
	_buf.append(',');
	_buf.append("totalBetInUnfoldPot=");
	_buf.appendInt(totalBetInUnfoldPot);
	_buf.append(',');
	_buf.append("playerState2=");
	_buf.appendUint64(playerState2);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_PlayerChips::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("chipsBet", chipsBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("isSittingIn", isSittingIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isSeatedAndConnected", isSeatedAndConnected, _buf);
	Atf::XmlElement::encodeAsXmlElement("allInFlag", allInFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("inHand", inHand, _buf);
	Atf::XmlElement::encodeAsXmlElement("seatIndicator", seatIndicator, _buf);
	Atf::XmlElement::encodeAsXmlElement("connectQuality", connectQuality, _buf);
	Atf::XmlElement::encodeAsXmlElement("tb", timeBank, _buf);
	Atf::XmlElement::encodeAsXmlElement("numOfAllInsLeft", numOfAllInsLeft, _buf);
	Atf::XmlElement::encodeAsXmlElement("capN", capN, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalBet", totalBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerState", playerState, _buf);
	Atf::XmlElement::encodeAsXmlElement("remainingStacks", remainingStacks, _buf);
	Atf::XmlElement::encodeAsXmlElement("hasCard", hasCard, _buf);
	Atf::XmlElement::encodeAsXmlElement("hasFolded", hasFolded, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalBetInUnfoldPot", totalBetInUnfoldPot, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerState2", playerState2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_PlayerChips::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chips"))
		{
			chips = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chipsBet"))
		{
			chipsBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isSittingIn"))
		{
			isSittingIn = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isSeatedAndConnected"))
		{
			isSeatedAndConnected = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("allInFlag"))
		{
			allInFlag = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("inHand"))
		{
			inHand = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("seatIndicator"))
		{
			seatIndicator = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("connectQuality"))
		{
			connectQuality = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tb") || _element.equals("timeBank"))
		{
			timeBank = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numOfAllInsLeft"))
		{
			numOfAllInsLeft = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("capN"))
		{
			capN = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalBet"))
		{
			totalBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerState"))
		{
			playerState = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("remainingStacks"))
		{
			remainingStacks = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hasCard"))
		{
			hasCard = (*_value.ptr() == '1');
		}
		else if (_element.equals("hasFolded"))
		{
			hasFolded = (*_value.ptr() == '1');
		}
		else if (_element.equals("totalBetInUnfoldPot"))
		{
			totalBetInUnfoldPot = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerState2"))
		{
			playerState2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_PlayerChips::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(chips);
	_msg.composeUINT32(chipsBet);
	_msg.composeBYTE(isSittingIn);
	_msg.composeBYTE(isSeatedAndConnected);
	_msg.composeBYTE(allInFlag);
	_msg.composeBYTE(inHand);
	_msg.composeBYTE(seatIndicator);
	_msg.composeINT8(connectQuality);
	_msg.composeUINT32(timeBank);
	_msg.composeINT16(numOfAllInsLeft);
	_msg.composeINT32(capN);
	_msg.composeUINT32(totalBet);
	_msg.composeBYTE(playerState);
	_msg.composeUINT32(remainingStacks);
	_msg.composeBOOL(hasCard);
	_msg.composeBOOL(hasFolded);
	_msg.composeINT32(totalBetInUnfoldPot);
	_msg.composeUINT64(playerState2);
}

void TableClient::publication::TableSubscr_PlayerChips::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(chips);
	_parser.parseUINT32(chipsBet);
	_parser.parseBYTE(isSittingIn);
	_parser.parseBYTE(isSeatedAndConnected);
	_parser.parseBYTE(allInFlag);
	_parser.parseBYTE(inHand);
	_parser.parseBYTE(seatIndicator);
	_parser.parseINT8(connectQuality);
	_parser.parseUINT32(timeBank);
	_parser.parseINT16(numOfAllInsLeft);
	_parser.parseINT32(capN);
	_parser.parseUINT32(totalBet);
	_parser.parseBYTE(playerState);
	_parser.parseUINT32(remainingStacks);
	_parser.parseBOOL(hasCard);
	_parser.parseBOOL(hasFolded);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(totalBetInUnfoldPot);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(playerState2);
}

const char *TableClient::publication::TableSubscr_PlayerChips::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("chipsBet", chipsBet);
	_jsonstr.compose("isSittingIn", isSittingIn);
	_jsonstr.compose("isSeatedAndConnected", isSeatedAndConnected);
	_jsonstr.compose("allInFlag", allInFlag);
	_jsonstr.compose("inHand", inHand);
	_jsonstr.compose("seatIndicator", seatIndicator);
	_jsonstr.compose("connectQuality", connectQuality);
	_jsonstr.compose("tb", timeBank);
	_jsonstr.compose("numOfAllInsLeft", numOfAllInsLeft);
	_jsonstr.compose("capN", capN);
	_jsonstr.compose("totalBet", totalBet);
	_jsonstr.compose("playerState", playerState);
	_jsonstr.compose("remainingStacks", remainingStacks);
	_jsonstr.compose("hasCard", hasCard);
	_jsonstr.compose("hasFolded", hasFolded);
	_jsonstr.compose("totalBetInUnfoldPot", totalBetInUnfoldPot);
	_jsonstr.compose("playerState2", playerState2);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_PlayerChips::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("chipsBet", chipsBet);
	_jparser.parseByNameThrow("isSittingIn", isSittingIn);
	_jparser.parseByNameThrow("isSeatedAndConnected", isSeatedAndConnected);
	_jparser.parseByNameThrow("allInFlag", allInFlag);
	_jparser.parseByNameThrow("inHand", inHand);
	_jparser.parseByNameThrow("seatIndicator", seatIndicator);
	_jparser.parseByNameThrow("connectQuality", connectQuality);
	if(!_jparser.parseByName("tb", timeBank)) _jparser.parseByNameThrow("timeBank", timeBank);
	_jparser.parseByNameThrow("numOfAllInsLeft", numOfAllInsLeft);
	_jparser.parseByNameThrow("capN", capN);
	_jparser.parseByNameThrow("totalBet", totalBet);
	_jparser.parseByNameThrow("playerState", playerState);
	_jparser.parseByNameThrow("remainingStacks", remainingStacks);
	_jparser.parseByNameThrow("hasCard", hasCard);
	_jparser.parseByNameThrow("hasFolded", hasFolded);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("totalBetInUnfoldPot", totalBetInUnfoldPot);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("playerState2", playerState2);
}

/* static */ void TableClient::publication::TableSubscr_PlayerChips::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT32 chipsBet; _jparser.validateByNameThrow("chipsBet", chipsBet);
	AtfValidator::validateInt(_descr, "chipsBet", chipsBet, _checker, __FILE__, __LINE__);
	BYTE isSittingIn; _jparser.validateByNameThrow("isSittingIn", isSittingIn);
	AtfValidator::validateInt(_descr, "isSittingIn", isSittingIn, _checker, __FILE__, __LINE__);
	BYTE isSeatedAndConnected; _jparser.validateByNameThrow("isSeatedAndConnected", isSeatedAndConnected);
	AtfValidator::validateInt(_descr, "isSeatedAndConnected", isSeatedAndConnected, _checker, __FILE__, __LINE__);
	BYTE allInFlag; _jparser.validateByNameThrow("allInFlag", allInFlag);
	AtfValidator::validateInt(_descr, "allInFlag", allInFlag, _checker, __FILE__, __LINE__);
	BYTE inHand; _jparser.validateByNameThrow("inHand", inHand);
	AtfValidator::validateInt(_descr, "inHand", inHand, _checker, __FILE__, __LINE__);
	BYTE seatIndicator; _jparser.validateByNameThrow("seatIndicator", seatIndicator);
	AtfValidator::validateInt(_descr, "seatIndicator", seatIndicator, _checker, __FILE__, __LINE__);
	INT8 connectQuality; _jparser.validateByNameThrow("connectQuality", connectQuality);
	AtfValidator::validateInt(_descr, "connectQuality", connectQuality, _checker, __FILE__, __LINE__);
	UINT32 timeBank; if(!_jparser.validateByName("tb", timeBank)) _jparser.validateByNameThrow("timeBank", timeBank);
	AtfValidator::validateInt(_descr, "timeBank", timeBank, _checker, __FILE__, __LINE__);
	INT16 numOfAllInsLeft; _jparser.validateByNameThrow("numOfAllInsLeft", numOfAllInsLeft);
	AtfValidator::validateInt(_descr, "numOfAllInsLeft", numOfAllInsLeft, _checker, __FILE__, __LINE__);
	INT32 capN; _jparser.validateByNameThrow("capN", capN);
	AtfValidator::validateInt(_descr, "capN", capN, _checker, __FILE__, __LINE__);
	UINT32 totalBet; _jparser.validateByNameThrow("totalBet", totalBet);
	AtfValidator::validateInt(_descr, "totalBet", totalBet, _checker, __FILE__, __LINE__);
	BYTE playerState; _jparser.validateByNameThrow("playerState", playerState);
	AtfValidator::validateInt(_descr, "playerState", playerState, _checker, __FILE__, __LINE__);
	UINT32 remainingStacks; _jparser.validateByNameThrow("remainingStacks", remainingStacks);
	AtfValidator::validateInt(_descr, "remainingStacks", remainingStacks, _checker, __FILE__, __LINE__);
	bool hasCard; _jparser.validateByNameThrow("hasCard", hasCard);
	AtfValidator::validateInt(_descr, "hasCard", hasCard, _checker, __FILE__, __LINE__);
	bool hasFolded; _jparser.validateByNameThrow("hasFolded", hasFolded);
	AtfValidator::validateInt(_descr, "hasFolded", hasFolded, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 totalBetInUnfoldPot; _jparser.validateByNameThrow("totalBetInUnfoldPot", totalBetInUnfoldPot);
	AtfValidator::validateInt(_descr, "totalBetInUnfoldPot", totalBetInUnfoldPot, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 playerState2; _jparser.validateByNameThrow("playerState2", playerState2);
	AtfValidator::validateUint(_descr, "playerState2", playerState2, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_PlayerChips::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT32 chipsBet; _parser.parseUINT32(chipsBet);
	AtfValidator::validateInt(_descr, "chipsBet", chipsBet, _checker, __FILE__, __LINE__);
	BYTE isSittingIn; _parser.parseBYTE(isSittingIn);
	AtfValidator::validateInt(_descr, "isSittingIn", isSittingIn, _checker, __FILE__, __LINE__);
	BYTE isSeatedAndConnected; _parser.parseBYTE(isSeatedAndConnected);
	AtfValidator::validateInt(_descr, "isSeatedAndConnected", isSeatedAndConnected, _checker, __FILE__, __LINE__);
	BYTE allInFlag; _parser.parseBYTE(allInFlag);
	AtfValidator::validateInt(_descr, "allInFlag", allInFlag, _checker, __FILE__, __LINE__);
	BYTE inHand; _parser.parseBYTE(inHand);
	AtfValidator::validateInt(_descr, "inHand", inHand, _checker, __FILE__, __LINE__);
	BYTE seatIndicator; _parser.parseBYTE(seatIndicator);
	AtfValidator::validateInt(_descr, "seatIndicator", seatIndicator, _checker, __FILE__, __LINE__);
	INT8 connectQuality; _parser.parseINT8(connectQuality);
	AtfValidator::validateInt(_descr, "connectQuality", connectQuality, _checker, __FILE__, __LINE__);
	UINT32 timeBank; _parser.parseUINT32(timeBank);
	AtfValidator::validateInt(_descr, "timeBank", timeBank, _checker, __FILE__, __LINE__);
	INT16 numOfAllInsLeft; _parser.parseINT16(numOfAllInsLeft);
	AtfValidator::validateInt(_descr, "numOfAllInsLeft", numOfAllInsLeft, _checker, __FILE__, __LINE__);
	INT32 capN; _parser.parseINT32(capN);
	AtfValidator::validateInt(_descr, "capN", capN, _checker, __FILE__, __LINE__);
	UINT32 totalBet; _parser.parseUINT32(totalBet);
	AtfValidator::validateInt(_descr, "totalBet", totalBet, _checker, __FILE__, __LINE__);
	BYTE playerState; _parser.parseBYTE(playerState);
	AtfValidator::validateInt(_descr, "playerState", playerState, _checker, __FILE__, __LINE__);
	UINT32 remainingStacks; _parser.parseUINT32(remainingStacks);
	AtfValidator::validateInt(_descr, "remainingStacks", remainingStacks, _checker, __FILE__, __LINE__);
	bool hasCard; _parser.parseBOOL(hasCard);
	AtfValidator::validateInt(_descr, "hasCard", hasCard, _checker, __FILE__, __LINE__);
	bool hasFolded; _parser.parseBOOL(hasFolded);
	AtfValidator::validateInt(_descr, "hasFolded", hasFolded, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 totalBetInUnfoldPot; _parser.parseINT32(totalBetInUnfoldPot);
	AtfValidator::validateInt(_descr, "totalBetInUnfoldPot", totalBetInUnfoldPot, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 playerState2; _parser.parseUINT64(playerState2);
	AtfValidator::validateUint(_descr, "playerState2", playerState2, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSubscr_PlayerProfile
//=================================================================

TableClient::publication::TableSubscr_PlayerProfile::TableSubscr_PlayerProfile()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TableSubscr_PlayerProfile::TableSubscr_PlayerProfile(TableSubscr_PlayerProfile&& _o)
	: user(std::move(_o.user))
	, city(std::move(_o.city))
	, imageId(std::move(_o.imageId))
	, siteId(std::move(_o.siteId))
	, vipStatus(std::move(_o.vipStatus))
	, publProp(std::move(_o.publProp))
	, bounty(std::move(_o.bounty))
	, promoImageCode(std::move(_o.promoImageCode))
	, country(std::move(_o.country))
	, showCountry(std::move(_o.showCountry))
	, headBounty(std::move(_o.headBounty))
	, hallOfFame(std::move(_o.hallOfFame))
	, mileStoneAward(std::move(_o.mileStoneAward))
	, clientDevice(std::move(_o.clientDevice))
	, userPropertyMsg(std::move(_o.userPropertyMsg))
	, brandImages(std::move(_o.brandImages))
	, altBounty_tournId(std::move(_o.altBounty_tournId))
	, altBounty_admission(std::move(_o.altBounty_admission))
	, altBounty_tChips(std::move(_o.altBounty_tChips))
	, earlyBirdMultiplier(std::move(_o.earlyBirdMultiplier))
	, earlyBirdMins(std::move(_o.earlyBirdMins))
	, amountToHeadIfEliminated(std::move(_o.amountToHeadIfEliminated))
	, baseWinIfEliminated(std::move(_o.baseWinIfEliminated))
	, maxBonusWinIfEliminated(std::move(_o.maxBonusWinIfEliminated))
{
}

TableClient::publication::TableSubscr_PlayerProfile& TableClient::publication::TableSubscr_PlayerProfile::operator=(TableSubscr_PlayerProfile&& _o)
{
	if(this != &_o)
	{
		user = std::move(_o.user);
		city = std::move(_o.city);
		imageId = std::move(_o.imageId);
		siteId = std::move(_o.siteId);
		vipStatus = std::move(_o.vipStatus);
		publProp = std::move(_o.publProp);
		bounty = std::move(_o.bounty);
		promoImageCode = std::move(_o.promoImageCode);
		country = std::move(_o.country);
		showCountry = std::move(_o.showCountry);
		headBounty = std::move(_o.headBounty);
		hallOfFame = std::move(_o.hallOfFame);
		mileStoneAward = std::move(_o.mileStoneAward);
		clientDevice = std::move(_o.clientDevice);
		userPropertyMsg = std::move(_o.userPropertyMsg);
		brandImages = std::move(_o.brandImages);
		altBounty_tournId = std::move(_o.altBounty_tournId);
		altBounty_admission = std::move(_o.altBounty_admission);
		altBounty_tChips = std::move(_o.altBounty_tChips);
		earlyBirdMultiplier = std::move(_o.earlyBirdMultiplier);
		earlyBirdMins = std::move(_o.earlyBirdMins);
		amountToHeadIfEliminated = std::move(_o.amountToHeadIfEliminated);
		baseWinIfEliminated = std::move(_o.baseWinIfEliminated);
		maxBonusWinIfEliminated = std::move(_o.maxBonusWinIfEliminated);
	}
	return *this;
}

#endif

void TableClient::publication::TableSubscr_PlayerProfile::clear()
{
	user.clear();
	city.clear();
	imageId = 0;
	siteId = 0;
	vipStatus = 0;
	publProp = 0;
	bounty = 0;
	promoImageCode.clear();
	country.clear();
	showCountry = 0;
	headBounty = 0;
	hallOfFame = 0;
	mileStoneAward = 0;
	clientDevice = 0;
	userPropertyMsg.clear();
	brandImages.clear();
	altBounty_tournId = 0;
	altBounty_admission.clear();
	altBounty_tChips = 0;
	earlyBirdMultiplier = 0;
	earlyBirdMins = 0;
	amountToHeadIfEliminated = 0;
	baseWinIfEliminated = 0;
	maxBonusWinIfEliminated = 0;
}

bool TableClient::publication::TableSubscr_PlayerProfile::equals(const TableSubscr_PlayerProfile& _o) const
{
	return Atf::atfPStringEquals(user, _o.user) &&
		Atf::atfPStringEquals(city, _o.city) &&
		imageId == _o.imageId &&
		siteId == _o.siteId &&
		vipStatus == _o.vipStatus &&
		publProp == _o.publProp &&
		bounty == _o.bounty &&
		Atf::atfPStringEquals(promoImageCode, _o.promoImageCode) &&
		Atf::atfPStringEquals(country, _o.country) &&
		showCountry == _o.showCountry &&
		headBounty == _o.headBounty &&
		hallOfFame == _o.hallOfFame &&
		mileStoneAward == _o.mileStoneAward &&
		clientDevice == _o.clientDevice &&
		userPropertyMsg.equals(_o.userPropertyMsg) &&
		brandImages.equals(_o.brandImages) &&
		altBounty_tournId == _o.altBounty_tournId &&
		Atf::atfPStringEquals(altBounty_admission, _o.altBounty_admission) &&
		altBounty_tChips == _o.altBounty_tChips &&
		earlyBirdMultiplier == _o.earlyBirdMultiplier &&
		earlyBirdMins == _o.earlyBirdMins &&
		amountToHeadIfEliminated == _o.amountToHeadIfEliminated &&
		baseWinIfEliminated == _o.baseWinIfEliminated &&
		maxBonusWinIfEliminated == _o.maxBonusWinIfEliminated;
}

const char *TableClient::publication::TableSubscr_PlayerProfile::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("user=");
	_buf.append(user);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("vipStatus=");
	_buf.appendUint(vipStatus);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendUint(bounty);
	_buf.append(',');
	_buf.append("promoImageCode=");
	_buf.append(promoImageCode);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("showCountry=");
	_buf.appendUint(showCountry);
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendUint(headBounty);
	_buf.append(',');
	_buf.append("hallOfFame=");
	_buf.appendUint(hallOfFame);
	_buf.append(',');
	_buf.append("mileStoneAward=");
	_buf.appendUint(mileStoneAward);
	_buf.append(',');
	_buf.append("clientDevice=");
	_buf.appendUint(clientDevice);
	_buf.append(',');
	_buf.append("userPropertyMsg=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(userPropertyMsg, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("brandImages=");
	brandImages.toTraceString(_buf);
	_buf.append(',');
	_buf.append("altBounty_tournId=");
	_buf.appendUint64(altBounty_tournId);
	_buf.append(',');
	_buf.append("altBounty_admission=");
	_buf.append(altBounty_admission);
	_buf.append(',');
	_buf.append("altBounty_tChips=");
	_buf.appendInt(altBounty_tChips);
	_buf.append(',');
	_buf.append("earlyBirdMultiplier=");
	_buf.appendInt(earlyBirdMultiplier);
	_buf.append(',');
	_buf.append("earlyBirdMins=");
	_buf.appendInt(earlyBirdMins);
	_buf.append(',');
	_buf.append("amountToHeadIfEliminated=");
	_buf.appendInt64(amountToHeadIfEliminated);
	_buf.append(',');
	_buf.append("baseWinIfEliminated=");
	_buf.appendInt64(baseWinIfEliminated);
	_buf.append(',');
	_buf.append("maxBonusWinIfEliminated=");
	_buf.appendInt64(maxBonusWinIfEliminated);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_PlayerProfile::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("user", user, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("vipStatus", vipStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("publProp", publProp, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("promoImageCode", promoImageCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("showCountry", showCountry, _buf);
	Atf::XmlElement::encodeAsXmlElement("headBounty", headBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("hallOfFame", hallOfFame, _buf);
	Atf::XmlElement::encodeAsXmlElement("mileStoneAward", mileStoneAward, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientDevice", clientDevice, _buf);
	Atf::XmlElement::encodeAsXmlElement("userPropertyMsg", userPropertyMsg, _buf);
	brandImages.toXmlString("brandImages", _buf);
	Atf::XmlElement::encodeAsXmlElement("altBounty_tournId", altBounty_tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("altBounty_admission", altBounty_admission, _buf);
	Atf::XmlElement::encodeAsXmlElement("altBounty_tChips", altBounty_tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("earlyBirdMultiplier", earlyBirdMultiplier, _buf);
	Atf::XmlElement::encodeAsXmlElement("earlyBirdMins", earlyBirdMins, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountToHeadIfEliminated", amountToHeadIfEliminated, _buf);
	Atf::XmlElement::encodeAsXmlElement("baseWinIfEliminated", baseWinIfEliminated, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBonusWinIfEliminated", maxBonusWinIfEliminated, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_PlayerProfile::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("user"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, user)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vipStatus"))
		{
			vipStatus = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publProp"))
		{
			publProp = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("promoImageCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, promoImageCode)) return false;
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("showCountry"))
		{
			showCountry = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("headBounty"))
		{
			headBounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hallOfFame"))
		{
			hallOfFame = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mileStoneAward"))
		{
			mileStoneAward = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clientDevice"))
		{
			clientDevice = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userPropertyMsg"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, userPropertyMsg)) return false;
		}
		else if (_element.equals("brandImages"))
		{
			if(!Atf::AtfTempl< BrandProt::BrandImageList >::FromXmlString(_value, brandImages)) return false;
		}
		else if (_element.equals("altBounty_tournId"))
		{
			altBounty_tournId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("altBounty_admission"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, altBounty_admission)) return false;
		}
		else if (_element.equals("altBounty_tChips"))
		{
			altBounty_tChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("earlyBirdMultiplier"))
		{
			earlyBirdMultiplier = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("earlyBirdMins"))
		{
			earlyBirdMins = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amountToHeadIfEliminated"))
		{
			amountToHeadIfEliminated = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("baseWinIfEliminated"))
		{
			baseWinIfEliminated = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBonusWinIfEliminated"))
		{
			maxBonusWinIfEliminated = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_PlayerProfile::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(user);
	_msg.composeString(city);
	_msg.composeUINT32(imageId);
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(vipStatus);
	_msg.composeBYTE(publProp);
	_msg.composeUINT32(bounty);
	_msg.composeString(promoImageCode);
	_msg.composeString(country);
	_msg.composeBYTE(showCountry);
	_msg.composeUINT32(headBounty);
	_msg.composeUINT32(hallOfFame);
	_msg.composeUINT32(mileStoneAward);
	_msg.composeUINT32(clientDevice);
	_msg.composeMsgBody(userPropertyMsg);
	brandImages.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT64(altBounty_tournId);
	_msg.composeString(altBounty_admission);
	_msg.composeINT32(altBounty_tChips);
	_msg.composeINT32(earlyBirdMultiplier);
	_msg.composeINT32(earlyBirdMins);
	_msg.composeINT64(amountToHeadIfEliminated);
	_msg.composeINT64(baseWinIfEliminated);
	_msg.composeINT64(maxBonusWinIfEliminated);
}

void TableClient::publication::TableSubscr_PlayerProfile::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(user);
	_parser.parseStringP(city);
	_parser.parseUINT32(imageId);
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(vipStatus);
	_parser.parseBYTE(publProp);
	_parser.parseUINT32(bounty);
	_parser.parseStringP(promoImageCode);
	_parser.parseStringP(country);
	_parser.parseBYTE(showCountry);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(headBounty);
	_parser.parseUINT32(hallOfFame);
	_parser.parseUINT32(mileStoneAward);
	_parser.parseUINT32(clientDevice);
	_parser.parseMsgBody(userPropertyMsg);
	brandImages.parseMsg(_parser);
	_parser.parseUINT64(altBounty_tournId);
	_parser.parseStringP(altBounty_admission);
	_parser.parseINT32(altBounty_tChips);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(earlyBirdMultiplier);
	_parser.parseINT32(earlyBirdMins);
	if(_parser.parseEnded()) return;
	_parser.parseINT64(amountToHeadIfEliminated);
	_parser.parseINT64(baseWinIfEliminated);
	_parser.parseINT64(maxBonusWinIfEliminated);
}

const char *TableClient::publication::TableSubscr_PlayerProfile::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("user", user);
	_jsonstr.compose("city", city);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("vipStatus", vipStatus);
	_jsonstr.compose("publProp", publProp);
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("promoImageCode", promoImageCode);
	_jsonstr.compose("country", country);
	_jsonstr.compose("showCountry", showCountry);
	_jsonstr.compose("headBounty", headBounty);
	_jsonstr.compose("hallOfFame", hallOfFame);
	_jsonstr.compose("mileStoneAward", mileStoneAward);
	_jsonstr.compose("clientDevice", clientDevice);
	_jsonstr.compose("userPropertyMsg", userPropertyMsg);
	_jsonstr.compose("brandImages", brandImages);
	_jsonstr.compose("altBounty_tournId", altBounty_tournId);
	_jsonstr.compose("altBounty_admission", altBounty_admission);
	_jsonstr.compose("altBounty_tChips", altBounty_tChips);
	_jsonstr.compose("earlyBirdMultiplier", earlyBirdMultiplier);
	_jsonstr.compose("earlyBirdMins", earlyBirdMins);
	_jsonstr.compose("amountToHeadIfEliminated", amountToHeadIfEliminated);
	_jsonstr.compose("baseWinIfEliminated", baseWinIfEliminated);
	_jsonstr.compose("maxBonusWinIfEliminated", maxBonusWinIfEliminated);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_PlayerProfile::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("user", user);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("vipStatus", vipStatus);
	_jparser.parseByNameThrow("publProp", publProp);
	_jparser.parseByNameThrow("bounty", bounty);
	_jparser.parseByNameThrow("promoImageCode", promoImageCode);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("showCountry", showCountry);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("headBounty", headBounty);
	_jparser.parseByNameThrow("hallOfFame", hallOfFame);
	_jparser.parseByNameThrow("mileStoneAward", mileStoneAward);
	_jparser.parseByNameThrow("clientDevice", clientDevice);
	_jparser.parseByNameThrow("userPropertyMsg", userPropertyMsg);
	_jparser.parseByNameThrow("brandImages", brandImages);
	_jparser.parseByNameThrow("altBounty_tournId", altBounty_tournId);
	_jparser.parseByNameThrow("altBounty_admission", altBounty_admission);
	_jparser.parseByNameThrow("altBounty_tChips", altBounty_tChips);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("earlyBirdMultiplier", earlyBirdMultiplier);
	_jparser.parseByNameThrow("earlyBirdMins", earlyBirdMins);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("amountToHeadIfEliminated", amountToHeadIfEliminated);
	_jparser.parseByNameThrow("baseWinIfEliminated", baseWinIfEliminated);
	_jparser.parseByNameThrow("maxBonusWinIfEliminated", maxBonusWinIfEliminated);
}

/* static */ void TableClient::publication::TableSubscr_PlayerProfile::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString user; _jparser.validateByNameThrow("user", user);
	AtfValidator::validateInt(_descr, "user", user.length(), _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
	UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 vipStatus; _jparser.validateByNameThrow("vipStatus", vipStatus);
	AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
	BYTE publProp; _jparser.validateByNameThrow("publProp", publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 bounty; _jparser.validateByNameThrow("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	PString promoImageCode; _jparser.validateByNameThrow("promoImageCode", promoImageCode);
	AtfValidator::validateInt(_descr, "promoImageCode", promoImageCode.length(), _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	BYTE showCountry; _jparser.validateByNameThrow("showCountry", showCountry);
	AtfValidator::validateInt(_descr, "showCountry", showCountry, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 headBounty; _jparser.validateByNameThrow("headBounty", headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	UINT32 hallOfFame; _jparser.validateByNameThrow("hallOfFame", hallOfFame);
	AtfValidator::validateInt(_descr, "hallOfFame", hallOfFame, _checker, __FILE__, __LINE__);
	UINT32 mileStoneAward; _jparser.validateByNameThrow("mileStoneAward", mileStoneAward);
	AtfValidator::validateInt(_descr, "mileStoneAward", mileStoneAward, _checker, __FILE__, __LINE__);
	UINT32 clientDevice; _jparser.validateByNameThrow("clientDevice", clientDevice);
	AtfValidator::validateInt(_descr, "clientDevice", clientDevice, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody userPropertyMsg; _jparser.validateByNameThrow("userPropertyMsg", userPropertyMsg);
	AtfValidator::validateInt(_descr, "userPropertyMsg", userPropertyMsg._size(), _checker, __FILE__, __LINE__);
	BrandProt::BrandImageList brandImages; _jparser.validateByNameThrow("brandImages", brandImages);
	UINT64 altBounty_tournId; _jparser.validateByNameThrow("altBounty_tournId", altBounty_tournId);
	AtfValidator::validateUint(_descr, "altBounty_tournId", altBounty_tournId, _checker, __FILE__, __LINE__);
	PString altBounty_admission; _jparser.validateByNameThrow("altBounty_admission", altBounty_admission);
	AtfValidator::validateInt(_descr, "altBounty_admission", altBounty_admission.length(), _checker, __FILE__, __LINE__);
	INT32 altBounty_tChips; _jparser.validateByNameThrow("altBounty_tChips", altBounty_tChips);
	AtfValidator::validateInt(_descr, "altBounty_tChips", altBounty_tChips, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 earlyBirdMultiplier; _jparser.validateByNameThrow("earlyBirdMultiplier", earlyBirdMultiplier);
	AtfValidator::validateInt(_descr, "earlyBirdMultiplier", earlyBirdMultiplier, _checker, __FILE__, __LINE__);
	INT32 earlyBirdMins; _jparser.validateByNameThrow("earlyBirdMins", earlyBirdMins);
	AtfValidator::validateInt(_descr, "earlyBirdMins", earlyBirdMins, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT64 amountToHeadIfEliminated; _jparser.validateByNameThrow("amountToHeadIfEliminated", amountToHeadIfEliminated);
	AtfValidator::validateInt(_descr, "amountToHeadIfEliminated", amountToHeadIfEliminated, _checker, __FILE__, __LINE__);
	INT64 baseWinIfEliminated; _jparser.validateByNameThrow("baseWinIfEliminated", baseWinIfEliminated);
	AtfValidator::validateInt(_descr, "baseWinIfEliminated", baseWinIfEliminated, _checker, __FILE__, __LINE__);
	INT64 maxBonusWinIfEliminated; _jparser.validateByNameThrow("maxBonusWinIfEliminated", maxBonusWinIfEliminated);
	AtfValidator::validateInt(_descr, "maxBonusWinIfEliminated", maxBonusWinIfEliminated, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_PlayerProfile::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "user"); size_t szUser = strlen(_dummy);
	AtfValidator::validateInt(_descr, "user", szUser, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	UINT32 imageId; _parser.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 vipStatus; _parser.parseUINT32(vipStatus);
	AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 bounty; _parser.parseUINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "promoImageCode"); size_t szPromoImageCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "promoImageCode", szPromoImageCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	BYTE showCountry; _parser.parseBYTE(showCountry);
	AtfValidator::validateInt(_descr, "showCountry", showCountry, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 headBounty; _parser.parseUINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	UINT32 hallOfFame; _parser.parseUINT32(hallOfFame);
	AtfValidator::validateInt(_descr, "hallOfFame", hallOfFame, _checker, __FILE__, __LINE__);
	UINT32 mileStoneAward; _parser.parseUINT32(mileStoneAward);
	AtfValidator::validateInt(_descr, "mileStoneAward", mileStoneAward, _checker, __FILE__, __LINE__);
	UINT32 clientDevice; _parser.parseUINT32(clientDevice);
	AtfValidator::validateInt(_descr, "clientDevice", clientDevice, _checker, __FILE__, __LINE__);
	size_t szUserPropertyMsg; _parser.skipMsgBody(szUserPropertyMsg);  /*userPropertyMsg*/
	AtfValidator::validateInt(_descr, "userPropertyMsg", szUserPropertyMsg, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BrandProt::BrandImageList::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("brandImages"), _fieldsWithUnparsedContent);
	UINT64 altBounty_tournId; _parser.parseUINT64(altBounty_tournId);
	AtfValidator::validateUint(_descr, "altBounty_tournId", altBounty_tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "altBounty_admission"); size_t szAltBounty_admission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "altBounty_admission", szAltBounty_admission, _checker, __FILE__, __LINE__);
	INT32 altBounty_tChips; _parser.parseINT32(altBounty_tChips);
	AtfValidator::validateInt(_descr, "altBounty_tChips", altBounty_tChips, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 earlyBirdMultiplier; _parser.parseINT32(earlyBirdMultiplier);
	AtfValidator::validateInt(_descr, "earlyBirdMultiplier", earlyBirdMultiplier, _checker, __FILE__, __LINE__);
	INT32 earlyBirdMins; _parser.parseINT32(earlyBirdMins);
	AtfValidator::validateInt(_descr, "earlyBirdMins", earlyBirdMins, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT64 amountToHeadIfEliminated; _parser.parseINT64(amountToHeadIfEliminated);
	AtfValidator::validateInt(_descr, "amountToHeadIfEliminated", amountToHeadIfEliminated, _checker, __FILE__, __LINE__);
	INT64 baseWinIfEliminated; _parser.parseINT64(baseWinIfEliminated);
	AtfValidator::validateInt(_descr, "baseWinIfEliminated", baseWinIfEliminated, _checker, __FILE__, __LINE__);
	INT64 maxBonusWinIfEliminated; _parser.parseINT64(maxBonusWinIfEliminated);
	AtfValidator::validateInt(_descr, "maxBonusWinIfEliminated", maxBonusWinIfEliminated, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PowerOnCard
//=================================================================

TableClient::publication::PowerOnCard::PowerOnCard()
{
	clear();
}

void TableClient::publication::PowerOnCard::clear()
{
	powerId = 0;
	powerPlayer = 0;
}

bool TableClient::publication::PowerOnCard::equals(const PowerOnCard& _o) const
{
	return powerId == _o.powerId &&
		powerPlayer == _o.powerPlayer;
}

const char *TableClient::publication::PowerOnCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("powerPlayer=");
	_buf.appendUint(powerPlayer);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::PowerOnCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("powerPlayer", powerPlayer, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::PowerOnCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pI") || _element.equals("powerId"))
		{
			powerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powerPlayer"))
		{
			powerPlayer = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::PowerOnCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PowerOnCard())) // not empty
	{
		_body.composeINT32(powerId);
		_body.composeBYTE(powerPlayer);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::PowerOnCard::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerId);
	_parser0.parseBYTE(powerPlayer);
}

const char *TableClient::publication::PowerOnCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("powerPlayer", powerPlayer);
	return _buf.c_str();
}

void TableClient::publication::PowerOnCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("powerPlayer", powerPlayer);
}

/* static */ void TableClient::publication::PowerOnCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	BYTE powerPlayer; _jparser.validateByNameThrow("powerPlayer", powerPlayer);
	AtfValidator::validateInt(_descr, "powerPlayer", powerPlayer, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::PowerOnCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 powerId; _parser0.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	BYTE powerPlayer; _parser0.parseBYTE(powerPlayer);
	AtfValidator::validateInt(_descr, "powerPlayer", powerPlayer, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SubscrPlayerCard
//=================================================================

TableClient::publication::SubscrPlayerCard::SubscrPlayerCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::SubscrPlayerCard::SubscrPlayerCard(SubscrPlayerCard&& _o)
	: showFlag(std::move(_o.showFlag))
	, cardOrIndex(std::move(_o.cardOrIndex))
	, visibilityMask(std::move(_o.visibilityMask))
	, powers(std::move(_o.powers))
{
}

TableClient::publication::SubscrPlayerCard& TableClient::publication::SubscrPlayerCard::operator=(SubscrPlayerCard&& _o)
{
	if(this != &_o)
	{
		showFlag = std::move(_o.showFlag);
		cardOrIndex = std::move(_o.cardOrIndex);
		visibilityMask = std::move(_o.visibilityMask);
		powers = std::move(_o.powers);
	}
	return *this;
}

#endif

void TableClient::publication::SubscrPlayerCard::clear()
{
	showFlag = 0;
	cardOrIndex.clear();
	visibilityMask = 0;
	powers.clear();
}

bool TableClient::publication::SubscrPlayerCard::equals(const SubscrPlayerCard& _o) const
{
	return showFlag == _o.showFlag &&
		cardOrIndex.equals(_o.cardOrIndex) &&
		visibilityMask == _o.visibilityMask &&
		powers.equals(_o.powers);
}

const char *TableClient::publication::SubscrPlayerCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("showFlag=");
	_buf.appendUint(showFlag);
	_buf.append(',');
	_buf.append("cardOrIndex=");
	cardOrIndex.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendInt(visibilityMask);
	_buf.append(',');
	_buf.append("powers=");
	powers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::SubscrPlayerCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("showFlag", showFlag, _buf);
	cardOrIndex.toXmlString("cardOrIndex", _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	powers.toXmlString("powers", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::SubscrPlayerCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("showFlag"))
		{
			showFlag = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cardOrIndex"))
		{
			if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, cardOrIndex)) return false;
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PowerOnCard, 1 > >::FromXmlString(_value, powers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::SubscrPlayerCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SubscrPlayerCard())) // not empty
	{
		_body.composeBYTE(showFlag);
		cardOrIndex.composeMsg(_body, _ignoreJSON);
		_body.composeINT16(visibilityMask);
		powers.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::SubscrPlayerCard::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(showFlag);
	cardOrIndex.parseMsg(_parser0);
	_parser0.parseINT16(visibilityMask);
	powers.parseMsg(_parser0);
}

const char *TableClient::publication::SubscrPlayerCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("showFlag", showFlag);
	_jsonstr.compose("cardOrIndex", cardOrIndex);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("powers", powers);
	return _buf.c_str();
}

void TableClient::publication::SubscrPlayerCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("showFlag", showFlag);
	_jparser.parseByNameThrow("cardOrIndex", cardOrIndex);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("powers", powers);
}

/* static */ void TableClient::publication::SubscrPlayerCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE showFlag; _jparser.validateByNameThrow("showFlag", showFlag);
	AtfValidator::validateInt(_descr, "showFlag", showFlag, _checker, __FILE__, __LINE__);
	TableCommon::P_Card cardOrIndex; _jparser.validateByNameThrow("cardOrIndex", cardOrIndex);
	INT16 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PowerOnCard > powers; _jparser.validateByNameThrow("powers", powers);
	AtfValidator::validateInt(_descr, "powers", powers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::SubscrPlayerCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE showFlag; _parser0.parseBYTE(showFlag);
	AtfValidator::validateInt(_descr, "showFlag", showFlag, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableCommon::P_Card::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cardOrIndex"), _fieldsWithUnparsedContent);
	INT16 visibilityMask; _parser0.parseINT16(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	int szPowers = Atf::LAtfVector< PowerOnCard, 1 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powers", szPowers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableSubscr_PlayerCards_Dict
//=================================================================

TableClient::publication::TableSubscr_PlayerCards_Dict::TableSubscr_PlayerCards_Dict()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TableSubscr_PlayerCards_Dict::TableSubscr_PlayerCards_Dict(TableSubscr_PlayerCards_Dict&& _o)
	: playerCards(std::move(_o.playerCards))
	, numSwapped(std::move(_o.numSwapped))
	, swapRound(std::move(_o.swapRound))
{
}

TableClient::publication::TableSubscr_PlayerCards_Dict& TableClient::publication::TableSubscr_PlayerCards_Dict::operator=(TableSubscr_PlayerCards_Dict&& _o)
{
	if(this != &_o)
	{
		playerCards = std::move(_o.playerCards);
		numSwapped = std::move(_o.numSwapped);
		swapRound = std::move(_o.swapRound);
	}
	return *this;
}

#endif

void TableClient::publication::TableSubscr_PlayerCards_Dict::clear()
{
	playerCards.clear();
	numSwapped = 0;
	swapRound = 0;
}

bool TableClient::publication::TableSubscr_PlayerCards_Dict::equals(const TableSubscr_PlayerCards_Dict& _o) const
{
	return playerCards.equals(_o.playerCards) &&
		numSwapped == _o.numSwapped &&
		swapRound == _o.swapRound;
}

const char *TableClient::publication::TableSubscr_PlayerCards_Dict::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("playerCards=");
	playerCards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("numSwapped=");
	_buf.appendInt(numSwapped);
	_buf.append(',');
	_buf.append("swapRound=");
	_buf.appendInt(swapRound);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_PlayerCards_Dict::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	playerCards.toXmlString("playerCards", _buf);
	Atf::XmlElement::encodeAsXmlElement("numSwapped", numSwapped, _buf);
	Atf::XmlElement::encodeAsXmlElement("swapRound", swapRound, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_PlayerCards_Dict::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("playerCards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SubscrPlayerCard, 1 > >::FromXmlString(_value, playerCards)) return false;
		}
		else if (_element.equals("numSwapped"))
		{
			numSwapped = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("swapRound"))
		{
			swapRound = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_PlayerCards_Dict::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	playerCards.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT8(numSwapped);
	_msg.composeINT8(swapRound);
}

void TableClient::publication::TableSubscr_PlayerCards_Dict::parseMsg(CommMsgParser& _parser)
{
	playerCards.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseINT8(numSwapped);
	_parser.parseINT8(swapRound);
}

const char *TableClient::publication::TableSubscr_PlayerCards_Dict::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playerCards", playerCards);
	_jsonstr.compose("numSwapped", numSwapped);
	_jsonstr.compose("swapRound", swapRound);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_PlayerCards_Dict::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playerCards", playerCards);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("numSwapped", numSwapped);
	_jparser.parseByNameThrow("swapRound", swapRound);
}

/* static */ void TableClient::publication::TableSubscr_PlayerCards_Dict::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< SubscrPlayerCard > playerCards; _jparser.validateByNameThrow("playerCards", playerCards);
	AtfValidator::validateInt(_descr, "playerCards", playerCards.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT8 numSwapped; _jparser.validateByNameThrow("numSwapped", numSwapped);
	AtfValidator::validateInt(_descr, "numSwapped", numSwapped, _checker, __FILE__, __LINE__);
	INT8 swapRound; _jparser.validateByNameThrow("swapRound", swapRound);
	AtfValidator::validateInt(_descr, "swapRound", swapRound, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_PlayerCards_Dict::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szPlayerCards = Atf::LAtfVector< SubscrPlayerCard, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerCards", szPlayerCards, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT8 numSwapped; _parser.parseINT8(numSwapped);
	AtfValidator::validateInt(_descr, "numSwapped", numSwapped, _checker, __FILE__, __LINE__);
	INT8 swapRound; _parser.parseINT8(swapRound);
	AtfValidator::validateInt(_descr, "swapRound", swapRound, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSubscr_AllBoards
//=================================================================

TableClient::publication::TableSubscr_AllBoards::TableSubscr_AllBoards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TableSubscr_AllBoards::TableSubscr_AllBoards(TableSubscr_AllBoards&& _o)
	: allBoards(std::move(_o.allBoards))
{
}

TableClient::publication::TableSubscr_AllBoards& TableClient::publication::TableSubscr_AllBoards::operator=(TableSubscr_AllBoards&& _o)
{
	if(this != &_o)
	{
		allBoards = std::move(_o.allBoards);
	}
	return *this;
}

#endif

void TableClient::publication::TableSubscr_AllBoards::clear()
{
	allBoards.clear();
}

bool TableClient::publication::TableSubscr_AllBoards::equals(const TableSubscr_AllBoards& _o) const
{
	return allBoards.equals(_o.allBoards);
}

const char *TableClient::publication::TableSubscr_AllBoards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("allBoards=");
	allBoards.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_AllBoards::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	allBoards.toXmlString("allBoards", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_AllBoards::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("allBoards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TableSubscr_Board, 1 > >::FromXmlString(_value, allBoards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_AllBoards::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	allBoards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::TableSubscr_AllBoards::parseMsg(CommMsgParser& _parser)
{
	allBoards.parseMsg(_parser);
}

const char *TableClient::publication::TableSubscr_AllBoards::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("allBoards", allBoards);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_AllBoards::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("allBoards", allBoards);
}

/* static */ void TableClient::publication::TableSubscr_AllBoards::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TableSubscr_Board > allBoards; _jparser.validateByNameThrow("allBoards", allBoards);
	AtfValidator::validateInt(_descr, "allBoards", allBoards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_AllBoards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szAllBoards = Atf::LAtfVector< TableSubscr_Board, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("allBoards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "allBoards", szAllBoards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSubscr_Dynamic
//=================================================================

TableClient::publication::TableSubscr_Dynamic::TableSubscr_Dynamic()
{
	clear();
}

void TableClient::publication::TableSubscr_Dynamic::clear()
{
	numPublSubscribers = -1;
}

bool TableClient::publication::TableSubscr_Dynamic::equals(const TableSubscr_Dynamic& _o) const
{
	return numPublSubscribers == _o.numPublSubscribers;
}

const char *TableClient::publication::TableSubscr_Dynamic::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numPublSubscribers=");
	_buf.appendInt(numPublSubscribers);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_Dynamic::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numPublSubscribers", numPublSubscribers, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_Dynamic::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numPublSubscribers"))
		{
			numPublSubscribers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_Dynamic::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(numPublSubscribers);
}

void TableClient::publication::TableSubscr_Dynamic::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(numPublSubscribers);
}

const char *TableClient::publication::TableSubscr_Dynamic::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numPublSubscribers", numPublSubscribers);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_Dynamic::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numPublSubscribers", numPublSubscribers);
}

/* static */ void TableClient::publication::TableSubscr_Dynamic::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numPublSubscribers; _jparser.validateByNameThrow("numPublSubscribers", numPublSubscribers);
	AtfValidator::validateInt(_descr, "numPublSubscribers", numPublSubscribers, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_Dynamic::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 numPublSubscribers; _parser.parseINT32(numPublSubscribers);
	AtfValidator::validateInt(_descr, "numPublSubscribers", numPublSubscribers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableSubscr_AutoDeal
//=================================================================

TableClient::publication::TableSubscr_AutoDeal::TableSubscr_AutoDeal()
{
	clear();
}

void TableClient::publication::TableSubscr_AutoDeal::clear()
{
	autoDealState = 0;
	numInterested = 0;
	numRemaining = 0;
}

bool TableClient::publication::TableSubscr_AutoDeal::equals(const TableSubscr_AutoDeal& _o) const
{
	return autoDealState == _o.autoDealState &&
		numInterested == _o.numInterested &&
		numRemaining == _o.numRemaining;
}

const char *TableClient::publication::TableSubscr_AutoDeal::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("autoDealState=");
	_buf.appendInt(autoDealState);
	_buf.append(',');
	_buf.append("numInterested=");
	_buf.appendInt(numInterested);
	_buf.append(',');
	_buf.append("numRemaining=");
	_buf.appendInt(numRemaining);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TableSubscr_AutoDeal::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("autoDealState", autoDealState, _buf);
	Atf::XmlElement::encodeAsXmlElement("numInterested", numInterested, _buf);
	Atf::XmlElement::encodeAsXmlElement("numRemaining", numRemaining, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TableSubscr_AutoDeal::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("autoDealState"))
		{
			autoDealState = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numInterested"))
		{
			numInterested = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numRemaining"))
		{
			numRemaining = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TableSubscr_AutoDeal::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(autoDealState);
	_msg.composeINT8(numInterested);
	_msg.composeINT8(numRemaining);
}

void TableClient::publication::TableSubscr_AutoDeal::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(autoDealState);
	_parser.parseINT8(numInterested);
	_parser.parseINT8(numRemaining);
}

const char *TableClient::publication::TableSubscr_AutoDeal::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("autoDealState", autoDealState);
	_jsonstr.compose("numInterested", numInterested);
	_jsonstr.compose("numRemaining", numRemaining);
	return _buf.c_str();
}

void TableClient::publication::TableSubscr_AutoDeal::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("autoDealState", autoDealState);
	_jparser.parseByNameThrow("numInterested", numInterested);
	_jparser.parseByNameThrow("numRemaining", numRemaining);
}

/* static */ void TableClient::publication::TableSubscr_AutoDeal::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 autoDealState; _jparser.validateByNameThrow("autoDealState", autoDealState);
	AtfValidator::validateInt(_descr, "autoDealState", autoDealState, _checker, __FILE__, __LINE__);
	INT8 numInterested; _jparser.validateByNameThrow("numInterested", numInterested);
	AtfValidator::validateInt(_descr, "numInterested", numInterested, _checker, __FILE__, __LINE__);
	INT8 numRemaining; _jparser.validateByNameThrow("numRemaining", numRemaining);
	AtfValidator::validateInt(_descr, "numRemaining", numRemaining, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TableSubscr_AutoDeal::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 autoDealState; _parser.parseINT8(autoDealState);
	AtfValidator::validateInt(_descr, "autoDealState", autoDealState, _checker, __FILE__, __LINE__);
	INT8 numInterested; _parser.parseINT8(numInterested);
	AtfValidator::validateInt(_descr, "numInterested", numInterested, _checker, __FILE__, __LINE__);
	INT8 numRemaining; _parser.parseINT8(numRemaining);
	AtfValidator::validateInt(_descr, "numRemaining", numRemaining, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PowerBasicInfo
//=================================================================

TableClient::publication::PowerBasicInfo::PowerBasicInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::PowerBasicInfo::PowerBasicInfo(PowerBasicInfo&& _o)
	: powerId(std::move(_o.powerId))
	, cost(std::move(_o.cost))
	, powerName(std::move(_o.powerName))
	, desc(std::move(_o.desc))
{
}

TableClient::publication::PowerBasicInfo& TableClient::publication::PowerBasicInfo::operator=(PowerBasicInfo&& _o)
{
	if(this != &_o)
	{
		powerId = std::move(_o.powerId);
		cost = std::move(_o.cost);
		powerName = std::move(_o.powerName);
		desc = std::move(_o.desc);
	}
	return *this;
}

#endif

void TableClient::publication::PowerBasicInfo::clear()
{
	powerId = 0;
	cost = 0;
	powerName.clear();
	desc.clear();
}

bool TableClient::publication::PowerBasicInfo::equals(const PowerBasicInfo& _o) const
{
	return powerId == _o.powerId &&
		cost == _o.cost &&
		Atf::atfPStringEquals(powerName, _o.powerName) &&
		Atf::atfPStringEquals(desc, _o.desc);
}

const char *TableClient::publication::PowerBasicInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("cost=");
	_buf.appendInt(cost);
	_buf.append(',');
	_buf.append("powerName=");
	_buf.append(powerName);
	_buf.append(',');
	_buf.append("desc=");
	_buf.append(desc);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::PowerBasicInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("cost", cost, _buf);
	Atf::XmlElement::encodeAsXmlElement("powerName", powerName, _buf);
	Atf::XmlElement::encodeAsXmlElement("desc", desc, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::PowerBasicInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pI") || _element.equals("powerId"))
		{
			powerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cost"))
		{
			cost = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powerName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, powerName)) return false;
		}
		else if (_element.equals("desc"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, desc)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::PowerBasicInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PowerBasicInfo())) // not empty
	{
		_body.composeINT32(powerId);
		_body.composeINT32(cost);
		_body.composeString(powerName);
		_body.composeString(desc);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::PowerBasicInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerId);
	_parser0.parseINT32(cost);
	_parser0.parseStringP(powerName);
	_parser0.parseStringP(desc);
}

const char *TableClient::publication::PowerBasicInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("cost", cost);
	_jsonstr.compose("powerName", powerName);
	_jsonstr.compose("desc", desc);
	return _buf.c_str();
}

void TableClient::publication::PowerBasicInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("cost", cost);
	_jparser.parseByNameThrow("powerName", powerName);
	_jparser.parseByNameThrow("desc", desc);
}

/* static */ void TableClient::publication::PowerBasicInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 cost; _jparser.validateByNameThrow("cost", cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	PString powerName; _jparser.validateByNameThrow("powerName", powerName);
	AtfValidator::validateInt(_descr, "powerName", powerName.length(), _checker, __FILE__, __LINE__);
	PString desc; _jparser.validateByNameThrow("desc", desc);
	AtfValidator::validateInt(_descr, "desc", desc.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::PowerBasicInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 powerId; _parser0.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 cost; _parser0.parseINT32(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "powerName"); size_t szPowerName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "powerName", szPowerName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "desc"); size_t szDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "desc", szDesc, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TablePowerSubscr_PowerList
//=================================================================

TableClient::publication::TablePowerSubscr_PowerList::TablePowerSubscr_PowerList()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TablePowerSubscr_PowerList::TablePowerSubscr_PowerList(TablePowerSubscr_PowerList&& _o)
	: oldPowers(std::move(_o.oldPowers))
	, maxPowersPerPlayer(std::move(_o.maxPowersPerPlayer))
	, numDiscardedPowers(std::move(_o.numDiscardedPowers))
	, powersLimitPerStreet(std::move(_o.powersLimitPerStreet))
	, powersLimitPerHand(std::move(_o.powersLimitPerHand))
	, isManaEnabled(std::move(_o.isManaEnabled))
{
}

TableClient::publication::TablePowerSubscr_PowerList& TableClient::publication::TablePowerSubscr_PowerList::operator=(TablePowerSubscr_PowerList&& _o)
{
	if(this != &_o)
	{
		oldPowers = std::move(_o.oldPowers);
		maxPowersPerPlayer = std::move(_o.maxPowersPerPlayer);
		numDiscardedPowers = std::move(_o.numDiscardedPowers);
		powersLimitPerStreet = std::move(_o.powersLimitPerStreet);
		powersLimitPerHand = std::move(_o.powersLimitPerHand);
		isManaEnabled = std::move(_o.isManaEnabled);
	}
	return *this;
}

#endif

void TableClient::publication::TablePowerSubscr_PowerList::clear()
{
	oldPowers.clear();
	maxPowersPerPlayer = 0;
	numDiscardedPowers = 0;
	powersLimitPerStreet = 0;
	powersLimitPerHand = 0;
	isManaEnabled = false;
}

bool TableClient::publication::TablePowerSubscr_PowerList::equals(const TablePowerSubscr_PowerList& _o) const
{
	return oldPowers.equals(_o.oldPowers) &&
		maxPowersPerPlayer == _o.maxPowersPerPlayer &&
		numDiscardedPowers == _o.numDiscardedPowers &&
		powersLimitPerStreet == _o.powersLimitPerStreet &&
		powersLimitPerHand == _o.powersLimitPerHand &&
		isManaEnabled == _o.isManaEnabled;
}

const char *TableClient::publication::TablePowerSubscr_PowerList::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("oldPowers=");
	oldPowers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxPowersPerPlayer=");
	_buf.appendInt(maxPowersPerPlayer);
	_buf.append(',');
	_buf.append("numDiscardedPowers=");
	_buf.appendInt(numDiscardedPowers);
	_buf.append(',');
	_buf.append("powersLimitPerStreet=");
	_buf.appendInt(powersLimitPerStreet);
	_buf.append(',');
	_buf.append("powersLimitPerHand=");
	_buf.appendInt(powersLimitPerHand);
	_buf.append(',');
	_buf.append("isManaEnabled=");
	_buf.appendUint(isManaEnabled);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_PowerList::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	oldPowers.toXmlString("oldPowers", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPowersPerPlayer", maxPowersPerPlayer, _buf);
	Atf::XmlElement::encodeAsXmlElement("numDiscardedPowers", numDiscardedPowers, _buf);
	Atf::XmlElement::encodeAsXmlElement("powersLimitPerStreet", powersLimitPerStreet, _buf);
	Atf::XmlElement::encodeAsXmlElement("powersLimitPerHand", powersLimitPerHand, _buf);
	Atf::XmlElement::encodeAsXmlElement("isManaEnabled", isManaEnabled, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_PowerList::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("oldPowers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PowerBasicInfo, 4 > >::FromXmlString(_value, oldPowers)) return false;
		}
		else if (_element.equals("maxPowersPerPlayer"))
		{
			maxPowersPerPlayer = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numDiscardedPowers"))
		{
			numDiscardedPowers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powersLimitPerStreet"))
		{
			powersLimitPerStreet = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powersLimitPerHand"))
		{
			powersLimitPerHand = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isManaEnabled"))
		{
			isManaEnabled = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_PowerList::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	oldPowers.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(maxPowersPerPlayer);
	_msg.composeINT32(numDiscardedPowers);
	_msg.composeINT32(powersLimitPerStreet);
	_msg.composeINT32(powersLimitPerHand);
	_msg.composeBOOL(isManaEnabled);
}

void TableClient::publication::TablePowerSubscr_PowerList::parseMsg(CommMsgParser& _parser)
{
	oldPowers.parseMsg(_parser);
	_parser.parseINT32(maxPowersPerPlayer);
	_parser.parseINT32(numDiscardedPowers);
	_parser.parseINT32(powersLimitPerStreet);
	_parser.parseINT32(powersLimitPerHand);
	_parser.parseBOOL(isManaEnabled);
}

const char *TableClient::publication::TablePowerSubscr_PowerList::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("oldPowers", oldPowers);
	_jsonstr.compose("maxPowersPerPlayer", maxPowersPerPlayer);
	_jsonstr.compose("numDiscardedPowers", numDiscardedPowers);
	_jsonstr.compose("powersLimitPerStreet", powersLimitPerStreet);
	_jsonstr.compose("powersLimitPerHand", powersLimitPerHand);
	_jsonstr.compose("isManaEnabled", isManaEnabled);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_PowerList::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("oldPowers", oldPowers);
	_jparser.parseByNameThrow("maxPowersPerPlayer", maxPowersPerPlayer);
	_jparser.parseByNameThrow("numDiscardedPowers", numDiscardedPowers);
	_jparser.parseByNameThrow("powersLimitPerStreet", powersLimitPerStreet);
	_jparser.parseByNameThrow("powersLimitPerHand", powersLimitPerHand);
	_jparser.parseByNameThrow("isManaEnabled", isManaEnabled);
}

/* static */ void TableClient::publication::TablePowerSubscr_PowerList::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PowerBasicInfo > oldPowers; _jparser.validateByNameThrow("oldPowers", oldPowers);
	AtfValidator::validateInt(_descr, "oldPowers", oldPowers.size(), _checker, __FILE__, __LINE__);
	INT32 maxPowersPerPlayer; _jparser.validateByNameThrow("maxPowersPerPlayer", maxPowersPerPlayer);
	AtfValidator::validateInt(_descr, "maxPowersPerPlayer", maxPowersPerPlayer, _checker, __FILE__, __LINE__);
	INT32 numDiscardedPowers; _jparser.validateByNameThrow("numDiscardedPowers", numDiscardedPowers);
	AtfValidator::validateInt(_descr, "numDiscardedPowers", numDiscardedPowers, _checker, __FILE__, __LINE__);
	INT32 powersLimitPerStreet; _jparser.validateByNameThrow("powersLimitPerStreet", powersLimitPerStreet);
	AtfValidator::validateInt(_descr, "powersLimitPerStreet", powersLimitPerStreet, _checker, __FILE__, __LINE__);
	INT32 powersLimitPerHand; _jparser.validateByNameThrow("powersLimitPerHand", powersLimitPerHand);
	AtfValidator::validateInt(_descr, "powersLimitPerHand", powersLimitPerHand, _checker, __FILE__, __LINE__);
	bool isManaEnabled; _jparser.validateByNameThrow("isManaEnabled", isManaEnabled);
	AtfValidator::validateInt(_descr, "isManaEnabled", isManaEnabled, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_PowerList::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szOldPowers = Atf::LAtfVector< PowerBasicInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("oldPowers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "oldPowers", szOldPowers, _checker, __FILE__, __LINE__);
	INT32 maxPowersPerPlayer; _parser.parseINT32(maxPowersPerPlayer);
	AtfValidator::validateInt(_descr, "maxPowersPerPlayer", maxPowersPerPlayer, _checker, __FILE__, __LINE__);
	INT32 numDiscardedPowers; _parser.parseINT32(numDiscardedPowers);
	AtfValidator::validateInt(_descr, "numDiscardedPowers", numDiscardedPowers, _checker, __FILE__, __LINE__);
	INT32 powersLimitPerStreet; _parser.parseINT32(powersLimitPerStreet);
	AtfValidator::validateInt(_descr, "powersLimitPerStreet", powersLimitPerStreet, _checker, __FILE__, __LINE__);
	INT32 powersLimitPerHand; _parser.parseINT32(powersLimitPerHand);
	AtfValidator::validateInt(_descr, "powersLimitPerHand", powersLimitPerHand, _checker, __FILE__, __LINE__);
	bool isManaEnabled; _parser.parseBOOL(isManaEnabled);
	AtfValidator::validateInt(_descr, "isManaEnabled", isManaEnabled, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TablePowerSubscr_PowerPot
//=================================================================

TableClient::publication::TablePowerSubscr_PowerPot::TablePowerSubscr_PowerPot()
{
	clear();
}

void TableClient::publication::TablePowerSubscr_PowerPot::clear()
{
	carryOverAmount = 0;
}

bool TableClient::publication::TablePowerSubscr_PowerPot::equals(const TablePowerSubscr_PowerPot& _o) const
{
	return carryOverAmount == _o.carryOverAmount;
}

const char *TableClient::publication::TablePowerSubscr_PowerPot::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("carryOverAmount=");
	_buf.appendInt(carryOverAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_PowerPot::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("carryOverAmount", carryOverAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_PowerPot::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("carryOverAmount"))
		{
			carryOverAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_PowerPot::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(carryOverAmount);
}

void TableClient::publication::TablePowerSubscr_PowerPot::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(carryOverAmount);
}

const char *TableClient::publication::TablePowerSubscr_PowerPot::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("carryOverAmount", carryOverAmount);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_PowerPot::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("carryOverAmount", carryOverAmount);
}

/* static */ void TableClient::publication::TablePowerSubscr_PowerPot::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 carryOverAmount; _jparser.validateByNameThrow("carryOverAmount", carryOverAmount);
	AtfValidator::validateInt(_descr, "carryOverAmount", carryOverAmount, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_PowerPot::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 carryOverAmount; _parser.parseINT32(carryOverAmount);
	AtfValidator::validateInt(_descr, "carryOverAmount", carryOverAmount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardRedealt
//=================================================================

TableClient::publication::CardRedealt::CardRedealt()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::CardRedealt::CardRedealt(CardRedealt&& _o)
	: newCard(std::move(_o.newCard))
	, oldCard(std::move(_o.oldCard))
{
}

TableClient::publication::CardRedealt& TableClient::publication::CardRedealt::operator=(CardRedealt&& _o)
{
	if(this != &_o)
	{
		newCard = std::move(_o.newCard);
		oldCard = std::move(_o.oldCard);
	}
	return *this;
}

#endif

void TableClient::publication::CardRedealt::clear()
{
	newCard.clear();
	oldCard.clear();
}

bool TableClient::publication::CardRedealt::equals(const CardRedealt& _o) const
{
	return newCard.equals(_o.newCard) &&
		oldCard.equals(_o.oldCard);
}

const char *TableClient::publication::CardRedealt::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("newCard=");
	newCard.toTraceString(_buf);
	_buf.append(',');
	_buf.append("oldCard=");
	oldCard.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::CardRedealt::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	newCard.toXmlString("newCard", _buf);
	oldCard.toXmlString("oldCard", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::CardRedealt::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("newCard"))
		{
			if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, newCard)) return false;
		}
		else if (_element.equals("oldCard"))
		{
			if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, oldCard)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::CardRedealt::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CardRedealt())) // not empty
	{
		newCard.composeMsg(_body, _ignoreJSON);
		oldCard.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::CardRedealt::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	newCard.parseMsg(_parser0);
	oldCard.parseMsg(_parser0);
}

const char *TableClient::publication::CardRedealt::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("newCard", newCard);
	_jsonstr.compose("oldCard", oldCard);
	return _buf.c_str();
}

void TableClient::publication::CardRedealt::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("newCard", newCard);
	_jparser.parseByNameThrow("oldCard", oldCard);
}

/* static */ void TableClient::publication::CardRedealt::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableCommon::P_Card newCard; _jparser.validateByNameThrow("newCard", newCard);
	TableCommon::P_Card oldCard; _jparser.validateByNameThrow("oldCard", oldCard);
}

/*static*/ void TableClient::publication::CardRedealt::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableCommon::P_Card::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("newCard"), _fieldsWithUnparsedContent);
	TableCommon::P_Card::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("oldCard"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PowerInfoOnBoardCard
//=================================================================

TableClient::publication::PowerInfoOnBoardCard::PowerInfoOnBoardCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::PowerInfoOnBoardCard::PowerInfoOnBoardCard(PowerInfoOnBoardCard&& _o)
	: powers(std::move(_o.powers))
	, flag(std::move(_o.flag))
{
}

TableClient::publication::PowerInfoOnBoardCard& TableClient::publication::PowerInfoOnBoardCard::operator=(PowerInfoOnBoardCard&& _o)
{
	if(this != &_o)
	{
		powers = std::move(_o.powers);
		flag = std::move(_o.flag);
	}
	return *this;
}

#endif

void TableClient::publication::PowerInfoOnBoardCard::clear()
{
	powers.clear();
	flag = 0;
}

bool TableClient::publication::PowerInfoOnBoardCard::equals(const PowerInfoOnBoardCard& _o) const
{
	return powers.equals(_o.powers) &&
		flag == _o.flag;
}

const char *TableClient::publication::PowerInfoOnBoardCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("powers=");
	powers.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flag=");
	_buf.appendInt(flag);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::PowerInfoOnBoardCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	powers.toXmlString("powers", _buf);
	Atf::XmlElement::encodeAsXmlElement("flag", flag, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::PowerInfoOnBoardCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PowerOnCard, 1 > >::FromXmlString(_value, powers)) return false;
		}
		else if (_element.equals("flag"))
		{
			flag = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::PowerInfoOnBoardCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PowerInfoOnBoardCard())) // not empty
	{
		powers.composeMsg(_body, _ignoreJSON);
		_body.composeINT8(flag);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::PowerInfoOnBoardCard::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	powers.parseMsg(_parser0);
	_parser0.parseINT8(flag);
}

const char *TableClient::publication::PowerInfoOnBoardCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("powers", powers);
	_jsonstr.compose("flag", flag);
	return _buf.c_str();
}

void TableClient::publication::PowerInfoOnBoardCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powers", powers);
	_jparser.parseByNameThrow("flag", flag);
}

/* static */ void TableClient::publication::PowerInfoOnBoardCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PowerOnCard > powers; _jparser.validateByNameThrow("powers", powers);
	AtfValidator::validateInt(_descr, "powers", powers.size(), _checker, __FILE__, __LINE__);
	INT8 flag; _jparser.validateByNameThrow("flag", flag);
	AtfValidator::validateInt(_descr, "flag", flag, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::PowerInfoOnBoardCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPowers = Atf::LAtfVector< PowerOnCard, 1 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powers", szPowers, _checker, __FILE__, __LINE__);
	INT8 flag; _parser0.parseINT8(flag);
	AtfValidator::validateInt(_descr, "flag", flag, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TablePowerSubscr_BoardRedealt
//=================================================================

TableClient::publication::TablePowerSubscr_BoardRedealt::TablePowerSubscr_BoardRedealt()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TablePowerSubscr_BoardRedealt::TablePowerSubscr_BoardRedealt(TablePowerSubscr_BoardRedealt&& _o)
	: boardCardChangesOld(std::move(_o.boardCardChangesOld))
	, board1CardsFlagsOld(std::move(_o.board1CardsFlagsOld))
	, board2CardsFlagsOld(std::move(_o.board2CardsFlagsOld))
	, boardCardsStreet(std::move(_o.boardCardsStreet))
	, board1(std::move(_o.board1))
	, board2(std::move(_o.board2))
	, maxBoardWidth(std::move(_o.maxBoardWidth))
{
}

TableClient::publication::TablePowerSubscr_BoardRedealt& TableClient::publication::TablePowerSubscr_BoardRedealt::operator=(TablePowerSubscr_BoardRedealt&& _o)
{
	if(this != &_o)
	{
		boardCardChangesOld = std::move(_o.boardCardChangesOld);
		board1CardsFlagsOld = std::move(_o.board1CardsFlagsOld);
		board2CardsFlagsOld = std::move(_o.board2CardsFlagsOld);
		boardCardsStreet = std::move(_o.boardCardsStreet);
		board1 = std::move(_o.board1);
		board2 = std::move(_o.board2);
		maxBoardWidth = std::move(_o.maxBoardWidth);
	}
	return *this;
}

#endif

void TableClient::publication::TablePowerSubscr_BoardRedealt::clear()
{
	boardCardChangesOld.clear();
	board1CardsFlagsOld.clear();
	board2CardsFlagsOld.clear();
	boardCardsStreet.clear();
	board1.clear();
	board2.clear();
	maxBoardWidth = 0;
}

bool TableClient::publication::TablePowerSubscr_BoardRedealt::equals(const TablePowerSubscr_BoardRedealt& _o) const
{
	return boardCardChangesOld.equals(_o.boardCardChangesOld) &&
		board1CardsFlagsOld.equals(_o.board1CardsFlagsOld) &&
		board2CardsFlagsOld.equals(_o.board2CardsFlagsOld) &&
		boardCardsStreet.equals(_o.boardCardsStreet) &&
		board1.equals(_o.board1) &&
		board2.equals(_o.board2) &&
		maxBoardWidth == _o.maxBoardWidth;
}

const char *TableClient::publication::TablePowerSubscr_BoardRedealt::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("boardCardChangesOld=");
	boardCardChangesOld.toTraceString(_buf);
	_buf.append(',');
	_buf.append("board1CardsFlagsOld=");
	board1CardsFlagsOld.toTraceString(_buf);
	_buf.append(',');
	_buf.append("board2CardsFlagsOld=");
	board2CardsFlagsOld.toTraceString(_buf);
	_buf.append(',');
	_buf.append("boardCardsStreet=");
	boardCardsStreet.toTraceString(_buf);
	_buf.append(',');
	_buf.append("board1=");
	board1.toTraceString(_buf);
	_buf.append(',');
	_buf.append("board2=");
	board2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxBoardWidth=");
	_buf.appendUint(maxBoardWidth);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_BoardRedealt::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	boardCardChangesOld.toXmlString("boardCardChangesOld", _buf);
	board1CardsFlagsOld.toXmlString("board1CardsFlagsOld", _buf);
	board2CardsFlagsOld.toXmlString("board2CardsFlagsOld", _buf);
	boardCardsStreet.toXmlString("boardCardsStreet", _buf);
	board1.toXmlString("board1", _buf);
	board2.toXmlString("board2", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBoardWidth", maxBoardWidth, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_BoardRedealt::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("boardCardChangesOld"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CardRedealt, 1 > >::FromXmlString(_value, boardCardChangesOld)) return false;
		}
		else if (_element.equals("board1CardsFlagsOld"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT8, 1 > >::FromXmlString(_value, board1CardsFlagsOld)) return false;
		}
		else if (_element.equals("board2CardsFlagsOld"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT8, 1 > >::FromXmlString(_value, board2CardsFlagsOld)) return false;
		}
		else if (_element.equals("boardCardsStreet"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT8, 1 > >::FromXmlString(_value, boardCardsStreet)) return false;
		}
		else if (_element.equals("board1"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PowerInfoOnBoardCard, 1 > >::FromXmlString(_value, board1)) return false;
		}
		else if (_element.equals("board2"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PowerInfoOnBoardCard, 1 > >::FromXmlString(_value, board2)) return false;
		}
		else if (_element.equals("maxBoardWidth"))
		{
			maxBoardWidth = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_BoardRedealt::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	boardCardChangesOld.composeMsg(_msg, _ignoreJSON);
	board1CardsFlagsOld.composeMsg(_msg, _ignoreJSON);
	board2CardsFlagsOld.composeMsg(_msg, _ignoreJSON);
	boardCardsStreet.composeMsg(_msg, _ignoreJSON);
	board1.composeMsg(_msg, _ignoreJSON);
	board2.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(maxBoardWidth);
}

void TableClient::publication::TablePowerSubscr_BoardRedealt::parseMsg(CommMsgParser& _parser)
{
	boardCardChangesOld.parseMsg(_parser);
	board1CardsFlagsOld.parseMsg(_parser);
	board2CardsFlagsOld.parseMsg(_parser);
	boardCardsStreet.parseMsg(_parser);
	board1.parseMsg(_parser);
	board2.parseMsg(_parser);
	_parser.parseBYTE(maxBoardWidth);
}

const char *TableClient::publication::TablePowerSubscr_BoardRedealt::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("boardCardChangesOld", boardCardChangesOld);
	_jsonstr.compose("board1CardsFlagsOld", board1CardsFlagsOld);
	_jsonstr.compose("board2CardsFlagsOld", board2CardsFlagsOld);
	_jsonstr.compose("boardCardsStreet", boardCardsStreet);
	_jsonstr.compose("board1", board1);
	_jsonstr.compose("board2", board2);
	_jsonstr.compose("maxBoardWidth", maxBoardWidth);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_BoardRedealt::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("boardCardChangesOld", boardCardChangesOld);
	_jparser.parseByNameThrow("board1CardsFlagsOld", board1CardsFlagsOld);
	_jparser.parseByNameThrow("board2CardsFlagsOld", board2CardsFlagsOld);
	_jparser.parseByNameThrow("boardCardsStreet", boardCardsStreet);
	_jparser.parseByNameThrow("board1", board1);
	_jparser.parseByNameThrow("board2", board2);
	_jparser.parseByNameThrow("maxBoardWidth", maxBoardWidth);
}

/* static */ void TableClient::publication::TablePowerSubscr_BoardRedealt::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< CardRedealt > boardCardChangesOld; _jparser.validateByNameThrow("boardCardChangesOld", boardCardChangesOld);
	AtfValidator::validateInt(_descr, "boardCardChangesOld", boardCardChangesOld.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT8 > board1CardsFlagsOld; _jparser.validateByNameThrow("board1CardsFlagsOld", board1CardsFlagsOld);
	AtfValidator::validateInt(_descr, "board1CardsFlagsOld", board1CardsFlagsOld.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT8 > board2CardsFlagsOld; _jparser.validateByNameThrow("board2CardsFlagsOld", board2CardsFlagsOld);
	AtfValidator::validateInt(_descr, "board2CardsFlagsOld", board2CardsFlagsOld.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT8 > boardCardsStreet; _jparser.validateByNameThrow("boardCardsStreet", boardCardsStreet);
	AtfValidator::validateInt(_descr, "boardCardsStreet", boardCardsStreet.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PowerInfoOnBoardCard > board1; _jparser.validateByNameThrow("board1", board1);
	AtfValidator::validateInt(_descr, "board1", board1.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PowerInfoOnBoardCard > board2; _jparser.validateByNameThrow("board2", board2);
	AtfValidator::validateInt(_descr, "board2", board2.size(), _checker, __FILE__, __LINE__);
	BYTE maxBoardWidth; _jparser.validateByNameThrow("maxBoardWidth", maxBoardWidth);
	AtfValidator::validateInt(_descr, "maxBoardWidth", maxBoardWidth, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_BoardRedealt::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szBoardCardChangesOld = Atf::LAtfVector< CardRedealt, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("boardCardChangesOld"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "boardCardChangesOld", szBoardCardChangesOld, _checker, __FILE__, __LINE__);
	int szBoard1CardsFlagsOld = Atf::LAtfVector< INT8, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("board1CardsFlagsOld"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "board1CardsFlagsOld", szBoard1CardsFlagsOld, _checker, __FILE__, __LINE__);
	int szBoard2CardsFlagsOld = Atf::LAtfVector< INT8, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("board2CardsFlagsOld"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "board2CardsFlagsOld", szBoard2CardsFlagsOld, _checker, __FILE__, __LINE__);
	int szBoardCardsStreet = Atf::LAtfVector< INT8, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("boardCardsStreet"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "boardCardsStreet", szBoardCardsStreet, _checker, __FILE__, __LINE__);
	int szBoard1 = Atf::LAtfVector< PowerInfoOnBoardCard, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("board1"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "board1", szBoard1, _checker, __FILE__, __LINE__);
	int szBoard2 = Atf::LAtfVector< PowerInfoOnBoardCard, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("board2"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "board2", szBoard2, _checker, __FILE__, __LINE__);
	BYTE maxBoardWidth; _parser.parseBYTE(maxBoardWidth);
	AtfValidator::validateInt(_descr, "maxBoardWidth", maxBoardWidth, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TablePowerSubscr_PlayerInfo
//=================================================================

TableClient::publication::TablePowerSubscr_PlayerInfo::TablePowerSubscr_PlayerInfo()
{
	clear();
}

void TableClient::publication::TablePowerSubscr_PlayerInfo::clear()
{
	numPowers = 0;
	currentMana = 0;
	numOfPendingSecrets = 0;
	manaRewards = 0;
}

bool TableClient::publication::TablePowerSubscr_PlayerInfo::equals(const TablePowerSubscr_PlayerInfo& _o) const
{
	return numPowers == _o.numPowers &&
		currentMana == _o.currentMana &&
		numOfPendingSecrets == _o.numOfPendingSecrets &&
		manaRewards == _o.manaRewards;
}

const char *TableClient::publication::TablePowerSubscr_PlayerInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numPowers=");
	_buf.appendUint(numPowers);
	_buf.append(',');
	_buf.append("currentMana=");
	_buf.appendUint(currentMana);
	_buf.append(',');
	_buf.append("numOfPendingSecrets=");
	_buf.appendInt(numOfPendingSecrets);
	_buf.append(',');
	_buf.append("manaRewards=");
	_buf.appendUint(manaRewards);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_PlayerInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numPowers", numPowers, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentMana", currentMana, _buf);
	Atf::XmlElement::encodeAsXmlElement("numOfPendingSecrets", numOfPendingSecrets, _buf);
	Atf::XmlElement::encodeAsXmlElement("manaRewards", manaRewards, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_PlayerInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numPowers"))
		{
			numPowers = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currentMana"))
		{
			currentMana = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numOfPendingSecrets"))
		{
			numOfPendingSecrets = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("manaRewards"))
		{
			manaRewards = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_PlayerInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(numPowers);
	_msg.composeUINT32(currentMana);
	_msg.composeINT8(numOfPendingSecrets);
	_msg.composeUINT32(manaRewards);
}

void TableClient::publication::TablePowerSubscr_PlayerInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(numPowers);
	_parser.parseUINT32(currentMana);
	_parser.parseINT8(numOfPendingSecrets);
	_parser.parseUINT32(manaRewards);
}

const char *TableClient::publication::TablePowerSubscr_PlayerInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numPowers", numPowers);
	_jsonstr.compose("currentMana", currentMana);
	_jsonstr.compose("numOfPendingSecrets", numOfPendingSecrets);
	_jsonstr.compose("manaRewards", manaRewards);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_PlayerInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numPowers", numPowers);
	_jparser.parseByNameThrow("currentMana", currentMana);
	_jparser.parseByNameThrow("numOfPendingSecrets", numOfPendingSecrets);
	_jparser.parseByNameThrow("manaRewards", manaRewards);
}

/* static */ void TableClient::publication::TablePowerSubscr_PlayerInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE numPowers; _jparser.validateByNameThrow("numPowers", numPowers);
	AtfValidator::validateInt(_descr, "numPowers", numPowers, _checker, __FILE__, __LINE__);
	UINT32 currentMana; _jparser.validateByNameThrow("currentMana", currentMana);
	AtfValidator::validateInt(_descr, "currentMana", currentMana, _checker, __FILE__, __LINE__);
	INT8 numOfPendingSecrets; _jparser.validateByNameThrow("numOfPendingSecrets", numOfPendingSecrets);
	AtfValidator::validateInt(_descr, "numOfPendingSecrets", numOfPendingSecrets, _checker, __FILE__, __LINE__);
	UINT32 manaRewards; _jparser.validateByNameThrow("manaRewards", manaRewards);
	AtfValidator::validateInt(_descr, "manaRewards", manaRewards, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_PlayerInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE numPowers; _parser.parseBYTE(numPowers);
	AtfValidator::validateInt(_descr, "numPowers", numPowers, _checker, __FILE__, __LINE__);
	UINT32 currentMana; _parser.parseUINT32(currentMana);
	AtfValidator::validateInt(_descr, "currentMana", currentMana, _checker, __FILE__, __LINE__);
	INT8 numOfPendingSecrets; _parser.parseINT8(numOfPendingSecrets);
	AtfValidator::validateInt(_descr, "numOfPendingSecrets", numOfPendingSecrets, _checker, __FILE__, __LINE__);
	UINT32 manaRewards; _parser.parseUINT32(manaRewards);
	AtfValidator::validateInt(_descr, "manaRewards", manaRewards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TablePowerSubscr_SilenceStateInfo
//=================================================================

TableClient::publication::TablePowerSubscr_SilenceStateInfo::TablePowerSubscr_SilenceStateInfo()
{
	clear();
}

void TableClient::publication::TablePowerSubscr_SilenceStateInfo::clear()
{
	silenceIsOn = false;
	nonSilencedSeatsMask = 0;
}

bool TableClient::publication::TablePowerSubscr_SilenceStateInfo::equals(const TablePowerSubscr_SilenceStateInfo& _o) const
{
	return silenceIsOn == _o.silenceIsOn &&
		nonSilencedSeatsMask == _o.nonSilencedSeatsMask;
}

const char *TableClient::publication::TablePowerSubscr_SilenceStateInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("silenceIsOn=");
	_buf.appendUint(silenceIsOn);
	_buf.append(',');
	_buf.append("nonSilencedSeatsMask=");
	_buf.appendInt(nonSilencedSeatsMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_SilenceStateInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("silenceIsOn", silenceIsOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("nonSilencedSeatsMask", nonSilencedSeatsMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_SilenceStateInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("silenceIsOn"))
		{
			silenceIsOn = (*_value.ptr() == '1');
		}
		else if (_element.equals("nonSilencedSeatsMask"))
		{
			nonSilencedSeatsMask = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_SilenceStateInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(silenceIsOn);
	_msg.composeINT16(nonSilencedSeatsMask);
}

void TableClient::publication::TablePowerSubscr_SilenceStateInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(silenceIsOn);
	_parser.parseINT16(nonSilencedSeatsMask);
}

const char *TableClient::publication::TablePowerSubscr_SilenceStateInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("silenceIsOn", silenceIsOn);
	_jsonstr.compose("nonSilencedSeatsMask", nonSilencedSeatsMask);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_SilenceStateInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("silenceIsOn", silenceIsOn);
	_jparser.parseByNameThrow("nonSilencedSeatsMask", nonSilencedSeatsMask);
}

/* static */ void TableClient::publication::TablePowerSubscr_SilenceStateInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool silenceIsOn; _jparser.validateByNameThrow("silenceIsOn", silenceIsOn);
	AtfValidator::validateInt(_descr, "silenceIsOn", silenceIsOn, _checker, __FILE__, __LINE__);
	INT16 nonSilencedSeatsMask; _jparser.validateByNameThrow("nonSilencedSeatsMask", nonSilencedSeatsMask);
	AtfValidator::validateInt(_descr, "nonSilencedSeatsMask", nonSilencedSeatsMask, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_SilenceStateInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool silenceIsOn; _parser.parseBOOL(silenceIsOn);
	AtfValidator::validateInt(_descr, "silenceIsOn", silenceIsOn, _checker, __FILE__, __LINE__);
	INT16 nonSilencedSeatsMask; _parser.parseINT16(nonSilencedSeatsMask);
	AtfValidator::validateInt(_descr, "nonSilencedSeatsMask", nonSilencedSeatsMask, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TablePowerSubscr_SenseStateInfo
//=================================================================

TableClient::publication::TablePowerSubscr_SenseStateInfo::TablePowerSubscr_SenseStateInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TablePowerSubscr_SenseStateInfo::TablePowerSubscr_SenseStateInfo(TablePowerSubscr_SenseStateInfo&& _o)
	: tokensNum(std::move(_o.tokensNum))
{
}

TableClient::publication::TablePowerSubscr_SenseStateInfo& TableClient::publication::TablePowerSubscr_SenseStateInfo::operator=(TablePowerSubscr_SenseStateInfo&& _o)
{
	if(this != &_o)
	{
		tokensNum = std::move(_o.tokensNum);
	}
	return *this;
}

#endif

void TableClient::publication::TablePowerSubscr_SenseStateInfo::clear()
{
	tokensNum.clear();
}

bool TableClient::publication::TablePowerSubscr_SenseStateInfo::equals(const TablePowerSubscr_SenseStateInfo& _o) const
{
	return tokensNum.equals(_o.tokensNum);
}

const char *TableClient::publication::TablePowerSubscr_SenseStateInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tokensNum=");
	tokensNum.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_SenseStateInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	tokensNum.toXmlString("tokensNum", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_SenseStateInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tokensNum"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT16, 1 > >::FromXmlString(_value, tokensNum)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_SenseStateInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	tokensNum.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::TablePowerSubscr_SenseStateInfo::parseMsg(CommMsgParser& _parser)
{
	tokensNum.parseMsg(_parser);
}

const char *TableClient::publication::TablePowerSubscr_SenseStateInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tokensNum", tokensNum);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_SenseStateInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tokensNum", tokensNum);
}

/* static */ void TableClient::publication::TablePowerSubscr_SenseStateInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT16 > tokensNum; _jparser.validateByNameThrow("tokensNum", tokensNum);
	AtfValidator::validateInt(_descr, "tokensNum", tokensNum.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_SenseStateInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szTokensNum = Atf::LAtfVector< INT16, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tokensNum"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tokensNum", szTokensNum, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TablePowerSubscr_CloakedStateInfo
//=================================================================

TableClient::publication::TablePowerSubscr_CloakedStateInfo::TablePowerSubscr_CloakedStateInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TablePowerSubscr_CloakedStateInfo::TablePowerSubscr_CloakedStateInfo(TablePowerSubscr_CloakedStateInfo&& _o)
	: cloakedSeatsNow(std::move(_o.cloakedSeatsNow))
	, cloakedSeatsPerHand(std::move(_o.cloakedSeatsPerHand))
{
}

TableClient::publication::TablePowerSubscr_CloakedStateInfo& TableClient::publication::TablePowerSubscr_CloakedStateInfo::operator=(TablePowerSubscr_CloakedStateInfo&& _o)
{
	if(this != &_o)
	{
		cloakedSeatsNow = std::move(_o.cloakedSeatsNow);
		cloakedSeatsPerHand = std::move(_o.cloakedSeatsPerHand);
	}
	return *this;
}

#endif

void TableClient::publication::TablePowerSubscr_CloakedStateInfo::clear()
{
	cloakedSeatsNow.clear();
	cloakedSeatsPerHand.clear();
}

bool TableClient::publication::TablePowerSubscr_CloakedStateInfo::equals(const TablePowerSubscr_CloakedStateInfo& _o) const
{
	return cloakedSeatsNow.equals(_o.cloakedSeatsNow) &&
		cloakedSeatsPerHand.equals(_o.cloakedSeatsPerHand);
}

const char *TableClient::publication::TablePowerSubscr_CloakedStateInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cloakedSeatsNow=");
	cloakedSeatsNow.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cloakedSeatsPerHand=");
	cloakedSeatsPerHand.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_CloakedStateInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	cloakedSeatsNow.toXmlString("cloakedSeatsNow", _buf);
	cloakedSeatsPerHand.toXmlString("cloakedSeatsPerHand", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_CloakedStateInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cloakedSeatsNow"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT8, 1 > >::FromXmlString(_value, cloakedSeatsNow)) return false;
		}
		else if (_element.equals("cloakedSeatsPerHand"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT8, 1 > >::FromXmlString(_value, cloakedSeatsPerHand)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_CloakedStateInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	cloakedSeatsNow.composeMsg(_msg, _ignoreJSON);
	cloakedSeatsPerHand.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::TablePowerSubscr_CloakedStateInfo::parseMsg(CommMsgParser& _parser)
{
	cloakedSeatsNow.parseMsg(_parser);
	cloakedSeatsPerHand.parseMsg(_parser);
}

const char *TableClient::publication::TablePowerSubscr_CloakedStateInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cloakedSeatsNow", cloakedSeatsNow);
	_jsonstr.compose("cloakedSeatsPerHand", cloakedSeatsPerHand);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_CloakedStateInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cloakedSeatsNow", cloakedSeatsNow);
	_jparser.parseByNameThrow("cloakedSeatsPerHand", cloakedSeatsPerHand);
}

/* static */ void TableClient::publication::TablePowerSubscr_CloakedStateInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT8 > cloakedSeatsNow; _jparser.validateByNameThrow("cloakedSeatsNow", cloakedSeatsNow);
	AtfValidator::validateInt(_descr, "cloakedSeatsNow", cloakedSeatsNow.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT8 > cloakedSeatsPerHand; _jparser.validateByNameThrow("cloakedSeatsPerHand", cloakedSeatsPerHand);
	AtfValidator::validateInt(_descr, "cloakedSeatsPerHand", cloakedSeatsPerHand.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_CloakedStateInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szCloakedSeatsNow = Atf::LAtfVector< INT8, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cloakedSeatsNow"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cloakedSeatsNow", szCloakedSeatsNow, _checker, __FILE__, __LINE__);
	int szCloakedSeatsPerHand = Atf::LAtfVector< INT8, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cloakedSeatsPerHand"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cloakedSeatsPerHand", szCloakedSeatsPerHand, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardVisibility
//=================================================================

TableClient::publication::CardVisibility::CardVisibility()
{
	clear();
}

void TableClient::publication::CardVisibility::clear()
{
	seat = -1;
	position = 0;
	visibilityMask = 0;
}

bool TableClient::publication::CardVisibility::equals(const CardVisibility& _o) const
{
	return seat == _o.seat &&
		position == _o.position &&
		visibilityMask == _o.visibilityMask;
}

const char *TableClient::publication::CardVisibility::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("s=");
	_buf.appendInt(seat);
	_buf.append(',');
	_buf.append("position=");
	_buf.appendInt(position);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendInt(visibilityMask);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::CardVisibility::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("s", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("position", position, _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::CardVisibility::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("s") || _element.equals("seat"))
		{
			seat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("position"))
		{
			position = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::CardVisibility::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(seat);
	_msg.composeINT8(position);
	_msg.composeINT16(visibilityMask);
}

void TableClient::publication::CardVisibility::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(seat);
	_parser.parseINT8(position);
	_parser.parseINT16(visibilityMask);
}

const char *TableClient::publication::CardVisibility::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("s", seat);
	_jsonstr.compose("position", position);
	_jsonstr.compose("visibilityMask", visibilityMask);
	return _buf.c_str();
}

void TableClient::publication::CardVisibility::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("s", seat)) _jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("position", position);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
}

/* static */ void TableClient::publication::CardVisibility::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 seat; if(!_jparser.validateByName("s", seat)) _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT8 position; _jparser.validateByNameThrow("position", position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	INT16 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::CardVisibility::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 seat; _parser.parseINT8(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	INT8 position; _parser.parseINT8(position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	INT16 visibilityMask; _parser.parseINT16(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SensedCardIndex
//=================================================================

TableClient::publication::SensedCardIndex::SensedCardIndex()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::SensedCardIndex::SensedCardIndex(SensedCardIndex&& _o)
	: cardOrIndex(std::move(_o.cardOrIndex))
	, visibilityMask(std::move(_o.visibilityMask))
	, powers(std::move(_o.powers))
{
}

TableClient::publication::SensedCardIndex& TableClient::publication::SensedCardIndex::operator=(SensedCardIndex&& _o)
{
	if(this != &_o)
	{
		cardOrIndex = std::move(_o.cardOrIndex);
		visibilityMask = std::move(_o.visibilityMask);
		powers = std::move(_o.powers);
	}
	return *this;
}

#endif

void TableClient::publication::SensedCardIndex::clear()
{
	cardOrIndex.clear();
	visibilityMask = 0;
	powers.clear();
}

bool TableClient::publication::SensedCardIndex::equals(const SensedCardIndex& _o) const
{
	return cardOrIndex.equals(_o.cardOrIndex) &&
		visibilityMask == _o.visibilityMask &&
		powers.equals(_o.powers);
}

const char *TableClient::publication::SensedCardIndex::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cardOrIndex=");
	cardOrIndex.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibilityMask=");
	_buf.appendInt(visibilityMask);
	_buf.append(',');
	_buf.append("powers=");
	powers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::SensedCardIndex::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	cardOrIndex.toXmlString("cardOrIndex", _buf);
	Atf::XmlElement::encodeAsXmlElement("visibilityMask", visibilityMask, _buf);
	powers.toXmlString("powers", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::SensedCardIndex::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardOrIndex"))
		{
			if(!Atf::AtfTempl< TableCommon::P_Card >::FromXmlString(_value, cardOrIndex)) return false;
		}
		else if (_element.equals("visibilityMask"))
		{
			visibilityMask = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PowerOnCard, 1 > >::FromXmlString(_value, powers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::SensedCardIndex::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SensedCardIndex())) // not empty
	{
		cardOrIndex.composeMsg(_body, _ignoreJSON);
		_body.composeINT16(visibilityMask);
		powers.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::SensedCardIndex::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	cardOrIndex.parseMsg(_parser0);
	_parser0.parseINT16(visibilityMask);
	powers.parseMsg(_parser0);
}

const char *TableClient::publication::SensedCardIndex::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cardOrIndex", cardOrIndex);
	_jsonstr.compose("visibilityMask", visibilityMask);
	_jsonstr.compose("powers", powers);
	return _buf.c_str();
}

void TableClient::publication::SensedCardIndex::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardOrIndex", cardOrIndex);
	_jparser.parseByNameThrow("visibilityMask", visibilityMask);
	_jparser.parseByNameThrow("powers", powers);
}

/* static */ void TableClient::publication::SensedCardIndex::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableCommon::P_Card cardOrIndex; _jparser.validateByNameThrow("cardOrIndex", cardOrIndex);
	INT16 visibilityMask; _jparser.validateByNameThrow("visibilityMask", visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PowerOnCard > powers; _jparser.validateByNameThrow("powers", powers);
	AtfValidator::validateInt(_descr, "powers", powers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::SensedCardIndex::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableCommon::P_Card::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cardOrIndex"), _fieldsWithUnparsedContent);
	INT16 visibilityMask; _parser0.parseINT16(visibilityMask);
	AtfValidator::validateInt(_descr, "visibilityMask", visibilityMask, _checker, __FILE__, __LINE__);
	int szPowers = Atf::LAtfVector< PowerOnCard, 1 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powers", szPowers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TablePowerSubscr_CardsVisibility
//=================================================================

TableClient::publication::TablePowerSubscr_CardsVisibility::TablePowerSubscr_CardsVisibility()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TablePowerSubscr_CardsVisibility::TablePowerSubscr_CardsVisibility(TablePowerSubscr_CardsVisibility&& _o)
	: visInfo(std::move(_o.visInfo))
	, sensedCards(std::move(_o.sensedCards))
{
}

TableClient::publication::TablePowerSubscr_CardsVisibility& TableClient::publication::TablePowerSubscr_CardsVisibility::operator=(TablePowerSubscr_CardsVisibility&& _o)
{
	if(this != &_o)
	{
		visInfo = std::move(_o.visInfo);
		sensedCards = std::move(_o.sensedCards);
	}
	return *this;
}

#endif

void TableClient::publication::TablePowerSubscr_CardsVisibility::clear()
{
	visInfo.clear();
	sensedCards.clear();
}

bool TableClient::publication::TablePowerSubscr_CardsVisibility::equals(const TablePowerSubscr_CardsVisibility& _o) const
{
	return visInfo.equals(_o.visInfo) &&
		sensedCards.equals(_o.sensedCards);
}

const char *TableClient::publication::TablePowerSubscr_CardsVisibility::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("visInfo=");
	visInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sensedCards=");
	sensedCards.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_CardsVisibility::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	visInfo.toXmlString("visInfo", _buf);
	sensedCards.toXmlString("sensedCards", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_CardsVisibility::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("visInfo"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CardVisibility, 1 > >::FromXmlString(_value, visInfo)) return false;
		}
		else if (_element.equals("sensedCards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SensedCardIndex, 1 > >::FromXmlString(_value, sensedCards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_CardsVisibility::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	visInfo.composeMsg(_msg, _ignoreJSON);
	sensedCards.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::TablePowerSubscr_CardsVisibility::parseMsg(CommMsgParser& _parser)
{
	visInfo.parseMsg(_parser);
	sensedCards.parseMsg(_parser);
}

const char *TableClient::publication::TablePowerSubscr_CardsVisibility::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("visInfo", visInfo);
	_jsonstr.compose("sensedCards", sensedCards);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_CardsVisibility::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("visInfo", visInfo);
	_jparser.parseByNameThrow("sensedCards", sensedCards);
}

/* static */ void TableClient::publication::TablePowerSubscr_CardsVisibility::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< CardVisibility > visInfo; _jparser.validateByNameThrow("visInfo", visInfo);
	AtfValidator::validateInt(_descr, "visInfo", visInfo.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SensedCardIndex > sensedCards; _jparser.validateByNameThrow("sensedCards", sensedCards);
	AtfValidator::validateInt(_descr, "sensedCards", sensedCards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_CardsVisibility::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szVisInfo = Atf::LAtfVector< CardVisibility, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "visInfo", szVisInfo, _checker, __FILE__, __LINE__);
	int szSensedCards = Atf::LAtfVector< SensedCardIndex, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sensedCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sensedCards", szSensedCards, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TablePowerSubscr_PowerStateInfo
//=================================================================

TableClient::publication::TablePowerSubscr_PowerStateInfo::TablePowerSubscr_PowerStateInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TablePowerSubscr_PowerStateInfo::TablePowerSubscr_PowerStateInfo(TablePowerSubscr_PowerStateInfo&& _o)
	: powerId(std::move(_o.powerId))
	, isActive(std::move(_o.isActive))
	, playerSeat(std::move(_o.playerSeat))
	, extInfo(std::move(_o.extInfo))
{
}

TableClient::publication::TablePowerSubscr_PowerStateInfo& TableClient::publication::TablePowerSubscr_PowerStateInfo::operator=(TablePowerSubscr_PowerStateInfo&& _o)
{
	if(this != &_o)
	{
		powerId = std::move(_o.powerId);
		isActive = std::move(_o.isActive);
		playerSeat = std::move(_o.playerSeat);
		extInfo = std::move(_o.extInfo);
	}
	return *this;
}

#endif

void TableClient::publication::TablePowerSubscr_PowerStateInfo::clear()
{
	powerId = 0;
	isActive = false;
	playerSeat = 0;
	extInfo.clear();
}

bool TableClient::publication::TablePowerSubscr_PowerStateInfo::equals(const TablePowerSubscr_PowerStateInfo& _o) const
{
	return powerId == _o.powerId &&
		isActive == _o.isActive &&
		playerSeat == _o.playerSeat &&
		extInfo.equals(_o.extInfo);
}

const char *TableClient::publication::TablePowerSubscr_PowerStateInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("isActive=");
	_buf.appendUint(isActive);
	_buf.append(',');
	_buf.append("playerSeat=");
	_buf.appendInt(playerSeat);
	_buf.append(',');
	_buf.append("extInfo=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(extInfo, _buf); _buf.append('}');
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_PowerStateInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isActive", isActive, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerSeat", playerSeat, _buf);
	Atf::XmlElement::encodeAsXmlElement("extInfo", extInfo, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_PowerStateInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pI") || _element.equals("powerId"))
		{
			powerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isActive"))
		{
			isActive = (*_value.ptr() == '1');
		}
		else if (_element.equals("playerSeat"))
		{
			playerSeat = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("extInfo"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, extInfo)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_PowerStateInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(powerId);
	_msg.composeBOOL(isActive);
	_msg.composeINT8(playerSeat);
	_msg.composeMsgBody(extInfo);
}

void TableClient::publication::TablePowerSubscr_PowerStateInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(powerId);
	_parser.parseBOOL(isActive);
	_parser.parseINT8(playerSeat);
	_parser.parseMsgBody(extInfo);
}

const char *TableClient::publication::TablePowerSubscr_PowerStateInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("isActive", isActive);
	_jsonstr.compose("playerSeat", playerSeat);
	_jsonstr.compose("extInfo", extInfo);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_PowerStateInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("isActive", isActive);
	_jparser.parseByNameThrow("playerSeat", playerSeat);
	_jparser.parseByNameThrow("extInfo", extInfo);
}

/* static */ void TableClient::publication::TablePowerSubscr_PowerStateInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	bool isActive; _jparser.validateByNameThrow("isActive", isActive);
	AtfValidator::validateInt(_descr, "isActive", isActive, _checker, __FILE__, __LINE__);
	INT8 playerSeat; _jparser.validateByNameThrow("playerSeat", playerSeat);
	AtfValidator::validateInt(_descr, "playerSeat", playerSeat, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody extInfo; _jparser.validateByNameThrow("extInfo", extInfo);
	AtfValidator::validateInt(_descr, "extInfo", extInfo._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_PowerStateInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 powerId; _parser.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	bool isActive; _parser.parseBOOL(isActive);
	AtfValidator::validateInt(_descr, "isActive", isActive, _checker, __FILE__, __LINE__);
	INT8 playerSeat; _parser.parseINT8(playerSeat);
	AtfValidator::validateInt(_descr, "playerSeat", playerSeat, _checker, __FILE__, __LINE__);
	size_t szExtInfo; _parser.skipMsgBody(szExtInfo);  /*extInfo*/
	AtfValidator::validateInt(_descr, "extInfo", szExtInfo, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    PowerIndicator
//=================================================================

TableClient::publication::PowerIndicator::PowerIndicator()
{
	clear();
}

void TableClient::publication::PowerIndicator::clear()
{
	powerId = 0;
	powerCardUniqueId = 0;
	powerPlayer = 0;
}

bool TableClient::publication::PowerIndicator::equals(const PowerIndicator& _o) const
{
	return powerId == _o.powerId &&
		powerCardUniqueId == _o.powerCardUniqueId &&
		powerPlayer == _o.powerPlayer;
}

const char *TableClient::publication::PowerIndicator::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("powerCardUniqueId=");
	_buf.appendInt(powerCardUniqueId);
	_buf.append(',');
	_buf.append("powerPlayer=");
	_buf.appendUint(powerPlayer);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::PowerIndicator::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("powerCardUniqueId", powerCardUniqueId, _buf);
	Atf::XmlElement::encodeAsXmlElement("powerPlayer", powerPlayer, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::PowerIndicator::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pI") || _element.equals("powerId"))
		{
			powerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powerCardUniqueId"))
		{
			powerCardUniqueId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powerPlayer"))
		{
			powerPlayer = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::PowerIndicator::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PowerIndicator())) // not empty
	{
		_body.composeINT32(powerId);
		_body.composeINT32(powerCardUniqueId);
		_body.composeBYTE(powerPlayer);
	}

	_msg.composeMsgBody(_body);
}

void TableClient::publication::PowerIndicator::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerId);
	_parser0.parseINT32(powerCardUniqueId);
	_parser0.parseBYTE(powerPlayer);
}

const char *TableClient::publication::PowerIndicator::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("powerCardUniqueId", powerCardUniqueId);
	_jsonstr.compose("powerPlayer", powerPlayer);
	return _buf.c_str();
}

void TableClient::publication::PowerIndicator::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("powerCardUniqueId", powerCardUniqueId);
	_jparser.parseByNameThrow("powerPlayer", powerPlayer);
}

/* static */ void TableClient::publication::PowerIndicator::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 powerCardUniqueId; _jparser.validateByNameThrow("powerCardUniqueId", powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	BYTE powerPlayer; _jparser.validateByNameThrow("powerPlayer", powerPlayer);
	AtfValidator::validateInt(_descr, "powerPlayer", powerPlayer, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::PowerIndicator::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 powerId; _parser0.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 powerCardUniqueId; _parser0.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	BYTE powerPlayer; _parser0.parseBYTE(powerPlayer);
	AtfValidator::validateInt(_descr, "powerPlayer", powerPlayer, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TablePowerSubscr_PowerIndicators
//=================================================================

TableClient::publication::TablePowerSubscr_PowerIndicators::TablePowerSubscr_PowerIndicators()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TablePowerSubscr_PowerIndicators::TablePowerSubscr_PowerIndicators(TablePowerSubscr_PowerIndicators&& _o)
	: powers(std::move(_o.powers))
{
}

TableClient::publication::TablePowerSubscr_PowerIndicators& TableClient::publication::TablePowerSubscr_PowerIndicators::operator=(TablePowerSubscr_PowerIndicators&& _o)
{
	if(this != &_o)
	{
		powers = std::move(_o.powers);
	}
	return *this;
}

#endif

void TableClient::publication::TablePowerSubscr_PowerIndicators::clear()
{
	powers.clear();
}

bool TableClient::publication::TablePowerSubscr_PowerIndicators::equals(const TablePowerSubscr_PowerIndicators& _o) const
{
	return powers.equals(_o.powers);
}

const char *TableClient::publication::TablePowerSubscr_PowerIndicators::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("powers=");
	powers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_PowerIndicators::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	powers.toXmlString("powers", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_PowerIndicators::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PowerIndicator, 1 > >::FromXmlString(_value, powers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_PowerIndicators::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	powers.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::TablePowerSubscr_PowerIndicators::parseMsg(CommMsgParser& _parser)
{
	powers.parseMsg(_parser);
}

const char *TableClient::publication::TablePowerSubscr_PowerIndicators::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("powers", powers);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_PowerIndicators::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powers", powers);
}

/* static */ void TableClient::publication::TablePowerSubscr_PowerIndicators::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PowerIndicator > powers; _jparser.validateByNameThrow("powers", powers);
	AtfValidator::validateInt(_descr, "powers", powers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_PowerIndicators::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szPowers = Atf::LAtfVector< PowerIndicator, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powers", szPowers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TablePowerSubscr_PowerInfo
//=================================================================

TableClient::publication::TablePowerSubscr_PowerInfo::TablePowerSubscr_PowerInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::TablePowerSubscr_PowerInfo::TablePowerSubscr_PowerInfo(TablePowerSubscr_PowerInfo&& _o)
	: powerId(std::move(_o.powerId))
	, cost(std::move(_o.cost))
	, paramBody(std::move(_o.paramBody))
{
}

TableClient::publication::TablePowerSubscr_PowerInfo& TableClient::publication::TablePowerSubscr_PowerInfo::operator=(TablePowerSubscr_PowerInfo&& _o)
{
	if(this != &_o)
	{
		powerId = std::move(_o.powerId);
		cost = std::move(_o.cost);
		paramBody = std::move(_o.paramBody);
	}
	return *this;
}

#endif

void TableClient::publication::TablePowerSubscr_PowerInfo::clear()
{
	powerId = 0;
	cost = 0;
	paramBody.clear();
}

bool TableClient::publication::TablePowerSubscr_PowerInfo::equals(const TablePowerSubscr_PowerInfo& _o) const
{
	return powerId == _o.powerId &&
		cost == _o.cost &&
		paramBody.equals(_o.paramBody);
}

const char *TableClient::publication::TablePowerSubscr_PowerInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pI=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("cost=");
	_buf.appendInt(cost);
	_buf.append(',');
	_buf.append("paramBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(paramBody, _buf); _buf.append('}');
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_PowerInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pI", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("cost", cost, _buf);
	Atf::XmlElement::encodeAsXmlElement("paramBody", paramBody, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_PowerInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pI") || _element.equals("powerId"))
		{
			powerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cost"))
		{
			cost = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("paramBody"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, paramBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_PowerInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(powerId);
	_msg.composeINT32(cost);
	_msg.composeMsgBody(paramBody);
}

void TableClient::publication::TablePowerSubscr_PowerInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(powerId);
	_parser.parseINT32(cost);
	_parser.parseMsgBody(paramBody);
}

const char *TableClient::publication::TablePowerSubscr_PowerInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pI", powerId);
	_jsonstr.compose("cost", cost);
	_jsonstr.compose("paramBody", paramBody);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_PowerInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("pI", powerId)) _jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("cost", cost);
	_jparser.parseByNameThrow("paramBody", paramBody);
}

/* static */ void TableClient::publication::TablePowerSubscr_PowerInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; if(!_jparser.validateByName("pI", powerId)) _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 cost; _jparser.validateByNameThrow("cost", cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody paramBody; _jparser.validateByNameThrow("paramBody", paramBody);
	AtfValidator::validateInt(_descr, "paramBody", paramBody._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_PowerInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 powerId; _parser.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	INT32 cost; _parser.parseINT32(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	size_t szParamBody; _parser.skipMsgBody(szParamBody);  /*paramBody*/
	AtfValidator::validateInt(_descr, "paramBody", szParamBody, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TablePowerSubscr_PowerMouseOver
//=================================================================

TableClient::publication::TablePowerSubscr_PowerMouseOver::TablePowerSubscr_PowerMouseOver()
{
	clear();
}

void TableClient::publication::TablePowerSubscr_PowerMouseOver::clear()
{
	position = 0;
}

bool TableClient::publication::TablePowerSubscr_PowerMouseOver::equals(const TablePowerSubscr_PowerMouseOver& _o) const
{
	return position == _o.position;
}

const char *TableClient::publication::TablePowerSubscr_PowerMouseOver::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("position=");
	_buf.appendInt(position);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::TablePowerSubscr_PowerMouseOver::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("position", position, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::TablePowerSubscr_PowerMouseOver::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("position"))
		{
			position = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::TablePowerSubscr_PowerMouseOver::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(position);
}

void TableClient::publication::TablePowerSubscr_PowerMouseOver::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(position);
}

const char *TableClient::publication::TablePowerSubscr_PowerMouseOver::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("position", position);
	return _buf.c_str();
}

void TableClient::publication::TablePowerSubscr_PowerMouseOver::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("position", position);
}

/* static */ void TableClient::publication::TablePowerSubscr_PowerMouseOver::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 position; _jparser.validateByNameThrow("position", position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::TablePowerSubscr_PowerMouseOver::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 position; _parser.parseINT8(position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    AppendOrUpdateLeafMsg
//=================================================================

//=================================================================
//                _Path0Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::_Path0Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::_Path0Type(_Path0Type&& _o)
	: chat(std::move(_o.chat))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::operator=(_Path0Type&& _o)
{
	if(this != &_o)
	{
		chat = std::move(_o.chat);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::clear()
{
	chat.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::equals(const _Path0Type& _o) const
{
	return chat.equals(_o.chat);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("chat=");
		chat.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		chat.toXmlString("chat", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chat"))
		{
			if(!Atf::AtfTempl< TableSubscr_Chat >::FromXmlString(_value, chat)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		chat.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	chat.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("chat", chat);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chat", chat);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_Chat chat; _jparser.validateByNameThrow("chat", chat);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path0Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_Chat::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("chat"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path1Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::_Path1Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::_Path1Type(_Path1Type&& _o)
	: staticInfo(std::move(_o.staticInfo))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::operator=(_Path1Type&& _o)
{
	if(this != &_o)
	{
		staticInfo = std::move(_o.staticInfo);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::clear()
{
	staticInfo.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::equals(const _Path1Type& _o) const
{
	return staticInfo.equals(_o.staticInfo);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("staticInfo=");
		staticInfo.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		staticInfo.toXmlString("staticInfo", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("staticInfo"))
		{
			if(!Atf::AtfTempl< TableSubscr_Static >::FromXmlString(_value, staticInfo)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		staticInfo.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	staticInfo.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("staticInfo", staticInfo);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("staticInfo", staticInfo);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_Static staticInfo; _jparser.validateByNameThrow("staticInfo", staticInfo);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path1Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_Static::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("staticInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path2Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::_Path2Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::_Path2Type(_Path2Type&& _o)
	: hand(std::move(_o.hand))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::operator=(_Path2Type&& _o)
{
	if(this != &_o)
	{
		hand = std::move(_o.hand);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::clear()
{
	hand.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::equals(const _Path2Type& _o) const
{
	return hand.equals(_o.hand);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("hand=");
		hand.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		hand.toXmlString("hand", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("hand"))
		{
			if(!Atf::AtfTempl< TableSubscr_Hand >::FromXmlString(_value, hand)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		hand.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	hand.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("hand", hand);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("hand", hand);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_Hand hand; _jparser.validateByNameThrow("hand", hand);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path2Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_Hand::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("hand"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path3Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::_Path3Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::_Path3Type(_Path3Type&& _o)
	: activePlayer(std::move(_o.activePlayer))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::operator=(_Path3Type&& _o)
{
	if(this != &_o)
	{
		activePlayer = std::move(_o.activePlayer);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::clear()
{
	activePlayer.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::equals(const _Path3Type& _o) const
{
	return activePlayer.equals(_o.activePlayer);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("activePlayer=");
		activePlayer.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		activePlayer.toXmlString("activePlayer", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("activePlayer"))
		{
			if(!Atf::AtfTempl< TableSubscr_ActivePlayer >::FromXmlString(_value, activePlayer)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		activePlayer.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	activePlayer.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("activePlayer", activePlayer);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("activePlayer", activePlayer);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_ActivePlayer activePlayer; _jparser.validateByNameThrow("activePlayer", activePlayer);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path3Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_ActivePlayer::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("activePlayer"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path5x0Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::_Path5x0Type()
{
	clear();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::clear()
{
	chips.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::equals(const _Path5x0Type& _o) const
{
	return chips.equals(_o.chips);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("chips=");
		chips.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		chips.toXmlString("chips", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chips"))
		{
			if(!Atf::AtfTempl< TableSubscr_PlayerChips >::FromXmlString(_value, chips)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		chips.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	chips.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("chips", chips);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chips", chips);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_PlayerChips chips; _jparser.validateByNameThrow("chips", chips);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x0Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_PlayerChips::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("chips"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path5x1Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::_Path5x1Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::_Path5x1Type(_Path5x1Type&& _o)
	: profile(std::move(_o.profile))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::operator=(_Path5x1Type&& _o)
{
	if(this != &_o)
	{
		profile = std::move(_o.profile);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::clear()
{
	profile.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::equals(const _Path5x1Type& _o) const
{
	return profile.equals(_o.profile);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("profile=");
		profile.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		profile.toXmlString("profile", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("profile"))
		{
			if(!Atf::AtfTempl< TableSubscr_PlayerProfile >::FromXmlString(_value, profile)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		profile.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	profile.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("profile", profile);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("profile", profile);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_PlayerProfile profile; _jparser.validateByNameThrow("profile", profile);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x1Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_PlayerProfile::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("profile"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path5x3Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::_Path5x3Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::_Path5x3Type(_Path5x3Type&& _o)
	: cards(std::move(_o.cards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::operator=(_Path5x3Type&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::clear()
{
	cards.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::equals(const _Path5x3Type& _o) const
{
	return cards.equals(_o.cards);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cards=");
		cards.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		cards.toXmlString("cards", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cards"))
		{
			if(!Atf::AtfTempl< TableSubscr_PlayerCards_Dict >::FromXmlString(_value, cards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		cards.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	cards.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("cards", cards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cards", cards);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_PlayerCards_Dict cards; _jparser.validateByNameThrow("cards", cards);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path5x3Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_PlayerCards_Dict::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path6Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::_Path6Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::_Path6Type(_Path6Type&& _o)
	: allBoards(std::move(_o.allBoards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::operator=(_Path6Type&& _o)
{
	if(this != &_o)
	{
		allBoards = std::move(_o.allBoards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::clear()
{
	allBoards.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::equals(const _Path6Type& _o) const
{
	return allBoards.equals(_o.allBoards);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("allBoards=");
		allBoards.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		allBoards.toXmlString("allBoards", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("allBoards"))
		{
			if(!Atf::AtfTempl< TableSubscr_AllBoards >::FromXmlString(_value, allBoards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		allBoards.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	allBoards.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("allBoards", allBoards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("allBoards", allBoards);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_AllBoards allBoards; _jparser.validateByNameThrow("allBoards", allBoards);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path6Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_AllBoards::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("allBoards"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path7Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::_Path7Type()
{
	clear();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::clear()
{
	dynamic.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::equals(const _Path7Type& _o) const
{
	return dynamic.equals(_o.dynamic);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("dynamic=");
		dynamic.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		dynamic.toXmlString("dynamic", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("dynamic"))
		{
			if(!Atf::AtfTempl< TableSubscr_Dynamic >::FromXmlString(_value, dynamic)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		dynamic.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	dynamic.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("dynamic", dynamic);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dynamic", dynamic);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_Dynamic dynamic; _jparser.validateByNameThrow("dynamic", dynamic);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path7Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_Dynamic::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("dynamic"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path8Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::_Path8Type()
{
	clear();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::clear()
{
	autoDeal.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::equals(const _Path8Type& _o) const
{
	return autoDeal.equals(_o.autoDeal);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("autoDeal=");
		autoDeal.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		autoDeal.toXmlString("autoDeal", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("autoDeal"))
		{
			if(!Atf::AtfTempl< TableSubscr_AutoDeal >::FromXmlString(_value, autoDeal)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		autoDeal.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	autoDeal.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("autoDeal", autoDeal);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("autoDeal", autoDeal);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableSubscr_AutoDeal autoDeal; _jparser.validateByNameThrow("autoDeal", autoDeal);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path8Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TableSubscr_AutoDeal::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("autoDeal"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path90Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::_Path90Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::_Path90Type(_Path90Type&& _o)
	: powerList(std::move(_o.powerList))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::operator=(_Path90Type&& _o)
{
	if(this != &_o)
	{
		powerList = std::move(_o.powerList);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::clear()
{
	powerList.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::equals(const _Path90Type& _o) const
{
	return powerList.equals(_o.powerList);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerList=");
		powerList.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		powerList.toXmlString("powerList", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerList"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_PowerList >::FromXmlString(_value, powerList)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		powerList.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	powerList.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("powerList", powerList);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerList", powerList);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_PowerList powerList; _jparser.validateByNameThrow("powerList", powerList);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path90Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_PowerList::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powerList"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path91Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::_Path91Type()
{
	clear();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::clear()
{
	powerPot.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::equals(const _Path91Type& _o) const
{
	return powerPot.equals(_o.powerPot);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerPot=");
		powerPot.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		powerPot.toXmlString("powerPot", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerPot"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_PowerPot >::FromXmlString(_value, powerPot)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		powerPot.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	powerPot.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("powerPot", powerPot);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerPot", powerPot);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_PowerPot powerPot; _jparser.validateByNameThrow("powerPot", powerPot);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path91Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_PowerPot::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powerPot"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path92Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::_Path92Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::_Path92Type(_Path92Type&& _o)
	: boardRedealt(std::move(_o.boardRedealt))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::operator=(_Path92Type&& _o)
{
	if(this != &_o)
	{
		boardRedealt = std::move(_o.boardRedealt);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::clear()
{
	boardRedealt.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::equals(const _Path92Type& _o) const
{
	return boardRedealt.equals(_o.boardRedealt);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("boardRedealt=");
		boardRedealt.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		boardRedealt.toXmlString("boardRedealt", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("boardRedealt"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_BoardRedealt >::FromXmlString(_value, boardRedealt)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		boardRedealt.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	boardRedealt.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("boardRedealt", boardRedealt);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("boardRedealt", boardRedealt);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_BoardRedealt boardRedealt; _jparser.validateByNameThrow("boardRedealt", boardRedealt);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path92Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_BoardRedealt::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("boardRedealt"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path93xType
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::_Path93xType()
{
	clear();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::clear()
{
	powerPlayerInfo.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::equals(const _Path93xType& _o) const
{
	return powerPlayerInfo.equals(_o.powerPlayerInfo);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerPlayerInfo=");
		powerPlayerInfo.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		powerPlayerInfo.toXmlString("powerPlayerInfo", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerPlayerInfo"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_PlayerInfo >::FromXmlString(_value, powerPlayerInfo)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		powerPlayerInfo.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	powerPlayerInfo.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("powerPlayerInfo", powerPlayerInfo);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerPlayerInfo", powerPlayerInfo);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_PlayerInfo powerPlayerInfo; _jparser.validateByNameThrow("powerPlayerInfo", powerPlayerInfo);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path93xType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_PlayerInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powerPlayerInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path940Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::_Path940Type()
{
	clear();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::clear()
{
	silenceStateInfo.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::equals(const _Path940Type& _o) const
{
	return silenceStateInfo.equals(_o.silenceStateInfo);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("silenceStateInfo=");
		silenceStateInfo.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		silenceStateInfo.toXmlString("silenceStateInfo", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("silenceStateInfo"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_SilenceStateInfo >::FromXmlString(_value, silenceStateInfo)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		silenceStateInfo.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	silenceStateInfo.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("silenceStateInfo", silenceStateInfo);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("silenceStateInfo", silenceStateInfo);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_SilenceStateInfo silenceStateInfo; _jparser.validateByNameThrow("silenceStateInfo", silenceStateInfo);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path940Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_SilenceStateInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("silenceStateInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path941Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::_Path941Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::_Path941Type(_Path941Type&& _o)
	: senseStateInfo(std::move(_o.senseStateInfo))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::operator=(_Path941Type&& _o)
{
	if(this != &_o)
	{
		senseStateInfo = std::move(_o.senseStateInfo);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::clear()
{
	senseStateInfo.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::equals(const _Path941Type& _o) const
{
	return senseStateInfo.equals(_o.senseStateInfo);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("senseStateInfo=");
		senseStateInfo.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		senseStateInfo.toXmlString("senseStateInfo", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("senseStateInfo"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_SenseStateInfo >::FromXmlString(_value, senseStateInfo)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		senseStateInfo.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	senseStateInfo.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("senseStateInfo", senseStateInfo);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("senseStateInfo", senseStateInfo);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_SenseStateInfo senseStateInfo; _jparser.validateByNameThrow("senseStateInfo", senseStateInfo);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path941Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_SenseStateInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("senseStateInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path942Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::_Path942Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::_Path942Type(_Path942Type&& _o)
	: cloakedStateInfo(std::move(_o.cloakedStateInfo))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::operator=(_Path942Type&& _o)
{
	if(this != &_o)
	{
		cloakedStateInfo = std::move(_o.cloakedStateInfo);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::clear()
{
	cloakedStateInfo.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::equals(const _Path942Type& _o) const
{
	return cloakedStateInfo.equals(_o.cloakedStateInfo);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cloakedStateInfo=");
		cloakedStateInfo.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		cloakedStateInfo.toXmlString("cloakedStateInfo", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cloakedStateInfo"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_CloakedStateInfo >::FromXmlString(_value, cloakedStateInfo)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		cloakedStateInfo.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	cloakedStateInfo.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("cloakedStateInfo", cloakedStateInfo);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cloakedStateInfo", cloakedStateInfo);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_CloakedStateInfo cloakedStateInfo; _jparser.validateByNameThrow("cloakedStateInfo", cloakedStateInfo);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path942Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_CloakedStateInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cloakedStateInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path95Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::_Path95Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::_Path95Type(_Path95Type&& _o)
	: cardsVisibility(std::move(_o.cardsVisibility))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::operator=(_Path95Type&& _o)
{
	if(this != &_o)
	{
		cardsVisibility = std::move(_o.cardsVisibility);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::clear()
{
	cardsVisibility.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::equals(const _Path95Type& _o) const
{
	return cardsVisibility.equals(_o.cardsVisibility);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cardsVisibility=");
		cardsVisibility.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		cardsVisibility.toXmlString("cardsVisibility", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardsVisibility"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_CardsVisibility >::FromXmlString(_value, cardsVisibility)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		cardsVisibility.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	cardsVisibility.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("cardsVisibility", cardsVisibility);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardsVisibility", cardsVisibility);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_CardsVisibility cardsVisibility; _jparser.validateByNameThrow("cardsVisibility", cardsVisibility);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path95Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_CardsVisibility::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cardsVisibility"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path96xType
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::_Path96xType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::_Path96xType(_Path96xType&& _o)
	: powerStateInfo(std::move(_o.powerStateInfo))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType& TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::operator=(_Path96xType&& _o)
{
	if(this != &_o)
	{
		powerStateInfo = std::move(_o.powerStateInfo);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::clear()
{
	powerStateInfo.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::equals(const _Path96xType& _o) const
{
	return powerStateInfo.equals(_o.powerStateInfo);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerStateInfo=");
		powerStateInfo.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		powerStateInfo.toXmlString("powerStateInfo", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerStateInfo"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_PowerStateInfo >::FromXmlString(_value, powerStateInfo)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		powerStateInfo.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	powerStateInfo.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("powerStateInfo", powerStateInfo);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerStateInfo", powerStateInfo);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_PowerStateInfo powerStateInfo; _jparser.validateByNameThrow("powerStateInfo", powerStateInfo);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path96xType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_PowerStateInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powerStateInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path97Type
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::_Path97Type()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::_Path97Type(_Path97Type&& _o)
	: powerIndicators(std::move(_o.powerIndicators))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type& TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::operator=(_Path97Type&& _o)
{
	if(this != &_o)
	{
		powerIndicators = std::move(_o.powerIndicators);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::clear()
{
	powerIndicators.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::equals(const _Path97Type& _o) const
{
	return powerIndicators.equals(_o.powerIndicators);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerIndicators=");
		powerIndicators.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		powerIndicators.toXmlString("powerIndicators", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerIndicators"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_PowerIndicators >::FromXmlString(_value, powerIndicators)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		powerIndicators.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	powerIndicators.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("powerIndicators", powerIndicators);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerIndicators", powerIndicators);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_PowerIndicators powerIndicators; _jparser.validateByNameThrow("powerIndicators", powerIndicators);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path97Type::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_PowerIndicators::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powerIndicators"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path98xType
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::_Path98xType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::_Path98xType(_Path98xType&& _o)
	: powerInfo(std::move(_o.powerInfo))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType& TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::operator=(_Path98xType&& _o)
{
	if(this != &_o)
	{
		powerInfo = std::move(_o.powerInfo);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::clear()
{
	powerInfo.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::equals(const _Path98xType& _o) const
{
	return powerInfo.equals(_o.powerInfo);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerInfo=");
		powerInfo.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		powerInfo.toXmlString("powerInfo", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerInfo"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_PowerInfo >::FromXmlString(_value, powerInfo)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		powerInfo.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	powerInfo.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("powerInfo", powerInfo);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerInfo", powerInfo);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_PowerInfo powerInfo; _jparser.validateByNameThrow("powerInfo", powerInfo);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path98xType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_PowerInfo::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powerInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _Path99xType
//=================================================================

TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::_Path99xType()
{
	clear();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::clear()
{
	powerMoouseOver.clear();
	_is_empty_internal = true;
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::equals(const _Path99xType& _o) const
{
	return powerMoouseOver.equals(_o.powerMoouseOver);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerMoouseOver=");
		powerMoouseOver.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		powerMoouseOver.toXmlString("powerMoouseOver", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerMoouseOver"))
		{
			if(!Atf::AtfTempl< TablePowerSubscr_PowerMouseOver >::FromXmlString(_value, powerMoouseOver)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		powerMoouseOver.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	powerMoouseOver.parseMsg(_parser0);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("powerMoouseOver", powerMoouseOver);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerMoouseOver", powerMoouseOver);
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TablePowerSubscr_PowerMouseOver powerMoouseOver; _jparser.validateByNameThrow("powerMoouseOver", powerMoouseOver);
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::_Path99xType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	TablePowerSubscr_PowerMouseOver::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powerMoouseOver"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

TableClient::publication::AppendOrUpdateLeafMsg::AppendOrUpdateLeafMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AppendOrUpdateLeafMsg::AppendOrUpdateLeafMsg(AppendOrUpdateLeafMsg&& _o)
	: path(std::move(_o.path))
	, path0(std::move(_o.path0))
	, path1(std::move(_o.path1))
	, path2(std::move(_o.path2))
	, path3(std::move(_o.path3))
	, path5x0(std::move(_o.path5x0))
	, path5x1(std::move(_o.path5x1))
	, path5x3(std::move(_o.path5x3))
	, path6(std::move(_o.path6))
	, path7(std::move(_o.path7))
	, path8(std::move(_o.path8))
	, path90(std::move(_o.path90))
	, path91(std::move(_o.path91))
	, path92(std::move(_o.path92))
	, path93x(std::move(_o.path93x))
	, path940(std::move(_o.path940))
	, path941(std::move(_o.path941))
	, path942(std::move(_o.path942))
	, path95(std::move(_o.path95))
	, path96x(std::move(_o.path96x))
	, path97(std::move(_o.path97))
	, path98x(std::move(_o.path98x))
	, path99x(std::move(_o.path99x))
{
}

TableClient::publication::AppendOrUpdateLeafMsg& TableClient::publication::AppendOrUpdateLeafMsg::operator=(AppendOrUpdateLeafMsg&& _o)
{
	if(this != &_o)
	{
		path = std::move(_o.path);
		path0 = std::move(_o.path0);
		path1 = std::move(_o.path1);
		path2 = std::move(_o.path2);
		path3 = std::move(_o.path3);
		path5x0 = std::move(_o.path5x0);
		path5x1 = std::move(_o.path5x1);
		path5x3 = std::move(_o.path5x3);
		path6 = std::move(_o.path6);
		path7 = std::move(_o.path7);
		path8 = std::move(_o.path8);
		path90 = std::move(_o.path90);
		path91 = std::move(_o.path91);
		path92 = std::move(_o.path92);
		path93x = std::move(_o.path93x);
		path940 = std::move(_o.path940);
		path941 = std::move(_o.path941);
		path942 = std::move(_o.path942);
		path95 = std::move(_o.path95);
		path96x = std::move(_o.path96x);
		path97 = std::move(_o.path97);
		path98x = std::move(_o.path98x);
		path99x = std::move(_o.path99x);
	}
	return *this;
}

#endif

void TableClient::publication::AppendOrUpdateLeafMsg::clear()
{
	path.clear();
	path0.clear();
	path1.clear();
	path2.clear();
	path3.clear();
	path5x0.clear();
	path5x1.clear();
	path5x3.clear();
	path6.clear();
	path7.clear();
	path8.clear();
	path90.clear();
	path91.clear();
	path92.clear();
	path93x.clear();
	path940.clear();
	path941.clear();
	path942.clear();
	path95.clear();
	path96x.clear();
	path97.clear();
	path98x.clear();
	path99x.clear();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::equals(const AppendOrUpdateLeafMsg& _o) const
{
	return path.equals(_o.path) &&
		path0.equals(_o.path0) &&
		path1.equals(_o.path1) &&
		path2.equals(_o.path2) &&
		path3.equals(_o.path3) &&
		path5x0.equals(_o.path5x0) &&
		path5x1.equals(_o.path5x1) &&
		path5x3.equals(_o.path5x3) &&
		path6.equals(_o.path6) &&
		path7.equals(_o.path7) &&
		path8.equals(_o.path8) &&
		path90.equals(_o.path90) &&
		path91.equals(_o.path91) &&
		path92.equals(_o.path92) &&
		path93x.equals(_o.path93x) &&
		path940.equals(_o.path940) &&
		path941.equals(_o.path941) &&
		path942.equals(_o.path942) &&
		path95.equals(_o.path95) &&
		path96x.equals(_o.path96x) &&
		path97.equals(_o.path97) &&
		path98x.equals(_o.path98x) &&
		path99x.equals(_o.path99x);
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("path=");
	path.toTraceString(_buf);
	if (path.size() >= 1 && path[0] == 0)
	{
		_buf.append(',');
		_buf.append("path0=");
		path0.toTraceString(_buf);
	}
	else if (path.size() == 1 && path[0] == 1)
	{
		_buf.append(',');
		_buf.append("path1=");
		path1.toTraceString(_buf);
	}
	else if (path.size() == 1 && path[0] == 2)
	{
		_buf.append(',');
		_buf.append("path2=");
		path2.toTraceString(_buf);
	}
	else if (path.size() == 1 && path[0] == 3)
	{
		_buf.append(',');
		_buf.append("path3=");
		path3.toTraceString(_buf);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 0)
	{
		_buf.append(',');
		_buf.append("path5x0=");
		path5x0.toTraceString(_buf);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 1)
	{
		_buf.append(',');
		_buf.append("path5x1=");
		path5x1.toTraceString(_buf);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 3)
	{
		_buf.append(',');
		_buf.append("path5x3=");
		path5x3.toTraceString(_buf);
	}
	else if (path.size() == 1 && path[0] == 6)
	{
		_buf.append(',');
		_buf.append("path6=");
		path6.toTraceString(_buf);
	}
	else if (path.size() == 1 && path[0] == 7)
	{
		_buf.append(',');
		_buf.append("path7=");
		path7.toTraceString(_buf);
	}
	else if (path.size() == 1 && path[0] == 8)
	{
		_buf.append(',');
		_buf.append("path8=");
		path8.toTraceString(_buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 0)
	{
		_buf.append(',');
		_buf.append("path90=");
		path90.toTraceString(_buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 1)
	{
		_buf.append(',');
		_buf.append("path91=");
		path91.toTraceString(_buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 2)
	{
		_buf.append(',');
		_buf.append("path92=");
		path92.toTraceString(_buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 3)
	{
		_buf.append(',');
		_buf.append("path93x=");
		path93x.toTraceString(_buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 0)
	{
		_buf.append(',');
		_buf.append("path940=");
		path940.toTraceString(_buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 1)
	{
		_buf.append(',');
		_buf.append("path941=");
		path941.toTraceString(_buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 2)
	{
		_buf.append(',');
		_buf.append("path942=");
		path942.toTraceString(_buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 5)
	{
		_buf.append(',');
		_buf.append("path95=");
		path95.toTraceString(_buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 6)
	{
		_buf.append(',');
		_buf.append("path96x=");
		path96x.toTraceString(_buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 7)
	{
		_buf.append(',');
		_buf.append("path97=");
		path97.toTraceString(_buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 8)
	{
		_buf.append(',');
		_buf.append("path98x=");
		path98x.toTraceString(_buf);
	}
	else if (path.size() == 3 &&  path[0] == 9 && path[1] == 9)
	{
		_buf.append(',');
		_buf.append("path99x=");
		path99x.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	path.toXmlString("path", _buf);
	if (path.size() >= 1 && path[0] == 0)
	{
		path0.toXmlString("path0", _buf);
	}
	else if (path.size() == 1 && path[0] == 1)
	{
		path1.toXmlString("path1", _buf);
	}
	else if (path.size() == 1 && path[0] == 2)
	{
		path2.toXmlString("path2", _buf);
	}
	else if (path.size() == 1 && path[0] == 3)
	{
		path3.toXmlString("path3", _buf);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 0)
	{
		path5x0.toXmlString("path5x0", _buf);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 1)
	{
		path5x1.toXmlString("path5x1", _buf);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 3)
	{
		path5x3.toXmlString("path5x3", _buf);
	}
	else if (path.size() == 1 && path[0] == 6)
	{
		path6.toXmlString("path6", _buf);
	}
	else if (path.size() == 1 && path[0] == 7)
	{
		path7.toXmlString("path7", _buf);
	}
	else if (path.size() == 1 && path[0] == 8)
	{
		path8.toXmlString("path8", _buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 0)
	{
		path90.toXmlString("path90", _buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 1)
	{
		path91.toXmlString("path91", _buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 2)
	{
		path92.toXmlString("path92", _buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 3)
	{
		path93x.toXmlString("path93x", _buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 0)
	{
		path940.toXmlString("path940", _buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 1)
	{
		path941.toXmlString("path941", _buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 2)
	{
		path942.toXmlString("path942", _buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 5)
	{
		path95.toXmlString("path95", _buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 6)
	{
		path96x.toXmlString("path96x", _buf);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 7)
	{
		path97.toXmlString("path97", _buf);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 8)
	{
		path98x.toXmlString("path98x", _buf);
	}
	else if (path.size() == 3 &&  path[0] == 9 && path[1] == 9)
	{
		path99x.toXmlString("path99x", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AppendOrUpdateLeafMsg::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("path"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT16, 2 > >::FromXmlString(_value, path)) return false;
		}
		else if (_element.equals("path0"))
		{
			if(!Atf::AtfTempl< _Path0Type >::FromXmlString(_value, path0)) return false;
		}
		else if (_element.equals("path1"))
		{
			if(!Atf::AtfTempl< _Path1Type >::FromXmlString(_value, path1)) return false;
		}
		else if (_element.equals("path2"))
		{
			if(!Atf::AtfTempl< _Path2Type >::FromXmlString(_value, path2)) return false;
		}
		else if (_element.equals("path3"))
		{
			if(!Atf::AtfTempl< _Path3Type >::FromXmlString(_value, path3)) return false;
		}
		else if (_element.equals("path5x0"))
		{
			if(!Atf::AtfTempl< _Path5x0Type >::FromXmlString(_value, path5x0)) return false;
		}
		else if (_element.equals("path5x1"))
		{
			if(!Atf::AtfTempl< _Path5x1Type >::FromXmlString(_value, path5x1)) return false;
		}
		else if (_element.equals("path5x3"))
		{
			if(!Atf::AtfTempl< _Path5x3Type >::FromXmlString(_value, path5x3)) return false;
		}
		else if (_element.equals("path6"))
		{
			if(!Atf::AtfTempl< _Path6Type >::FromXmlString(_value, path6)) return false;
		}
		else if (_element.equals("path7"))
		{
			if(!Atf::AtfTempl< _Path7Type >::FromXmlString(_value, path7)) return false;
		}
		else if (_element.equals("path8"))
		{
			if(!Atf::AtfTempl< _Path8Type >::FromXmlString(_value, path8)) return false;
		}
		else if (_element.equals("path90"))
		{
			if(!Atf::AtfTempl< _Path90Type >::FromXmlString(_value, path90)) return false;
		}
		else if (_element.equals("path91"))
		{
			if(!Atf::AtfTempl< _Path91Type >::FromXmlString(_value, path91)) return false;
		}
		else if (_element.equals("path92"))
		{
			if(!Atf::AtfTempl< _Path92Type >::FromXmlString(_value, path92)) return false;
		}
		else if (_element.equals("path93x"))
		{
			if(!Atf::AtfTempl< _Path93xType >::FromXmlString(_value, path93x)) return false;
		}
		else if (_element.equals("path940"))
		{
			if(!Atf::AtfTempl< _Path940Type >::FromXmlString(_value, path940)) return false;
		}
		else if (_element.equals("path941"))
		{
			if(!Atf::AtfTempl< _Path941Type >::FromXmlString(_value, path941)) return false;
		}
		else if (_element.equals("path942"))
		{
			if(!Atf::AtfTempl< _Path942Type >::FromXmlString(_value, path942)) return false;
		}
		else if (_element.equals("path95"))
		{
			if(!Atf::AtfTempl< _Path95Type >::FromXmlString(_value, path95)) return false;
		}
		else if (_element.equals("path96x"))
		{
			if(!Atf::AtfTempl< _Path96xType >::FromXmlString(_value, path96x)) return false;
		}
		else if (_element.equals("path97"))
		{
			if(!Atf::AtfTempl< _Path97Type >::FromXmlString(_value, path97)) return false;
		}
		else if (_element.equals("path98x"))
		{
			if(!Atf::AtfTempl< _Path98xType >::FromXmlString(_value, path98x)) return false;
		}
		else if (_element.equals("path99x"))
		{
			if(!Atf::AtfTempl< _Path99xType >::FromXmlString(_value, path99x)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::AppendOrUpdateLeafMsg::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	path.composeMsg(_msg, _ignoreJSON);
	if (path.size() >= 1 && path[0] == 0)
	{
		path0.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 1 && path[0] == 1)
	{
		path1.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 1 && path[0] == 2)
	{
		path2.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 1 && path[0] == 3)
	{
		path3.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 0)
	{
		path5x0.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 1)
	{
		path5x1.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 3)
	{
		path5x3.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 1 && path[0] == 6)
	{
		path6.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 1 && path[0] == 7)
	{
		path7.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 1 && path[0] == 8)
	{
		path8.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 0)
	{
		path90.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 1)
	{
		path91.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 2)
	{
		path92.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 3)
	{
		path93x.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 0)
	{
		path940.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 1)
	{
		path941.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 2)
	{
		path942.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 5)
	{
		path95.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 6)
	{
		path96x.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 7)
	{
		path97.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 8)
	{
		path98x.composeMsg(_msg, _ignoreJSON);
	}
	else if (path.size() == 3 &&  path[0] == 9 && path[1] == 9)
	{
		path99x.composeMsg(_msg, _ignoreJSON);
	}
}

void TableClient::publication::AppendOrUpdateLeafMsg::parseMsg(CommMsgParser& _parser)
{
	path.parseMsg(_parser);
	if (path.size() >= 1 && path[0] == 0)
	{
		path0.parseMsg(_parser);
	}
	else if (path.size() == 1 && path[0] == 1)
	{
		path1.parseMsg(_parser);
	}
	else if (path.size() == 1 && path[0] == 2)
	{
		path2.parseMsg(_parser);
	}
	else if (path.size() == 1 && path[0] == 3)
	{
		path3.parseMsg(_parser);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 0)
	{
		path5x0.parseMsg(_parser);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 1)
	{
		path5x1.parseMsg(_parser);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 3)
	{
		path5x3.parseMsg(_parser);
	}
	else if (path.size() == 1 && path[0] == 6)
	{
		path6.parseMsg(_parser);
	}
	else if (path.size() == 1 && path[0] == 7)
	{
		path7.parseMsg(_parser);
	}
	else if (path.size() == 1 && path[0] == 8)
	{
		path8.parseMsg(_parser);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 0)
	{
		path90.parseMsg(_parser);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 1)
	{
		path91.parseMsg(_parser);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 2)
	{
		path92.parseMsg(_parser);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 3)
	{
		path93x.parseMsg(_parser);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 0)
	{
		path940.parseMsg(_parser);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 1)
	{
		path941.parseMsg(_parser);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 2)
	{
		path942.parseMsg(_parser);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 5)
	{
		path95.parseMsg(_parser);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 6)
	{
		path96x.parseMsg(_parser);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 7)
	{
		path97.parseMsg(_parser);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 8)
	{
		path98x.parseMsg(_parser);
	}
	else if (path.size() == 3 &&  path[0] == 9 && path[1] == 9)
	{
		path99x.parseMsg(_parser);
	}
}

const char *TableClient::publication::AppendOrUpdateLeafMsg::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("path", path);
	if (path.size() >= 1 && path[0] == 0)
	{
		_jsonstr.compose("path0", path0);
	}
	else if (path.size() == 1 && path[0] == 1)
	{
		_jsonstr.compose("path1", path1);
	}
	else if (path.size() == 1 && path[0] == 2)
	{
		_jsonstr.compose("path2", path2);
	}
	else if (path.size() == 1 && path[0] == 3)
	{
		_jsonstr.compose("path3", path3);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 0)
	{
		_jsonstr.compose("path5x0", path5x0);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 1)
	{
		_jsonstr.compose("path5x1", path5x1);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 3)
	{
		_jsonstr.compose("path5x3", path5x3);
	}
	else if (path.size() == 1 && path[0] == 6)
	{
		_jsonstr.compose("path6", path6);
	}
	else if (path.size() == 1 && path[0] == 7)
	{
		_jsonstr.compose("path7", path7);
	}
	else if (path.size() == 1 && path[0] == 8)
	{
		_jsonstr.compose("path8", path8);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 0)
	{
		_jsonstr.compose("path90", path90);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 1)
	{
		_jsonstr.compose("path91", path91);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 2)
	{
		_jsonstr.compose("path92", path92);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 3)
	{
		_jsonstr.compose("path93x", path93x);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 0)
	{
		_jsonstr.compose("path940", path940);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 1)
	{
		_jsonstr.compose("path941", path941);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 2)
	{
		_jsonstr.compose("path942", path942);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 5)
	{
		_jsonstr.compose("path95", path95);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 6)
	{
		_jsonstr.compose("path96x", path96x);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 7)
	{
		_jsonstr.compose("path97", path97);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 8)
	{
		_jsonstr.compose("path98x", path98x);
	}
	else if (path.size() == 3 &&  path[0] == 9 && path[1] == 9)
	{
		_jsonstr.compose("path99x", path99x);
	}
	return _buf.c_str();
}

void TableClient::publication::AppendOrUpdateLeafMsg::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("path", path);
	if (path.size() >= 1 && path[0] == 0)
	{
		_jparser.parseByNameThrow("path0", path0);
	}
	else if (path.size() == 1 && path[0] == 1)
	{
		_jparser.parseByNameThrow("path1", path1);
	}
	else if (path.size() == 1 && path[0] == 2)
	{
		_jparser.parseByNameThrow("path2", path2);
	}
	else if (path.size() == 1 && path[0] == 3)
	{
		_jparser.parseByNameThrow("path3", path3);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 0)
	{
		_jparser.parseByNameThrow("path5x0", path5x0);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 1)
	{
		_jparser.parseByNameThrow("path5x1", path5x1);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 3)
	{
		_jparser.parseByNameThrow("path5x3", path5x3);
	}
	else if (path.size() == 1 && path[0] == 6)
	{
		_jparser.parseByNameThrow("path6", path6);
	}
	else if (path.size() == 1 && path[0] == 7)
	{
		_jparser.parseByNameThrow("path7", path7);
	}
	else if (path.size() == 1 && path[0] == 8)
	{
		_jparser.parseByNameThrow("path8", path8);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 0)
	{
		_jparser.parseByNameThrow("path90", path90);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 1)
	{
		_jparser.parseByNameThrow("path91", path91);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 2)
	{
		_jparser.parseByNameThrow("path92", path92);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 3)
	{
		_jparser.parseByNameThrow("path93x", path93x);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 0)
	{
		_jparser.parseByNameThrow("path940", path940);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 1)
	{
		_jparser.parseByNameThrow("path941", path941);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 2)
	{
		_jparser.parseByNameThrow("path942", path942);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 5)
	{
		_jparser.parseByNameThrow("path95", path95);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 6)
	{
		_jparser.parseByNameThrow("path96x", path96x);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 7)
	{
		_jparser.parseByNameThrow("path97", path97);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 8)
	{
		_jparser.parseByNameThrow("path98x", path98x);
	}
	else if (path.size() == 3 &&  path[0] == 9 && path[1] == 9)
	{
		_jparser.parseByNameThrow("path99x", path99x);
	}
}

/* static */ void TableClient::publication::AppendOrUpdateLeafMsg::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT16 > path;
	_jparser.validateByNameThrow("path", path);
	AtfValidator::validateInt(_descr, "path", path.size(), _checker, __FILE__, __LINE__);
	if (path.size() >= 1 && path[0] == 0)
	{
		_Path0Type path0; _jparser.validateByNameThrow("path0", path0);
	}
	else if (path.size() == 1 && path[0] == 1)
	{
		_Path1Type path1; _jparser.validateByNameThrow("path1", path1);
	}
	else if (path.size() == 1 && path[0] == 2)
	{
		_Path2Type path2; _jparser.validateByNameThrow("path2", path2);
	}
	else if (path.size() == 1 && path[0] == 3)
	{
		_Path3Type path3; _jparser.validateByNameThrow("path3", path3);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 0)
	{
		_Path5x0Type path5x0; _jparser.validateByNameThrow("path5x0", path5x0);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 1)
	{
		_Path5x1Type path5x1; _jparser.validateByNameThrow("path5x1", path5x1);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 3)
	{
		_Path5x3Type path5x3; _jparser.validateByNameThrow("path5x3", path5x3);
	}
	else if (path.size() == 1 && path[0] == 6)
	{
		_Path6Type path6; _jparser.validateByNameThrow("path6", path6);
	}
	else if (path.size() == 1 && path[0] == 7)
	{
		_Path7Type path7; _jparser.validateByNameThrow("path7", path7);
	}
	else if (path.size() == 1 && path[0] == 8)
	{
		_Path8Type path8; _jparser.validateByNameThrow("path8", path8);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 0)
	{
		_Path90Type path90; _jparser.validateByNameThrow("path90", path90);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 1)
	{
		_Path91Type path91; _jparser.validateByNameThrow("path91", path91);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 2)
	{
		_Path92Type path92; _jparser.validateByNameThrow("path92", path92);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 3)
	{
		_Path93xType path93x; _jparser.validateByNameThrow("path93x", path93x);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 0)
	{
		_Path940Type path940; _jparser.validateByNameThrow("path940", path940);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 1)
	{
		_Path941Type path941; _jparser.validateByNameThrow("path941", path941);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 2)
	{
		_Path942Type path942; _jparser.validateByNameThrow("path942", path942);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 5)
	{
		_Path95Type path95; _jparser.validateByNameThrow("path95", path95);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 6)
	{
		_Path96xType path96x; _jparser.validateByNameThrow("path96x", path96x);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 7)
	{
		_Path97Type path97; _jparser.validateByNameThrow("path97", path97);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 8)
	{
		_Path98xType path98x; _jparser.validateByNameThrow("path98x", path98x);
	}
	else if (path.size() == 3 &&  path[0] == 9 && path[1] == 9)
	{
		_Path99xType path99x; _jparser.validateByNameThrow("path99x", path99x);
	}
}

/*static*/ void TableClient::publication::AppendOrUpdateLeafMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::LAtfVector< UINT16, 2 > path;
	path.parseMsg(_parser);
	AtfValidator::validateInt(_descr, "path", path.size(), _checker, __FILE__, __LINE__);
	if (path.size() >= 1 && path[0] == 0)
	{
		PString _descbuf;
		_Path0Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path0"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 1 && path[0] == 1)
	{
		PString _descbuf;
		_Path1Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path1"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 1 && path[0] == 2)
	{
		PString _descbuf;
		_Path2Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path2"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 1 && path[0] == 3)
	{
		PString _descbuf;
		_Path3Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path3"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 0)
	{
		PString _descbuf;
		_Path5x0Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path5x0"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 1)
	{
		PString _descbuf;
		_Path5x1Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path5x1"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 && path[0] == 5 && path[2] == 3)
	{
		PString _descbuf;
		_Path5x3Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path5x3"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 1 && path[0] == 6)
	{
		PString _descbuf;
		_Path6Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path6"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 1 && path[0] == 7)
	{
		PString _descbuf;
		_Path7Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path7"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 1 && path[0] == 8)
	{
		PString _descbuf;
		_Path8Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path8"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 0)
	{
		PString _descbuf;
		_Path90Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path90"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 1)
	{
		PString _descbuf;
		_Path91Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path91"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 2)
	{
		PString _descbuf;
		_Path92Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path92"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 3)
	{
		PString _descbuf;
		_Path93xType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path93x"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 0)
	{
		PString _descbuf;
		_Path940Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path940"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 1)
	{
		PString _descbuf;
		_Path941Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path941"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 4 && path[2] == 2)
	{
		PString _descbuf;
		_Path942Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path942"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 5)
	{
		PString _descbuf;
		_Path95Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path95"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 6)
	{
		PString _descbuf;
		_Path96xType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path96x"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 2 && path[0] == 9 && path[1] == 7)
	{
		PString _descbuf;
		_Path97Type::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path97"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 && path[0] == 9 && path[1] == 8)
	{
		PString _descbuf;
		_Path98xType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path98x"), _fieldsWithUnparsedContent);
	}
	else if (path.size() == 3 &&  path[0] == 9 && path[1] == 9)
	{
		PString _descbuf;
		_Path99xType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path99x"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    PublOnlineUpdateItem
//=================================================================

// @Override
bool TableClient::publication::PublOnlineUpdateItem::canBeSkippedInComparison() const
{
	
	if( leaf.path.size() == 1 && leaf.path[0] == 7 )
	{
		return true;
	}
	if( leaf.path.size() > 1 && leaf.path[0] == 9 )  
	{
		return true;
	}
	return false;
}

TableClient::publication::PublOnlineUpdateItem::PublOnlineUpdateItem()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::PublOnlineUpdateItem::PublOnlineUpdateItem(PublOnlineUpdateItem&& _o)
	: action(std::move(_o.action))
	, attchedMsg(std::move(_o.attchedMsg))
	, path(std::move(_o.path))
	, idx(std::move(_o.idx))
	, leaf(std::move(_o.leaf))
{
}

TableClient::publication::PublOnlineUpdateItem& TableClient::publication::PublOnlineUpdateItem::operator=(PublOnlineUpdateItem&& _o)
{
	if(this != &_o)
	{
		action = std::move(_o.action);
		attchedMsg = std::move(_o.attchedMsg);
		path = std::move(_o.path);
		idx = std::move(_o.idx);
		leaf = std::move(_o.leaf);
	}
	return *this;
}

#endif

void TableClient::publication::PublOnlineUpdateItem::clear()
{
	action = '0';
	attchedMsg.clear();
	path.clear();
	idx = 0;
	leaf.clear();
}

bool TableClient::publication::PublOnlineUpdateItem::equals(const PublOnlineUpdateItem& _o) const
{
	return action == _o.action &&
		attchedMsg.equals(_o.attchedMsg) &&
		path.equals(_o.path) &&
		idx == _o.idx &&
		leaf.equals(_o.leaf);
}

const char *TableClient::publication::PublOnlineUpdateItem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("a=");
	_buf.append(action);
	if (action == PUBLICATION_ACTION_ATTACH_MSG)
	{
		_buf.append(',');
		_buf.append("attchedMsg=");
		attchedMsg.toTraceString(_buf);
	}
	else if(action == PUBLICATION_ACTION_APPEND_NODE)
	{
		_buf.append(',');
		_buf.append("path=");
		path.toTraceString(_buf);
	}
	else if (action == PUBLICATION_ACTION_REMOVE_NODE || action == PUBLICATION_ACTION_REMOVE_LEAF)
	{
		_buf.append(',');
		_buf.append("path=");
		path.toTraceString(_buf);
		_buf.append(',');
		_buf.append("idx=");
		_buf.appendUint(idx);
	}
	else if(action == PUBLICATION_ACTION_UPDATE_LEAF || action == PUBLICATION_ACTION_APPEND_LEAF)
	{
		_buf.append(',');
		_buf.append("leaf=");
		leaf.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::PublOnlineUpdateItem::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("a", action, _buf);
	if (action == PUBLICATION_ACTION_ATTACH_MSG)
	{
		attchedMsg.toXmlString("attchedMsg", _buf);
	}
	else if(action == PUBLICATION_ACTION_APPEND_NODE)
	{
		path.toXmlString("path", _buf);
	}
	else if (action == PUBLICATION_ACTION_REMOVE_NODE || action == PUBLICATION_ACTION_REMOVE_LEAF)
	{
		path.toXmlString("path", _buf);
		Atf::XmlElement::encodeAsXmlElement("idx", idx, _buf);
	}
	else if(action == PUBLICATION_ACTION_UPDATE_LEAF || action == PUBLICATION_ACTION_APPEND_LEAF)
	{
		leaf.toXmlString("leaf", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::PublOnlineUpdateItem::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("a") || _element.equals("action"))
		{
			action = *_value.ptr();
		}
		else if (_element.equals("attchedMsg"))
		{
			if(!Atf::AtfTempl< AttachedPublMsg >::FromXmlString(_value, attchedMsg)) return false;
		}
		else if (_element.equals("path"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT16, 2 > >::FromXmlString(_value, path)) return false;
		}
		else if (_element.equals("idx"))
		{
			idx = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("leaf"))
		{
			if(!Atf::AtfTempl< AppendOrUpdateLeafMsg >::FromXmlString(_value, leaf)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::PublOnlineUpdateItem::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(action);
	if (action == PUBLICATION_ACTION_ATTACH_MSG)
	{
		attchedMsg.composeMsg(_msg, _ignoreJSON);
	}
	else if(action == PUBLICATION_ACTION_APPEND_NODE)
	{
		path.composeMsg(_msg, _ignoreJSON);
	}
	else if (action == PUBLICATION_ACTION_REMOVE_NODE || action == PUBLICATION_ACTION_REMOVE_LEAF)
	{
		path.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT16(idx);
	}
	else if(action == PUBLICATION_ACTION_UPDATE_LEAF || action == PUBLICATION_ACTION_APPEND_LEAF)
	{
		leaf.composeMsg(_msg, _ignoreJSON);
	}
}

void TableClient::publication::PublOnlineUpdateItem::parseMsg(CommMsgParser& _parser)
{
	{ INT8 _n; _parser.parseINT8(_n); action = _n; }
	if (action == PUBLICATION_ACTION_ATTACH_MSG)
	{
		attchedMsg.parseMsg(_parser);
	}
	else if(action == PUBLICATION_ACTION_APPEND_NODE)
	{
		path.parseMsg(_parser);
	}
	else if (action == PUBLICATION_ACTION_REMOVE_NODE || action == PUBLICATION_ACTION_REMOVE_LEAF)
	{
		path.parseMsg(_parser);
		_parser.parseUINT16(idx);
	}
	else if(action == PUBLICATION_ACTION_UPDATE_LEAF || action == PUBLICATION_ACTION_APPEND_LEAF)
	{
		leaf.parseMsg(_parser);
	}
}

const char *TableClient::publication::PublOnlineUpdateItem::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("a", action);
	if (action == PUBLICATION_ACTION_ATTACH_MSG)
	{
		_jsonstr.compose("attchedMsg", attchedMsg);
	}
	else if(action == PUBLICATION_ACTION_APPEND_NODE)
	{
		_jsonstr.compose("path", path);
	}
	else if (action == PUBLICATION_ACTION_REMOVE_NODE || action == PUBLICATION_ACTION_REMOVE_LEAF)
	{
		_jsonstr.compose("path", path);
		_jsonstr.compose("idx", idx);
	}
	else if(action == PUBLICATION_ACTION_UPDATE_LEAF || action == PUBLICATION_ACTION_APPEND_LEAF)
	{
		_jsonstr.compose("leaf", leaf);
	}
	return _buf.c_str();
}

void TableClient::publication::PublOnlineUpdateItem::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(!_jparser.parseByName("a", action)) _jparser.parseByNameThrow("action", action);
	if (action == PUBLICATION_ACTION_ATTACH_MSG)
	{
		_jparser.parseByNameThrow("attchedMsg", attchedMsg);
	}
	else if(action == PUBLICATION_ACTION_APPEND_NODE)
	{
		_jparser.parseByNameThrow("path", path);
	}
	else if (action == PUBLICATION_ACTION_REMOVE_NODE || action == PUBLICATION_ACTION_REMOVE_LEAF)
	{
		_jparser.parseByNameThrow("path", path);
		_jparser.parseByNameThrow("idx", idx);
	}
	else if(action == PUBLICATION_ACTION_UPDATE_LEAF || action == PUBLICATION_ACTION_APPEND_LEAF)
	{
		_jparser.parseByNameThrow("leaf", leaf);
	}
}

/* static */ void TableClient::publication::PublOnlineUpdateItem::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	char action = '0';
	if(!_jparser.validateByName("a", action)) _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	if (action == PUBLICATION_ACTION_ATTACH_MSG)
	{
		AttachedPublMsg attchedMsg; _jparser.validateByNameThrow("attchedMsg", attchedMsg);
	}
	else if(action == PUBLICATION_ACTION_APPEND_NODE)
	{
		Atf::AtfVectorBase< UINT16 > path; _jparser.validateByNameThrow("path", path);
		AtfValidator::validateInt(_descr, "path", path.size(), _checker, __FILE__, __LINE__);
	}
	else if (action == PUBLICATION_ACTION_REMOVE_NODE || action == PUBLICATION_ACTION_REMOVE_LEAF)
	{
		Atf::AtfVectorBase< UINT16 > path; _jparser.validateByNameThrow("path", path);
		AtfValidator::validateInt(_descr, "path", path.size(), _checker, __FILE__, __LINE__);
		UINT16 idx; _jparser.validateByNameThrow("idx", idx);
		AtfValidator::validateInt(_descr, "idx", idx, _checker, __FILE__, __LINE__);
	}
	else if(action == PUBLICATION_ACTION_UPDATE_LEAF || action == PUBLICATION_ACTION_APPEND_LEAF)
	{
		AppendOrUpdateLeafMsg leaf; _jparser.validateByNameThrow("leaf", leaf);
	}
}

/*static*/ void TableClient::publication::PublOnlineUpdateItem::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	char action = '0';
	{ INT8 _n; _parser.parseINT8(_n); action = _n; }
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	if (action == PUBLICATION_ACTION_ATTACH_MSG)
	{
		PString _descbuf;
		AttachedPublMsg::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("attchedMsg"), _fieldsWithUnparsedContent);
	}
	else if(action == PUBLICATION_ACTION_APPEND_NODE)
	{
		PString _descbuf;
		int szPath = Atf::LAtfVector< UINT16, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "path", szPath, _checker, __FILE__, __LINE__);
	}
	else if (action == PUBLICATION_ACTION_REMOVE_NODE || action == PUBLICATION_ACTION_REMOVE_LEAF)
	{
		PString _descbuf;
		int szPath = Atf::LAtfVector< UINT16, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("path"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "path", szPath, _checker, __FILE__, __LINE__);
		UINT16 idx; _parser.parseUINT16(idx);
		AtfValidator::validateInt(_descr, "idx", idx, _checker, __FILE__, __LINE__);
	}
	else if(action == PUBLICATION_ACTION_UPDATE_LEAF || action == PUBLICATION_ACTION_APPEND_LEAF)
	{
		PString _descbuf;
		AppendOrUpdateLeafMsg::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("leaf"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                Protocol_MSG_PUBLICATION_UPDATE
//=================================================================

// @Override
bool TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::equals(const Protocol_MSG_PUBLICATION_UPDATE& _o) const
{
	
	if((rootRevBeforeUpdate == 0 && rootRevAfterUpdate == 0) || (_o.rootRevBeforeUpdate == 0 && _o.rootRevAfterUpdate == 0))
	{
		return true;
	}
	else
	{
		UINT32 _i = 0, _j = 0;
		while (_i < updates.size() && _j < _o.updates.size())
		{
			if (updates[ _i ].canBeSkippedInComparison())
			{
				++_i;
				continue;
			}
			if (_o.updates[ _j ].canBeSkippedInComparison())
			{
				++_j;
				continue;
			}
			if (! Atf::AtfTempl< PublOnlineUpdateItem >::Equals(updates[ _i ], _o.updates[ _j ]))
			{
				return false;
			}
			++_i;
			++_j;
		}
		if (_i == updates.size())
		{
			while (_j < _o.updates.size() && _o.updates[ _j ].canBeSkippedInComparison())
			{
				++_j;
			}			
			return _j == _o.updates.size();
		}
		else
		{
			while (_i < updates.size() && updates[ _i ].canBeSkippedInComparison())
			{
				++_i;
			}			
			return _i == updates.size();
		}
	}
}

// @Override
bool TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PUBLICATION_UPDATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()) )
	{
		return false;
	}
	else
	{ 
		return equals(*((Protocol_MSG_PUBLICATION_UPDATE*)_other));
	}
}

TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::Protocol_MSG_PUBLICATION_UPDATE(): updates("30") 
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::Protocol_MSG_PUBLICATION_UPDATE(Protocol_MSG_PUBLICATION_UPDATE&& _o)
	: thisid(std::move(_o.thisid))
	, peerid(std::move(_o.peerid))
	, rootRevBeforeUpdate(std::move(_o.rootRevBeforeUpdate))
	, updates(std::move(_o.updates))
	, rootRevAfterUpdate(std::move(_o.rootRevAfterUpdate))
{
}

TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE& TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::operator=(Protocol_MSG_PUBLICATION_UPDATE&& _o)
{
	if(this != &_o)
	{
		thisid = std::move(_o.thisid);
		peerid = std::move(_o.peerid);
		rootRevBeforeUpdate = std::move(_o.rootRevBeforeUpdate);
		updates = std::move(_o.updates);
		rootRevAfterUpdate = std::move(_o.rootRevAfterUpdate);
	}
	return *this;
}

#endif

void TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::clear()
{
	thisid = 0;
	peerid = 0;
	rootRevBeforeUpdate = 0;
	updates.clear();
	rootRevAfterUpdate = 0;
}

const char *TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PUBLICATION_UPDATE).append(")");
	_buf.append(',');
	_buf.append("thisid=");
	_buf.appendUint(thisid);
	_buf.append(',');
	_buf.append("peerid=");
	_buf.appendUint(peerid);
	_buf.append(',');
	_buf.append("rootRevBeforeUpdate=");
	_buf.appendUint(rootRevBeforeUpdate);
	_buf.append(',');
	_buf.append("updates=");
	updates.toTraceString(_buf);
	_buf.append(',');
	_buf.append("rootRevAfterUpdate=");
	_buf.appendUint(rootRevAfterUpdate);
	return _buf.c_str();
}

const char *TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PUBLICATION_UPDATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("thisid", thisid, _buf);
	Atf::XmlElement::encodeAsXmlElement("peerid", peerid, _buf);
	Atf::XmlElement::encodeAsXmlElement("rootRevBeforeUpdate", rootRevBeforeUpdate, _buf);
	updates.toXmlString("updates", _buf);
	Atf::XmlElement::encodeAsXmlElement("rootRevAfterUpdate", rootRevAfterUpdate, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("thisid"))
			{
				thisid = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("peerid"))
			{
				peerid = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rootRevBeforeUpdate"))
			{
				rootRevBeforeUpdate = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("updates"))
			{
				if(!Atf::AtfTempl< Atf::AtfVectorWithSpecialTerminator< PublOnlineUpdateItem > >::FromXmlString(_value, updates)) return false;
			}
			else if (_element.equals("rootRevAfterUpdate"))
			{
				rootRevAfterUpdate = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(thisid);
	_msg.composeUINT32(peerid);
	_msg.composeUINT32(rootRevBeforeUpdate);
	updates.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(rootRevAfterUpdate);
}

void TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(thisid);
	_parser.parseUINT32(peerid);
	_parser.parseUINT32(rootRevBeforeUpdate);
	updates.parseMsg(_parser);
	_parser.parseUINT32(rootRevAfterUpdate);
}

const char *TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("thisid", thisid);
	_jsonstr.compose("peerid", peerid);
	_jsonstr.compose("rootRevBeforeUpdate", rootRevBeforeUpdate);
	_jsonstr.compose("updates", updates);
	_jsonstr.compose("rootRevAfterUpdate", rootRevAfterUpdate);
	return _buf.c_str();
}

void TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("thisid", thisid);
	_jparser.parseByNameThrow("peerid", peerid);
	_jparser.parseByNameThrow("rootRevBeforeUpdate", rootRevBeforeUpdate);
	_jparser.parseByNameThrow("updates", updates);
	_jparser.parseByNameThrow("rootRevAfterUpdate", rootRevAfterUpdate);
}

/*static*/ void TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PUBLICATION_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 thisid; _jparser.validateByNameThrow("thisid", thisid);
	AtfValidator::validateInt(_descr, "thisid", thisid, _checker, __FILE__, __LINE__);
	UINT32 peerid; _jparser.validateByNameThrow("peerid", peerid);
	AtfValidator::validateInt(_descr, "peerid", peerid, _checker, __FILE__, __LINE__);
	UINT32 rootRevBeforeUpdate; _jparser.validateByNameThrow("rootRevBeforeUpdate", rootRevBeforeUpdate);
	AtfValidator::validateInt(_descr, "rootRevBeforeUpdate", rootRevBeforeUpdate, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PublOnlineUpdateItem > updates; _jparser.validateByNameThrow("updates", updates);
	AtfValidator::validateInt(_descr, "updates", updates.size(), _checker, __FILE__, __LINE__);
	UINT32 rootRevAfterUpdate; _jparser.validateByNameThrow("rootRevAfterUpdate", rootRevAfterUpdate);
	AtfValidator::validateInt(_descr, "rootRevAfterUpdate", rootRevAfterUpdate, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::Protocol_MSG_PUBLICATION_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PUBLICATION_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 thisid; _parser.parseUINT32(thisid);
	AtfValidator::validateInt(_descr, "thisid", thisid, _checker, __FILE__, __LINE__);
	UINT32 peerid; _parser.parseUINT32(peerid);
	AtfValidator::validateInt(_descr, "peerid", peerid, _checker, __FILE__, __LINE__);
	UINT32 rootRevBeforeUpdate; _parser.parseUINT32(rootRevBeforeUpdate);
	AtfValidator::validateInt(_descr, "rootRevBeforeUpdate", rootRevBeforeUpdate, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szUpdates = Atf::AtfVectorWithSpecialTerminator< PublOnlineUpdateItem >::validateMsg(_parser, "30", _checker, _descbuf.assign(_descr).append('.').append("updates"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "updates", szUpdates, _checker, __FILE__, __LINE__);
	UINT32 rootRevAfterUpdate; _parser.parseUINT32(rootRevAfterUpdate);
	AtfValidator::validateInt(_descr, "rootRevAfterUpdate", rootRevAfterUpdate, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClientMsg_TxtEx_TableHistory_AllInCashout
//=================================================================

TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::ClientMsg_TxtEx_TableHistory_AllInCashout()
{
	clear();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::clear()
{
	code = 0;
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::equals(const ClientMsg_TxtEx_TableHistory_AllInCashout& _o) const
{
	return code == _o.code;
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("code=");
	_buf.appendUint(code);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("code", code, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("code"))
		{
			code = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(code);
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(code);
}

const char *TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("code", code);
	return _buf.c_str();
}

void TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("code", code);
}

/* static */ void TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE code; _jparser.validateByNameThrow("code", code);
	AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::ClientMsg_TxtEx_TableHistory_AllInCashout::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE code; _parser.parseBYTE(code);
	AtfValidator::validateInt(_descr, "code", code, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    AllInCashout_PlayerCashedOut_Data
//=================================================================

TableClient::publication::AllInCashout_PlayerCashedOut_Data::AllInCashout_PlayerCashedOut_Data()
{
	clear();
}

void TableClient::publication::AllInCashout_PlayerCashedOut_Data::clear()
{
	cashoutAmount = 0;
}

bool TableClient::publication::AllInCashout_PlayerCashedOut_Data::equals(const AllInCashout_PlayerCashedOut_Data& _o) const
{
	return cashoutAmount == _o.cashoutAmount;
}

const char *TableClient::publication::AllInCashout_PlayerCashedOut_Data::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cashoutAmount=");
	_buf.appendInt64(cashoutAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AllInCashout_PlayerCashedOut_Data::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cashoutAmount", cashoutAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AllInCashout_PlayerCashedOut_Data::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cashoutAmount"))
		{
			cashoutAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::AllInCashout_PlayerCashedOut_Data::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(cashoutAmount);
}

void TableClient::publication::AllInCashout_PlayerCashedOut_Data::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(cashoutAmount);
}

const char *TableClient::publication::AllInCashout_PlayerCashedOut_Data::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cashoutAmount", cashoutAmount);
	return _buf.c_str();
}

void TableClient::publication::AllInCashout_PlayerCashedOut_Data::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cashoutAmount", cashoutAmount);
}

/* static */ void TableClient::publication::AllInCashout_PlayerCashedOut_Data::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 cashoutAmount; _jparser.validateByNameThrow("cashoutAmount", cashoutAmount);
	AtfValidator::validateInt(_descr, "cashoutAmount", cashoutAmount, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::AllInCashout_PlayerCashedOut_Data::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT64 cashoutAmount; _parser.parseINT64(cashoutAmount);
	AtfValidator::validateInt(_descr, "cashoutAmount", cashoutAmount, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    AllInCashout_ResumingHand_Data
//=================================================================

TableClient::publication::AllInCashout_ResumingHand_Data::AllInCashout_ResumingHand_Data()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::publication::AllInCashout_ResumingHand_Data::AllInCashout_ResumingHand_Data(AllInCashout_ResumingHand_Data&& _o)
	: activePlayers(std::move(_o.activePlayers))
{
}

TableClient::publication::AllInCashout_ResumingHand_Data& TableClient::publication::AllInCashout_ResumingHand_Data::operator=(AllInCashout_ResumingHand_Data&& _o)
{
	if(this != &_o)
	{
		activePlayers = std::move(_o.activePlayers);
	}
	return *this;
}

#endif

void TableClient::publication::AllInCashout_ResumingHand_Data::clear()
{
	activePlayers.clear();
}

bool TableClient::publication::AllInCashout_ResumingHand_Data::equals(const AllInCashout_ResumingHand_Data& _o) const
{
	return activePlayers.equals(_o.activePlayers);
}

const char *TableClient::publication::AllInCashout_ResumingHand_Data::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("activePlayers=");
	activePlayers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TableClient::publication::AllInCashout_ResumingHand_Data::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	activePlayers.toXmlString("activePlayers", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TableClient::publication::AllInCashout_ResumingHand_Data::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("activePlayers"))
		{
			if(!Atf::AtfTempl< Atf::AtfVector0< PString, 1 > >::FromXmlString(_value, activePlayers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TableClient::publication::AllInCashout_ResumingHand_Data::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	activePlayers.composeMsg(_msg, _ignoreJSON);
}

void TableClient::publication::AllInCashout_ResumingHand_Data::parseMsg(CommMsgParser& _parser)
{
	activePlayers.parseMsg(_parser);
}

const char *TableClient::publication::AllInCashout_ResumingHand_Data::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("activePlayers", activePlayers);
	return _buf.c_str();
}

void TableClient::publication::AllInCashout_ResumingHand_Data::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("activePlayers", activePlayers);
}

/* static */ void TableClient::publication::AllInCashout_ResumingHand_Data::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PString > activePlayers; _jparser.validateByNameThrow("activePlayers", activePlayers);
	AtfValidator::validateInt(_descr, "activePlayers", activePlayers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::publication::AllInCashout_ResumingHand_Data::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szActivePlayers = Atf::AtfVector0< PString, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("activePlayers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "activePlayers", szActivePlayers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_TABLE_IHH_GET_HANDBLOB
//=================================================================

TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::Protocol_MSG_TABLE_IHH_GET_HANDBLOB()
{
	clear();
}

void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::clear()
{
	handId = 0;
}

bool TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::equals(const Protocol_MSG_TABLE_IHH_GET_HANDBLOB& _o) const
{
	return handId == _o.handId;
}

bool TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_IHH_GET_HANDBLOB != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_IHH_GET_HANDBLOB*)_other));
}

const char *TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_IHH_GET_HANDBLOB).append(")");
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	return _buf.c_str();
}

const char *TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_IHH_GET_HANDBLOB).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
}

void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
}

const char *TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handId", handId);
	return _buf.c_str();
}

void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handId", handId);
}

/*static*/ void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_IHH_GET_HANDBLOB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
}

/*static*/ void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_IHH_GET_HANDBLOB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY
//=================================================================

TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY(Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY&& _o)
	: errcode(std::move(_o.errcode))
	, errstr(std::move(_o.errstr))
	, handId(std::move(_o.handId))
	, zipped(std::move(_o.zipped))
	, blob(std::move(_o.blob))
{
}

TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY& TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::operator=(Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY&& _o)
{
	if(this != &_o)
	{
		errcode = std::move(_o.errcode);
		errstr = std::move(_o.errstr);
		handId = std::move(_o.handId);
		zipped = std::move(_o.zipped);
		blob = std::move(_o.blob);
	}
	return *this;
}

#endif

void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::clear()
{
	errcode = 0;
	errstr.clear();
	handId = 0;
	zipped = false;
	blob.clear();
}

bool TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::equals(const Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY& _o) const
{
	return errcode == _o.errcode &&
		Atf::atfPStringEquals(errstr, _o.errstr) &&
		handId == _o.handId &&
		zipped == _o.zipped &&
		blob.size() == _o.blob.size() && memcmp(blob.ptr(), _o.blob.ptr(), blob.size()) == 0;
}

bool TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_TABLE_IHH_GET_HANDBLOB_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY*)_other));
}

const char *TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_TABLE_IHH_GET_HANDBLOB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errcode=");
	_buf.appendUint(errcode);
	if(errcode)
	{
		_buf.append(',');
		_buf.append("errstr=");
		_buf.append(errstr);
	}
	else
	{
		_buf.append(',');
		_buf.append("handId=");
		_buf.appendUint64(handId);
		_buf.append(',');
		_buf.append("zipped=");
		_buf.appendUint(zipped);
		_buf.append(',');
		_buf.append("blob=");
		_buf.append("...");
	}
	return _buf.c_str();
}

const char *TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_TABLE_IHH_GET_HANDBLOB_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errcode", errcode, _buf);
	if(errcode)
	{
		Atf::XmlElement::encodeAsXmlElement("errstr", errstr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
		Atf::XmlElement::encodeAsXmlElement("zipped", zipped, _buf);
		Atf::XmlElement::encodeAsXmlElement("blob", blob, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errcode"))
			{
				errcode = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errstr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errstr)) return false;
			}
			else if (_element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("zipped"))
			{
				zipped = (*_value.ptr() == '1');
			}
			else if (_element.equals("blob"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, blob);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(errcode);
	if(errcode)
	{
		_msg.composeString(errstr);
	}
	else
	{
		_msg.composeUINT64(handId);
		_msg.composeBOOL(zipped);
		_msg._composeVarBlock(blob.ptr(), blob.size());
	}
}

void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(errcode);
	if(errcode)
	{
		_parser.parseStringP(errstr);
	}
	else
	{
		_parser.parseUINT64(handId);
		_parser.parseBOOL(zipped);
		_parser.parsePBlock(blob);
	}
}

const char *TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errcode", errcode);
	if(errcode)
	{
		_jsonstr.compose("errstr", errstr);
	}
	else
	{
		_jsonstr.compose("handId", handId);
		_jsonstr.compose("zipped", zipped);
		_jsonstr.compose("blob", blob);
	}
	return _buf.c_str();
}

void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errcode", errcode);
	if(errcode)
	{
		_jparser.parseByNameThrow("errstr", errstr);
	}
	else
	{
		_jparser.parseByNameThrow("handId", handId);
		_jparser.parseByNameThrow("zipped", zipped);
		_jparser.parseByNameThrow("blob", blob);
	}
}

/*static*/ void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_IHH_GET_HANDBLOB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE errcode = 0;
	_jparser.validateByNameThrow("errcode", errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if(errcode)
	{
		PString errstr; _jparser.validateByNameThrow("errstr", errstr);
		AtfValidator::validateInt(_descr, "errstr", errstr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 handId; _jparser.validateByNameThrow("handId", handId);
		AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
		bool zipped; _jparser.validateByNameThrow("zipped", zipped);
		AtfValidator::validateInt(_descr, "zipped", zipped, _checker, __FILE__, __LINE__);
		PBlock blob; _jparser.validateByNameThrow("blob", blob);
		AtfValidator::validateInt(_descr, "blob", blob.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void TableClient::ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_TABLE_IHH_GET_HANDBLOB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	BYTE errcode = 0;
	_parser.parseBYTE(errcode);
	AtfValidator::validateInt(_descr, "errcode", errcode, _checker, __FILE__, __LINE__);
	if(errcode)
	{
		_parser.parseStringN(_dummy, 0, "errstr"); size_t szErrstr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errstr", szErrstr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 handId; _parser.parseUINT64(handId);
		AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
		bool zipped; _parser.parseBOOL(zipped);
		AtfValidator::validateInt(_descr, "zipped", zipped, _checker, __FILE__, __LINE__);
		const BYTE* blob; size_t szBlob; _parser._parseVarBlock(blob, szBlob);  /*blob*/
		AtfValidator::validateInt(_descr, "blob", szBlob, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* TableClient::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "ihh"))
	{
		switch(_msgId)
		{
			case MSG_TABLE_IHH_GET_HANDBLOB: _obj = new ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB(); break;
			case MSG_TABLE_IHH_GET_HANDBLOB_REPLY: _obj = new ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_TABLE_ACTION: _obj = new player::Protocol_MSG_TABLE_ACTION(); break;
			case MSG_TABLE_ADDCHIPS: _obj = new player::Protocol_MSG_TABLE_ADDCHIPS(); break;
			case MSG_TABLE_ADDCHIPS_AUTO_REPLY: _obj = new player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY(); break;
			case MSG_TABLE_ADDCHIPS_REPLY: _obj = new player::Protocol_MSG_TABLE_ADDCHIPS_REPLY(); break;
			case MSG_TABLE_ADDONCHIPS: _obj = new player::Protocol_MSG_TABLE_ADDONCHIPS(); break;
			case MSG_TABLE_ADDONCHIPS_REPLY: _obj = new player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY(); break;
			case MSG_TABLE_ADMIN_INFO: _obj = new player::Protocol_MSG_TABLE_ADMIN_INFO(); break;
			case MSG_TABLE_ADVANCED_BET: _obj = new player::Protocol_MSG_TABLE_ADVANCED_BET(); break;
			case MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY: _obj = new player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY(); break;
			case MSG_TABLE_BLITZ_KICK: _obj = new player::Protocol_MSG_TABLE_BLITZ_KICK(); break;
			case MSG_TABLE_BLITZ_MTT_KICK: _obj = new player::Protocol_MSG_TABLE_BLITZ_MTT_KICK(); break;
			case MSG_TABLE_BOUNTY_GREETINGS: _obj = new player::Protocol_MSG_TABLE_BOUNTY_GREETINGS(); break;
			case MSG_TABLE_CANCELACTION: _obj = new player::Protocol_MSG_TABLE_CANCELACTION(); break;
			case MSG_TABLE_CHAT2: _obj = new player::Protocol_MSG_TABLE_CHAT2(); break;
			case MSG_TABLE_CHAT2_REPLY: _obj = new player::Protocol_MSG_TABLE_CHAT2_REPLY(); break;
			case MSG_TABLE_CHIPSAVAIL: _obj = new player::Protocol_MSG_TABLE_CHIPSAVAIL(); break;
			case MSG_TABLE_CHIPSAVAIL_REPLY: _obj = new player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY(); break;
			case MSG_TABLE_ENTROPY: _obj = new player::Protocol_MSG_TABLE_ENTROPY(); break;
			case MSG_TABLE_FAST_FOLD: _obj = new player::Protocol_MSG_TABLE_FAST_FOLD(); break;
			case MSG_TABLE_FORCE_SITOUT: _obj = new player::Protocol_MSG_TABLE_FORCE_SITOUT(); break;
			case MSG_TABLE_GET_DEAL: _obj = new player::Protocol_MSG_TABLE_GET_DEAL(); break;
			case MSG_TABLE_GET_DEAL_REPLY: _obj = new player::Protocol_MSG_TABLE_GET_DEAL_REPLY(); break;
			case MSG_TABLE_GOTO_NEXTHAND: _obj = new player::Protocol_MSG_TABLE_GOTO_NEXTHAND(); break;
			case MSG_TABLE_HAND_RANK: _obj = new player::Protocol_MSG_TABLE_HAND_RANK(); break;
			case MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS: _obj = new player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS(); break;
			case MSG_TABLE_LOGIN: _obj = new player::Protocol_MSG_TABLE_LOGIN(); break;
			case MSG_TABLE_LOGIN_REPLY: _obj = new player::Protocol_MSG_TABLE_LOGIN_REPLY(); break;
			case MSG_TABLE_LOGOUT: _obj = new player::Protocol_MSG_TABLE_LOGOUT(); break;
			case MSG_TABLE_LOGOUT_REPLY: _obj = new player::Protocol_MSG_TABLE_LOGOUT_REPLY(); break;
			case MSG_TABLE_MTT_CHANGETABLE: _obj = new player::Protocol_MSG_TABLE_MTT_CHANGETABLE(); break;
			case MSG_TABLE_NSTACK_RELOAD: _obj = new player::Protocol_MSG_TABLE_NSTACK_RELOAD(); break;
			case MSG_TABLE_NSTACK_RELOAD_REPLY: _obj = new player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY(); break;
			case MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE: _obj = new player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE(); break;
			case MSG_TABLE_PLAYNOW: _obj = new player::Protocol_MSG_TABLE_PLAYNOW(); break;
			case MSG_TABLE_POWER_CARD_PLAY: _obj = new player::Protocol_MSG_TABLE_POWER_CARD_PLAY(); break;
			case MSG_TABLE_POWER_CARD_PLAY_REPLY: _obj = new player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY(); break;
			case MSG_TABLE_POWER_CARD_PRESELECT: _obj = new player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT(); break;
			case MSG_TABLE_POWER_CHANGE_FUTURE: _obj = new player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE(); break;
			case MSG_TABLE_POWER_CHANGE_FUTURE_ACK: _obj = new player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK(); break;
			case MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL: _obj = new player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL(); break;
			case MSG_TABLE_POWER_CHANGE_FUTURE_REPLY: _obj = new player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY(); break;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD: _obj = new player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD(); break;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK: _obj = new player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK(); break;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL: _obj = new player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL(); break;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY: _obj = new player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY(); break;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS: _obj = new player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS(); break;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK: _obj = new player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK(); break;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL: _obj = new player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL(); break;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY: _obj = new player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY(); break;
			case MSG_TABLE_POWER_DARK_BET: _obj = new player::Protocol_MSG_TABLE_POWER_DARK_BET(); break;
			case MSG_TABLE_POWER_DARK_BET_ACK: _obj = new player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK(); break;
			case MSG_TABLE_POWER_DARK_BET_CANCEL: _obj = new player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL(); break;
			case MSG_TABLE_POWER_DARK_BET_REPLY: _obj = new player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY(); break;
			case MSG_TABLE_POWER_DETECT_HOLECARDS: _obj = new player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS(); break;
			case MSG_TABLE_POWER_MOUSE_OVER: _obj = new player::Protocol_MSG_TABLE_POWER_MOUSE_OVER(); break;
			case MSG_TABLE_POWER_PLAYERS_CHOICE: _obj = new player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE(); break;
			case MSG_TABLE_POWER_PLAYERS_CHOICE_ACK: _obj = new player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK(); break;
			case MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL: _obj = new player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL(); break;
			case MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY: _obj = new player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY(); break;
			case MSG_TABLE_POWER_POSSESSION: _obj = new player::Protocol_MSG_TABLE_POWER_POSSESSION(); break;
			case MSG_TABLE_POWER_PRIVATE_ANIMATION: _obj = new player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION(); break;
			case MSG_TABLE_POWER_PRIVATE_EFFECT: _obj = new player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT(); break;
			case MSG_TABLE_POWER_REDRAW: _obj = new player::Protocol_MSG_TABLE_POWER_REDRAW(); break;
			case MSG_TABLE_POWER_REDRAW_ACK: _obj = new player::Protocol_MSG_TABLE_POWER_REDRAW_ACK(); break;
			case MSG_TABLE_POWER_REDRAW_CANCEL: _obj = new player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL(); break;
			case MSG_TABLE_POWER_REDRAW_REPLY: _obj = new player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY(); break;
			case MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS: _obj = new player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS(); break;
			case MSG_TABLE_POWER_STATUS_UPDATE: _obj = new player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE(); break;
			case MSG_TABLE_REBUYCHIPS: _obj = new player::Protocol_MSG_TABLE_REBUYCHIPS(); break;
			case MSG_TABLE_REBUYCHIPS_REPLY: _obj = new player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY(); break;
			case MSG_TABLE_REFRESH: _obj = new player::Protocol_MSG_TABLE_REFRESH(); break;
			case MSG_TABLE_REFRESH_REPLY: _obj = new player::Protocol_MSG_TABLE_REFRESH_REPLY(); break;
			case MSG_TABLE_REQUESTACTION: _obj = new player::Protocol_MSG_TABLE_REQUESTACTION(); break;
			case MSG_TABLE_REQUESTACTION_REPLY: _obj = new player::Protocol_MSG_TABLE_REQUESTACTION_REPLY(); break;
			case MSG_TABLE_SAGMAX_USER_DRAW: _obj = new player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW(); break;
			case MSG_TABLE_SET_AUTO_REBUY: _obj = new player::Protocol_MSG_TABLE_SET_AUTO_REBUY(); break;
			case MSG_TABLE_SET_AUTO_REBUY_REPLY: _obj = new player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY(); break;
			case MSG_TABLE_SET_DEAL: _obj = new player::Protocol_MSG_TABLE_SET_DEAL(); break;
			case MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE: _obj = new player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE(); break;
			case MSG_TABLE_SET_SHOW_WHEN_ALLIN: _obj = new player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN(); break;
			case MSG_TABLE_SIT1: _obj = new player::Protocol_MSG_TABLE_SIT1(); break;
			case MSG_TABLE_SIT1_REPLY: _obj = new player::Protocol_MSG_TABLE_SIT1_REPLY(); break;
			case MSG_TABLE_SIT2: _obj = new player::Protocol_MSG_TABLE_SIT2(); break;
			case MSG_TABLE_SIT2_KICK: _obj = new player::Protocol_MSG_TABLE_SIT2_KICK(); break;
			case MSG_TABLE_SIT2_REPLY: _obj = new player::Protocol_MSG_TABLE_SIT2_REPLY(); break;
			case MSG_TABLE_SITIN: _obj = new player::Protocol_MSG_TABLE_SITIN(); break;
			case MSG_TABLE_SITIN_REPLY: _obj = new player::Protocol_MSG_TABLE_SITIN_REPLY(); break;
			case MSG_TABLE_SITOUT: _obj = new player::Protocol_MSG_TABLE_SITOUT(); break;
			case MSG_TABLE_SITOUT_NEXTHAND: _obj = new player::Protocol_MSG_TABLE_SITOUT_NEXTHAND(); break;
			case MSG_TABLE_SITOUT_REPLY: _obj = new player::Protocol_MSG_TABLE_SITOUT_REPLY(); break;
			case MSG_TABLE_SITTING_STATUS: _obj = new player::Protocol_MSG_TABLE_SITTING_STATUS(); break;
			case MSG_TABLE_SIT_KICK: _obj = new player::Protocol_MSG_TABLE_SIT_KICK(); break;
			case MSG_TABLE_START_CAMPING_PREVENTION: _obj = new player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION(); break;
			case MSG_TABLE_STATISTIC: _obj = new player::Protocol_MSG_TABLE_STATISTIC(); break;
			case MSG_TABLE_THROW: _obj = new player::Protocol_MSG_TABLE_THROW(); break;
			case MSG_TABLE_THROW_REPLY: _obj = new player::Protocol_MSG_TABLE_THROW_REPLY(); break;
			case MSG_TABLE_TIMEBANK: _obj = new player::Protocol_MSG_TABLE_TIMEBANK(); break;
			case MSG_TABLE_USER_CHAT_BAN: _obj = new player::Protocol_MSG_TABLE_USER_CHAT_BAN(); break;
			case MSG_TABLE_USER_CHAT_WARN: _obj = new player::Protocol_MSG_TABLE_USER_CHAT_WARN(); break;
			case MSG_TABLE_USER_DICTIONARY_UPDATE: _obj = new player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE(); break;
			case MSG_TABLE_USER_MINI_CHAT_REQUEST: _obj = new player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST(); break;
			case MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE: _obj = new player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE(); break;
			case MSG_TABLE_USER_SPECIFIC_BROADCAST: _obj = new player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST(); break;
			case MSG_TABLE_WARNING_BELL: _obj = new player::Protocol_MSG_TABLE_WARNING_BELL(); break;
		}
	}
	else if(!strcmp(_nameSpace, "publication"))
	{
		switch(_msgId)
		{
			case MSG_PUBLICATION_UPDATE: _obj = new publication::Protocol_MSG_PUBLICATION_UPDATE(); break;
			case MSG_TABLE_SUBSCR_ACTION: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_ACTION(); break;
			case MSG_TABLE_SUBSCR_ACTIVESEAT: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT(); break;
			case MSG_TABLE_SUBSCR_ANIMATION: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION(); break;
			case MSG_TABLE_SUBSCR_BEGINHAND: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND(); break;
			case MSG_TABLE_SUBSCR_CHAT_BUBBLE: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE(); break;
			case MSG_TABLE_SUBSCR_DEALBOARD: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD(); break;
			case MSG_TABLE_SUBSCR_DEALBOARD_RIT: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT(); break;
			case MSG_TABLE_SUBSCR_DEALPLAYERCARDS: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS(); break;
			case MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE(); break;
			case MSG_TABLE_SUBSCR_ENDHAND: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND(); break;
			case MSG_TABLE_SUBSCR_I18N_MESSAGE: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE(); break;
			case MSG_TABLE_SUBSCR_KNOCKOUT: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT(); break;
			case MSG_TABLE_SUBSCR_MESSAGE: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE(); break;
			case MSG_TABLE_SUBSCR_MESSAGE2: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2(); break;
			case MSG_TABLE_SUBSCR_MOVEFROMPOT: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT(); break;
			case MSG_TABLE_SUBSCR_MOVETOPOT: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT(); break;
			case MSG_TABLE_SUBSCR_NEWGAME: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME(); break;
			case MSG_TABLE_SUBSCR_POT_DISTRIBUTION: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION(); break;
			case MSG_TABLE_SUBSCR_POWER_PLAY: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY(); break;
			case MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET(); break;
			case MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS(); break;
			case MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE(); break;
			case MSG_TABLE_SUBSCR_SHOW_POT_WINNERS: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS(); break;
			case MSG_TABLE_SUBSCR_THROW: _obj = new publication::Protocol_MSG_TABLE_SUBSCR_THROW(); break;
			case MSG_TABLE_USER_MINI_CHAT_BROADCAST: _obj = new publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST(); break;
		}
	}
	
	return _obj;
}

/* static */ bool TableClient::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "ihh"))
	{
		switch(_msgId)
		{
			case MSG_TABLE_IHH_GET_HANDBLOB: ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_IHH_GET_HANDBLOB_REPLY: ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_TABLE_ACTION: player::Protocol_MSG_TABLE_ACTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDCHIPS: player::Protocol_MSG_TABLE_ADDCHIPS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDCHIPS_AUTO_REPLY: player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDCHIPS_REPLY: player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDONCHIPS: player::Protocol_MSG_TABLE_ADDONCHIPS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDONCHIPS_REPLY: player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADMIN_INFO: player::Protocol_MSG_TABLE_ADMIN_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADVANCED_BET: player::Protocol_MSG_TABLE_ADVANCED_BET::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY: player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_BLITZ_KICK: player::Protocol_MSG_TABLE_BLITZ_KICK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_BLITZ_MTT_KICK: player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_BOUNTY_GREETINGS: player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CANCELACTION: player::Protocol_MSG_TABLE_CANCELACTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2: player::Protocol_MSG_TABLE_CHAT2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2_REPLY: player::Protocol_MSG_TABLE_CHAT2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHIPSAVAIL: player::Protocol_MSG_TABLE_CHIPSAVAIL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHIPSAVAIL_REPLY: player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ENTROPY: player::Protocol_MSG_TABLE_ENTROPY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_FAST_FOLD: player::Protocol_MSG_TABLE_FAST_FOLD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_FORCE_SITOUT: player::Protocol_MSG_TABLE_FORCE_SITOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_GET_DEAL: player::Protocol_MSG_TABLE_GET_DEAL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_GET_DEAL_REPLY: player::Protocol_MSG_TABLE_GET_DEAL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_GOTO_NEXTHAND: player::Protocol_MSG_TABLE_GOTO_NEXTHAND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_HAND_RANK: player::Protocol_MSG_TABLE_HAND_RANK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS: player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN: player::Protocol_MSG_TABLE_LOGIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN_REPLY: player::Protocol_MSG_TABLE_LOGIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGOUT: player::Protocol_MSG_TABLE_LOGOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGOUT_REPLY: player::Protocol_MSG_TABLE_LOGOUT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_MTT_CHANGETABLE: player::Protocol_MSG_TABLE_MTT_CHANGETABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_NSTACK_RELOAD: player::Protocol_MSG_TABLE_NSTACK_RELOAD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_NSTACK_RELOAD_REPLY: player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE: player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_PLAYNOW: player::Protocol_MSG_TABLE_PLAYNOW::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CARD_PLAY: player::Protocol_MSG_TABLE_POWER_CARD_PLAY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CARD_PLAY_REPLY: player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CARD_PRESELECT: player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHANGE_FUTURE: player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHANGE_FUTURE_ACK: player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL: player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHANGE_FUTURE_REPLY: player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD: player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK: player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL: player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY: player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS: player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK: player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL: player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY: player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DARK_BET: player::Protocol_MSG_TABLE_POWER_DARK_BET::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DARK_BET_ACK: player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DARK_BET_CANCEL: player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DARK_BET_REPLY: player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DETECT_HOLECARDS: player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_MOUSE_OVER: player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PLAYERS_CHOICE: player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PLAYERS_CHOICE_ACK: player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL: player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY: player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_POSSESSION: player::Protocol_MSG_TABLE_POWER_POSSESSION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PRIVATE_ANIMATION: player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PRIVATE_EFFECT: player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_REDRAW: player::Protocol_MSG_TABLE_POWER_REDRAW::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_REDRAW_ACK: player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_REDRAW_CANCEL: player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_REDRAW_REPLY: player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS: player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_STATUS_UPDATE: player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REBUYCHIPS: player::Protocol_MSG_TABLE_REBUYCHIPS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REBUYCHIPS_REPLY: player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REFRESH: player::Protocol_MSG_TABLE_REFRESH::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REFRESH_REPLY: player::Protocol_MSG_TABLE_REFRESH_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REQUESTACTION: player::Protocol_MSG_TABLE_REQUESTACTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REQUESTACTION_REPLY: player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SAGMAX_USER_DRAW: player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_AUTO_REBUY: player::Protocol_MSG_TABLE_SET_AUTO_REBUY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_AUTO_REBUY_REPLY: player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_DEAL: player::Protocol_MSG_TABLE_SET_DEAL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE: player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_SHOW_WHEN_ALLIN: player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT1: player::Protocol_MSG_TABLE_SIT1::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT1_REPLY: player::Protocol_MSG_TABLE_SIT1_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT2: player::Protocol_MSG_TABLE_SIT2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT2_KICK: player::Protocol_MSG_TABLE_SIT2_KICK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT2_REPLY: player::Protocol_MSG_TABLE_SIT2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITIN: player::Protocol_MSG_TABLE_SITIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITIN_REPLY: player::Protocol_MSG_TABLE_SITIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITOUT: player::Protocol_MSG_TABLE_SITOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITOUT_NEXTHAND: player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITOUT_REPLY: player::Protocol_MSG_TABLE_SITOUT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITTING_STATUS: player::Protocol_MSG_TABLE_SITTING_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT_KICK: player::Protocol_MSG_TABLE_SIT_KICK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_START_CAMPING_PREVENTION: player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_STATISTIC: player::Protocol_MSG_TABLE_STATISTIC::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_THROW: player::Protocol_MSG_TABLE_THROW::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_THROW_REPLY: player::Protocol_MSG_TABLE_THROW_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_TIMEBANK: player::Protocol_MSG_TABLE_TIMEBANK::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_CHAT_BAN: player::Protocol_MSG_TABLE_USER_CHAT_BAN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_CHAT_WARN: player::Protocol_MSG_TABLE_USER_CHAT_WARN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_DICTIONARY_UPDATE: player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_MINI_CHAT_REQUEST: player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE: player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_SPECIFIC_BROADCAST: player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_WARNING_BELL: player::Protocol_MSG_TABLE_WARNING_BELL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "publication"))
	{
		switch(_msgId)
		{
			case MSG_PUBLICATION_UPDATE: publication::Protocol_MSG_PUBLICATION_UPDATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_ACTION: publication::Protocol_MSG_TABLE_SUBSCR_ACTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_ACTIVESEAT: publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_ANIMATION: publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_BEGINHAND: publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_CHAT_BUBBLE: publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_DEALBOARD: publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_DEALBOARD_RIT: publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_DEALPLAYERCARDS: publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE: publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_ENDHAND: publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_I18N_MESSAGE: publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_KNOCKOUT: publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_MESSAGE: publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_MESSAGE2: publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_MOVEFROMPOT: publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_MOVETOPOT: publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_NEWGAME: publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_POT_DISTRIBUTION: publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_POWER_PLAY: publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET: publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS: publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE: publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_SHOW_POT_WINNERS: publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_THROW: publication::Protocol_MSG_TABLE_SUBSCR_THROW::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_MINI_CHAT_BROADCAST: publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool TableClient::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "ihh"))
	{
		switch(_msgId)
		{
			case MSG_TABLE_IHH_GET_HANDBLOB: ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_IHH_GET_HANDBLOB_REPLY: ihh::Protocol_MSG_TABLE_IHH_GET_HANDBLOB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_TABLE_ACTION: player::Protocol_MSG_TABLE_ACTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDCHIPS: player::Protocol_MSG_TABLE_ADDCHIPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDCHIPS_AUTO_REPLY: player::Protocol_MSG_TABLE_ADDCHIPS_AUTO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDCHIPS_REPLY: player::Protocol_MSG_TABLE_ADDCHIPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDONCHIPS: player::Protocol_MSG_TABLE_ADDONCHIPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADDONCHIPS_REPLY: player::Protocol_MSG_TABLE_ADDONCHIPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADMIN_INFO: player::Protocol_MSG_TABLE_ADMIN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ADVANCED_BET: player::Protocol_MSG_TABLE_ADVANCED_BET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY: player::Protocol_MSG_TABLE_AUTO_RELOAD_STACKS_NOTIFY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_BLITZ_KICK: player::Protocol_MSG_TABLE_BLITZ_KICK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_BLITZ_MTT_KICK: player::Protocol_MSG_TABLE_BLITZ_MTT_KICK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_BOUNTY_GREETINGS: player::Protocol_MSG_TABLE_BOUNTY_GREETINGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CANCELACTION: player::Protocol_MSG_TABLE_CANCELACTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2: player::Protocol_MSG_TABLE_CHAT2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHAT2_REPLY: player::Protocol_MSG_TABLE_CHAT2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHIPSAVAIL: player::Protocol_MSG_TABLE_CHIPSAVAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_CHIPSAVAIL_REPLY: player::Protocol_MSG_TABLE_CHIPSAVAIL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_ENTROPY: player::Protocol_MSG_TABLE_ENTROPY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_FAST_FOLD: player::Protocol_MSG_TABLE_FAST_FOLD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_FORCE_SITOUT: player::Protocol_MSG_TABLE_FORCE_SITOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_GET_DEAL: player::Protocol_MSG_TABLE_GET_DEAL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_GET_DEAL_REPLY: player::Protocol_MSG_TABLE_GET_DEAL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_GOTO_NEXTHAND: player::Protocol_MSG_TABLE_GOTO_NEXTHAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_HAND_RANK: player::Protocol_MSG_TABLE_HAND_RANK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS: player::Protocol_MSG_TABLE_INVITE_CHOOSE_STARTING_STACKS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN: player::Protocol_MSG_TABLE_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGIN_REPLY: player::Protocol_MSG_TABLE_LOGIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGOUT: player::Protocol_MSG_TABLE_LOGOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_LOGOUT_REPLY: player::Protocol_MSG_TABLE_LOGOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_MTT_CHANGETABLE: player::Protocol_MSG_TABLE_MTT_CHANGETABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_NSTACK_RELOAD: player::Protocol_MSG_TABLE_NSTACK_RELOAD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_NSTACK_RELOAD_REPLY: player::Protocol_MSG_TABLE_NSTACK_RELOAD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE: player::Protocol_MSG_TABLE_PLAYER_CARD_DICTIONARY_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_PLAYNOW: player::Protocol_MSG_TABLE_PLAYNOW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CARD_PLAY: player::Protocol_MSG_TABLE_POWER_CARD_PLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CARD_PLAY_REPLY: player::Protocol_MSG_TABLE_POWER_CARD_PLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CARD_PRESELECT: player::Protocol_MSG_TABLE_POWER_CARD_PRESELECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHANGE_FUTURE: player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHANGE_FUTURE_ACK: player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_ACK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL: player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHANGE_FUTURE_REPLY: player::Protocol_MSG_TABLE_POWER_CHANGE_FUTURE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD: player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK: player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_ACK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL: player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY: player::Protocol_MSG_TABLE_POWER_CHOOSE_HOLECARDS_DISCARD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS: player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK: player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_ACK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL: player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY: player::Protocol_MSG_TABLE_POWER_CHOOSE_POWER_SLOTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DARK_BET: player::Protocol_MSG_TABLE_POWER_DARK_BET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DARK_BET_ACK: player::Protocol_MSG_TABLE_POWER_DARK_BET_ACK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DARK_BET_CANCEL: player::Protocol_MSG_TABLE_POWER_DARK_BET_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DARK_BET_REPLY: player::Protocol_MSG_TABLE_POWER_DARK_BET_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_DETECT_HOLECARDS: player::Protocol_MSG_TABLE_POWER_DETECT_HOLECARDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_MOUSE_OVER: player::Protocol_MSG_TABLE_POWER_MOUSE_OVER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PLAYERS_CHOICE: player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PLAYERS_CHOICE_ACK: player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_ACK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL: player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY: player::Protocol_MSG_TABLE_POWER_PLAYERS_CHOICE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_POSSESSION: player::Protocol_MSG_TABLE_POWER_POSSESSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PRIVATE_ANIMATION: player::Protocol_MSG_TABLE_POWER_PRIVATE_ANIMATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_PRIVATE_EFFECT: player::Protocol_MSG_TABLE_POWER_PRIVATE_EFFECT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_REDRAW: player::Protocol_MSG_TABLE_POWER_REDRAW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_REDRAW_ACK: player::Protocol_MSG_TABLE_POWER_REDRAW_ACK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_REDRAW_CANCEL: player::Protocol_MSG_TABLE_POWER_REDRAW_CANCEL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_REDRAW_REPLY: player::Protocol_MSG_TABLE_POWER_REDRAW_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS: player::Protocol_MSG_TABLE_POWER_SABOTAGE_TRAPPED_CARDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_POWER_STATUS_UPDATE: player::Protocol_MSG_TABLE_POWER_STATUS_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REBUYCHIPS: player::Protocol_MSG_TABLE_REBUYCHIPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REBUYCHIPS_REPLY: player::Protocol_MSG_TABLE_REBUYCHIPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REFRESH: player::Protocol_MSG_TABLE_REFRESH::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REFRESH_REPLY: player::Protocol_MSG_TABLE_REFRESH_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REQUESTACTION: player::Protocol_MSG_TABLE_REQUESTACTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_REQUESTACTION_REPLY: player::Protocol_MSG_TABLE_REQUESTACTION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SAGMAX_USER_DRAW: player::Protocol_MSG_TABLE_SAGMAX_USER_DRAW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_AUTO_REBUY: player::Protocol_MSG_TABLE_SET_AUTO_REBUY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_AUTO_REBUY_REPLY: player::Protocol_MSG_TABLE_SET_AUTO_REBUY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_DEAL: player::Protocol_MSG_TABLE_SET_DEAL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE: player::Protocol_MSG_TABLE_SET_RUN_IT_TWICE_AND_MORE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SET_SHOW_WHEN_ALLIN: player::Protocol_MSG_TABLE_SET_SHOW_WHEN_ALLIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT1: player::Protocol_MSG_TABLE_SIT1::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT1_REPLY: player::Protocol_MSG_TABLE_SIT1_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT2: player::Protocol_MSG_TABLE_SIT2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT2_KICK: player::Protocol_MSG_TABLE_SIT2_KICK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT2_REPLY: player::Protocol_MSG_TABLE_SIT2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITIN: player::Protocol_MSG_TABLE_SITIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITIN_REPLY: player::Protocol_MSG_TABLE_SITIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITOUT: player::Protocol_MSG_TABLE_SITOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITOUT_NEXTHAND: player::Protocol_MSG_TABLE_SITOUT_NEXTHAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITOUT_REPLY: player::Protocol_MSG_TABLE_SITOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SITTING_STATUS: player::Protocol_MSG_TABLE_SITTING_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SIT_KICK: player::Protocol_MSG_TABLE_SIT_KICK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_START_CAMPING_PREVENTION: player::Protocol_MSG_TABLE_START_CAMPING_PREVENTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_STATISTIC: player::Protocol_MSG_TABLE_STATISTIC::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_THROW: player::Protocol_MSG_TABLE_THROW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_THROW_REPLY: player::Protocol_MSG_TABLE_THROW_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_TIMEBANK: player::Protocol_MSG_TABLE_TIMEBANK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_CHAT_BAN: player::Protocol_MSG_TABLE_USER_CHAT_BAN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_CHAT_WARN: player::Protocol_MSG_TABLE_USER_CHAT_WARN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_DICTIONARY_UPDATE: player::Protocol_MSG_TABLE_USER_DICTIONARY_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_MINI_CHAT_REQUEST: player::Protocol_MSG_TABLE_USER_MINI_CHAT_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE: player::Protocol_MSG_TABLE_USER_POOL_BLOCK_STATE_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_SPECIFIC_BROADCAST: player::Protocol_MSG_TABLE_USER_SPECIFIC_BROADCAST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_WARNING_BELL: player::Protocol_MSG_TABLE_WARNING_BELL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "publication"))
	{
		switch(_msgId)
		{
			case MSG_PUBLICATION_UPDATE: publication::Protocol_MSG_PUBLICATION_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_ACTION: publication::Protocol_MSG_TABLE_SUBSCR_ACTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_ACTIVESEAT: publication::Protocol_MSG_TABLE_SUBSCR_ACTIVESEAT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_ANIMATION: publication::Protocol_MSG_TABLE_SUBSCR_ANIMATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_BEGINHAND: publication::Protocol_MSG_TABLE_SUBSCR_BEGINHAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_CHAT_BUBBLE: publication::Protocol_MSG_TABLE_SUBSCR_CHAT_BUBBLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_DEALBOARD: publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_DEALBOARD_RIT: publication::Protocol_MSG_TABLE_SUBSCR_DEALBOARD_RIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_DEALPLAYERCARDS: publication::Protocol_MSG_TABLE_SUBSCR_DEALPLAYERCARDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE: publication::Protocol_MSG_TABLE_SUBSCR_DELAYED_TABLECLOSE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_ENDHAND: publication::Protocol_MSG_TABLE_SUBSCR_ENDHAND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_I18N_MESSAGE: publication::Protocol_MSG_TABLE_SUBSCR_I18N_MESSAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_KNOCKOUT: publication::Protocol_MSG_TABLE_SUBSCR_KNOCKOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_MESSAGE: publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_MESSAGE2: publication::Protocol_MSG_TABLE_SUBSCR_MESSAGE2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_MOVEFROMPOT: publication::Protocol_MSG_TABLE_SUBSCR_MOVEFROMPOT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_MOVETOPOT: publication::Protocol_MSG_TABLE_SUBSCR_MOVETOPOT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_NEWGAME: publication::Protocol_MSG_TABLE_SUBSCR_NEWGAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_POT_DISTRIBUTION: publication::Protocol_MSG_TABLE_SUBSCR_POT_DISTRIBUTION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_POWER_PLAY: publication::Protocol_MSG_TABLE_SUBSCR_POWER_PLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET: publication::Protocol_MSG_TABLE_SUBSCR_RETURN_UNCALLED_BET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS: publication::Protocol_MSG_TABLE_SUBSCR_REVEAL_UNFOLD_ACTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE: publication::Protocol_MSG_TABLE_SUBSCR_SET_RECORDING_PAUSE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_SHOW_POT_WINNERS: publication::Protocol_MSG_TABLE_SUBSCR_SHOW_POT_WINNERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_SUBSCR_THROW: publication::Protocol_MSG_TABLE_SUBSCR_THROW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_TABLE_USER_MINI_CHAT_BROADCAST: publication::Protocol_MSG_TABLE_USER_MINI_CHAT_BROADCAST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

