/**
 * stormhh.cpp
 *
 * This file was auto-generated from stormhh.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor stormhh.txt
 */
 
#include "stormhh.h"

//=================================================================
//                    P_Card
//=================================================================

// @Override
StormHH::P_Card::P_Card(const Card& card)
{
	suit = card.suit;
	rank = card.rank;
}

// @Override
StormHH::P_Card::operator Card()
{
	Card card;
	card.suit = suit;
	card.rank = rank;
	return card;
}

StormHH::P_Card::P_Card()
{
	clear();
}

void StormHH::P_Card::clear()
{
	suit = '0';
	rank = 0;
}

bool StormHH::P_Card::equals(const P_Card& _o) const
{
	return suit == _o.suit &&
		rank == _o.rank;
}

const char *StormHH::P_Card::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("suit=");
	_buf.append(suit);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::P_Card::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("suit", suit, _buf);
	Atf::XmlElement::encodeAsXmlElement("rank", rank, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::P_Card::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("suit"))
		{
			suit = *_value.ptr();
		}
		else if (_element.equals("rank"))
		{
			rank = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::P_Card::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(P_Card())) // not empty
	{
		_body.composeINT8(suit);
		_body.composeBYTE(rank);
	}

	_msg.composeMsgBody(_body);
}

void StormHH::P_Card::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	{ INT8 _n; _parser0.parseINT8(_n); suit = _n; }
	_parser0.parseBYTE(rank);
}

const char *StormHH::P_Card::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("suit", suit);
	_jsonstr.compose("rank", rank);
	return _buf.c_str();
}

void StormHH::P_Card::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("suit", suit);
	_jparser.parseByNameThrow("rank", rank);
}

/* static */ void StormHH::P_Card::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	char suit; _jparser.validateByNameThrow("suit", suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _jparser.validateByNameThrow("rank", rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::P_Card::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	char suit; { INT8 _n; _parser0.parseINT8(_n); suit = _n; }
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _parser0.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    Header
//=================================================================

StormHH::invoke::Header::Header()
{
	clear();
}

void StormHH::invoke::Header::clear()
{
	cost = 0;
	exposePrivacy = false;
	powerCardUniqueId = 0;
}

bool StormHH::invoke::Header::equals(const Header& _o) const
{
	return cost == _o.cost &&
		exposePrivacy == _o.exposePrivacy &&
		powerCardUniqueId == _o.powerCardUniqueId;
}

const char *StormHH::invoke::Header::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cost=");
	_buf.appendInt64(cost);
	_buf.append(',');
	_buf.append("exposePrivacy=");
	_buf.appendUint(exposePrivacy);
	_buf.append(',');
	_buf.append("powerCardUniqueId=");
	_buf.appendInt(powerCardUniqueId);
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Header::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("cost", cost, _buf);
	Atf::XmlElement::encodeAsXmlElement("exposePrivacy", exposePrivacy, _buf);
	Atf::XmlElement::encodeAsXmlElement("powerCardUniqueId", powerCardUniqueId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Header::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cost"))
		{
			cost = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("exposePrivacy"))
		{
			exposePrivacy = (*_value.ptr() == '1');
		}
		else if (_element.equals("powerCardUniqueId"))
		{
			powerCardUniqueId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Header::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Header())) // not empty
	{
		_body.composeINT64(cost);
		_body.composeBOOL(exposePrivacy);
		_body.composeINT32(powerCardUniqueId);
	}

	_msg.composeMsgBody(_body);
}

void StormHH::invoke::Header::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(cost);
	_parser0.parseBOOL(exposePrivacy);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(powerCardUniqueId);
}

const char *StormHH::invoke::Header::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cost", cost);
	_jsonstr.compose("exposePrivacy", exposePrivacy);
	_jsonstr.compose("powerCardUniqueId", powerCardUniqueId);
	return _buf.c_str();
}

void StormHH::invoke::Header::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cost", cost);
	_jparser.parseByNameThrow("exposePrivacy", exposePrivacy);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("powerCardUniqueId", powerCardUniqueId);
}

/* static */ void StormHH::invoke::Header::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 cost; _jparser.validateByNameThrow("cost", cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	bool exposePrivacy; _jparser.validateByNameThrow("exposePrivacy", exposePrivacy);
	AtfValidator::validateInt(_descr, "exposePrivacy", exposePrivacy, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 powerCardUniqueId; _jparser.validateByNameThrow("powerCardUniqueId", powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Header::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 cost; _parser0.parseINT64(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	bool exposePrivacy; _parser0.parseBOOL(exposePrivacy);
	AtfValidator::validateInt(_descr, "exposePrivacy", exposePrivacy, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 powerCardUniqueId; _parser0.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BaseData
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::BaseData::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::BaseData::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::BaseData::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::BaseData::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::BaseData::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::BaseData::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::BaseData::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::BaseData::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::BaseData::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::BaseData::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::BaseData::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::BaseData::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::BaseData::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::BaseData::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::BaseData::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::BaseData::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::BaseData::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::BaseData::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::BaseData::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::BaseData::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::BaseData::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::BaseData::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::BaseData::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::BaseData::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::BaseData::BaseData()
{
	clear();
}

void StormHH::invoke::BaseData::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::BaseData::equals(const BaseData& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::BaseData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::BaseData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::BaseData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::BaseData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::BaseData::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::BaseData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::BaseData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::BaseData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::BaseData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    PubClientExtraMsg
//=================================================================

StormHH::invoke::PubClientExtraMsg::PubClientExtraMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::PubClientExtraMsg::PubClientExtraMsg(PubClientExtraMsg&& _o)
	: hasPrivateDataInSeparateMsg(std::move(_o.hasPrivateDataInSeparateMsg))
	, privateMessageSeatMask(std::move(_o.privateMessageSeatMask))
{
}

StormHH::invoke::PubClientExtraMsg& StormHH::invoke::PubClientExtraMsg::operator=(PubClientExtraMsg&& _o)
{
	if(this != &_o)
	{
		hasPrivateDataInSeparateMsg = std::move(_o.hasPrivateDataInSeparateMsg);
		privateMessageSeatMask = std::move(_o.privateMessageSeatMask);
	}
	return *this;
}

#endif

void StormHH::invoke::PubClientExtraMsg::clear()
{
	hasPrivateDataInSeparateMsg = false;
	privateMessageSeatMask = 0;
}

bool StormHH::invoke::PubClientExtraMsg::equals(const PubClientExtraMsg& _o) const
{
	return hasPrivateDataInSeparateMsg == _o.hasPrivateDataInSeparateMsg &&
		privateMessageSeatMask == _o.privateMessageSeatMask;
}

const char *StormHH::invoke::PubClientExtraMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("hasPrivateDataInSeparateMsg=");
	_buf.appendUint(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_buf.append(',');
		_buf.append("privateMessageSeatMask=");
		_buf.appendInt(privateMessageSeatMask);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::PubClientExtraMsg::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg, _buf);
	if(hasPrivateDataInSeparateMsg)
	{
		Atf::XmlElement::encodeAsXmlElement("privateMessageSeatMask", privateMessageSeatMask, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::PubClientExtraMsg::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("hasPrivateDataInSeparateMsg"))
		{
			hasPrivateDataInSeparateMsg = (*_value.ptr() == '1');
		}
		else if (_element.equals("privateMessageSeatMask"))
		{
			privateMessageSeatMask = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::PubClientExtraMsg::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_msg.composeINT16(privateMessageSeatMask);
	}
}

void StormHH::invoke::PubClientExtraMsg::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_parser.parseINT16(privateMessageSeatMask);
	}
}

const char *StormHH::invoke::PubClientExtraMsg::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_jsonstr.compose("privateMessageSeatMask", privateMessageSeatMask);
	}
	return _buf.c_str();
}

void StormHH::invoke::PubClientExtraMsg::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_jparser.parseByNameThrow("privateMessageSeatMask", privateMessageSeatMask);
	}
}

/* static */ void StormHH::invoke::PubClientExtraMsg::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool hasPrivateDataInSeparateMsg = false;
	_jparser.validateByNameThrow("hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg);
	AtfValidator::validateInt(_descr, "hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg, _checker, __FILE__, __LINE__);
	if(hasPrivateDataInSeparateMsg)
	{
		INT16 privateMessageSeatMask; _jparser.validateByNameThrow("privateMessageSeatMask", privateMessageSeatMask);
		AtfValidator::validateInt(_descr, "privateMessageSeatMask", privateMessageSeatMask, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void StormHH::invoke::PubClientExtraMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool hasPrivateDataInSeparateMsg = false;
	_parser.parseBOOL(hasPrivateDataInSeparateMsg);
	AtfValidator::validateInt(_descr, "hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg, _checker, __FILE__, __LINE__);
	if(hasPrivateDataInSeparateMsg)
	{
		INT16 privateMessageSeatMask; _parser.parseINT16(privateMessageSeatMask);
		AtfValidator::validateInt(_descr, "privateMessageSeatMask", privateMessageSeatMask, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    EMP
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::EMP::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::EMP::_PubDataType::clear()
{
	startStreet = -1;
	endStreet = -1;
	_is_empty_internal = true;
}

bool StormHH::invoke::EMP::_PubDataType::equals(const _PubDataType& _o) const
{
	return startStreet == _o.startStreet &&
		endStreet == _o.endStreet;
}

const char *StormHH::invoke::EMP::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("startStreet=");
		_buf.appendUint(startStreet);
		_buf.append(',');
		_buf.append("endStreet=");
		_buf.appendUint(endStreet);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::EMP::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("startStreet", startStreet, _buf);
		Atf::XmlElement::encodeAsXmlElement("endStreet", endStreet, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::EMP::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("startStreet"))
		{
			startStreet = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("endStreet"))
		{
			endStreet = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::EMP::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBYTE(startStreet);
		_msg0.composeBYTE(endStreet);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::EMP::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseBYTE(startStreet);
	_parser0.parseBYTE(endStreet);
}

const char *StormHH::invoke::EMP::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("startStreet", startStreet);
		_jsonstr.compose("endStreet", endStreet);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::EMP::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("startStreet", startStreet);
	_jparser.parseByNameThrow("endStreet", endStreet);
}

/* static */ void StormHH::invoke::EMP::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	BYTE startStreet; _jparser.validateByNameThrow("startStreet", startStreet);
	AtfValidator::validateInt(_descr, "startStreet", startStreet, _checker, __FILE__, __LINE__);
	BYTE endStreet; _jparser.validateByNameThrow("endStreet", endStreet);
	AtfValidator::validateInt(_descr, "endStreet", endStreet, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::EMP::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	if(_parser0.parseEnded()) return;
	BYTE startStreet; _parser0.parseBYTE(startStreet);
	AtfValidator::validateInt(_descr, "startStreet", startStreet, _checker, __FILE__, __LINE__);
	BYTE endStreet; _parser0.parseBYTE(endStreet);
	AtfValidator::validateInt(_descr, "endStreet", endStreet, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::EMP::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::EMP::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::EMP::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::EMP::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::EMP::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::EMP::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::EMP::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::EMP::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::EMP::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::EMP::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::EMP::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::EMP::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::EMP::EMP()
{
	clear();
}

void StormHH::invoke::EMP::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::EMP::equals(const EMP& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::EMP::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::EMP::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::EMP::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::EMP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::EMP::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::EMP::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::EMP::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::EMP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::EMP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Clone
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Clone::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Clone::_PubDataType::clear()
{
	powerIdToPlay = PokerGamePowerSecretPlaceholder;
	_is_empty_internal = true;
}

bool StormHH::invoke::Clone::_PubDataType::equals(const _PubDataType& _o) const
{
	return powerIdToPlay == _o.powerIdToPlay;
}

const char *StormHH::invoke::Clone::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerIdToPlay=");
		_buf.appendInt(powerIdToPlay);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Clone::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("powerIdToPlay", powerIdToPlay, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Clone::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerIdToPlay"))
		{
			powerIdToPlay = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Clone::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(powerIdToPlay);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Clone::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerIdToPlay);
}

const char *StormHH::invoke::Clone::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("powerIdToPlay", powerIdToPlay);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Clone::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerIdToPlay", powerIdToPlay);
}

/* static */ void StormHH::invoke::Clone::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerIdToPlay; _jparser.validateByNameThrow("powerIdToPlay", powerIdToPlay);
	AtfValidator::validateInt(_descr, "powerIdToPlay", powerIdToPlay, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Clone::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 powerIdToPlay; _parser0.parseINT32(powerIdToPlay);
	AtfValidator::validateInt(_descr, "powerIdToPlay", powerIdToPlay, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Clone::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Clone::_PrivDataType::clear()
{
	powerIdToPlay = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::Clone::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return powerIdToPlay == _o.powerIdToPlay;
}

const char *StormHH::invoke::Clone::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerIdToPlay=");
		_buf.appendInt(powerIdToPlay);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Clone::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("powerIdToPlay", powerIdToPlay, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Clone::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerIdToPlay"))
		{
			powerIdToPlay = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Clone::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(powerIdToPlay);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Clone::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerIdToPlay);
}

const char *StormHH::invoke::Clone::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("powerIdToPlay", powerIdToPlay);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Clone::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerIdToPlay", powerIdToPlay);
}

/* static */ void StormHH::invoke::Clone::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerIdToPlay; _jparser.validateByNameThrow("powerIdToPlay", powerIdToPlay);
	AtfValidator::validateInt(_descr, "powerIdToPlay", powerIdToPlay, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Clone::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 powerIdToPlay; _parser0.parseINT32(powerIdToPlay);
	AtfValidator::validateInt(_descr, "powerIdToPlay", powerIdToPlay, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::Clone::Clone()
{
	clear();
}

void StormHH::invoke::Clone::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Clone::equals(const Clone& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Clone::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Clone::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Clone::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Clone::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Clone::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Clone::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Clone::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Clone::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Clone::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    DarkBet
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::DarkBet::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::DarkBet::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::DarkBet::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::DarkBet::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::DarkBet::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::DarkBet::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::DarkBet::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::DarkBet::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::DarkBet::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::DarkBet::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::DarkBet::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::DarkBet::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::DarkBet::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::DarkBet::_PrivDataType::clear()
{
	amount = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::DarkBet::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return amount == _o.amount;
}

const char *StormHH::invoke::DarkBet::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("amount=");
		_buf.appendInt64(amount);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::DarkBet::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::DarkBet::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::DarkBet::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(amount);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::DarkBet::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(amount);
}

const char *StormHH::invoke::DarkBet::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("amount", amount);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::DarkBet::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void StormHH::invoke::DarkBet::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::DarkBet::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::DarkBet::DarkBet()
{
	clear();
}

void StormHH::invoke::DarkBet::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::DarkBet::equals(const DarkBet& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::DarkBet::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::DarkBet::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::DarkBet::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::DarkBet::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::DarkBet::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::DarkBet::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::DarkBet::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::DarkBet::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::DarkBet::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Scanner
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Scanner::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Scanner::_PubDataType::_PubDataType(_PubDataType&& _o)
	: keepOrDiscard(std::move(_o.keepOrDiscard))
	, numCards(std::move(_o.numCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::invoke::Scanner::_PubDataType& StormHH::invoke::Scanner::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		keepOrDiscard = std::move(_o.keepOrDiscard);
		numCards = std::move(_o.numCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::invoke::Scanner::_PubDataType::clear()
{
	keepOrDiscard.clear();
	numCards = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::Scanner::_PubDataType::equals(const _PubDataType& _o) const
{
	return Atf::atfPStringEquals(keepOrDiscard, _o.keepOrDiscard) &&
		numCards == _o.numCards;
}

const char *StormHH::invoke::Scanner::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("keepOrDiscard=");
		_buf.append(keepOrDiscard);
		_buf.append(',');
		_buf.append("numCards=");
		_buf.appendUint(numCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Scanner::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("keepOrDiscard", keepOrDiscard, _buf);
		Atf::XmlElement::encodeAsXmlElement("numCards", numCards, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Scanner::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("keepOrDiscard"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, keepOrDiscard)) return false;
		}
		else if (_element.equals("numCards"))
		{
			numCards = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Scanner::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(keepOrDiscard);
		_msg0.composeBYTE(numCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Scanner::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(keepOrDiscard);
	_parser0.parseBYTE(numCards);
}

const char *StormHH::invoke::Scanner::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("keepOrDiscard", keepOrDiscard);
		_jsonstr.compose("numCards", numCards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Scanner::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("keepOrDiscard", keepOrDiscard);
	_jparser.parseByNameThrow("numCards", numCards);
}

/* static */ void StormHH::invoke::Scanner::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString keepOrDiscard; _jparser.validateByNameThrow("keepOrDiscard", keepOrDiscard);
	AtfValidator::validateInt(_descr, "keepOrDiscard", keepOrDiscard.length(), _checker, __FILE__, __LINE__);
	BYTE numCards; _jparser.validateByNameThrow("numCards", numCards);
	AtfValidator::validateInt(_descr, "numCards", numCards, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Scanner::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "keepOrDiscard"); size_t szKeepOrDiscard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "keepOrDiscard", szKeepOrDiscard, _checker, __FILE__, __LINE__);
	BYTE numCards; _parser0.parseBYTE(numCards);
	AtfValidator::validateInt(_descr, "numCards", numCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Scanner::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Scanner::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: cards(std::move(_o.cards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::invoke::Scanner::_PrivDataType& StormHH::invoke::Scanner::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::invoke::Scanner::_PrivDataType::clear()
{
	cards.clear();
	_is_empty_internal = true;
}

bool StormHH::invoke::Scanner::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return Atf::atfPStringEquals(cards, _o.cards);
}

const char *StormHH::invoke::Scanner::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cards=");
		_buf.append(cards);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Scanner::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("cards", cards, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Scanner::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cards"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Scanner::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(cards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Scanner::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cards);
}

const char *StormHH::invoke::Scanner::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("cards", cards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Scanner::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cards", cards);
}

/* static */ void StormHH::invoke::Scanner::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Scanner::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cards"); size_t szCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::Scanner::Scanner()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Scanner::Scanner(Scanner&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::invoke::Scanner& StormHH::invoke::Scanner::operator=(Scanner&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::invoke::Scanner::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Scanner::equals(const Scanner& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Scanner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Scanner::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Scanner::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Scanner::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Scanner::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Scanner::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Scanner::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Scanner::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Scanner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    MindControl
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::MindControl::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::MindControl::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::MindControl::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::MindControl::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::MindControl::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::MindControl::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::MindControl::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::MindControl::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::MindControl::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::MindControl::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::MindControl::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::MindControl::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::MindControl::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::MindControl::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: stolenPowerId(std::move(_o.stolenPowerId))
	, powersLeft(std::move(_o.powersLeft))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::invoke::MindControl::_PrivDataType& StormHH::invoke::MindControl::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		stolenPowerId = std::move(_o.stolenPowerId);
		powersLeft = std::move(_o.powersLeft);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::invoke::MindControl::_PrivDataType::clear()
{
	stolenPowerId = 0;
	powersLeft.clear();
	_is_empty_internal = true;
}

bool StormHH::invoke::MindControl::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return stolenPowerId == _o.stolenPowerId &&
		powersLeft.equals(_o.powersLeft);
}

const char *StormHH::invoke::MindControl::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("stolenPowerId=");
		_buf.appendInt(stolenPowerId);
		_buf.append(',');
		_buf.append("powersLeft=");
		powersLeft.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::MindControl::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("stolenPowerId", stolenPowerId, _buf);
		powersLeft.toXmlString("powersLeft", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::MindControl::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("stolenPowerId"))
		{
			stolenPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("powersLeft"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, powersLeft)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::MindControl::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(stolenPowerId);
		powersLeft.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::MindControl::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(stolenPowerId);
	powersLeft.parseMsg(_parser0);
}

const char *StormHH::invoke::MindControl::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("stolenPowerId", stolenPowerId);
		_jsonstr.compose("powersLeft", powersLeft);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::MindControl::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stolenPowerId", stolenPowerId);
	_jparser.parseByNameThrow("powersLeft", powersLeft);
}

/* static */ void StormHH::invoke::MindControl::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 stolenPowerId; _jparser.validateByNameThrow("stolenPowerId", stolenPowerId);
	AtfValidator::validateInt(_descr, "stolenPowerId", stolenPowerId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > powersLeft; _jparser.validateByNameThrow("powersLeft", powersLeft);
	AtfValidator::validateInt(_descr, "powersLeft", powersLeft.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::MindControl::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 stolenPowerId; _parser0.parseINT32(stolenPowerId);
	AtfValidator::validateInt(_descr, "stolenPowerId", stolenPowerId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPowersLeft = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powersLeft"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powersLeft", szPowersLeft, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::MindControl::MindControl()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::MindControl::MindControl(MindControl&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::invoke::MindControl& StormHH::invoke::MindControl::operator=(MindControl&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::invoke::MindControl::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::MindControl::equals(const MindControl& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::MindControl::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::MindControl::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::MindControl::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::MindControl::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::MindControl::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::MindControl::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::MindControl::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::MindControl::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::MindControl::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Intel
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Intel::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Intel::_PubDataType::clear()
{
	numOfSensedNextCards = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::Intel::_PubDataType::equals(const _PubDataType& _o) const
{
	return numOfSensedNextCards == _o.numOfSensedNextCards;
}

const char *StormHH::invoke::Intel::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numOfSensedNextCards=");
		_buf.appendInt(numOfSensedNextCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Intel::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("numOfSensedNextCards", numOfSensedNextCards, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Intel::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numOfSensedNextCards"))
		{
			numOfSensedNextCards = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Intel::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numOfSensedNextCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Intel::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numOfSensedNextCards);
}

const char *StormHH::invoke::Intel::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("numOfSensedNextCards", numOfSensedNextCards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Intel::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numOfSensedNextCards", numOfSensedNextCards);
}

/* static */ void StormHH::invoke::Intel::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numOfSensedNextCards; _jparser.validateByNameThrow("numOfSensedNextCards", numOfSensedNextCards);
	AtfValidator::validateInt(_descr, "numOfSensedNextCards", numOfSensedNextCards, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Intel::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numOfSensedNextCards; _parser0.parseINT32(numOfSensedNextCards);
	AtfValidator::validateInt(_descr, "numOfSensedNextCards", numOfSensedNextCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Intel::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Intel::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: sensedCards(std::move(_o.sensedCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::invoke::Intel::_PrivDataType& StormHH::invoke::Intel::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		sensedCards = std::move(_o.sensedCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::invoke::Intel::_PrivDataType::clear()
{
	sensedCards.clear();
	_is_empty_internal = true;
}

bool StormHH::invoke::Intel::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return Atf::atfPStringEquals(sensedCards, _o.sensedCards);
}

const char *StormHH::invoke::Intel::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("sensedCards=");
		_buf.append(sensedCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Intel::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("sensedCards", sensedCards, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Intel::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sensedCards"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, sensedCards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Intel::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(sensedCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Intel::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(sensedCards);
}

const char *StormHH::invoke::Intel::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("sensedCards", sensedCards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Intel::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sensedCards", sensedCards);
}

/* static */ void StormHH::invoke::Intel::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString sensedCards; _jparser.validateByNameThrow("sensedCards", sensedCards);
	AtfValidator::validateInt(_descr, "sensedCards", sensedCards.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Intel::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "sensedCards"); size_t szSensedCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sensedCards", szSensedCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::Intel::Intel()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Intel::Intel(Intel&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::invoke::Intel& StormHH::invoke::Intel::operator=(Intel&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::invoke::Intel::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Intel::equals(const Intel& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Intel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Intel::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Intel::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Intel::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Intel::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Intel::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Intel::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Intel::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Intel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Pacify
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Pacify::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Pacify::_PubDataType::clear()
{
	cardUnfreezePossible = false;
	_is_empty_internal = true;
}

bool StormHH::invoke::Pacify::_PubDataType::equals(const _PubDataType& _o) const
{
	return cardUnfreezePossible == _o.cardUnfreezePossible;
}

const char *StormHH::invoke::Pacify::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cardUnfreezePossible=");
		_buf.appendUint(cardUnfreezePossible);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Pacify::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("cardUnfreezePossible", cardUnfreezePossible, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Pacify::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cardUnfreezePossible"))
		{
			cardUnfreezePossible = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Pacify::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(cardUnfreezePossible);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Pacify::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(cardUnfreezePossible);
}

const char *StormHH::invoke::Pacify::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("cardUnfreezePossible", cardUnfreezePossible);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Pacify::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cardUnfreezePossible", cardUnfreezePossible);
}

/* static */ void StormHH::invoke::Pacify::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool cardUnfreezePossible; _jparser.validateByNameThrow("cardUnfreezePossible", cardUnfreezePossible);
	AtfValidator::validateInt(_descr, "cardUnfreezePossible", cardUnfreezePossible, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Pacify::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool cardUnfreezePossible; _parser0.parseBOOL(cardUnfreezePossible);
	AtfValidator::validateInt(_descr, "cardUnfreezePossible", cardUnfreezePossible, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Pacify::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Pacify::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Pacify::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Pacify::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Pacify::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Pacify::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Pacify::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Pacify::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Pacify::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Pacify::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Pacify::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Pacify::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Pacify::Pacify()
{
	clear();
}

void StormHH::invoke::Pacify::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Pacify::equals(const Pacify& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Pacify::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Pacify::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Pacify::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Pacify::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Pacify::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Pacify::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Pacify::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Pacify::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Pacify::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Reload
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Reload::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Reload::_PubDataType::clear()
{
	numCards = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::Reload::_PubDataType::equals(const _PubDataType& _o) const
{
	return numCards == _o.numCards;
}

const char *StormHH::invoke::Reload::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numCards=");
		_buf.appendInt(numCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Reload::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("numCards", numCards, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Reload::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numCards"))
		{
			numCards = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Reload::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Reload::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numCards);
}

const char *StormHH::invoke::Reload::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("numCards", numCards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Reload::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numCards", numCards);
}

/* static */ void StormHH::invoke::Reload::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numCards; _jparser.validateByNameThrow("numCards", numCards);
	AtfValidator::validateInt(_descr, "numCards", numCards, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Reload::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numCards; _parser0.parseINT32(numCards);
	AtfValidator::validateInt(_descr, "numCards", numCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Reload::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Reload::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Reload::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Reload::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Reload::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Reload::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Reload::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Reload::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Reload::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Reload::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Reload::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Reload::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Reload::Reload()
{
	clear();
}

void StormHH::invoke::Reload::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Reload::equals(const Reload& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Reload::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Reload::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Reload::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Reload::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Reload::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Reload::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Reload::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Reload::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Reload::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Chaos
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Chaos::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Chaos::_PubDataType::clear()
{
	numBombs = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::Chaos::_PubDataType::equals(const _PubDataType& _o) const
{
	return numBombs == _o.numBombs;
}

const char *StormHH::invoke::Chaos::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numBombs=");
		_buf.appendInt(numBombs);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Chaos::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("numBombs", numBombs, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Chaos::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numBombs"))
		{
			numBombs = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Chaos::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numBombs);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Chaos::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numBombs);
}

const char *StormHH::invoke::Chaos::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("numBombs", numBombs);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Chaos::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numBombs", numBombs);
}

/* static */ void StormHH::invoke::Chaos::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numBombs; _jparser.validateByNameThrow("numBombs", numBombs);
	AtfValidator::validateInt(_descr, "numBombs", numBombs, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Chaos::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numBombs; _parser0.parseINT32(numBombs);
	AtfValidator::validateInt(_descr, "numBombs", numBombs, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Chaos::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Chaos::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Chaos::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Chaos::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Chaos::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Chaos::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Chaos::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Chaos::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Chaos::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Chaos::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Chaos::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Chaos::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Chaos::Chaos()
{
	clear();
}

void StormHH::invoke::Chaos::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Chaos::equals(const Chaos& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Chaos::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Chaos::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Chaos::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Chaos::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Chaos::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Chaos::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Chaos::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Chaos::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Chaos::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Mint
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Mint::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Mint::_PubDataType::clear()
{
	chipsMinted = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::Mint::_PubDataType::equals(const _PubDataType& _o) const
{
	return chipsMinted == _o.chipsMinted;
}

const char *StormHH::invoke::Mint::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("chipsMinted=");
		_buf.appendInt64(chipsMinted);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Mint::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("chipsMinted", chipsMinted, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Mint::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chipsMinted"))
		{
			chipsMinted = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Mint::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(chipsMinted);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Mint::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(chipsMinted);
}

const char *StormHH::invoke::Mint::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("chipsMinted", chipsMinted);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Mint::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chipsMinted", chipsMinted);
}

/* static */ void StormHH::invoke::Mint::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 chipsMinted; _jparser.validateByNameThrow("chipsMinted", chipsMinted);
	AtfValidator::validateInt(_descr, "chipsMinted", chipsMinted, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Mint::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 chipsMinted; _parser0.parseINT64(chipsMinted);
	AtfValidator::validateInt(_descr, "chipsMinted", chipsMinted, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Mint::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Mint::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Mint::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Mint::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Mint::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Mint::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Mint::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Mint::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Mint::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Mint::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Mint::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Mint::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Mint::Mint()
{
	clear();
}

void StormHH::invoke::Mint::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Mint::equals(const Mint& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Mint::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Mint::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Mint::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Mint::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Mint::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Mint::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Mint::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Mint::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Mint::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Swap
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Swap::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Swap::_PubDataType::_PubDataType(_PubDataType&& _o)
	: holeCard(std::move(_o.holeCard))
	, boardCard(std::move(_o.boardCard))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::invoke::Swap::_PubDataType& StormHH::invoke::Swap::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		holeCard = std::move(_o.holeCard);
		boardCard = std::move(_o.boardCard);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::invoke::Swap::_PubDataType::clear()
{
	holeCard.clear();
	boardCard.clear();
	_is_empty_internal = true;
}

bool StormHH::invoke::Swap::_PubDataType::equals(const _PubDataType& _o) const
{
	return Atf::atfPStringEquals(holeCard, _o.holeCard) &&
		Atf::atfPStringEquals(boardCard, _o.boardCard);
}

const char *StormHH::invoke::Swap::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("holeCard=");
		_buf.append(holeCard);
		_buf.append(',');
		_buf.append("boardCard=");
		_buf.append(boardCard);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Swap::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("holeCard", holeCard, _buf);
		Atf::XmlElement::encodeAsXmlElement("boardCard", boardCard, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Swap::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("holeCard"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, holeCard)) return false;
		}
		else if (_element.equals("boardCard"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, boardCard)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Swap::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(holeCard);
		_msg0.composeString(boardCard);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Swap::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(holeCard);
	_parser0.parseStringP(boardCard);
}

const char *StormHH::invoke::Swap::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("holeCard", holeCard);
		_jsonstr.compose("boardCard", boardCard);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Swap::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("holeCard", holeCard);
	_jparser.parseByNameThrow("boardCard", boardCard);
}

/* static */ void StormHH::invoke::Swap::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString holeCard; _jparser.validateByNameThrow("holeCard", holeCard);
	AtfValidator::validateInt(_descr, "holeCard", holeCard.length(), _checker, __FILE__, __LINE__);
	PString boardCard; _jparser.validateByNameThrow("boardCard", boardCard);
	AtfValidator::validateInt(_descr, "boardCard", boardCard.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Swap::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "holeCard"); size_t szHoleCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "holeCard", szHoleCard, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "boardCard"); size_t szBoardCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "boardCard", szBoardCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Swap::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Swap::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Swap::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Swap::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Swap::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Swap::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Swap::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Swap::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Swap::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Swap::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Swap::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Swap::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Swap::Swap()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Swap::Swap(Swap&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::invoke::Swap& StormHH::invoke::Swap::operator=(Swap&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::invoke::Swap::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Swap::equals(const Swap& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Swap::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Swap::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Swap::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Swap::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Swap::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Swap::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Swap::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Swap::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Swap::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Engineer
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Engineer::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Engineer::_PubDataType::_PubDataType(_PubDataType&& _o)
	: chosenCard(std::move(_o.chosenCard))
	, discardedCards(std::move(_o.discardedCards))
	, cardsCandidate(std::move(_o.cardsCandidate))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::invoke::Engineer::_PubDataType& StormHH::invoke::Engineer::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		chosenCard = std::move(_o.chosenCard);
		discardedCards = std::move(_o.discardedCards);
		cardsCandidate = std::move(_o.cardsCandidate);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::invoke::Engineer::_PubDataType::clear()
{
	chosenCard.clear();
	discardedCards.clear();
	cardsCandidate.clear();
	_is_empty_internal = true;
}

bool StormHH::invoke::Engineer::_PubDataType::equals(const _PubDataType& _o) const
{
	return Atf::atfPStringEquals(chosenCard, _o.chosenCard) &&
		Atf::atfPStringEquals(discardedCards, _o.discardedCards) &&
		Atf::atfPStringEquals(cardsCandidate, _o.cardsCandidate);
}

const char *StormHH::invoke::Engineer::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("chosenCard=");
		_buf.append(chosenCard);
		_buf.append(',');
		_buf.append("discardedCards=");
		_buf.append(discardedCards);
		_buf.append(',');
		_buf.append("cardsCandidate=");
		_buf.append(cardsCandidate);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Engineer::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("chosenCard", chosenCard, _buf);
		Atf::XmlElement::encodeAsXmlElement("discardedCards", discardedCards, _buf);
		Atf::XmlElement::encodeAsXmlElement("cardsCandidate", cardsCandidate, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Engineer::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chosenCard"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, chosenCard)) return false;
		}
		else if (_element.equals("discardedCards"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, discardedCards)) return false;
		}
		else if (_element.equals("cardsCandidate"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cardsCandidate)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Engineer::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(chosenCard);
		_msg0.composeString(discardedCards);
		_msg0.composeString(cardsCandidate);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Engineer::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(chosenCard);
	_parser0.parseStringP(discardedCards);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(cardsCandidate);
}

const char *StormHH::invoke::Engineer::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("chosenCard", chosenCard);
		_jsonstr.compose("discardedCards", discardedCards);
		_jsonstr.compose("cardsCandidate", cardsCandidate);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Engineer::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chosenCard", chosenCard);
	_jparser.parseByNameThrow("discardedCards", discardedCards);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cardsCandidate", cardsCandidate);
}

/* static */ void StormHH::invoke::Engineer::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString chosenCard; _jparser.validateByNameThrow("chosenCard", chosenCard);
	AtfValidator::validateInt(_descr, "chosenCard", chosenCard.length(), _checker, __FILE__, __LINE__);
	PString discardedCards; _jparser.validateByNameThrow("discardedCards", discardedCards);
	AtfValidator::validateInt(_descr, "discardedCards", discardedCards.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString cardsCandidate; _jparser.validateByNameThrow("cardsCandidate", cardsCandidate);
	AtfValidator::validateInt(_descr, "cardsCandidate", cardsCandidate.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Engineer::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "chosenCard"); size_t szChosenCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "chosenCard", szChosenCard, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "discardedCards"); size_t szDiscardedCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "discardedCards", szDiscardedCards, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "cardsCandidate"); size_t szCardsCandidate = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardsCandidate", szCardsCandidate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Engineer::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Engineer::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Engineer::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Engineer::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Engineer::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Engineer::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Engineer::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Engineer::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Engineer::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Engineer::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Engineer::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Engineer::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Engineer::Engineer()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Engineer::Engineer(Engineer&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::invoke::Engineer& StormHH::invoke::Engineer::operator=(Engineer&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::invoke::Engineer::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Engineer::equals(const Engineer& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Engineer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Engineer::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Engineer::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Engineer::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Engineer::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Engineer::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Engineer::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Engineer::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Engineer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Reboot
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Reboot::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Reboot::_PubDataType::clear()
{
	numPowersDrawn = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::Reboot::_PubDataType::equals(const _PubDataType& _o) const
{
	return numPowersDrawn == _o.numPowersDrawn;
}

const char *StormHH::invoke::Reboot::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numPowersDrawn=");
		_buf.appendInt(numPowersDrawn);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Reboot::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("numPowersDrawn", numPowersDrawn, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Reboot::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numPowersDrawn"))
		{
			numPowersDrawn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Reboot::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numPowersDrawn);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Reboot::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numPowersDrawn);
}

const char *StormHH::invoke::Reboot::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("numPowersDrawn", numPowersDrawn);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Reboot::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numPowersDrawn", numPowersDrawn);
}

/* static */ void StormHH::invoke::Reboot::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numPowersDrawn; _jparser.validateByNameThrow("numPowersDrawn", numPowersDrawn);
	AtfValidator::validateInt(_descr, "numPowersDrawn", numPowersDrawn, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Reboot::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numPowersDrawn; _parser0.parseINT32(numPowersDrawn);
	AtfValidator::validateInt(_descr, "numPowersDrawn", numPowersDrawn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Reboot::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Reboot::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Reboot::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Reboot::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Reboot::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Reboot::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Reboot::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Reboot::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Reboot::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Reboot::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Reboot::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Reboot::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Reboot::Reboot()
{
	clear();
}

void StormHH::invoke::Reboot::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Reboot::equals(const Reboot& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Reboot::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Reboot::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Reboot::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Reboot::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Reboot::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Reboot::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Reboot::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Reboot::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Reboot::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Equalizer
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Equalizer::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Equalizer::_PubDataType::clear()
{
	manaCopied = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::Equalizer::_PubDataType::equals(const _PubDataType& _o) const
{
	return manaCopied == _o.manaCopied;
}

const char *StormHH::invoke::Equalizer::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("manaCopied=");
		_buf.appendInt64(manaCopied);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Equalizer::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("manaCopied", manaCopied, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Equalizer::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("manaCopied"))
		{
			manaCopied = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Equalizer::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(manaCopied);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Equalizer::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(manaCopied);
}

const char *StormHH::invoke::Equalizer::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("manaCopied", manaCopied);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Equalizer::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("manaCopied", manaCopied);
}

/* static */ void StormHH::invoke::Equalizer::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 manaCopied; _jparser.validateByNameThrow("manaCopied", manaCopied);
	AtfValidator::validateInt(_descr, "manaCopied", manaCopied, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Equalizer::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 manaCopied; _parser0.parseINT64(manaCopied);
	AtfValidator::validateInt(_descr, "manaCopied", manaCopied, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Equalizer::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Equalizer::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Equalizer::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Equalizer::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Equalizer::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Equalizer::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Equalizer::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Equalizer::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Equalizer::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Equalizer::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Equalizer::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Equalizer::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Equalizer::Equalizer()
{
	clear();
}

void StormHH::invoke::Equalizer::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Equalizer::equals(const Equalizer& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Equalizer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Equalizer::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Equalizer::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Equalizer::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Equalizer::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Equalizer::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Equalizer::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Equalizer::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Equalizer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Freeze
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Freeze::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Freeze::_PubDataType::_PubDataType(_PubDataType&& _o)
	: frozenCards(std::move(_o.frozenCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::invoke::Freeze::_PubDataType& StormHH::invoke::Freeze::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		frozenCards = std::move(_o.frozenCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::invoke::Freeze::_PubDataType::clear()
{
	frozenCards.clear();
	_is_empty_internal = true;
}

bool StormHH::invoke::Freeze::_PubDataType::equals(const _PubDataType& _o) const
{
	return Atf::atfPStringEquals(frozenCards, _o.frozenCards);
}

const char *StormHH::invoke::Freeze::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("frozenCards=");
		_buf.append(frozenCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Freeze::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("frozenCards", frozenCards, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Freeze::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("frozenCards"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, frozenCards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Freeze::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(frozenCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Freeze::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(frozenCards);
}

const char *StormHH::invoke::Freeze::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("frozenCards", frozenCards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Freeze::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("frozenCards", frozenCards);
}

/* static */ void StormHH::invoke::Freeze::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString frozenCards; _jparser.validateByNameThrow("frozenCards", frozenCards);
	AtfValidator::validateInt(_descr, "frozenCards", frozenCards.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Freeze::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "frozenCards"); size_t szFrozenCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "frozenCards", szFrozenCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Freeze::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Freeze::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Freeze::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Freeze::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Freeze::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Freeze::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Freeze::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Freeze::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Freeze::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Freeze::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Freeze::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Freeze::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Freeze::Freeze()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Freeze::Freeze(Freeze&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::invoke::Freeze& StormHH::invoke::Freeze::operator=(Freeze&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::invoke::Freeze::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Freeze::equals(const Freeze& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Freeze::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Freeze::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Freeze::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Freeze::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Freeze::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Freeze::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Freeze::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Freeze::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Freeze::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Syphon
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Syphon::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Syphon::_PubDataType::_PubDataType(_PubDataType&& _o)
	: manaStolen(std::move(_o.manaStolen))
	, targetPlayer(std::move(_o.targetPlayer))
	, targetUserId(std::move(_o.targetUserId))
	, manaReceived(std::move(_o.manaReceived))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::invoke::Syphon::_PubDataType& StormHH::invoke::Syphon::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		manaStolen = std::move(_o.manaStolen);
		targetPlayer = std::move(_o.targetPlayer);
		targetUserId = std::move(_o.targetUserId);
		manaReceived = std::move(_o.manaReceived);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::invoke::Syphon::_PubDataType::clear()
{
	manaStolen = 0;
	targetPlayer = 0;
	targetUserId.clear();
	manaReceived = -1;
	_is_empty_internal = true;
}

bool StormHH::invoke::Syphon::_PubDataType::equals(const _PubDataType& _o) const
{
	return manaStolen == _o.manaStolen &&
		targetPlayer == _o.targetPlayer &&
		Atf::atfPStringEquals(targetUserId, _o.targetUserId) &&
		manaReceived == _o.manaReceived;
}

const char *StormHH::invoke::Syphon::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("manaStolen=");
		_buf.appendInt64(manaStolen);
		_buf.append(',');
		_buf.append("targetPlayer=");
		_buf.appendInt(targetPlayer);
		_buf.append(',');
		_buf.append("targetUserId=");
		_buf.append(targetUserId);
		_buf.append(',');
		_buf.append("manaReceived=");
		_buf.appendInt64(manaReceived);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Syphon::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("manaStolen", manaStolen, _buf);
		Atf::XmlElement::encodeAsXmlElement("targetPlayer", targetPlayer, _buf);
		Atf::XmlElement::encodeAsXmlElement("targetUserId", targetUserId, _buf);
		Atf::XmlElement::encodeAsXmlElement("manaReceived", manaReceived, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Syphon::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("manaStolen"))
		{
			manaStolen = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("targetPlayer"))
		{
			targetPlayer = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("targetUserId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, targetUserId)) return false;
		}
		else if (_element.equals("manaReceived"))
		{
			manaReceived = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Syphon::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(manaStolen);
		_msg0.composeINT8(targetPlayer);
		_msg0.composeString(targetUserId);
		_msg0.composeINT64(manaReceived);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Syphon::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(manaStolen);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT8(targetPlayer);
	_parser0.parseStringP(targetUserId);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(manaReceived);
}

const char *StormHH::invoke::Syphon::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("manaStolen", manaStolen);
		_jsonstr.compose("targetPlayer", targetPlayer);
		_jsonstr.compose("targetUserId", targetUserId);
		_jsonstr.compose("manaReceived", manaReceived);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Syphon::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("manaStolen", manaStolen);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("targetPlayer", targetPlayer);
	_jparser.parseByNameThrow("targetUserId", targetUserId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("manaReceived", manaReceived);
}

/* static */ void StormHH::invoke::Syphon::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 manaStolen; _jparser.validateByNameThrow("manaStolen", manaStolen);
	AtfValidator::validateInt(_descr, "manaStolen", manaStolen, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT8 targetPlayer; _jparser.validateByNameThrow("targetPlayer", targetPlayer);
	AtfValidator::validateInt(_descr, "targetPlayer", targetPlayer, _checker, __FILE__, __LINE__);
	PString targetUserId; _jparser.validateByNameThrow("targetUserId", targetUserId);
	AtfValidator::validateInt(_descr, "targetUserId", targetUserId.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT64 manaReceived; _jparser.validateByNameThrow("manaReceived", manaReceived);
	AtfValidator::validateInt(_descr, "manaReceived", manaReceived, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Syphon::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	INT64 manaStolen; _parser0.parseINT64(manaStolen);
	AtfValidator::validateInt(_descr, "manaStolen", manaStolen, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT8 targetPlayer; _parser0.parseINT8(targetPlayer);
	AtfValidator::validateInt(_descr, "targetPlayer", targetPlayer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetUserId"); size_t szTargetUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetUserId", szTargetUserId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT64 manaReceived; _parser0.parseINT64(manaReceived);
	AtfValidator::validateInt(_descr, "manaReceived", manaReceived, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Syphon::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Syphon::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::Syphon::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::Syphon::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Syphon::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Syphon::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::Syphon::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Syphon::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::Syphon::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::Syphon::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::Syphon::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::Syphon::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::Syphon::Syphon()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::invoke::Syphon::Syphon(Syphon&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::invoke::Syphon& StormHH::invoke::Syphon::operator=(Syphon&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::invoke::Syphon::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Syphon::equals(const Syphon& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Syphon::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Syphon::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Syphon::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Syphon::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Syphon::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Syphon::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Syphon::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Syphon::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Syphon::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    AnteUp
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::AnteUp::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::AnteUp::_PubDataType::clear()
{
	ante = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::AnteUp::_PubDataType::equals(const _PubDataType& _o) const
{
	return ante == _o.ante;
}

const char *StormHH::invoke::AnteUp::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("ante=");
		_buf.appendInt64(ante);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::AnteUp::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::AnteUp::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ante"))
		{
			ante = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::AnteUp::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(ante);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::AnteUp::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(ante);
}

const char *StormHH::invoke::AnteUp::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("ante", ante);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::AnteUp::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ante", ante);
}

/* static */ void StormHH::invoke::AnteUp::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::AnteUp::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 ante; _parser0.parseINT64(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::AnteUp::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::AnteUp::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::invoke::AnteUp::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::invoke::AnteUp::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::AnteUp::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::AnteUp::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::invoke::AnteUp::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::AnteUp::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::invoke::AnteUp::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::invoke::AnteUp::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::invoke::AnteUp::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::invoke::AnteUp::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::invoke::AnteUp::AnteUp()
{
	clear();
}

void StormHH::invoke::AnteUp::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::AnteUp::equals(const AnteUp& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::AnteUp::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::AnteUp::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::AnteUp::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::AnteUp::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::AnteUp::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::AnteUp::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::AnteUp::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::AnteUp::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::AnteUp::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    CounterSpell
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::CounterSpell::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::CounterSpell::_PubDataType::clear()
{
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHH::invoke::CounterSpell::_PubDataType::equals(const _PubDataType& _o) const
{
	return isRevealStage == _o.isRevealStage;
}

const char *StormHH::invoke::CounterSpell::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::CounterSpell::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("isRevealStage", isRevealStage, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::CounterSpell::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isRevealStage"))
		{
			isRevealStage = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::CounterSpell::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::CounterSpell::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isRevealStage);
}

const char *StormHH::invoke::CounterSpell::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("isRevealStage", isRevealStage);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::CounterSpell::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isRevealStage", isRevealStage);
}

/* static */ void StormHH::invoke::CounterSpell::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isRevealStage; _jparser.validateByNameThrow("isRevealStage", isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::CounterSpell::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::CounterSpell::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::CounterSpell::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	destroyedPowerId = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::CounterSpell::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId &&
		destroyedPowerId == _o.destroyedPowerId;
}

const char *StormHH::invoke::CounterSpell::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
		_buf.append(',');
		_buf.append("destroyedPowerId=");
		_buf.appendInt(destroyedPowerId);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::CounterSpell::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("mySecretPowerId", mySecretPowerId, _buf);
		Atf::XmlElement::encodeAsXmlElement("destroyedPowerId", destroyedPowerId, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::CounterSpell::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("mySecretPowerId"))
		{
			mySecretPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("destroyedPowerId"))
		{
			destroyedPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::CounterSpell::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
		_msg0.composeINT32(destroyedPowerId);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::CounterSpell::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
	_parser0.parseINT32(destroyedPowerId);
}

const char *StormHH::invoke::CounterSpell::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("mySecretPowerId", mySecretPowerId);
		_jsonstr.compose("destroyedPowerId", destroyedPowerId);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::CounterSpell::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("mySecretPowerId", mySecretPowerId);
	_jparser.parseByNameThrow("destroyedPowerId", destroyedPowerId);
}

/* static */ void StormHH::invoke::CounterSpell::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 mySecretPowerId; _jparser.validateByNameThrow("mySecretPowerId", mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	INT32 destroyedPowerId; _jparser.validateByNameThrow("destroyedPowerId", destroyedPowerId);
	AtfValidator::validateInt(_descr, "destroyedPowerId", destroyedPowerId, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::CounterSpell::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	INT32 destroyedPowerId; _parser0.parseINT32(destroyedPowerId);
	AtfValidator::validateInt(_descr, "destroyedPowerId", destroyedPowerId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::CounterSpell::CounterSpell()
{
	clear();
}

void StormHH::invoke::CounterSpell::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::CounterSpell::equals(const CounterSpell& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::CounterSpell::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::CounterSpell::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::CounterSpell::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::CounterSpell::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::CounterSpell::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::CounterSpell::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::CounterSpell::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::CounterSpell::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::CounterSpell::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Lowblow
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Lowblow::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Lowblow::_PubDataType::clear()
{
	isSecretPlay = false;
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHH::invoke::Lowblow::_PubDataType::equals(const _PubDataType& _o) const
{
	return isSecretPlay == _o.isSecretPlay &&
		isRevealStage == _o.isRevealStage;
}

const char *StormHH::invoke::Lowblow::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isSecretPlay=");
		_buf.appendUint(isSecretPlay);
		_buf.append(',');
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Lowblow::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("isSecretPlay", isSecretPlay, _buf);
		Atf::XmlElement::encodeAsXmlElement("isRevealStage", isRevealStage, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Lowblow::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isSecretPlay"))
		{
			isSecretPlay = (*_value.ptr() == '1');
		}
		else if (_element.equals("isRevealStage"))
		{
			isRevealStage = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Lowblow::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isSecretPlay);
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Lowblow::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isSecretPlay);
	_parser0.parseBOOL(isRevealStage);
}

const char *StormHH::invoke::Lowblow::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("isSecretPlay", isSecretPlay);
		_jsonstr.compose("isRevealStage", isRevealStage);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Lowblow::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isSecretPlay", isSecretPlay);
	_jparser.parseByNameThrow("isRevealStage", isRevealStage);
}

/* static */ void StormHH::invoke::Lowblow::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isSecretPlay; _jparser.validateByNameThrow("isSecretPlay", isSecretPlay);
	AtfValidator::validateInt(_descr, "isSecretPlay", isSecretPlay, _checker, __FILE__, __LINE__);
	bool isRevealStage; _jparser.validateByNameThrow("isRevealStage", isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Lowblow::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isSecretPlay; _parser0.parseBOOL(isSecretPlay);
	AtfValidator::validateInt(_descr, "isSecretPlay", isSecretPlay, _checker, __FILE__, __LINE__);
	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Lowblow::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Lowblow::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	_is_empty_internal = true;
}

bool StormHH::invoke::Lowblow::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId;
}

const char *StormHH::invoke::Lowblow::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Lowblow::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("mySecretPowerId", mySecretPowerId, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Lowblow::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("mySecretPowerId"))
		{
			mySecretPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Lowblow::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Lowblow::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
}

const char *StormHH::invoke::Lowblow::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("mySecretPowerId", mySecretPowerId);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Lowblow::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("mySecretPowerId", mySecretPowerId);
}

/* static */ void StormHH::invoke::Lowblow::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 mySecretPowerId; _jparser.validateByNameThrow("mySecretPowerId", mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Lowblow::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::Lowblow::Lowblow()
{
	clear();
}

void StormHH::invoke::Lowblow::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Lowblow::equals(const Lowblow& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Lowblow::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Lowblow::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Lowblow::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Lowblow::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Lowblow::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Lowblow::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Lowblow::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Lowblow::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Lowblow::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Stretch
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Stretch::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Stretch::_PubDataType::clear()
{
	isSecretPlay = false;
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHH::invoke::Stretch::_PubDataType::equals(const _PubDataType& _o) const
{
	return isSecretPlay == _o.isSecretPlay &&
		isRevealStage == _o.isRevealStage;
}

const char *StormHH::invoke::Stretch::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isSecretPlay=");
		_buf.appendUint(isSecretPlay);
		_buf.append(',');
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Stretch::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("isSecretPlay", isSecretPlay, _buf);
		Atf::XmlElement::encodeAsXmlElement("isRevealStage", isRevealStage, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Stretch::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isSecretPlay"))
		{
			isSecretPlay = (*_value.ptr() == '1');
		}
		else if (_element.equals("isRevealStage"))
		{
			isRevealStage = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Stretch::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isSecretPlay);
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Stretch::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isSecretPlay);
	_parser0.parseBOOL(isRevealStage);
}

const char *StormHH::invoke::Stretch::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("isSecretPlay", isSecretPlay);
		_jsonstr.compose("isRevealStage", isRevealStage);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Stretch::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isSecretPlay", isSecretPlay);
	_jparser.parseByNameThrow("isRevealStage", isRevealStage);
}

/* static */ void StormHH::invoke::Stretch::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isSecretPlay; _jparser.validateByNameThrow("isSecretPlay", isSecretPlay);
	AtfValidator::validateInt(_descr, "isSecretPlay", isSecretPlay, _checker, __FILE__, __LINE__);
	bool isRevealStage; _jparser.validateByNameThrow("isRevealStage", isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Stretch::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isSecretPlay; _parser0.parseBOOL(isSecretPlay);
	AtfValidator::validateInt(_descr, "isSecretPlay", isSecretPlay, _checker, __FILE__, __LINE__);
	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Stretch::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Stretch::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	_is_empty_internal = true;
}

bool StormHH::invoke::Stretch::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId;
}

const char *StormHH::invoke::Stretch::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Stretch::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("mySecretPowerId", mySecretPowerId, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Stretch::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("mySecretPowerId"))
		{
			mySecretPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Stretch::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Stretch::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
}

const char *StormHH::invoke::Stretch::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("mySecretPowerId", mySecretPowerId);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Stretch::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("mySecretPowerId", mySecretPowerId);
}

/* static */ void StormHH::invoke::Stretch::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 mySecretPowerId; _jparser.validateByNameThrow("mySecretPowerId", mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Stretch::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::Stretch::Stretch()
{
	clear();
}

void StormHH::invoke::Stretch::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Stretch::equals(const Stretch& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Stretch::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Stretch::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Stretch::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Stretch::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Stretch::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Stretch::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Stretch::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Stretch::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Stretch::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    SuitUp
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::SuitUp::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::SuitUp::_PubDataType::clear()
{
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHH::invoke::SuitUp::_PubDataType::equals(const _PubDataType& _o) const
{
	return isRevealStage == _o.isRevealStage;
}

const char *StormHH::invoke::SuitUp::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::SuitUp::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("isRevealStage", isRevealStage, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::SuitUp::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isRevealStage"))
		{
			isRevealStage = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::SuitUp::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::SuitUp::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isRevealStage);
}

const char *StormHH::invoke::SuitUp::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("isRevealStage", isRevealStage);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::SuitUp::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isRevealStage", isRevealStage);
}

/* static */ void StormHH::invoke::SuitUp::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isRevealStage; _jparser.validateByNameThrow("isRevealStage", isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::SuitUp::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::SuitUp::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::SuitUp::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	suit = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::SuitUp::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId &&
		suit == _o.suit;
}

const char *StormHH::invoke::SuitUp::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
		_buf.append(',');
		_buf.append("suit=");
		_buf.appendUint(suit);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::SuitUp::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("mySecretPowerId", mySecretPowerId, _buf);
		Atf::XmlElement::encodeAsXmlElement("suit", suit, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::SuitUp::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("mySecretPowerId"))
		{
			mySecretPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("suit"))
		{
			suit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::SuitUp::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
		_msg0.composeBYTE(suit);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::SuitUp::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
	_parser0.parseBYTE(suit);
}

const char *StormHH::invoke::SuitUp::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("mySecretPowerId", mySecretPowerId);
		_jsonstr.compose("suit", suit);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::SuitUp::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("mySecretPowerId", mySecretPowerId);
	_jparser.parseByNameThrow("suit", suit);
}

/* static */ void StormHH::invoke::SuitUp::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 mySecretPowerId; _jparser.validateByNameThrow("mySecretPowerId", mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	BYTE suit; _jparser.validateByNameThrow("suit", suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::SuitUp::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::SuitUp::SuitUp()
{
	clear();
}

void StormHH::invoke::SuitUp::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::SuitUp::equals(const SuitUp& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::SuitUp::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::SuitUp::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::SuitUp::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::SuitUp::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::SuitUp::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::SuitUp::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::SuitUp::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::SuitUp::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::SuitUp::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    SplashPot
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::SplashPot::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::SplashPot::_PubDataType::clear()
{
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHH::invoke::SplashPot::_PubDataType::equals(const _PubDataType& _o) const
{
	return isRevealStage == _o.isRevealStage;
}

const char *StormHH::invoke::SplashPot::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::SplashPot::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("isRevealStage", isRevealStage, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::SplashPot::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isRevealStage"))
		{
			isRevealStage = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::SplashPot::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::SplashPot::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isRevealStage);
}

const char *StormHH::invoke::SplashPot::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("isRevealStage", isRevealStage);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::SplashPot::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isRevealStage", isRevealStage);
}

/* static */ void StormHH::invoke::SplashPot::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isRevealStage; _jparser.validateByNameThrow("isRevealStage", isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::SplashPot::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::SplashPot::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::SplashPot::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	splashSize = 0;
	_is_empty_internal = true;
}

bool StormHH::invoke::SplashPot::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId &&
		splashSize == _o.splashSize;
}

const char *StormHH::invoke::SplashPot::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
		_buf.append(',');
		_buf.append("splashSize=");
		_buf.appendInt64(splashSize);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::SplashPot::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("mySecretPowerId", mySecretPowerId, _buf);
		Atf::XmlElement::encodeAsXmlElement("splashSize", splashSize, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::SplashPot::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("mySecretPowerId"))
		{
			mySecretPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("splashSize"))
		{
			splashSize = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::SplashPot::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
		_msg0.composeINT64(splashSize);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::SplashPot::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
	_parser0.parseINT64(splashSize);
}

const char *StormHH::invoke::SplashPot::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("mySecretPowerId", mySecretPowerId);
		_jsonstr.compose("splashSize", splashSize);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::SplashPot::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("mySecretPowerId", mySecretPowerId);
	_jparser.parseByNameThrow("splashSize", splashSize);
}

/* static */ void StormHH::invoke::SplashPot::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 mySecretPowerId; _jparser.validateByNameThrow("mySecretPowerId", mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	INT64 splashSize; _jparser.validateByNameThrow("splashSize", splashSize);
	AtfValidator::validateInt(_descr, "splashSize", splashSize, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::SplashPot::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	INT64 splashSize; _parser0.parseINT64(splashSize);
	AtfValidator::validateInt(_descr, "splashSize", splashSize, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::SplashPot::SplashPot()
{
	clear();
}

void StormHH::invoke::SplashPot::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::SplashPot::equals(const SplashPot& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::SplashPot::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::SplashPot::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::SplashPot::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::SplashPot::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::SplashPot::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::SplashPot::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::SplashPot::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::SplashPot::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::SplashPot::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Sabotage
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::invoke::Sabotage::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::invoke::Sabotage::_PubDataType::clear()
{
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHH::invoke::Sabotage::_PubDataType::equals(const _PubDataType& _o) const
{
	return isRevealStage == _o.isRevealStage;
}

const char *StormHH::invoke::Sabotage::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Sabotage::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("isRevealStage", isRevealStage, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Sabotage::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isRevealStage"))
		{
			isRevealStage = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Sabotage::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Sabotage::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isRevealStage);
}

const char *StormHH::invoke::Sabotage::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("isRevealStage", isRevealStage);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Sabotage::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isRevealStage", isRevealStage);
}

/* static */ void StormHH::invoke::Sabotage::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isRevealStage; _jparser.validateByNameThrow("isRevealStage", isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Sabotage::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::invoke::Sabotage::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::invoke::Sabotage::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	destroyedPowerId = 0;
	hitPayment = 0;
	isManaHit = false;
	_is_empty_internal = true;
}

bool StormHH::invoke::Sabotage::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId &&
		destroyedPowerId == _o.destroyedPowerId &&
		hitPayment == _o.hitPayment &&
		isManaHit == _o.isManaHit;
}

const char *StormHH::invoke::Sabotage::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
		_buf.append(',');
		_buf.append("destroyedPowerId=");
		_buf.appendInt(destroyedPowerId);
		_buf.append(',');
		_buf.append("hitPayment=");
		_buf.appendInt64(hitPayment);
		_buf.append(',');
		_buf.append("isManaHit=");
		_buf.appendUint(isManaHit);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Sabotage::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("mySecretPowerId", mySecretPowerId, _buf);
		Atf::XmlElement::encodeAsXmlElement("destroyedPowerId", destroyedPowerId, _buf);
		Atf::XmlElement::encodeAsXmlElement("hitPayment", hitPayment, _buf);
		Atf::XmlElement::encodeAsXmlElement("isManaHit", isManaHit, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Sabotage::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("mySecretPowerId"))
		{
			mySecretPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("destroyedPowerId"))
		{
			destroyedPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hitPayment"))
		{
			hitPayment = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isManaHit"))
		{
			isManaHit = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::invoke::Sabotage::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
		_msg0.composeINT32(destroyedPowerId);
		_msg0.composeINT64(hitPayment);
		_msg0.composeBOOL(isManaHit);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::invoke::Sabotage::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
	_parser0.parseINT32(destroyedPowerId);
	_parser0.parseINT64(hitPayment);
	_parser0.parseBOOL(isManaHit);
}

const char *StormHH::invoke::Sabotage::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("mySecretPowerId", mySecretPowerId);
		_jsonstr.compose("destroyedPowerId", destroyedPowerId);
		_jsonstr.compose("hitPayment", hitPayment);
		_jsonstr.compose("isManaHit", isManaHit);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::invoke::Sabotage::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("mySecretPowerId", mySecretPowerId);
	_jparser.parseByNameThrow("destroyedPowerId", destroyedPowerId);
	_jparser.parseByNameThrow("hitPayment", hitPayment);
	_jparser.parseByNameThrow("isManaHit", isManaHit);
}

/* static */ void StormHH::invoke::Sabotage::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 mySecretPowerId; _jparser.validateByNameThrow("mySecretPowerId", mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	INT32 destroyedPowerId; _jparser.validateByNameThrow("destroyedPowerId", destroyedPowerId);
	AtfValidator::validateInt(_descr, "destroyedPowerId", destroyedPowerId, _checker, __FILE__, __LINE__);
	INT64 hitPayment; _jparser.validateByNameThrow("hitPayment", hitPayment);
	AtfValidator::validateInt(_descr, "hitPayment", hitPayment, _checker, __FILE__, __LINE__);
	bool isManaHit; _jparser.validateByNameThrow("isManaHit", isManaHit);
	AtfValidator::validateInt(_descr, "isManaHit", isManaHit, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::invoke::Sabotage::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	INT32 destroyedPowerId; _parser0.parseINT32(destroyedPowerId);
	AtfValidator::validateInt(_descr, "destroyedPowerId", destroyedPowerId, _checker, __FILE__, __LINE__);
	INT64 hitPayment; _parser0.parseINT64(hitPayment);
	AtfValidator::validateInt(_descr, "hitPayment", hitPayment, _checker, __FILE__, __LINE__);
	bool isManaHit; _parser0.parseBOOL(isManaHit);
	AtfValidator::validateInt(_descr, "isManaHit", isManaHit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::invoke::Sabotage::Sabotage()
{
	clear();
}

void StormHH::invoke::Sabotage::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::invoke::Sabotage::equals(const Sabotage& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::invoke::Sabotage::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::invoke::Sabotage::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::invoke::Sabotage::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::invoke::Sabotage::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::invoke::Sabotage::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::invoke::Sabotage::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::invoke::Sabotage::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::invoke::Sabotage::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::invoke::Sabotage::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Header
//=================================================================

StormHH::effect::Header::Header()
{
	clear();
}

void StormHH::effect::Header::clear()
{
	powerId = 0;
	exposePrivacy = false;
	powerCardUniqueId = 0;
}

bool StormHH::effect::Header::equals(const Header& _o) const
{
	return powerId == _o.powerId &&
		exposePrivacy == _o.exposePrivacy &&
		powerCardUniqueId == _o.powerCardUniqueId;
}

const char *StormHH::effect::Header::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("powerId=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("exposePrivacy=");
	_buf.appendUint(exposePrivacy);
	_buf.append(',');
	_buf.append("powerCardUniqueId=");
	_buf.appendInt(powerCardUniqueId);
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::Header::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("powerId", powerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("exposePrivacy", exposePrivacy, _buf);
	Atf::XmlElement::encodeAsXmlElement("powerCardUniqueId", powerCardUniqueId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::Header::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("powerId"))
		{
			powerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("exposePrivacy"))
		{
			exposePrivacy = (*_value.ptr() == '1');
		}
		else if (_element.equals("powerCardUniqueId"))
		{
			powerCardUniqueId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::Header::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Header())) // not empty
	{
		_body.composeINT32(powerId);
		_body.composeBOOL(exposePrivacy);
		_body.composeINT32(powerCardUniqueId);
	}

	_msg.composeMsgBody(_body);
}

void StormHH::effect::Header::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerId);
	_parser0.parseBOOL(exposePrivacy);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(powerCardUniqueId);
}

const char *StormHH::effect::Header::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("powerId", powerId);
	_jsonstr.compose("exposePrivacy", exposePrivacy);
	_jsonstr.compose("powerCardUniqueId", powerCardUniqueId);
	return _buf.c_str();
}

void StormHH::effect::Header::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("powerId", powerId);
	_jparser.parseByNameThrow("exposePrivacy", exposePrivacy);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("powerCardUniqueId", powerCardUniqueId);
}

/* static */ void StormHH::effect::Header::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 powerId; _jparser.validateByNameThrow("powerId", powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	bool exposePrivacy; _jparser.validateByNameThrow("exposePrivacy", exposePrivacy);
	AtfValidator::validateInt(_descr, "exposePrivacy", exposePrivacy, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 powerCardUniqueId; _jparser.validateByNameThrow("powerCardUniqueId", powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::Header::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 powerId; _parser0.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	bool exposePrivacy; _parser0.parseBOOL(exposePrivacy);
	AtfValidator::validateInt(_descr, "exposePrivacy", exposePrivacy, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 powerCardUniqueId; _parser0.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BaseData
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::BaseData::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::BaseData::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::BaseData::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::effect::BaseData::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::BaseData::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::BaseData::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::BaseData::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::BaseData::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::BaseData::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::BaseData::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::BaseData::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::BaseData::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::BaseData::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::BaseData::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::BaseData::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::BaseData::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::BaseData::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::BaseData::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::BaseData::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::BaseData::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::BaseData::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::BaseData::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::BaseData::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::BaseData::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::BaseData::BaseData()
{
	clear();
}

void StormHH::effect::BaseData::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::BaseData::equals(const BaseData& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::BaseData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::BaseData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::BaseData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::BaseData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::BaseData::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::BaseData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::BaseData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::BaseData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::BaseData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    PubClientExtraMsg
//=================================================================

StormHH::effect::PubClientExtraMsg::PubClientExtraMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::PubClientExtraMsg::PubClientExtraMsg(PubClientExtraMsg&& _o)
	: hasPrivateDataInSeparateMsg(std::move(_o.hasPrivateDataInSeparateMsg))
	, privateMessageSeatMask(std::move(_o.privateMessageSeatMask))
{
}

StormHH::effect::PubClientExtraMsg& StormHH::effect::PubClientExtraMsg::operator=(PubClientExtraMsg&& _o)
{
	if(this != &_o)
	{
		hasPrivateDataInSeparateMsg = std::move(_o.hasPrivateDataInSeparateMsg);
		privateMessageSeatMask = std::move(_o.privateMessageSeatMask);
	}
	return *this;
}

#endif

void StormHH::effect::PubClientExtraMsg::clear()
{
	hasPrivateDataInSeparateMsg = false;
	privateMessageSeatMask = 0;
}

bool StormHH::effect::PubClientExtraMsg::equals(const PubClientExtraMsg& _o) const
{
	return hasPrivateDataInSeparateMsg == _o.hasPrivateDataInSeparateMsg &&
		privateMessageSeatMask == _o.privateMessageSeatMask;
}

const char *StormHH::effect::PubClientExtraMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("hasPrivateDataInSeparateMsg=");
	_buf.appendUint(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_buf.append(',');
		_buf.append("privateMessageSeatMask=");
		_buf.appendInt(privateMessageSeatMask);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::PubClientExtraMsg::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg, _buf);
	if(hasPrivateDataInSeparateMsg)
	{
		Atf::XmlElement::encodeAsXmlElement("privateMessageSeatMask", privateMessageSeatMask, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::PubClientExtraMsg::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("hasPrivateDataInSeparateMsg"))
		{
			hasPrivateDataInSeparateMsg = (*_value.ptr() == '1');
		}
		else if (_element.equals("privateMessageSeatMask"))
		{
			privateMessageSeatMask = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::PubClientExtraMsg::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_msg.composeINT16(privateMessageSeatMask);
	}
}

void StormHH::effect::PubClientExtraMsg::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_parser.parseINT16(privateMessageSeatMask);
	}
}

const char *StormHH::effect::PubClientExtraMsg::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_jsonstr.compose("privateMessageSeatMask", privateMessageSeatMask);
	}
	return _buf.c_str();
}

void StormHH::effect::PubClientExtraMsg::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_jparser.parseByNameThrow("privateMessageSeatMask", privateMessageSeatMask);
	}
}

/* static */ void StormHH::effect::PubClientExtraMsg::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool hasPrivateDataInSeparateMsg = false;
	_jparser.validateByNameThrow("hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg);
	AtfValidator::validateInt(_descr, "hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg, _checker, __FILE__, __LINE__);
	if(hasPrivateDataInSeparateMsg)
	{
		INT16 privateMessageSeatMask; _jparser.validateByNameThrow("privateMessageSeatMask", privateMessageSeatMask);
		AtfValidator::validateInt(_descr, "privateMessageSeatMask", privateMessageSeatMask, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void StormHH::effect::PubClientExtraMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool hasPrivateDataInSeparateMsg = false;
	_parser.parseBOOL(hasPrivateDataInSeparateMsg);
	AtfValidator::validateInt(_descr, "hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg, _checker, __FILE__, __LINE__);
	if(hasPrivateDataInSeparateMsg)
	{
		INT16 privateMessageSeatMask; _parser.parseINT16(privateMessageSeatMask);
		AtfValidator::validateInt(_descr, "privateMessageSeatMask", privateMessageSeatMask, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    DarkBetCall
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::DarkBetCall::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::DarkBetCall::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::DarkBetCall::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::effect::DarkBetCall::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::DarkBetCall::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::DarkBetCall::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::DarkBetCall::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::DarkBetCall::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::DarkBetCall::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::DarkBetCall::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::DarkBetCall::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::DarkBetCall::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::DarkBetCall::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::DarkBetCall::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::DarkBetCall::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::DarkBetCall::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::DarkBetCall::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::DarkBetCall::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::DarkBetCall::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::DarkBetCall::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::DarkBetCall::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::DarkBetCall::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::DarkBetCall::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::DarkBetCall::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::DarkBetCall::DarkBetCall()
{
	clear();
}

void StormHH::effect::DarkBetCall::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::DarkBetCall::equals(const DarkBetCall& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::DarkBetCall::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::DarkBetCall::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::DarkBetCall::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::DarkBetCall::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::DarkBetCall::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::DarkBetCall::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::DarkBetCall::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::DarkBetCall::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::DarkBetCall::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    DarkBetEnd
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::DarkBetEnd::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::DarkBetEnd::_PubDataType::clear()
{
	amount = 0;
	_is_empty_internal = true;
}

bool StormHH::effect::DarkBetEnd::_PubDataType::equals(const _PubDataType& _o) const
{
	return amount == _o.amount;
}

const char *StormHH::effect::DarkBetEnd::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("amount=");
		_buf.appendInt64(amount);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::DarkBetEnd::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::DarkBetEnd::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::DarkBetEnd::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(amount);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::DarkBetEnd::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(amount);
}

const char *StormHH::effect::DarkBetEnd::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("amount", amount);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::DarkBetEnd::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void StormHH::effect::DarkBetEnd::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::DarkBetEnd::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::DarkBetEnd::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::DarkBetEnd::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::DarkBetEnd::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::DarkBetEnd::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::DarkBetEnd::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::DarkBetEnd::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::DarkBetEnd::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::DarkBetEnd::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::DarkBetEnd::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::DarkBetEnd::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::DarkBetEnd::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::DarkBetEnd::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::DarkBetEnd::DarkBetEnd()
{
	clear();
}

void StormHH::effect::DarkBetEnd::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::DarkBetEnd::equals(const DarkBetEnd& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::DarkBetEnd::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::DarkBetEnd::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::DarkBetEnd::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::DarkBetEnd::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::DarkBetEnd::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::DarkBetEnd::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::DarkBetEnd::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::DarkBetEnd::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::DarkBetEnd::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    AllInFreeze
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::AllInFreeze::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::AllInFreeze::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::AllInFreeze::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::effect::AllInFreeze::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::AllInFreeze::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::AllInFreeze::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::AllInFreeze::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::AllInFreeze::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::AllInFreeze::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::AllInFreeze::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::AllInFreeze::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::AllInFreeze::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::AllInFreeze::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::AllInFreeze::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::AllInFreeze::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::AllInFreeze::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::AllInFreeze::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::AllInFreeze::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::AllInFreeze::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::AllInFreeze::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::AllInFreeze::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::AllInFreeze::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::AllInFreeze::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::AllInFreeze::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::AllInFreeze::AllInFreeze()
{
	clear();
}

void StormHH::effect::AllInFreeze::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::AllInFreeze::equals(const AllInFreeze& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::AllInFreeze::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::AllInFreeze::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::AllInFreeze::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::AllInFreeze::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::AllInFreeze::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::AllInFreeze::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::AllInFreeze::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::AllInFreeze::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::AllInFreeze::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ReplaceBoardCard
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::ReplaceBoardCard::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ReplaceBoardCard::_PubDataType::_PubDataType(_PubDataType&& _o)
	: oldCard(std::move(_o.oldCard))
	, newCard(std::move(_o.newCard))
	, suit(std::move(_o.suit))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::ReplaceBoardCard::_PubDataType& StormHH::effect::ReplaceBoardCard::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		oldCard = std::move(_o.oldCard);
		newCard = std::move(_o.newCard);
		suit = std::move(_o.suit);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::ReplaceBoardCard::_PubDataType::clear()
{
	oldCard.clear();
	newCard.clear();
	suit = 0;
	_is_empty_internal = true;
}

bool StormHH::effect::ReplaceBoardCard::_PubDataType::equals(const _PubDataType& _o) const
{
	return Atf::atfPStringEquals(oldCard, _o.oldCard) &&
		Atf::atfPStringEquals(newCard, _o.newCard) &&
		suit == _o.suit;
}

const char *StormHH::effect::ReplaceBoardCard::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("oldCard=");
		_buf.append(oldCard);
		_buf.append(',');
		_buf.append("newCard=");
		_buf.append(newCard);
		_buf.append(',');
		_buf.append("suit=");
		_buf.appendUint(suit);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReplaceBoardCard::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("oldCard", oldCard, _buf);
		Atf::XmlElement::encodeAsXmlElement("newCard", newCard, _buf);
		Atf::XmlElement::encodeAsXmlElement("suit", suit, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReplaceBoardCard::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("oldCard"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, oldCard)) return false;
		}
		else if (_element.equals("newCard"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, newCard)) return false;
		}
		else if (_element.equals("suit"))
		{
			suit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::ReplaceBoardCard::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(oldCard);
		_msg0.composeString(newCard);
		_msg0.composeBYTE(suit);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ReplaceBoardCard::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(oldCard);
	_parser0.parseStringP(newCard);
	_parser0.parseBYTE(suit);
}

const char *StormHH::effect::ReplaceBoardCard::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("oldCard", oldCard);
		_jsonstr.compose("newCard", newCard);
		_jsonstr.compose("suit", suit);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::ReplaceBoardCard::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("oldCard", oldCard);
	_jparser.parseByNameThrow("newCard", newCard);
	_jparser.parseByNameThrow("suit", suit);
}

/* static */ void StormHH::effect::ReplaceBoardCard::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString oldCard; _jparser.validateByNameThrow("oldCard", oldCard);
	AtfValidator::validateInt(_descr, "oldCard", oldCard.length(), _checker, __FILE__, __LINE__);
	PString newCard; _jparser.validateByNameThrow("newCard", newCard);
	AtfValidator::validateInt(_descr, "newCard", newCard.length(), _checker, __FILE__, __LINE__);
	BYTE suit; _jparser.validateByNameThrow("suit", suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::ReplaceBoardCard::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "oldCard"); size_t szOldCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "oldCard", szOldCard, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "newCard"); size_t szNewCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "newCard", szNewCard, _checker, __FILE__, __LINE__);
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::ReplaceBoardCard::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::ReplaceBoardCard::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::ReplaceBoardCard::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::ReplaceBoardCard::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReplaceBoardCard::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReplaceBoardCard::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::ReplaceBoardCard::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ReplaceBoardCard::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::ReplaceBoardCard::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::ReplaceBoardCard::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::ReplaceBoardCard::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::ReplaceBoardCard::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::ReplaceBoardCard::ReplaceBoardCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ReplaceBoardCard::ReplaceBoardCard(ReplaceBoardCard&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::ReplaceBoardCard& StormHH::effect::ReplaceBoardCard::operator=(ReplaceBoardCard&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::ReplaceBoardCard::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::ReplaceBoardCard::equals(const ReplaceBoardCard& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::ReplaceBoardCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReplaceBoardCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReplaceBoardCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::ReplaceBoardCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::ReplaceBoardCard::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::ReplaceBoardCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::ReplaceBoardCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::ReplaceBoardCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::ReplaceBoardCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ReplaceMultiBoardCards
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::ReplaceMultiBoardCards::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ReplaceMultiBoardCards::_PubDataType::_PubDataType(_PubDataType&& _o)
	: oldCards(std::move(_o.oldCards))
	, newCards(std::move(_o.newCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::ReplaceMultiBoardCards::_PubDataType& StormHH::effect::ReplaceMultiBoardCards::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		oldCards = std::move(_o.oldCards);
		newCards = std::move(_o.newCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::ReplaceMultiBoardCards::_PubDataType::clear()
{
	oldCards.clear();
	newCards.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::ReplaceMultiBoardCards::_PubDataType::equals(const _PubDataType& _o) const
{
	return oldCards.equals(_o.oldCards) &&
		newCards.equals(_o.newCards);
}

const char *StormHH::effect::ReplaceMultiBoardCards::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("oldCards=");
		oldCards.toTraceString(_buf);
		_buf.append(',');
		_buf.append("newCards=");
		newCards.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReplaceMultiBoardCards::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		oldCards.toXmlString("oldCards", _buf);
		newCards.toXmlString("newCards", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReplaceMultiBoardCards::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("oldCards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, oldCards)) return false;
		}
		else if (_element.equals("newCards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, newCards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::ReplaceMultiBoardCards::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		oldCards.composeMsg(_msg0, _ignoreJSON);
		newCards.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ReplaceMultiBoardCards::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	oldCards.parseMsg(_parser0);
	newCards.parseMsg(_parser0);
}

const char *StormHH::effect::ReplaceMultiBoardCards::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("oldCards", oldCards);
		_jsonstr.compose("newCards", newCards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::ReplaceMultiBoardCards::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("oldCards", oldCards);
	_jparser.parseByNameThrow("newCards", newCards);
}

/* static */ void StormHH::effect::ReplaceMultiBoardCards::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PString > oldCards; _jparser.validateByNameThrow("oldCards", oldCards);
	AtfValidator::validateInt(_descr, "oldCards", oldCards.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > newCards; _jparser.validateByNameThrow("newCards", newCards);
	AtfValidator::validateInt(_descr, "newCards", newCards.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::ReplaceMultiBoardCards::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	int szOldCards = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("oldCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "oldCards", szOldCards, _checker, __FILE__, __LINE__);
	int szNewCards = Atf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("newCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "newCards", szNewCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::ReplaceMultiBoardCards::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::ReplaceMultiBoardCards::ReplaceMultiBoardCards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ReplaceMultiBoardCards::ReplaceMultiBoardCards(ReplaceMultiBoardCards&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::ReplaceMultiBoardCards& StormHH::effect::ReplaceMultiBoardCards::operator=(ReplaceMultiBoardCards&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::ReplaceMultiBoardCards::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::ReplaceMultiBoardCards::equals(const ReplaceMultiBoardCards& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::ReplaceMultiBoardCards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReplaceMultiBoardCards::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReplaceMultiBoardCards::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::ReplaceMultiBoardCards::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::ReplaceMultiBoardCards::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::ReplaceMultiBoardCards::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::ReplaceMultiBoardCards::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::ReplaceMultiBoardCards::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::ReplaceMultiBoardCards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    AddBoardCard
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::AddBoardCard::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::AddBoardCard::_PubDataType::_PubDataType(_PubDataType&& _o)
	: card(std::move(_o.card))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::AddBoardCard::_PubDataType& StormHH::effect::AddBoardCard::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		card = std::move(_o.card);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::AddBoardCard::_PubDataType::clear()
{
	card.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::AddBoardCard::_PubDataType::equals(const _PubDataType& _o) const
{
	return Atf::atfPStringEquals(card, _o.card);
}

const char *StormHH::effect::AddBoardCard::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("card=");
		_buf.append(card);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::AddBoardCard::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("card", card, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::AddBoardCard::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("card"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, card)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::AddBoardCard::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(card);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::AddBoardCard::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(card);
}

const char *StormHH::effect::AddBoardCard::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("card", card);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::AddBoardCard::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("card", card);
}

/* static */ void StormHH::effect::AddBoardCard::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString card; _jparser.validateByNameThrow("card", card);
	AtfValidator::validateInt(_descr, "card", card.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::AddBoardCard::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "card"); size_t szCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "card", szCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::AddBoardCard::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::AddBoardCard::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::AddBoardCard::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::AddBoardCard::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::AddBoardCard::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::AddBoardCard::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::AddBoardCard::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::AddBoardCard::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::AddBoardCard::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::AddBoardCard::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::AddBoardCard::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::AddBoardCard::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::AddBoardCard::AddBoardCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::AddBoardCard::AddBoardCard(AddBoardCard&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::AddBoardCard& StormHH::effect::AddBoardCard::operator=(AddBoardCard&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::AddBoardCard::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::AddBoardCard::equals(const AddBoardCard& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::AddBoardCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::AddBoardCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::AddBoardCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::AddBoardCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::AddBoardCard::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::AddBoardCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::AddBoardCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::AddBoardCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::AddBoardCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    GetFreeChips
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::GetFreeChips::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::GetFreeChips::_PubDataType::clear()
{
	freeChipsReceived = 0;
	_is_empty_internal = true;
}

bool StormHH::effect::GetFreeChips::_PubDataType::equals(const _PubDataType& _o) const
{
	return freeChipsReceived == _o.freeChipsReceived;
}

const char *StormHH::effect::GetFreeChips::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("freeChipsReceived=");
		_buf.appendInt64(freeChipsReceived);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::GetFreeChips::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("freeChipsReceived", freeChipsReceived, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::GetFreeChips::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("freeChipsReceived"))
		{
			freeChipsReceived = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::GetFreeChips::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(freeChipsReceived);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::GetFreeChips::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(freeChipsReceived);
}

const char *StormHH::effect::GetFreeChips::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("freeChipsReceived", freeChipsReceived);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::GetFreeChips::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("freeChipsReceived", freeChipsReceived);
}

/* static */ void StormHH::effect::GetFreeChips::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 freeChipsReceived; _jparser.validateByNameThrow("freeChipsReceived", freeChipsReceived);
	AtfValidator::validateInt(_descr, "freeChipsReceived", freeChipsReceived, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::GetFreeChips::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 freeChipsReceived; _parser0.parseINT64(freeChipsReceived);
	AtfValidator::validateInt(_descr, "freeChipsReceived", freeChipsReceived, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::GetFreeChips::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::GetFreeChips::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::GetFreeChips::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::GetFreeChips::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::GetFreeChips::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::GetFreeChips::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::GetFreeChips::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::GetFreeChips::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::GetFreeChips::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::GetFreeChips::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::GetFreeChips::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::GetFreeChips::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::GetFreeChips::GetFreeChips()
{
	clear();
}

void StormHH::effect::GetFreeChips::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::GetFreeChips::equals(const GetFreeChips& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::GetFreeChips::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::GetFreeChips::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::GetFreeChips::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::GetFreeChips::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::GetFreeChips::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::GetFreeChips::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::GetFreeChips::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::GetFreeChips::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::GetFreeChips::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    CarryOverChipsToNextHand
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::CarryOverChipsToNextHand::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::CarryOverChipsToNextHand::_PubDataType::clear()
{
	chipsCarriedOver = 0;
	_is_empty_internal = true;
}

bool StormHH::effect::CarryOverChipsToNextHand::_PubDataType::equals(const _PubDataType& _o) const
{
	return chipsCarriedOver == _o.chipsCarriedOver;
}

const char *StormHH::effect::CarryOverChipsToNextHand::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("chipsCarriedOver=");
		_buf.appendInt64(chipsCarriedOver);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::CarryOverChipsToNextHand::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("chipsCarriedOver", chipsCarriedOver, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::CarryOverChipsToNextHand::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chipsCarriedOver"))
		{
			chipsCarriedOver = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::CarryOverChipsToNextHand::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(chipsCarriedOver);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::CarryOverChipsToNextHand::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(chipsCarriedOver);
}

const char *StormHH::effect::CarryOverChipsToNextHand::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("chipsCarriedOver", chipsCarriedOver);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::CarryOverChipsToNextHand::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chipsCarriedOver", chipsCarriedOver);
}

/* static */ void StormHH::effect::CarryOverChipsToNextHand::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 chipsCarriedOver; _jparser.validateByNameThrow("chipsCarriedOver", chipsCarriedOver);
	AtfValidator::validateInt(_descr, "chipsCarriedOver", chipsCarriedOver, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::CarryOverChipsToNextHand::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 chipsCarriedOver; _parser0.parseINT64(chipsCarriedOver);
	AtfValidator::validateInt(_descr, "chipsCarriedOver", chipsCarriedOver, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::CarryOverChipsToNextHand::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::CarryOverChipsToNextHand::CarryOverChipsToNextHand()
{
	clear();
}

void StormHH::effect::CarryOverChipsToNextHand::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::CarryOverChipsToNextHand::equals(const CarryOverChipsToNextHand& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::CarryOverChipsToNextHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::CarryOverChipsToNextHand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::CarryOverChipsToNextHand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::CarryOverChipsToNextHand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::CarryOverChipsToNextHand::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::CarryOverChipsToNextHand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::CarryOverChipsToNextHand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::CarryOverChipsToNextHand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::CarryOverChipsToNextHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    FrozenCardHit
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::FrozenCardHit::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::FrozenCardHit::_PubDataType::_PubDataType(_PubDataType&& _o)
	: card(std::move(_o.card))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::FrozenCardHit::_PubDataType& StormHH::effect::FrozenCardHit::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		card = std::move(_o.card);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::FrozenCardHit::_PubDataType::clear()
{
	card.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::FrozenCardHit::_PubDataType::equals(const _PubDataType& _o) const
{
	return Atf::atfPStringEquals(card, _o.card);
}

const char *StormHH::effect::FrozenCardHit::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("card=");
		_buf.append(card);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::FrozenCardHit::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("card", card, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::FrozenCardHit::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("card"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, card)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::FrozenCardHit::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(card);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::FrozenCardHit::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(card);
}

const char *StormHH::effect::FrozenCardHit::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("card", card);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::FrozenCardHit::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("card", card);
}

/* static */ void StormHH::effect::FrozenCardHit::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString card; _jparser.validateByNameThrow("card", card);
	AtfValidator::validateInt(_descr, "card", card.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::FrozenCardHit::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "card"); size_t szCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "card", szCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::FrozenCardHit::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::FrozenCardHit::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::FrozenCardHit::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::FrozenCardHit::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::FrozenCardHit::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::FrozenCardHit::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::FrozenCardHit::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::FrozenCardHit::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::FrozenCardHit::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::FrozenCardHit::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::FrozenCardHit::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::FrozenCardHit::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::FrozenCardHit::FrozenCardHit()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::FrozenCardHit::FrozenCardHit(FrozenCardHit&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::FrozenCardHit& StormHH::effect::FrozenCardHit::operator=(FrozenCardHit&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::FrozenCardHit::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::FrozenCardHit::equals(const FrozenCardHit& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::FrozenCardHit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::FrozenCardHit::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::FrozenCardHit::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::FrozenCardHit::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::FrozenCardHit::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::FrozenCardHit::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::FrozenCardHit::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::FrozenCardHit::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::FrozenCardHit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ShowOneHoleCard
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::ShowOneHoleCard::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ShowOneHoleCard::_PubDataType::_PubDataType(_PubDataType&& _o)
	: card(std::move(_o.card))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::ShowOneHoleCard::_PubDataType& StormHH::effect::ShowOneHoleCard::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		card = std::move(_o.card);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::ShowOneHoleCard::_PubDataType::clear()
{
	card.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::ShowOneHoleCard::_PubDataType::equals(const _PubDataType& _o) const
{
	return Atf::atfPStringEquals(card, _o.card);
}

const char *StormHH::effect::ShowOneHoleCard::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("card=");
		_buf.append(card);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ShowOneHoleCard::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("card", card, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ShowOneHoleCard::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("card"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, card)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::ShowOneHoleCard::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(card);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ShowOneHoleCard::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(card);
}

const char *StormHH::effect::ShowOneHoleCard::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("card", card);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::ShowOneHoleCard::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("card", card);
}

/* static */ void StormHH::effect::ShowOneHoleCard::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString card; _jparser.validateByNameThrow("card", card);
	AtfValidator::validateInt(_descr, "card", card.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::ShowOneHoleCard::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "card"); size_t szCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "card", szCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::ShowOneHoleCard::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::ShowOneHoleCard::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::ShowOneHoleCard::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHH::effect::ShowOneHoleCard::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ShowOneHoleCard::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ShowOneHoleCard::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::ShowOneHoleCard::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ShowOneHoleCard::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::ShowOneHoleCard::_PrivDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::ShowOneHoleCard::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::ShowOneHoleCard::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::ShowOneHoleCard::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHH::effect::ShowOneHoleCard::ShowOneHoleCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ShowOneHoleCard::ShowOneHoleCard(ShowOneHoleCard&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::ShowOneHoleCard& StormHH::effect::ShowOneHoleCard::operator=(ShowOneHoleCard&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::ShowOneHoleCard::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::ShowOneHoleCard::equals(const ShowOneHoleCard& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::ShowOneHoleCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ShowOneHoleCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ShowOneHoleCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::ShowOneHoleCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::ShowOneHoleCard::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::ShowOneHoleCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::ShowOneHoleCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::ShowOneHoleCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::ShowOneHoleCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ReplaceHoleCard
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::ReplaceHoleCard::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::ReplaceHoleCard::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::ReplaceHoleCard::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::effect::ReplaceHoleCard::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReplaceHoleCard::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReplaceHoleCard::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::ReplaceHoleCard::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ReplaceHoleCard::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::ReplaceHoleCard::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::ReplaceHoleCard::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::ReplaceHoleCard::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::ReplaceHoleCard::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::ReplaceHoleCard::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ReplaceHoleCard::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: oldCard(std::move(_o.oldCard))
	, newCard(std::move(_o.newCard))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::ReplaceHoleCard::_PrivDataType& StormHH::effect::ReplaceHoleCard::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		oldCard = std::move(_o.oldCard);
		newCard = std::move(_o.newCard);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::ReplaceHoleCard::_PrivDataType::clear()
{
	oldCard.clear();
	newCard.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::ReplaceHoleCard::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return Atf::atfPStringEquals(oldCard, _o.oldCard) &&
		Atf::atfPStringEquals(newCard, _o.newCard);
}

const char *StormHH::effect::ReplaceHoleCard::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("oldCard=");
		_buf.append(oldCard);
		_buf.append(',');
		_buf.append("newCard=");
		_buf.append(newCard);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReplaceHoleCard::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("oldCard", oldCard, _buf);
		Atf::XmlElement::encodeAsXmlElement("newCard", newCard, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReplaceHoleCard::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("oldCard"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, oldCard)) return false;
		}
		else if (_element.equals("newCard"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, newCard)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::ReplaceHoleCard::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(oldCard);
		_msg0.composeString(newCard);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ReplaceHoleCard::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(oldCard);
	_parser0.parseStringP(newCard);
}

const char *StormHH::effect::ReplaceHoleCard::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("oldCard", oldCard);
		_jsonstr.compose("newCard", newCard);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::ReplaceHoleCard::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("oldCard", oldCard);
	_jparser.parseByNameThrow("newCard", newCard);
}

/* static */ void StormHH::effect::ReplaceHoleCard::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString oldCard; _jparser.validateByNameThrow("oldCard", oldCard);
	AtfValidator::validateInt(_descr, "oldCard", oldCard.length(), _checker, __FILE__, __LINE__);
	PString newCard; _jparser.validateByNameThrow("newCard", newCard);
	AtfValidator::validateInt(_descr, "newCard", newCard.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::ReplaceHoleCard::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "oldCard"); size_t szOldCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "oldCard", szOldCard, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "newCard"); size_t szNewCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "newCard", szNewCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::effect::ReplaceHoleCard::ReplaceHoleCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ReplaceHoleCard::ReplaceHoleCard(ReplaceHoleCard&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::ReplaceHoleCard& StormHH::effect::ReplaceHoleCard::operator=(ReplaceHoleCard&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::ReplaceHoleCard::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::ReplaceHoleCard::equals(const ReplaceHoleCard& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::ReplaceHoleCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReplaceHoleCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReplaceHoleCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::ReplaceHoleCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::ReplaceHoleCard::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::ReplaceHoleCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::ReplaceHoleCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::ReplaceHoleCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::ReplaceHoleCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ReceiveHoleCards
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::ReceiveHoleCards::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::ReceiveHoleCards::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::ReceiveHoleCards::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::effect::ReceiveHoleCards::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReceiveHoleCards::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReceiveHoleCards::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::ReceiveHoleCards::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ReceiveHoleCards::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::ReceiveHoleCards::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::ReceiveHoleCards::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::ReceiveHoleCards::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::ReceiveHoleCards::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::ReceiveHoleCards::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ReceiveHoleCards::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: cards(std::move(_o.cards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::ReceiveHoleCards::_PrivDataType& StormHH::effect::ReceiveHoleCards::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::ReceiveHoleCards::_PrivDataType::clear()
{
	cards.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::ReceiveHoleCards::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return Atf::atfPStringEquals(cards, _o.cards);
}

const char *StormHH::effect::ReceiveHoleCards::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cards=");
		_buf.append(cards);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReceiveHoleCards::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("cards", cards, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReceiveHoleCards::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cards"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::ReceiveHoleCards::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(cards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ReceiveHoleCards::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cards);
}

const char *StormHH::effect::ReceiveHoleCards::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("cards", cards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::ReceiveHoleCards::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cards", cards);
}

/* static */ void StormHH::effect::ReceiveHoleCards::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::ReceiveHoleCards::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cards"); size_t szCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::effect::ReceiveHoleCards::ReceiveHoleCards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::ReceiveHoleCards::ReceiveHoleCards(ReceiveHoleCards&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::ReceiveHoleCards& StormHH::effect::ReceiveHoleCards::operator=(ReceiveHoleCards&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::ReceiveHoleCards::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::ReceiveHoleCards::equals(const ReceiveHoleCards& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::ReceiveHoleCards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ReceiveHoleCards::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ReceiveHoleCards::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::ReceiveHoleCards::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::ReceiveHoleCards::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::ReceiveHoleCards::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::ReceiveHoleCards::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::ReceiveHoleCards::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::ReceiveHoleCards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    DiscardHoleCards
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::DiscardHoleCards::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::DiscardHoleCards::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::DiscardHoleCards::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::effect::DiscardHoleCards::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::DiscardHoleCards::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::DiscardHoleCards::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::DiscardHoleCards::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::DiscardHoleCards::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::DiscardHoleCards::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::DiscardHoleCards::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::DiscardHoleCards::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::DiscardHoleCards::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::DiscardHoleCards::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::DiscardHoleCards::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: cards(std::move(_o.cards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::DiscardHoleCards::_PrivDataType& StormHH::effect::DiscardHoleCards::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::DiscardHoleCards::_PrivDataType::clear()
{
	cards.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::DiscardHoleCards::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return Atf::atfPStringEquals(cards, _o.cards);
}

const char *StormHH::effect::DiscardHoleCards::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cards=");
		_buf.append(cards);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::DiscardHoleCards::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("cards", cards, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::DiscardHoleCards::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cards"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::DiscardHoleCards::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(cards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::DiscardHoleCards::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cards);
}

const char *StormHH::effect::DiscardHoleCards::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("cards", cards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::DiscardHoleCards::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cards", cards);
}

/* static */ void StormHH::effect::DiscardHoleCards::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::DiscardHoleCards::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cards"); size_t szCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::effect::DiscardHoleCards::DiscardHoleCards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::DiscardHoleCards::DiscardHoleCards(DiscardHoleCards&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::DiscardHoleCards& StormHH::effect::DiscardHoleCards::operator=(DiscardHoleCards&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::DiscardHoleCards::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::DiscardHoleCards::equals(const DiscardHoleCards& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::DiscardHoleCards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::DiscardHoleCards::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::DiscardHoleCards::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::DiscardHoleCards::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::DiscardHoleCards::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::DiscardHoleCards::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::DiscardHoleCards::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::DiscardHoleCards::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::DiscardHoleCards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    RebootEffect
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::RebootEffect::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::RebootEffect::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::RebootEffect::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::effect::RebootEffect::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::RebootEffect::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::RebootEffect::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::RebootEffect::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::RebootEffect::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::RebootEffect::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::RebootEffect::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::RebootEffect::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::RebootEffect::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::RebootEffect::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::RebootEffect::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: discardedPowers(std::move(_o.discardedPowers))
	, reloadedPowers(std::move(_o.reloadedPowers))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::RebootEffect::_PrivDataType& StormHH::effect::RebootEffect::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		discardedPowers = std::move(_o.discardedPowers);
		reloadedPowers = std::move(_o.reloadedPowers);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::RebootEffect::_PrivDataType::clear()
{
	discardedPowers.clear();
	reloadedPowers.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::RebootEffect::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return discardedPowers.equals(_o.discardedPowers) &&
		reloadedPowers.equals(_o.reloadedPowers);
}

const char *StormHH::effect::RebootEffect::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("discardedPowers=");
		discardedPowers.toTraceString(_buf);
		_buf.append(',');
		_buf.append("reloadedPowers=");
		reloadedPowers.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::RebootEffect::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		discardedPowers.toXmlString("discardedPowers", _buf);
		reloadedPowers.toXmlString("reloadedPowers", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::RebootEffect::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("discardedPowers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, discardedPowers)) return false;
		}
		else if (_element.equals("reloadedPowers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, reloadedPowers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::RebootEffect::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		discardedPowers.composeMsg(_msg0, _ignoreJSON);
		reloadedPowers.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::RebootEffect::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	discardedPowers.parseMsg(_parser0);
	reloadedPowers.parseMsg(_parser0);
}

const char *StormHH::effect::RebootEffect::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("discardedPowers", discardedPowers);
		_jsonstr.compose("reloadedPowers", reloadedPowers);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::RebootEffect::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("discardedPowers", discardedPowers);
	_jparser.parseByNameThrow("reloadedPowers", reloadedPowers);
}

/* static */ void StormHH::effect::RebootEffect::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT32 > discardedPowers; _jparser.validateByNameThrow("discardedPowers", discardedPowers);
	AtfValidator::validateInt(_descr, "discardedPowers", discardedPowers.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > reloadedPowers; _jparser.validateByNameThrow("reloadedPowers", reloadedPowers);
	AtfValidator::validateInt(_descr, "reloadedPowers", reloadedPowers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::RebootEffect::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	int szDiscardedPowers = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("discardedPowers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "discardedPowers", szDiscardedPowers, _checker, __FILE__, __LINE__);
	int szReloadedPowers = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("reloadedPowers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "reloadedPowers", szReloadedPowers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::effect::RebootEffect::RebootEffect()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::RebootEffect::RebootEffect(RebootEffect&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::RebootEffect& StormHH::effect::RebootEffect::operator=(RebootEffect&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::RebootEffect::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::RebootEffect::equals(const RebootEffect& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::RebootEffect::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::RebootEffect::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::RebootEffect::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::RebootEffect::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::RebootEffect::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::RebootEffect::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::RebootEffect::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::RebootEffect::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::RebootEffect::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    IntelEffect
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::IntelEffect::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::IntelEffect::_PubDataType::clear()
{
	numCardsSensed = 0;
	_is_empty_internal = true;
}

bool StormHH::effect::IntelEffect::_PubDataType::equals(const _PubDataType& _o) const
{
	return numCardsSensed == _o.numCardsSensed;
}

const char *StormHH::effect::IntelEffect::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numCardsSensed=");
		_buf.appendInt(numCardsSensed);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::IntelEffect::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("numCardsSensed", numCardsSensed, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::IntelEffect::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numCardsSensed"))
		{
			numCardsSensed = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::IntelEffect::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numCardsSensed);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::IntelEffect::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numCardsSensed);
}

const char *StormHH::effect::IntelEffect::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("numCardsSensed", numCardsSensed);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::IntelEffect::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numCardsSensed", numCardsSensed);
}

/* static */ void StormHH::effect::IntelEffect::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numCardsSensed; _jparser.validateByNameThrow("numCardsSensed", numCardsSensed);
	AtfValidator::validateInt(_descr, "numCardsSensed", numCardsSensed, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::IntelEffect::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numCardsSensed; _parser0.parseINT32(numCardsSensed);
	AtfValidator::validateInt(_descr, "numCardsSensed", numCardsSensed, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::IntelEffect::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::IntelEffect::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: sensedCards(std::move(_o.sensedCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::IntelEffect::_PrivDataType& StormHH::effect::IntelEffect::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		sensedCards = std::move(_o.sensedCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::IntelEffect::_PrivDataType::clear()
{
	sensedCards.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::IntelEffect::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return Atf::atfPStringEquals(sensedCards, _o.sensedCards);
}

const char *StormHH::effect::IntelEffect::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("sensedCards=");
		_buf.append(sensedCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::IntelEffect::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("sensedCards", sensedCards, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::IntelEffect::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sensedCards"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, sensedCards)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::IntelEffect::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(sensedCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::IntelEffect::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(sensedCards);
}

const char *StormHH::effect::IntelEffect::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("sensedCards", sensedCards);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::IntelEffect::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sensedCards", sensedCards);
}

/* static */ void StormHH::effect::IntelEffect::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString sensedCards; _jparser.validateByNameThrow("sensedCards", sensedCards);
	AtfValidator::validateInt(_descr, "sensedCards", sensedCards.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::IntelEffect::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "sensedCards"); size_t szSensedCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sensedCards", szSensedCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::effect::IntelEffect::IntelEffect()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::IntelEffect::IntelEffect(IntelEffect&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::IntelEffect& StormHH::effect::IntelEffect::operator=(IntelEffect&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::IntelEffect::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::IntelEffect::equals(const IntelEffect& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::IntelEffect::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::IntelEffect::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::IntelEffect::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::IntelEffect::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::IntelEffect::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::IntelEffect::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::IntelEffect::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::IntelEffect::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::IntelEffect::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ExchangePowerEffect
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::ExchangePowerEffect::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::ExchangePowerEffect::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHH::effect::ExchangePowerEffect::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHH::effect::ExchangePowerEffect::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ExchangePowerEffect::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ExchangePowerEffect::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;
	return true;
}

void StormHH::effect::ExchangePowerEffect::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ExchangePowerEffect::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

const char *StormHH::effect::ExchangePowerEffect::_PubDataType::toJSONString(PString& _buf) const
{
	_buf.append("{}");
	return _buf.c_str();
}

void StormHH::effect::ExchangePowerEffect::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void StormHH::effect::ExchangePowerEffect::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void StormHH::effect::ExchangePowerEffect::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::ExchangePowerEffect::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHH::effect::ExchangePowerEffect::_PrivDataType::clear()
{
	isAdded = false;
	changedPowerId = 0;
	_is_empty_internal = true;
}

bool StormHH::effect::ExchangePowerEffect::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return isAdded == _o.isAdded &&
		changedPowerId == _o.changedPowerId;
}

const char *StormHH::effect::ExchangePowerEffect::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isAdded=");
		_buf.appendUint(isAdded);
		_buf.append(',');
		_buf.append("changedPowerId=");
		_buf.appendInt(changedPowerId);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ExchangePowerEffect::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("isAdded", isAdded, _buf);
		Atf::XmlElement::encodeAsXmlElement("changedPowerId", changedPowerId, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ExchangePowerEffect::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isAdded"))
		{
			isAdded = (*_value.ptr() == '1');
		}
		else if (_element.equals("changedPowerId"))
		{
			changedPowerId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::ExchangePowerEffect::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isAdded);
		_msg0.composeINT32(changedPowerId);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::ExchangePowerEffect::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isAdded);
	_parser0.parseINT32(changedPowerId);
}

const char *StormHH::effect::ExchangePowerEffect::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("isAdded", isAdded);
		_jsonstr.compose("changedPowerId", changedPowerId);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::ExchangePowerEffect::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isAdded", isAdded);
	_jparser.parseByNameThrow("changedPowerId", changedPowerId);
}

/* static */ void StormHH::effect::ExchangePowerEffect::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isAdded; _jparser.validateByNameThrow("isAdded", isAdded);
	AtfValidator::validateInt(_descr, "isAdded", isAdded, _checker, __FILE__, __LINE__);
	INT32 changedPowerId; _jparser.validateByNameThrow("changedPowerId", changedPowerId);
	AtfValidator::validateInt(_descr, "changedPowerId", changedPowerId, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::ExchangePowerEffect::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isAdded; _parser0.parseBOOL(isAdded);
	AtfValidator::validateInt(_descr, "isAdded", isAdded, _checker, __FILE__, __LINE__);
	INT32 changedPowerId; _parser0.parseINT32(changedPowerId);
	AtfValidator::validateInt(_descr, "changedPowerId", changedPowerId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::effect::ExchangePowerEffect::ExchangePowerEffect()
{
	clear();
}

void StormHH::effect::ExchangePowerEffect::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::ExchangePowerEffect::equals(const ExchangePowerEffect& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::ExchangePowerEffect::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::ExchangePowerEffect::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::ExchangePowerEffect::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::ExchangePowerEffect::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::ExchangePowerEffect::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::ExchangePowerEffect::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::ExchangePowerEffect::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::ExchangePowerEffect::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::ExchangePowerEffect::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    MindControlDrawNewPowersEffect
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::_PubDataType()
{
	clear();
}

void StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::clear()
{
	numNewPowers = 0;
	_is_empty_internal = true;
}

bool StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::equals(const _PubDataType& _o) const
{
	return numNewPowers == _o.numNewPowers;
}

const char *StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numNewPowers=");
		_buf.appendInt(numNewPowers);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		Atf::XmlElement::encodeAsXmlElement("numNewPowers", numNewPowers, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numNewPowers"))
		{
			numNewPowers = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numNewPowers);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numNewPowers);
}

const char *StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("numNewPowers", numNewPowers);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numNewPowers", numNewPowers);
}

/* static */ void StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 numNewPowers; _jparser.validateByNameThrow("numNewPowers", numNewPowers);
	AtfValidator::validateInt(_descr, "numNewPowers", numNewPowers, _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::MindControlDrawNewPowersEffect::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numNewPowers; _parser0.parseINT32(numNewPowers);
	AtfValidator::validateInt(_descr, "numNewPowers", numNewPowers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: newPowerIds(std::move(_o.newPowerIds))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType& StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		newPowerIds = std::move(_o.newPowerIds);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::clear()
{
	newPowerIds.clear();
	_is_empty_internal = true;
}

bool StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return newPowerIds.equals(_o.newPowerIds);
}

const char *StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("newPowerIds=");
		newPowerIds.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		newPowerIds.toXmlString("newPowerIds", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("newPowerIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, newPowerIds)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		newPowerIds.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	newPowerIds.parseMsg(_parser0);
}

const char *StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("newPowerIds", newPowerIds);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("newPowerIds", newPowerIds);
}

/* static */ void StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT32 > newPowerIds; _jparser.validateByNameThrow("newPowerIds", newPowerIds);
	AtfValidator::validateInt(_descr, "newPowerIds", newPowerIds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void StormHH::effect::MindControlDrawNewPowersEffect::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	int szNewPowerIds = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("newPowerIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "newPowerIds", szNewPowerIds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHH::effect::MindControlDrawNewPowersEffect::MindControlDrawNewPowersEffect()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHH::effect::MindControlDrawNewPowersEffect::MindControlDrawNewPowersEffect(MindControlDrawNewPowersEffect&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHH::effect::MindControlDrawNewPowersEffect& StormHH::effect::MindControlDrawNewPowersEffect::operator=(MindControlDrawNewPowersEffect&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHH::effect::MindControlDrawNewPowersEffect::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHH::effect::MindControlDrawNewPowersEffect::equals(const MindControlDrawNewPowersEffect& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHH::effect::MindControlDrawNewPowersEffect::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *StormHH::effect::MindControlDrawNewPowersEffect::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	header.toXmlString("header", _buf);
	pubData.toXmlString("pubData", _buf);
	if(header.exposePrivacy)
	{
		privData.toXmlString("privData", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool StormHH::effect::MindControlDrawNewPowersEffect::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("header"))
		{
			if(!Atf::AtfTempl< Header >::FromXmlString(_value, header)) return false;
		}
		else if (_element.equals("pubData"))
		{
			if(!Atf::AtfTempl< _PubDataType >::FromXmlString(_value, pubData)) return false;
		}
		else if (_element.equals("privData"))
		{
			if(!Atf::AtfTempl< _PrivDataType >::FromXmlString(_value, privData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void StormHH::effect::MindControlDrawNewPowersEffect::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	header.composeMsg(_msg, _ignoreJSON);
	pubData.composeMsg(_msg, _ignoreJSON);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg, _ignoreJSON);
	}
}

void StormHH::effect::MindControlDrawNewPowersEffect::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

const char *StormHH::effect::MindControlDrawNewPowersEffect::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("header", header);
	_jsonstr.compose("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jsonstr.compose("privData", privData);
	}
	return _buf.c_str();
}

void StormHH::effect::MindControlDrawNewPowersEffect::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("header", header);
	_jparser.parseByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_jparser.parseByNameThrow("privData", privData);
	}
}

/* static */ void StormHH::effect::MindControlDrawNewPowersEffect::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Header header;
	_jparser.validateByNameThrow("header", header);
	_PubDataType pubData; _jparser.validateByNameThrow("pubData", pubData);
	if(header.exposePrivacy)
	{
		_PrivDataType privData; _jparser.validateByNameThrow("privData", privData);
	}
}

/*static*/ void StormHH::effect::MindControlDrawNewPowersEffect::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

