#include "../../atf/UserDefStructs.h"
#include "table.h"

#define TOP_LEVEL_NAMESPACE   StormHH${ATF_THIN_NAMESPACE_SUFFIX}


MsgBodyStruct P_Card
{
	char suit;
	BYTE rank;
	
	@Override P_Card(const Card& card)
	{
		suit = card.suit;
		rank = card.rank;
	}
	
	@Override operator Card()
	{
		Card card;
		card.suit = suit;
		card.rank = rank;
		return card;
	}
};


namespace invoke
{
	MsgBodyStruct Header
	{
		INT64 cost;
		bool exposePrivacy;
		INT32 powerCardUniqueId parseEndOptB4Me;  // guaranteed unique inside one hand if > 0
	};

	struct BaseData  // minimum fields must be defined in this "invoke" namespace
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};
	

	struct PubClientExtraMsg   // client extra msg on publication, this struct does not go to database
	{
		bool hasPrivateDataInSeparateMsg;

		if(hasPrivateDataInSeparateMsg)
		{
			INT16 privateMessageSeatMask;
		}
	};


	struct EMP
	{
		Header header;

		CommMsgBody pubData
		{
			BYTE startStreet default -1 parseEndOptB4Me;
			BYTE endStreet default -1;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};

	struct Clone
	{
		Header header;

		CommMsgBody pubData
		{
			INT32 powerIdToPlay default PokerGamePowerSecretPlaceholder;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				INT32 powerIdToPlay;
			};
		}
	};


	struct DarkBet
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				INT64 amount;
			};
		}
	};
	

	struct Scanner
	{
		Header header;

		CommMsgBody pubData
		{
			PString keepOrDiscard;  // "k" or "d"
			BYTE numCards;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				PString cards;
			};
		}
	};
	

	struct MindControl
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				INT32 stolenPowerId;
				vector<INT32> powersLeft;
			};
		}	
	};
	

	struct Intel
	{
		Header header;

		CommMsgBody pubData
		{
			INT32 numOfSensedNextCards;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				PString sensedCards;
			};
		}	
	};


	struct Pacify
	{
		Header header;

		CommMsgBody pubData
		{
			bool cardUnfreezePossible;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct Reload
	{
		Header header;

		CommMsgBody pubData
		{
			INT32 numCards;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct Chaos
	{
		Header header;

		CommMsgBody pubData
		{
			INT32 numBombs;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct Mint
	{
		Header header;

		CommMsgBody pubData
		{
			INT64 chipsMinted;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct Swap
	{
		Header header;

		CommMsgBody pubData
		{
			PString holeCard;
			PString boardCard;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct Engineer
	{
		Header header;

		CommMsgBody pubData
		{
			PString chosenCard;
			PString discardedCards;
			PString cardsCandidate parseEndOptB4Me;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct Reboot
	{
		Header header;

		CommMsgBody pubData
		{
			INT32 numPowersDrawn;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct Equalizer
	{
		Header header;

		CommMsgBody pubData
		{
			INT64 manaCopied;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct Freeze
	{
		Header header;

		CommMsgBody pubData
		{
			PString frozenCards;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct Syphon
	{
		Header header;

		CommMsgBody pubData
		{
			INT64 manaStolen;
			INT8 targetPlayer parseEndOptB4Me;
			PString targetUserId;
			INT64 manaReceived default -1 parseEndOptB4Me;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct AnteUp
	{
		Header header;

		CommMsgBody pubData
		{
			INT64 ante;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	// =================== the followings are secret powers =====================

	struct CounterSpell
	{
		Header header;

		CommMsgBody pubData
		{
			bool isRevealStage;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				INT32 mySecretPowerId default PokerGamePowerSecretPlaceholder;
				INT32 destroyedPowerId;
			};
		}
	};


	struct Lowblow
	{
		Header header;

		CommMsgBody pubData
		{
			bool isSecretPlay;
			bool isRevealStage;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				INT32 mySecretPowerId default PokerGamePowerSecretPlaceholder;
			};
		}
	};


	struct Stretch
	{
		Header header;

		CommMsgBody pubData
		{
			bool isSecretPlay;
			bool isRevealStage;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				INT32 mySecretPowerId default PokerGamePowerSecretPlaceholder;
			};
		}
	};


	struct SuitUp
	{
		Header header;

		CommMsgBody pubData
		{
			bool isRevealStage;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				INT32 mySecretPowerId default PokerGamePowerSecretPlaceholder;
				BYTE suit;
			};
		}
	};


	struct SplashPot
	{
		Header header;

		CommMsgBody pubData
		{
			bool isRevealStage;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				INT32 mySecretPowerId default PokerGamePowerSecretPlaceholder;
				INT64 splashSize;
			};
		}
	};


	struct Sabotage
	{
		Header header;

		CommMsgBody pubData
		{
			bool isRevealStage;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				INT32 mySecretPowerId default PokerGamePowerSecretPlaceholder;
				INT32 destroyedPowerId;
				INT64 hitPayment;
				bool isManaHit;
			};
		}
	};

};




namespace effect
{
	MsgBodyStruct Header
	{
		INT32 powerId;
		bool exposePrivacy;
		INT32 powerCardUniqueId parseEndOptB4Me;  // guaranteed unique inside one hand if > 0
	};

	struct BaseData  // minimum fields must be defined in this "invoke" namespace
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct PubClientExtraMsg   // client extra msg on publication, this struct does not go to database
	{
		bool hasPrivateDataInSeparateMsg;

		if(hasPrivateDataInSeparateMsg)
		{
			INT16 privateMessageSeatMask;
		}
	};


	struct DarkBetCall
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}	
	};


	struct DarkBetEnd
	{
		Header header;

		CommMsgBody pubData
		{
			INT64 amount;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}	
	};


	struct AllInFreeze
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}	
	};


	Struct ReplaceBoardCard
	{
		Header header;

		CommMsgBody pubData
		{
			PString oldCard;
			PString newCard;
			BYTE suit;  // for suit up
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}	
	};

	Struct ReplaceMultiBoardCards
	{
		Header header;

		CommMsgBody pubData
		{
			vector<PString> oldCards;
			vector<PString> newCards;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}	
	};

	Struct AddBoardCard
	{
		Header header;

		CommMsgBody pubData
		{
			PString card;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}	
	};


	Struct GetFreeChips
	{
		Header header;

		CommMsgBody pubData
		{
			INT64 freeChipsReceived;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}	
	};


	Struct CarryOverChipsToNextHand
	{
		Header header;

		CommMsgBody pubData
		{
			INT64 chipsCarriedOver;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}	
	};


	struct FrozenCardHit
	{
		Header header;

		CommMsgBody pubData
		{
			PString card;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct ShowOneHoleCard
	{
		Header header;

		CommMsgBody pubData
		{
			PString card;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
			};
		}
	};


	struct ReplaceHoleCard
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				PString oldCard;
				PString newCard;
			};
		}
	};


	struct ReceiveHoleCards
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				PString cards;
			};
		}
	};


	struct DiscardHoleCards
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				PString cards;
			};
		}
	};


	Struct RebootEffect
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				vector<INT32> discardedPowers;
				vector<INT32> reloadedPowers;
			};
		}
	};


	Struct IntelEffect
	{
		Header header;

		CommMsgBody pubData
		{
			INT32 numCardsSensed;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				PString sensedCards;
				
			};
		}
	};


	Struct ExchangePowerEffect
	{
		Header header;

		CommMsgBody pubData
		{
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				bool isAdded;
				INT32 changedPowerId;
			};
		}
	};


	struct MindControlDrawNewPowersEffect
	{
		Header header;

		CommMsgBody pubData
		{
			INT32 numNewPowers;
		};
		
		if(header.exposePrivacy)
		{
			CommMsgBody privData
			{
				vector<INT32> newPowerIds;
			};
		}
	};

};

