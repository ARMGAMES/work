/**
 * stormhh_thin.cpp
 *
 * This file was auto-generated from stormhh.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin stormhh.txt
 */
 
#include "stormhh_thin.h"

//=================================================================
//                    P_Card
//=================================================================

// @Override
StormHHThin::P_Card::P_Card(const Card& card)
{
	suit = card.suit;
	rank = card.rank;
}

// @Override
StormHHThin::P_Card::operator Card()
{
	Card card;
	card.suit = suit;
	card.rank = rank;
	return card;
}

StormHHThin::P_Card::P_Card()
{
	clear();
}

void StormHHThin::P_Card::clear()
{
	suit = '0';
	rank = 0;
}

bool StormHHThin::P_Card::equals(const P_Card& _o) const
{
	return suit == _o.suit &&
		rank == _o.rank;
}

const char *StormHHThin::P_Card::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("suit=");
	_buf.append(suit);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::P_Card::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(P_Card())) // not empty
	{
		_body.composeINT8(suit);
		_body.composeBYTE(rank);
	}

	_msg.composeMsgBody(_body);
}

void StormHHThin::P_Card::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	{ INT8 _n; _parser0.parseINT8(_n); suit = _n; }
	_parser0.parseBYTE(rank);
}

/*static*/ void StormHHThin::P_Card::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	char suit; { INT8 _n; _parser0.parseINT8(_n); suit = _n; }
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	BYTE rank; _parser0.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    Header
//=================================================================

StormHHThin::invoke::Header::Header()
{
	clear();
}

void StormHHThin::invoke::Header::clear()
{
	cost = 0;
	exposePrivacy = false;
	powerCardUniqueId = 0;
}

bool StormHHThin::invoke::Header::equals(const Header& _o) const
{
	return cost == _o.cost &&
		exposePrivacy == _o.exposePrivacy &&
		powerCardUniqueId == _o.powerCardUniqueId;
}

const char *StormHHThin::invoke::Header::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cost=");
	_buf.appendInt64(cost);
	_buf.append(',');
	_buf.append("exposePrivacy=");
	_buf.appendUint(exposePrivacy);
	_buf.append(',');
	_buf.append("powerCardUniqueId=");
	_buf.appendInt(powerCardUniqueId);
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Header::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(Header())) // not empty
	{
		_body.composeINT64(cost);
		_body.composeBOOL(exposePrivacy);
		_body.composeINT32(powerCardUniqueId);
	}

	_msg.composeMsgBody(_body);
}

void StormHHThin::invoke::Header::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(cost);
	_parser0.parseBOOL(exposePrivacy);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(powerCardUniqueId);
}

/*static*/ void StormHHThin::invoke::Header::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 cost; _parser0.parseINT64(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	bool exposePrivacy; _parser0.parseBOOL(exposePrivacy);
	AtfValidator::validateInt(_descr, "exposePrivacy", exposePrivacy, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 powerCardUniqueId; _parser0.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BaseData
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::BaseData::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::BaseData::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::BaseData::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::BaseData::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::BaseData::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::BaseData::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::BaseData::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::BaseData::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::BaseData::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::BaseData::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::BaseData::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::BaseData::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::BaseData::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::BaseData::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::BaseData::BaseData()
{
	clear();
}

void StormHHThin::invoke::BaseData::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::BaseData::equals(const BaseData& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::BaseData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::BaseData::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::BaseData::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::BaseData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    PubClientExtraMsg
//=================================================================

StormHHThin::invoke::PubClientExtraMsg::PubClientExtraMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::PubClientExtraMsg::PubClientExtraMsg(PubClientExtraMsg&& _o)
	: hasPrivateDataInSeparateMsg(std::move(_o.hasPrivateDataInSeparateMsg))
	, privateMessageSeatMask(std::move(_o.privateMessageSeatMask))
{
}

StormHHThin::invoke::PubClientExtraMsg& StormHHThin::invoke::PubClientExtraMsg::operator=(PubClientExtraMsg&& _o)
{
	if(this != &_o)
	{
		hasPrivateDataInSeparateMsg = std::move(_o.hasPrivateDataInSeparateMsg);
		privateMessageSeatMask = std::move(_o.privateMessageSeatMask);
	}
	return *this;
}

#endif

void StormHHThin::invoke::PubClientExtraMsg::clear()
{
	hasPrivateDataInSeparateMsg = false;
	privateMessageSeatMask = 0;
}

bool StormHHThin::invoke::PubClientExtraMsg::equals(const PubClientExtraMsg& _o) const
{
	return hasPrivateDataInSeparateMsg == _o.hasPrivateDataInSeparateMsg &&
		privateMessageSeatMask == _o.privateMessageSeatMask;
}

const char *StormHHThin::invoke::PubClientExtraMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("hasPrivateDataInSeparateMsg=");
	_buf.appendUint(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_buf.append(',');
		_buf.append("privateMessageSeatMask=");
		_buf.appendInt(privateMessageSeatMask);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::PubClientExtraMsg::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_msg.composeINT16(privateMessageSeatMask);
	}
}

void StormHHThin::invoke::PubClientExtraMsg::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_parser.parseINT16(privateMessageSeatMask);
	}
}

/*static*/ void StormHHThin::invoke::PubClientExtraMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool hasPrivateDataInSeparateMsg = false;
	_parser.parseBOOL(hasPrivateDataInSeparateMsg);
	AtfValidator::validateInt(_descr, "hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg, _checker, __FILE__, __LINE__);
	if(hasPrivateDataInSeparateMsg)
	{
		INT16 privateMessageSeatMask; _parser.parseINT16(privateMessageSeatMask);
		AtfValidator::validateInt(_descr, "privateMessageSeatMask", privateMessageSeatMask, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    EMP
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::EMP::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::EMP::_PubDataType::clear()
{
	startStreet = -1;
	endStreet = -1;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::EMP::_PubDataType::equals(const _PubDataType& _o) const
{
	return startStreet == _o.startStreet &&
		endStreet == _o.endStreet;
}

const char *StormHHThin::invoke::EMP::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("startStreet=");
		_buf.appendUint(startStreet);
		_buf.append(',');
		_buf.append("endStreet=");
		_buf.appendUint(endStreet);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::EMP::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBYTE(startStreet);
		_msg0.composeBYTE(endStreet);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::EMP::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseBYTE(startStreet);
	_parser0.parseBYTE(endStreet);
}

/*static*/ void StormHHThin::invoke::EMP::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	if(_parser0.parseEnded()) return;
	BYTE startStreet; _parser0.parseBYTE(startStreet);
	AtfValidator::validateInt(_descr, "startStreet", startStreet, _checker, __FILE__, __LINE__);
	BYTE endStreet; _parser0.parseBYTE(endStreet);
	AtfValidator::validateInt(_descr, "endStreet", endStreet, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::EMP::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::EMP::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::EMP::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::EMP::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::EMP::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::EMP::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::EMP::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::EMP::EMP()
{
	clear();
}

void StormHHThin::invoke::EMP::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::EMP::equals(const EMP& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::EMP::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::EMP::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::EMP::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::EMP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Clone
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Clone::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Clone::_PubDataType::clear()
{
	powerIdToPlay = PokerGamePowerSecretPlaceholder;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Clone::_PubDataType::equals(const _PubDataType& _o) const
{
	return powerIdToPlay == _o.powerIdToPlay;
}

const char *StormHHThin::invoke::Clone::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerIdToPlay=");
		_buf.appendInt(powerIdToPlay);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Clone::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(powerIdToPlay);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Clone::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerIdToPlay);
}

/*static*/ void StormHHThin::invoke::Clone::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 powerIdToPlay; _parser0.parseINT32(powerIdToPlay);
	AtfValidator::validateInt(_descr, "powerIdToPlay", powerIdToPlay, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Clone::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Clone::_PrivDataType::clear()
{
	powerIdToPlay = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Clone::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return powerIdToPlay == _o.powerIdToPlay;
}

const char *StormHHThin::invoke::Clone::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("powerIdToPlay=");
		_buf.appendInt(powerIdToPlay);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Clone::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(powerIdToPlay);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Clone::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerIdToPlay);
}

/*static*/ void StormHHThin::invoke::Clone::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 powerIdToPlay; _parser0.parseINT32(powerIdToPlay);
	AtfValidator::validateInt(_descr, "powerIdToPlay", powerIdToPlay, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::Clone::Clone()
{
	clear();
}

void StormHHThin::invoke::Clone::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Clone::equals(const Clone& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Clone::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Clone::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Clone::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Clone::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    DarkBet
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::DarkBet::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::DarkBet::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::DarkBet::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::DarkBet::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::DarkBet::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::DarkBet::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::DarkBet::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::DarkBet::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::DarkBet::_PrivDataType::clear()
{
	amount = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::DarkBet::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return amount == _o.amount;
}

const char *StormHHThin::invoke::DarkBet::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("amount=");
		_buf.appendInt64(amount);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::DarkBet::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(amount);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::DarkBet::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(amount);
}

/*static*/ void StormHHThin::invoke::DarkBet::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::DarkBet::DarkBet()
{
	clear();
}

void StormHHThin::invoke::DarkBet::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::DarkBet::equals(const DarkBet& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::DarkBet::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::DarkBet::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::DarkBet::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::DarkBet::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Scanner
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Scanner::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Scanner::_PubDataType::_PubDataType(_PubDataType&& _o)
	: keepOrDiscard(std::move(_o.keepOrDiscard))
	, numCards(std::move(_o.numCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::invoke::Scanner::_PubDataType& StormHHThin::invoke::Scanner::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		keepOrDiscard = std::move(_o.keepOrDiscard);
		numCards = std::move(_o.numCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Scanner::_PubDataType::clear()
{
	keepOrDiscard.clear();
	numCards = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Scanner::_PubDataType::equals(const _PubDataType& _o) const
{
	return keepOrDiscard.equals(_o.keepOrDiscard) &&
		numCards == _o.numCards;
}

const char *StormHHThin::invoke::Scanner::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("keepOrDiscard=");
		_buf.append(keepOrDiscard);
		_buf.append(',');
		_buf.append("numCards=");
		_buf.appendUint(numCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Scanner::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(keepOrDiscard);
		_msg0.composeBYTE(numCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Scanner::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(keepOrDiscard);
	_parser0.parseBYTE(numCards);
}

/*static*/ void StormHHThin::invoke::Scanner::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "keepOrDiscard"); size_t szKeepOrDiscard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "keepOrDiscard", szKeepOrDiscard, _checker, __FILE__, __LINE__);
	BYTE numCards; _parser0.parseBYTE(numCards);
	AtfValidator::validateInt(_descr, "numCards", numCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Scanner::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Scanner::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: cards(std::move(_o.cards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::invoke::Scanner::_PrivDataType& StormHHThin::invoke::Scanner::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Scanner::_PrivDataType::clear()
{
	cards.clear();
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Scanner::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return cards.equals(_o.cards);
}

const char *StormHHThin::invoke::Scanner::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cards=");
		_buf.append(cards);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Scanner::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(cards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Scanner::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cards);
}

/*static*/ void StormHHThin::invoke::Scanner::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cards"); size_t szCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::Scanner::Scanner()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Scanner::Scanner(Scanner&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::invoke::Scanner& StormHHThin::invoke::Scanner::operator=(Scanner&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Scanner::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Scanner::equals(const Scanner& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Scanner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Scanner::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Scanner::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Scanner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    MindControl
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::MindControl::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::MindControl::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::MindControl::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::MindControl::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::MindControl::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::MindControl::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::MindControl::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::MindControl::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::MindControl::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: stolenPowerId(std::move(_o.stolenPowerId))
	, powersLeft(std::move(_o.powersLeft))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::invoke::MindControl::_PrivDataType& StormHHThin::invoke::MindControl::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		stolenPowerId = std::move(_o.stolenPowerId);
		powersLeft = std::move(_o.powersLeft);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::invoke::MindControl::_PrivDataType::clear()
{
	stolenPowerId = 0;
	powersLeft.clear();
	_is_empty_internal = true;
}

bool StormHHThin::invoke::MindControl::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return stolenPowerId == _o.stolenPowerId &&
		powersLeft.equals(_o.powersLeft);
}

const char *StormHHThin::invoke::MindControl::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("stolenPowerId=");
		_buf.appendInt(stolenPowerId);
		_buf.append(',');
		_buf.append("powersLeft=");
		powersLeft.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::MindControl::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(stolenPowerId);
		powersLeft.composeMsg(_msg0);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::MindControl::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(stolenPowerId);
	powersLeft.parseMsg(_parser0);
}

/*static*/ void StormHHThin::invoke::MindControl::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 stolenPowerId; _parser0.parseINT32(stolenPowerId);
	AtfValidator::validateInt(_descr, "stolenPowerId", stolenPowerId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPowersLeft = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("powersLeft"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powersLeft", szPowersLeft, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::MindControl::MindControl()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::MindControl::MindControl(MindControl&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::invoke::MindControl& StormHHThin::invoke::MindControl::operator=(MindControl&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::invoke::MindControl::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::MindControl::equals(const MindControl& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::MindControl::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::MindControl::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::MindControl::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::MindControl::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Intel
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Intel::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Intel::_PubDataType::clear()
{
	numOfSensedNextCards = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Intel::_PubDataType::equals(const _PubDataType& _o) const
{
	return numOfSensedNextCards == _o.numOfSensedNextCards;
}

const char *StormHHThin::invoke::Intel::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numOfSensedNextCards=");
		_buf.appendInt(numOfSensedNextCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Intel::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numOfSensedNextCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Intel::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numOfSensedNextCards);
}

/*static*/ void StormHHThin::invoke::Intel::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numOfSensedNextCards; _parser0.parseINT32(numOfSensedNextCards);
	AtfValidator::validateInt(_descr, "numOfSensedNextCards", numOfSensedNextCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Intel::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Intel::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: sensedCards(std::move(_o.sensedCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::invoke::Intel::_PrivDataType& StormHHThin::invoke::Intel::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		sensedCards = std::move(_o.sensedCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Intel::_PrivDataType::clear()
{
	sensedCards.clear();
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Intel::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return sensedCards.equals(_o.sensedCards);
}

const char *StormHHThin::invoke::Intel::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("sensedCards=");
		_buf.append(sensedCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Intel::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(sensedCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Intel::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(sensedCards);
}

/*static*/ void StormHHThin::invoke::Intel::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "sensedCards"); size_t szSensedCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sensedCards", szSensedCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::Intel::Intel()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Intel::Intel(Intel&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::invoke::Intel& StormHHThin::invoke::Intel::operator=(Intel&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Intel::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Intel::equals(const Intel& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Intel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Intel::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Intel::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Intel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Pacify
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Pacify::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Pacify::_PubDataType::clear()
{
	cardUnfreezePossible = false;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Pacify::_PubDataType::equals(const _PubDataType& _o) const
{
	return cardUnfreezePossible == _o.cardUnfreezePossible;
}

const char *StormHHThin::invoke::Pacify::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cardUnfreezePossible=");
		_buf.appendUint(cardUnfreezePossible);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Pacify::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(cardUnfreezePossible);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Pacify::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(cardUnfreezePossible);
}

/*static*/ void StormHHThin::invoke::Pacify::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool cardUnfreezePossible; _parser0.parseBOOL(cardUnfreezePossible);
	AtfValidator::validateInt(_descr, "cardUnfreezePossible", cardUnfreezePossible, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Pacify::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Pacify::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Pacify::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Pacify::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Pacify::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Pacify::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Pacify::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Pacify::Pacify()
{
	clear();
}

void StormHHThin::invoke::Pacify::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Pacify::equals(const Pacify& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Pacify::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Pacify::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Pacify::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Pacify::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Reload
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Reload::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Reload::_PubDataType::clear()
{
	numCards = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Reload::_PubDataType::equals(const _PubDataType& _o) const
{
	return numCards == _o.numCards;
}

const char *StormHHThin::invoke::Reload::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numCards=");
		_buf.appendInt(numCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Reload::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Reload::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numCards);
}

/*static*/ void StormHHThin::invoke::Reload::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numCards; _parser0.parseINT32(numCards);
	AtfValidator::validateInt(_descr, "numCards", numCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Reload::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Reload::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Reload::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Reload::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Reload::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Reload::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Reload::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Reload::Reload()
{
	clear();
}

void StormHHThin::invoke::Reload::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Reload::equals(const Reload& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Reload::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Reload::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Reload::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Reload::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Chaos
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Chaos::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Chaos::_PubDataType::clear()
{
	numBombs = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Chaos::_PubDataType::equals(const _PubDataType& _o) const
{
	return numBombs == _o.numBombs;
}

const char *StormHHThin::invoke::Chaos::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numBombs=");
		_buf.appendInt(numBombs);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Chaos::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numBombs);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Chaos::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numBombs);
}

/*static*/ void StormHHThin::invoke::Chaos::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numBombs; _parser0.parseINT32(numBombs);
	AtfValidator::validateInt(_descr, "numBombs", numBombs, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Chaos::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Chaos::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Chaos::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Chaos::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Chaos::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Chaos::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Chaos::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Chaos::Chaos()
{
	clear();
}

void StormHHThin::invoke::Chaos::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Chaos::equals(const Chaos& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Chaos::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Chaos::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Chaos::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Chaos::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Mint
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Mint::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Mint::_PubDataType::clear()
{
	chipsMinted = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Mint::_PubDataType::equals(const _PubDataType& _o) const
{
	return chipsMinted == _o.chipsMinted;
}

const char *StormHHThin::invoke::Mint::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("chipsMinted=");
		_buf.appendInt64(chipsMinted);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Mint::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(chipsMinted);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Mint::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(chipsMinted);
}

/*static*/ void StormHHThin::invoke::Mint::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 chipsMinted; _parser0.parseINT64(chipsMinted);
	AtfValidator::validateInt(_descr, "chipsMinted", chipsMinted, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Mint::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Mint::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Mint::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Mint::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Mint::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Mint::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Mint::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Mint::Mint()
{
	clear();
}

void StormHHThin::invoke::Mint::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Mint::equals(const Mint& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Mint::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Mint::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Mint::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Mint::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Swap
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Swap::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Swap::_PubDataType::_PubDataType(_PubDataType&& _o)
	: holeCard(std::move(_o.holeCard))
	, boardCard(std::move(_o.boardCard))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::invoke::Swap::_PubDataType& StormHHThin::invoke::Swap::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		holeCard = std::move(_o.holeCard);
		boardCard = std::move(_o.boardCard);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Swap::_PubDataType::clear()
{
	holeCard.clear();
	boardCard.clear();
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Swap::_PubDataType::equals(const _PubDataType& _o) const
{
	return holeCard.equals(_o.holeCard) &&
		boardCard.equals(_o.boardCard);
}

const char *StormHHThin::invoke::Swap::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("holeCard=");
		_buf.append(holeCard);
		_buf.append(',');
		_buf.append("boardCard=");
		_buf.append(boardCard);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Swap::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(holeCard);
		_msg0.composeString(boardCard);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Swap::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(holeCard);
	_parser0.parseStringP(boardCard);
}

/*static*/ void StormHHThin::invoke::Swap::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "holeCard"); size_t szHoleCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "holeCard", szHoleCard, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "boardCard"); size_t szBoardCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "boardCard", szBoardCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Swap::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Swap::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Swap::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Swap::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Swap::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Swap::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Swap::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Swap::Swap()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Swap::Swap(Swap&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::invoke::Swap& StormHHThin::invoke::Swap::operator=(Swap&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Swap::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Swap::equals(const Swap& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Swap::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Swap::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Swap::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Swap::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Engineer
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Engineer::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Engineer::_PubDataType::_PubDataType(_PubDataType&& _o)
	: chosenCard(std::move(_o.chosenCard))
	, discardedCards(std::move(_o.discardedCards))
	, cardsCandidate(std::move(_o.cardsCandidate))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::invoke::Engineer::_PubDataType& StormHHThin::invoke::Engineer::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		chosenCard = std::move(_o.chosenCard);
		discardedCards = std::move(_o.discardedCards);
		cardsCandidate = std::move(_o.cardsCandidate);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Engineer::_PubDataType::clear()
{
	chosenCard.clear();
	discardedCards.clear();
	cardsCandidate.clear();
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Engineer::_PubDataType::equals(const _PubDataType& _o) const
{
	return chosenCard.equals(_o.chosenCard) &&
		discardedCards.equals(_o.discardedCards) &&
		cardsCandidate.equals(_o.cardsCandidate);
}

const char *StormHHThin::invoke::Engineer::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("chosenCard=");
		_buf.append(chosenCard);
		_buf.append(',');
		_buf.append("discardedCards=");
		_buf.append(discardedCards);
		_buf.append(',');
		_buf.append("cardsCandidate=");
		_buf.append(cardsCandidate);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Engineer::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(chosenCard);
		_msg0.composeString(discardedCards);
		_msg0.composeString(cardsCandidate);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Engineer::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(chosenCard);
	_parser0.parseStringP(discardedCards);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(cardsCandidate);
}

/*static*/ void StormHHThin::invoke::Engineer::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "chosenCard"); size_t szChosenCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "chosenCard", szChosenCard, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "discardedCards"); size_t szDiscardedCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "discardedCards", szDiscardedCards, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "cardsCandidate"); size_t szCardsCandidate = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cardsCandidate", szCardsCandidate, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Engineer::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Engineer::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Engineer::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Engineer::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Engineer::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Engineer::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Engineer::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Engineer::Engineer()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Engineer::Engineer(Engineer&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::invoke::Engineer& StormHHThin::invoke::Engineer::operator=(Engineer&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Engineer::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Engineer::equals(const Engineer& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Engineer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Engineer::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Engineer::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Engineer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Reboot
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Reboot::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Reboot::_PubDataType::clear()
{
	numPowersDrawn = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Reboot::_PubDataType::equals(const _PubDataType& _o) const
{
	return numPowersDrawn == _o.numPowersDrawn;
}

const char *StormHHThin::invoke::Reboot::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numPowersDrawn=");
		_buf.appendInt(numPowersDrawn);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Reboot::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numPowersDrawn);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Reboot::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numPowersDrawn);
}

/*static*/ void StormHHThin::invoke::Reboot::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numPowersDrawn; _parser0.parseINT32(numPowersDrawn);
	AtfValidator::validateInt(_descr, "numPowersDrawn", numPowersDrawn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Reboot::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Reboot::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Reboot::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Reboot::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Reboot::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Reboot::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Reboot::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Reboot::Reboot()
{
	clear();
}

void StormHHThin::invoke::Reboot::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Reboot::equals(const Reboot& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Reboot::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Reboot::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Reboot::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Reboot::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Equalizer
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Equalizer::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Equalizer::_PubDataType::clear()
{
	manaCopied = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Equalizer::_PubDataType::equals(const _PubDataType& _o) const
{
	return manaCopied == _o.manaCopied;
}

const char *StormHHThin::invoke::Equalizer::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("manaCopied=");
		_buf.appendInt64(manaCopied);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Equalizer::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(manaCopied);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Equalizer::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(manaCopied);
}

/*static*/ void StormHHThin::invoke::Equalizer::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 manaCopied; _parser0.parseINT64(manaCopied);
	AtfValidator::validateInt(_descr, "manaCopied", manaCopied, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Equalizer::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Equalizer::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Equalizer::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Equalizer::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Equalizer::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Equalizer::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Equalizer::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Equalizer::Equalizer()
{
	clear();
}

void StormHHThin::invoke::Equalizer::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Equalizer::equals(const Equalizer& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Equalizer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Equalizer::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Equalizer::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Equalizer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Freeze
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Freeze::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Freeze::_PubDataType::_PubDataType(_PubDataType&& _o)
	: frozenCards(std::move(_o.frozenCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::invoke::Freeze::_PubDataType& StormHHThin::invoke::Freeze::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		frozenCards = std::move(_o.frozenCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Freeze::_PubDataType::clear()
{
	frozenCards.clear();
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Freeze::_PubDataType::equals(const _PubDataType& _o) const
{
	return frozenCards.equals(_o.frozenCards);
}

const char *StormHHThin::invoke::Freeze::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("frozenCards=");
		_buf.append(frozenCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Freeze::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(frozenCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Freeze::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(frozenCards);
}

/*static*/ void StormHHThin::invoke::Freeze::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "frozenCards"); size_t szFrozenCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "frozenCards", szFrozenCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Freeze::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Freeze::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Freeze::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Freeze::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Freeze::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Freeze::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Freeze::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Freeze::Freeze()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Freeze::Freeze(Freeze&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::invoke::Freeze& StormHHThin::invoke::Freeze::operator=(Freeze&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Freeze::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Freeze::equals(const Freeze& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Freeze::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Freeze::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Freeze::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Freeze::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Syphon
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Syphon::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Syphon::_PubDataType::_PubDataType(_PubDataType&& _o)
	: manaStolen(std::move(_o.manaStolen))
	, targetPlayer(std::move(_o.targetPlayer))
	, targetUserId(std::move(_o.targetUserId))
	, manaReceived(std::move(_o.manaReceived))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::invoke::Syphon::_PubDataType& StormHHThin::invoke::Syphon::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		manaStolen = std::move(_o.manaStolen);
		targetPlayer = std::move(_o.targetPlayer);
		targetUserId = std::move(_o.targetUserId);
		manaReceived = std::move(_o.manaReceived);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Syphon::_PubDataType::clear()
{
	manaStolen = 0;
	targetPlayer = 0;
	targetUserId.clear();
	manaReceived = -1;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Syphon::_PubDataType::equals(const _PubDataType& _o) const
{
	return manaStolen == _o.manaStolen &&
		targetPlayer == _o.targetPlayer &&
		targetUserId.equals(_o.targetUserId) &&
		manaReceived == _o.manaReceived;
}

const char *StormHHThin::invoke::Syphon::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("manaStolen=");
		_buf.appendInt64(manaStolen);
		_buf.append(',');
		_buf.append("targetPlayer=");
		_buf.appendInt(targetPlayer);
		_buf.append(',');
		_buf.append("targetUserId=");
		_buf.append(targetUserId);
		_buf.append(',');
		_buf.append("manaReceived=");
		_buf.appendInt64(manaReceived);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Syphon::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(manaStolen);
		_msg0.composeINT8(targetPlayer);
		_msg0.composeString(targetUserId);
		_msg0.composeINT64(manaReceived);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Syphon::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(manaStolen);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT8(targetPlayer);
	_parser0.parseStringP(targetUserId);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(manaReceived);
}

/*static*/ void StormHHThin::invoke::Syphon::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	INT64 manaStolen; _parser0.parseINT64(manaStolen);
	AtfValidator::validateInt(_descr, "manaStolen", manaStolen, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT8 targetPlayer; _parser0.parseINT8(targetPlayer);
	AtfValidator::validateInt(_descr, "targetPlayer", targetPlayer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "targetUserId"); size_t szTargetUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetUserId", szTargetUserId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT64 manaReceived; _parser0.parseINT64(manaReceived);
	AtfValidator::validateInt(_descr, "manaReceived", manaReceived, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Syphon::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Syphon::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Syphon::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::Syphon::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Syphon::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Syphon::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::Syphon::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::Syphon::Syphon()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::invoke::Syphon::Syphon(Syphon&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::invoke::Syphon& StormHHThin::invoke::Syphon::operator=(Syphon&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::invoke::Syphon::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Syphon::equals(const Syphon& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Syphon::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Syphon::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Syphon::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Syphon::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    AnteUp
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::AnteUp::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::AnteUp::_PubDataType::clear()
{
	ante = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::AnteUp::_PubDataType::equals(const _PubDataType& _o) const
{
	return ante == _o.ante;
}

const char *StormHHThin::invoke::AnteUp::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("ante=");
		_buf.appendInt64(ante);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::AnteUp::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(ante);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::AnteUp::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(ante);
}

/*static*/ void StormHHThin::invoke::AnteUp::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 ante; _parser0.parseINT64(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::AnteUp::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::AnteUp::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::invoke::AnteUp::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::invoke::AnteUp::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::AnteUp::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::AnteUp::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::invoke::AnteUp::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::invoke::AnteUp::AnteUp()
{
	clear();
}

void StormHHThin::invoke::AnteUp::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::AnteUp::equals(const AnteUp& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::AnteUp::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::AnteUp::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::AnteUp::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::AnteUp::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    CounterSpell
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::CounterSpell::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::CounterSpell::_PubDataType::clear()
{
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::CounterSpell::_PubDataType::equals(const _PubDataType& _o) const
{
	return isRevealStage == _o.isRevealStage;
}

const char *StormHHThin::invoke::CounterSpell::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::CounterSpell::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::CounterSpell::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isRevealStage);
}

/*static*/ void StormHHThin::invoke::CounterSpell::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::CounterSpell::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::CounterSpell::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	destroyedPowerId = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::CounterSpell::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId &&
		destroyedPowerId == _o.destroyedPowerId;
}

const char *StormHHThin::invoke::CounterSpell::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
		_buf.append(',');
		_buf.append("destroyedPowerId=");
		_buf.appendInt(destroyedPowerId);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::CounterSpell::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
		_msg0.composeINT32(destroyedPowerId);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::CounterSpell::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
	_parser0.parseINT32(destroyedPowerId);
}

/*static*/ void StormHHThin::invoke::CounterSpell::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	INT32 destroyedPowerId; _parser0.parseINT32(destroyedPowerId);
	AtfValidator::validateInt(_descr, "destroyedPowerId", destroyedPowerId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::CounterSpell::CounterSpell()
{
	clear();
}

void StormHHThin::invoke::CounterSpell::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::CounterSpell::equals(const CounterSpell& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::CounterSpell::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::CounterSpell::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::CounterSpell::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::CounterSpell::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Lowblow
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Lowblow::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Lowblow::_PubDataType::clear()
{
	isSecretPlay = false;
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Lowblow::_PubDataType::equals(const _PubDataType& _o) const
{
	return isSecretPlay == _o.isSecretPlay &&
		isRevealStage == _o.isRevealStage;
}

const char *StormHHThin::invoke::Lowblow::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isSecretPlay=");
		_buf.appendUint(isSecretPlay);
		_buf.append(',');
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Lowblow::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isSecretPlay);
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Lowblow::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isSecretPlay);
	_parser0.parseBOOL(isRevealStage);
}

/*static*/ void StormHHThin::invoke::Lowblow::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isSecretPlay; _parser0.parseBOOL(isSecretPlay);
	AtfValidator::validateInt(_descr, "isSecretPlay", isSecretPlay, _checker, __FILE__, __LINE__);
	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Lowblow::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Lowblow::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Lowblow::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId;
}

const char *StormHHThin::invoke::Lowblow::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Lowblow::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Lowblow::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
}

/*static*/ void StormHHThin::invoke::Lowblow::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::Lowblow::Lowblow()
{
	clear();
}

void StormHHThin::invoke::Lowblow::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Lowblow::equals(const Lowblow& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Lowblow::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Lowblow::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Lowblow::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Lowblow::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Stretch
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Stretch::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Stretch::_PubDataType::clear()
{
	isSecretPlay = false;
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Stretch::_PubDataType::equals(const _PubDataType& _o) const
{
	return isSecretPlay == _o.isSecretPlay &&
		isRevealStage == _o.isRevealStage;
}

const char *StormHHThin::invoke::Stretch::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isSecretPlay=");
		_buf.appendUint(isSecretPlay);
		_buf.append(',');
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Stretch::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isSecretPlay);
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Stretch::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isSecretPlay);
	_parser0.parseBOOL(isRevealStage);
}

/*static*/ void StormHHThin::invoke::Stretch::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isSecretPlay; _parser0.parseBOOL(isSecretPlay);
	AtfValidator::validateInt(_descr, "isSecretPlay", isSecretPlay, _checker, __FILE__, __LINE__);
	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Stretch::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Stretch::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Stretch::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId;
}

const char *StormHHThin::invoke::Stretch::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Stretch::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Stretch::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
}

/*static*/ void StormHHThin::invoke::Stretch::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::Stretch::Stretch()
{
	clear();
}

void StormHHThin::invoke::Stretch::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Stretch::equals(const Stretch& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Stretch::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Stretch::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Stretch::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Stretch::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    SuitUp
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::SuitUp::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::SuitUp::_PubDataType::clear()
{
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::SuitUp::_PubDataType::equals(const _PubDataType& _o) const
{
	return isRevealStage == _o.isRevealStage;
}

const char *StormHHThin::invoke::SuitUp::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::SuitUp::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::SuitUp::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isRevealStage);
}

/*static*/ void StormHHThin::invoke::SuitUp::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::SuitUp::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::SuitUp::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	suit = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::SuitUp::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId &&
		suit == _o.suit;
}

const char *StormHHThin::invoke::SuitUp::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
		_buf.append(',');
		_buf.append("suit=");
		_buf.appendUint(suit);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::SuitUp::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
		_msg0.composeBYTE(suit);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::SuitUp::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
	_parser0.parseBYTE(suit);
}

/*static*/ void StormHHThin::invoke::SuitUp::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::SuitUp::SuitUp()
{
	clear();
}

void StormHHThin::invoke::SuitUp::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::SuitUp::equals(const SuitUp& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::SuitUp::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::SuitUp::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::SuitUp::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::SuitUp::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    SplashPot
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::SplashPot::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::SplashPot::_PubDataType::clear()
{
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::SplashPot::_PubDataType::equals(const _PubDataType& _o) const
{
	return isRevealStage == _o.isRevealStage;
}

const char *StormHHThin::invoke::SplashPot::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::SplashPot::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::SplashPot::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isRevealStage);
}

/*static*/ void StormHHThin::invoke::SplashPot::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::SplashPot::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::SplashPot::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	splashSize = 0;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::SplashPot::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId &&
		splashSize == _o.splashSize;
}

const char *StormHHThin::invoke::SplashPot::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
		_buf.append(',');
		_buf.append("splashSize=");
		_buf.appendInt64(splashSize);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::SplashPot::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
		_msg0.composeINT64(splashSize);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::SplashPot::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
	_parser0.parseINT64(splashSize);
}

/*static*/ void StormHHThin::invoke::SplashPot::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	INT64 splashSize; _parser0.parseINT64(splashSize);
	AtfValidator::validateInt(_descr, "splashSize", splashSize, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::SplashPot::SplashPot()
{
	clear();
}

void StormHHThin::invoke::SplashPot::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::SplashPot::equals(const SplashPot& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::SplashPot::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::SplashPot::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::SplashPot::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::SplashPot::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Sabotage
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::invoke::Sabotage::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::invoke::Sabotage::_PubDataType::clear()
{
	isRevealStage = false;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Sabotage::_PubDataType::equals(const _PubDataType& _o) const
{
	return isRevealStage == _o.isRevealStage;
}

const char *StormHHThin::invoke::Sabotage::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isRevealStage=");
		_buf.appendUint(isRevealStage);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Sabotage::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isRevealStage);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Sabotage::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isRevealStage);
}

/*static*/ void StormHHThin::invoke::Sabotage::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isRevealStage; _parser0.parseBOOL(isRevealStage);
	AtfValidator::validateInt(_descr, "isRevealStage", isRevealStage, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::invoke::Sabotage::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::invoke::Sabotage::_PrivDataType::clear()
{
	mySecretPowerId = PokerGamePowerSecretPlaceholder;
	destroyedPowerId = 0;
	hitPayment = 0;
	isManaHit = false;
	_is_empty_internal = true;
}

bool StormHHThin::invoke::Sabotage::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return mySecretPowerId == _o.mySecretPowerId &&
		destroyedPowerId == _o.destroyedPowerId &&
		hitPayment == _o.hitPayment &&
		isManaHit == _o.isManaHit;
}

const char *StormHHThin::invoke::Sabotage::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("mySecretPowerId=");
		_buf.appendInt(mySecretPowerId);
		_buf.append(',');
		_buf.append("destroyedPowerId=");
		_buf.appendInt(destroyedPowerId);
		_buf.append(',');
		_buf.append("hitPayment=");
		_buf.appendInt64(hitPayment);
		_buf.append(',');
		_buf.append("isManaHit=");
		_buf.appendUint(isManaHit);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Sabotage::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(mySecretPowerId);
		_msg0.composeINT32(destroyedPowerId);
		_msg0.composeINT64(hitPayment);
		_msg0.composeBOOL(isManaHit);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::invoke::Sabotage::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(mySecretPowerId);
	_parser0.parseINT32(destroyedPowerId);
	_parser0.parseINT64(hitPayment);
	_parser0.parseBOOL(isManaHit);
}

/*static*/ void StormHHThin::invoke::Sabotage::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 mySecretPowerId; _parser0.parseINT32(mySecretPowerId);
	AtfValidator::validateInt(_descr, "mySecretPowerId", mySecretPowerId, _checker, __FILE__, __LINE__);
	INT32 destroyedPowerId; _parser0.parseINT32(destroyedPowerId);
	AtfValidator::validateInt(_descr, "destroyedPowerId", destroyedPowerId, _checker, __FILE__, __LINE__);
	INT64 hitPayment; _parser0.parseINT64(hitPayment);
	AtfValidator::validateInt(_descr, "hitPayment", hitPayment, _checker, __FILE__, __LINE__);
	bool isManaHit; _parser0.parseBOOL(isManaHit);
	AtfValidator::validateInt(_descr, "isManaHit", isManaHit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::invoke::Sabotage::Sabotage()
{
	clear();
}

void StormHHThin::invoke::Sabotage::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::invoke::Sabotage::equals(const Sabotage& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::invoke::Sabotage::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::invoke::Sabotage::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::invoke::Sabotage::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::invoke::Sabotage::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    Header
//=================================================================

StormHHThin::effect::Header::Header()
{
	clear();
}

void StormHHThin::effect::Header::clear()
{
	powerId = 0;
	exposePrivacy = false;
	powerCardUniqueId = 0;
}

bool StormHHThin::effect::Header::equals(const Header& _o) const
{
	return powerId == _o.powerId &&
		exposePrivacy == _o.exposePrivacy &&
		powerCardUniqueId == _o.powerCardUniqueId;
}

const char *StormHHThin::effect::Header::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("powerId=");
	_buf.appendInt(powerId);
	_buf.append(',');
	_buf.append("exposePrivacy=");
	_buf.appendUint(exposePrivacy);
	_buf.append(',');
	_buf.append("powerCardUniqueId=");
	_buf.appendInt(powerCardUniqueId);
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::Header::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(Header())) // not empty
	{
		_body.composeINT32(powerId);
		_body.composeBOOL(exposePrivacy);
		_body.composeINT32(powerCardUniqueId);
	}

	_msg.composeMsgBody(_body);
}

void StormHHThin::effect::Header::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(powerId);
	_parser0.parseBOOL(exposePrivacy);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(powerCardUniqueId);
}

/*static*/ void StormHHThin::effect::Header::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 powerId; _parser0.parseINT32(powerId);
	AtfValidator::validateInt(_descr, "powerId", powerId, _checker, __FILE__, __LINE__);
	bool exposePrivacy; _parser0.parseBOOL(exposePrivacy);
	AtfValidator::validateInt(_descr, "exposePrivacy", exposePrivacy, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 powerCardUniqueId; _parser0.parseINT32(powerCardUniqueId);
	AtfValidator::validateInt(_descr, "powerCardUniqueId", powerCardUniqueId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    BaseData
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::BaseData::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::BaseData::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::BaseData::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::BaseData::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::BaseData::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::BaseData::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::BaseData::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::BaseData::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::BaseData::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::BaseData::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::BaseData::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::BaseData::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::BaseData::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::BaseData::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::BaseData::BaseData()
{
	clear();
}

void StormHHThin::effect::BaseData::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::BaseData::equals(const BaseData& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::BaseData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::BaseData::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::BaseData::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::BaseData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    PubClientExtraMsg
//=================================================================

StormHHThin::effect::PubClientExtraMsg::PubClientExtraMsg()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::PubClientExtraMsg::PubClientExtraMsg(PubClientExtraMsg&& _o)
	: hasPrivateDataInSeparateMsg(std::move(_o.hasPrivateDataInSeparateMsg))
	, privateMessageSeatMask(std::move(_o.privateMessageSeatMask))
{
}

StormHHThin::effect::PubClientExtraMsg& StormHHThin::effect::PubClientExtraMsg::operator=(PubClientExtraMsg&& _o)
{
	if(this != &_o)
	{
		hasPrivateDataInSeparateMsg = std::move(_o.hasPrivateDataInSeparateMsg);
		privateMessageSeatMask = std::move(_o.privateMessageSeatMask);
	}
	return *this;
}

#endif

void StormHHThin::effect::PubClientExtraMsg::clear()
{
	hasPrivateDataInSeparateMsg = false;
	privateMessageSeatMask = 0;
}

bool StormHHThin::effect::PubClientExtraMsg::equals(const PubClientExtraMsg& _o) const
{
	return hasPrivateDataInSeparateMsg == _o.hasPrivateDataInSeparateMsg &&
		privateMessageSeatMask == _o.privateMessageSeatMask;
}

const char *StormHHThin::effect::PubClientExtraMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("hasPrivateDataInSeparateMsg=");
	_buf.appendUint(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_buf.append(',');
		_buf.append("privateMessageSeatMask=");
		_buf.appendInt(privateMessageSeatMask);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::PubClientExtraMsg::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_msg.composeINT16(privateMessageSeatMask);
	}
}

void StormHHThin::effect::PubClientExtraMsg::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(hasPrivateDataInSeparateMsg);
	if(hasPrivateDataInSeparateMsg)
	{
		_parser.parseINT16(privateMessageSeatMask);
	}
}

/*static*/ void StormHHThin::effect::PubClientExtraMsg::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool hasPrivateDataInSeparateMsg = false;
	_parser.parseBOOL(hasPrivateDataInSeparateMsg);
	AtfValidator::validateInt(_descr, "hasPrivateDataInSeparateMsg", hasPrivateDataInSeparateMsg, _checker, __FILE__, __LINE__);
	if(hasPrivateDataInSeparateMsg)
	{
		INT16 privateMessageSeatMask; _parser.parseINT16(privateMessageSeatMask);
		AtfValidator::validateInt(_descr, "privateMessageSeatMask", privateMessageSeatMask, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    DarkBetCall
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::DarkBetCall::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::DarkBetCall::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::DarkBetCall::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::DarkBetCall::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::DarkBetCall::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::DarkBetCall::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::DarkBetCall::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::DarkBetCall::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::DarkBetCall::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::DarkBetCall::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::DarkBetCall::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::DarkBetCall::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::DarkBetCall::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::DarkBetCall::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::DarkBetCall::DarkBetCall()
{
	clear();
}

void StormHHThin::effect::DarkBetCall::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::DarkBetCall::equals(const DarkBetCall& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::DarkBetCall::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::DarkBetCall::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::DarkBetCall::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::DarkBetCall::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    DarkBetEnd
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::DarkBetEnd::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::DarkBetEnd::_PubDataType::clear()
{
	amount = 0;
	_is_empty_internal = true;
}

bool StormHHThin::effect::DarkBetEnd::_PubDataType::equals(const _PubDataType& _o) const
{
	return amount == _o.amount;
}

const char *StormHHThin::effect::DarkBetEnd::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("amount=");
		_buf.appendInt64(amount);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::DarkBetEnd::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(amount);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::DarkBetEnd::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(amount);
}

/*static*/ void StormHHThin::effect::DarkBetEnd::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::DarkBetEnd::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::DarkBetEnd::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::DarkBetEnd::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::DarkBetEnd::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::DarkBetEnd::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::DarkBetEnd::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::DarkBetEnd::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::DarkBetEnd::DarkBetEnd()
{
	clear();
}

void StormHHThin::effect::DarkBetEnd::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::DarkBetEnd::equals(const DarkBetEnd& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::DarkBetEnd::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::DarkBetEnd::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::DarkBetEnd::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::DarkBetEnd::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    AllInFreeze
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::AllInFreeze::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::AllInFreeze::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::AllInFreeze::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::AllInFreeze::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::AllInFreeze::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::AllInFreeze::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::AllInFreeze::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::AllInFreeze::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::AllInFreeze::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::AllInFreeze::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::AllInFreeze::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::AllInFreeze::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::AllInFreeze::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::AllInFreeze::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::AllInFreeze::AllInFreeze()
{
	clear();
}

void StormHHThin::effect::AllInFreeze::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::AllInFreeze::equals(const AllInFreeze& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::AllInFreeze::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::AllInFreeze::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::AllInFreeze::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::AllInFreeze::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ReplaceBoardCard
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::ReplaceBoardCard::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ReplaceBoardCard::_PubDataType::_PubDataType(_PubDataType&& _o)
	: oldCard(std::move(_o.oldCard))
	, newCard(std::move(_o.newCard))
	, suit(std::move(_o.suit))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::ReplaceBoardCard::_PubDataType& StormHHThin::effect::ReplaceBoardCard::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		oldCard = std::move(_o.oldCard);
		newCard = std::move(_o.newCard);
		suit = std::move(_o.suit);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::ReplaceBoardCard::_PubDataType::clear()
{
	oldCard.clear();
	newCard.clear();
	suit = 0;
	_is_empty_internal = true;
}

bool StormHHThin::effect::ReplaceBoardCard::_PubDataType::equals(const _PubDataType& _o) const
{
	return oldCard.equals(_o.oldCard) &&
		newCard.equals(_o.newCard) &&
		suit == _o.suit;
}

const char *StormHHThin::effect::ReplaceBoardCard::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("oldCard=");
		_buf.append(oldCard);
		_buf.append(',');
		_buf.append("newCard=");
		_buf.append(newCard);
		_buf.append(',');
		_buf.append("suit=");
		_buf.appendUint(suit);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReplaceBoardCard::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(oldCard);
		_msg0.composeString(newCard);
		_msg0.composeBYTE(suit);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ReplaceBoardCard::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(oldCard);
	_parser0.parseStringP(newCard);
	_parser0.parseBYTE(suit);
}

/*static*/ void StormHHThin::effect::ReplaceBoardCard::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "oldCard"); size_t szOldCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "oldCard", szOldCard, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "newCard"); size_t szNewCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "newCard", szNewCard, _checker, __FILE__, __LINE__);
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::ReplaceBoardCard::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::ReplaceBoardCard::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::ReplaceBoardCard::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::ReplaceBoardCard::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReplaceBoardCard::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ReplaceBoardCard::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::ReplaceBoardCard::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::ReplaceBoardCard::ReplaceBoardCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ReplaceBoardCard::ReplaceBoardCard(ReplaceBoardCard&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::ReplaceBoardCard& StormHHThin::effect::ReplaceBoardCard::operator=(ReplaceBoardCard&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::ReplaceBoardCard::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::ReplaceBoardCard::equals(const ReplaceBoardCard& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::ReplaceBoardCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReplaceBoardCard::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::ReplaceBoardCard::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::ReplaceBoardCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ReplaceMultiBoardCards
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType::_PubDataType(_PubDataType&& _o)
	: oldCards(std::move(_o.oldCards))
	, newCards(std::move(_o.newCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType& StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		oldCards = std::move(_o.oldCards);
		newCards = std::move(_o.newCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType::clear()
{
	oldCards.clear();
	newCards.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType::equals(const _PubDataType& _o) const
{
	return oldCards.equals(_o.oldCards) &&
		newCards.equals(_o.newCards);
}

const char *StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("oldCards=");
		oldCards.toTraceString(_buf);
		_buf.append(',');
		_buf.append("newCards=");
		newCards.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		oldCards.composeMsg(_msg0);
		newCards.composeMsg(_msg0);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	oldCards.parseMsg(_parser0);
	newCards.parseMsg(_parser0);
}

/*static*/ void StormHHThin::effect::ReplaceMultiBoardCards::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	int szOldCards = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("oldCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "oldCards", szOldCards, _checker, __FILE__, __LINE__);
	int szNewCards = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("newCards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "newCards", szNewCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::ReplaceMultiBoardCards::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::ReplaceMultiBoardCards::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::ReplaceMultiBoardCards::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::ReplaceMultiBoardCards::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReplaceMultiBoardCards::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ReplaceMultiBoardCards::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::ReplaceMultiBoardCards::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::ReplaceMultiBoardCards::ReplaceMultiBoardCards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ReplaceMultiBoardCards::ReplaceMultiBoardCards(ReplaceMultiBoardCards&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::ReplaceMultiBoardCards& StormHHThin::effect::ReplaceMultiBoardCards::operator=(ReplaceMultiBoardCards&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::ReplaceMultiBoardCards::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::ReplaceMultiBoardCards::equals(const ReplaceMultiBoardCards& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::ReplaceMultiBoardCards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReplaceMultiBoardCards::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::ReplaceMultiBoardCards::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::ReplaceMultiBoardCards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    AddBoardCard
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::AddBoardCard::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::AddBoardCard::_PubDataType::_PubDataType(_PubDataType&& _o)
	: card(std::move(_o.card))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::AddBoardCard::_PubDataType& StormHHThin::effect::AddBoardCard::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		card = std::move(_o.card);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::AddBoardCard::_PubDataType::clear()
{
	card.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::AddBoardCard::_PubDataType::equals(const _PubDataType& _o) const
{
	return card.equals(_o.card);
}

const char *StormHHThin::effect::AddBoardCard::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("card=");
		_buf.append(card);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::AddBoardCard::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(card);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::AddBoardCard::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(card);
}

/*static*/ void StormHHThin::effect::AddBoardCard::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "card"); size_t szCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "card", szCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::AddBoardCard::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::AddBoardCard::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::AddBoardCard::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::AddBoardCard::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::AddBoardCard::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::AddBoardCard::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::AddBoardCard::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::AddBoardCard::AddBoardCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::AddBoardCard::AddBoardCard(AddBoardCard&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::AddBoardCard& StormHHThin::effect::AddBoardCard::operator=(AddBoardCard&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::AddBoardCard::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::AddBoardCard::equals(const AddBoardCard& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::AddBoardCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::AddBoardCard::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::AddBoardCard::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::AddBoardCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    GetFreeChips
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::GetFreeChips::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::GetFreeChips::_PubDataType::clear()
{
	freeChipsReceived = 0;
	_is_empty_internal = true;
}

bool StormHHThin::effect::GetFreeChips::_PubDataType::equals(const _PubDataType& _o) const
{
	return freeChipsReceived == _o.freeChipsReceived;
}

const char *StormHHThin::effect::GetFreeChips::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("freeChipsReceived=");
		_buf.appendInt64(freeChipsReceived);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::GetFreeChips::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(freeChipsReceived);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::GetFreeChips::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(freeChipsReceived);
}

/*static*/ void StormHHThin::effect::GetFreeChips::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 freeChipsReceived; _parser0.parseINT64(freeChipsReceived);
	AtfValidator::validateInt(_descr, "freeChipsReceived", freeChipsReceived, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::GetFreeChips::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::GetFreeChips::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::GetFreeChips::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::GetFreeChips::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::GetFreeChips::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::GetFreeChips::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::GetFreeChips::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::GetFreeChips::GetFreeChips()
{
	clear();
}

void StormHHThin::effect::GetFreeChips::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::GetFreeChips::equals(const GetFreeChips& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::GetFreeChips::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::GetFreeChips::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::GetFreeChips::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::GetFreeChips::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    CarryOverChipsToNextHand
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::CarryOverChipsToNextHand::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::CarryOverChipsToNextHand::_PubDataType::clear()
{
	chipsCarriedOver = 0;
	_is_empty_internal = true;
}

bool StormHHThin::effect::CarryOverChipsToNextHand::_PubDataType::equals(const _PubDataType& _o) const
{
	return chipsCarriedOver == _o.chipsCarriedOver;
}

const char *StormHHThin::effect::CarryOverChipsToNextHand::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("chipsCarriedOver=");
		_buf.appendInt64(chipsCarriedOver);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::CarryOverChipsToNextHand::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT64(chipsCarriedOver);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::CarryOverChipsToNextHand::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT64(chipsCarriedOver);
}

/*static*/ void StormHHThin::effect::CarryOverChipsToNextHand::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT64 chipsCarriedOver; _parser0.parseINT64(chipsCarriedOver);
	AtfValidator::validateInt(_descr, "chipsCarriedOver", chipsCarriedOver, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::CarryOverChipsToNextHand::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::CarryOverChipsToNextHand::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::CarryOverChipsToNextHand::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::CarryOverChipsToNextHand::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::CarryOverChipsToNextHand::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::CarryOverChipsToNextHand::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::CarryOverChipsToNextHand::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::CarryOverChipsToNextHand::CarryOverChipsToNextHand()
{
	clear();
}

void StormHHThin::effect::CarryOverChipsToNextHand::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::CarryOverChipsToNextHand::equals(const CarryOverChipsToNextHand& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::CarryOverChipsToNextHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::CarryOverChipsToNextHand::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::CarryOverChipsToNextHand::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::CarryOverChipsToNextHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    FrozenCardHit
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::FrozenCardHit::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::FrozenCardHit::_PubDataType::_PubDataType(_PubDataType&& _o)
	: card(std::move(_o.card))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::FrozenCardHit::_PubDataType& StormHHThin::effect::FrozenCardHit::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		card = std::move(_o.card);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::FrozenCardHit::_PubDataType::clear()
{
	card.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::FrozenCardHit::_PubDataType::equals(const _PubDataType& _o) const
{
	return card.equals(_o.card);
}

const char *StormHHThin::effect::FrozenCardHit::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("card=");
		_buf.append(card);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::FrozenCardHit::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(card);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::FrozenCardHit::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(card);
}

/*static*/ void StormHHThin::effect::FrozenCardHit::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "card"); size_t szCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "card", szCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::FrozenCardHit::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::FrozenCardHit::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::FrozenCardHit::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::FrozenCardHit::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::FrozenCardHit::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::FrozenCardHit::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::FrozenCardHit::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::FrozenCardHit::FrozenCardHit()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::FrozenCardHit::FrozenCardHit(FrozenCardHit&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::FrozenCardHit& StormHHThin::effect::FrozenCardHit::operator=(FrozenCardHit&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::FrozenCardHit::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::FrozenCardHit::equals(const FrozenCardHit& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::FrozenCardHit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::FrozenCardHit::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::FrozenCardHit::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::FrozenCardHit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ShowOneHoleCard
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::ShowOneHoleCard::_PubDataType::_PubDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ShowOneHoleCard::_PubDataType::_PubDataType(_PubDataType&& _o)
	: card(std::move(_o.card))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::ShowOneHoleCard::_PubDataType& StormHHThin::effect::ShowOneHoleCard::_PubDataType::operator=(_PubDataType&& _o)
{
	if(this != &_o)
	{
		card = std::move(_o.card);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::ShowOneHoleCard::_PubDataType::clear()
{
	card.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::ShowOneHoleCard::_PubDataType::equals(const _PubDataType& _o) const
{
	return card.equals(_o.card);
}

const char *StormHHThin::effect::ShowOneHoleCard::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("card=");
		_buf.append(card);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ShowOneHoleCard::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(card);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ShowOneHoleCard::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(card);
}

/*static*/ void StormHHThin::effect::ShowOneHoleCard::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "card"); size_t szCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "card", szCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::ShowOneHoleCard::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::ShowOneHoleCard::_PrivDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::ShowOneHoleCard::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::ShowOneHoleCard::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ShowOneHoleCard::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ShowOneHoleCard::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::ShowOneHoleCard::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

StormHHThin::effect::ShowOneHoleCard::ShowOneHoleCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ShowOneHoleCard::ShowOneHoleCard(ShowOneHoleCard&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::ShowOneHoleCard& StormHHThin::effect::ShowOneHoleCard::operator=(ShowOneHoleCard&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::ShowOneHoleCard::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::ShowOneHoleCard::equals(const ShowOneHoleCard& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::ShowOneHoleCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ShowOneHoleCard::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::ShowOneHoleCard::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::ShowOneHoleCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ReplaceHoleCard
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::ReplaceHoleCard::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::ReplaceHoleCard::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::ReplaceHoleCard::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::ReplaceHoleCard::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReplaceHoleCard::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ReplaceHoleCard::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::ReplaceHoleCard::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::ReplaceHoleCard::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ReplaceHoleCard::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: oldCard(std::move(_o.oldCard))
	, newCard(std::move(_o.newCard))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::ReplaceHoleCard::_PrivDataType& StormHHThin::effect::ReplaceHoleCard::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		oldCard = std::move(_o.oldCard);
		newCard = std::move(_o.newCard);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::ReplaceHoleCard::_PrivDataType::clear()
{
	oldCard.clear();
	newCard.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::ReplaceHoleCard::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return oldCard.equals(_o.oldCard) &&
		newCard.equals(_o.newCard);
}

const char *StormHHThin::effect::ReplaceHoleCard::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("oldCard=");
		_buf.append(oldCard);
		_buf.append(',');
		_buf.append("newCard=");
		_buf.append(newCard);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReplaceHoleCard::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(oldCard);
		_msg0.composeString(newCard);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ReplaceHoleCard::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(oldCard);
	_parser0.parseStringP(newCard);
}

/*static*/ void StormHHThin::effect::ReplaceHoleCard::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "oldCard"); size_t szOldCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "oldCard", szOldCard, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "newCard"); size_t szNewCard = strlen(_dummy);
	AtfValidator::validateInt(_descr, "newCard", szNewCard, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::effect::ReplaceHoleCard::ReplaceHoleCard()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ReplaceHoleCard::ReplaceHoleCard(ReplaceHoleCard&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::ReplaceHoleCard& StormHHThin::effect::ReplaceHoleCard::operator=(ReplaceHoleCard&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::ReplaceHoleCard::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::ReplaceHoleCard::equals(const ReplaceHoleCard& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::ReplaceHoleCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReplaceHoleCard::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::ReplaceHoleCard::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::ReplaceHoleCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ReceiveHoleCards
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::ReceiveHoleCards::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::ReceiveHoleCards::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::ReceiveHoleCards::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::ReceiveHoleCards::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReceiveHoleCards::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ReceiveHoleCards::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::ReceiveHoleCards::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::ReceiveHoleCards::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ReceiveHoleCards::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: cards(std::move(_o.cards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::ReceiveHoleCards::_PrivDataType& StormHHThin::effect::ReceiveHoleCards::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::ReceiveHoleCards::_PrivDataType::clear()
{
	cards.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::ReceiveHoleCards::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return cards.equals(_o.cards);
}

const char *StormHHThin::effect::ReceiveHoleCards::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cards=");
		_buf.append(cards);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReceiveHoleCards::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(cards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ReceiveHoleCards::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cards);
}

/*static*/ void StormHHThin::effect::ReceiveHoleCards::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cards"); size_t szCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::effect::ReceiveHoleCards::ReceiveHoleCards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::ReceiveHoleCards::ReceiveHoleCards(ReceiveHoleCards&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::ReceiveHoleCards& StormHHThin::effect::ReceiveHoleCards::operator=(ReceiveHoleCards&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::ReceiveHoleCards::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::ReceiveHoleCards::equals(const ReceiveHoleCards& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::ReceiveHoleCards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ReceiveHoleCards::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::ReceiveHoleCards::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::ReceiveHoleCards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    DiscardHoleCards
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::DiscardHoleCards::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::DiscardHoleCards::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::DiscardHoleCards::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::DiscardHoleCards::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::DiscardHoleCards::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::DiscardHoleCards::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::DiscardHoleCards::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::DiscardHoleCards::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::DiscardHoleCards::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: cards(std::move(_o.cards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::DiscardHoleCards::_PrivDataType& StormHHThin::effect::DiscardHoleCards::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::DiscardHoleCards::_PrivDataType::clear()
{
	cards.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::DiscardHoleCards::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return cards.equals(_o.cards);
}

const char *StormHHThin::effect::DiscardHoleCards::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("cards=");
		_buf.append(cards);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::DiscardHoleCards::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(cards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::DiscardHoleCards::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(cards);
}

/*static*/ void StormHHThin::effect::DiscardHoleCards::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "cards"); size_t szCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::effect::DiscardHoleCards::DiscardHoleCards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::DiscardHoleCards::DiscardHoleCards(DiscardHoleCards&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::DiscardHoleCards& StormHHThin::effect::DiscardHoleCards::operator=(DiscardHoleCards&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::DiscardHoleCards::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::DiscardHoleCards::equals(const DiscardHoleCards& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::DiscardHoleCards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::DiscardHoleCards::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::DiscardHoleCards::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::DiscardHoleCards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    RebootEffect
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::RebootEffect::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::RebootEffect::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::RebootEffect::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::RebootEffect::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::RebootEffect::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::RebootEffect::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::RebootEffect::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::RebootEffect::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::RebootEffect::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: discardedPowers(std::move(_o.discardedPowers))
	, reloadedPowers(std::move(_o.reloadedPowers))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::RebootEffect::_PrivDataType& StormHHThin::effect::RebootEffect::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		discardedPowers = std::move(_o.discardedPowers);
		reloadedPowers = std::move(_o.reloadedPowers);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::RebootEffect::_PrivDataType::clear()
{
	discardedPowers.clear();
	reloadedPowers.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::RebootEffect::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return discardedPowers.equals(_o.discardedPowers) &&
		reloadedPowers.equals(_o.reloadedPowers);
}

const char *StormHHThin::effect::RebootEffect::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("discardedPowers=");
		discardedPowers.toTraceString(_buf);
		_buf.append(',');
		_buf.append("reloadedPowers=");
		reloadedPowers.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::RebootEffect::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		discardedPowers.composeMsg(_msg0);
		reloadedPowers.composeMsg(_msg0);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::RebootEffect::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	discardedPowers.parseMsg(_parser0);
	reloadedPowers.parseMsg(_parser0);
}

/*static*/ void StormHHThin::effect::RebootEffect::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	int szDiscardedPowers = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("discardedPowers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "discardedPowers", szDiscardedPowers, _checker, __FILE__, __LINE__);
	int szReloadedPowers = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("reloadedPowers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "reloadedPowers", szReloadedPowers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::effect::RebootEffect::RebootEffect()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::RebootEffect::RebootEffect(RebootEffect&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::RebootEffect& StormHHThin::effect::RebootEffect::operator=(RebootEffect&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::RebootEffect::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::RebootEffect::equals(const RebootEffect& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::RebootEffect::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::RebootEffect::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::RebootEffect::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::RebootEffect::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    IntelEffect
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::IntelEffect::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::IntelEffect::_PubDataType::clear()
{
	numCardsSensed = 0;
	_is_empty_internal = true;
}

bool StormHHThin::effect::IntelEffect::_PubDataType::equals(const _PubDataType& _o) const
{
	return numCardsSensed == _o.numCardsSensed;
}

const char *StormHHThin::effect::IntelEffect::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numCardsSensed=");
		_buf.appendInt(numCardsSensed);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::IntelEffect::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numCardsSensed);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::IntelEffect::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numCardsSensed);
}

/*static*/ void StormHHThin::effect::IntelEffect::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numCardsSensed; _parser0.parseINT32(numCardsSensed);
	AtfValidator::validateInt(_descr, "numCardsSensed", numCardsSensed, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::IntelEffect::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::IntelEffect::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: sensedCards(std::move(_o.sensedCards))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::IntelEffect::_PrivDataType& StormHHThin::effect::IntelEffect::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		sensedCards = std::move(_o.sensedCards);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::IntelEffect::_PrivDataType::clear()
{
	sensedCards.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::IntelEffect::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return sensedCards.equals(_o.sensedCards);
}

const char *StormHHThin::effect::IntelEffect::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("sensedCards=");
		_buf.append(sensedCards);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::IntelEffect::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeString(sensedCards);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::IntelEffect::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(sensedCards);
}

/*static*/ void StormHHThin::effect::IntelEffect::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "sensedCards"); size_t szSensedCards = strlen(_dummy);
	AtfValidator::validateInt(_descr, "sensedCards", szSensedCards, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::effect::IntelEffect::IntelEffect()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::IntelEffect::IntelEffect(IntelEffect&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::IntelEffect& StormHHThin::effect::IntelEffect::operator=(IntelEffect&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::IntelEffect::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::IntelEffect::equals(const IntelEffect& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::IntelEffect::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::IntelEffect::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::IntelEffect::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::IntelEffect::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    ExchangePowerEffect
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::ExchangePowerEffect::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::ExchangePowerEffect::_PubDataType::clear()
{
	_is_empty_internal = true;
}

bool StormHHThin::effect::ExchangePowerEffect::_PubDataType::equals(const _PubDataType& _o) const
{
	return true;
}

const char *StormHHThin::effect::ExchangePowerEffect::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ExchangePowerEffect::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ExchangePowerEffect::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}
}

/*static*/ void StormHHThin::effect::ExchangePowerEffect::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::ExchangePowerEffect::_PrivDataType::_PrivDataType()
{
	clear();
}

void StormHHThin::effect::ExchangePowerEffect::_PrivDataType::clear()
{
	isAdded = false;
	changedPowerId = 0;
	_is_empty_internal = true;
}

bool StormHHThin::effect::ExchangePowerEffect::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return isAdded == _o.isAdded &&
		changedPowerId == _o.changedPowerId;
}

const char *StormHHThin::effect::ExchangePowerEffect::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("isAdded=");
		_buf.appendUint(isAdded);
		_buf.append(',');
		_buf.append("changedPowerId=");
		_buf.appendInt(changedPowerId);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ExchangePowerEffect::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeBOOL(isAdded);
		_msg0.composeINT32(changedPowerId);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::ExchangePowerEffect::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isAdded);
	_parser0.parseINT32(changedPowerId);
}

/*static*/ void StormHHThin::effect::ExchangePowerEffect::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	bool isAdded; _parser0.parseBOOL(isAdded);
	AtfValidator::validateInt(_descr, "isAdded", isAdded, _checker, __FILE__, __LINE__);
	INT32 changedPowerId; _parser0.parseINT32(changedPowerId);
	AtfValidator::validateInt(_descr, "changedPowerId", changedPowerId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::effect::ExchangePowerEffect::ExchangePowerEffect()
{
	clear();
}

void StormHHThin::effect::ExchangePowerEffect::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::ExchangePowerEffect::equals(const ExchangePowerEffect& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::ExchangePowerEffect::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::ExchangePowerEffect::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::ExchangePowerEffect::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::ExchangePowerEffect::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

//=================================================================
//                    MindControlDrawNewPowersEffect
//=================================================================

//=================================================================
//                _PubDataType
//=================================================================

StormHHThin::effect::MindControlDrawNewPowersEffect::_PubDataType::_PubDataType()
{
	clear();
}

void StormHHThin::effect::MindControlDrawNewPowersEffect::_PubDataType::clear()
{
	numNewPowers = 0;
	_is_empty_internal = true;
}

bool StormHHThin::effect::MindControlDrawNewPowersEffect::_PubDataType::equals(const _PubDataType& _o) const
{
	return numNewPowers == _o.numNewPowers;
}

const char *StormHHThin::effect::MindControlDrawNewPowersEffect::_PubDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("numNewPowers=");
		_buf.appendInt(numNewPowers);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::MindControlDrawNewPowersEffect::_PubDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		_msg0.composeINT32(numNewPowers);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::MindControlDrawNewPowersEffect::_PubDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(numNewPowers);
}

/*static*/ void StormHHThin::effect::MindControlDrawNewPowersEffect::_PubDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	INT32 numNewPowers; _parser0.parseINT32(numNewPowers);
	AtfValidator::validateInt(_descr, "numNewPowers", numNewPowers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _PrivDataType
//=================================================================

StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType::_PrivDataType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType::_PrivDataType(_PrivDataType&& _o)
	: newPowerIds(std::move(_o.newPowerIds))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType& StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType::operator=(_PrivDataType&& _o)
{
	if(this != &_o)
	{
		newPowerIds = std::move(_o.newPowerIds);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType::clear()
{
	newPowerIds.clear();
	_is_empty_internal = true;
}

bool StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType::equals(const _PrivDataType& _o) const
{
	return newPowerIds.equals(_o.newPowerIds);
}

const char *StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("newPowerIds=");
		newPowerIds.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		newPowerIds.composeMsg(_msg0);
	}

	_msg.composeMsgBody(_msg0);
}

void StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	newPowerIds.parseMsg(_parser0);
}

/*static*/ void StormHHThin::effect::MindControlDrawNewPowersEffect::_PrivDataType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	int szNewPowerIds = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("newPowerIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "newPowerIds", szNewPowerIds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

StormHHThin::effect::MindControlDrawNewPowersEffect::MindControlDrawNewPowersEffect()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

StormHHThin::effect::MindControlDrawNewPowersEffect::MindControlDrawNewPowersEffect(MindControlDrawNewPowersEffect&& _o)
	: header(std::move(_o.header))
	, pubData(std::move(_o.pubData))
	, privData(std::move(_o.privData))
{
}

StormHHThin::effect::MindControlDrawNewPowersEffect& StormHHThin::effect::MindControlDrawNewPowersEffect::operator=(MindControlDrawNewPowersEffect&& _o)
{
	if(this != &_o)
	{
		header = std::move(_o.header);
		pubData = std::move(_o.pubData);
		privData = std::move(_o.privData);
	}
	return *this;
}

#endif

void StormHHThin::effect::MindControlDrawNewPowersEffect::clear()
{
	header.clear();
	pubData.clear();
	privData.clear();
}

bool StormHHThin::effect::MindControlDrawNewPowersEffect::equals(const MindControlDrawNewPowersEffect& _o) const
{
	return header.equals(_o.header) &&
		pubData.equals(_o.pubData) &&
		privData.equals(_o.privData);
}

const char *StormHHThin::effect::MindControlDrawNewPowersEffect::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("header=");
	header.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pubData=");
	pubData.toTraceString(_buf);
	if(header.exposePrivacy)
	{
		_buf.append(',');
		_buf.append("privData=");
		privData.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void StormHHThin::effect::MindControlDrawNewPowersEffect::composeMsg(CommMsgBody& _msg) const
{
	header.composeMsg(_msg);
	pubData.composeMsg(_msg);
	if(header.exposePrivacy)
	{
		privData.composeMsg(_msg);
	}
}

void StormHHThin::effect::MindControlDrawNewPowersEffect::parseMsg(CommMsgParser& _parser)
{
	header.parseMsg(_parser);
	pubData.parseMsg(_parser);
	if(header.exposePrivacy)
	{
		privData.parseMsg(_parser);
	}
}

/*static*/ void StormHHThin::effect::MindControlDrawNewPowersEffect::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Header header;
	header.parseMsg(_parser);
	PString _descbuf;
	_PubDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("pubData"), _fieldsWithUnparsedContent);
	if(header.exposePrivacy)
	{
		_PrivDataType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("privData"), _fieldsWithUnparsedContent);
	}
}

