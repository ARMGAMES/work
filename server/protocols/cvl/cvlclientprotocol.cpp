/**
 * cvlclientprotocol.cpp
 *
 * This file was auto-generated from cvlclientprotocol.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor cvlclientprotocol.txt
 */
 
#include "cvlclientprotocol.h"

//=================================================================
//                    ChestAsset
//=================================================================

// @Override
ChestAsset::ChestAsset( const INT32 id_, const INT32 type_,  const PString& uriHint_ )
{
	id		= id_;
	type	= type_;
	uriHint = uriHint_;
}

ChestAsset::ChestAsset()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ChestAsset::ChestAsset(ChestAsset&& _o)
	: id(std::move(_o.id))
	, type(std::move(_o.type))
	, uriHint(std::move(_o.uriHint))
{
}

ChestAsset& ChestAsset::operator=(ChestAsset&& _o)
{
	if(this != &_o)
	{
		id = std::move(_o.id);
		type = std::move(_o.type);
		uriHint = std::move(_o.uriHint);
	}
	return *this;
}

#endif

void ChestAsset::clear()
{
	id = 0;
	type = 0;
	uriHint.clear();
}

bool ChestAsset::equals(const ChestAsset& _o) const
{
	return id == _o.id &&
		type == _o.type &&
		Atf::atfPStringEquals(uriHint, _o.uriHint);
}

const char *ChestAsset::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendInt(id);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendInt(type);
	_buf.append(',');
	_buf.append("uriHint=");
	_buf.append(uriHint);
	_buf.append('}');
	return _buf.c_str();
}

const char *ChestAsset::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("uriHint", uriHint, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ChestAsset::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("type"))
		{
			type = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("uriHint"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, uriHint)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ChestAsset::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ChestAsset())) // not empty
	{
		_body.composeINT32(id);
		_body.composeINT32(type);
		_body.composeString(uriHint);
	}

	_msg.composeMsgBody(_body);
}

void ChestAsset::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(id);
	_parser0.parseINT32(type);
	_parser0.parseStringP(uriHint);
}

const char *ChestAsset::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("type", type);
	_jsonstr.compose("uriHint", uriHint);
	return _buf.c_str();
}

void ChestAsset::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("uriHint", uriHint);
}

/* static */ void ChestAsset::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	INT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	PString uriHint; _jparser.validateByNameThrow("uriHint", uriHint);
	AtfValidator::validateInt(_descr, "uriHint", uriHint.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void ChestAsset::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 id; _parser0.parseINT32(id);
	AtfValidator::validateInt(_descr, "id", id, _checker, __FILE__, __LINE__);
	INT32 type; _parser0.parseINT32(type);
	AtfValidator::validateInt(_descr, "type", type, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "uriHint"); size_t szUriHint = strlen(_dummy);
	AtfValidator::validateInt(_descr, "uriHint", szUriHint, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CvlConfigParams
//=================================================================

CvlConfigParams::CvlConfigParams()
{
	clear();
}

void CvlConfigParams::clear()
{
	stateFlags = 0;
	daysToExpire = 0;
	tierUpDays = 0;
	tierUpBars = 0;
	exchangePercent = 0;
	boostEnabled = false;
	currentBarDueTime = 0;
	recentBarCounter = 0;
	tierDownDays = 0;
	currentBarStartTime = 0;
	totalDoneBarCount = 0;
	preferredTimeZone = 0;
}

bool CvlConfigParams::equals(const CvlConfigParams& _o) const
{
	return stateFlags == _o.stateFlags &&
		daysToExpire == _o.daysToExpire &&
		tierUpDays == _o.tierUpDays &&
		tierUpBars == _o.tierUpBars &&
		exchangePercent == _o.exchangePercent &&
		boostEnabled == _o.boostEnabled &&
		currentBarDueTime == _o.currentBarDueTime &&
		recentBarCounter == _o.recentBarCounter &&
		tierDownDays == _o.tierDownDays &&
		currentBarStartTime == _o.currentBarStartTime &&
		totalDoneBarCount == _o.totalDoneBarCount &&
		preferredTimeZone == _o.preferredTimeZone;
}

const char *CvlConfigParams::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("stateFlags=");
	_buf.appendUint(stateFlags);
	_buf.append(',');
	_buf.append("daysToExpire=");
	_buf.appendInt(daysToExpire);
	_buf.append(',');
	_buf.append("tierUpDays=");
	_buf.appendInt(tierUpDays);
	_buf.append(',');
	_buf.append("tierUpBars=");
	_buf.appendInt(tierUpBars);
	_buf.append(',');
	_buf.append("exchangePercent=");
	_buf.appendInt(exchangePercent);
	_buf.append(',');
	_buf.append("boostEnabled=");
	_buf.appendUint(boostEnabled);
	_buf.append(',');
	_buf.append("currentBarDueTime=");
	_buf.appendUint(currentBarDueTime);
	_buf.append(',');
	_buf.append("recentBarCounter=");
	_buf.appendUint(recentBarCounter);
	_buf.append(',');
	_buf.append("tierDownDays=");
	_buf.appendInt(tierDownDays);
	_buf.append(',');
	_buf.append("currentBarStartTime=");
	_buf.appendUint(currentBarStartTime);
	_buf.append(',');
	_buf.append("totalDoneBarCount=");
	_buf.appendInt(totalDoneBarCount);
	_buf.append(',');
	_buf.append("preferredTimeZone=");
	_buf.appendInt(preferredTimeZone);
	_buf.append('}');
	return _buf.c_str();
}

const char *CvlConfigParams::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("stateFlags", stateFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("daysToExpire", daysToExpire, _buf);
	Atf::XmlElement::encodeAsXmlElement("tierUpDays", tierUpDays, _buf);
	Atf::XmlElement::encodeAsXmlElement("tierUpBars", tierUpBars, _buf);
	Atf::XmlElement::encodeAsXmlElement("exchangePercent", exchangePercent, _buf);
	Atf::XmlElement::encodeAsXmlElement("boostEnabled", boostEnabled, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentBarDueTime", currentBarDueTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("recentBarCounter", recentBarCounter, _buf);
	Atf::XmlElement::encodeAsXmlElement("tierDownDays", tierDownDays, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentBarStartTime", currentBarStartTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalDoneBarCount", totalDoneBarCount, _buf);
	Atf::XmlElement::encodeAsXmlElement("preferredTimeZone", preferredTimeZone, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CvlConfigParams::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("stateFlags"))
		{
			stateFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("daysToExpire"))
		{
			daysToExpire = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tierUpDays"))
		{
			tierUpDays = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tierUpBars"))
		{
			tierUpBars = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("exchangePercent"))
		{
			exchangePercent = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("boostEnabled"))
		{
			boostEnabled = (*_value.ptr() == '1');
		}
		else if (_element.equals("currentBarDueTime"))
		{
			currentBarDueTime = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("recentBarCounter"))
		{
			recentBarCounter = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tierDownDays"))
		{
			tierDownDays = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currentBarStartTime"))
		{
			currentBarStartTime = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalDoneBarCount"))
		{
			totalDoneBarCount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("preferredTimeZone"))
		{
			preferredTimeZone = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CvlConfigParams::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CvlConfigParams())) // not empty
	{
		_body.composeUINT32(stateFlags);
		_body.composeINT32(daysToExpire);
		_body.composeINT32(tierUpDays);
		_body.composeINT32(tierUpBars);
		_body.composeINT32(exchangePercent);
		_body.composeBOOL(boostEnabled);
		_body.composeUINT32(currentBarDueTime);
		_body.composeUINT32(recentBarCounter);
		_body.composeINT32(tierDownDays);
		_body.composeUINT32(currentBarStartTime);
		_body.composeINT32(totalDoneBarCount);
		_body.composeINT32(preferredTimeZone);
	}

	_msg.composeMsgBody(_body);
}

void CvlConfigParams::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(stateFlags);
	_parser0.parseINT32(daysToExpire);
	_parser0.parseINT32(tierUpDays);
	_parser0.parseINT32(tierUpBars);
	_parser0.parseINT32(exchangePercent);
	_parser0.parseBOOL(boostEnabled);
	_parser0.parseUINT32(currentBarDueTime);
	_parser0.parseUINT32(recentBarCounter);
	_parser0.parseINT32(tierDownDays);
	_parser0.parseUINT32(currentBarStartTime);
	_parser0.parseINT32(totalDoneBarCount);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(preferredTimeZone);
}

const char *CvlConfigParams::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("stateFlags", stateFlags);
	_jsonstr.compose("daysToExpire", daysToExpire);
	_jsonstr.compose("tierUpDays", tierUpDays);
	_jsonstr.compose("tierUpBars", tierUpBars);
	_jsonstr.compose("exchangePercent", exchangePercent);
	_jsonstr.compose("boostEnabled", boostEnabled);
	_jsonstr.compose("currentBarDueTime", currentBarDueTime);
	_jsonstr.compose("recentBarCounter", recentBarCounter);
	_jsonstr.compose("tierDownDays", tierDownDays);
	_jsonstr.compose("currentBarStartTime", currentBarStartTime);
	_jsonstr.compose("totalDoneBarCount", totalDoneBarCount);
	_jsonstr.compose("preferredTimeZone", preferredTimeZone);
	return _buf.c_str();
}

void CvlConfigParams::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stateFlags", stateFlags);
	_jparser.parseByNameThrow("daysToExpire", daysToExpire);
	_jparser.parseByNameThrow("tierUpDays", tierUpDays);
	_jparser.parseByNameThrow("tierUpBars", tierUpBars);
	_jparser.parseByNameThrow("exchangePercent", exchangePercent);
	_jparser.parseByNameThrow("boostEnabled", boostEnabled);
	_jparser.parseByNameThrow("currentBarDueTime", currentBarDueTime);
	_jparser.parseByNameThrow("recentBarCounter", recentBarCounter);
	_jparser.parseByNameThrow("tierDownDays", tierDownDays);
	_jparser.parseByNameThrow("currentBarStartTime", currentBarStartTime);
	_jparser.parseByNameThrow("totalDoneBarCount", totalDoneBarCount);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("preferredTimeZone", preferredTimeZone);
}

/* static */ void CvlConfigParams::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 stateFlags; _jparser.validateByNameThrow("stateFlags", stateFlags);
	AtfValidator::validateInt(_descr, "stateFlags", stateFlags, _checker, __FILE__, __LINE__);
	INT32 daysToExpire; _jparser.validateByNameThrow("daysToExpire", daysToExpire);
	AtfValidator::validateInt(_descr, "daysToExpire", daysToExpire, _checker, __FILE__, __LINE__);
	INT32 tierUpDays; _jparser.validateByNameThrow("tierUpDays", tierUpDays);
	AtfValidator::validateInt(_descr, "tierUpDays", tierUpDays, _checker, __FILE__, __LINE__);
	INT32 tierUpBars; _jparser.validateByNameThrow("tierUpBars", tierUpBars);
	AtfValidator::validateInt(_descr, "tierUpBars", tierUpBars, _checker, __FILE__, __LINE__);
	INT32 exchangePercent; _jparser.validateByNameThrow("exchangePercent", exchangePercent);
	AtfValidator::validateInt(_descr, "exchangePercent", exchangePercent, _checker, __FILE__, __LINE__);
	bool boostEnabled; _jparser.validateByNameThrow("boostEnabled", boostEnabled);
	AtfValidator::validateInt(_descr, "boostEnabled", boostEnabled, _checker, __FILE__, __LINE__);
	UINT32 currentBarDueTime; _jparser.validateByNameThrow("currentBarDueTime", currentBarDueTime);
	AtfValidator::validateInt(_descr, "currentBarDueTime", currentBarDueTime, _checker, __FILE__, __LINE__);
	UINT32 recentBarCounter; _jparser.validateByNameThrow("recentBarCounter", recentBarCounter);
	AtfValidator::validateInt(_descr, "recentBarCounter", recentBarCounter, _checker, __FILE__, __LINE__);
	INT32 tierDownDays; _jparser.validateByNameThrow("tierDownDays", tierDownDays);
	AtfValidator::validateInt(_descr, "tierDownDays", tierDownDays, _checker, __FILE__, __LINE__);
	UINT32 currentBarStartTime; _jparser.validateByNameThrow("currentBarStartTime", currentBarStartTime);
	AtfValidator::validateInt(_descr, "currentBarStartTime", currentBarStartTime, _checker, __FILE__, __LINE__);
	INT32 totalDoneBarCount; _jparser.validateByNameThrow("totalDoneBarCount", totalDoneBarCount);
	AtfValidator::validateInt(_descr, "totalDoneBarCount", totalDoneBarCount, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 preferredTimeZone; _jparser.validateByNameThrow("preferredTimeZone", preferredTimeZone);
	AtfValidator::validateInt(_descr, "preferredTimeZone", preferredTimeZone, _checker, __FILE__, __LINE__);
}

/*static*/ void CvlConfigParams::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 stateFlags; _parser0.parseUINT32(stateFlags);
	AtfValidator::validateInt(_descr, "stateFlags", stateFlags, _checker, __FILE__, __LINE__);
	INT32 daysToExpire; _parser0.parseINT32(daysToExpire);
	AtfValidator::validateInt(_descr, "daysToExpire", daysToExpire, _checker, __FILE__, __LINE__);
	INT32 tierUpDays; _parser0.parseINT32(tierUpDays);
	AtfValidator::validateInt(_descr, "tierUpDays", tierUpDays, _checker, __FILE__, __LINE__);
	INT32 tierUpBars; _parser0.parseINT32(tierUpBars);
	AtfValidator::validateInt(_descr, "tierUpBars", tierUpBars, _checker, __FILE__, __LINE__);
	INT32 exchangePercent; _parser0.parseINT32(exchangePercent);
	AtfValidator::validateInt(_descr, "exchangePercent", exchangePercent, _checker, __FILE__, __LINE__);
	bool boostEnabled; _parser0.parseBOOL(boostEnabled);
	AtfValidator::validateInt(_descr, "boostEnabled", boostEnabled, _checker, __FILE__, __LINE__);
	UINT32 currentBarDueTime; _parser0.parseUINT32(currentBarDueTime);
	AtfValidator::validateInt(_descr, "currentBarDueTime", currentBarDueTime, _checker, __FILE__, __LINE__);
	UINT32 recentBarCounter; _parser0.parseUINT32(recentBarCounter);
	AtfValidator::validateInt(_descr, "recentBarCounter", recentBarCounter, _checker, __FILE__, __LINE__);
	INT32 tierDownDays; _parser0.parseINT32(tierDownDays);
	AtfValidator::validateInt(_descr, "tierDownDays", tierDownDays, _checker, __FILE__, __LINE__);
	UINT32 currentBarStartTime; _parser0.parseUINT32(currentBarStartTime);
	AtfValidator::validateInt(_descr, "currentBarStartTime", currentBarStartTime, _checker, __FILE__, __LINE__);
	INT32 totalDoneBarCount; _parser0.parseINT32(totalDoneBarCount);
	AtfValidator::validateInt(_descr, "totalDoneBarCount", totalDoneBarCount, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 preferredTimeZone; _parser0.parseINT32(preferredTimeZone);
	AtfValidator::validateInt(_descr, "preferredTimeZone", preferredTimeZone, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CvlClientUserBar
//=================================================================

CvlClientUserBar::CvlClientUserBar()
{
	clear();
}

void CvlClientUserBar::clear()
{
	tierId = 0;
	flags = 0;
	currentBoostRemaining = 0;
	nextBoostTime = 0;
	barProgress = 0;
	barTarget = 0;
	doneBarCount = 0;
	tierUpEnd = 0;
	starCoinBalance = 0;
}

bool CvlClientUserBar::equals(const CvlClientUserBar& _o) const
{
	return tierId == _o.tierId &&
		flags == _o.flags &&
		currentBoostRemaining == _o.currentBoostRemaining &&
		nextBoostTime == _o.nextBoostTime &&
		barProgress == _o.barProgress &&
		barTarget == _o.barTarget &&
		doneBarCount == _o.doneBarCount &&
		tierUpEnd == _o.tierUpEnd &&
		starCoinBalance == _o.starCoinBalance;
}

const char *CvlClientUserBar::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tierId=");
	_buf.appendUint(tierId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("currentBoostRemaining=");
	_buf.appendInt(currentBoostRemaining);
	_buf.append(',');
	_buf.append("nextBoostTime=");
	_buf.appendUint(nextBoostTime);
	_buf.append(',');
	_buf.append("barProgress=");
	_buf.appendInt(barProgress);
	_buf.append(',');
	_buf.append("barTarget=");
	_buf.appendInt(barTarget);
	_buf.append(',');
	_buf.append("doneBarCount=");
	_buf.appendInt(doneBarCount);
	_buf.append(',');
	_buf.append("tierUpEnd=");
	_buf.appendUint(tierUpEnd);
	_buf.append(',');
	_buf.append("starCoinBalance=");
	_buf.appendInt(starCoinBalance);
	_buf.append('}');
	return _buf.c_str();
}

const char *CvlClientUserBar::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tierId", tierId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentBoostRemaining", currentBoostRemaining, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextBoostTime", nextBoostTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("barProgress", barProgress, _buf);
	Atf::XmlElement::encodeAsXmlElement("barTarget", barTarget, _buf);
	Atf::XmlElement::encodeAsXmlElement("doneBarCount", doneBarCount, _buf);
	Atf::XmlElement::encodeAsXmlElement("tierUpEnd", tierUpEnd, _buf);
	Atf::XmlElement::encodeAsXmlElement("starCoinBalance", starCoinBalance, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CvlClientUserBar::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tierId"))
		{
			tierId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currentBoostRemaining"))
		{
			currentBoostRemaining = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextBoostTime"))
		{
			nextBoostTime = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("barProgress"))
		{
			barProgress = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("barTarget"))
		{
			barTarget = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("doneBarCount"))
		{
			doneBarCount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tierUpEnd"))
		{
			tierUpEnd = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("starCoinBalance"))
		{
			starCoinBalance = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CvlClientUserBar::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CvlClientUserBar())) // not empty
	{
		_body.composeUINT32(tierId);
		_body.composeUINT32(flags);
		_body.composeINT32(currentBoostRemaining);
		_body.composeUINT32(nextBoostTime);
		_body.composeINT32(barProgress);
		_body.composeINT32(barTarget);
		_body.composeINT32(doneBarCount);
		_body.composeUINT32(tierUpEnd);
		_body.composeINT32(starCoinBalance);
	}

	_msg.composeMsgBody(_body);
}

void CvlClientUserBar::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tierId);
	_parser0.parseUINT32(flags);
	_parser0.parseINT32(currentBoostRemaining);
	_parser0.parseUINT32(nextBoostTime);
	_parser0.parseINT32(barProgress);
	_parser0.parseINT32(barTarget);
	_parser0.parseINT32(doneBarCount);
	_parser0.parseUINT32(tierUpEnd);
	_parser0.parseINT32(starCoinBalance);
}

const char *CvlClientUserBar::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tierId", tierId);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("currentBoostRemaining", currentBoostRemaining);
	_jsonstr.compose("nextBoostTime", nextBoostTime);
	_jsonstr.compose("barProgress", barProgress);
	_jsonstr.compose("barTarget", barTarget);
	_jsonstr.compose("doneBarCount", doneBarCount);
	_jsonstr.compose("tierUpEnd", tierUpEnd);
	_jsonstr.compose("starCoinBalance", starCoinBalance);
	return _buf.c_str();
}

void CvlClientUserBar::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tierId", tierId);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("currentBoostRemaining", currentBoostRemaining);
	_jparser.parseByNameThrow("nextBoostTime", nextBoostTime);
	_jparser.parseByNameThrow("barProgress", barProgress);
	_jparser.parseByNameThrow("barTarget", barTarget);
	_jparser.parseByNameThrow("doneBarCount", doneBarCount);
	_jparser.parseByNameThrow("tierUpEnd", tierUpEnd);
	_jparser.parseByNameThrow("starCoinBalance", starCoinBalance);
}

/* static */ void CvlClientUserBar::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tierId; _jparser.validateByNameThrow("tierId", tierId);
	AtfValidator::validateInt(_descr, "tierId", tierId, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	INT32 currentBoostRemaining; _jparser.validateByNameThrow("currentBoostRemaining", currentBoostRemaining);
	AtfValidator::validateInt(_descr, "currentBoostRemaining", currentBoostRemaining, _checker, __FILE__, __LINE__);
	UINT32 nextBoostTime; _jparser.validateByNameThrow("nextBoostTime", nextBoostTime);
	AtfValidator::validateInt(_descr, "nextBoostTime", nextBoostTime, _checker, __FILE__, __LINE__);
	INT32 barProgress; _jparser.validateByNameThrow("barProgress", barProgress);
	AtfValidator::validateInt(_descr, "barProgress", barProgress, _checker, __FILE__, __LINE__);
	INT32 barTarget; _jparser.validateByNameThrow("barTarget", barTarget);
	AtfValidator::validateInt(_descr, "barTarget", barTarget, _checker, __FILE__, __LINE__);
	INT32 doneBarCount; _jparser.validateByNameThrow("doneBarCount", doneBarCount);
	AtfValidator::validateInt(_descr, "doneBarCount", doneBarCount, _checker, __FILE__, __LINE__);
	UINT32 tierUpEnd; _jparser.validateByNameThrow("tierUpEnd", tierUpEnd);
	AtfValidator::validateInt(_descr, "tierUpEnd", tierUpEnd, _checker, __FILE__, __LINE__);
	INT32 starCoinBalance; _jparser.validateByNameThrow("starCoinBalance", starCoinBalance);
	AtfValidator::validateInt(_descr, "starCoinBalance", starCoinBalance, _checker, __FILE__, __LINE__);
}

/*static*/ void CvlClientUserBar::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 tierId; _parser0.parseUINT32(tierId);
	AtfValidator::validateInt(_descr, "tierId", tierId, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	INT32 currentBoostRemaining; _parser0.parseINT32(currentBoostRemaining);
	AtfValidator::validateInt(_descr, "currentBoostRemaining", currentBoostRemaining, _checker, __FILE__, __LINE__);
	UINT32 nextBoostTime; _parser0.parseUINT32(nextBoostTime);
	AtfValidator::validateInt(_descr, "nextBoostTime", nextBoostTime, _checker, __FILE__, __LINE__);
	INT32 barProgress; _parser0.parseINT32(barProgress);
	AtfValidator::validateInt(_descr, "barProgress", barProgress, _checker, __FILE__, __LINE__);
	INT32 barTarget; _parser0.parseINT32(barTarget);
	AtfValidator::validateInt(_descr, "barTarget", barTarget, _checker, __FILE__, __LINE__);
	INT32 doneBarCount; _parser0.parseINT32(doneBarCount);
	AtfValidator::validateInt(_descr, "doneBarCount", doneBarCount, _checker, __FILE__, __LINE__);
	UINT32 tierUpEnd; _parser0.parseUINT32(tierUpEnd);
	AtfValidator::validateInt(_descr, "tierUpEnd", tierUpEnd, _checker, __FILE__, __LINE__);
	INT32 starCoinBalance; _parser0.parseINT32(starCoinBalance);
	AtfValidator::validateInt(_descr, "starCoinBalance", starCoinBalance, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CvlClientUserBarNotification
//=================================================================

CvlClientUserBarNotification::CvlClientUserBarNotification()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CvlClientUserBarNotification::CvlClientUserBarNotification(CvlClientUserBarNotification&& _o)
	: properties(std::move(_o.properties))
{
}

CvlClientUserBarNotification& CvlClientUserBarNotification::operator=(CvlClientUserBarNotification&& _o)
{
	if(this != &_o)
	{
		properties = std::move(_o.properties);
	}
	return *this;
}

#endif

void CvlClientUserBarNotification::clear()
{
	properties.clear();
}

bool CvlClientUserBarNotification::equals(const CvlClientUserBarNotification& _o) const
{
	return properties.equals(_o.properties);
}

const char *CvlClientUserBarNotification::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("properties=");
	properties.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CvlClientUserBarNotification::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	properties.toXmlString("properties", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CvlClientUserBarNotification::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("properties"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CvlClientUserBar, 4 > >::FromXmlString(_value, properties)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CvlClientUserBarNotification::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CvlClientUserBarNotification())) // not empty
	{
		properties.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void CvlClientUserBarNotification::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	properties.parseMsg(_parser0);
}

const char *CvlClientUserBarNotification::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("properties", properties);
	return _buf.c_str();
}

void CvlClientUserBarNotification::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("properties", properties);
}

/* static */ void CvlClientUserBarNotification::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< CvlClientUserBar > properties; _jparser.validateByNameThrow("properties", properties);
	AtfValidator::validateInt(_descr, "properties", properties.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void CvlClientUserBarNotification::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szProperties = Atf::LAtfVector< CvlClientUserBar, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("properties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "properties", szProperties, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE
//=================================================================

Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE(Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE&& _o)
	: clientReqId(std::move(_o.clientReqId))
	, notify(std::move(_o.notify))
	, cvlConfig(std::move(_o.cvlConfig))
{
}

Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE& Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::operator=(Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE&& _o)
{
	if(this != &_o)
	{
		clientReqId = std::move(_o.clientReqId);
		notify = std::move(_o.notify);
		cvlConfig = std::move(_o.cvlConfig);
	}
	return *this;
}

#endif

void Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::clear()
{
	clientReqId = 0;
	notify.clear();
	cvlConfig.clear();
}

bool Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::equals(const Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE& _o) const
{
	return clientReqId == _o.clientReqId &&
		notify.equals(_o.notify) &&
		cvlConfig.equals(_o.cvlConfig);
}

bool Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE*)_other));
}

const char *Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE).append(")");
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("notify=");
	notify.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cvlConfig=");
	cvlConfig.toTraceString(_buf);
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	notify.toXmlString("notify", _buf);
	cvlConfig.toXmlString("cvlConfig", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notify"))
			{
				if(!Atf::AtfTempl< CvlClientUserBarNotification >::FromXmlString(_value, notify)) return false;
			}
			else if (_element.equals("cvlConfig"))
			{
				if(!Atf::AtfTempl< CvlConfigParams >::FromXmlString(_value, cvlConfig)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clientReqId);
	notify.composeMsg(_msg, _ignoreJSON);
	cvlConfig.composeMsg(_msg, _ignoreJSON);
}

void Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clientReqId);
	notify.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	cvlConfig.parseMsg(_parser);
}

const char *Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientReqId", clientReqId);
	_jsonstr.compose("notify", notify);
	_jsonstr.compose("cvlConfig", cvlConfig);
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientReqId", clientReqId);
	_jparser.parseByNameThrow("notify", notify);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cvlConfig", cvlConfig);
}

/*static*/ void Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	CvlClientUserBarNotification notify; _jparser.validateByNameThrow("notify", notify);
	if(_jparser.parseEnded()) return;
	CvlConfigParams cvlConfig; _jparser.validateByNameThrow("cvlConfig", cvlConfig);
}

/*static*/ void Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	CvlClientUserBarNotification::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("notify"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	CvlConfigParams::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cvlConfig"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER
//=================================================================

Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER()
{
	clear();
}

void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::clear()
{
}

bool Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::equals(const Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER& _o) const
{
	return true;
}

bool Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_CVL_STATE_FOR_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER*)_other));
}

const char *Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_CVL_STATE_FOR_USER).append(")");
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_CVL_STATE_FOR_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::parseMsg(CommMsgParser& _parser)
{
}

const char *Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_CVL_STATE_FOR_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_CVL_STATE_FOR_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY
//=================================================================

Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY(Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, bar(std::move(_o.bar))
	, cvlConfig(std::move(_o.cvlConfig))
{
}

Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY& Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		bar = std::move(_o.bar);
		cvlConfig = std::move(_o.cvlConfig);
	}
	return *this;
}

#endif

void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	bar.clear();
	cvlConfig.clear();
}

bool Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		bar.equals(_o.bar) &&
		cvlConfig.equals(_o.cvlConfig);
}

bool Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY*)_other));
}

const char *Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("bar=");
		bar.toTraceString(_buf);
		_buf.append(',');
		_buf.append("cvlConfig=");
		cvlConfig.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		bar.toXmlString("bar", _buf);
		cvlConfig.toXmlString("cvlConfig", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("bar"))
			{
				if(!Atf::AtfTempl< CvlClientUserBar >::FromXmlString(_value, bar)) return false;
			}
			else if (_element.equals("cvlConfig"))
			{
				if(!Atf::AtfTempl< CvlConfigParams >::FromXmlString(_value, cvlConfig)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		bar.composeMsg(_msg, _ignoreJSON);
		cvlConfig.composeMsg(_msg, _ignoreJSON);
	}
}

void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		bar.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		cvlConfig.parseMsg(_parser);
	}
}

const char *Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("bar", bar);
		_jsonstr.compose("cvlConfig", cvlConfig);
	}
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("bar", bar);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("cvlConfig", cvlConfig);
	}
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		CvlClientUserBar bar; _jparser.validateByNameThrow("bar", bar);
		if(_jparser.parseEnded()) return;
		CvlConfigParams cvlConfig; _jparser.validateByNameThrow("cvlConfig", cvlConfig);
	}
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		CvlClientUserBar::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bar"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		CvlConfigParams::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cvlConfig"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CVL_OPTED_IN
//=================================================================

Protocol_MSG_LOBBYETC_CVL_OPTED_IN::Protocol_MSG_LOBBYETC_CVL_OPTED_IN()
{
	clear();
}

void Protocol_MSG_LOBBYETC_CVL_OPTED_IN::clear()
{
	optedIn = false;
}

bool Protocol_MSG_LOBBYETC_CVL_OPTED_IN::equals(const Protocol_MSG_LOBBYETC_CVL_OPTED_IN& _o) const
{
	return optedIn == _o.optedIn;
}

bool Protocol_MSG_LOBBYETC_CVL_OPTED_IN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CVL_OPTED_IN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CVL_OPTED_IN*)_other));
}

const char *Protocol_MSG_LOBBYETC_CVL_OPTED_IN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CVL_OPTED_IN).append(")");
	_buf.append(',');
	_buf.append("optedIn=");
	_buf.appendUint(optedIn);
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_CVL_OPTED_IN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_CVL_OPTED_IN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CVL_OPTED_IN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("optedIn", optedIn, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_CVL_OPTED_IN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("optedIn"))
			{
				optedIn = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_CVL_OPTED_IN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(optedIn);
}

void Protocol_MSG_LOBBYETC_CVL_OPTED_IN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(optedIn);
}

const char *Protocol_MSG_LOBBYETC_CVL_OPTED_IN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("optedIn", optedIn);
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_CVL_OPTED_IN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("optedIn", optedIn);
}

/*static*/ void Protocol_MSG_LOBBYETC_CVL_OPTED_IN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CVL_OPTED_IN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool optedIn; _jparser.validateByNameThrow("optedIn", optedIn);
	AtfValidator::validateInt(_descr, "optedIn", optedIn, _checker, __FILE__, __LINE__);
}

/*static*/ void Protocol_MSG_LOBBYETC_CVL_OPTED_IN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CVL_OPTED_IN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool optedIn; _parser.parseBOOL(optedIn);
	AtfValidator::validateInt(_descr, "optedIn", optedIn, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY
//=================================================================

Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY(Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY& Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::operator=(Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::equals(const Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CVL_OPTED_IN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY*)_other));
}

const char *Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CVL_OPTED_IN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CVL_OPTED_IN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
}

void Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
}

const char *Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CVL_OPTED_IN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CVL_OPTED_IN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClientChestData
//=================================================================

ClientChestData::ClientChestData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ClientChestData::ClientChestData(ClientChestData&& _o)
	: logoName(std::move(_o.logoName))
	, availableUntil(std::move(_o.availableUntil))
	, skinType(std::move(_o.skinType))
	, chestText(std::move(_o.chestText))
	, chestDescription(std::move(_o.chestDescription))
	, chestId(std::move(_o.chestId))
	, lockType(std::move(_o.lockType))
	, icePromo(std::move(_o.icePromo))
	, customSkin(std::move(_o.customSkin))
	, assets(std::move(_o.assets))
{
}

ClientChestData& ClientChestData::operator=(ClientChestData&& _o)
{
	if(this != &_o)
	{
		logoName = std::move(_o.logoName);
		availableUntil = std::move(_o.availableUntil);
		skinType = std::move(_o.skinType);
		chestText = std::move(_o.chestText);
		chestDescription = std::move(_o.chestDescription);
		chestId = std::move(_o.chestId);
		lockType = std::move(_o.lockType);
		icePromo = std::move(_o.icePromo);
		customSkin = std::move(_o.customSkin);
		assets = std::move(_o.assets);
	}
	return *this;
}

#endif

void ClientChestData::clear()
{
	logoName.clear();
	availableUntil = 0;
	skinType = 0;
	chestText.clear();
	chestDescription.clear();
	chestId = 0;
	lockType = 0;
	icePromo.clear();
	customSkin.clear();
	assets.clear();
}

bool ClientChestData::equals(const ClientChestData& _o) const
{
	return Atf::atfPStringEquals(logoName, _o.logoName) &&
		availableUntil == _o.availableUntil &&
		skinType == _o.skinType &&
		Atf::atfPStringEquals(chestText, _o.chestText) &&
		Atf::atfPStringEquals(chestDescription, _o.chestDescription) &&
		chestId == _o.chestId &&
		lockType == _o.lockType &&
		Atf::atfPStringEquals(icePromo, _o.icePromo) &&
		Atf::atfPStringEquals(customSkin, _o.customSkin) &&
		assets.equals(_o.assets);
}

const char *ClientChestData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("logoName=");
	_buf.append(logoName);
	_buf.append(',');
	_buf.append("availableUntil=");
	_buf.appendUint(availableUntil);
	_buf.append(',');
	_buf.append("skinType=");
	_buf.appendUint(skinType);
	_buf.append(',');
	_buf.append("chestText=");
	_buf.append(chestText);
	_buf.append(',');
	_buf.append("chestDescription=");
	_buf.append(chestDescription);
	_buf.append(',');
	_buf.append("chestId=");
	_buf.appendUint64(chestId);
	_buf.append(',');
	_buf.append("lockType=");
	_buf.appendInt(lockType);
	_buf.append(',');
	_buf.append("icePromo=");
	_buf.append(icePromo);
	_buf.append(',');
	_buf.append("customSkin=");
	_buf.append(customSkin);
	_buf.append(',');
	_buf.append("assets=");
	assets.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *ClientChestData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("logoName", logoName, _buf);
	Atf::XmlElement::encodeAsXmlElement("availableUntil", availableUntil, _buf);
	Atf::XmlElement::encodeAsXmlElement("skinType", skinType, _buf);
	Atf::XmlElement::encodeAsXmlElement("chestText", chestText, _buf);
	Atf::XmlElement::encodeAsXmlElement("chestDescription", chestDescription, _buf);
	Atf::XmlElement::encodeAsXmlElement("chestId", chestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("lockType", lockType, _buf);
	Atf::XmlElement::encodeAsXmlElement("icePromo", icePromo, _buf);
	Atf::XmlElement::encodeAsXmlElement("customSkin", customSkin, _buf);
	assets.toXmlString("assets", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ClientChestData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("logoName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, logoName)) return false;
		}
		else if (_element.equals("availableUntil"))
		{
			availableUntil = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("skinType"))
		{
			skinType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chestText"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, chestText)) return false;
		}
		else if (_element.equals("chestDescription"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, chestDescription)) return false;
		}
		else if (_element.equals("chestId"))
		{
			chestId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lockType"))
		{
			lockType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("icePromo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, icePromo)) return false;
		}
		else if (_element.equals("customSkin"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, customSkin)) return false;
		}
		else if (_element.equals("assets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ChestAsset, 4 > >::FromXmlString(_value, assets)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ClientChestData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientChestData())) // not empty
	{
		_body.composeString(logoName);
		_body.composeUINT32(availableUntil);
		_body.composeBYTE(skinType);
		_body.composeString(chestText);
		_body.composeString(chestDescription);
		_body.composeUINT64(chestId);
		_body.composeINT32(lockType);
		_body.composeString(icePromo);
		_body.composeString(customSkin);
		assets.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void ClientChestData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(logoName);
	_parser0.parseUINT32(availableUntil);
	if(_parser0.parseEnded()) return;
	_parser0.parseBYTE(skinType);
	_parser0.parseStringP(chestText);
	_parser0.parseStringP(chestDescription);
	_parser0.parseUINT64(chestId);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(lockType);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(icePromo);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(customSkin);
	if(_parser0.parseEnded()) return;
	assets.parseMsg(_parser0);
}

const char *ClientChestData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("logoName", logoName);
	_jsonstr.compose("availableUntil", availableUntil);
	_jsonstr.compose("skinType", skinType);
	_jsonstr.compose("chestText", chestText);
	_jsonstr.compose("chestDescription", chestDescription);
	_jsonstr.compose("chestId", chestId);
	_jsonstr.compose("lockType", lockType);
	_jsonstr.compose("icePromo", icePromo);
	_jsonstr.compose("customSkin", customSkin);
	_jsonstr.compose("assets", assets);
	return _buf.c_str();
}

void ClientChestData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("logoName", logoName);
	_jparser.parseByNameThrow("availableUntil", availableUntil);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("skinType", skinType);
	_jparser.parseByNameThrow("chestText", chestText);
	_jparser.parseByNameThrow("chestDescription", chestDescription);
	_jparser.parseByNameThrow("chestId", chestId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("lockType", lockType);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("icePromo", icePromo);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("customSkin", customSkin);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("assets", assets);
}

/* static */ void ClientChestData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString logoName; _jparser.validateByNameThrow("logoName", logoName);
	AtfValidator::validateInt(_descr, "logoName", logoName.length(), _checker, __FILE__, __LINE__);
	UINT32 availableUntil; _jparser.validateByNameThrow("availableUntil", availableUntil);
	AtfValidator::validateInt(_descr, "availableUntil", availableUntil, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE skinType; _jparser.validateByNameThrow("skinType", skinType);
	AtfValidator::validateInt(_descr, "skinType", skinType, _checker, __FILE__, __LINE__);
	PString chestText; _jparser.validateByNameThrow("chestText", chestText);
	AtfValidator::validateInt(_descr, "chestText", chestText.length(), _checker, __FILE__, __LINE__);
	PString chestDescription; _jparser.validateByNameThrow("chestDescription", chestDescription);
	AtfValidator::validateInt(_descr, "chestDescription", chestDescription.length(), _checker, __FILE__, __LINE__);
	UINT64 chestId; _jparser.validateByNameThrow("chestId", chestId);
	AtfValidator::validateUint(_descr, "chestId", chestId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 lockType; _jparser.validateByNameThrow("lockType", lockType);
	AtfValidator::validateInt(_descr, "lockType", lockType, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString icePromo; _jparser.validateByNameThrow("icePromo", icePromo);
	AtfValidator::validateInt(_descr, "icePromo", icePromo.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString customSkin; _jparser.validateByNameThrow("customSkin", customSkin);
	AtfValidator::validateInt(_descr, "customSkin", customSkin.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< ChestAsset > assets; _jparser.validateByNameThrow("assets", assets);
	AtfValidator::validateInt(_descr, "assets", assets.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void ClientChestData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "logoName"); size_t szLogoName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "logoName", szLogoName, _checker, __FILE__, __LINE__);
	UINT32 availableUntil; _parser0.parseUINT32(availableUntil);
	AtfValidator::validateInt(_descr, "availableUntil", availableUntil, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	BYTE skinType; _parser0.parseBYTE(skinType);
	AtfValidator::validateInt(_descr, "skinType", skinType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "chestText"); size_t szChestText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "chestText", szChestText, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "chestDescription"); size_t szChestDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "chestDescription", szChestDescription, _checker, __FILE__, __LINE__);
	UINT64 chestId; _parser0.parseUINT64(chestId);
	AtfValidator::validateUint(_descr, "chestId", chestId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 lockType; _parser0.parseINT32(lockType);
	AtfValidator::validateInt(_descr, "lockType", lockType, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "icePromo"); size_t szIcePromo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "icePromo", szIcePromo, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "customSkin"); size_t szCustomSkin = strlen(_dummy);
	AtfValidator::validateInt(_descr, "customSkin", szCustomSkin, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szAssets = Atf::LAtfVector< ChestAsset, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("assets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "assets", szAssets, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED
//=================================================================

Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED(Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED&& _o)
	: clientReqId(std::move(_o.clientReqId))
	, isUserOptedIn(std::move(_o.isUserOptedIn))
	, chestCount(std::move(_o.chestCount))
	, chestToShow(std::move(_o.chestToShow))
	, lockedChestCount(std::move(_o.lockedChestCount))
	, lockedChestToShow(std::move(_o.lockedChestToShow))
	, stateFlags(std::move(_o.stateFlags))
{
}

Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED& Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::operator=(Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED&& _o)
{
	if(this != &_o)
	{
		clientReqId = std::move(_o.clientReqId);
		isUserOptedIn = std::move(_o.isUserOptedIn);
		chestCount = std::move(_o.chestCount);
		chestToShow = std::move(_o.chestToShow);
		lockedChestCount = std::move(_o.lockedChestCount);
		lockedChestToShow = std::move(_o.lockedChestToShow);
		stateFlags = std::move(_o.stateFlags);
	}
	return *this;
}

#endif

void Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::clear()
{
	clientReqId = 0;
	isUserOptedIn = false;
	chestCount = 0;
	chestToShow.clear();
	lockedChestCount = 0;
	lockedChestToShow.clear();
	stateFlags = 0;
}

bool Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::equals(const Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED& _o) const
{
	return clientReqId == _o.clientReqId &&
		isUserOptedIn == _o.isUserOptedIn &&
		chestCount == _o.chestCount &&
		chestToShow.equals(_o.chestToShow) &&
		lockedChestCount == _o.lockedChestCount &&
		lockedChestToShow.equals(_o.lockedChestToShow) &&
		stateFlags == _o.stateFlags;
}

bool Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED*)_other));
}

const char *Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED).append(")");
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("isUserOptedIn=");
	_buf.appendUint(isUserOptedIn);
	_buf.append(',');
	_buf.append("chestCount=");
	_buf.appendUint(chestCount);
	_buf.append(',');
	_buf.append("chestToShow=");
	chestToShow.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lockedChestCount=");
	_buf.appendUint(lockedChestCount);
	_buf.append(',');
	_buf.append("lockedChestToShow=");
	lockedChestToShow.toTraceString(_buf);
	_buf.append(',');
	_buf.append("stateFlags=");
	_buf.appendUint(stateFlags);
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isUserOptedIn", isUserOptedIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("chestCount", chestCount, _buf);
	chestToShow.toXmlString("chestToShow", _buf);
	Atf::XmlElement::encodeAsXmlElement("lockedChestCount", lockedChestCount, _buf);
	lockedChestToShow.toXmlString("lockedChestToShow", _buf);
	Atf::XmlElement::encodeAsXmlElement("stateFlags", stateFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isUserOptedIn"))
			{
				isUserOptedIn = (*_value.ptr() == '1');
			}
			else if (_element.equals("chestCount"))
			{
				chestCount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chestToShow"))
			{
				if(!Atf::AtfTempl< ClientChestData >::FromXmlString(_value, chestToShow)) return false;
			}
			else if (_element.equals("lockedChestCount"))
			{
				lockedChestCount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("lockedChestToShow"))
			{
				if(!Atf::AtfTempl< ClientChestData >::FromXmlString(_value, lockedChestToShow)) return false;
			}
			else if (_element.equals("stateFlags"))
			{
				stateFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clientReqId);
	_msg.composeBOOL(isUserOptedIn);
	_msg.composeUINT32(chestCount);
	chestToShow.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(lockedChestCount);
	lockedChestToShow.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(stateFlags);
}

void Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clientReqId);
	_parser.parseBOOL(isUserOptedIn);
	_parser.parseUINT32(chestCount);
	chestToShow.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(lockedChestCount);
	lockedChestToShow.parseMsg(_parser);
	_parser.parseUINT32(stateFlags);
}

const char *Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientReqId", clientReqId);
	_jsonstr.compose("isUserOptedIn", isUserOptedIn);
	_jsonstr.compose("chestCount", chestCount);
	_jsonstr.compose("chestToShow", chestToShow);
	_jsonstr.compose("lockedChestCount", lockedChestCount);
	_jsonstr.compose("lockedChestToShow", lockedChestToShow);
	_jsonstr.compose("stateFlags", stateFlags);
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientReqId", clientReqId);
	_jparser.parseByNameThrow("isUserOptedIn", isUserOptedIn);
	_jparser.parseByNameThrow("chestCount", chestCount);
	_jparser.parseByNameThrow("chestToShow", chestToShow);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("lockedChestCount", lockedChestCount);
	_jparser.parseByNameThrow("lockedChestToShow", lockedChestToShow);
	_jparser.parseByNameThrow("stateFlags", stateFlags);
}

/*static*/ void Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	bool isUserOptedIn; _jparser.validateByNameThrow("isUserOptedIn", isUserOptedIn);
	AtfValidator::validateInt(_descr, "isUserOptedIn", isUserOptedIn, _checker, __FILE__, __LINE__);
	UINT32 chestCount; _jparser.validateByNameThrow("chestCount", chestCount);
	AtfValidator::validateInt(_descr, "chestCount", chestCount, _checker, __FILE__, __LINE__);
	ClientChestData chestToShow; _jparser.validateByNameThrow("chestToShow", chestToShow);
	if(_jparser.parseEnded()) return;
	UINT32 lockedChestCount; _jparser.validateByNameThrow("lockedChestCount", lockedChestCount);
	AtfValidator::validateInt(_descr, "lockedChestCount", lockedChestCount, _checker, __FILE__, __LINE__);
	ClientChestData lockedChestToShow; _jparser.validateByNameThrow("lockedChestToShow", lockedChestToShow);
	UINT32 stateFlags; _jparser.validateByNameThrow("stateFlags", stateFlags);
	AtfValidator::validateInt(_descr, "stateFlags", stateFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	bool isUserOptedIn; _parser.parseBOOL(isUserOptedIn);
	AtfValidator::validateInt(_descr, "isUserOptedIn", isUserOptedIn, _checker, __FILE__, __LINE__);
	UINT32 chestCount; _parser.parseUINT32(chestCount);
	AtfValidator::validateInt(_descr, "chestCount", chestCount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ClientChestData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("chestToShow"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 lockedChestCount; _parser.parseUINT32(lockedChestCount);
	AtfValidator::validateInt(_descr, "lockedChestCount", lockedChestCount, _checker, __FILE__, __LINE__);
	ClientChestData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("lockedChestToShow"), _fieldsWithUnparsedContent);
	UINT32 stateFlags; _parser.parseUINT32(stateFlags);
	AtfValidator::validateInt(_descr, "stateFlags", stateFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClientChestDataEx
//=================================================================

ClientChestDataEx::ClientChestDataEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

ClientChestDataEx::ClientChestDataEx(ClientChestDataEx&& _o)
	: commonData(std::move(_o.commonData))
	, chestId(std::move(_o.chestId))
	, tierId(std::move(_o.tierId))
	, chestType(std::move(_o.chestType))
	, availableAfter(std::move(_o.availableAfter))
{
}

ClientChestDataEx& ClientChestDataEx::operator=(ClientChestDataEx&& _o)
{
	if(this != &_o)
	{
		commonData = std::move(_o.commonData);
		chestId = std::move(_o.chestId);
		tierId = std::move(_o.tierId);
		chestType = std::move(_o.chestType);
		availableAfter = std::move(_o.availableAfter);
	}
	return *this;
}

#endif

void ClientChestDataEx::clear()
{
	commonData.clear();
	chestId = 0;
	tierId = 0;
	chestType = 0;
	availableAfter = 0;
}

bool ClientChestDataEx::equals(const ClientChestDataEx& _o) const
{
	return commonData.equals(_o.commonData) &&
		chestId == _o.chestId &&
		tierId == _o.tierId &&
		chestType == _o.chestType &&
		availableAfter == _o.availableAfter;
}

const char *ClientChestDataEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("commonData=");
	commonData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("chestId=");
	_buf.appendUint64(chestId);
	_buf.append(',');
	_buf.append("tierId=");
	_buf.appendUint(tierId);
	_buf.append(',');
	_buf.append("chestType=");
	_buf.appendUint(chestType);
	_buf.append(',');
	_buf.append("availableAfter=");
	_buf.appendUint(availableAfter);
	_buf.append('}');
	return _buf.c_str();
}

const char *ClientChestDataEx::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	commonData.toXmlString("commonData", _buf);
	Atf::XmlElement::encodeAsXmlElement("chestId", chestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tierId", tierId, _buf);
	Atf::XmlElement::encodeAsXmlElement("chestType", chestType, _buf);
	Atf::XmlElement::encodeAsXmlElement("availableAfter", availableAfter, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool ClientChestDataEx::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("commonData"))
		{
			if(!Atf::AtfTempl< ClientChestData >::FromXmlString(_value, commonData)) return false;
		}
		else if (_element.equals("chestId"))
		{
			chestId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tierId"))
		{
			tierId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chestType"))
		{
			chestType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("availableAfter"))
		{
			availableAfter = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void ClientChestDataEx::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientChestDataEx())) // not empty
	{
		commonData.composeMsg(_body, _ignoreJSON);
		_body.composeUINT64(chestId);
		_body.composeUINT32(tierId);
		_body.composeBYTE(chestType);
		_body.composeUINT32(availableAfter);
	}

	_msg.composeMsgBody(_body);
}

void ClientChestDataEx::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	commonData.parseMsg(_parser0);
	_parser0.parseUINT64(chestId);
	_parser0.parseUINT32(tierId);
	_parser0.parseBYTE(chestType);
	_parser0.parseUINT32(availableAfter);
}

const char *ClientChestDataEx::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("commonData", commonData);
	_jsonstr.compose("chestId", chestId);
	_jsonstr.compose("tierId", tierId);
	_jsonstr.compose("chestType", chestType);
	_jsonstr.compose("availableAfter", availableAfter);
	return _buf.c_str();
}

void ClientChestDataEx::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("commonData", commonData);
	_jparser.parseByNameThrow("chestId", chestId);
	_jparser.parseByNameThrow("tierId", tierId);
	_jparser.parseByNameThrow("chestType", chestType);
	_jparser.parseByNameThrow("availableAfter", availableAfter);
}

/* static */ void ClientChestDataEx::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	ClientChestData commonData; _jparser.validateByNameThrow("commonData", commonData);
	UINT64 chestId; _jparser.validateByNameThrow("chestId", chestId);
	AtfValidator::validateUint(_descr, "chestId", chestId, _checker, __FILE__, __LINE__);
	UINT32 tierId; _jparser.validateByNameThrow("tierId", tierId);
	AtfValidator::validateInt(_descr, "tierId", tierId, _checker, __FILE__, __LINE__);
	BYTE chestType; _jparser.validateByNameThrow("chestType", chestType);
	AtfValidator::validateInt(_descr, "chestType", chestType, _checker, __FILE__, __LINE__);
	UINT32 availableAfter; _jparser.validateByNameThrow("availableAfter", availableAfter);
	AtfValidator::validateInt(_descr, "availableAfter", availableAfter, _checker, __FILE__, __LINE__);
}

/*static*/ void ClientChestDataEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	ClientChestData::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("commonData"), _fieldsWithUnparsedContent);
	UINT64 chestId; _parser0.parseUINT64(chestId);
	AtfValidator::validateUint(_descr, "chestId", chestId, _checker, __FILE__, __LINE__);
	UINT32 tierId; _parser0.parseUINT32(tierId);
	AtfValidator::validateInt(_descr, "tierId", tierId, _checker, __FILE__, __LINE__);
	BYTE chestType; _parser0.parseBYTE(chestType);
	AtfValidator::validateInt(_descr, "chestType", chestType, _checker, __FILE__, __LINE__);
	UINT32 availableAfter; _parser0.parseUINT32(availableAfter);
	AtfValidator::validateInt(_descr, "availableAfter", availableAfter, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_USER_BARS
//=================================================================

Protocol_MSG_LOBBYETC_GET_USER_BARS::Protocol_MSG_LOBBYETC_GET_USER_BARS()
{
	clear();
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS::clear()
{
}

bool Protocol_MSG_LOBBYETC_GET_USER_BARS::equals(const Protocol_MSG_LOBBYETC_GET_USER_BARS& _o) const
{
	return true;
}

bool Protocol_MSG_LOBBYETC_GET_USER_BARS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_USER_BARS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_USER_BARS*)_other));
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_USER_BARS).append(")");
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_USER_BARS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_GET_USER_BARS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS::parseMsg(CommMsgParser& _parser)
{
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_USER_BARS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_BARS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_USER_BARS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_BARS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY
//=================================================================

Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY(Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, availableChests(std::move(_o.availableChests))
	, lockedChests(std::move(_o.lockedChests))
	, stateFlags(std::move(_o.stateFlags))
{
}

Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY& Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		availableChests = std::move(_o.availableChests);
		lockedChests = std::move(_o.lockedChests);
		stateFlags = std::move(_o.stateFlags);
	}
	return *this;
}

#endif

void Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	availableChests.clear();
	lockedChests.clear();
	stateFlags = 0;
}

bool Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		availableChests.equals(_o.availableChests) &&
		lockedChests.equals(_o.lockedChests) &&
		stateFlags == _o.stateFlags;
}

bool Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_USER_BARS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY*)_other));
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_USER_BARS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("availableChests=");
		availableChests.toTraceString(_buf);
		_buf.append(',');
		_buf.append("lockedChests=");
		lockedChests.toTraceString(_buf);
		_buf.append(',');
		_buf.append("stateFlags=");
		_buf.appendUint(stateFlags);
	}
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_USER_BARS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		availableChests.toXmlString("availableChests", _buf);
		lockedChests.toXmlString("lockedChests", _buf);
		Atf::XmlElement::encodeAsXmlElement("stateFlags", stateFlags, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("availableChests"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientChestDataEx, 4 > >::FromXmlString(_value, availableChests)) return false;
			}
			else if (_element.equals("lockedChests"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientChestDataEx, 4 > >::FromXmlString(_value, lockedChests)) return false;
			}
			else if (_element.equals("stateFlags"))
			{
				stateFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		availableChests.composeMsg(_msg, _ignoreJSON);
		lockedChests.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(stateFlags);
	}
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		availableChests.parseMsg(_parser);
		lockedChests.parseMsg(_parser);
		_parser.parseUINT32(stateFlags);
	}
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("availableChests", availableChests);
		_jsonstr.compose("lockedChests", lockedChests);
		_jsonstr.compose("stateFlags", stateFlags);
	}
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("availableChests", availableChests);
		_jparser.parseByNameThrow("lockedChests", lockedChests);
		_jparser.parseByNameThrow("stateFlags", stateFlags);
	}
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_BARS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ClientChestDataEx > availableChests; _jparser.validateByNameThrow("availableChests", availableChests);
		AtfValidator::validateInt(_descr, "availableChests", availableChests.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ClientChestDataEx > lockedChests; _jparser.validateByNameThrow("lockedChests", lockedChests);
		AtfValidator::validateInt(_descr, "lockedChests", lockedChests.size(), _checker, __FILE__, __LINE__);
		UINT32 stateFlags; _jparser.validateByNameThrow("stateFlags", stateFlags);
		AtfValidator::validateInt(_descr, "stateFlags", stateFlags, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_BARS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szAvailableChests = Atf::LAtfVector< ClientChestDataEx, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("availableChests"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "availableChests", szAvailableChests, _checker, __FILE__, __LINE__);
		int szLockedChests = Atf::LAtfVector< ClientChestDataEx, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("lockedChests"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "lockedChests", szLockedChests, _checker, __FILE__, __LINE__);
		UINT32 stateFlags; _parser.parseUINT32(stateFlags);
		AtfValidator::validateInt(_descr, "stateFlags", stateFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION
//=================================================================

Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION(Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION&& _o)
	: clientReqId(std::move(_o.clientReqId))
	, availableChests(std::move(_o.availableChests))
	, lockedChests(std::move(_o.lockedChests))
	, stateFlags(std::move(_o.stateFlags))
{
}

Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION& Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::operator=(Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION&& _o)
{
	if(this != &_o)
	{
		clientReqId = std::move(_o.clientReqId);
		availableChests = std::move(_o.availableChests);
		lockedChests = std::move(_o.lockedChests);
		stateFlags = std::move(_o.stateFlags);
	}
	return *this;
}

#endif

void Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::clear()
{
	clientReqId = 0;
	availableChests.clear();
	lockedChests.clear();
	stateFlags = 0;
}

bool Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::equals(const Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION& _o) const
{
	return clientReqId == _o.clientReqId &&
		availableChests.equals(_o.availableChests) &&
		lockedChests.equals(_o.lockedChests) &&
		stateFlags == _o.stateFlags;
}

bool Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION*)_other));
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION).append(")");
	_buf.append(',');
	_buf.append("clientReqId=");
	_buf.appendUint(clientReqId);
	_buf.append(',');
	_buf.append("availableChests=");
	availableChests.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lockedChests=");
	lockedChests.toTraceString(_buf);
	_buf.append(',');
	_buf.append("stateFlags=");
	_buf.appendUint(stateFlags);
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientReqId", clientReqId, _buf);
	availableChests.toXmlString("availableChests", _buf);
	lockedChests.toXmlString("lockedChests", _buf);
	Atf::XmlElement::encodeAsXmlElement("stateFlags", stateFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientReqId"))
			{
				clientReqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("availableChests"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientChestDataEx, 4 > >::FromXmlString(_value, availableChests)) return false;
			}
			else if (_element.equals("lockedChests"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientChestDataEx, 4 > >::FromXmlString(_value, lockedChests)) return false;
			}
			else if (_element.equals("stateFlags"))
			{
				stateFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clientReqId);
	availableChests.composeMsg(_msg, _ignoreJSON);
	lockedChests.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(stateFlags);
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clientReqId);
	availableChests.parseMsg(_parser);
	lockedChests.parseMsg(_parser);
	_parser.parseUINT32(stateFlags);
}

const char *Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientReqId", clientReqId);
	_jsonstr.compose("availableChests", availableChests);
	_jsonstr.compose("lockedChests", lockedChests);
	_jsonstr.compose("stateFlags", stateFlags);
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientReqId", clientReqId);
	_jparser.parseByNameThrow("availableChests", availableChests);
	_jparser.parseByNameThrow("lockedChests", lockedChests);
	_jparser.parseByNameThrow("stateFlags", stateFlags);
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clientReqId; _jparser.validateByNameThrow("clientReqId", clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ClientChestDataEx > availableChests; _jparser.validateByNameThrow("availableChests", availableChests);
	AtfValidator::validateInt(_descr, "availableChests", availableChests.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< ClientChestDataEx > lockedChests; _jparser.validateByNameThrow("lockedChests", lockedChests);
	AtfValidator::validateInt(_descr, "lockedChests", lockedChests.size(), _checker, __FILE__, __LINE__);
	UINT32 stateFlags; _jparser.validateByNameThrow("stateFlags", stateFlags);
	AtfValidator::validateInt(_descr, "stateFlags", stateFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clientReqId; _parser.parseUINT32(clientReqId);
	AtfValidator::validateInt(_descr, "clientReqId", clientReqId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAvailableChests = Atf::LAtfVector< ClientChestDataEx, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("availableChests"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "availableChests", szAvailableChests, _checker, __FILE__, __LINE__);
	int szLockedChests = Atf::LAtfVector< ClientChestDataEx, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("lockedChests"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "lockedChests", szLockedChests, _checker, __FILE__, __LINE__);
	UINT32 stateFlags; _parser.parseUINT32(stateFlags);
	AtfValidator::validateInt(_descr, "stateFlags", stateFlags, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR
//=================================================================

Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR()
{
	clear();
}

void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::clear()
{
}

bool Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::equals(const Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR& _o) const
{
	return true;
}

bool Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR*)_other));
}

const char *Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR).append(")");
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::parseMsg(CommMsgParser& _parser)
{
}

const char *Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY
//=================================================================

Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY(Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY& Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::operator=(Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::equals(const Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY*)_other));
}

const char *Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
}

void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
}

const char *Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE: _obj = new Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE(); break;
			case MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED: _obj = new Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED(); break;
			case MSG_LOBBYETC_CVL_OPTED_IN: _obj = new Protocol_MSG_LOBBYETC_CVL_OPTED_IN(); break;
			case MSG_LOBBYETC_CVL_OPTED_IN_REPLY: _obj = new Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY(); break;
			case MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR: _obj = new Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR(); break;
			case MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY: _obj = new Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY(); break;
			case MSG_LOBBYETC_GET_CVL_STATE_FOR_USER: _obj = new Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER(); break;
			case MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY: _obj = new Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY(); break;
			case MSG_LOBBYETC_GET_USER_BARS: _obj = new Protocol_MSG_LOBBYETC_GET_USER_BARS(); break;
			case MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION: _obj = new Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION(); break;
			case MSG_LOBBYETC_GET_USER_BARS_REPLY: _obj = new Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE: Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED: Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CVL_OPTED_IN: Protocol_MSG_LOBBYETC_CVL_OPTED_IN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CVL_OPTED_IN_REPLY: Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR: Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY: Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_CVL_STATE_FOR_USER: Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY: Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_BARS: Protocol_MSG_LOBBYETC_GET_USER_BARS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION: Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_BARS_REPLY: Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE: Protocol_MSG_LOBBYETC_CLI_NOTIFY_CVL_STATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED: Protocol_MSG_LOBBYETC_CLI_NOTIFY_MPC_ISSUED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CVL_OPTED_IN: Protocol_MSG_LOBBYETC_CVL_OPTED_IN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CVL_OPTED_IN_REPLY: Protocol_MSG_LOBBYETC_CVL_OPTED_IN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR: Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY: Protocol_MSG_LOBBYETC_EXCHANGE_CURRENT_CVL_BAR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_CVL_STATE_FOR_USER: Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY: Protocol_MSG_LOBBYETC_GET_CVL_STATE_FOR_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_BARS: Protocol_MSG_LOBBYETC_GET_USER_BARS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION: Protocol_MSG_LOBBYETC_GET_USER_BARS_NOTIFICATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_BARS_REPLY: Protocol_MSG_LOBBYETC_GET_USER_BARS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

