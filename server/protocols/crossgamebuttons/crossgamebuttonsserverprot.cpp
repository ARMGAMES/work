/**
 * crossgamebuttonsserverprot.cpp
 *
 * This file was auto-generated from crossgamebuttonsserverprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor crossgamebuttonsserverprot.txt
 */
 
#include "crossgamebuttonsserverprot.h"

//=================================================================
//                Protocol_CRM_Q_GET_CROSSLINK_BUTTONS
//=================================================================

CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS()
{
	clear();
}

void CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::clear()
{
}

bool CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::equals(const Protocol_CRM_Q_GET_CROSSLINK_BUTTONS& _o) const
{
	return true;
}

bool CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::equals(Atf::MessageProtocol* _other) const
{
	if (CRM_Q_GET_CROSSLINK_BUTTONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CRM_Q_GET_CROSSLINK_BUTTONS*)_other));
}

const char *CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRM_Q_GET_CROSSLINK_BUTTONS).append(")");
	return _buf.c_str();
}

const char *CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CRM_Q_GET_CROSSLINK_BUTTONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::parseMsg(CommMsgParser& _parser)
{
}

const char *CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRM_Q_GET_CROSSLINK_BUTTONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void CrossGameLinkServer::Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRM_Q_GET_CROSSLINK_BUTTONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CRM_A_GET_CROSSLINK_BUTTONS
//=================================================================

CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::Protocol_CRM_A_GET_CROSSLINK_BUTTONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::Protocol_CRM_A_GET_CROSSLINK_BUTTONS(Protocol_CRM_A_GET_CROSSLINK_BUTTONS&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, buttons(std::move(_o.buttons))
{
}

CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS& CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::operator=(Protocol_CRM_A_GET_CROSSLINK_BUTTONS&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		buttons = std::move(_o.buttons);
	}
	return *this;
}

#endif

void CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::clear()
{
	errCode = 0;
	errStr.clear();
	buttons.clear();
}

bool CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::equals(const Protocol_CRM_A_GET_CROSSLINK_BUTTONS& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		buttons.equals(_o.buttons);
}

bool CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::equals(Atf::MessageProtocol* _other) const
{
	if (CRM_A_GET_CROSSLINK_BUTTONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CRM_A_GET_CROSSLINK_BUTTONS*)_other));
}

const char *CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRM_A_GET_CROSSLINK_BUTTONS).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("buttons=");
		buttons.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CRM_A_GET_CROSSLINK_BUTTONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		buttons.toXmlString("buttons", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("buttons"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CrossGameLinkCommon::CrossGameLinkButtonData, 4 > >::FromXmlString(_value, buttons)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		buttons.composeMsg(_msg, _ignoreJSON);
	}
}

void CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		buttons.parseMsg(_parser);
	}
}

const char *CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("buttons", buttons);
	}
	return _buf.c_str();
}

void CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("buttons", buttons);
	}
}

/*static*/ void CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRM_A_GET_CROSSLINK_BUTTONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< CrossGameLinkCommon::CrossGameLinkButtonData > buttons; _jparser.validateByNameThrow("buttons", buttons);
		AtfValidator::validateInt(_descr, "buttons", buttons.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CrossGameLinkServer::Protocol_CRM_A_GET_CROSSLINK_BUTTONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRM_A_GET_CROSSLINK_BUTTONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szButtons = Atf::LAtfVector< CrossGameLinkCommon::CrossGameLinkButtonData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buttons"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "buttons", szButtons, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE
//=================================================================

CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE(Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE&& _o)
	: adminIntId(std::move(_o.adminIntId))
	, buttons(std::move(_o.buttons))
{
}

CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE& CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::operator=(Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE&& _o)
{
	if(this != &_o)
	{
		adminIntId = std::move(_o.adminIntId);
		buttons = std::move(_o.buttons);
	}
	return *this;
}

#endif

void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::clear()
{
	adminIntId = 0;
	buttons.clear();
}

bool CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::equals(const Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE& _o) const
{
	return adminIntId == _o.adminIntId &&
		buttons.equals(_o.buttons);
}

bool CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE*)_other));
}

const char *CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE).append(")");
	_buf.append(',');
	_buf.append("adminIntId=");
	_buf.appendUint(adminIntId);
	_buf.append(',');
	_buf.append("buttons=");
	buttons.toTraceString(_buf);
	return _buf.c_str();
}

const char *CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("adminIntId", adminIntId, _buf);
	buttons.toXmlString("buttons", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("adminIntId"))
			{
				adminIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buttons"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CrossGameLinkCommon::CrossGameLinkButtonData, 4 > >::FromXmlString(_value, buttons)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(adminIntId);
	buttons.composeMsg(_msg, _ignoreJSON);
}

void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(adminIntId);
	buttons.parseMsg(_parser);
}

const char *CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("adminIntId", adminIntId);
	_jsonstr.compose("buttons", buttons);
	return _buf.c_str();
}

void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("adminIntId", adminIntId);
	_jparser.parseByNameThrow("buttons", buttons);
}

/*static*/ void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 adminIntId; _jparser.validateByNameThrow("adminIntId", adminIntId);
	AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CrossGameLinkCommon::CrossGameLinkButtonData > buttons; _jparser.validateByNameThrow("buttons", buttons);
	AtfValidator::validateInt(_descr, "buttons", buttons.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 adminIntId; _parser.parseUINT32(adminIntId);
	AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szButtons = Atf::LAtfVector< CrossGameLinkCommon::CrossGameLinkButtonData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buttons"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "buttons", szButtons, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY
//=================================================================

CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY(Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY& CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::operator=(Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::clear()
{
	errCode = 0;
	errStr.clear();
}

bool CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::equals(const Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY*)_other));
}

const char *CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CrossGameLinkServer::Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS
//=================================================================

CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS(Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS&& _o)
	: adminIntId(std::move(_o.adminIntId))
	, buttons(std::move(_o.buttons))
{
}

CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS& CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::operator=(Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS&& _o)
{
	if(this != &_o)
	{
		adminIntId = std::move(_o.adminIntId);
		buttons = std::move(_o.buttons);
	}
	return *this;
}

#endif

void CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::clear()
{
	adminIntId = 0;
	buttons.clear();
}

bool CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::equals(const Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS& _o) const
{
	return adminIntId == _o.adminIntId &&
		buttons.equals(_o.buttons);
}

bool CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::equals(Atf::MessageProtocol* _other) const
{
	if (CRM_Q_CREATE_CROSSLINK_BUTTONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS*)_other));
}

const char *CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRM_Q_CREATE_CROSSLINK_BUTTONS).append(")");
	_buf.append(',');
	_buf.append("adminIntId=");
	_buf.appendUint(adminIntId);
	_buf.append(',');
	_buf.append("buttons=");
	buttons.toTraceString(_buf);
	return _buf.c_str();
}

const char *CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CRM_Q_CREATE_CROSSLINK_BUTTONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("adminIntId", adminIntId, _buf);
	buttons.toXmlString("buttons", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("adminIntId"))
			{
				adminIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buttons"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CrossGameLinkCommon::CrossGameLinkButtonData, 4 > >::FromXmlString(_value, buttons)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(adminIntId);
	buttons.composeMsg(_msg, _ignoreJSON);
}

void CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(adminIntId);
	buttons.parseMsg(_parser);
}

const char *CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("adminIntId", adminIntId);
	_jsonstr.compose("buttons", buttons);
	return _buf.c_str();
}

void CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("adminIntId", adminIntId);
	_jparser.parseByNameThrow("buttons", buttons);
}

/*static*/ void CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRM_Q_CREATE_CROSSLINK_BUTTONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 adminIntId; _jparser.validateByNameThrow("adminIntId", adminIntId);
	AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CrossGameLinkCommon::CrossGameLinkButtonData > buttons; _jparser.validateByNameThrow("buttons", buttons);
	AtfValidator::validateInt(_descr, "buttons", buttons.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void CrossGameLinkServer::Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRM_Q_CREATE_CROSSLINK_BUTTONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 adminIntId; _parser.parseUINT32(adminIntId);
	AtfValidator::validateInt(_descr, "adminIntId", adminIntId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szButtons = Atf::LAtfVector< CrossGameLinkCommon::CrossGameLinkButtonData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buttons"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "buttons", szButtons, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS
//=================================================================

CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS(Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS& CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::operator=(Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::clear()
{
	errCode = 0;
	errStr.clear();
}

bool CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::equals(const Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::equals(Atf::MessageProtocol* _other) const
{
	if (CRM_A_CREATE_CROSSLINK_BUTTONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS*)_other));
}

const char *CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRM_A_CREATE_CROSSLINK_BUTTONS).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CRM_A_CREATE_CROSSLINK_BUTTONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRM_A_CREATE_CROSSLINK_BUTTONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void CrossGameLinkServer::Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRM_A_CREATE_CROSSLINK_BUTTONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* CrossGameLinkServer::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case CRM_A_CREATE_CROSSLINK_BUTTONS: _obj = new Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS(); break;
			case CRM_A_GET_CROSSLINK_BUTTONS: _obj = new Protocol_CRM_A_GET_CROSSLINK_BUTTONS(); break;
			case CRM_Q_CREATE_CROSSLINK_BUTTONS: _obj = new Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS(); break;
			case CRM_Q_GET_CROSSLINK_BUTTONS: _obj = new Protocol_CRM_Q_GET_CROSSLINK_BUTTONS(); break;
			case MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE: _obj = new Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE(); break;
			case MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY: _obj = new Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool CrossGameLinkServer::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case CRM_A_CREATE_CROSSLINK_BUTTONS: Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CRM_A_GET_CROSSLINK_BUTTONS: Protocol_CRM_A_GET_CROSSLINK_BUTTONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CRM_Q_CREATE_CROSSLINK_BUTTONS: Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CRM_Q_GET_CROSSLINK_BUTTONS: Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE: Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY: Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool CrossGameLinkServer::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case CRM_A_CREATE_CROSSLINK_BUTTONS: Protocol_CRM_A_CREATE_CROSSLINK_BUTTONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CRM_A_GET_CROSSLINK_BUTTONS: Protocol_CRM_A_GET_CROSSLINK_BUTTONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CRM_Q_CREATE_CROSSLINK_BUTTONS: Protocol_CRM_Q_CREATE_CROSSLINK_BUTTONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CRM_Q_GET_CROSSLINK_BUTTONS: Protocol_CRM_Q_GET_CROSSLINK_BUTTONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE: Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY: Protocol_MSG_LOBBYETC_CROSSLINK_BUTTONS_CREATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

