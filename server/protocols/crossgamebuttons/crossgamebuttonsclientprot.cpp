/**
 * crossgamebuttonsclientprot.cpp
 *
 * This file was auto-generated from crossgamebuttonsclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor crossgamebuttonsclientprot.txt
 */
 
#include "crossgamebuttonsclientprot.h"

//=================================================================
//                    ButtonsLeaf
//=================================================================

CrossGameLink::ButtonsLeaf::ButtonsLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

CrossGameLink::ButtonsLeaf::ButtonsLeaf(ButtonsLeaf&& _o)
	: buttons(std::move(_o.buttons))
{
}

CrossGameLink::ButtonsLeaf& CrossGameLink::ButtonsLeaf::operator=(ButtonsLeaf&& _o)
{
	if(this != &_o)
	{
		buttons = std::move(_o.buttons);
	}
	return *this;
}

#endif

void CrossGameLink::ButtonsLeaf::clear()
{
	buttons.clear();
}

bool CrossGameLink::ButtonsLeaf::equals(const ButtonsLeaf& _o) const
{
	return buttons.equals(_o.buttons);
}

const char *CrossGameLink::ButtonsLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("buttons=");
	buttons.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *CrossGameLink::ButtonsLeaf::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	buttons.toXmlString("buttons", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool CrossGameLink::ButtonsLeaf::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("buttons"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CrossGameLinkCommon::CrossGameLinkButtonData, 4 > >::FromXmlString(_value, buttons)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void CrossGameLink::ButtonsLeaf::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	buttons.composeMsg(_msg, _ignoreJSON);
}

void CrossGameLink::ButtonsLeaf::parseMsg(CommMsgParser& _parser)
{
	buttons.parseMsg(_parser);
}

const char *CrossGameLink::ButtonsLeaf::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("buttons", buttons);
	return _buf.c_str();
}

void CrossGameLink::ButtonsLeaf::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("buttons", buttons);
}

/* static */ void CrossGameLink::ButtonsLeaf::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< CrossGameLinkCommon::CrossGameLinkButtonData > buttons; _jparser.validateByNameThrow("buttons", buttons);
	AtfValidator::validateInt(_descr, "buttons", buttons.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void CrossGameLink::ButtonsLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szButtons = Atf::LAtfVector< CrossGameLinkCommon::CrossGameLinkButtonData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buttons"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "buttons", szButtons, _checker, __FILE__, __LINE__);
}

