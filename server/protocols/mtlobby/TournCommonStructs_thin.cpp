/**
 * TournCommonStructs_thin.cpp
 *
 * This file was auto-generated from TournCommonStructs.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin TournCommonStructs.txt
 */
 
#include "TournCommonStructs_thin.h"

//=================================================================
//                    P_Event
//=================================================================

TournCommonThin::P_Event::P_Event()
{
	clear();
}

void TournCommonThin::P_Event::clear()
{
	startNum = 0;
	stopNum = 0;
}

bool TournCommonThin::P_Event::equals(const P_Event& _o) const
{
	return startNum == _o.startNum &&
		stopNum == _o.stopNum;
}

const char *TournCommonThin::P_Event::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startNum=");
	_buf.appendUint(startNum);
	_buf.append(',');
	_buf.append("stopNum=");
	_buf.appendUint(stopNum);
	_buf.append('}');
	return _buf.c_str();
}

void TournCommonThin::P_Event::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT16(startNum);
	_msg.composeUINT16(stopNum);
}

void TournCommonThin::P_Event::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(startNum);
	_parser.parseUINT16(stopNum);
}

/*static*/ void TournCommonThin::P_Event::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT16 startNum; _parser.parseUINT16(startNum);
	AtfValidator::validateInt(_descr, "startNum", startNum, _checker, __FILE__, __LINE__);
	UINT16 stopNum; _parser.parseUINT16(stopNum);
	AtfValidator::validateInt(_descr, "stopNum", stopNum, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    Error_InsufficientFunds32
//=================================================================

TournCommonThin::Error_InsufficientFunds32::Error_InsufficientFunds32()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournCommonThin::Error_InsufficientFunds32::Error_InsufficientFunds32(Error_InsufficientFunds32&& _o)
	: minBuyIn(std::move(_o.minBuyIn))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, clientServiceFlag(std::move(_o.clientServiceFlag))
	, availableChips(std::move(_o.availableChips))
	, gameCurrency(std::move(_o.gameCurrency))
	, isAutoConversionOn(std::move(_o.isAutoConversionOn))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, tournFlags2(std::move(_o.tournFlags2))
	, bounty(std::move(_o.bounty))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, name(std::move(_o.name))
{
}

TournCommonThin::Error_InsufficientFunds32& TournCommonThin::Error_InsufficientFunds32::operator=(Error_InsufficientFunds32&& _o)
{
	if(this != &_o)
	{
		minBuyIn = std::move(_o.minBuyIn);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		clientServiceFlag = std::move(_o.clientServiceFlag);
		availableChips = std::move(_o.availableChips);
		gameCurrency = std::move(_o.gameCurrency);
		isAutoConversionOn = std::move(_o.isAutoConversionOn);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		tournFlags2 = std::move(_o.tournFlags2);
		bounty = std::move(_o.bounty);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournCommonThin::Error_InsufficientFunds32::clear()
{
	minBuyIn = 0;
	enoughMoneyInOtherCurrency = false;
	clientServiceFlag = 0;
	availableChips = 0;
	gameCurrency.clear();
	isAutoConversionOn = false;
	clientCurrencyContext.clear();
	tournFlags2 = 0;
	bounty = 0;
	handType = 0;
	structure = 0;
	isHiLo = false;
	name.clear();
}

bool TournCommonThin::Error_InsufficientFunds32::equals(const Error_InsufficientFunds32& _o) const
{
	return minBuyIn == _o.minBuyIn &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		clientServiceFlag == _o.clientServiceFlag &&
		availableChips == _o.availableChips &&
		gameCurrency.equals(_o.gameCurrency) &&
		isAutoConversionOn == _o.isAutoConversionOn &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		tournFlags2 == _o.tournFlags2 &&
		bounty == _o.bounty &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		name.equals(_o.name);
}

const char *TournCommonThin::Error_InsufficientFunds32::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minBuyIn=");
	_buf.appendInt(minBuyIn);
	_buf.append(',');
	_buf.append("enoughMoneyInOtherCurrency=");
	_buf.appendUint(enoughMoneyInOtherCurrency);
	_buf.append(',');
	_buf.append("clientServiceFlag=");
	_buf.appendUint(clientServiceFlag);
	_buf.append(',');
	_buf.append("availableChips=");
	_buf.appendInt(availableChips);
	_buf.append(',');
	_buf.append("gameCurrency=");
	_buf.append(gameCurrency);
	_buf.append(',');
	_buf.append("isAutoConversionOn=");
	_buf.appendUint(isAutoConversionOn);
	_buf.append(',');
	_buf.append("clientCurrencyContext=");
	clientCurrencyContext.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendInt64(tournFlags2);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendUint(bounty);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

void TournCommonThin::Error_InsufficientFunds32::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(minBuyIn);
	_msg.composeBOOL(enoughMoneyInOtherCurrency);
	_msg.composeBYTE(clientServiceFlag);
	_msg.composeINT32(availableChips);
	_msg.composeString(gameCurrency);
	_msg.composeBOOL(isAutoConversionOn);
	_msg.composeMsgBody(clientCurrencyContext);
	CommMsgBody _msg0;
	_msg0.composeINT64(tournFlags2);
	_msg0.composeUINT32(bounty);
	_msg0.composeBYTE(handType);
	_msg0.composeBYTE(structure);
	_msg0.composeBOOL(isHiLo);
	_msg0.composeString(name);
	_msg.composeMsgBody(_msg0);
}

void TournCommonThin::Error_InsufficientFunds32::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(minBuyIn);
	_parser.parseBOOL(enoughMoneyInOtherCurrency);
	_parser.parseBYTE(clientServiceFlag);
	_parser.parseINT32(availableChips);
	_parser.parseStringP(gameCurrency);
	_parser.parseBOOL(isAutoConversionOn);
	_parser.parseMsgBody(clientCurrencyContext);
	parseAnonymousMsgBody0(_parser);
}

/*static*/ void TournCommonThin::Error_InsufficientFunds32::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 minBuyIn; _parser.parseINT32(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
	AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	INT32 availableChips; _parser.parseINT32(availableChips);
	AtfValidator::validateInt(_descr, "availableChips", availableChips, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gameCurrency"); size_t szGameCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "gameCurrency", szGameCurrency, _checker, __FILE__, __LINE__);
	bool isAutoConversionOn; _parser.parseBOOL(isAutoConversionOn);
	AtfValidator::validateInt(_descr, "isAutoConversionOn", isAutoConversionOn, _checker, __FILE__, __LINE__);
	size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
	AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
}

void TournCommonThin::Error_InsufficientFunds32::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(tournFlags2);
	_parser0.parseUINT32(bounty);
	_parser0.parseBYTE(handType);
	_parser0.parseBYTE(structure);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseStringP(name);
}

/*static*/ void TournCommonThin::Error_InsufficientFunds32::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	INT64 tournFlags2; _parser0.parseINT64(tournFlags2);
	AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 bounty; _parser0.parseUINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    Error_InsufficientFunds
//=================================================================

TournCommonThin::Error_InsufficientFunds::Error_InsufficientFunds()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournCommonThin::Error_InsufficientFunds::Error_InsufficientFunds(Error_InsufficientFunds&& _o)
	: minBuyIn(std::move(_o.minBuyIn))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, clientServiceFlag(std::move(_o.clientServiceFlag))
	, availableChips(std::move(_o.availableChips))
	, gameCurrency(std::move(_o.gameCurrency))
	, isAutoConversionOn(std::move(_o.isAutoConversionOn))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, tournFlags2(std::move(_o.tournFlags2))
	, bounty(std::move(_o.bounty))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, name(std::move(_o.name))
{
}

TournCommonThin::Error_InsufficientFunds& TournCommonThin::Error_InsufficientFunds::operator=(Error_InsufficientFunds&& _o)
{
	if(this != &_o)
	{
		minBuyIn = std::move(_o.minBuyIn);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		clientServiceFlag = std::move(_o.clientServiceFlag);
		availableChips = std::move(_o.availableChips);
		gameCurrency = std::move(_o.gameCurrency);
		isAutoConversionOn = std::move(_o.isAutoConversionOn);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		tournFlags2 = std::move(_o.tournFlags2);
		bounty = std::move(_o.bounty);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournCommonThin::Error_InsufficientFunds::clear()
{
	minBuyIn = 0;
	enoughMoneyInOtherCurrency = false;
	clientServiceFlag = 0;
	availableChips = 0;
	gameCurrency.clear();
	isAutoConversionOn = false;
	clientCurrencyContext.clear();
	tournFlags2 = 0;
	bounty = 0;
	handType = 0;
	structure = 0;
	isHiLo = false;
	name.clear();
}

bool TournCommonThin::Error_InsufficientFunds::equals(const Error_InsufficientFunds& _o) const
{
	return minBuyIn == _o.minBuyIn &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		clientServiceFlag == _o.clientServiceFlag &&
		availableChips == _o.availableChips &&
		gameCurrency.equals(_o.gameCurrency) &&
		isAutoConversionOn == _o.isAutoConversionOn &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		tournFlags2 == _o.tournFlags2 &&
		bounty == _o.bounty &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		name.equals(_o.name);
}

const char *TournCommonThin::Error_InsufficientFunds::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("enoughMoneyInOtherCurrency=");
	_buf.appendUint(enoughMoneyInOtherCurrency);
	_buf.append(',');
	_buf.append("clientServiceFlag=");
	_buf.appendUint(clientServiceFlag);
	_buf.append(',');
	_buf.append("availableChips=");
	_buf.appendInt64(availableChips);
	_buf.append(',');
	_buf.append("gameCurrency=");
	_buf.append(gameCurrency);
	_buf.append(',');
	_buf.append("isAutoConversionOn=");
	_buf.appendUint(isAutoConversionOn);
	_buf.append(',');
	_buf.append("clientCurrencyContext=");
	clientCurrencyContext.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendInt64(tournFlags2);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt64(bounty);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

void TournCommonThin::Error_InsufficientFunds::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(minBuyIn);
	_msg.composeBOOL(enoughMoneyInOtherCurrency);
	_msg.composeBYTE(clientServiceFlag);
	_msg.composeINT64(availableChips);
	_msg.composeString(gameCurrency);
	_msg.composeBOOL(isAutoConversionOn);
	_msg.composeMsgBody(clientCurrencyContext);
	CommMsgBody _msg0;
	_msg0.composeINT64(tournFlags2);
	_msg0.composeINT64(bounty);
	_msg0.composeBYTE(handType);
	_msg0.composeBYTE(structure);
	_msg0.composeBOOL(isHiLo);
	_msg0.composeString(name);
	_msg.composeMsgBody(_msg0);
}

void TournCommonThin::Error_InsufficientFunds::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(minBuyIn);
	_parser.parseBOOL(enoughMoneyInOtherCurrency);
	_parser.parseBYTE(clientServiceFlag);
	_parser.parseINT64(availableChips);
	_parser.parseStringP(gameCurrency);
	_parser.parseBOOL(isAutoConversionOn);
	_parser.parseMsgBody(clientCurrencyContext);
	parseAnonymousMsgBody0(_parser);
}

/*static*/ void TournCommonThin::Error_InsufficientFunds::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT64 minBuyIn; _parser.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
	AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	INT64 availableChips; _parser.parseINT64(availableChips);
	AtfValidator::validateInt(_descr, "availableChips", availableChips, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gameCurrency"); size_t szGameCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "gameCurrency", szGameCurrency, _checker, __FILE__, __LINE__);
	bool isAutoConversionOn; _parser.parseBOOL(isAutoConversionOn);
	AtfValidator::validateInt(_descr, "isAutoConversionOn", isAutoConversionOn, _checker, __FILE__, __LINE__);
	size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
	AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
}

void TournCommonThin::Error_InsufficientFunds::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(tournFlags2);
	_parser0.parseINT64(bounty);
	_parser0.parseBYTE(handType);
	_parser0.parseBYTE(structure);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseStringP(name);
}

/*static*/ void TournCommonThin::Error_InsufficientFunds::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	INT64 tournFlags2; _parser0.parseINT64(tournFlags2);
	AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	INT64 bounty; _parser0.parseINT64(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSpendLimit
//=================================================================

TournCommonThin::TournSpendLimit::TournSpendLimit()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournCommonThin::TournSpendLimit::TournSpendLimit(TournSpendLimit&& _o)
	: limitImposed(std::move(_o.limitImposed))
	, spendAmount(std::move(_o.spendAmount))
	, spendLimit(std::move(_o.spendLimit))
{
}

TournCommonThin::TournSpendLimit& TournCommonThin::TournSpendLimit::operator=(TournSpendLimit&& _o)
{
	if(this != &_o)
	{
		limitImposed = std::move(_o.limitImposed);
		spendAmount = std::move(_o.spendAmount);
		spendLimit = std::move(_o.spendLimit);
	}
	return *this;
}

#endif

void TournCommonThin::TournSpendLimit::clear()
{
	limitImposed = false;
	spendAmount = 0;
	spendLimit = 0;
}

bool TournCommonThin::TournSpendLimit::equals(const TournSpendLimit& _o) const
{
	return limitImposed == _o.limitImposed &&
		spendAmount == _o.spendAmount &&
		spendLimit == _o.spendLimit;
}

const char *TournCommonThin::TournSpendLimit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitImposed=");
	_buf.appendUint(limitImposed);
	if( limitImposed )
	{
		_buf.append(',');
		_buf.append("spendAmount=");
		_buf.appendInt(spendAmount);
		_buf.append(',');
		_buf.append("spendLimit=");
		_buf.appendInt(spendLimit);
	}
	_buf.append('}');
	return _buf.c_str();
}

void TournCommonThin::TournSpendLimit::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournSpendLimit())) // not empty
	{
		_body.composeBOOL(limitImposed);
		if( limitImposed )
		{
			_body.composeINT32(spendAmount);
			_body.composeINT32(spendLimit);
		}
	}

	_msg.composeMsgBody(_body);
}

void TournCommonThin::TournSpendLimit::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(limitImposed);
	if( limitImposed )
	{
		_parser0.parseINT32(spendAmount);
		_parser0.parseINT32(spendLimit);
	}
}

/*static*/ void TournCommonThin::TournSpendLimit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool limitImposed = false;
	_parser0.parseBOOL(limitImposed);
	AtfValidator::validateInt(_descr, "limitImposed", limitImposed, _checker, __FILE__, __LINE__);
	if( limitImposed )
	{
		INT32 spendAmount; _parser0.parseINT32(spendAmount);
		AtfValidator::validateInt(_descr, "spendAmount", spendAmount, _checker, __FILE__, __LINE__);
		INT32 spendLimit; _parser0.parseINT32(spendLimit);
		AtfValidator::validateInt(_descr, "spendLimit", spendLimit, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

