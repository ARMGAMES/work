/**
 * MultidayTourn.cpp
 *
 * This file was auto-generated from MultidayTourn.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor MultidayTourn.txt
 */
 
#include "MultidayTourn.h"

//=================================================================
//                    MultidayTourn
//=================================================================

TournClient::MultidayTourn::MultidayTourn()
{
	clear();
}

void TournClient::MultidayTourn::clear()
{
	props = 0;
	dayOneStopValue = 0;
	dayTwoStartMinutes = 0;
	dayTwoStart.setNull();
}

bool TournClient::MultidayTourn::equals(const MultidayTourn& _o) const
{
	return props == _o.props &&
		dayOneStopValue == _o.dayOneStopValue &&
		dayTwoStartMinutes == _o.dayTwoStartMinutes &&
		dayTwoStart.equals(_o.dayTwoStart);
}

const char *TournClient::MultidayTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("props=");
	_buf.appendUint(props);
	_buf.append(',');
	_buf.append("dayOneStopValue=");
	_buf.appendUint(dayOneStopValue);
	_buf.append(',');
	_buf.append("dayTwoStartMinutes=");
	_buf.appendUint(dayTwoStartMinutes);
	_buf.append(',');
	_buf.append("dayTwoStart=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, dayTwoStart);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::MultidayTourn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("props", props, _buf);
	Atf::XmlElement::encodeAsXmlElement("dayOneStopValue", dayOneStopValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("dayTwoStartMinutes", dayTwoStartMinutes, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "dayTwoStart", dayTwoStart);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::MultidayTourn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("props"))
		{
			props = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dayOneStopValue"))
		{
			dayOneStopValue = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dayTwoStartMinutes"))
		{
			dayTwoStartMinutes = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dayTwoStart"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, dayTwoStart);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::MultidayTourn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(props);
	_msg.composeUINT32(dayOneStopValue);
	_msg.composeUINT32(dayTwoStartMinutes);
	_msg.composeSrvTime(dayTwoStart);
}

void TournClient::MultidayTourn::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(props);
	_parser.parseUINT32(dayOneStopValue);
	_parser.parseUINT32(dayTwoStartMinutes);
	_parser.parseSrvTime(dayTwoStart);
}

const char *TournClient::MultidayTourn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("props", props);
	_jsonstr.compose("dayOneStopValue", dayOneStopValue);
	_jsonstr.compose("dayTwoStartMinutes", dayTwoStartMinutes);
	_jsonstr.compose("dayTwoStart", dayTwoStart);
	return _buf.c_str();
}

void TournClient::MultidayTourn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("props", props);
	_jparser.parseByNameThrow("dayOneStopValue", dayOneStopValue);
	_jparser.parseByNameThrow("dayTwoStartMinutes", dayTwoStartMinutes);
	_jparser.parseByNameThrow("dayTwoStart", dayTwoStart);
}

/* static */ void TournClient::MultidayTourn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 props; _jparser.validateByNameThrow("props", props);
	AtfValidator::validateInt(_descr, "props", props, _checker, __FILE__, __LINE__);
	UINT32 dayOneStopValue; _jparser.validateByNameThrow("dayOneStopValue", dayOneStopValue);
	AtfValidator::validateInt(_descr, "dayOneStopValue", dayOneStopValue, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartMinutes; _jparser.validateByNameThrow("dayTwoStartMinutes", dayTwoStartMinutes);
	AtfValidator::validateInt(_descr, "dayTwoStartMinutes", dayTwoStartMinutes, _checker, __FILE__, __LINE__);
	CommSrvTime dayTwoStart; _jparser.validateByNameThrow("dayTwoStart", dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::MultidayTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 props; _parser.parseUINT32(props);
	AtfValidator::validateInt(_descr, "props", props, _checker, __FILE__, __LINE__);
	UINT32 dayOneStopValue; _parser.parseUINT32(dayOneStopValue);
	AtfValidator::validateInt(_descr, "dayOneStopValue", dayOneStopValue, _checker, __FILE__, __LINE__);
	UINT32 dayTwoStartMinutes; _parser.parseUINT32(dayTwoStartMinutes);
	AtfValidator::validateInt(_descr, "dayTwoStartMinutes", dayTwoStartMinutes, _checker, __FILE__, __LINE__);
	CommSrvTime dayTwoStart; _parser.parseSrvTime(dayTwoStart);
	AtfValidator::validateSrvDateTime(_descr, "dayTwoStart", dayTwoStart, _checker, __FILE__, __LINE__);
}

