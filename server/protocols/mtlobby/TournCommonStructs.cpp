/**
 * TournCommonStructs.cpp
 *
 * This file was auto-generated from TournCommonStructs.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor TournCommonStructs.txt
 */
 
#include "TournCommonStructs.h"

//=================================================================
//                    P_Event
//=================================================================

TournCommon::P_Event::P_Event()
{
	clear();
}

void TournCommon::P_Event::clear()
{
	startNum = 0;
	stopNum = 0;
}

bool TournCommon::P_Event::equals(const P_Event& _o) const
{
	return startNum == _o.startNum &&
		stopNum == _o.stopNum;
}

const char *TournCommon::P_Event::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startNum=");
	_buf.appendUint(startNum);
	_buf.append(',');
	_buf.append("stopNum=");
	_buf.appendUint(stopNum);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournCommon::P_Event::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("startNum", startNum, _buf);
	Atf::XmlElement::encodeAsXmlElement("stopNum", stopNum, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournCommon::P_Event::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("startNum"))
		{
			startNum = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stopNum"))
		{
			stopNum = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournCommon::P_Event::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(startNum);
	_msg.composeUINT16(stopNum);
}

void TournCommon::P_Event::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(startNum);
	_parser.parseUINT16(stopNum);
}

const char *TournCommon::P_Event::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("startNum", startNum);
	_jsonstr.compose("stopNum", stopNum);
	return _buf.c_str();
}

void TournCommon::P_Event::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("startNum", startNum);
	_jparser.parseByNameThrow("stopNum", stopNum);
}

/* static */ void TournCommon::P_Event::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 startNum; _jparser.validateByNameThrow("startNum", startNum);
	AtfValidator::validateInt(_descr, "startNum", startNum, _checker, __FILE__, __LINE__);
	UINT16 stopNum; _jparser.validateByNameThrow("stopNum", stopNum);
	AtfValidator::validateInt(_descr, "stopNum", stopNum, _checker, __FILE__, __LINE__);
}

/*static*/ void TournCommon::P_Event::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT16 startNum; _parser.parseUINT16(startNum);
	AtfValidator::validateInt(_descr, "startNum", startNum, _checker, __FILE__, __LINE__);
	UINT16 stopNum; _parser.parseUINT16(stopNum);
	AtfValidator::validateInt(_descr, "stopNum", stopNum, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    Error_InsufficientFunds32
//=================================================================

TournCommon::Error_InsufficientFunds32::Error_InsufficientFunds32()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournCommon::Error_InsufficientFunds32::Error_InsufficientFunds32(Error_InsufficientFunds32&& _o)
	: minBuyIn(std::move(_o.minBuyIn))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, clientServiceFlag(std::move(_o.clientServiceFlag))
	, availableChips(std::move(_o.availableChips))
	, gameCurrency(std::move(_o.gameCurrency))
	, isAutoConversionOn(std::move(_o.isAutoConversionOn))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, tournFlags2(std::move(_o.tournFlags2))
	, bounty(std::move(_o.bounty))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, name(std::move(_o.name))
{
}

TournCommon::Error_InsufficientFunds32& TournCommon::Error_InsufficientFunds32::operator=(Error_InsufficientFunds32&& _o)
{
	if(this != &_o)
	{
		minBuyIn = std::move(_o.minBuyIn);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		clientServiceFlag = std::move(_o.clientServiceFlag);
		availableChips = std::move(_o.availableChips);
		gameCurrency = std::move(_o.gameCurrency);
		isAutoConversionOn = std::move(_o.isAutoConversionOn);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		tournFlags2 = std::move(_o.tournFlags2);
		bounty = std::move(_o.bounty);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournCommon::Error_InsufficientFunds32::clear()
{
	minBuyIn = 0;
	enoughMoneyInOtherCurrency = false;
	clientServiceFlag = 0;
	availableChips = 0;
	gameCurrency.clear();
	isAutoConversionOn = false;
	clientCurrencyContext.clear();
	tournFlags2 = 0;
	bounty = 0;
	handType = 0;
	structure = 0;
	isHiLo = false;
	name.clear();
}

bool TournCommon::Error_InsufficientFunds32::equals(const Error_InsufficientFunds32& _o) const
{
	return minBuyIn == _o.minBuyIn &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		clientServiceFlag == _o.clientServiceFlag &&
		availableChips == _o.availableChips &&
		Atf::atfPStringEquals(gameCurrency, _o.gameCurrency) &&
		isAutoConversionOn == _o.isAutoConversionOn &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		tournFlags2 == _o.tournFlags2 &&
		bounty == _o.bounty &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		Atf::atfPStringEquals(name, _o.name);
}

const char *TournCommon::Error_InsufficientFunds32::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minBuyIn=");
	_buf.appendInt(minBuyIn);
	_buf.append(',');
	_buf.append("enoughMoneyInOtherCurrency=");
	_buf.appendUint(enoughMoneyInOtherCurrency);
	_buf.append(',');
	_buf.append("clientServiceFlag=");
	_buf.appendUint(clientServiceFlag);
	_buf.append(',');
	_buf.append("availableChips=");
	_buf.appendInt(availableChips);
	_buf.append(',');
	_buf.append("gameCurrency=");
	_buf.append(gameCurrency);
	_buf.append(',');
	_buf.append("isAutoConversionOn=");
	_buf.appendUint(isAutoConversionOn);
	_buf.append(',');
	_buf.append("clientCurrencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientCurrencyContext, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendInt64(tournFlags2);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendUint(bounty);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournCommon::Error_InsufficientFunds32::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientServiceFlag", clientServiceFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("availableChips", availableChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCurrency", gameCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isAutoConversionOn", isAutoConversionOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientCurrencyContext", clientCurrencyContext, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournCommon::Error_InsufficientFunds32::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minBuyIn"))
		{
			minBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("enoughMoneyInOtherCurrency"))
		{
			enoughMoneyInOtherCurrency = (*_value.ptr() == '1');
		}
		else if (_element.equals("clientServiceFlag"))
		{
			clientServiceFlag = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("availableChips"))
		{
			availableChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, gameCurrency)) return false;
		}
		else if (_element.equals("isAutoConversionOn"))
		{
			isAutoConversionOn = (*_value.ptr() == '1');
		}
		else if (_element.equals("clientCurrencyContext"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientCurrencyContext)) return false;
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournCommon::Error_InsufficientFunds32::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(minBuyIn);
	_msg.composeBOOL(enoughMoneyInOtherCurrency);
	_msg.composeBYTE(clientServiceFlag);
	_msg.composeINT32(availableChips);
	_msg.composeString(gameCurrency);
	_msg.composeBOOL(isAutoConversionOn);
	_msg.composeMsgBody(clientCurrencyContext);
	CommMsgBody _msg0;
	_msg0.composeINT64(tournFlags2);
	_msg0.composeUINT32(bounty);
	_msg0.composeBYTE(handType);
	_msg0.composeBYTE(structure);
	_msg0.composeBOOL(isHiLo);
	_msg0.composeString(name);
	_msg.composeMsgBody(_msg0);
}

void TournCommon::Error_InsufficientFunds32::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(minBuyIn);
	_parser.parseBOOL(enoughMoneyInOtherCurrency);
	_parser.parseBYTE(clientServiceFlag);
	_parser.parseINT32(availableChips);
	_parser.parseStringP(gameCurrency);
	_parser.parseBOOL(isAutoConversionOn);
	_parser.parseMsgBody(clientCurrencyContext);
	parseAnonymousMsgBody0(_parser);
}

const char *TournCommon::Error_InsufficientFunds32::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	_jsonstr.compose("clientServiceFlag", clientServiceFlag);
	_jsonstr.compose("availableChips", availableChips);
	_jsonstr.compose("gameCurrency", gameCurrency);
	_jsonstr.compose("isAutoConversionOn", isAutoConversionOn);
	_jsonstr.compose("clientCurrencyContext", clientCurrencyContext);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void TournCommon::Error_InsufficientFunds32::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	_jparser.parseByNameThrow("clientServiceFlag", clientServiceFlag);
	_jparser.parseByNameThrow("availableChips", availableChips);
	_jparser.parseByNameThrow("gameCurrency", gameCurrency);
	_jparser.parseByNameThrow("isAutoConversionOn", isAutoConversionOn);
	_jparser.parseByNameThrow("clientCurrencyContext", clientCurrencyContext);
	_jparser.parseByName("tournFlags2", tournFlags2);
	_jparser.parseByName("bounty", bounty);
	_jparser.parseByName("handType", handType);
	_jparser.parseByName("structure", structure);
	_jparser.parseByName("isHiLo", isHiLo);
	_jparser.parseByName("name", name);
}

/* static */ void TournCommon::Error_InsufficientFunds32::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; _jparser.validateByNameThrow("clientServiceFlag", clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	INT32 availableChips; _jparser.validateByNameThrow("availableChips", availableChips);
	AtfValidator::validateInt(_descr, "availableChips", availableChips, _checker, __FILE__, __LINE__);
	PString gameCurrency; _jparser.validateByNameThrow("gameCurrency", gameCurrency);
	AtfValidator::validateInt(_descr, "gameCurrency", gameCurrency.length(), _checker, __FILE__, __LINE__);
	bool isAutoConversionOn; _jparser.validateByNameThrow("isAutoConversionOn", isAutoConversionOn);
	AtfValidator::validateInt(_descr, "isAutoConversionOn", isAutoConversionOn, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientCurrencyContext; _jparser.validateByNameThrow("clientCurrencyContext", clientCurrencyContext);
	AtfValidator::validateInt(_descr, "clientCurrencyContext", clientCurrencyContext._size(), _checker, __FILE__, __LINE__);
	INT64 tournFlags2; _jparser.validateByName("tournFlags2", tournFlags2);
	AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 bounty; _jparser.validateByName("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	BYTE handType; _jparser.validateByName("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByName("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByName("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByName("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournCommon::Error_InsufficientFunds32::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 minBuyIn; _parser.parseINT32(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
	AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	INT32 availableChips; _parser.parseINT32(availableChips);
	AtfValidator::validateInt(_descr, "availableChips", availableChips, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gameCurrency"); size_t szGameCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "gameCurrency", szGameCurrency, _checker, __FILE__, __LINE__);
	bool isAutoConversionOn; _parser.parseBOOL(isAutoConversionOn);
	AtfValidator::validateInt(_descr, "isAutoConversionOn", isAutoConversionOn, _checker, __FILE__, __LINE__);
	size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
	AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
}

void TournCommon::Error_InsufficientFunds32::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(tournFlags2);
	_parser0.parseUINT32(bounty);
	_parser0.parseBYTE(handType);
	_parser0.parseBYTE(structure);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseStringP(name);
}

/*static*/ void TournCommon::Error_InsufficientFunds32::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	INT64 tournFlags2; _parser0.parseINT64(tournFlags2);
	AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 bounty; _parser0.parseUINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    Error_InsufficientFunds
//=================================================================

TournCommon::Error_InsufficientFunds::Error_InsufficientFunds()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournCommon::Error_InsufficientFunds::Error_InsufficientFunds(Error_InsufficientFunds&& _o)
	: minBuyIn(std::move(_o.minBuyIn))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, clientServiceFlag(std::move(_o.clientServiceFlag))
	, availableChips(std::move(_o.availableChips))
	, gameCurrency(std::move(_o.gameCurrency))
	, isAutoConversionOn(std::move(_o.isAutoConversionOn))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, tournFlags2(std::move(_o.tournFlags2))
	, bounty(std::move(_o.bounty))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, name(std::move(_o.name))
{
}

TournCommon::Error_InsufficientFunds& TournCommon::Error_InsufficientFunds::operator=(Error_InsufficientFunds&& _o)
{
	if(this != &_o)
	{
		minBuyIn = std::move(_o.minBuyIn);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		clientServiceFlag = std::move(_o.clientServiceFlag);
		availableChips = std::move(_o.availableChips);
		gameCurrency = std::move(_o.gameCurrency);
		isAutoConversionOn = std::move(_o.isAutoConversionOn);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		tournFlags2 = std::move(_o.tournFlags2);
		bounty = std::move(_o.bounty);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournCommon::Error_InsufficientFunds::clear()
{
	minBuyIn = 0;
	enoughMoneyInOtherCurrency = false;
	clientServiceFlag = 0;
	availableChips = 0;
	gameCurrency.clear();
	isAutoConversionOn = false;
	clientCurrencyContext.clear();
	tournFlags2 = 0;
	bounty = 0;
	handType = 0;
	structure = 0;
	isHiLo = false;
	name.clear();
}

bool TournCommon::Error_InsufficientFunds::equals(const Error_InsufficientFunds& _o) const
{
	return minBuyIn == _o.minBuyIn &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		clientServiceFlag == _o.clientServiceFlag &&
		availableChips == _o.availableChips &&
		Atf::atfPStringEquals(gameCurrency, _o.gameCurrency) &&
		isAutoConversionOn == _o.isAutoConversionOn &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		tournFlags2 == _o.tournFlags2 &&
		bounty == _o.bounty &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		Atf::atfPStringEquals(name, _o.name);
}

const char *TournCommon::Error_InsufficientFunds::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minBuyIn=");
	_buf.appendInt64(minBuyIn);
	_buf.append(',');
	_buf.append("enoughMoneyInOtherCurrency=");
	_buf.appendUint(enoughMoneyInOtherCurrency);
	_buf.append(',');
	_buf.append("clientServiceFlag=");
	_buf.appendUint(clientServiceFlag);
	_buf.append(',');
	_buf.append("availableChips=");
	_buf.appendInt64(availableChips);
	_buf.append(',');
	_buf.append("gameCurrency=");
	_buf.append(gameCurrency);
	_buf.append(',');
	_buf.append("isAutoConversionOn=");
	_buf.appendUint(isAutoConversionOn);
	_buf.append(',');
	_buf.append("clientCurrencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientCurrencyContext, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendInt64(tournFlags2);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt64(bounty);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournCommon::Error_InsufficientFunds::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientServiceFlag", clientServiceFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("availableChips", availableChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameCurrency", gameCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isAutoConversionOn", isAutoConversionOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientCurrencyContext", clientCurrencyContext, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournCommon::Error_InsufficientFunds::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minBuyIn"))
		{
			minBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("enoughMoneyInOtherCurrency"))
		{
			enoughMoneyInOtherCurrency = (*_value.ptr() == '1');
		}
		else if (_element.equals("clientServiceFlag"))
		{
			clientServiceFlag = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("availableChips"))
		{
			availableChips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, gameCurrency)) return false;
		}
		else if (_element.equals("isAutoConversionOn"))
		{
			isAutoConversionOn = (*_value.ptr() == '1');
		}
		else if (_element.equals("clientCurrencyContext"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientCurrencyContext)) return false;
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournCommon::Error_InsufficientFunds::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(minBuyIn);
	_msg.composeBOOL(enoughMoneyInOtherCurrency);
	_msg.composeBYTE(clientServiceFlag);
	_msg.composeINT64(availableChips);
	_msg.composeString(gameCurrency);
	_msg.composeBOOL(isAutoConversionOn);
	_msg.composeMsgBody(clientCurrencyContext);
	CommMsgBody _msg0;
	_msg0.composeINT64(tournFlags2);
	_msg0.composeINT64(bounty);
	_msg0.composeBYTE(handType);
	_msg0.composeBYTE(structure);
	_msg0.composeBOOL(isHiLo);
	_msg0.composeString(name);
	_msg.composeMsgBody(_msg0);
}

void TournCommon::Error_InsufficientFunds::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(minBuyIn);
	_parser.parseBOOL(enoughMoneyInOtherCurrency);
	_parser.parseBYTE(clientServiceFlag);
	_parser.parseINT64(availableChips);
	_parser.parseStringP(gameCurrency);
	_parser.parseBOOL(isAutoConversionOn);
	_parser.parseMsgBody(clientCurrencyContext);
	parseAnonymousMsgBody0(_parser);
}

const char *TournCommon::Error_InsufficientFunds::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	_jsonstr.compose("clientServiceFlag", clientServiceFlag);
	_jsonstr.compose("availableChips", availableChips);
	_jsonstr.compose("gameCurrency", gameCurrency);
	_jsonstr.compose("isAutoConversionOn", isAutoConversionOn);
	_jsonstr.compose("clientCurrencyContext", clientCurrencyContext);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void TournCommon::Error_InsufficientFunds::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	_jparser.parseByNameThrow("clientServiceFlag", clientServiceFlag);
	_jparser.parseByNameThrow("availableChips", availableChips);
	_jparser.parseByNameThrow("gameCurrency", gameCurrency);
	_jparser.parseByNameThrow("isAutoConversionOn", isAutoConversionOn);
	_jparser.parseByNameThrow("clientCurrencyContext", clientCurrencyContext);
	_jparser.parseByName("tournFlags2", tournFlags2);
	_jparser.parseByName("bounty", bounty);
	_jparser.parseByName("handType", handType);
	_jparser.parseByName("structure", structure);
	_jparser.parseByName("isHiLo", isHiLo);
	_jparser.parseByName("name", name);
}

/* static */ void TournCommon::Error_InsufficientFunds::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; _jparser.validateByNameThrow("clientServiceFlag", clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	INT64 availableChips; _jparser.validateByNameThrow("availableChips", availableChips);
	AtfValidator::validateInt(_descr, "availableChips", availableChips, _checker, __FILE__, __LINE__);
	PString gameCurrency; _jparser.validateByNameThrow("gameCurrency", gameCurrency);
	AtfValidator::validateInt(_descr, "gameCurrency", gameCurrency.length(), _checker, __FILE__, __LINE__);
	bool isAutoConversionOn; _jparser.validateByNameThrow("isAutoConversionOn", isAutoConversionOn);
	AtfValidator::validateInt(_descr, "isAutoConversionOn", isAutoConversionOn, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody clientCurrencyContext; _jparser.validateByNameThrow("clientCurrencyContext", clientCurrencyContext);
	AtfValidator::validateInt(_descr, "clientCurrencyContext", clientCurrencyContext._size(), _checker, __FILE__, __LINE__);
	INT64 tournFlags2; _jparser.validateByName("tournFlags2", tournFlags2);
	AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	INT64 bounty; _jparser.validateByName("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	BYTE handType; _jparser.validateByName("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByName("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByName("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByName("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournCommon::Error_InsufficientFunds::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT64 minBuyIn; _parser.parseINT64(minBuyIn);
	AtfValidator::validateInt(_descr, "minBuyIn", minBuyIn, _checker, __FILE__, __LINE__);
	bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
	AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
	AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
	INT64 availableChips; _parser.parseINT64(availableChips);
	AtfValidator::validateInt(_descr, "availableChips", availableChips, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gameCurrency"); size_t szGameCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "gameCurrency", szGameCurrency, _checker, __FILE__, __LINE__);
	bool isAutoConversionOn; _parser.parseBOOL(isAutoConversionOn);
	AtfValidator::validateInt(_descr, "isAutoConversionOn", isAutoConversionOn, _checker, __FILE__, __LINE__);
	size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
	AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
}

void TournCommon::Error_InsufficientFunds::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT64(tournFlags2);
	_parser0.parseINT64(bounty);
	_parser0.parseBYTE(handType);
	_parser0.parseBYTE(structure);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseStringP(name);
}

/*static*/ void TournCommon::Error_InsufficientFunds::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	if(_parser0.parseEnded()) return;
	INT64 tournFlags2; _parser0.parseINT64(tournFlags2);
	AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	INT64 bounty; _parser0.parseINT64(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE structure; _parser0.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSpendLimit
//=================================================================

TournCommon::TournSpendLimit::TournSpendLimit()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournCommon::TournSpendLimit::TournSpendLimit(TournSpendLimit&& _o)
	: limitImposed(std::move(_o.limitImposed))
	, spendAmount(std::move(_o.spendAmount))
	, spendLimit(std::move(_o.spendLimit))
{
}

TournCommon::TournSpendLimit& TournCommon::TournSpendLimit::operator=(TournSpendLimit&& _o)
{
	if(this != &_o)
	{
		limitImposed = std::move(_o.limitImposed);
		spendAmount = std::move(_o.spendAmount);
		spendLimit = std::move(_o.spendLimit);
	}
	return *this;
}

#endif

void TournCommon::TournSpendLimit::clear()
{
	limitImposed = false;
	spendAmount = 0;
	spendLimit = 0;
}

bool TournCommon::TournSpendLimit::equals(const TournSpendLimit& _o) const
{
	return limitImposed == _o.limitImposed &&
		spendAmount == _o.spendAmount &&
		spendLimit == _o.spendLimit;
}

const char *TournCommon::TournSpendLimit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limitImposed=");
	_buf.appendUint(limitImposed);
	if( limitImposed )
	{
		_buf.append(',');
		_buf.append("spendAmount=");
		_buf.appendInt(spendAmount);
		_buf.append(',');
		_buf.append("spendLimit=");
		_buf.appendInt(spendLimit);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TournCommon::TournSpendLimit::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limitImposed", limitImposed, _buf);
	if( limitImposed )
	{
		Atf::XmlElement::encodeAsXmlElement("spendAmount", spendAmount, _buf);
		Atf::XmlElement::encodeAsXmlElement("spendLimit", spendLimit, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournCommon::TournSpendLimit::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limitImposed"))
		{
			limitImposed = (*_value.ptr() == '1');
		}
		else if (_element.equals("spendAmount"))
		{
			spendAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spendLimit"))
		{
			spendLimit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournCommon::TournSpendLimit::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournSpendLimit())) // not empty
	{
		_body.composeBOOL(limitImposed);
		if( limitImposed )
		{
			_body.composeINT32(spendAmount);
			_body.composeINT32(spendLimit);
		}
	}

	_msg.composeMsgBody(_body);
}

void TournCommon::TournSpendLimit::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(limitImposed);
	if( limitImposed )
	{
		_parser0.parseINT32(spendAmount);
		_parser0.parseINT32(spendLimit);
	}
}

const char *TournCommon::TournSpendLimit::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limitImposed", limitImposed);
	if( limitImposed )
	{
		_jsonstr.compose("spendAmount", spendAmount);
		_jsonstr.compose("spendLimit", spendLimit);
	}
	return _buf.c_str();
}

void TournCommon::TournSpendLimit::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limitImposed", limitImposed);
	if( limitImposed )
	{
		_jparser.parseByNameThrow("spendAmount", spendAmount);
		_jparser.parseByNameThrow("spendLimit", spendLimit);
	}
}

/* static */ void TournCommon::TournSpendLimit::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool limitImposed = false;
	_jparser.validateByNameThrow("limitImposed", limitImposed);
	AtfValidator::validateInt(_descr, "limitImposed", limitImposed, _checker, __FILE__, __LINE__);
	if( limitImposed )
	{
		INT32 spendAmount; _jparser.validateByNameThrow("spendAmount", spendAmount);
		AtfValidator::validateInt(_descr, "spendAmount", spendAmount, _checker, __FILE__, __LINE__);
		INT32 spendLimit; _jparser.validateByNameThrow("spendLimit", spendLimit);
		AtfValidator::validateInt(_descr, "spendLimit", spendLimit, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void TournCommon::TournSpendLimit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool limitImposed = false;
	_parser0.parseBOOL(limitImposed);
	AtfValidator::validateInt(_descr, "limitImposed", limitImposed, _checker, __FILE__, __LINE__);
	if( limitImposed )
	{
		INT32 spendAmount; _parser0.parseINT32(spendAmount);
		AtfValidator::validateInt(_descr, "spendAmount", spendAmount, _checker, __FILE__, __LINE__);
		INT32 spendLimit; _parser0.parseINT32(spendLimit);
		AtfValidator::validateInt(_descr, "spendLimit", spendLimit, _checker, __FILE__, __LINE__);
	}
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

