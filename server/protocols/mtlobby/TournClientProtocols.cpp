/**
 * TournClientProtocols.cpp
 *
 * This file was auto-generated from TournClientProtocols.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor TournClientProtocols.txt
 */
 
#include "TournClientProtocols.h"

//=================================================================
//                    P_BreakPub
//=================================================================

TournClient::P_BreakPub::P_BreakPub()
{
	clear();
}

void TournClient::P_BreakPub::clear()
{
	breakTime = 0;
	breakLength = 0;
}

bool TournClient::P_BreakPub::equals(const P_BreakPub& _o) const
{
	return breakTime == _o.breakTime &&
		breakLength == _o.breakLength;
}

const char *TournClient::P_BreakPub::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("breakTime=");
	_buf.appendInt(breakTime);
	_buf.append(',');
	_buf.append("breakLength=");
	_buf.appendUint(breakLength);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::P_BreakPub::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("breakTime", breakTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("breakLength", breakLength, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::P_BreakPub::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("breakTime"))
		{
			breakTime = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("breakLength"))
		{
			breakLength = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::P_BreakPub::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(breakTime);
	_msg.composeUINT32(breakLength);
}

void TournClient::P_BreakPub::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(breakTime);
	_parser.parseUINT32(breakLength);
}

const char *TournClient::P_BreakPub::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("breakTime", breakTime);
	_jsonstr.compose("breakLength", breakLength);
	return _buf.c_str();
}

void TournClient::P_BreakPub::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("breakTime", breakTime);
	_jparser.parseByNameThrow("breakLength", breakLength);
}

/* static */ void TournClient::P_BreakPub::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 breakTime; _jparser.validateByNameThrow("breakTime", breakTime);
	AtfValidator::validateInt(_descr, "breakTime", breakTime, _checker, __FILE__, __LINE__);
	UINT32 breakLength; _jparser.validateByNameThrow("breakLength", breakLength);
	AtfValidator::validateInt(_descr, "breakLength", breakLength, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::P_BreakPub::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 breakTime; _parser.parseINT32(breakTime);
	AtfValidator::validateInt(_descr, "breakTime", breakTime, _checker, __FILE__, __LINE__);
	UINT32 breakLength; _parser.parseUINT32(breakLength);
	AtfValidator::validateInt(_descr, "breakLength", breakLength, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_TicketType
//=================================================================

TournClient::P_TicketType::P_TicketType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::P_TicketType::P_TicketType(P_TicketType&& _o)
	: ticketTypeId(std::move(_o.ticketTypeId))
	, name(std::move(_o.name))
{
}

TournClient::P_TicketType& TournClient::P_TicketType::operator=(P_TicketType&& _o)
{
	if(this != &_o)
	{
		ticketTypeId = std::move(_o.ticketTypeId);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournClient::P_TicketType::clear()
{
	ticketTypeId = 0;
	name.clear();
}

bool TournClient::P_TicketType::equals(const P_TicketType& _o) const
{
	return ticketTypeId == _o.ticketTypeId &&
		Atf::atfPStringEquals(name, _o.name);
}

const char *TournClient::P_TicketType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketTypeId=");
	_buf.appendUint(ticketTypeId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::P_TicketType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketTypeId", ticketTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::P_TicketType::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketTypeId"))
		{
			ticketTypeId = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::P_TicketType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT16(ticketTypeId);
	_msg.composeString(name);
}

void TournClient::P_TicketType::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(ticketTypeId);
	_parser.parseStringP(name);
}

const char *TournClient::P_TicketType::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketTypeId", ticketTypeId);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void TournClient::P_TicketType::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketTypeId", ticketTypeId);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void TournClient::P_TicketType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT16 ticketTypeId; _jparser.validateByNameThrow("ticketTypeId", ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::P_TicketType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT16 ticketTypeId; _parser.parseUINT16(ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_FppReward
//=================================================================

TournClient::P_FppReward::P_FppReward()
{
	clear();
}

void TournClient::P_FppReward::clear()
{
	siteId = 0;
	reward = 0;
}

bool TournClient::P_FppReward::equals(const P_FppReward& _o) const
{
	return siteId == _o.siteId &&
		reward == _o.reward;
}

const char *TournClient::P_FppReward::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("reward=");
	_buf.appendUint(reward);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::P_FppReward::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("reward", reward, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::P_FppReward::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("siteId"))
		{
			siteId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reward"))
		{
			reward = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::P_FppReward::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(P_FppReward())) // not empty
	{
		_body.composeUINT32(siteId);
		_body.composeUINT32(reward);
	}

	_msg.composeMsgBody(_body);
}

void TournClient::P_FppReward::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(reward);
}

const char *TournClient::P_FppReward::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("reward", reward);
	return _buf.c_str();
}

void TournClient::P_FppReward::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("reward", reward);
}

/* static */ void TournClient::P_FppReward::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 reward; _jparser.validateByNameThrow("reward", reward);
	AtfValidator::validateInt(_descr, "reward", reward, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::P_FppReward::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 reward; _parser0.parseUINT32(reward);
	AtfValidator::validateInt(_descr, "reward", reward, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_AwardRange
//=================================================================

TournClient::P_AwardRange::P_AwardRange()
{
	clear();
}

void TournClient::P_AwardRange::clear()
{
	awardAmount = 0;
	nextTournId = 0;
	startPlace = 0;
	endPlace = 0;
}

bool TournClient::P_AwardRange::equals(const P_AwardRange& _o) const
{
	return awardAmount == _o.awardAmount &&
		nextTournId == _o.nextTournId &&
		startPlace == _o.startPlace &&
		endPlace == _o.endPlace;
}

const char *TournClient::P_AwardRange::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("awardAmount=");
	_buf.appendUint(awardAmount);
	_buf.append(',');
	_buf.append("nextTournId=");
	_buf.appendUint(nextTournId);
	_buf.append(',');
	_buf.append("startPlace=");
	_buf.appendUint(startPlace);
	_buf.append(',');
	_buf.append("endPlace=");
	_buf.appendUint(endPlace);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::P_AwardRange::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("awardAmount", awardAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextTournId", nextTournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("startPlace", startPlace, _buf);
	Atf::XmlElement::encodeAsXmlElement("endPlace", endPlace, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::P_AwardRange::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("awardAmount"))
		{
			awardAmount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextTournId"))
		{
			nextTournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startPlace"))
		{
			startPlace = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("endPlace"))
		{
			endPlace = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::P_AwardRange::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(awardAmount);
	_msg.composeUINT32(nextTournId);
	_msg.composeUINT32(startPlace);
	_msg.composeUINT32(endPlace);
}

void TournClient::P_AwardRange::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(awardAmount);
	_parser.parseUINT32(nextTournId);
	_parser.parseUINT32(startPlace);
	_parser.parseUINT32(endPlace);
}

const char *TournClient::P_AwardRange::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("awardAmount", awardAmount);
	_jsonstr.compose("nextTournId", nextTournId);
	_jsonstr.compose("startPlace", startPlace);
	_jsonstr.compose("endPlace", endPlace);
	return _buf.c_str();
}

void TournClient::P_AwardRange::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("awardAmount", awardAmount);
	_jparser.parseByNameThrow("nextTournId", nextTournId);
	_jparser.parseByNameThrow("startPlace", startPlace);
	_jparser.parseByNameThrow("endPlace", endPlace);
}

/* static */ void TournClient::P_AwardRange::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 awardAmount; _jparser.validateByNameThrow("awardAmount", awardAmount);
	AtfValidator::validateInt(_descr, "awardAmount", awardAmount, _checker, __FILE__, __LINE__);
	UINT32 nextTournId; _jparser.validateByNameThrow("nextTournId", nextTournId);
	AtfValidator::validateInt(_descr, "nextTournId", nextTournId, _checker, __FILE__, __LINE__);
	UINT32 startPlace; _jparser.validateByNameThrow("startPlace", startPlace);
	AtfValidator::validateInt(_descr, "startPlace", startPlace, _checker, __FILE__, __LINE__);
	UINT32 endPlace; _jparser.validateByNameThrow("endPlace", endPlace);
	AtfValidator::validateInt(_descr, "endPlace", endPlace, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::P_AwardRange::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 awardAmount; _parser.parseUINT32(awardAmount);
	AtfValidator::validateInt(_descr, "awardAmount", awardAmount, _checker, __FILE__, __LINE__);
	UINT32 nextTournId; _parser.parseUINT32(nextTournId);
	AtfValidator::validateInt(_descr, "nextTournId", nextTournId, _checker, __FILE__, __LINE__);
	UINT32 startPlace; _parser.parseUINT32(startPlace);
	AtfValidator::validateInt(_descr, "startPlace", startPlace, _checker, __FILE__, __LINE__);
	UINT32 endPlace; _parser.parseUINT32(endPlace);
	AtfValidator::validateInt(_descr, "endPlace", endPlace, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_AutopublishBody
//=================================================================

TournClient::P_AutopublishBody::P_AutopublishBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::P_AutopublishBody::P_AutopublishBody(P_AutopublishBody&& _o)
	: name(std::move(_o.name))
	, value(std::move(_o.value))
{
}

TournClient::P_AutopublishBody& TournClient::P_AutopublishBody::operator=(P_AutopublishBody&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		value = std::move(_o.value);
	}
	return *this;
}

#endif

void TournClient::P_AutopublishBody::clear()
{
	name.clear();
	value.clear();
}

bool TournClient::P_AutopublishBody::equals(const P_AutopublishBody& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(value, _o.value);
}

const char *TournClient::P_AutopublishBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::P_AutopublishBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::P_AutopublishBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("value"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, value)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::P_AutopublishBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(P_AutopublishBody())) // not empty
	{
		_body.composeString(name);
		_body.composeString(value);
	}

	_msg.composeMsgBody(_body);
}

void TournClient::P_AutopublishBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	_parser0.parseStringP(value);
}

const char *TournClient::P_AutopublishBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("value", value);
	return _buf.c_str();
}

void TournClient::P_AutopublishBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("value", value);
}

/* static */ void TournClient::P_AutopublishBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::P_AutopublishBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "value"); size_t szValue = strlen(_dummy);
	AtfValidator::validateInt(_descr, "value", szValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSubscr_SpinGoPrize_TargetReference
//=================================================================

TournClient::TournSubscr_SpinGoPrize_TargetReference::TournSubscr_SpinGoPrize_TargetReference()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::TournSubscr_SpinGoPrize_TargetReference::TournSubscr_SpinGoPrize_TargetReference(TournSubscr_SpinGoPrize_TargetReference&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, instance(std::move(_o.instance))
	, name(std::move(_o.name))
{
}

TournClient::TournSubscr_SpinGoPrize_TargetReference& TournClient::TournSubscr_SpinGoPrize_TargetReference::operator=(TournSubscr_SpinGoPrize_TargetReference&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		instance = std::move(_o.instance);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournClient::TournSubscr_SpinGoPrize_TargetReference::clear()
{
	tournamentId = 0;
	server.clear();
	instance.clear();
	name.clear();
}

bool TournClient::TournSubscr_SpinGoPrize_TargetReference::equals(const TournSubscr_SpinGoPrize_TargetReference& _o) const
{
	return tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(instance, _o.instance) &&
		name.equals(_o.name);
}

const char *TournClient::TournSubscr_SpinGoPrize_TargetReference::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint64(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("instance=");
	_buf.append(instance);
	_buf.append(',');
	_buf.append("name=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::TournSubscr_SpinGoPrize_TargetReference::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("instance", instance, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "name", name);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::TournSubscr_SpinGoPrize_TargetReference::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournamentId"))
		{
			tournamentId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("instance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, instance)) return false;
		}
		else if (_element.equals("name"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, name);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::TournSubscr_SpinGoPrize_TargetReference::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(tournamentId);
	_msg.composeString(server);
	_msg.composeString(instance);
	name.compose(_msg);
}

void TournClient::TournSubscr_SpinGoPrize_TargetReference::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tournamentId);
	_parser.parseStringP(server);
	_parser.parseStringP(instance);
	name.parse(_parser);
}

const char *TournClient::TournSubscr_SpinGoPrize_TargetReference::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("instance", instance);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void TournClient::TournSubscr_SpinGoPrize_TargetReference::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("instance", instance);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void TournClient::TournSubscr_SpinGoPrize_TargetReference::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateUint(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString instance; _jparser.validateByNameThrow("instance", instance);
	AtfValidator::validateInt(_descr, "instance", instance.length(), _checker, __FILE__, __LINE__);
	I18nPString name; _jparser.validateByNameThrow("name", name);
}

/*static*/ void TournClient::TournSubscr_SpinGoPrize_TargetReference::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT64 tournamentId; _parser.parseUINT64(tournamentId);
	AtfValidator::validateUint(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "instance"); size_t szInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "instance", szInstance, _checker, __FILE__, __LINE__);
	I18nPString name; name.parse(_parser);
}

//=================================================================
//                    LobbyData_Betting
//=================================================================

TournClient::LobbyData_Betting::LobbyData_Betting()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::LobbyData_Betting::LobbyData_Betting(LobbyData_Betting&& _o)
	: blindsLevel(std::move(_o.blindsLevel))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, hilo(std::move(_o.hilo))
	, stakes(std::move(_o.stakes))
{
}

TournClient::LobbyData_Betting& TournClient::LobbyData_Betting::operator=(LobbyData_Betting&& _o)
{
	if(this != &_o)
	{
		blindsLevel = std::move(_o.blindsLevel);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		hilo = std::move(_o.hilo);
		stakes = std::move(_o.stakes);
	}
	return *this;
}

#endif

void TournClient::LobbyData_Betting::clear()
{
	blindsLevel = 0;
	handType = 0;
	structure = 0;
	hilo = 0;
	stakes.clear();
}

bool TournClient::LobbyData_Betting::equals(const LobbyData_Betting& _o) const
{
	return blindsLevel == _o.blindsLevel &&
		handType == _o.handType &&
		structure == _o.structure &&
		hilo == _o.hilo &&
		stakes.equals(_o.stakes);
}

const char *TournClient::LobbyData_Betting::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("blindsLevel=");
	_buf.appendUint(blindsLevel);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("hilo=");
	_buf.appendUint(hilo);
	_buf.append(',');
	_buf.append("stakes=");
	stakes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::LobbyData_Betting::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("blindsLevel", blindsLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("hilo", hilo, _buf);
	stakes.toXmlString("stakes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::LobbyData_Betting::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("blindsLevel"))
		{
			blindsLevel = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hilo"))
		{
			hilo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, stakes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::LobbyData_Betting::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(blindsLevel);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(hilo);
	stakes.composeMsg(_msg, _ignoreJSON);
}

void TournClient::LobbyData_Betting::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(blindsLevel);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(hilo);
	stakes.parseMsg(_parser);
}

const char *TournClient::LobbyData_Betting::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("blindsLevel", blindsLevel);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("hilo", hilo);
	_jsonstr.compose("stakes", stakes);
	return _buf.c_str();
}

void TournClient::LobbyData_Betting::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("blindsLevel", blindsLevel);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("hilo", hilo);
	_jparser.parseByNameThrow("stakes", stakes);
}

/* static */ void TournClient::LobbyData_Betting::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE blindsLevel; _jparser.validateByNameThrow("blindsLevel", blindsLevel);
	AtfValidator::validateInt(_descr, "blindsLevel", blindsLevel, _checker, __FILE__, __LINE__);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE hilo; _jparser.validateByNameThrow("hilo", hilo);
	AtfValidator::validateInt(_descr, "hilo", hilo, _checker, __FILE__, __LINE__);
	TableCommon::TableStakes stakes; _jparser.validateByNameThrow("stakes", stakes);
}

/*static*/ void TournClient::LobbyData_Betting::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE blindsLevel; _parser.parseBYTE(blindsLevel);
	AtfValidator::validateInt(_descr, "blindsLevel", blindsLevel, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE hilo; _parser.parseBYTE(hilo);
	AtfValidator::validateInt(_descr, "hilo", hilo, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableCommon::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stakes"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    LobbyData_MultidayTourn
//=================================================================

TournClient::LobbyData_MultidayTourn::LobbyData_MultidayTourn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::LobbyData_MultidayTourn::LobbyData_MultidayTourn(LobbyData_MultidayTourn&& _o)
	: mt(std::move(_o.mt))
{
}

TournClient::LobbyData_MultidayTourn& TournClient::LobbyData_MultidayTourn::operator=(LobbyData_MultidayTourn&& _o)
{
	if(this != &_o)
	{
		mt = std::move(_o.mt);
	}
	return *this;
}

#endif

void TournClient::LobbyData_MultidayTourn::clear()
{
	mt.clear();
}

bool TournClient::LobbyData_MultidayTourn::equals(const LobbyData_MultidayTourn& _o) const
{
	return mt.equals(_o.mt);
}

const char *TournClient::LobbyData_MultidayTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("mt=");
	mt.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::LobbyData_MultidayTourn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	mt.toXmlString("mt", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::LobbyData_MultidayTourn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("mt"))
		{
			if(!Atf::AtfTempl< MultidayTourn >::FromXmlString(_value, mt)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::LobbyData_MultidayTourn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(LobbyData_MultidayTourn())) // not empty
	{
		mt.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TournClient::LobbyData_MultidayTourn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	mt.parseMsg(_parser0);
}

const char *TournClient::LobbyData_MultidayTourn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("mt", mt);
	return _buf.c_str();
}

void TournClient::LobbyData_MultidayTourn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("mt", mt);
}

/* static */ void TournClient::LobbyData_MultidayTourn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	MultidayTourn mt; _jparser.validateByNameThrow("mt", mt);
}

/*static*/ void TournClient::LobbyData_MultidayTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	MultidayTourn::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("mt"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_ParticipantsInfo
//=================================================================

TournClient::P_ParticipantsInfo::P_ParticipantsInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::P_ParticipantsInfo::P_ParticipantsInfo(P_ParticipantsInfo&& _o)
	: name(std::move(_o.name))
	, chips(std::move(_o.chips))
	, payment0(std::move(_o.payment0))
	, payment1(std::move(_o.payment1))
{
}

TournClient::P_ParticipantsInfo& TournClient::P_ParticipantsInfo::operator=(P_ParticipantsInfo&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		chips = std::move(_o.chips);
		payment0 = std::move(_o.payment0);
		payment1 = std::move(_o.payment1);
	}
	return *this;
}

#endif

void TournClient::P_ParticipantsInfo::clear()
{
	name.clear();
	chips = 0;
	payment0 = 0;
	payment1 = 0;
}

bool TournClient::P_ParticipantsInfo::equals(const P_ParticipantsInfo& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		chips == _o.chips &&
		payment0 == _o.payment0 &&
		payment1 == _o.payment1;
}

const char *TournClient::P_ParticipantsInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("payment0=");
	_buf.appendInt(payment0);
	_buf.append(',');
	_buf.append("payment1=");
	_buf.appendInt(payment1);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::P_ParticipantsInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("payment0", payment0, _buf);
	Atf::XmlElement::encodeAsXmlElement("payment1", payment1, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::P_ParticipantsInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("chips"))
		{
			chips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("payment0"))
		{
			payment0 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("payment1"))
		{
			payment1 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::P_ParticipantsInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
	_msg.composeINT32(chips);
	_msg.composeINT32(payment0);
	_msg.composeINT32(payment1);
}

void TournClient::P_ParticipantsInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseINT32(chips);
	_parser.parseINT32(payment0);
	_parser.parseINT32(payment1);
}

const char *TournClient::P_ParticipantsInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("payment0", payment0);
	_jsonstr.compose("payment1", payment1);
	return _buf.c_str();
}

void TournClient::P_ParticipantsInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("payment0", payment0);
	_jparser.parseByNameThrow("payment1", payment1);
}

/* static */ void TournClient::P_ParticipantsInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 payment0; _jparser.validateByNameThrow("payment0", payment0);
	AtfValidator::validateInt(_descr, "payment0", payment0, _checker, __FILE__, __LINE__);
	INT32 payment1; _jparser.validateByNameThrow("payment1", payment1);
	AtfValidator::validateInt(_descr, "payment1", payment1, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::P_ParticipantsInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	INT32 chips; _parser.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 payment0; _parser.parseINT32(payment0);
	AtfValidator::validateInt(_descr, "payment0", payment0, _checker, __FILE__, __LINE__);
	INT32 payment1; _parser.parseINT32(payment1);
	AtfValidator::validateInt(_descr, "payment1", payment1, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_DealPayout
//=================================================================

TournClient::P_DealPayout::P_DealPayout()
{
	clear();
}

void TournClient::P_DealPayout::clear()
{
	position = 0;
	noDealPayout = 0;
}

bool TournClient::P_DealPayout::equals(const P_DealPayout& _o) const
{
	return position == _o.position &&
		noDealPayout == _o.noDealPayout;
}

const char *TournClient::P_DealPayout::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("position=");
	_buf.appendInt(position);
	_buf.append(',');
	_buf.append("noDealPayout=");
	_buf.appendInt(noDealPayout);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::P_DealPayout::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("position", position, _buf);
	Atf::XmlElement::encodeAsXmlElement("noDealPayout", noDealPayout, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::P_DealPayout::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("position"))
		{
			position = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("noDealPayout"))
		{
			noDealPayout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::P_DealPayout::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(position);
	_msg.composeINT32(noDealPayout);
}

void TournClient::P_DealPayout::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(position);
	_parser.parseINT32(noDealPayout);
}

const char *TournClient::P_DealPayout::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("position", position);
	_jsonstr.compose("noDealPayout", noDealPayout);
	return _buf.c_str();
}

void TournClient::P_DealPayout::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("position", position);
	_jparser.parseByNameThrow("noDealPayout", noDealPayout);
}

/* static */ void TournClient::P_DealPayout::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 position; _jparser.validateByNameThrow("position", position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	INT32 noDealPayout; _jparser.validateByNameThrow("noDealPayout", noDealPayout);
	AtfValidator::validateInt(_descr, "noDealPayout", noDealPayout, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::P_DealPayout::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 position; _parser.parseINT8(position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	INT32 noDealPayout; _parser.parseINT32(noDealPayout);
	AtfValidator::validateInt(_descr, "noDealPayout", noDealPayout, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ExtraInfo_StakesLevel
//=================================================================

TournClient::ExtraInfo_StakesLevel::ExtraInfo_StakesLevel()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::ExtraInfo_StakesLevel::ExtraInfo_StakesLevel(ExtraInfo_StakesLevel&& _o)
	: stakes(std::move(_o.stakes))
	, levelTime(std::move(_o.levelTime))
	, addTimeBank(std::move(_o.addTimeBank))
{
}

TournClient::ExtraInfo_StakesLevel& TournClient::ExtraInfo_StakesLevel::operator=(ExtraInfo_StakesLevel&& _o)
{
	if(this != &_o)
	{
		stakes = std::move(_o.stakes);
		levelTime = std::move(_o.levelTime);
		addTimeBank = std::move(_o.addTimeBank);
	}
	return *this;
}

#endif

void TournClient::ExtraInfo_StakesLevel::clear()
{
	stakes.clear();
	levelTime = 0;
	addTimeBank = 0;
}

bool TournClient::ExtraInfo_StakesLevel::equals(const ExtraInfo_StakesLevel& _o) const
{
	return stakes.equals(_o.stakes) &&
		levelTime == _o.levelTime &&
		addTimeBank == _o.addTimeBank;
}

const char *TournClient::ExtraInfo_StakesLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("stakes=");
	stakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("levelTime=");
	_buf.appendUint(levelTime);
	_buf.append(',');
	_buf.append("addTimeBank=");
	_buf.appendUint(addTimeBank);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::ExtraInfo_StakesLevel::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	stakes.toXmlString("stakes", _buf);
	Atf::XmlElement::encodeAsXmlElement("levelTime", levelTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("addTimeBank", addTimeBank, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::ExtraInfo_StakesLevel::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("stakes"))
		{
			if(!Atf::AtfTempl< TableCommon::TableStakes >::FromXmlString(_value, stakes)) return false;
		}
		else if (_element.equals("levelTime"))
		{
			levelTime = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addTimeBank"))
		{
			addTimeBank = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::ExtraInfo_StakesLevel::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ExtraInfo_StakesLevel())) // not empty
	{
		stakes.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(levelTime);
		_body.composeUINT32(addTimeBank);
	}

	_msg.composeMsgBody(_body);
}

void TournClient::ExtraInfo_StakesLevel::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	stakes.parseMsg(_parser0);
	_parser0.parseUINT32(levelTime);
	_parser0.parseUINT32(addTimeBank);
}

const char *TournClient::ExtraInfo_StakesLevel::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("stakes", stakes);
	_jsonstr.compose("levelTime", levelTime);
	_jsonstr.compose("addTimeBank", addTimeBank);
	return _buf.c_str();
}

void TournClient::ExtraInfo_StakesLevel::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stakes", stakes);
	_jparser.parseByNameThrow("levelTime", levelTime);
	_jparser.parseByNameThrow("addTimeBank", addTimeBank);
}

/* static */ void TournClient::ExtraInfo_StakesLevel::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableCommon::TableStakes stakes; _jparser.validateByNameThrow("stakes", stakes);
	UINT32 levelTime; _jparser.validateByNameThrow("levelTime", levelTime);
	AtfValidator::validateInt(_descr, "levelTime", levelTime, _checker, __FILE__, __LINE__);
	UINT32 addTimeBank; _jparser.validateByNameThrow("addTimeBank", addTimeBank);
	AtfValidator::validateInt(_descr, "addTimeBank", addTimeBank, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::ExtraInfo_StakesLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableCommon::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("stakes"), _fieldsWithUnparsedContent);
	UINT32 levelTime; _parser0.parseUINT32(levelTime);
	AtfValidator::validateInt(_descr, "levelTime", levelTime, _checker, __FILE__, __LINE__);
	UINT32 addTimeBank; _parser0.parseUINT32(addTimeBank);
	AtfValidator::validateInt(_descr, "addTimeBank", addTimeBank, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournExtraSubscr_Prize_Winner
//=================================================================

TournClient::TournExtraSubscr_Prize_Winner::TournExtraSubscr_Prize_Winner()
{
	clear();
}

void TournClient::TournExtraSubscr_Prize_Winner::clear()
{
	amount = 0;
	percent = 0;
}

bool TournClient::TournExtraSubscr_Prize_Winner::equals(const TournExtraSubscr_Prize_Winner& _o) const
{
	return amount == _o.amount &&
		percent == _o.percent;
}

const char *TournClient::TournExtraSubscr_Prize_Winner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("percent=");
	_buf.appendUint(percent);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::TournExtraSubscr_Prize_Winner::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("percent", percent, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::TournExtraSubscr_Prize_Winner::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("percent"))
		{
			percent = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::TournExtraSubscr_Prize_Winner::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(amount);
	_msg.composeBYTE(percent);
}

void TournClient::TournExtraSubscr_Prize_Winner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(amount);
	_parser.parseBYTE(percent);
}

const char *TournClient::TournExtraSubscr_Prize_Winner::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("percent", percent);
	return _buf.c_str();
}

void TournClient::TournExtraSubscr_Prize_Winner::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("percent", percent);
}

/* static */ void TournClient::TournExtraSubscr_Prize_Winner::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE percent; _jparser.validateByNameThrow("percent", percent);
	AtfValidator::validateInt(_descr, "percent", percent, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::TournExtraSubscr_Prize_Winner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE percent; _parser.parseBYTE(percent);
	AtfValidator::validateInt(_descr, "percent", percent, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize_Prize
//=================================================================

TournClient::TournExtraSubscr_Prize_Prize::TournExtraSubscr_Prize_Prize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::TournExtraSubscr_Prize_Prize::TournExtraSubscr_Prize_Prize(TournExtraSubscr_Prize_Prize&& _o)
	: min(std::move(_o.min))
	, max(std::move(_o.max))
	, numTickets(std::move(_o.numTickets))
	, winners(std::move(_o.winners))
{
}

TournClient::TournExtraSubscr_Prize_Prize& TournClient::TournExtraSubscr_Prize_Prize::operator=(TournExtraSubscr_Prize_Prize&& _o)
{
	if(this != &_o)
	{
		min = std::move(_o.min);
		max = std::move(_o.max);
		numTickets = std::move(_o.numTickets);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void TournClient::TournExtraSubscr_Prize_Prize::clear()
{
	min = 0;
	max = 0;
	numTickets = 0;
	winners.clear();
}

bool TournClient::TournExtraSubscr_Prize_Prize::equals(const TournExtraSubscr_Prize_Prize& _o) const
{
	return min == _o.min &&
		max == _o.max &&
		numTickets == _o.numTickets &&
		winners.equals(_o.winners);
}

const char *TournClient::TournExtraSubscr_Prize_Prize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("min=");
	_buf.appendInt(min);
	_buf.append(',');
	_buf.append("max=");
	_buf.appendInt(max);
	_buf.append(',');
	_buf.append("numTickets=");
	_buf.appendInt(numTickets);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::TournExtraSubscr_Prize_Prize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("min", min, _buf);
	Atf::XmlElement::encodeAsXmlElement("max", max, _buf);
	Atf::XmlElement::encodeAsXmlElement("numTickets", numTickets, _buf);
	winners.toXmlString("winners", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::TournExtraSubscr_Prize_Prize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("min"))
		{
			min = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("max"))
		{
			max = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numTickets"))
		{
			numTickets = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winners"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournExtraSubscr_Prize_Winner, 4 > >::FromXmlString(_value, winners)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::TournExtraSubscr_Prize_Prize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(min);
	_msg.composeINT32(max);
	_msg.composeINT32(numTickets);
	winners.composeMsg(_msg, _ignoreJSON);
}

void TournClient::TournExtraSubscr_Prize_Prize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(min);
	_parser.parseINT32(max);
	_parser.parseINT32(numTickets);
	winners.parseMsg(_parser);
}

const char *TournClient::TournExtraSubscr_Prize_Prize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("min", min);
	_jsonstr.compose("max", max);
	_jsonstr.compose("numTickets", numTickets);
	_jsonstr.compose("winners", winners);
	return _buf.c_str();
}

void TournClient::TournExtraSubscr_Prize_Prize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("min", min);
	_jparser.parseByNameThrow("max", max);
	_jparser.parseByNameThrow("numTickets", numTickets);
	_jparser.parseByNameThrow("winners", winners);
}

/* static */ void TournClient::TournExtraSubscr_Prize_Prize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 min; _jparser.validateByNameThrow("min", min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	INT32 max; _jparser.validateByNameThrow("max", max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
	INT32 numTickets; _jparser.validateByNameThrow("numTickets", numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournExtraSubscr_Prize_Winner > winners; _jparser.validateByNameThrow("winners", winners);
	AtfValidator::validateInt(_descr, "winners", winners.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::TournExtraSubscr_Prize_Prize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 min; _parser.parseINT32(min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	INT32 max; _parser.parseINT32(max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
	INT32 numTickets; _parser.parseINT32(numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = Atf::LAtfVector< TournExtraSubscr_Prize_Winner, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Static
//=================================================================

//=================================================================
//                _BountiesType
//=================================================================

TournClient::publication::TournSubscr_Static::_BountiesType::_BountiesType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_Static::_BountiesType::_BountiesType(_BountiesType&& _o)
	: teamProBounties(std::move(_o.teamProBounties))
	, bountyMultipliers(std::move(_o.bountyMultipliers))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TournClient::publication::TournSubscr_Static::_BountiesType& TournClient::publication::TournSubscr_Static::_BountiesType::operator=(_BountiesType&& _o)
{
	if(this != &_o)
	{
		teamProBounties = std::move(_o.teamProBounties);
		bountyMultipliers = std::move(_o.bountyMultipliers);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_Static::_BountiesType::clear()
{
	teamProBounties.clear();
	bountyMultipliers.clear();
	_is_empty_internal = true;
}

bool TournClient::publication::TournSubscr_Static::_BountiesType::equals(const _BountiesType& _o) const
{
	return teamProBounties.equals(_o.teamProBounties) &&
		bountyMultipliers.equals(_o.bountyMultipliers);
}

const char *TournClient::publication::TournSubscr_Static::_BountiesType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("teamProBounties=");
		teamProBounties.toTraceString(_buf);
		_buf.append(',');
		_buf.append("bountyMultipliers=");
		bountyMultipliers.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Static::_BountiesType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		teamProBounties.toXmlString("teamProBounties", _buf);
		bountyMultipliers.toXmlString("bountyMultipliers", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Static::_BountiesType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("teamProBounties"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, teamProBounties)) return false;
		}
		else if (_element.equals("bountyMultipliers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, bountyMultipliers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TournClient::publication::TournSubscr_Static::_BountiesType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		teamProBounties.composeMsg(_msg0, _ignoreJSON);
		bountyMultipliers.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TournClient::publication::TournSubscr_Static::_BountiesType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	teamProBounties.parseMsg(_parser0);
	bountyMultipliers.parseMsg(_parser0);
}

const char *TournClient::publication::TournSubscr_Static::_BountiesType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("teamProBounties", teamProBounties);
		_jsonstr.compose("bountyMultipliers", bountyMultipliers);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Static::_BountiesType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("teamProBounties", teamProBounties);
	_jparser.parseByNameThrow("bountyMultipliers", bountyMultipliers);
}

/* static */ void TournClient::publication::TournSubscr_Static::_BountiesType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< UINT32 > teamProBounties; _jparser.validateByNameThrow("teamProBounties", teamProBounties);
	AtfValidator::validateInt(_descr, "teamProBounties", teamProBounties.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > bountyMultipliers; _jparser.validateByNameThrow("bountyMultipliers", bountyMultipliers);
	AtfValidator::validateInt(_descr, "bountyMultipliers", bountyMultipliers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Static::_BountiesType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szTeamProBounties = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("teamProBounties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "teamProBounties", szTeamProBounties, _checker, __FILE__, __LINE__);
	int szBountyMultipliers = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("bountyMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "bountyMultipliers", szBountyMultipliers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

TournClient::publication::TournSubscr_Static::TournSubscr_Static()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_Static::TournSubscr_Static(TournSubscr_Static&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, startingChips(std::move(_o.startingChips))
	, maxPlayers(std::move(_o.maxPlayers))
	, playersPerTable(std::move(_o.playersPerTable))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, startingTime(std::move(_o.startingTime))
	, registrationStarts(std::move(_o.registrationStarts))
	, registrationEnds(std::move(_o.registrationEnds))
	, seatingStarts(std::move(_o.seatingStarts))
	, minPlayers(std::move(_o.minPlayers))
	, restricted(std::move(_o.restricted))
	, fppReward(std::move(_o.fppReward))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, name(std::move(_o.name))
	, numRebuys(std::move(_o.numRebuys))
	, rebuyChips(std::move(_o.rebuyChips))
	, _obsolete_1(std::move(_o._obsolete_1))
	, rebuyMaxChips(std::move(_o.rebuyMaxChips))
	, numAddOns(std::move(_o.numAddOns))
	, addOnChips(std::move(_o.addOnChips))
	, _obsolete_2(std::move(_o._obsolete_2))
	, addOnMaxChips(std::move(_o.addOnMaxChips))
	, scriptPrizeAddOn(std::move(_o.scriptPrizeAddOn))
	, guaranteedPrizePool(std::move(_o.guaranteedPrizePool))
	, tournFlags(std::move(_o.tournFlags))
	, maxAllIns(std::move(_o.maxAllIns))
	, awardSchema(std::move(_o.awardSchema))
	, timeBank(std::move(_o.timeBank))
	, unregistrationEnds_t(std::move(_o.unregistrationEnds_t))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, satelliteTargetBuyIn(std::move(_o.satelliteTargetBuyIn))
	, rebuyFppPrice(std::move(_o.rebuyFppPrice))
	, addonFppPrice(std::move(_o.addonFppPrice))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, startingTime_t(std::move(_o.startingTime_t))
	, registrationStarts_t(std::move(_o.registrationStarts_t))
	, registrationEnds_t(std::move(_o.registrationEnds_t))
	, seatingStarts_t(std::move(_o.seatingStarts_t))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, tournProp2(std::move(_o.tournProp2))
	, ticketTypes(std::move(_o.ticketTypes))
	, tableLogo(std::move(_o.tableLogo))
	, finalTableText(std::move(_o.finalTableText))
	, chatLang(std::move(_o.chatLang))
	, lobbyRestricted(std::move(_o.lobbyRestricted))
	, fppFraction(std::move(_o.fppFraction))
	, currency(std::move(_o.currency))
	, rebuyFppReward(std::move(_o.rebuyFppReward))
	, addOnFppReward(std::move(_o.addOnFppReward))
	, fppRewardPercent(std::move(_o.fppRewardPercent))
	, nPublishLobbyPlayersLess(std::move(_o.nPublishLobbyPlayersLess))
	, bounty(std::move(_o.bounty))
	, placeHolder(std::move(_o.placeHolder))
	, bounties(std::move(_o.bounties))
	, publPropFlag(std::move(_o.publPropFlag))
	, multiday(std::move(_o.multiday))
	, satelliteTargetReference(std::move(_o.satelliteTargetReference))
	, satelliteTargetReferenceLock(std::move(_o.satelliteTargetReferenceLock))
	, clubId(std::move(_o.clubId))
	, timedTournType(std::move(_o.timedTournType))
	, timedTournLevelsOrMinutes(std::move(_o.timedTournLevelsOrMinutes))
	, timedTournPayoutStructure(std::move(_o.timedTournPayoutStructure))
	, _obsolete_3(std::move(_o._obsolete_3))
	, vppToPublish(std::move(_o.vppToPublish))
	, speedDisplay(std::move(_o.speedDisplay))
	, tournBrand(std::move(_o.tournBrand))
	, scalePM(std::move(_o.scalePM))
	, blitzNormalDealingThreshold(std::move(_o.blitzNormalDealingThreshold))
	, _obsolete_4(std::move(_o._obsolete_4))
	, progressiveKnockout(std::move(_o.progressiveKnockout))
	, tableText(std::move(_o.tableText))
	, reEntryAllowed(std::move(_o.reEntryAllowed))
	, tournMask(std::move(_o.tournMask))
	, tournMask2(std::move(_o.tournMask2))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, internalReference(std::move(_o.internalReference))
	, favoriteReference(std::move(_o.favoriteReference))
	, ticketPrice(std::move(_o.ticketPrice))
	, tournFlags2(std::move(_o.tournFlags2))
	, cannotUnregisterFromTarget(std::move(_o.cannotUnregisterFromTarget))
	, nStackInfoMsg(std::move(_o.nStackInfoMsg))
	, targetWhenStarts(std::move(_o.targetWhenStarts))
	, admission(std::move(_o.admission))
	, siteMask(std::move(_o.siteMask))
	, publStartLevel(std::move(_o.publStartLevel))
	, tournMask5(std::move(_o.tournMask5))
	, tournMask6(std::move(_o.tournMask6))
	, dealExclusionType(std::move(_o.dealExclusionType))
	, dealExclusionValue(std::move(_o.dealExclusionValue))
	, timedTournPlayersPercent(std::move(_o.timedTournPlayersPercent))
	, _obsolete_5(std::move(_o._obsolete_5))
	, spinGoStartDelay(std::move(_o.spinGoStartDelay))
	, rmPmLobby(std::move(_o.rmPmLobby))
	, brandMask(std::move(_o.brandMask))
	, playerKnockOutAddOn(std::move(_o.playerKnockOutAddOn))
	, totalKnockOutAddOn(std::move(_o.totalKnockOutAddOn))
	, knockOutAddOnProgressive(std::move(_o.knockOutAddOnProgressive))
	, sitGoStarterGameId(std::move(_o.sitGoStarterGameId))
	, numStandardButton(std::move(_o.numStandardButton))
	, lateRegDelta(std::move(_o.lateRegDelta))
	, finalTablePlusOne(std::move(_o.finalTablePlusOne))
	, multidayIndex(std::move(_o.multidayIndex))
	, multiDayVec(std::move(_o.multiDayVec))
	, criteria(std::move(_o.criteria))
	, groupReference(std::move(_o.groupReference))
	, tournGroup(std::move(_o.tournGroup))
	, prizePool(std::move(_o.prizePool))
	, admissions(std::move(_o.admissions))
	, pokerNgGroup(std::move(_o.pokerNgGroup))
	, siteMaskEx(std::move(_o.siteMaskEx))
	, pppId(std::move(_o.pppId))
	, tableTrait(std::move(_o.tableTrait))
	, highlightColor(std::move(_o.highlightColor))
{
}

TournClient::publication::TournSubscr_Static& TournClient::publication::TournSubscr_Static::operator=(TournSubscr_Static&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		startingChips = std::move(_o.startingChips);
		maxPlayers = std::move(_o.maxPlayers);
		playersPerTable = std::move(_o.playersPerTable);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		startingTime = std::move(_o.startingTime);
		registrationStarts = std::move(_o.registrationStarts);
		registrationEnds = std::move(_o.registrationEnds);
		seatingStarts = std::move(_o.seatingStarts);
		minPlayers = std::move(_o.minPlayers);
		restricted = std::move(_o.restricted);
		fppReward = std::move(_o.fppReward);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		name = std::move(_o.name);
		numRebuys = std::move(_o.numRebuys);
		rebuyChips = std::move(_o.rebuyChips);
		_obsolete_1 = std::move(_o._obsolete_1);
		rebuyMaxChips = std::move(_o.rebuyMaxChips);
		numAddOns = std::move(_o.numAddOns);
		addOnChips = std::move(_o.addOnChips);
		_obsolete_2 = std::move(_o._obsolete_2);
		addOnMaxChips = std::move(_o.addOnMaxChips);
		scriptPrizeAddOn = std::move(_o.scriptPrizeAddOn);
		guaranteedPrizePool = std::move(_o.guaranteedPrizePool);
		tournFlags = std::move(_o.tournFlags);
		maxAllIns = std::move(_o.maxAllIns);
		awardSchema = std::move(_o.awardSchema);
		timeBank = std::move(_o.timeBank);
		unregistrationEnds_t = std::move(_o.unregistrationEnds_t);
		satelliteTarget = std::move(_o.satelliteTarget);
		satelliteTargetBuyIn = std::move(_o.satelliteTargetBuyIn);
		rebuyFppPrice = std::move(_o.rebuyFppPrice);
		addonFppPrice = std::move(_o.addonFppPrice);
		isPlayMoney = std::move(_o.isPlayMoney);
		startingTime_t = std::move(_o.startingTime_t);
		registrationStarts_t = std::move(_o.registrationStarts_t);
		registrationEnds_t = std::move(_o.registrationEnds_t);
		seatingStarts_t = std::move(_o.seatingStarts_t);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		tournProp2 = std::move(_o.tournProp2);
		ticketTypes = std::move(_o.ticketTypes);
		tableLogo = std::move(_o.tableLogo);
		finalTableText = std::move(_o.finalTableText);
		chatLang = std::move(_o.chatLang);
		lobbyRestricted = std::move(_o.lobbyRestricted);
		fppFraction = std::move(_o.fppFraction);
		currency = std::move(_o.currency);
		rebuyFppReward = std::move(_o.rebuyFppReward);
		addOnFppReward = std::move(_o.addOnFppReward);
		fppRewardPercent = std::move(_o.fppRewardPercent);
		nPublishLobbyPlayersLess = std::move(_o.nPublishLobbyPlayersLess);
		bounty = std::move(_o.bounty);
		placeHolder = std::move(_o.placeHolder);
		bounties = std::move(_o.bounties);
		publPropFlag = std::move(_o.publPropFlag);
		multiday = std::move(_o.multiday);
		satelliteTargetReference = std::move(_o.satelliteTargetReference);
		satelliteTargetReferenceLock = std::move(_o.satelliteTargetReferenceLock);
		clubId = std::move(_o.clubId);
		timedTournType = std::move(_o.timedTournType);
		timedTournLevelsOrMinutes = std::move(_o.timedTournLevelsOrMinutes);
		timedTournPayoutStructure = std::move(_o.timedTournPayoutStructure);
		_obsolete_3 = std::move(_o._obsolete_3);
		vppToPublish = std::move(_o.vppToPublish);
		speedDisplay = std::move(_o.speedDisplay);
		tournBrand = std::move(_o.tournBrand);
		scalePM = std::move(_o.scalePM);
		blitzNormalDealingThreshold = std::move(_o.blitzNormalDealingThreshold);
		_obsolete_4 = std::move(_o._obsolete_4);
		progressiveKnockout = std::move(_o.progressiveKnockout);
		tableText = std::move(_o.tableText);
		reEntryAllowed = std::move(_o.reEntryAllowed);
		tournMask = std::move(_o.tournMask);
		tournMask2 = std::move(_o.tournMask2);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		internalReference = std::move(_o.internalReference);
		favoriteReference = std::move(_o.favoriteReference);
		ticketPrice = std::move(_o.ticketPrice);
		tournFlags2 = std::move(_o.tournFlags2);
		cannotUnregisterFromTarget = std::move(_o.cannotUnregisterFromTarget);
		nStackInfoMsg = std::move(_o.nStackInfoMsg);
		targetWhenStarts = std::move(_o.targetWhenStarts);
		admission = std::move(_o.admission);
		siteMask = std::move(_o.siteMask);
		publStartLevel = std::move(_o.publStartLevel);
		tournMask5 = std::move(_o.tournMask5);
		tournMask6 = std::move(_o.tournMask6);
		dealExclusionType = std::move(_o.dealExclusionType);
		dealExclusionValue = std::move(_o.dealExclusionValue);
		timedTournPlayersPercent = std::move(_o.timedTournPlayersPercent);
		_obsolete_5 = std::move(_o._obsolete_5);
		spinGoStartDelay = std::move(_o.spinGoStartDelay);
		rmPmLobby = std::move(_o.rmPmLobby);
		brandMask = std::move(_o.brandMask);
		playerKnockOutAddOn = std::move(_o.playerKnockOutAddOn);
		totalKnockOutAddOn = std::move(_o.totalKnockOutAddOn);
		knockOutAddOnProgressive = std::move(_o.knockOutAddOnProgressive);
		sitGoStarterGameId = std::move(_o.sitGoStarterGameId);
		numStandardButton = std::move(_o.numStandardButton);
		lateRegDelta = std::move(_o.lateRegDelta);
		finalTablePlusOne = std::move(_o.finalTablePlusOne);
		multidayIndex = std::move(_o.multidayIndex);
		multiDayVec = std::move(_o.multiDayVec);
		criteria = std::move(_o.criteria);
		groupReference = std::move(_o.groupReference);
		tournGroup = std::move(_o.tournGroup);
		prizePool = std::move(_o.prizePool);
		admissions = std::move(_o.admissions);
		pokerNgGroup = std::move(_o.pokerNgGroup);
		siteMaskEx = std::move(_o.siteMaskEx);
		pppId = std::move(_o.pppId);
		tableTrait = std::move(_o.tableTrait);
		highlightColor = std::move(_o.highlightColor);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_Static::clear()
{
	tournamentId = 0;
	buyIn = 0;
	rake = 0;
	startingChips = 0;
	maxPlayers = 0;
	playersPerTable = 0;
	gameType = 0;
	isHiLo = 0;
	startingTime.setNull();
	registrationStarts.setNull();
	registrationEnds.setNull();
	seatingStarts.setNull();
	minPlayers = 0;
	restricted = 0;
	fppReward = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	name.clear();
	numRebuys = 0;
	rebuyChips = 0;
	_obsolete_1 = 0;
	rebuyMaxChips = 0;
	numAddOns = 0;
	addOnChips = 0;
	_obsolete_2 = 0;
	addOnMaxChips = 0;
	scriptPrizeAddOn = 0;
	guaranteedPrizePool = 0;
	tournFlags = 0;
	maxAllIns = 0;
	awardSchema = 0;
	timeBank = 0;
	unregistrationEnds_t = 0;
	satelliteTarget = 0;
	satelliteTargetBuyIn = 0;
	rebuyFppPrice = 0;
	addonFppPrice = 0;
	isPlayMoney = 0;
	startingTime_t = 0;
	registrationStarts_t = 0;
	registrationEnds_t = 0;
	seatingStarts_t = 0;
	tournFlagsServInt = 0;
	tournProp2 = 0;
	ticketTypes.clear();
	tableLogo = 0;
	finalTableText.clear();
	chatLang = 0;
	lobbyRestricted = 0;
	fppFraction = 0;
	currency.clear();
	rebuyFppReward = 0;
	addOnFppReward = 0;
	fppRewardPercent = 0;
	nPublishLobbyPlayersLess = 0;
	bounty = 0;
	placeHolder = 0;
	bounties.clear();
	publPropFlag = 0;
	multiday.clear();
	satelliteTargetReference.clear();
	satelliteTargetReferenceLock = 0;
	clubId = 0;
	timedTournType = 0;
	timedTournLevelsOrMinutes = 0;
	timedTournPayoutStructure = 0;
	_obsolete_3 = false;
	vppToPublish.clear();
	speedDisplay = 0;
	tournBrand.clear();
	scalePM = 0;
	blitzNormalDealingThreshold = 0;
	_obsolete_4 = false;
	progressiveKnockout = 0;
	tableText.clear();
	reEntryAllowed = 0;
	tournMask = 0;
	tournMask2 = 0;
	tournMask3 = 0;
	tournMask4 = 0;
	internalReference.clear();
	favoriteReference.clear();
	ticketPrice = 0;
	tournFlags2 = 0;
	cannotUnregisterFromTarget = false;
	nStackInfoMsg.clear();
	targetWhenStarts.setNull();
	admission.clear();
	siteMask = 0;
	publStartLevel = 0;
	tournMask5 = 0;
	tournMask6 = 0;
	dealExclusionType = 0;
	dealExclusionValue = 0;
	timedTournPlayersPercent = 0;
	_obsolete_5 = 0;
	spinGoStartDelay = 0;
	rmPmLobby = 0;
	brandMask = 0;
	playerKnockOutAddOn = 0;
	totalKnockOutAddOn = 0;
	knockOutAddOnProgressive = 0;
	sitGoStarterGameId = 0;
	numStandardButton = 0;
	lateRegDelta = 0;
	finalTablePlusOne = 0;
	multidayIndex = 0;
	multiDayVec.clear();
	criteria.clear();
	groupReference.clear();
	tournGroup = 0;
	prizePool = 0;
	admissions.clear();
	pokerNgGroup.clear();
	siteMaskEx.clear();
	pppId = 0;
	tableTrait.clear();
	highlightColor.clear();
}

bool TournClient::publication::TournSubscr_Static::equals(const TournSubscr_Static& _o) const
{
	return tournamentId == _o.tournamentId &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		startingChips == _o.startingChips &&
		maxPlayers == _o.maxPlayers &&
		playersPerTable == _o.playersPerTable &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		startingTime.equals(_o.startingTime) &&
		registrationStarts.equals(_o.registrationStarts) &&
		registrationEnds.equals(_o.registrationEnds) &&
		seatingStarts.equals(_o.seatingStarts) &&
		minPlayers == _o.minPlayers &&
		restricted == _o.restricted &&
		fppReward == _o.fppReward &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		Atf::atfPStringEquals(name, _o.name) &&
		numRebuys == _o.numRebuys &&
		rebuyChips == _o.rebuyChips &&
		_obsolete_1 == _o._obsolete_1 &&
		rebuyMaxChips == _o.rebuyMaxChips &&
		numAddOns == _o.numAddOns &&
		addOnChips == _o.addOnChips &&
		_obsolete_2 == _o._obsolete_2 &&
		addOnMaxChips == _o.addOnMaxChips &&
		scriptPrizeAddOn == _o.scriptPrizeAddOn &&
		guaranteedPrizePool == _o.guaranteedPrizePool &&
		tournFlags == _o.tournFlags &&
		maxAllIns == _o.maxAllIns &&
		awardSchema == _o.awardSchema &&
		timeBank == _o.timeBank &&
		unregistrationEnds_t == _o.unregistrationEnds_t &&
		satelliteTarget == _o.satelliteTarget &&
		satelliteTargetBuyIn == _o.satelliteTargetBuyIn &&
		rebuyFppPrice == _o.rebuyFppPrice &&
		addonFppPrice == _o.addonFppPrice &&
		isPlayMoney == _o.isPlayMoney &&
		startingTime_t == _o.startingTime_t &&
		registrationStarts_t == _o.registrationStarts_t &&
		registrationEnds_t == _o.registrationEnds_t &&
		seatingStarts_t == _o.seatingStarts_t &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		tournProp2 == _o.tournProp2 &&
		ticketTypes.equals(_o.ticketTypes) &&
		tableLogo == _o.tableLogo &&
		finalTableText.equals(_o.finalTableText) &&
		chatLang == _o.chatLang &&
		lobbyRestricted == _o.lobbyRestricted &&
		fppFraction == _o.fppFraction &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		rebuyFppReward == _o.rebuyFppReward &&
		addOnFppReward == _o.addOnFppReward &&
		fppRewardPercent == _o.fppRewardPercent &&
		nPublishLobbyPlayersLess == _o.nPublishLobbyPlayersLess &&
		bounty == _o.bounty &&
		placeHolder == _o.placeHolder &&
		bounties.equals(_o.bounties) &&
		publPropFlag == _o.publPropFlag &&
		multiday.equals(_o.multiday) &&
		Atf::atfPStringEquals(satelliteTargetReference, _o.satelliteTargetReference) &&
		satelliteTargetReferenceLock == _o.satelliteTargetReferenceLock &&
		clubId == _o.clubId &&
		timedTournType == _o.timedTournType &&
		timedTournLevelsOrMinutes == _o.timedTournLevelsOrMinutes &&
		timedTournPayoutStructure == _o.timedTournPayoutStructure &&
		_obsolete_3 == _o._obsolete_3 &&
		vppToPublish.equals(_o.vppToPublish) &&
		speedDisplay == _o.speedDisplay &&
		Atf::atfPStringEquals(tournBrand, _o.tournBrand) &&
		scalePM == _o.scalePM &&
		blitzNormalDealingThreshold == _o.blitzNormalDealingThreshold &&
		_obsolete_4 == _o._obsolete_4 &&
		progressiveKnockout == _o.progressiveKnockout &&
		tableText.equals(_o.tableText) &&
		reEntryAllowed == _o.reEntryAllowed &&
		tournMask == _o.tournMask &&
		tournMask2 == _o.tournMask2 &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		Atf::atfPStringEquals(internalReference, _o.internalReference) &&
		Atf::atfPStringEquals(favoriteReference, _o.favoriteReference) &&
		ticketPrice == _o.ticketPrice &&
		tournFlags2 == _o.tournFlags2 &&
		cannotUnregisterFromTarget == _o.cannotUnregisterFromTarget &&
		nStackInfoMsg.equals(_o.nStackInfoMsg) &&
		targetWhenStarts.equals(_o.targetWhenStarts) &&
		Atf::atfPStringEquals(admission, _o.admission) &&
		siteMask == _o.siteMask &&
		publStartLevel == _o.publStartLevel &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		dealExclusionType == _o.dealExclusionType &&
		dealExclusionValue == _o.dealExclusionValue &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		_obsolete_5 == _o._obsolete_5 &&
		spinGoStartDelay == _o.spinGoStartDelay &&
		rmPmLobby == _o.rmPmLobby &&
		brandMask == _o.brandMask &&
		playerKnockOutAddOn == _o.playerKnockOutAddOn &&
		totalKnockOutAddOn == _o.totalKnockOutAddOn &&
		knockOutAddOnProgressive == _o.knockOutAddOnProgressive &&
		sitGoStarterGameId == _o.sitGoStarterGameId &&
		numStandardButton == _o.numStandardButton &&
		lateRegDelta == _o.lateRegDelta &&
		finalTablePlusOne == _o.finalTablePlusOne &&
		multidayIndex == _o.multidayIndex &&
		multiDayVec.equals(_o.multiDayVec) &&
		Atf::atfPStringEquals(criteria, _o.criteria) &&
		Atf::atfPStringEquals(groupReference, _o.groupReference) &&
		tournGroup == _o.tournGroup &&
		prizePool == _o.prizePool &&
		admissions.equals(_o.admissions) &&
		Atf::atfPStringEquals(pokerNgGroup, _o.pokerNgGroup) &&
		siteMaskEx.equals(_o.siteMaskEx) &&
		pppId == _o.pppId &&
		Atf::atfPStringEquals(tableTrait, _o.tableTrait) &&
		Atf::atfPStringEquals(highlightColor, _o.highlightColor);
}

const char *TournClient::publication::TournSubscr_Static::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("startingChips=");
	_buf.appendInt(startingChips);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendInt(maxPlayers);
	_buf.append(',');
	_buf.append("playersPerTable=");
	_buf.appendInt(playersPerTable);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("startingTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startingTime);
	_buf.append(',');
	_buf.append("registrationStarts=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, registrationStarts);
	_buf.append(',');
	_buf.append("registrationEnds=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, registrationEnds);
	_buf.append(',');
	_buf.append("seatingStarts=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, seatingStarts);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendInt(minPlayers);
	_buf.append(',');
	_buf.append("restricted=");
	_buf.appendUint(restricted);
	_buf.append(',');
	_buf.append("fppReward=");
	_buf.appendInt(fppReward);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendInt(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("numRebuys=");
	_buf.appendInt(numRebuys);
	_buf.append(',');
	_buf.append("rebuyChips=");
	_buf.appendInt(rebuyChips);
	_buf.append(',');
	_buf.append("_obsolete_1=");
	_buf.appendInt(_obsolete_1);
	_buf.append(',');
	_buf.append("rebuyMaxChips=");
	_buf.appendInt(rebuyMaxChips);
	_buf.append(',');
	_buf.append("numAddOns=");
	_buf.appendInt(numAddOns);
	_buf.append(',');
	_buf.append("addOnChips=");
	_buf.appendInt(addOnChips);
	_buf.append(',');
	_buf.append("_obsolete_2=");
	_buf.appendInt(_obsolete_2);
	_buf.append(',');
	_buf.append("addOnMaxChips=");
	_buf.appendInt(addOnMaxChips);
	_buf.append(',');
	_buf.append("scriptPrizeAddOn=");
	_buf.appendInt(scriptPrizeAddOn);
	_buf.append(',');
	_buf.append("guaranteedPrizePool=");
	_buf.appendInt(guaranteedPrizePool);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("maxAllIns=");
	_buf.appendInt(maxAllIns);
	_buf.append(',');
	_buf.append("awardSchema=");
	_buf.appendUint(awardSchema);
	_buf.append(',');
	_buf.append("timeBank=");
	_buf.appendUint(timeBank);
	_buf.append(',');
	_buf.append("unregistrationEnds_t=");
	_buf.appendInt(unregistrationEnds_t);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("satelliteTargetBuyIn=");
	_buf.appendInt(satelliteTargetBuyIn);
	_buf.append(',');
	_buf.append("rebuyFppPrice=");
	_buf.appendInt(rebuyFppPrice);
	_buf.append(',');
	_buf.append("addonFppPrice=");
	_buf.appendInt(addonFppPrice);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("startingTime_t=");
	_buf.appendUint(startingTime_t);
	_buf.append(',');
	_buf.append("registrationStarts_t=");
	_buf.appendUint(registrationStarts_t);
	_buf.append(',');
	_buf.append("registrationEnds_t=");
	_buf.appendUint(registrationEnds_t);
	_buf.append(',');
	_buf.append("seatingStarts_t=");
	_buf.appendUint(seatingStarts_t);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("tournProp2=");
	_buf.appendUint(tournProp2);
	_buf.append(',');
	_buf.append("ticketTypes=");
	ticketTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableLogo=");
	_buf.appendUint(tableLogo);
	_buf.append(',');
	_buf.append("finalTableText=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, finalTableText);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("lobbyRestricted=");
	_buf.appendUint(lobbyRestricted);
	_buf.append(',');
	_buf.append("fppFraction=");
	_buf.appendInt(fppFraction);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("rebuyFppReward=");
	_buf.appendInt(rebuyFppReward);
	_buf.append(',');
	_buf.append("addOnFppReward=");
	_buf.appendInt(addOnFppReward);
	_buf.append(',');
	_buf.append("fppRewardPercent=");
	_buf.appendInt(fppRewardPercent);
	_buf.append(',');
	_buf.append("nPublishLobbyPlayersLess=");
	_buf.appendUint(nPublishLobbyPlayersLess);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt(bounty);
	_buf.append(',');
	_buf.append("placeHolder=");
	_buf.appendUint(placeHolder);
	_buf.append(',');
	_buf.append("bounties=");
	bounties.toTraceString(_buf);
	_buf.append(',');
	_buf.append("publPropFlag=");
	_buf.appendUint(publPropFlag);
	_buf.append(',');
	_buf.append("multiday=");
	multiday.toTraceString(_buf);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("satelliteTargetReferenceLock=");
	_buf.appendUint(satelliteTargetReferenceLock);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournLevelsOrMinutes=");
	_buf.appendUint(timedTournLevelsOrMinutes);
	_buf.append(',');
	_buf.append("timedTournPayoutStructure=");
	_buf.appendUint(timedTournPayoutStructure);
	_buf.append(',');
	_buf.append("_obsolete_3=");
	_buf.appendUint(_obsolete_3);
	_buf.append(',');
	_buf.append("vppToPublish=");
	vppToPublish.toTraceString(_buf);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("tournBrand=");
	_buf.append(tournBrand);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append(',');
	_buf.append("blitzNormalDealingThreshold=");
	_buf.appendUint(blitzNormalDealingThreshold);
	_buf.append(',');
	_buf.append("_obsolete_4=");
	_buf.appendUint(_obsolete_4);
	_buf.append(',');
	_buf.append("progressiveKnockout=");
	_buf.appendUint(progressiveKnockout);
	_buf.append(',');
	_buf.append("tableText=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, tableText);
	_buf.append(',');
	_buf.append("reEntryAllowed=");
	_buf.appendUint(reEntryAllowed);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("internalReference=");
	_buf.append(internalReference);
	_buf.append(',');
	_buf.append("favoriteReference=");
	_buf.append(favoriteReference);
	_buf.append(',');
	_buf.append("ticketPrice=");
	_buf.appendInt64(ticketPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("cannotUnregisterFromTarget=");
	_buf.appendUint(cannotUnregisterFromTarget);
	_buf.append(',');
	_buf.append("nStackInfoMsg=");
	nStackInfoMsg.toTraceString(_buf);
	_buf.append(',');
	_buf.append("targetWhenStarts=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, targetWhenStarts);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("publStartLevel=");
	_buf.appendUint(publStartLevel);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("dealExclusionType=");
	_buf.appendUint(dealExclusionType);
	_buf.append(',');
	_buf.append("dealExclusionValue=");
	_buf.appendInt(dealExclusionValue);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("_obsolete_5=");
	_buf.appendInt(_obsolete_5);
	_buf.append(',');
	_buf.append("spinGoStartDelay=");
	_buf.appendInt(spinGoStartDelay);
	_buf.append(',');
	_buf.append("rmPmLobby=");
	_buf.appendUint(rmPmLobby);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("playerKnockOutAddOn=");
	_buf.appendInt(playerKnockOutAddOn);
	_buf.append(',');
	_buf.append("totalKnockOutAddOn=");
	_buf.appendInt(totalKnockOutAddOn);
	_buf.append(',');
	_buf.append("knockOutAddOnProgressive=");
	_buf.appendUint(knockOutAddOnProgressive);
	_buf.append(',');
	_buf.append("sitGoStarterGameId=");
	_buf.appendUint(sitGoStarterGameId);
	_buf.append(',');
	_buf.append("numStandardButton=");
	_buf.appendUint(numStandardButton);
	_buf.append(',');
	_buf.append("lateRegDelta=");
	_buf.appendInt(lateRegDelta);
	_buf.append(',');
	_buf.append("finalTablePlusOne=");
	_buf.appendInt(finalTablePlusOne);
	_buf.append(',');
	_buf.append("multidayIndex=");
	_buf.appendInt(multidayIndex);
	_buf.append(',');
	_buf.append("multiDayVec=");
	multiDayVec.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("groupReference=");
	_buf.append(groupReference);
	_buf.append(',');
	_buf.append("tournGroup=");
	_buf.appendInt(tournGroup);
	_buf.append(',');
	_buf.append("prizePool=");
	_buf.appendInt(prizePool);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pokerNgGroup=");
	_buf.append(pokerNgGroup);
	_buf.append(',');
	_buf.append("siteMaskEx=");
	siteMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("tableTrait=");
	_buf.append(tableTrait);
	_buf.append(',');
	_buf.append("highlightColor=");
	_buf.append(highlightColor);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Static::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingChips", startingChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("playersPerTable", playersPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startingTime", startingTime);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "registrationStarts", registrationStarts);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "registrationEnds", registrationEnds);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "seatingStarts", seatingStarts);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("restricted", restricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppReward", fppReward, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRestricted", isRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPwdProtected", isPwdProtected, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("numRebuys", numRebuys, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyChips", rebuyChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_1", _obsolete_1, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyMaxChips", rebuyMaxChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("numAddOns", numAddOns, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnChips", addOnChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_2", _obsolete_2, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnMaxChips", addOnMaxChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("scriptPrizeAddOn", scriptPrizeAddOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("guaranteedPrizePool", guaranteedPrizePool, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxAllIns", maxAllIns, _buf);
	Atf::XmlElement::encodeAsXmlElement("awardSchema", awardSchema, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeBank", timeBank, _buf);
	Atf::XmlElement::encodeAsXmlElement("unregistrationEnds_t", unregistrationEnds_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTarget", satelliteTarget, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetBuyIn", satelliteTargetBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyFppPrice", rebuyFppPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("addonFppPrice", addonFppPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingTime_t", startingTime_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("registrationStarts_t", registrationStarts_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("registrationEnds_t", registrationEnds_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("seatingStarts_t", seatingStarts_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournProp2", tournProp2, _buf);
	ticketTypes.toXmlString("ticketTypes", _buf);
	Atf::XmlElement::encodeAsXmlElement("tableLogo", tableLogo, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "finalTableText", finalTableText);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("lobbyRestricted", lobbyRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppFraction", fppFraction, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyFppReward", rebuyFppReward, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnFppReward", addOnFppReward, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppRewardPercent", fppRewardPercent, _buf);
	Atf::XmlElement::encodeAsXmlElement("nPublishLobbyPlayersLess", nPublishLobbyPlayersLess, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("placeHolder", placeHolder, _buf);
	bounties.toXmlString("bounties", _buf);
	Atf::XmlElement::encodeAsXmlElement("publPropFlag", publPropFlag, _buf);
	multiday.toXmlString("multiday", _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetReference", satelliteTargetReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("satelliteTargetReferenceLock", satelliteTargetReferenceLock, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournType", timedTournType, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournLevelsOrMinutes", timedTournLevelsOrMinutes, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPayoutStructure", timedTournPayoutStructure, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_3", _obsolete_3, _buf);
	vppToPublish.toXmlString("vppToPublish", _buf);
	Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournBrand", tournBrand, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzNormalDealingThreshold", blitzNormalDealingThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_4", _obsolete_4, _buf);
	Atf::XmlElement::encodeAsXmlElement("progressiveKnockout", progressiveKnockout, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "tableText", tableText);
	Atf::XmlElement::encodeAsXmlElement("reEntryAllowed", reEntryAllowed, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask", tournMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask2", tournMask2, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask3", tournMask3, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask4", tournMask4, _buf);
	Atf::XmlElement::encodeAsXmlElement("internalReference", internalReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("favoriteReference", favoriteReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketPrice", ticketPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("cannotUnregisterFromTarget", cannotUnregisterFromTarget, _buf);
	nStackInfoMsg.toXmlString("nStackInfoMsg", _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "targetWhenStarts", targetWhenStarts);
	Atf::XmlElement::encodeAsXmlElement("admission", admission, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("publStartLevel", publStartLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask5", tournMask5, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMask6", tournMask6, _buf);
	Atf::XmlElement::encodeAsXmlElement("dealExclusionType", dealExclusionType, _buf);
	Atf::XmlElement::encodeAsXmlElement("dealExclusionValue", dealExclusionValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPlayersPercent", timedTournPlayersPercent, _buf);
	Atf::XmlElement::encodeAsXmlElement("_obsolete_5", _obsolete_5, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinGoStartDelay", spinGoStartDelay, _buf);
	Atf::XmlElement::encodeAsXmlElement("rmPmLobby", rmPmLobby, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerKnockOutAddOn", playerKnockOutAddOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalKnockOutAddOn", totalKnockOutAddOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockOutAddOnProgressive", knockOutAddOnProgressive, _buf);
	Atf::XmlElement::encodeAsXmlElement("sitGoStarterGameId", sitGoStarterGameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("numStandardButton", numStandardButton, _buf);
	Atf::XmlElement::encodeAsXmlElement("lateRegDelta", lateRegDelta, _buf);
	Atf::XmlElement::encodeAsXmlElement("finalTablePlusOne", finalTablePlusOne, _buf);
	Atf::XmlElement::encodeAsXmlElement("multidayIndex", multidayIndex, _buf);
	multiDayVec.toXmlString("multiDayVec", _buf);
	Atf::XmlElement::encodeAsXmlElement("criteria", criteria, _buf);
	Atf::XmlElement::encodeAsXmlElement("groupReference", groupReference, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournGroup", tournGroup, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePool", prizePool, _buf);
	admissions.toXmlString("admissions", _buf);
	Atf::XmlElement::encodeAsXmlElement("pokerNgGroup", pokerNgGroup, _buf);
	siteMaskEx.toXmlString("siteMaskEx", _buf);
	Atf::XmlElement::encodeAsXmlElement("pppId", pppId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableTrait", tableTrait, _buf);
	Atf::XmlElement::encodeAsXmlElement("highlightColor", highlightColor, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Static::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		switch((BYTE)*_element)
		{
		case '_':
			if (_element.equals("_obsolete_1"))
			{
				_obsolete_1 = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("_obsolete_2"))
			{
				_obsolete_2 = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("_obsolete_3"))
			{
				_obsolete_3 = (*_value.ptr() == '1');
			}
			else if (_element.equals("_obsolete_4"))
			{
				_obsolete_4 = (*_value.ptr() == '1');
			}
			else if (_element.equals("_obsolete_5"))
			{
				_obsolete_5 = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'a':
			if (_element.equals("addOnChips"))
			{
				addOnChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addOnMaxChips"))
			{
				addOnMaxChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("awardSchema"))
			{
				awardSchema = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addonFppPrice"))
			{
				addonFppPrice = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("addOnFppReward"))
			{
				addOnFppReward = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admission"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, admission)) return false;
			}
			else if (_element.equals("admissions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, admissions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'b':
			if (_element.equals("buyIn"))
			{
				buyIn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bounty"))
			{
				bounty = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bounties"))
			{
				if(!Atf::AtfTempl< _BountiesType >::FromXmlString(_value, bounties)) return false;
			}
			else if (_element.equals("blitzNormalDealingThreshold"))
			{
				blitzNormalDealingThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("brandMask"))
			{
				brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'c':
			if (_element.equals("chatLang"))
			{
				chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cannotUnregisterFromTarget"))
			{
				cannotUnregisterFromTarget = (*_value.ptr() == '1');
			}
			else if (_element.equals("criteria"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, criteria)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'd':
			if (_element.equals("dealExclusionType"))
			{
				dealExclusionType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dealExclusionValue"))
			{
				dealExclusionValue = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'f':
			if (_element.equals("fppReward"))
			{
				fppReward = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppBuyIn"))
			{
				fppBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("finalTableText"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, finalTableText);
			}
			else if (_element.equals("fppFraction"))
			{
				fppFraction = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppRewardPercent"))
			{
				fppRewardPercent = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("favoriteReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, favoriteReference)) return false;
			}
			else if (_element.equals("finalTablePlusOne"))
			{
				finalTablePlusOne = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'g':
			if (_element.equals("gameType"))
			{
				gameType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("guaranteedPrizePool"))
			{
				guaranteedPrizePool = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("groupReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, groupReference)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'h':
			if (_element.equals("highlightColor"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, highlightColor)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'i':
			if (_element.equals("isHiLo"))
			{
				isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isRestricted"))
			{
				isRestricted = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPwdProtected"))
			{
				isPwdProtected = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("internalReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, internalReference)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'k':
			if (_element.equals("knockOutAddOnProgressive"))
			{
				knockOutAddOnProgressive = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'l':
			if (_element.equals("lobbyRestricted"))
			{
				lobbyRestricted = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("lateRegDelta"))
			{
				lateRegDelta = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'm':
			if (_element.equals("maxPlayers"))
			{
				maxPlayers = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayers"))
			{
				minPlayers = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxAllIns"))
			{
				maxAllIns = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("multiday"))
			{
				if(!Atf::AtfTempl< MultidayTourn >::FromXmlString(_value, multiday)) return false;
			}
			else if (_element.equals("multidayIndex"))
			{
				multidayIndex = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("multiDayVec"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< LobbyData_MultidayTourn, 4 > >::FromXmlString(_value, multiDayVec)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'n':
			if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("numRebuys"))
			{
				numRebuys = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numAddOns"))
			{
				numAddOns = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nPublishLobbyPlayersLess"))
			{
				nPublishLobbyPlayersLess = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nStackInfoMsg"))
			{
				if(!Atf::AtfTempl< NStackTournInfoStruct >::FromXmlString(_value, nStackInfoMsg)) return false;
			}
			else if (_element.equals("numStandardButton"))
			{
				numStandardButton = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'p':
			if (_element.equals("playersPerTable"))
			{
				playersPerTable = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("placeHolder"))
			{
				placeHolder = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("publPropFlag"))
			{
				publPropFlag = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("progressiveKnockout"))
			{
				progressiveKnockout = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("publStartLevel"))
			{
				publStartLevel = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playerKnockOutAddOn"))
			{
				playerKnockOutAddOn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("prizePool"))
			{
				prizePool = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pokerNgGroup"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, pokerNgGroup)) return false;
			}
			else if (_element.equals("pppId"))
			{
				pppId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'r':
			if (_element.equals("rake"))
			{
				rake = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("registrationStarts"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, registrationStarts);
			}
			else if (_element.equals("registrationEnds"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, registrationEnds);
			}
			else if (_element.equals("restricted"))
			{
				restricted = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuyChips"))
			{
				rebuyChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuyMaxChips"))
			{
				rebuyMaxChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuyFppPrice"))
			{
				rebuyFppPrice = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("registrationStarts_t"))
			{
				registrationStarts_t = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("registrationEnds_t"))
			{
				registrationEnds_t = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rebuyFppReward"))
			{
				rebuyFppReward = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("reEntryAllowed"))
			{
				reEntryAllowed = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rmPmLobby"))
			{
				rmPmLobby = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 's':
			if (_element.equals("startingChips"))
			{
				startingChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startingTime"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, startingTime);
			}
			else if (_element.equals("seatingStarts"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, seatingStarts);
			}
			else if (_element.equals("scriptPrizeAddOn"))
			{
				scriptPrizeAddOn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satelliteTarget"))
			{
				satelliteTarget = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satelliteTargetBuyIn"))
			{
				satelliteTargetBuyIn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startingTime_t"))
			{
				startingTime_t = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seatingStarts_t"))
			{
				seatingStarts_t = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("satelliteTargetReference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, satelliteTargetReference)) return false;
			}
			else if (_element.equals("satelliteTargetReferenceLock"))
			{
				satelliteTargetReferenceLock = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("speedDisplay"))
			{
				speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("siteMask"))
			{
				siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("spinGoStartDelay"))
			{
				spinGoStartDelay = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sitGoStarterGameId"))
			{
				sitGoStarterGameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("siteMaskEx"))
			{
				if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, siteMaskEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 't':
			if (_element.equals("tournamentId"))
			{
				tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeBank"))
			{
				timeBank = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlagsServInt"))
			{
				tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournProp2"))
			{
				tournProp2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ticketTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< P_TicketType, 4 > >::FromXmlString(_value, ticketTypes)) return false;
			}
			else if (_element.equals("tableLogo"))
			{
				tableLogo = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournType"))
			{
				timedTournType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournLevelsOrMinutes"))
			{
				timedTournLevelsOrMinutes = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournPayoutStructure"))
			{
				timedTournPayoutStructure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournBrand"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournBrand)) return false;
			}
			else if (_element.equals("tableText"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, tableText);
			}
			else if (_element.equals("tournMask"))
			{
				tournMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask2"))
			{
				tournMask2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask3"))
			{
				tournMask3 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask4"))
			{
				tournMask4 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ticketPrice"))
			{
				ticketPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("targetWhenStarts"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, targetWhenStarts);
			}
			else if (_element.equals("tournMask5"))
			{
				tournMask5 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMask6"))
			{
				tournMask6 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timedTournPlayersPercent"))
			{
				timedTournPlayersPercent = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalKnockOutAddOn"))
			{
				totalKnockOutAddOn = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournGroup"))
			{
				tournGroup = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableTrait"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tableTrait)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'u':
			if (_element.equals("unregistrationEnds_t"))
			{
				unregistrationEnds_t = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		case 'v':
			if (_element.equals("vppToPublish"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< P_FppReward, 4 > >::FromXmlString(_value, vppToPublish)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
			break;
		default:
			return false;
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Static::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeINT32(buyIn);
	_msg.composeINT32(rake);
	_msg.composeINT32(startingChips);
	_msg.composeINT32(maxPlayers);
	_msg.composeINT32(playersPerTable);
	_msg.composeBYTE(gameType);
	_msg.composeBYTE(isHiLo);
	_msg.composeSrvTime(startingTime);
	_msg.composeSrvTime(registrationStarts);
	_msg.composeSrvTime(registrationEnds);
	_msg.composeSrvTime(seatingStarts);
	_msg.composeINT32(minPlayers);
	_msg.composeBYTE(restricted);
	_msg.composeINT32(fppReward);
	_msg.composeINT32(fppBuyIn);
	_msg.composeBYTE(isRestricted);
	_msg.composeBYTE(isPwdProtected);
	_msg.composeString(name);
	_msg.composeINT32(numRebuys);
	_msg.composeINT32(rebuyChips);
	_msg.composeINT32(_obsolete_1);
	_msg.composeINT32(rebuyMaxChips);
	_msg.composeINT32(numAddOns);
	_msg.composeINT32(addOnChips);
	_msg.composeINT32(_obsolete_2);
	_msg.composeINT32(addOnMaxChips);
	_msg.composeINT32(scriptPrizeAddOn);
	_msg.composeINT32(guaranteedPrizePool);
	_msg.composeUINT32(tournFlags);
	_msg.composeINT16(maxAllIns);
	_msg.composeBYTE(awardSchema);
	_msg.composeUINT32(timeBank);
	_msg.composeINT32(unregistrationEnds_t);
	_msg.composeUINT32(satelliteTarget);
	_msg.composeINT32(satelliteTargetBuyIn);
	_msg.composeINT32(rebuyFppPrice);
	_msg.composeINT32(addonFppPrice);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeUINT32(startingTime_t);
	_msg.composeUINT32(registrationStarts_t);
	_msg.composeUINT32(registrationEnds_t);
	_msg.composeUINT32(seatingStarts_t);
	_msg.composeUINT32(tournFlagsServInt);
	_msg.composeUINT32(tournProp2);
	ticketTypes.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(tableLogo);
	finalTableText.compose(_msg);
	_msg.composeUINT16(chatLang);
	_msg.composeUINT32(lobbyRestricted);
	_msg.composeINT32(fppFraction);
	_msg.composeString(currency);
	_msg.composeINT32(rebuyFppReward);
	_msg.composeINT32(addOnFppReward);
	_msg.composeINT8(fppRewardPercent);
	_msg.composeUINT32(nPublishLobbyPlayersLess);
	_msg.composeINT32(bounty);
	_msg.composeUINT32(placeHolder);
	bounties.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(publPropFlag);
	multiday.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(satelliteTargetReference);
	_msg.composeUINT16(satelliteTargetReferenceLock);
	_msg.composeUINT32(clubId);
	_msg.composeBYTE(timedTournType);
	_msg.composeUINT16(timedTournLevelsOrMinutes);
	_msg.composeBYTE(timedTournPayoutStructure);
	_msg.composeBOOL(_obsolete_3);
	vppToPublish.composeMsg(_msg, _ignoreJSON);
	_msg.composeBYTE(speedDisplay);
	_msg.composeString(tournBrand);
	_msg.composeINT32(scalePM);
	_msg.composeUINT32(blitzNormalDealingThreshold);
	_msg.composeBOOL(_obsolete_4);
	_msg.composeBYTE(progressiveKnockout);
	tableText.compose(_msg);
	_msg.composeUINT16(reEntryAllowed);
	_msg.composeUINT32(tournMask);
	_msg.composeUINT32(tournMask2);
	_msg.composeUINT32(tournMask3);
	_msg.composeUINT32(tournMask4);
	_msg.composeString(internalReference);
	_msg.composeString(favoriteReference);
	_msg.composeINT64(ticketPrice);
	_msg.composeUINT64(tournFlags2);
	_msg.composeBOOL(cannotUnregisterFromTarget);
	CommMsgBody _msg0;
	nStackInfoMsg.composeMsg(_msg0, _ignoreJSON);
	_msg.composeMsgBody(_msg0);
	_msg.composeSrvTime(targetWhenStarts);
	_msg.composeString(admission);
	_msg.composeUINT32(siteMask);
	_msg.composeUINT32(publStartLevel);
	_msg.composeUINT32(tournMask5);
	_msg.composeUINT32(tournMask6);
	_msg.composeBYTE(dealExclusionType);
	_msg.composeINT32(dealExclusionValue);
	_msg.composeBYTE(timedTournPlayersPercent);
	_msg.composeINT32(_obsolete_5);
	_msg.composeINT32(spinGoStartDelay);
	_msg.composeBYTE(rmPmLobby);
	_msg.composeUINT32(brandMask);
	_msg.composeINT32(playerKnockOutAddOn);
	_msg.composeINT32(totalKnockOutAddOn);
	_msg.composeBYTE(knockOutAddOnProgressive);
	_msg.composeUINT32(sitGoStarterGameId);
	_msg.composeUINT32(numStandardButton);
	_msg.composeINT32(lateRegDelta);
	_msg.composeINT32(finalTablePlusOne);
	_msg.composeINT32(multidayIndex);
	multiDayVec.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(criteria);
	_msg.composeString(groupReference);
	_msg.composeINT32(tournGroup);
	_msg.composeINT32(prizePool);
	admissions.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(pokerNgGroup);
	siteMaskEx.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(pppId);
	_msg.composeString(tableTrait);
	_msg.composeString(highlightColor);
}

void TournClient::publication::TournSubscr_Static::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseINT32(buyIn);
	_parser.parseINT32(rake);
	_parser.parseINT32(startingChips);
	_parser.parseINT32(maxPlayers);
	_parser.parseINT32(playersPerTable);
	_parser.parseBYTE(gameType);
	_parser.parseBYTE(isHiLo);
	_parser.parseSrvTime(startingTime);
	_parser.parseSrvTime(registrationStarts);
	_parser.parseSrvTime(registrationEnds);
	_parser.parseSrvTime(seatingStarts);
	_parser.parseINT32(minPlayers);
	_parser.parseBYTE(restricted);
	_parser.parseINT32(fppReward);
	_parser.parseINT32(fppBuyIn);
	_parser.parseBYTE(isRestricted);
	_parser.parseBYTE(isPwdProtected);
	_parser.parseStringP(name);
	_parser.parseINT32(numRebuys);
	_parser.parseINT32(rebuyChips);
	_parser.parseINT32(_obsolete_1);
	_parser.parseINT32(rebuyMaxChips);
	_parser.parseINT32(numAddOns);
	_parser.parseINT32(addOnChips);
	_parser.parseINT32(_obsolete_2);
	_parser.parseINT32(addOnMaxChips);
	_parser.parseINT32(scriptPrizeAddOn);
	_parser.parseINT32(guaranteedPrizePool);
	_parser.parseUINT32(tournFlags);
	_parser.parseINT16(maxAllIns);
	_parser.parseBYTE(awardSchema);
	_parser.parseUINT32(timeBank);
	_parser.parseINT32(unregistrationEnds_t);
	_parser.parseUINT32(satelliteTarget);
	_parser.parseINT32(satelliteTargetBuyIn);
	_parser.parseINT32(rebuyFppPrice);
	_parser.parseINT32(addonFppPrice);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseUINT32(startingTime_t);
	_parser.parseUINT32(registrationStarts_t);
	_parser.parseUINT32(registrationEnds_t);
	_parser.parseUINT32(seatingStarts_t);
	_parser.parseUINT32(tournFlagsServInt);
	_parser.parseUINT32(tournProp2);
	ticketTypes.parseMsg(_parser);
	_parser.parseUINT32(tableLogo);
	finalTableText.parse(_parser);
	_parser.parseUINT16(chatLang);
	_parser.parseUINT32(lobbyRestricted);
	_parser.parseINT32(fppFraction);
	_parser.parseStringP(currency);
	_parser.parseINT32(rebuyFppReward);
	_parser.parseINT32(addOnFppReward);
	_parser.parseINT8(fppRewardPercent);
	_parser.parseUINT32(nPublishLobbyPlayersLess);
	_parser.parseINT32(bounty);
	_parser.parseUINT32(placeHolder);
	bounties.parseMsg(_parser);
	_parser.parseBYTE(publPropFlag);
	multiday.parseMsg(_parser);
	_parser.parseStringP(satelliteTargetReference);
	_parser.parseUINT16(satelliteTargetReferenceLock);
	_parser.parseUINT32(clubId);
	_parser.parseBYTE(timedTournType);
	_parser.parseUINT16(timedTournLevelsOrMinutes);
	_parser.parseBYTE(timedTournPayoutStructure);
	_parser.parseBOOL(_obsolete_3);
	vppToPublish.parseMsg(_parser);
	_parser.parseBYTE(speedDisplay);
	_parser.parseStringP(tournBrand);
	_parser.parseINT32(scalePM);
	_parser.parseUINT32(blitzNormalDealingThreshold);
	_parser.parseBOOL(_obsolete_4);
	_parser.parseBYTE(progressiveKnockout);
	tableText.parse(_parser);
	_parser.parseUINT16(reEntryAllowed);
	_parser.parseUINT32(tournMask);
	_parser.parseUINT32(tournMask2);
	_parser.parseUINT32(tournMask3);
	_parser.parseUINT32(tournMask4);
	_parser.parseStringP(internalReference);
	_parser.parseStringP(favoriteReference);
	_parser.parseINT64(ticketPrice);
	_parser.parseUINT64(tournFlags2);
	_parser.parseBOOL(cannotUnregisterFromTarget);
	parseAnonymousMsgBody0(_parser);
	_parser.parseSrvTime(targetWhenStarts);
	_parser.parseStringP(admission);
	_parser.parseUINT32(siteMask);
	_parser.parseUINT32(publStartLevel);
	_parser.parseUINT32(tournMask5);
	_parser.parseUINT32(tournMask6);
	_parser.parseBYTE(dealExclusionType);
	_parser.parseINT32(dealExclusionValue);
	_parser.parseBYTE(timedTournPlayersPercent);
	_parser.parseINT32(_obsolete_5);
	_parser.parseINT32(spinGoStartDelay);
	_parser.parseBYTE(rmPmLobby);
	_parser.parseUINT32(brandMask);
	_parser.parseINT32(playerKnockOutAddOn);
	_parser.parseINT32(totalKnockOutAddOn);
	_parser.parseBYTE(knockOutAddOnProgressive);
	_parser.parseUINT32(sitGoStarterGameId);
	_parser.parseUINT32(numStandardButton);
	_parser.parseINT32(lateRegDelta);
	_parser.parseINT32(finalTablePlusOne);
	_parser.parseINT32(multidayIndex);
	multiDayVec.parseMsg(_parser);
	_parser.parseStringP(criteria);
	_parser.parseStringP(groupReference);
	_parser.parseINT32(tournGroup);
	_parser.parseINT32(prizePool);
	admissions.parseMsg(_parser);
	_parser.parseStringP(pokerNgGroup);
	siteMaskEx.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(pppId);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(tableTrait);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(highlightColor);
}

const char *TournClient::publication::TournSubscr_Static::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("startingChips", startingChips);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("playersPerTable", playersPerTable);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("startingTime", startingTime);
	_jsonstr.compose("registrationStarts", registrationStarts);
	_jsonstr.compose("registrationEnds", registrationEnds);
	_jsonstr.compose("seatingStarts", seatingStarts);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("restricted", restricted);
	_jsonstr.compose("fppReward", fppReward);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("isRestricted", isRestricted);
	_jsonstr.compose("isPwdProtected", isPwdProtected);
	_jsonstr.compose("name", name);
	_jsonstr.compose("numRebuys", numRebuys);
	_jsonstr.compose("rebuyChips", rebuyChips);
	_jsonstr.compose("_obsolete_1", _obsolete_1);
	_jsonstr.compose("rebuyMaxChips", rebuyMaxChips);
	_jsonstr.compose("numAddOns", numAddOns);
	_jsonstr.compose("addOnChips", addOnChips);
	_jsonstr.compose("_obsolete_2", _obsolete_2);
	_jsonstr.compose("addOnMaxChips", addOnMaxChips);
	_jsonstr.compose("scriptPrizeAddOn", scriptPrizeAddOn);
	_jsonstr.compose("guaranteedPrizePool", guaranteedPrizePool);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("maxAllIns", maxAllIns);
	_jsonstr.compose("awardSchema", awardSchema);
	_jsonstr.compose("timeBank", timeBank);
	_jsonstr.compose("unregistrationEnds_t", unregistrationEnds_t);
	_jsonstr.compose("satelliteTarget", satelliteTarget);
	_jsonstr.compose("satelliteTargetBuyIn", satelliteTargetBuyIn);
	_jsonstr.compose("rebuyFppPrice", rebuyFppPrice);
	_jsonstr.compose("addonFppPrice", addonFppPrice);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("startingTime_t", startingTime_t);
	_jsonstr.compose("registrationStarts_t", registrationStarts_t);
	_jsonstr.compose("registrationEnds_t", registrationEnds_t);
	_jsonstr.compose("seatingStarts_t", seatingStarts_t);
	_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
	_jsonstr.compose("tournProp2", tournProp2);
	_jsonstr.compose("ticketTypes", ticketTypes);
	_jsonstr.compose("tableLogo", tableLogo);
	_jsonstr.compose("finalTableText", finalTableText);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("lobbyRestricted", lobbyRestricted);
	_jsonstr.compose("fppFraction", fppFraction);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("rebuyFppReward", rebuyFppReward);
	_jsonstr.compose("addOnFppReward", addOnFppReward);
	_jsonstr.compose("fppRewardPercent", fppRewardPercent);
	_jsonstr.compose("nPublishLobbyPlayersLess", nPublishLobbyPlayersLess);
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("placeHolder", placeHolder);
	_jsonstr.compose("bounties", bounties);
	_jsonstr.compose("publPropFlag", publPropFlag);
	_jsonstr.compose("multiday", multiday);
	_jsonstr.compose("satelliteTargetReference", satelliteTargetReference);
	_jsonstr.compose("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("timedTournType", timedTournType);
	_jsonstr.compose("timedTournLevelsOrMinutes", timedTournLevelsOrMinutes);
	_jsonstr.compose("timedTournPayoutStructure", timedTournPayoutStructure);
	_jsonstr.compose("_obsolete_3", _obsolete_3);
	_jsonstr.compose("vppToPublish", vppToPublish);
	_jsonstr.compose("speedDisplay", speedDisplay);
	_jsonstr.compose("tournBrand", tournBrand);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("blitzNormalDealingThreshold", blitzNormalDealingThreshold);
	_jsonstr.compose("_obsolete_4", _obsolete_4);
	_jsonstr.compose("progressiveKnockout", progressiveKnockout);
	_jsonstr.compose("tableText", tableText);
	_jsonstr.compose("reEntryAllowed", reEntryAllowed);
	_jsonstr.compose("tournMask", tournMask);
	_jsonstr.compose("tournMask2", tournMask2);
	_jsonstr.compose("tournMask3", tournMask3);
	_jsonstr.compose("tournMask4", tournMask4);
	_jsonstr.compose("internalReference", internalReference);
	_jsonstr.compose("favoriteReference", favoriteReference);
	_jsonstr.compose("ticketPrice", ticketPrice);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("cannotUnregisterFromTarget", cannotUnregisterFromTarget);
	_jsonstr.compose("nStackInfoMsg", nStackInfoMsg);
	_jsonstr.compose("targetWhenStarts", targetWhenStarts);
	_jsonstr.compose("admission", admission);
	_jsonstr.compose("siteMask", siteMask);
	_jsonstr.compose("publStartLevel", publStartLevel);
	_jsonstr.compose("tournMask5", tournMask5);
	_jsonstr.compose("tournMask6", tournMask6);
	_jsonstr.compose("dealExclusionType", dealExclusionType);
	_jsonstr.compose("dealExclusionValue", dealExclusionValue);
	_jsonstr.compose("timedTournPlayersPercent", timedTournPlayersPercent);
	_jsonstr.compose("_obsolete_5", _obsolete_5);
	_jsonstr.compose("spinGoStartDelay", spinGoStartDelay);
	_jsonstr.compose("rmPmLobby", rmPmLobby);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("playerKnockOutAddOn", playerKnockOutAddOn);
	_jsonstr.compose("totalKnockOutAddOn", totalKnockOutAddOn);
	_jsonstr.compose("knockOutAddOnProgressive", knockOutAddOnProgressive);
	_jsonstr.compose("sitGoStarterGameId", sitGoStarterGameId);
	_jsonstr.compose("numStandardButton", numStandardButton);
	_jsonstr.compose("lateRegDelta", lateRegDelta);
	_jsonstr.compose("finalTablePlusOne", finalTablePlusOne);
	_jsonstr.compose("multidayIndex", multidayIndex);
	_jsonstr.compose("multiDayVec", multiDayVec);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("groupReference", groupReference);
	_jsonstr.compose("tournGroup", tournGroup);
	_jsonstr.compose("prizePool", prizePool);
	_jsonstr.compose("admissions", admissions);
	_jsonstr.compose("pokerNgGroup", pokerNgGroup);
	_jsonstr.compose("siteMaskEx", siteMaskEx);
	_jsonstr.compose("pppId", pppId);
	_jsonstr.compose("tableTrait", tableTrait);
	_jsonstr.compose("highlightColor", highlightColor);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Static::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("startingChips", startingChips);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("playersPerTable", playersPerTable);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("startingTime", startingTime);
	_jparser.parseByNameThrow("registrationStarts", registrationStarts);
	_jparser.parseByNameThrow("registrationEnds", registrationEnds);
	_jparser.parseByNameThrow("seatingStarts", seatingStarts);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("restricted", restricted);
	_jparser.parseByNameThrow("fppReward", fppReward);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("isRestricted", isRestricted);
	_jparser.parseByNameThrow("isPwdProtected", isPwdProtected);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("numRebuys", numRebuys);
	_jparser.parseByNameThrow("rebuyChips", rebuyChips);
	_jparser.parseByNameThrow("_obsolete_1", _obsolete_1);
	_jparser.parseByNameThrow("rebuyMaxChips", rebuyMaxChips);
	_jparser.parseByNameThrow("numAddOns", numAddOns);
	_jparser.parseByNameThrow("addOnChips", addOnChips);
	_jparser.parseByNameThrow("_obsolete_2", _obsolete_2);
	_jparser.parseByNameThrow("addOnMaxChips", addOnMaxChips);
	_jparser.parseByNameThrow("scriptPrizeAddOn", scriptPrizeAddOn);
	_jparser.parseByNameThrow("guaranteedPrizePool", guaranteedPrizePool);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("maxAllIns", maxAllIns);
	_jparser.parseByNameThrow("awardSchema", awardSchema);
	_jparser.parseByNameThrow("timeBank", timeBank);
	_jparser.parseByNameThrow("unregistrationEnds_t", unregistrationEnds_t);
	_jparser.parseByNameThrow("satelliteTarget", satelliteTarget);
	_jparser.parseByNameThrow("satelliteTargetBuyIn", satelliteTargetBuyIn);
	_jparser.parseByNameThrow("rebuyFppPrice", rebuyFppPrice);
	_jparser.parseByNameThrow("addonFppPrice", addonFppPrice);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("startingTime_t", startingTime_t);
	_jparser.parseByNameThrow("registrationStarts_t", registrationStarts_t);
	_jparser.parseByNameThrow("registrationEnds_t", registrationEnds_t);
	_jparser.parseByNameThrow("seatingStarts_t", seatingStarts_t);
	_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
	_jparser.parseByNameThrow("tournProp2", tournProp2);
	_jparser.parseByNameThrow("ticketTypes", ticketTypes);
	_jparser.parseByNameThrow("tableLogo", tableLogo);
	_jparser.parseByNameThrow("finalTableText", finalTableText);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("lobbyRestricted", lobbyRestricted);
	_jparser.parseByNameThrow("fppFraction", fppFraction);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("rebuyFppReward", rebuyFppReward);
	_jparser.parseByNameThrow("addOnFppReward", addOnFppReward);
	_jparser.parseByNameThrow("fppRewardPercent", fppRewardPercent);
	_jparser.parseByNameThrow("nPublishLobbyPlayersLess", nPublishLobbyPlayersLess);
	_jparser.parseByNameThrow("bounty", bounty);
	_jparser.parseByNameThrow("placeHolder", placeHolder);
	_jparser.parseByNameThrow("bounties", bounties);
	_jparser.parseByNameThrow("publPropFlag", publPropFlag);
	_jparser.parseByNameThrow("multiday", multiday);
	_jparser.parseByNameThrow("satelliteTargetReference", satelliteTargetReference);
	_jparser.parseByNameThrow("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("timedTournType", timedTournType);
	_jparser.parseByNameThrow("timedTournLevelsOrMinutes", timedTournLevelsOrMinutes);
	_jparser.parseByNameThrow("timedTournPayoutStructure", timedTournPayoutStructure);
	_jparser.parseByNameThrow("_obsolete_3", _obsolete_3);
	_jparser.parseByNameThrow("vppToPublish", vppToPublish);
	_jparser.parseByNameThrow("speedDisplay", speedDisplay);
	_jparser.parseByNameThrow("tournBrand", tournBrand);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("blitzNormalDealingThreshold", blitzNormalDealingThreshold);
	_jparser.parseByNameThrow("_obsolete_4", _obsolete_4);
	_jparser.parseByNameThrow("progressiveKnockout", progressiveKnockout);
	_jparser.parseByNameThrow("tableText", tableText);
	_jparser.parseByNameThrow("reEntryAllowed", reEntryAllowed);
	_jparser.parseByNameThrow("tournMask", tournMask);
	_jparser.parseByNameThrow("tournMask2", tournMask2);
	_jparser.parseByNameThrow("tournMask3", tournMask3);
	_jparser.parseByNameThrow("tournMask4", tournMask4);
	_jparser.parseByNameThrow("internalReference", internalReference);
	_jparser.parseByNameThrow("favoriteReference", favoriteReference);
	_jparser.parseByNameThrow("ticketPrice", ticketPrice);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	_jparser.parseByNameThrow("cannotUnregisterFromTarget", cannotUnregisterFromTarget);
	_jparser.parseByName("nStackInfoMsg", nStackInfoMsg);
	_jparser.parseByNameThrow("targetWhenStarts", targetWhenStarts);
	_jparser.parseByNameThrow("admission", admission);
	_jparser.parseByNameThrow("siteMask", siteMask);
	_jparser.parseByNameThrow("publStartLevel", publStartLevel);
	_jparser.parseByNameThrow("tournMask5", tournMask5);
	_jparser.parseByNameThrow("tournMask6", tournMask6);
	_jparser.parseByNameThrow("dealExclusionType", dealExclusionType);
	_jparser.parseByNameThrow("dealExclusionValue", dealExclusionValue);
	_jparser.parseByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	_jparser.parseByNameThrow("_obsolete_5", _obsolete_5);
	_jparser.parseByNameThrow("spinGoStartDelay", spinGoStartDelay);
	_jparser.parseByNameThrow("rmPmLobby", rmPmLobby);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("playerKnockOutAddOn", playerKnockOutAddOn);
	_jparser.parseByNameThrow("totalKnockOutAddOn", totalKnockOutAddOn);
	_jparser.parseByNameThrow("knockOutAddOnProgressive", knockOutAddOnProgressive);
	_jparser.parseByNameThrow("sitGoStarterGameId", sitGoStarterGameId);
	_jparser.parseByNameThrow("numStandardButton", numStandardButton);
	_jparser.parseByNameThrow("lateRegDelta", lateRegDelta);
	_jparser.parseByNameThrow("finalTablePlusOne", finalTablePlusOne);
	_jparser.parseByNameThrow("multidayIndex", multidayIndex);
	_jparser.parseByNameThrow("multiDayVec", multiDayVec);
	_jparser.parseByNameThrow("criteria", criteria);
	_jparser.parseByNameThrow("groupReference", groupReference);
	_jparser.parseByNameThrow("tournGroup", tournGroup);
	_jparser.parseByNameThrow("prizePool", prizePool);
	_jparser.parseByNameThrow("admissions", admissions);
	_jparser.parseByNameThrow("pokerNgGroup", pokerNgGroup);
	_jparser.parseByNameThrow("siteMaskEx", siteMaskEx);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("pppId", pppId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableTrait", tableTrait);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("highlightColor", highlightColor);
}

/* static */ void TournClient::publication::TournSubscr_Static::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	INT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 startingChips; _jparser.validateByNameThrow("startingChips", startingChips);
	AtfValidator::validateInt(_descr, "startingChips", startingChips, _checker, __FILE__, __LINE__);
	INT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	INT32 playersPerTable; _jparser.validateByNameThrow("playersPerTable", playersPerTable);
	AtfValidator::validateInt(_descr, "playersPerTable", playersPerTable, _checker, __FILE__, __LINE__);
	BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	SrvTime startingTime; _jparser.validateByNameThrow("startingTime", startingTime);
	AtfValidator::validateSrvDateTime(_descr, "startingTime", startingTime, _checker, __FILE__, __LINE__);
	SrvTime registrationStarts; _jparser.validateByNameThrow("registrationStarts", registrationStarts);
	AtfValidator::validateSrvDateTime(_descr, "registrationStarts", registrationStarts, _checker, __FILE__, __LINE__);
	SrvTime registrationEnds; _jparser.validateByNameThrow("registrationEnds", registrationEnds);
	AtfValidator::validateSrvDateTime(_descr, "registrationEnds", registrationEnds, _checker, __FILE__, __LINE__);
	SrvTime seatingStarts; _jparser.validateByNameThrow("seatingStarts", seatingStarts);
	AtfValidator::validateSrvDateTime(_descr, "seatingStarts", seatingStarts, _checker, __FILE__, __LINE__);
	INT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	BYTE restricted; _jparser.validateByNameThrow("restricted", restricted);
	AtfValidator::validateInt(_descr, "restricted", restricted, _checker, __FILE__, __LINE__);
	INT32 fppReward; _jparser.validateByNameThrow("fppReward", fppReward);
	AtfValidator::validateInt(_descr, "fppReward", fppReward, _checker, __FILE__, __LINE__);
	INT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _jparser.validateByNameThrow("isRestricted", isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _jparser.validateByNameThrow("isPwdProtected", isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	INT32 numRebuys; _jparser.validateByNameThrow("numRebuys", numRebuys);
	AtfValidator::validateInt(_descr, "numRebuys", numRebuys, _checker, __FILE__, __LINE__);
	INT32 rebuyChips; _jparser.validateByNameThrow("rebuyChips", rebuyChips);
	AtfValidator::validateInt(_descr, "rebuyChips", rebuyChips, _checker, __FILE__, __LINE__);
	INT32 _obsolete_1; _jparser.validateByNameThrow("_obsolete_1", _obsolete_1);
	AtfValidator::validateInt(_descr, "_obsolete_1", _obsolete_1, _checker, __FILE__, __LINE__);
	INT32 rebuyMaxChips; _jparser.validateByNameThrow("rebuyMaxChips", rebuyMaxChips);
	AtfValidator::validateInt(_descr, "rebuyMaxChips", rebuyMaxChips, _checker, __FILE__, __LINE__);
	INT32 numAddOns; _jparser.validateByNameThrow("numAddOns", numAddOns);
	AtfValidator::validateInt(_descr, "numAddOns", numAddOns, _checker, __FILE__, __LINE__);
	INT32 addOnChips; _jparser.validateByNameThrow("addOnChips", addOnChips);
	AtfValidator::validateInt(_descr, "addOnChips", addOnChips, _checker, __FILE__, __LINE__);
	INT32 _obsolete_2; _jparser.validateByNameThrow("_obsolete_2", _obsolete_2);
	AtfValidator::validateInt(_descr, "_obsolete_2", _obsolete_2, _checker, __FILE__, __LINE__);
	INT32 addOnMaxChips; _jparser.validateByNameThrow("addOnMaxChips", addOnMaxChips);
	AtfValidator::validateInt(_descr, "addOnMaxChips", addOnMaxChips, _checker, __FILE__, __LINE__);
	INT32 scriptPrizeAddOn; _jparser.validateByNameThrow("scriptPrizeAddOn", scriptPrizeAddOn);
	AtfValidator::validateInt(_descr, "scriptPrizeAddOn", scriptPrizeAddOn, _checker, __FILE__, __LINE__);
	INT32 guaranteedPrizePool; _jparser.validateByNameThrow("guaranteedPrizePool", guaranteedPrizePool);
	AtfValidator::validateInt(_descr, "guaranteedPrizePool", guaranteedPrizePool, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	INT16 maxAllIns; _jparser.validateByNameThrow("maxAllIns", maxAllIns);
	AtfValidator::validateInt(_descr, "maxAllIns", maxAllIns, _checker, __FILE__, __LINE__);
	BYTE awardSchema; _jparser.validateByNameThrow("awardSchema", awardSchema);
	AtfValidator::validateInt(_descr, "awardSchema", awardSchema, _checker, __FILE__, __LINE__);
	UINT32 timeBank; _jparser.validateByNameThrow("timeBank", timeBank);
	AtfValidator::validateInt(_descr, "timeBank", timeBank, _checker, __FILE__, __LINE__);
	INT32 unregistrationEnds_t; _jparser.validateByNameThrow("unregistrationEnds_t", unregistrationEnds_t);
	AtfValidator::validateInt(_descr, "unregistrationEnds_t", unregistrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _jparser.validateByNameThrow("satelliteTarget", satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	INT32 satelliteTargetBuyIn; _jparser.validateByNameThrow("satelliteTargetBuyIn", satelliteTargetBuyIn);
	AtfValidator::validateInt(_descr, "satelliteTargetBuyIn", satelliteTargetBuyIn, _checker, __FILE__, __LINE__);
	INT32 rebuyFppPrice; _jparser.validateByNameThrow("rebuyFppPrice", rebuyFppPrice);
	AtfValidator::validateInt(_descr, "rebuyFppPrice", rebuyFppPrice, _checker, __FILE__, __LINE__);
	INT32 addonFppPrice; _jparser.validateByNameThrow("addonFppPrice", addonFppPrice);
	AtfValidator::validateInt(_descr, "addonFppPrice", addonFppPrice, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 startingTime_t; _jparser.validateByNameThrow("startingTime_t", startingTime_t);
	AtfValidator::validateInt(_descr, "startingTime_t", startingTime_t, _checker, __FILE__, __LINE__);
	UINT32 registrationStarts_t; _jparser.validateByNameThrow("registrationStarts_t", registrationStarts_t);
	AtfValidator::validateInt(_descr, "registrationStarts_t", registrationStarts_t, _checker, __FILE__, __LINE__);
	UINT32 registrationEnds_t; _jparser.validateByNameThrow("registrationEnds_t", registrationEnds_t);
	AtfValidator::validateInt(_descr, "registrationEnds_t", registrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 seatingStarts_t; _jparser.validateByNameThrow("seatingStarts_t", seatingStarts_t);
	AtfValidator::validateInt(_descr, "seatingStarts_t", seatingStarts_t, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 tournProp2; _jparser.validateByNameThrow("tournProp2", tournProp2);
	AtfValidator::validateInt(_descr, "tournProp2", tournProp2, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_TicketType > ticketTypes; _jparser.validateByNameThrow("ticketTypes", ticketTypes);
	AtfValidator::validateInt(_descr, "ticketTypes", ticketTypes.size(), _checker, __FILE__, __LINE__);
	UINT32 tableLogo; _jparser.validateByNameThrow("tableLogo", tableLogo);
	AtfValidator::validateInt(_descr, "tableLogo", tableLogo, _checker, __FILE__, __LINE__);
	I18nPString finalTableText; _jparser.validateByNameThrow("finalTableText", finalTableText);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	UINT32 lobbyRestricted; _jparser.validateByNameThrow("lobbyRestricted", lobbyRestricted);
	AtfValidator::validateInt(_descr, "lobbyRestricted", lobbyRestricted, _checker, __FILE__, __LINE__);
	INT32 fppFraction; _jparser.validateByNameThrow("fppFraction", fppFraction);
	AtfValidator::validateInt(_descr, "fppFraction", fppFraction, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 rebuyFppReward; _jparser.validateByNameThrow("rebuyFppReward", rebuyFppReward);
	AtfValidator::validateInt(_descr, "rebuyFppReward", rebuyFppReward, _checker, __FILE__, __LINE__);
	INT32 addOnFppReward; _jparser.validateByNameThrow("addOnFppReward", addOnFppReward);
	AtfValidator::validateInt(_descr, "addOnFppReward", addOnFppReward, _checker, __FILE__, __LINE__);
	INT8 fppRewardPercent; _jparser.validateByNameThrow("fppRewardPercent", fppRewardPercent);
	AtfValidator::validateInt(_descr, "fppRewardPercent", fppRewardPercent, _checker, __FILE__, __LINE__);
	UINT32 nPublishLobbyPlayersLess; _jparser.validateByNameThrow("nPublishLobbyPlayersLess", nPublishLobbyPlayersLess);
	AtfValidator::validateInt(_descr, "nPublishLobbyPlayersLess", nPublishLobbyPlayersLess, _checker, __FILE__, __LINE__);
	INT32 bounty; _jparser.validateByNameThrow("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	UINT32 placeHolder; _jparser.validateByNameThrow("placeHolder", placeHolder);
	AtfValidator::validateInt(_descr, "placeHolder", placeHolder, _checker, __FILE__, __LINE__);
	_BountiesType bounties; _jparser.validateByNameThrow("bounties", bounties);
	BYTE publPropFlag; _jparser.validateByNameThrow("publPropFlag", publPropFlag);
	AtfValidator::validateInt(_descr, "publPropFlag", publPropFlag, _checker, __FILE__, __LINE__);
	MultidayTourn multiday; _jparser.validateByNameThrow("multiday", multiday);
	PString satelliteTargetReference; _jparser.validateByNameThrow("satelliteTargetReference", satelliteTargetReference);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", satelliteTargetReference.length(), _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _jparser.validateByNameThrow("satelliteTargetReferenceLock", satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _jparser.validateByNameThrow("timedTournType", timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournLevelsOrMinutes; _jparser.validateByNameThrow("timedTournLevelsOrMinutes", timedTournLevelsOrMinutes);
	AtfValidator::validateInt(_descr, "timedTournLevelsOrMinutes", timedTournLevelsOrMinutes, _checker, __FILE__, __LINE__);
	BYTE timedTournPayoutStructure; _jparser.validateByNameThrow("timedTournPayoutStructure", timedTournPayoutStructure);
	AtfValidator::validateInt(_descr, "timedTournPayoutStructure", timedTournPayoutStructure, _checker, __FILE__, __LINE__);
	bool _obsolete_3; _jparser.validateByNameThrow("_obsolete_3", _obsolete_3);
	AtfValidator::validateInt(_descr, "_obsolete_3", _obsolete_3, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_FppReward > vppToPublish; _jparser.validateByNameThrow("vppToPublish", vppToPublish);
	AtfValidator::validateInt(_descr, "vppToPublish", vppToPublish.size(), _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	PString tournBrand; _jparser.validateByNameThrow("tournBrand", tournBrand);
	AtfValidator::validateInt(_descr, "tournBrand", tournBrand.length(), _checker, __FILE__, __LINE__);
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 blitzNormalDealingThreshold; _jparser.validateByNameThrow("blitzNormalDealingThreshold", blitzNormalDealingThreshold);
	AtfValidator::validateInt(_descr, "blitzNormalDealingThreshold", blitzNormalDealingThreshold, _checker, __FILE__, __LINE__);
	bool _obsolete_4; _jparser.validateByNameThrow("_obsolete_4", _obsolete_4);
	AtfValidator::validateInt(_descr, "_obsolete_4", _obsolete_4, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _jparser.validateByNameThrow("progressiveKnockout", progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	I18nPString tableText; _jparser.validateByNameThrow("tableText", tableText);
	UINT16 reEntryAllowed; _jparser.validateByNameThrow("reEntryAllowed", reEntryAllowed);
	AtfValidator::validateInt(_descr, "reEntryAllowed", reEntryAllowed, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _jparser.validateByNameThrow("tournMask", tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _jparser.validateByNameThrow("tournMask2", tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _jparser.validateByNameThrow("tournMask3", tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _jparser.validateByNameThrow("tournMask4", tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	PString internalReference; _jparser.validateByNameThrow("internalReference", internalReference);
	AtfValidator::validateInt(_descr, "internalReference", internalReference.length(), _checker, __FILE__, __LINE__);
	PString favoriteReference; _jparser.validateByNameThrow("favoriteReference", favoriteReference);
	AtfValidator::validateInt(_descr, "favoriteReference", favoriteReference.length(), _checker, __FILE__, __LINE__);
	INT64 ticketPrice; _jparser.validateByNameThrow("ticketPrice", ticketPrice);
	AtfValidator::validateInt(_descr, "ticketPrice", ticketPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	bool cannotUnregisterFromTarget; _jparser.validateByNameThrow("cannotUnregisterFromTarget", cannotUnregisterFromTarget);
	AtfValidator::validateInt(_descr, "cannotUnregisterFromTarget", cannotUnregisterFromTarget, _checker, __FILE__, __LINE__);
	NStackTournInfoStruct nStackInfoMsg; _jparser.validateByName("nStackInfoMsg", nStackInfoMsg);
	SrvTime targetWhenStarts; _jparser.validateByNameThrow("targetWhenStarts", targetWhenStarts);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStarts", targetWhenStarts, _checker, __FILE__, __LINE__);
	PString admission; _jparser.validateByNameThrow("admission", admission);
	AtfValidator::validateInt(_descr, "admission", admission.length(), _checker, __FILE__, __LINE__);
	UINT32 siteMask; _jparser.validateByNameThrow("siteMask", siteMask);
	AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
	UINT32 publStartLevel; _jparser.validateByNameThrow("publStartLevel", publStartLevel);
	AtfValidator::validateInt(_descr, "publStartLevel", publStartLevel, _checker, __FILE__, __LINE__);
	UINT32 tournMask5; _jparser.validateByNameThrow("tournMask5", tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _jparser.validateByNameThrow("tournMask6", tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	BYTE dealExclusionType; _jparser.validateByNameThrow("dealExclusionType", dealExclusionType);
	AtfValidator::validateInt(_descr, "dealExclusionType", dealExclusionType, _checker, __FILE__, __LINE__);
	INT32 dealExclusionValue; _jparser.validateByNameThrow("dealExclusionValue", dealExclusionValue);
	AtfValidator::validateInt(_descr, "dealExclusionValue", dealExclusionValue, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _jparser.validateByNameThrow("timedTournPlayersPercent", timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	INT32 _obsolete_5; _jparser.validateByNameThrow("_obsolete_5", _obsolete_5);
	AtfValidator::validateInt(_descr, "_obsolete_5", _obsolete_5, _checker, __FILE__, __LINE__);
	INT32 spinGoStartDelay; _jparser.validateByNameThrow("spinGoStartDelay", spinGoStartDelay);
	AtfValidator::validateInt(_descr, "spinGoStartDelay", spinGoStartDelay, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _jparser.validateByNameThrow("rmPmLobby", rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 playerKnockOutAddOn; _jparser.validateByNameThrow("playerKnockOutAddOn", playerKnockOutAddOn);
	AtfValidator::validateInt(_descr, "playerKnockOutAddOn", playerKnockOutAddOn, _checker, __FILE__, __LINE__);
	INT32 totalKnockOutAddOn; _jparser.validateByNameThrow("totalKnockOutAddOn", totalKnockOutAddOn);
	AtfValidator::validateInt(_descr, "totalKnockOutAddOn", totalKnockOutAddOn, _checker, __FILE__, __LINE__);
	BYTE knockOutAddOnProgressive; _jparser.validateByNameThrow("knockOutAddOnProgressive", knockOutAddOnProgressive);
	AtfValidator::validateInt(_descr, "knockOutAddOnProgressive", knockOutAddOnProgressive, _checker, __FILE__, __LINE__);
	UINT32 sitGoStarterGameId; _jparser.validateByNameThrow("sitGoStarterGameId", sitGoStarterGameId);
	AtfValidator::validateInt(_descr, "sitGoStarterGameId", sitGoStarterGameId, _checker, __FILE__, __LINE__);
	UINT32 numStandardButton; _jparser.validateByNameThrow("numStandardButton", numStandardButton);
	AtfValidator::validateInt(_descr, "numStandardButton", numStandardButton, _checker, __FILE__, __LINE__);
	INT32 lateRegDelta; _jparser.validateByNameThrow("lateRegDelta", lateRegDelta);
	AtfValidator::validateInt(_descr, "lateRegDelta", lateRegDelta, _checker, __FILE__, __LINE__);
	INT32 finalTablePlusOne; _jparser.validateByNameThrow("finalTablePlusOne", finalTablePlusOne);
	AtfValidator::validateInt(_descr, "finalTablePlusOne", finalTablePlusOne, _checker, __FILE__, __LINE__);
	INT32 multidayIndex; _jparser.validateByNameThrow("multidayIndex", multidayIndex);
	AtfValidator::validateInt(_descr, "multidayIndex", multidayIndex, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< LobbyData_MultidayTourn > multiDayVec; _jparser.validateByNameThrow("multiDayVec", multiDayVec);
	AtfValidator::validateInt(_descr, "multiDayVec", multiDayVec.size(), _checker, __FILE__, __LINE__);
	PString criteria; _jparser.validateByNameThrow("criteria", criteria);
	AtfValidator::validateInt(_descr, "criteria", criteria.length(), _checker, __FILE__, __LINE__);
	PString groupReference; _jparser.validateByNameThrow("groupReference", groupReference);
	AtfValidator::validateInt(_descr, "groupReference", groupReference.length(), _checker, __FILE__, __LINE__);
	INT32 tournGroup; _jparser.validateByNameThrow("tournGroup", tournGroup);
	AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
	INT32 prizePool; _jparser.validateByNameThrow("prizePool", prizePool);
	AtfValidator::validateInt(_descr, "prizePool", prizePool, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > admissions; _jparser.validateByNameThrow("admissions", admissions);
	AtfValidator::validateInt(_descr, "admissions", admissions.size(), _checker, __FILE__, __LINE__);
	PString pokerNgGroup; _jparser.validateByNameThrow("pokerNgGroup", pokerNgGroup);
	AtfValidator::validateInt(_descr, "pokerNgGroup", pokerNgGroup.length(), _checker, __FILE__, __LINE__);
	PSiteMask siteMaskEx; _jparser.validateByNameThrow("siteMaskEx", siteMaskEx);
	if(_jparser.parseEnded()) return;
	UINT32 pppId; _jparser.validateByNameThrow("pppId", pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString tableTrait; _jparser.validateByNameThrow("tableTrait", tableTrait);
	AtfValidator::validateInt(_descr, "tableTrait", tableTrait.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString highlightColor; _jparser.validateByNameThrow("highlightColor", highlightColor);
	AtfValidator::validateInt(_descr, "highlightColor", highlightColor.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Static::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _parser.parseINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 startingChips; _parser.parseINT32(startingChips);
	AtfValidator::validateInt(_descr, "startingChips", startingChips, _checker, __FILE__, __LINE__);
	INT32 maxPlayers; _parser.parseINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	INT32 playersPerTable; _parser.parseINT32(playersPerTable);
	AtfValidator::validateInt(_descr, "playersPerTable", playersPerTable, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	SrvTime startingTime; _parser.parseSrvTime(startingTime);
	AtfValidator::validateSrvDateTime(_descr, "startingTime", startingTime, _checker, __FILE__, __LINE__);
	SrvTime registrationStarts; _parser.parseSrvTime(registrationStarts);
	AtfValidator::validateSrvDateTime(_descr, "registrationStarts", registrationStarts, _checker, __FILE__, __LINE__);
	SrvTime registrationEnds; _parser.parseSrvTime(registrationEnds);
	AtfValidator::validateSrvDateTime(_descr, "registrationEnds", registrationEnds, _checker, __FILE__, __LINE__);
	SrvTime seatingStarts; _parser.parseSrvTime(seatingStarts);
	AtfValidator::validateSrvDateTime(_descr, "seatingStarts", seatingStarts, _checker, __FILE__, __LINE__);
	INT32 minPlayers; _parser.parseINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	BYTE restricted; _parser.parseBYTE(restricted);
	AtfValidator::validateInt(_descr, "restricted", restricted, _checker, __FILE__, __LINE__);
	INT32 fppReward; _parser.parseINT32(fppReward);
	AtfValidator::validateInt(_descr, "fppReward", fppReward, _checker, __FILE__, __LINE__);
	INT32 fppBuyIn; _parser.parseINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	INT32 numRebuys; _parser.parseINT32(numRebuys);
	AtfValidator::validateInt(_descr, "numRebuys", numRebuys, _checker, __FILE__, __LINE__);
	INT32 rebuyChips; _parser.parseINT32(rebuyChips);
	AtfValidator::validateInt(_descr, "rebuyChips", rebuyChips, _checker, __FILE__, __LINE__);
	INT32 _obsolete_1; _parser.parseINT32(_obsolete_1);
	AtfValidator::validateInt(_descr, "_obsolete_1", _obsolete_1, _checker, __FILE__, __LINE__);
	INT32 rebuyMaxChips; _parser.parseINT32(rebuyMaxChips);
	AtfValidator::validateInt(_descr, "rebuyMaxChips", rebuyMaxChips, _checker, __FILE__, __LINE__);
	INT32 numAddOns; _parser.parseINT32(numAddOns);
	AtfValidator::validateInt(_descr, "numAddOns", numAddOns, _checker, __FILE__, __LINE__);
	INT32 addOnChips; _parser.parseINT32(addOnChips);
	AtfValidator::validateInt(_descr, "addOnChips", addOnChips, _checker, __FILE__, __LINE__);
	INT32 _obsolete_2; _parser.parseINT32(_obsolete_2);
	AtfValidator::validateInt(_descr, "_obsolete_2", _obsolete_2, _checker, __FILE__, __LINE__);
	INT32 addOnMaxChips; _parser.parseINT32(addOnMaxChips);
	AtfValidator::validateInt(_descr, "addOnMaxChips", addOnMaxChips, _checker, __FILE__, __LINE__);
	INT32 scriptPrizeAddOn; _parser.parseINT32(scriptPrizeAddOn);
	AtfValidator::validateInt(_descr, "scriptPrizeAddOn", scriptPrizeAddOn, _checker, __FILE__, __LINE__);
	INT32 guaranteedPrizePool; _parser.parseINT32(guaranteedPrizePool);
	AtfValidator::validateInt(_descr, "guaranteedPrizePool", guaranteedPrizePool, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	INT16 maxAllIns; _parser.parseINT16(maxAllIns);
	AtfValidator::validateInt(_descr, "maxAllIns", maxAllIns, _checker, __FILE__, __LINE__);
	BYTE awardSchema; _parser.parseBYTE(awardSchema);
	AtfValidator::validateInt(_descr, "awardSchema", awardSchema, _checker, __FILE__, __LINE__);
	UINT32 timeBank; _parser.parseUINT32(timeBank);
	AtfValidator::validateInt(_descr, "timeBank", timeBank, _checker, __FILE__, __LINE__);
	INT32 unregistrationEnds_t; _parser.parseINT32(unregistrationEnds_t);
	AtfValidator::validateInt(_descr, "unregistrationEnds_t", unregistrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	INT32 satelliteTargetBuyIn; _parser.parseINT32(satelliteTargetBuyIn);
	AtfValidator::validateInt(_descr, "satelliteTargetBuyIn", satelliteTargetBuyIn, _checker, __FILE__, __LINE__);
	INT32 rebuyFppPrice; _parser.parseINT32(rebuyFppPrice);
	AtfValidator::validateInt(_descr, "rebuyFppPrice", rebuyFppPrice, _checker, __FILE__, __LINE__);
	INT32 addonFppPrice; _parser.parseINT32(addonFppPrice);
	AtfValidator::validateInt(_descr, "addonFppPrice", addonFppPrice, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 startingTime_t; _parser.parseUINT32(startingTime_t);
	AtfValidator::validateInt(_descr, "startingTime_t", startingTime_t, _checker, __FILE__, __LINE__);
	UINT32 registrationStarts_t; _parser.parseUINT32(registrationStarts_t);
	AtfValidator::validateInt(_descr, "registrationStarts_t", registrationStarts_t, _checker, __FILE__, __LINE__);
	UINT32 registrationEnds_t; _parser.parseUINT32(registrationEnds_t);
	AtfValidator::validateInt(_descr, "registrationEnds_t", registrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 seatingStarts_t; _parser.parseUINT32(seatingStarts_t);
	AtfValidator::validateInt(_descr, "seatingStarts_t", seatingStarts_t, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 tournProp2; _parser.parseUINT32(tournProp2);
	AtfValidator::validateInt(_descr, "tournProp2", tournProp2, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTicketTypes = Atf::LAtfVector< P_TicketType, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketTypes", szTicketTypes, _checker, __FILE__, __LINE__);
	UINT32 tableLogo; _parser.parseUINT32(tableLogo);
	AtfValidator::validateInt(_descr, "tableLogo", tableLogo, _checker, __FILE__, __LINE__);
	I18nPString finalTableText; finalTableText.parse(_parser);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	UINT32 lobbyRestricted; _parser.parseUINT32(lobbyRestricted);
	AtfValidator::validateInt(_descr, "lobbyRestricted", lobbyRestricted, _checker, __FILE__, __LINE__);
	INT32 fppFraction; _parser.parseINT32(fppFraction);
	AtfValidator::validateInt(_descr, "fppFraction", fppFraction, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 rebuyFppReward; _parser.parseINT32(rebuyFppReward);
	AtfValidator::validateInt(_descr, "rebuyFppReward", rebuyFppReward, _checker, __FILE__, __LINE__);
	INT32 addOnFppReward; _parser.parseINT32(addOnFppReward);
	AtfValidator::validateInt(_descr, "addOnFppReward", addOnFppReward, _checker, __FILE__, __LINE__);
	INT8 fppRewardPercent; _parser.parseINT8(fppRewardPercent);
	AtfValidator::validateInt(_descr, "fppRewardPercent", fppRewardPercent, _checker, __FILE__, __LINE__);
	UINT32 nPublishLobbyPlayersLess; _parser.parseUINT32(nPublishLobbyPlayersLess);
	AtfValidator::validateInt(_descr, "nPublishLobbyPlayersLess", nPublishLobbyPlayersLess, _checker, __FILE__, __LINE__);
	INT32 bounty; _parser.parseINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	UINT32 placeHolder; _parser.parseUINT32(placeHolder);
	AtfValidator::validateInt(_descr, "placeHolder", placeHolder, _checker, __FILE__, __LINE__);
	_BountiesType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bounties"), _fieldsWithUnparsedContent);
	BYTE publPropFlag; _parser.parseBYTE(publPropFlag);
	AtfValidator::validateInt(_descr, "publPropFlag", publPropFlag, _checker, __FILE__, __LINE__);
	MultidayTourn::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("multiday"), _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _parser.parseUINT16(satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournLevelsOrMinutes; _parser.parseUINT16(timedTournLevelsOrMinutes);
	AtfValidator::validateInt(_descr, "timedTournLevelsOrMinutes", timedTournLevelsOrMinutes, _checker, __FILE__, __LINE__);
	BYTE timedTournPayoutStructure; _parser.parseBYTE(timedTournPayoutStructure);
	AtfValidator::validateInt(_descr, "timedTournPayoutStructure", timedTournPayoutStructure, _checker, __FILE__, __LINE__);
	bool _obsolete_3; _parser.parseBOOL(_obsolete_3);
	AtfValidator::validateInt(_descr, "_obsolete_3", _obsolete_3, _checker, __FILE__, __LINE__);
	int szVppToPublish = Atf::LAtfVector< P_FppReward, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("vppToPublish"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "vppToPublish", szVppToPublish, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournBrand"); size_t szTournBrand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournBrand", szTournBrand, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 blitzNormalDealingThreshold; _parser.parseUINT32(blitzNormalDealingThreshold);
	AtfValidator::validateInt(_descr, "blitzNormalDealingThreshold", blitzNormalDealingThreshold, _checker, __FILE__, __LINE__);
	bool _obsolete_4; _parser.parseBOOL(_obsolete_4);
	AtfValidator::validateInt(_descr, "_obsolete_4", _obsolete_4, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _parser.parseBYTE(progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	I18nPString tableText; tableText.parse(_parser);
	UINT16 reEntryAllowed; _parser.parseUINT16(reEntryAllowed);
	AtfValidator::validateInt(_descr, "reEntryAllowed", reEntryAllowed, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "internalReference"); size_t szInternalReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "internalReference", szInternalReference, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "favoriteReference"); size_t szFavoriteReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "favoriteReference", szFavoriteReference, _checker, __FILE__, __LINE__);
	INT64 ticketPrice; _parser.parseINT64(ticketPrice);
	AtfValidator::validateInt(_descr, "ticketPrice", ticketPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	bool cannotUnregisterFromTarget; _parser.parseBOOL(cannotUnregisterFromTarget);
	AtfValidator::validateInt(_descr, "cannotUnregisterFromTarget", cannotUnregisterFromTarget, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime targetWhenStarts; _parser.parseSrvTime(targetWhenStarts);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStarts", targetWhenStarts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	UINT32 siteMask; _parser.parseUINT32(siteMask);
	AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
	UINT32 publStartLevel; _parser.parseUINT32(publStartLevel);
	AtfValidator::validateInt(_descr, "publStartLevel", publStartLevel, _checker, __FILE__, __LINE__);
	UINT32 tournMask5; _parser.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	BYTE dealExclusionType; _parser.parseBYTE(dealExclusionType);
	AtfValidator::validateInt(_descr, "dealExclusionType", dealExclusionType, _checker, __FILE__, __LINE__);
	INT32 dealExclusionValue; _parser.parseINT32(dealExclusionValue);
	AtfValidator::validateInt(_descr, "dealExclusionValue", dealExclusionValue, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	INT32 _obsolete_5; _parser.parseINT32(_obsolete_5);
	AtfValidator::validateInt(_descr, "_obsolete_5", _obsolete_5, _checker, __FILE__, __LINE__);
	INT32 spinGoStartDelay; _parser.parseINT32(spinGoStartDelay);
	AtfValidator::validateInt(_descr, "spinGoStartDelay", spinGoStartDelay, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _parser.parseBYTE(rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 playerKnockOutAddOn; _parser.parseINT32(playerKnockOutAddOn);
	AtfValidator::validateInt(_descr, "playerKnockOutAddOn", playerKnockOutAddOn, _checker, __FILE__, __LINE__);
	INT32 totalKnockOutAddOn; _parser.parseINT32(totalKnockOutAddOn);
	AtfValidator::validateInt(_descr, "totalKnockOutAddOn", totalKnockOutAddOn, _checker, __FILE__, __LINE__);
	BYTE knockOutAddOnProgressive; _parser.parseBYTE(knockOutAddOnProgressive);
	AtfValidator::validateInt(_descr, "knockOutAddOnProgressive", knockOutAddOnProgressive, _checker, __FILE__, __LINE__);
	UINT32 sitGoStarterGameId; _parser.parseUINT32(sitGoStarterGameId);
	AtfValidator::validateInt(_descr, "sitGoStarterGameId", sitGoStarterGameId, _checker, __FILE__, __LINE__);
	UINT32 numStandardButton; _parser.parseUINT32(numStandardButton);
	AtfValidator::validateInt(_descr, "numStandardButton", numStandardButton, _checker, __FILE__, __LINE__);
	INT32 lateRegDelta; _parser.parseINT32(lateRegDelta);
	AtfValidator::validateInt(_descr, "lateRegDelta", lateRegDelta, _checker, __FILE__, __LINE__);
	INT32 finalTablePlusOne; _parser.parseINT32(finalTablePlusOne);
	AtfValidator::validateInt(_descr, "finalTablePlusOne", finalTablePlusOne, _checker, __FILE__, __LINE__);
	INT32 multidayIndex; _parser.parseINT32(multidayIndex);
	AtfValidator::validateInt(_descr, "multidayIndex", multidayIndex, _checker, __FILE__, __LINE__);
	int szMultiDayVec = Atf::LAtfVector< LobbyData_MultidayTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("multiDayVec"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "multiDayVec", szMultiDayVec, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "groupReference"); size_t szGroupReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "groupReference", szGroupReference, _checker, __FILE__, __LINE__);
	INT32 tournGroup; _parser.parseINT32(tournGroup);
	AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
	INT32 prizePool; _parser.parseINT32(prizePool);
	AtfValidator::validateInt(_descr, "prizePool", prizePool, _checker, __FILE__, __LINE__);
	int szAdmissions = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pokerNgGroup"); size_t szPokerNgGroup = strlen(_dummy);
	AtfValidator::validateInt(_descr, "pokerNgGroup", szPokerNgGroup, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteMaskEx"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "tableTrait"); size_t szTableTrait = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableTrait", szTableTrait, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "highlightColor"); size_t szHighlightColor = strlen(_dummy);
	AtfValidator::validateInt(_descr, "highlightColor", szHighlightColor, _checker, __FILE__, __LINE__);
}

void TournClient::publication::TournSubscr_Static::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	nStackInfoMsg.parseMsg(_parser0);
}

/*static*/ void TournClient::publication::TournSubscr_Static::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	NStackTournInfoStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("nStackInfoMsg"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSubscr_Betting
//=================================================================

TournClient::publication::TournSubscr_Betting::TournSubscr_Betting()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_Betting::TournSubscr_Betting(TournSubscr_Betting&& _o)
	: loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, bringIn(std::move(_o.bringIn))
	, smallBlind(std::move(_o.smallBlind))
	, structure(std::move(_o.structure))
	, ante(std::move(_o.ante))
	, blindsLevel(std::move(_o.blindsLevel))
	, nextLevelOrdinal(std::move(_o.nextLevelOrdinal))
	, nextAnte(std::move(_o.nextAnte))
	, nextSmallBlind(std::move(_o.nextSmallBlind))
	, nextLoBet(std::move(_o.nextLoBet))
	, nextHiBet(std::move(_o.nextHiBet))
	, nextBringIn(std::move(_o.nextBringIn))
	, nextLevelStart_t(std::move(_o.nextLevelStart_t))
	, nextLevelStart(std::move(_o.nextLevelStart))
	, olympicLevel(std::move(_o.olympicLevel))
	, gameType(std::move(_o.gameType))
	, limit(std::move(_o.limit))
	, isHiLo(std::move(_o.isHiLo))
{
}

TournClient::publication::TournSubscr_Betting& TournClient::publication::TournSubscr_Betting::operator=(TournSubscr_Betting&& _o)
{
	if(this != &_o)
	{
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		bringIn = std::move(_o.bringIn);
		smallBlind = std::move(_o.smallBlind);
		structure = std::move(_o.structure);
		ante = std::move(_o.ante);
		blindsLevel = std::move(_o.blindsLevel);
		nextLevelOrdinal = std::move(_o.nextLevelOrdinal);
		nextAnte = std::move(_o.nextAnte);
		nextSmallBlind = std::move(_o.nextSmallBlind);
		nextLoBet = std::move(_o.nextLoBet);
		nextHiBet = std::move(_o.nextHiBet);
		nextBringIn = std::move(_o.nextBringIn);
		nextLevelStart_t = std::move(_o.nextLevelStart_t);
		nextLevelStart = std::move(_o.nextLevelStart);
		olympicLevel = std::move(_o.olympicLevel);
		gameType = std::move(_o.gameType);
		limit = std::move(_o.limit);
		isHiLo = std::move(_o.isHiLo);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_Betting::clear()
{
	loBet = 0;
	hiBet = 0;
	bringIn = 0;
	smallBlind = 0;
	structure = 0;
	ante = 0;
	blindsLevel = 0;
	nextLevelOrdinal = 0;
	nextAnte = 0;
	nextSmallBlind = 0;
	nextLoBet = 0;
	nextHiBet = 0;
	nextBringIn = 0;
	nextLevelStart_t = 0;
	nextLevelStart.setNull();
	olympicLevel = 0;
	gameType = 0;
	limit = 0;
	isHiLo = 0;
}

bool TournClient::publication::TournSubscr_Betting::equals(const TournSubscr_Betting& _o) const
{
	return loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		bringIn == _o.bringIn &&
		smallBlind == _o.smallBlind &&
		structure == _o.structure &&
		ante == _o.ante &&
		blindsLevel == _o.blindsLevel &&
		nextLevelOrdinal == _o.nextLevelOrdinal &&
		nextAnte == _o.nextAnte &&
		nextSmallBlind == _o.nextSmallBlind &&
		nextLoBet == _o.nextLoBet &&
		nextHiBet == _o.nextHiBet &&
		nextBringIn == _o.nextBringIn &&
		nextLevelStart_t == _o.nextLevelStart_t &&
		nextLevelStart.equals(_o.nextLevelStart) &&
		olympicLevel == _o.olympicLevel &&
		gameType == _o.gameType &&
		limit == _o.limit &&
		isHiLo == _o.isHiLo;
}

const char *TournClient::publication::TournSubscr_Betting::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("bringIn=");
	_buf.appendUint(bringIn);
	_buf.append(',');
	_buf.append("smallBlind=");
	_buf.appendUint(smallBlind);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("blindsLevel=");
	_buf.appendUint(blindsLevel);
	_buf.append(',');
	_buf.append("nextLevelOrdinal=");
	_buf.appendUint(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_buf.append(',');
		_buf.append("nextAnte=");
		_buf.appendUint(nextAnte);
		_buf.append(',');
		_buf.append("nextSmallBlind=");
		_buf.appendUint(nextSmallBlind);
		_buf.append(',');
		_buf.append("nextLoBet=");
		_buf.appendUint(nextLoBet);
		_buf.append(',');
		_buf.append("nextHiBet=");
		_buf.appendUint(nextHiBet);
		_buf.append(',');
		_buf.append("nextBringIn=");
		_buf.appendUint(nextBringIn);
		_buf.append(',');
		_buf.append("nextLevelStart_t=");
		_buf.appendUint(nextLevelStart_t);
		_buf.append(',');
		_buf.append("nextLevelStart=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, nextLevelStart);
	}
	_buf.append(',');
	_buf.append("olympicLevel=");
	_buf.appendUint(olympicLevel);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Betting::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("loBet", loBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiBet", hiBet, _buf);
	Atf::XmlElement::encodeAsXmlElement("bringIn", bringIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("smallBlind", smallBlind, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("blindsLevel", blindsLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextLevelOrdinal", nextLevelOrdinal, _buf);
	if( nextLevelOrdinal )
	{
		Atf::XmlElement::encodeAsXmlElement("nextAnte", nextAnte, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextSmallBlind", nextSmallBlind, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextLoBet", nextLoBet, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextHiBet", nextHiBet, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextBringIn", nextBringIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("nextLevelStart_t", nextLevelStart_t, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "nextLevelStart", nextLevelStart);
	}
	Atf::XmlElement::encodeAsXmlElement("olympicLevel", olympicLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Betting::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("loBet"))
		{
			loBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hiBet"))
		{
			hiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bringIn"))
		{
			bringIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("smallBlind"))
		{
			smallBlind = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("blindsLevel"))
		{
			blindsLevel = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextLevelOrdinal"))
		{
			nextLevelOrdinal = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextAnte"))
		{
			nextAnte = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextSmallBlind"))
		{
			nextSmallBlind = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextLoBet"))
		{
			nextLoBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextHiBet"))
		{
			nextHiBet = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextBringIn"))
		{
			nextBringIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextLevelStart_t"))
		{
			nextLevelStart_t = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextLevelStart"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, nextLevelStart);
		}
		else if (_element.equals("olympicLevel"))
		{
			olympicLevel = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameType"))
		{
			gameType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Betting::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeUINT32(bringIn);
	_msg.composeUINT32(smallBlind);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(ante);
	_msg.composeBYTE(blindsLevel);
	_msg.composeBYTE(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_msg.composeUINT32(nextAnte);
		_msg.composeUINT32(nextSmallBlind);
		_msg.composeUINT32(nextLoBet);
		_msg.composeUINT32(nextHiBet);
		_msg.composeUINT32(nextBringIn);
		_msg.composeUINT32(nextLevelStart_t);
		_msg.composeSrvTime(nextLevelStart);
	}
	_msg.composeUINT16(olympicLevel);
	_msg.composeBYTE(gameType);
	_msg.composeBYTE(limit);
	_msg.composeBYTE(isHiLo);
}

void TournClient::publication::TournSubscr_Betting::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseUINT32(bringIn);
	_parser.parseUINT32(smallBlind);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(ante);
	_parser.parseBYTE(blindsLevel);
	_parser.parseBYTE(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_parser.parseUINT32(nextAnte);
		_parser.parseUINT32(nextSmallBlind);
		_parser.parseUINT32(nextLoBet);
		_parser.parseUINT32(nextHiBet);
		_parser.parseUINT32(nextBringIn);
		_parser.parseUINT32(nextLevelStart_t);
		_parser.parseSrvTime(nextLevelStart);
	}
	_parser.parseUINT16(olympicLevel);
	_parser.parseBYTE(gameType);
	_parser.parseBYTE(limit);
	_parser.parseBYTE(isHiLo);
}

const char *TournClient::publication::TournSubscr_Betting::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("loBet", loBet);
	_jsonstr.compose("hiBet", hiBet);
	_jsonstr.compose("bringIn", bringIn);
	_jsonstr.compose("smallBlind", smallBlind);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("blindsLevel", blindsLevel);
	_jsonstr.compose("nextLevelOrdinal", nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_jsonstr.compose("nextAnte", nextAnte);
		_jsonstr.compose("nextSmallBlind", nextSmallBlind);
		_jsonstr.compose("nextLoBet", nextLoBet);
		_jsonstr.compose("nextHiBet", nextHiBet);
		_jsonstr.compose("nextBringIn", nextBringIn);
		_jsonstr.compose("nextLevelStart_t", nextLevelStart_t);
		_jsonstr.compose("nextLevelStart", nextLevelStart);
	}
	_jsonstr.compose("olympicLevel", olympicLevel);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("isHiLo", isHiLo);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Betting::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("loBet", loBet);
	_jparser.parseByNameThrow("hiBet", hiBet);
	_jparser.parseByNameThrow("bringIn", bringIn);
	_jparser.parseByNameThrow("smallBlind", smallBlind);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("blindsLevel", blindsLevel);
	_jparser.parseByNameThrow("nextLevelOrdinal", nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_jparser.parseByNameThrow("nextAnte", nextAnte);
		_jparser.parseByNameThrow("nextSmallBlind", nextSmallBlind);
		_jparser.parseByNameThrow("nextLoBet", nextLoBet);
		_jparser.parseByNameThrow("nextHiBet", nextHiBet);
		_jparser.parseByNameThrow("nextBringIn", nextBringIn);
		_jparser.parseByNameThrow("nextLevelStart_t", nextLevelStart_t);
		_jparser.parseByNameThrow("nextLevelStart", nextLevelStart);
	}
	_jparser.parseByNameThrow("olympicLevel", olympicLevel);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
}

/* static */ void TournClient::publication::TournSubscr_Betting::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE nextLevelOrdinal = 0;
	UINT32 loBet; _jparser.validateByNameThrow("loBet", loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _jparser.validateByNameThrow("hiBet", hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 bringIn; _jparser.validateByNameThrow("bringIn", bringIn);
	AtfValidator::validateInt(_descr, "bringIn", bringIn, _checker, __FILE__, __LINE__);
	UINT32 smallBlind; _jparser.validateByNameThrow("smallBlind", smallBlind);
	AtfValidator::validateInt(_descr, "smallBlind", smallBlind, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE blindsLevel; _jparser.validateByNameThrow("blindsLevel", blindsLevel);
	AtfValidator::validateInt(_descr, "blindsLevel", blindsLevel, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("nextLevelOrdinal", nextLevelOrdinal);
	AtfValidator::validateInt(_descr, "nextLevelOrdinal", nextLevelOrdinal, _checker, __FILE__, __LINE__);
	if( nextLevelOrdinal )
	{
		UINT32 nextAnte; _jparser.validateByNameThrow("nextAnte", nextAnte);
		AtfValidator::validateInt(_descr, "nextAnte", nextAnte, _checker, __FILE__, __LINE__);
		UINT32 nextSmallBlind; _jparser.validateByNameThrow("nextSmallBlind", nextSmallBlind);
		AtfValidator::validateInt(_descr, "nextSmallBlind", nextSmallBlind, _checker, __FILE__, __LINE__);
		UINT32 nextLoBet; _jparser.validateByNameThrow("nextLoBet", nextLoBet);
		AtfValidator::validateInt(_descr, "nextLoBet", nextLoBet, _checker, __FILE__, __LINE__);
		UINT32 nextHiBet; _jparser.validateByNameThrow("nextHiBet", nextHiBet);
		AtfValidator::validateInt(_descr, "nextHiBet", nextHiBet, _checker, __FILE__, __LINE__);
		UINT32 nextBringIn; _jparser.validateByNameThrow("nextBringIn", nextBringIn);
		AtfValidator::validateInt(_descr, "nextBringIn", nextBringIn, _checker, __FILE__, __LINE__);
		UINT32 nextLevelStart_t; _jparser.validateByNameThrow("nextLevelStart_t", nextLevelStart_t);
		AtfValidator::validateInt(_descr, "nextLevelStart_t", nextLevelStart_t, _checker, __FILE__, __LINE__);
		SrvTime nextLevelStart; _jparser.validateByNameThrow("nextLevelStart", nextLevelStart);
		AtfValidator::validateSrvDateTime(_descr, "nextLevelStart", nextLevelStart, _checker, __FILE__, __LINE__);
	}
	UINT16 olympicLevel; _jparser.validateByNameThrow("olympicLevel", olympicLevel);
	AtfValidator::validateInt(_descr, "olympicLevel", olympicLevel, _checker, __FILE__, __LINE__);
	BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Betting::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE nextLevelOrdinal = 0;
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 bringIn; _parser.parseUINT32(bringIn);
	AtfValidator::validateInt(_descr, "bringIn", bringIn, _checker, __FILE__, __LINE__);
	UINT32 smallBlind; _parser.parseUINT32(smallBlind);
	AtfValidator::validateInt(_descr, "smallBlind", smallBlind, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE blindsLevel; _parser.parseBYTE(blindsLevel);
	AtfValidator::validateInt(_descr, "blindsLevel", blindsLevel, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(nextLevelOrdinal);
	AtfValidator::validateInt(_descr, "nextLevelOrdinal", nextLevelOrdinal, _checker, __FILE__, __LINE__);
	if( nextLevelOrdinal )
	{
		UINT32 nextAnte; _parser.parseUINT32(nextAnte);
		AtfValidator::validateInt(_descr, "nextAnte", nextAnte, _checker, __FILE__, __LINE__);
		UINT32 nextSmallBlind; _parser.parseUINT32(nextSmallBlind);
		AtfValidator::validateInt(_descr, "nextSmallBlind", nextSmallBlind, _checker, __FILE__, __LINE__);
		UINT32 nextLoBet; _parser.parseUINT32(nextLoBet);
		AtfValidator::validateInt(_descr, "nextLoBet", nextLoBet, _checker, __FILE__, __LINE__);
		UINT32 nextHiBet; _parser.parseUINT32(nextHiBet);
		AtfValidator::validateInt(_descr, "nextHiBet", nextHiBet, _checker, __FILE__, __LINE__);
		UINT32 nextBringIn; _parser.parseUINT32(nextBringIn);
		AtfValidator::validateInt(_descr, "nextBringIn", nextBringIn, _checker, __FILE__, __LINE__);
		UINT32 nextLevelStart_t; _parser.parseUINT32(nextLevelStart_t);
		AtfValidator::validateInt(_descr, "nextLevelStart_t", nextLevelStart_t, _checker, __FILE__, __LINE__);
		SrvTime nextLevelStart; _parser.parseSrvTime(nextLevelStart);
		AtfValidator::validateSrvDateTime(_descr, "nextLevelStart", nextLevelStart, _checker, __FILE__, __LINE__);
	}
	UINT16 olympicLevel; _parser.parseUINT16(olympicLevel);
	AtfValidator::validateInt(_descr, "olympicLevel", olympicLevel, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	BYTE limit; _parser.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_BettingNew
//=================================================================

//=================================================================
//                _CLevelType
//=================================================================

TournClient::publication::TournSubscr_BettingNew::_CLevelType::_CLevelType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_BettingNew::_CLevelType::_CLevelType(_CLevelType&& _o)
	: currentLevel(std::move(_o.currentLevel))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TournClient::publication::TournSubscr_BettingNew::_CLevelType& TournClient::publication::TournSubscr_BettingNew::_CLevelType::operator=(_CLevelType&& _o)
{
	if(this != &_o)
	{
		currentLevel = std::move(_o.currentLevel);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_BettingNew::_CLevelType::clear()
{
	currentLevel.clear();
	_is_empty_internal = true;
}

bool TournClient::publication::TournSubscr_BettingNew::_CLevelType::equals(const _CLevelType& _o) const
{
	return currentLevel.equals(_o.currentLevel);
}

const char *TournClient::publication::TournSubscr_BettingNew::_CLevelType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("currentLevel=");
		currentLevel.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_BettingNew::_CLevelType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		currentLevel.toXmlString("currentLevel", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_BettingNew::_CLevelType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currentLevel"))
		{
			if(!Atf::AtfTempl< LobbyData_Betting >::FromXmlString(_value, currentLevel)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TournClient::publication::TournSubscr_BettingNew::_CLevelType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		currentLevel.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TournClient::publication::TournSubscr_BettingNew::_CLevelType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	currentLevel.parseMsg(_parser0);
}

const char *TournClient::publication::TournSubscr_BettingNew::_CLevelType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("currentLevel", currentLevel);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_BettingNew::_CLevelType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currentLevel", currentLevel);
}

/* static */ void TournClient::publication::TournSubscr_BettingNew::_CLevelType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	LobbyData_Betting currentLevel; _jparser.validateByNameThrow("currentLevel", currentLevel);
}

/*static*/ void TournClient::publication::TournSubscr_BettingNew::_CLevelType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	LobbyData_Betting::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("currentLevel"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _NLevelType
//=================================================================

TournClient::publication::TournSubscr_BettingNew::_NLevelType::_NLevelType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_BettingNew::_NLevelType::_NLevelType(_NLevelType&& _o)
	: nextLevel(std::move(_o.nextLevel))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TournClient::publication::TournSubscr_BettingNew::_NLevelType& TournClient::publication::TournSubscr_BettingNew::_NLevelType::operator=(_NLevelType&& _o)
{
	if(this != &_o)
	{
		nextLevel = std::move(_o.nextLevel);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_BettingNew::_NLevelType::clear()
{
	nextLevel.clear();
	_is_empty_internal = true;
}

bool TournClient::publication::TournSubscr_BettingNew::_NLevelType::equals(const _NLevelType& _o) const
{
	return nextLevel.equals(_o.nextLevel);
}

const char *TournClient::publication::TournSubscr_BettingNew::_NLevelType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("nextLevel=");
		nextLevel.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_BettingNew::_NLevelType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	if (!isEmptyMsg())
	{
		nextLevel.toXmlString("nextLevel", _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_BettingNew::_NLevelType::fromXmlString(const PString& _str)
{
	_is_empty_internal = true;

	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("nextLevel"))
		{
			if(!Atf::AtfTempl< LobbyData_Betting >::FromXmlString(_value, nextLevel)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}

		_is_empty_internal = false;
	}

	return true;
}

void TournClient::publication::TournSubscr_BettingNew::_NLevelType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		nextLevel.composeMsg(_msg0, _ignoreJSON);
	}

	_msg.composeMsgBody(_msg0);
}

void TournClient::publication::TournSubscr_BettingNew::_NLevelType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	nextLevel.parseMsg(_parser0);
}

const char *TournClient::publication::TournSubscr_BettingNew::_NLevelType::toJSONString(PString& _buf) const
{
	if (!isEmptyMsg())
	{
		Atf::JSONStringComposer _jsonstr(_buf);
		_jsonstr.compose("nextLevel", nextLevel);
	}
	else
	{
		_buf.append("{}");
	}
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_BettingNew::_NLevelType::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("nextLevel", nextLevel);
}

/* static */ void TournClient::publication::TournSubscr_BettingNew::_NLevelType::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_jsonString.equals("{}")) return;
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	LobbyData_Betting nextLevel; _jparser.validateByNameThrow("nextLevel", nextLevel);
}

/*static*/ void TournClient::publication::TournSubscr_BettingNew::_NLevelType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	LobbyData_Betting::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("nextLevel"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

TournClient::publication::TournSubscr_BettingNew::TournSubscr_BettingNew()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_BettingNew::TournSubscr_BettingNew(TournSubscr_BettingNew&& _o)
	: cLevel(std::move(_o.cLevel))
	, nLevel(std::move(_o.nLevel))
	, nextLevelStart(std::move(_o.nextLevelStart))
	, nextLevelStartTime(std::move(_o.nextLevelStartTime))
	, olympicLevel(std::move(_o.olympicLevel))
{
}

TournClient::publication::TournSubscr_BettingNew& TournClient::publication::TournSubscr_BettingNew::operator=(TournSubscr_BettingNew&& _o)
{
	if(this != &_o)
	{
		cLevel = std::move(_o.cLevel);
		nLevel = std::move(_o.nLevel);
		nextLevelStart = std::move(_o.nextLevelStart);
		nextLevelStartTime = std::move(_o.nextLevelStartTime);
		olympicLevel = std::move(_o.olympicLevel);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_BettingNew::clear()
{
	cLevel.clear();
	nLevel.clear();
	nextLevelStart = 0;
	nextLevelStartTime.setNull();
	olympicLevel = 0;
}

bool TournClient::publication::TournSubscr_BettingNew::equals(const TournSubscr_BettingNew& _o) const
{
	return cLevel.equals(_o.cLevel) &&
		nLevel.equals(_o.nLevel) &&
		nextLevelStart == _o.nextLevelStart &&
		nextLevelStartTime.equals(_o.nextLevelStartTime) &&
		olympicLevel == _o.olympicLevel;
}

const char *TournClient::publication::TournSubscr_BettingNew::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cLevel=");
	cLevel.toTraceString(_buf);
	_buf.append(',');
	_buf.append("nLevel=");
	nLevel.toTraceString(_buf);
	_buf.append(',');
	_buf.append("nextLevelStart=");
	_buf.appendUint(nextLevelStart);
	_buf.append(',');
	_buf.append("nextLevelStartTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, nextLevelStartTime);
	_buf.append(',');
	_buf.append("olympicLevel=");
	_buf.appendInt(olympicLevel);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_BettingNew::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	cLevel.toXmlString("cLevel", _buf);
	nLevel.toXmlString("nLevel", _buf);
	Atf::XmlElement::encodeAsXmlElement("nextLevelStart", nextLevelStart, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "nextLevelStartTime", nextLevelStartTime);
	Atf::XmlElement::encodeAsXmlElement("olympicLevel", olympicLevel, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_BettingNew::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cLevel"))
		{
			if(!Atf::AtfTempl< _CLevelType >::FromXmlString(_value, cLevel)) return false;
		}
		else if (_element.equals("nLevel"))
		{
			if(!Atf::AtfTempl< _NLevelType >::FromXmlString(_value, nLevel)) return false;
		}
		else if (_element.equals("nextLevelStart"))
		{
			nextLevelStart = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextLevelStartTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, nextLevelStartTime);
		}
		else if (_element.equals("olympicLevel"))
		{
			olympicLevel = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_BettingNew::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	cLevel.composeMsg(_msg, _ignoreJSON);
	nLevel.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(nextLevelStart);
	_msg.composeSrvTime(nextLevelStartTime);
	_msg.composeINT16(olympicLevel);
}

void TournClient::publication::TournSubscr_BettingNew::parseMsg(CommMsgParser& _parser)
{
	cLevel.parseMsg(_parser);
	nLevel.parseMsg(_parser);
	_parser.parseUINT32(nextLevelStart);
	_parser.parseSrvTime(nextLevelStartTime);
	_parser.parseINT16(olympicLevel);
}

const char *TournClient::publication::TournSubscr_BettingNew::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cLevel", cLevel);
	_jsonstr.compose("nLevel", nLevel);
	_jsonstr.compose("nextLevelStart", nextLevelStart);
	_jsonstr.compose("nextLevelStartTime", nextLevelStartTime);
	_jsonstr.compose("olympicLevel", olympicLevel);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_BettingNew::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cLevel", cLevel);
	_jparser.parseByNameThrow("nLevel", nLevel);
	_jparser.parseByNameThrow("nextLevelStart", nextLevelStart);
	_jparser.parseByNameThrow("nextLevelStartTime", nextLevelStartTime);
	_jparser.parseByNameThrow("olympicLevel", olympicLevel);
}

/* static */ void TournClient::publication::TournSubscr_BettingNew::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	_CLevelType cLevel; _jparser.validateByNameThrow("cLevel", cLevel);
	_NLevelType nLevel; _jparser.validateByNameThrow("nLevel", nLevel);
	UINT32 nextLevelStart; _jparser.validateByNameThrow("nextLevelStart", nextLevelStart);
	AtfValidator::validateInt(_descr, "nextLevelStart", nextLevelStart, _checker, __FILE__, __LINE__);
	SrvTime nextLevelStartTime; _jparser.validateByNameThrow("nextLevelStartTime", nextLevelStartTime);
	AtfValidator::validateSrvDateTime(_descr, "nextLevelStartTime", nextLevelStartTime, _checker, __FILE__, __LINE__);
	INT16 olympicLevel; _jparser.validateByNameThrow("olympicLevel", olympicLevel);
	AtfValidator::validateInt(_descr, "olympicLevel", olympicLevel, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_BettingNew::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	_CLevelType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cLevel"), _fieldsWithUnparsedContent);
	_NLevelType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nLevel"), _fieldsWithUnparsedContent);
	UINT32 nextLevelStart; _parser.parseUINT32(nextLevelStart);
	AtfValidator::validateInt(_descr, "nextLevelStart", nextLevelStart, _checker, __FILE__, __LINE__);
	SrvTime nextLevelStartTime; _parser.parseSrvTime(nextLevelStartTime);
	AtfValidator::validateSrvDateTime(_descr, "nextLevelStartTime", nextLevelStartTime, _checker, __FILE__, __LINE__);
	INT16 olympicLevel; _parser.parseINT16(olympicLevel);
	AtfValidator::validateInt(_descr, "olympicLevel", olympicLevel, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Status
//=================================================================

TournClient::publication::TournSubscr_Status::TournSubscr_Status()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_Status::TournSubscr_Status(TournSubscr_Status&& _o)
	: status(std::move(_o.status))
	, newStartTimeFlightTourn(std::move(_o.newStartTimeFlightTourn))
	, minutesLateFlightTourn(std::move(_o.minutesLateFlightTourn))
	, createdBy(std::move(_o.createdBy))
	, cancelledBy(std::move(_o.cancelledBy))
	, isBlitzTourn(std::move(_o.isBlitzTourn))
	, timedTournPlayersThreshold(std::move(_o.timedTournPlayersThreshold))
	, sameLevelFlightsAvailable(std::move(_o.sameLevelFlightsAvailable))
	, nextLevelFlightsAvailable(std::move(_o.nextLevelFlightsAvailable))
	, delayedPlaceDelta(std::move(_o.delayedPlaceDelta))
	, activeFlags(std::move(_o.activeFlags))
	, isWinTheButtonTourn(std::move(_o.isWinTheButtonTourn))
{
}

TournClient::publication::TournSubscr_Status& TournClient::publication::TournSubscr_Status::operator=(TournSubscr_Status&& _o)
{
	if(this != &_o)
	{
		status = std::move(_o.status);
		newStartTimeFlightTourn = std::move(_o.newStartTimeFlightTourn);
		minutesLateFlightTourn = std::move(_o.minutesLateFlightTourn);
		createdBy = std::move(_o.createdBy);
		cancelledBy = std::move(_o.cancelledBy);
		isBlitzTourn = std::move(_o.isBlitzTourn);
		timedTournPlayersThreshold = std::move(_o.timedTournPlayersThreshold);
		sameLevelFlightsAvailable = std::move(_o.sameLevelFlightsAvailable);
		nextLevelFlightsAvailable = std::move(_o.nextLevelFlightsAvailable);
		delayedPlaceDelta = std::move(_o.delayedPlaceDelta);
		activeFlags = std::move(_o.activeFlags);
		isWinTheButtonTourn = std::move(_o.isWinTheButtonTourn);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_Status::clear()
{
	status = 0;
	newStartTimeFlightTourn.setNull();
	minutesLateFlightTourn = 0;
	createdBy.clear();
	cancelledBy.clear();
	isBlitzTourn = false;
	timedTournPlayersThreshold = 0;
	sameLevelFlightsAvailable = false;
	nextLevelFlightsAvailable = false;
	delayedPlaceDelta = 0;
	activeFlags = 0;
	isWinTheButtonTourn = false;
}

bool TournClient::publication::TournSubscr_Status::equals(const TournSubscr_Status& _o) const
{
	return status == _o.status &&
		newStartTimeFlightTourn.equals(_o.newStartTimeFlightTourn) &&
		minutesLateFlightTourn == _o.minutesLateFlightTourn &&
		Atf::atfPStringEquals(createdBy, _o.createdBy) &&
		Atf::atfPStringEquals(cancelledBy, _o.cancelledBy) &&
		isBlitzTourn == _o.isBlitzTourn &&
		timedTournPlayersThreshold == _o.timedTournPlayersThreshold &&
		sameLevelFlightsAvailable == _o.sameLevelFlightsAvailable &&
		nextLevelFlightsAvailable == _o.nextLevelFlightsAvailable &&
		delayedPlaceDelta == _o.delayedPlaceDelta &&
		activeFlags == _o.activeFlags &&
		isWinTheButtonTourn == _o.isWinTheButtonTourn;
}

const char *TournClient::publication::TournSubscr_Status::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("newStartTimeFlightTourn=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, newStartTimeFlightTourn);
	_buf.append(',');
	_buf.append("minutesLateFlightTourn=");
	_buf.appendUint(minutesLateFlightTourn);
	_buf.append(',');
	_buf.append("createdBy=");
	_buf.append(createdBy);
	_buf.append(',');
	_buf.append("cancelledBy=");
	_buf.append(cancelledBy);
	_buf.append(',');
	_buf.append("isBlitzTourn=");
	_buf.appendUint(isBlitzTourn);
	_buf.append(',');
	_buf.append("timedTournPlayersThreshold=");
	_buf.appendUint(timedTournPlayersThreshold);
	_buf.append(',');
	_buf.append("sameLevelFlightsAvailable=");
	_buf.appendUint(sameLevelFlightsAvailable);
	_buf.append(',');
	_buf.append("nextLevelFlightsAvailable=");
	_buf.appendUint(nextLevelFlightsAvailable);
	_buf.append(',');
	_buf.append("delayedPlaceDelta=");
	_buf.appendInt(delayedPlaceDelta);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("isWinTheButtonTourn=");
	_buf.appendUint(isWinTheButtonTourn);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Status::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "newStartTimeFlightTourn", newStartTimeFlightTourn);
	Atf::XmlElement::encodeAsXmlElement("minutesLateFlightTourn", minutesLateFlightTourn, _buf);
	Atf::XmlElement::encodeAsXmlElement("createdBy", createdBy, _buf);
	Atf::XmlElement::encodeAsXmlElement("cancelledBy", cancelledBy, _buf);
	Atf::XmlElement::encodeAsXmlElement("isBlitzTourn", isBlitzTourn, _buf);
	Atf::XmlElement::encodeAsXmlElement("timedTournPlayersThreshold", timedTournPlayersThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("sameLevelFlightsAvailable", sameLevelFlightsAvailable, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextLevelFlightsAvailable", nextLevelFlightsAvailable, _buf);
	Atf::XmlElement::encodeAsXmlElement("delayedPlaceDelta", delayedPlaceDelta, _buf);
	Atf::XmlElement::encodeAsXmlElement("activeFlags", activeFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("isWinTheButtonTourn", isWinTheButtonTourn, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Status::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("newStartTimeFlightTourn"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, newStartTimeFlightTourn);
		}
		else if (_element.equals("minutesLateFlightTourn"))
		{
			minutesLateFlightTourn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("createdBy"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, createdBy)) return false;
		}
		else if (_element.equals("cancelledBy"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cancelledBy)) return false;
		}
		else if (_element.equals("isBlitzTourn"))
		{
			isBlitzTourn = (*_value.ptr() == '1');
		}
		else if (_element.equals("timedTournPlayersThreshold"))
		{
			timedTournPlayersThreshold = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sameLevelFlightsAvailable"))
		{
			sameLevelFlightsAvailable = (*_value.ptr() == '1');
		}
		else if (_element.equals("nextLevelFlightsAvailable"))
		{
			nextLevelFlightsAvailable = (*_value.ptr() == '1');
		}
		else if (_element.equals("delayedPlaceDelta"))
		{
			delayedPlaceDelta = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("activeFlags"))
		{
			activeFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isWinTheButtonTourn"))
		{
			isWinTheButtonTourn = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Status::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(status);
	_msg.composeSrvTime(newStartTimeFlightTourn);
	_msg.composeUINT32(minutesLateFlightTourn);
	_msg.composeString(createdBy);
	_msg.composeString(cancelledBy);
	_msg.composeBOOL(isBlitzTourn);
	_msg.composeUINT32(timedTournPlayersThreshold);
	_msg.composeBOOL(sameLevelFlightsAvailable);
	_msg.composeBOOL(nextLevelFlightsAvailable);
	_msg.composeINT32(delayedPlaceDelta);
	_msg.composeUINT32(activeFlags);
	_msg.composeBOOL(isWinTheButtonTourn);
}

void TournClient::publication::TournSubscr_Status::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
	_parser.parseSrvTime(newStartTimeFlightTourn);
	_parser.parseUINT32(minutesLateFlightTourn);
	_parser.parseStringP(createdBy);
	_parser.parseStringP(cancelledBy);
	_parser.parseBOOL(isBlitzTourn);
	_parser.parseUINT32(timedTournPlayersThreshold);
	_parser.parseBOOL(sameLevelFlightsAvailable);
	_parser.parseBOOL(nextLevelFlightsAvailable);
	_parser.parseINT32(delayedPlaceDelta);
	_parser.parseUINT32(activeFlags);
	_parser.parseBOOL(isWinTheButtonTourn);
}

const char *TournClient::publication::TournSubscr_Status::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	_jsonstr.compose("newStartTimeFlightTourn", newStartTimeFlightTourn);
	_jsonstr.compose("minutesLateFlightTourn", minutesLateFlightTourn);
	_jsonstr.compose("createdBy", createdBy);
	_jsonstr.compose("cancelledBy", cancelledBy);
	_jsonstr.compose("isBlitzTourn", isBlitzTourn);
	_jsonstr.compose("timedTournPlayersThreshold", timedTournPlayersThreshold);
	_jsonstr.compose("sameLevelFlightsAvailable", sameLevelFlightsAvailable);
	_jsonstr.compose("nextLevelFlightsAvailable", nextLevelFlightsAvailable);
	_jsonstr.compose("delayedPlaceDelta", delayedPlaceDelta);
	_jsonstr.compose("activeFlags", activeFlags);
	_jsonstr.compose("isWinTheButtonTourn", isWinTheButtonTourn);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Status::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("newStartTimeFlightTourn", newStartTimeFlightTourn);
	_jparser.parseByNameThrow("minutesLateFlightTourn", minutesLateFlightTourn);
	_jparser.parseByNameThrow("createdBy", createdBy);
	_jparser.parseByNameThrow("cancelledBy", cancelledBy);
	_jparser.parseByNameThrow("isBlitzTourn", isBlitzTourn);
	_jparser.parseByNameThrow("timedTournPlayersThreshold", timedTournPlayersThreshold);
	_jparser.parseByNameThrow("sameLevelFlightsAvailable", sameLevelFlightsAvailable);
	_jparser.parseByNameThrow("nextLevelFlightsAvailable", nextLevelFlightsAvailable);
	_jparser.parseByNameThrow("delayedPlaceDelta", delayedPlaceDelta);
	_jparser.parseByNameThrow("activeFlags", activeFlags);
	_jparser.parseByNameThrow("isWinTheButtonTourn", isWinTheButtonTourn);
}

/* static */ void TournClient::publication::TournSubscr_Status::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime newStartTimeFlightTourn; _jparser.validateByNameThrow("newStartTimeFlightTourn", newStartTimeFlightTourn);
	AtfValidator::validateSrvDateTime(_descr, "newStartTimeFlightTourn", newStartTimeFlightTourn, _checker, __FILE__, __LINE__);
	UINT32 minutesLateFlightTourn; _jparser.validateByNameThrow("minutesLateFlightTourn", minutesLateFlightTourn);
	AtfValidator::validateInt(_descr, "minutesLateFlightTourn", minutesLateFlightTourn, _checker, __FILE__, __LINE__);
	PString createdBy; _jparser.validateByNameThrow("createdBy", createdBy);
	AtfValidator::validateInt(_descr, "createdBy", createdBy.length(), _checker, __FILE__, __LINE__);
	PString cancelledBy; _jparser.validateByNameThrow("cancelledBy", cancelledBy);
	AtfValidator::validateInt(_descr, "cancelledBy", cancelledBy.length(), _checker, __FILE__, __LINE__);
	bool isBlitzTourn; _jparser.validateByNameThrow("isBlitzTourn", isBlitzTourn);
	AtfValidator::validateInt(_descr, "isBlitzTourn", isBlitzTourn, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _jparser.validateByNameThrow("timedTournPlayersThreshold", timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	bool sameLevelFlightsAvailable; _jparser.validateByNameThrow("sameLevelFlightsAvailable", sameLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "sameLevelFlightsAvailable", sameLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	bool nextLevelFlightsAvailable; _jparser.validateByNameThrow("nextLevelFlightsAvailable", nextLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "nextLevelFlightsAvailable", nextLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	INT32 delayedPlaceDelta; _jparser.validateByNameThrow("delayedPlaceDelta", delayedPlaceDelta);
	AtfValidator::validateInt(_descr, "delayedPlaceDelta", delayedPlaceDelta, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _jparser.validateByNameThrow("activeFlags", activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	bool isWinTheButtonTourn; _jparser.validateByNameThrow("isWinTheButtonTourn", isWinTheButtonTourn);
	AtfValidator::validateInt(_descr, "isWinTheButtonTourn", isWinTheButtonTourn, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Status::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime newStartTimeFlightTourn; _parser.parseSrvTime(newStartTimeFlightTourn);
	AtfValidator::validateSrvDateTime(_descr, "newStartTimeFlightTourn", newStartTimeFlightTourn, _checker, __FILE__, __LINE__);
	UINT32 minutesLateFlightTourn; _parser.parseUINT32(minutesLateFlightTourn);
	AtfValidator::validateInt(_descr, "minutesLateFlightTourn", minutesLateFlightTourn, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "createdBy"); size_t szCreatedBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "createdBy", szCreatedBy, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cancelledBy"); size_t szCancelledBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cancelledBy", szCancelledBy, _checker, __FILE__, __LINE__);
	bool isBlitzTourn; _parser.parseBOOL(isBlitzTourn);
	AtfValidator::validateInt(_descr, "isBlitzTourn", isBlitzTourn, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _parser.parseUINT32(timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	bool sameLevelFlightsAvailable; _parser.parseBOOL(sameLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "sameLevelFlightsAvailable", sameLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	bool nextLevelFlightsAvailable; _parser.parseBOOL(nextLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "nextLevelFlightsAvailable", nextLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	INT32 delayedPlaceDelta; _parser.parseINT32(delayedPlaceDelta);
	AtfValidator::validateInt(_descr, "delayedPlaceDelta", delayedPlaceDelta, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	bool isWinTheButtonTourn; _parser.parseBOOL(isWinTheButtonTourn);
	AtfValidator::validateInt(_descr, "isWinTheButtonTourn", isWinTheButtonTourn, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Board
//=================================================================

TournClient::publication::TournSubscr_Board::TournSubscr_Board()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_Board::TournSubscr_Board(TournSubscr_Board&& _o)
	: itSessionId(std::move(_o.itSessionId))
{
}

TournClient::publication::TournSubscr_Board& TournClient::publication::TournSubscr_Board::operator=(TournSubscr_Board&& _o)
{
	if(this != &_o)
	{
		itSessionId = std::move(_o.itSessionId);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_Board::clear()
{
	itSessionId.clear();
}

bool TournClient::publication::TournSubscr_Board::equals(const TournSubscr_Board& _o) const
{
	return Atf::atfPStringEquals(itSessionId, _o.itSessionId);
}

const char *TournClient::publication::TournSubscr_Board::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("itSessionId=");
	_buf.append(itSessionId);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Board::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("itSessionId", itSessionId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Board::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("itSessionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, itSessionId)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Board::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(itSessionId);
}

void TournClient::publication::TournSubscr_Board::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(itSessionId);
}

const char *TournClient::publication::TournSubscr_Board::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("itSessionId", itSessionId);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Board::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("itSessionId", itSessionId);
}

/* static */ void TournClient::publication::TournSubscr_Board::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString itSessionId; _jparser.validateByNameThrow("itSessionId", itSessionId);
	AtfValidator::validateInt(_descr, "itSessionId", itSessionId.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Board::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "itSessionId"); size_t szItSessionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "itSessionId", szItSessionId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Break
//=================================================================

TournClient::publication::TournSubscr_Break::TournSubscr_Break()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_Break::TournSubscr_Break(TournSubscr_Break&& _o)
	: nextBreakStarts(std::move(_o.nextBreakStarts))
	, currentBreakStops(std::move(_o.currentBreakStops))
	, currentBreakDuration(std::move(_o.currentBreakDuration))
	, nextBreakStarts_t(std::move(_o.nextBreakStarts_t))
	, currentBreakStops_t(std::move(_o.currentBreakStops_t))
	, addOnEligibleBreak(std::move(_o.addOnEligibleBreak))
	, blitzTableRound(std::move(_o.blitzTableRound))
	, message(std::move(_o.message))
{
}

TournClient::publication::TournSubscr_Break& TournClient::publication::TournSubscr_Break::operator=(TournSubscr_Break&& _o)
{
	if(this != &_o)
	{
		nextBreakStarts = std::move(_o.nextBreakStarts);
		currentBreakStops = std::move(_o.currentBreakStops);
		currentBreakDuration = std::move(_o.currentBreakDuration);
		nextBreakStarts_t = std::move(_o.nextBreakStarts_t);
		currentBreakStops_t = std::move(_o.currentBreakStops_t);
		addOnEligibleBreak = std::move(_o.addOnEligibleBreak);
		blitzTableRound = std::move(_o.blitzTableRound);
		message = std::move(_o.message);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_Break::clear()
{
	nextBreakStarts.setNull();
	currentBreakStops.setNull();
	currentBreakDuration = 0;
	nextBreakStarts_t = 0;
	currentBreakStops_t = 0;
	addOnEligibleBreak = false;
	blitzTableRound = 0;
	message.clear();
}

bool TournClient::publication::TournSubscr_Break::equals(const TournSubscr_Break& _o) const
{
	return nextBreakStarts.equals(_o.nextBreakStarts) &&
		currentBreakStops.equals(_o.currentBreakStops) &&
		currentBreakDuration == _o.currentBreakDuration &&
		nextBreakStarts_t == _o.nextBreakStarts_t &&
		currentBreakStops_t == _o.currentBreakStops_t &&
		addOnEligibleBreak == _o.addOnEligibleBreak &&
		blitzTableRound == _o.blitzTableRound &&
		message.equals(_o.message);
}

const char *TournClient::publication::TournSubscr_Break::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("nextBreakStarts=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, nextBreakStarts);
	_buf.append(',');
	_buf.append("currentBreakStops=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, currentBreakStops);
	_buf.append(',');
	_buf.append("currentBreakDuration=");
	_buf.appendUint(currentBreakDuration);
	_buf.append(',');
	_buf.append("nextBreakStarts_t=");
	_buf.appendUint(nextBreakStarts_t);
	_buf.append(',');
	_buf.append("currentBreakStops_t=");
	_buf.appendUint(currentBreakStops_t);
	_buf.append(',');
	_buf.append("addOnEligibleBreak=");
	_buf.appendUint(addOnEligibleBreak);
	_buf.append(',');
	_buf.append("blitzTableRound=");
	_buf.appendInt(blitzTableRound);
	_buf.append(',');
	_buf.append("message=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, message);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Break::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "nextBreakStarts", nextBreakStarts);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "currentBreakStops", currentBreakStops);
	Atf::XmlElement::encodeAsXmlElement("currentBreakDuration", currentBreakDuration, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextBreakStarts_t", nextBreakStarts_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentBreakStops_t", currentBreakStops_t, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnEligibleBreak", addOnEligibleBreak, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzTableRound", blitzTableRound, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "message", message);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Break::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("nextBreakStarts"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, nextBreakStarts);
		}
		else if (_element.equals("currentBreakStops"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, currentBreakStops);
		}
		else if (_element.equals("currentBreakDuration"))
		{
			currentBreakDuration = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextBreakStarts_t"))
		{
			nextBreakStarts_t = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currentBreakStops_t"))
		{
			currentBreakStops_t = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addOnEligibleBreak"))
		{
			addOnEligibleBreak = (*_value.ptr() == '1');
		}
		else if (_element.equals("blitzTableRound"))
		{
			blitzTableRound = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("message"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, message);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Break::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(nextBreakStarts);
	_msg.composeSrvTime(currentBreakStops);
	_msg.composeUINT32(currentBreakDuration);
	_msg.composeUINT32(nextBreakStarts_t);
	_msg.composeUINT32(currentBreakStops_t);
	_msg.composeBOOL(addOnEligibleBreak);
	_msg.composeINT32(blitzTableRound);
	message.compose(_msg);
}

void TournClient::publication::TournSubscr_Break::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(nextBreakStarts);
	_parser.parseSrvTime(currentBreakStops);
	_parser.parseUINT32(currentBreakDuration);
	_parser.parseUINT32(nextBreakStarts_t);
	_parser.parseUINT32(currentBreakStops_t);
	_parser.parseBOOL(addOnEligibleBreak);
	_parser.parseINT32(blitzTableRound);
	message.parse(_parser);
}

const char *TournClient::publication::TournSubscr_Break::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("nextBreakStarts", nextBreakStarts);
	_jsonstr.compose("currentBreakStops", currentBreakStops);
	_jsonstr.compose("currentBreakDuration", currentBreakDuration);
	_jsonstr.compose("nextBreakStarts_t", nextBreakStarts_t);
	_jsonstr.compose("currentBreakStops_t", currentBreakStops_t);
	_jsonstr.compose("addOnEligibleBreak", addOnEligibleBreak);
	_jsonstr.compose("blitzTableRound", blitzTableRound);
	_jsonstr.compose("message", message);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Break::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("nextBreakStarts", nextBreakStarts);
	_jparser.parseByNameThrow("currentBreakStops", currentBreakStops);
	_jparser.parseByNameThrow("currentBreakDuration", currentBreakDuration);
	_jparser.parseByNameThrow("nextBreakStarts_t", nextBreakStarts_t);
	_jparser.parseByNameThrow("currentBreakStops_t", currentBreakStops_t);
	_jparser.parseByNameThrow("addOnEligibleBreak", addOnEligibleBreak);
	_jparser.parseByNameThrow("blitzTableRound", blitzTableRound);
	_jparser.parseByNameThrow("message", message);
}

/* static */ void TournClient::publication::TournSubscr_Break::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime nextBreakStarts; _jparser.validateByNameThrow("nextBreakStarts", nextBreakStarts);
	AtfValidator::validateSrvDateTime(_descr, "nextBreakStarts", nextBreakStarts, _checker, __FILE__, __LINE__);
	SrvTime currentBreakStops; _jparser.validateByNameThrow("currentBreakStops", currentBreakStops);
	AtfValidator::validateSrvDateTime(_descr, "currentBreakStops", currentBreakStops, _checker, __FILE__, __LINE__);
	UINT32 currentBreakDuration; _jparser.validateByNameThrow("currentBreakDuration", currentBreakDuration);
	AtfValidator::validateInt(_descr, "currentBreakDuration", currentBreakDuration, _checker, __FILE__, __LINE__);
	UINT32 nextBreakStarts_t; _jparser.validateByNameThrow("nextBreakStarts_t", nextBreakStarts_t);
	AtfValidator::validateInt(_descr, "nextBreakStarts_t", nextBreakStarts_t, _checker, __FILE__, __LINE__);
	UINT32 currentBreakStops_t; _jparser.validateByNameThrow("currentBreakStops_t", currentBreakStops_t);
	AtfValidator::validateInt(_descr, "currentBreakStops_t", currentBreakStops_t, _checker, __FILE__, __LINE__);
	bool addOnEligibleBreak; _jparser.validateByNameThrow("addOnEligibleBreak", addOnEligibleBreak);
	AtfValidator::validateInt(_descr, "addOnEligibleBreak", addOnEligibleBreak, _checker, __FILE__, __LINE__);
	INT32 blitzTableRound; _jparser.validateByNameThrow("blitzTableRound", blitzTableRound);
	AtfValidator::validateInt(_descr, "blitzTableRound", blitzTableRound, _checker, __FILE__, __LINE__);
	I18nPString message; _jparser.validateByNameThrow("message", message);
}

/*static*/ void TournClient::publication::TournSubscr_Break::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime nextBreakStarts; _parser.parseSrvTime(nextBreakStarts);
	AtfValidator::validateSrvDateTime(_descr, "nextBreakStarts", nextBreakStarts, _checker, __FILE__, __LINE__);
	SrvTime currentBreakStops; _parser.parseSrvTime(currentBreakStops);
	AtfValidator::validateSrvDateTime(_descr, "currentBreakStops", currentBreakStops, _checker, __FILE__, __LINE__);
	UINT32 currentBreakDuration; _parser.parseUINT32(currentBreakDuration);
	AtfValidator::validateInt(_descr, "currentBreakDuration", currentBreakDuration, _checker, __FILE__, __LINE__);
	UINT32 nextBreakStarts_t; _parser.parseUINT32(nextBreakStarts_t);
	AtfValidator::validateInt(_descr, "nextBreakStarts_t", nextBreakStarts_t, _checker, __FILE__, __LINE__);
	UINT32 currentBreakStops_t; _parser.parseUINT32(currentBreakStops_t);
	AtfValidator::validateInt(_descr, "currentBreakStops_t", currentBreakStops_t, _checker, __FILE__, __LINE__);
	bool addOnEligibleBreak; _parser.parseBOOL(addOnEligibleBreak);
	AtfValidator::validateInt(_descr, "addOnEligibleBreak", addOnEligibleBreak, _checker, __FILE__, __LINE__);
	INT32 blitzTableRound; _parser.parseINT32(blitzTableRound);
	AtfValidator::validateInt(_descr, "blitzTableRound", blitzTableRound, _checker, __FILE__, __LINE__);
	I18nPString message; message.parse(_parser);
}

//=================================================================
//                    TournSubscr_Closed
//=================================================================

TournClient::publication::TournSubscr_Closed::TournSubscr_Closed()
{
	clear();
}

void TournClient::publication::TournSubscr_Closed::clear()
{
	closed.setNull();
}

bool TournClient::publication::TournSubscr_Closed::equals(const TournSubscr_Closed& _o) const
{
	return closed.equals(_o.closed);
}

const char *TournClient::publication::TournSubscr_Closed::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("closed=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, closed);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Closed::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "closed", closed);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Closed::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("closed"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, closed);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Closed::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(closed);
}

void TournClient::publication::TournSubscr_Closed::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(closed);
}

const char *TournClient::publication::TournSubscr_Closed::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("closed", closed);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Closed::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("closed", closed);
}

/* static */ void TournClient::publication::TournSubscr_Closed::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime closed; _jparser.validateByNameThrow("closed", closed);
	AtfValidator::validateSrvDateTime(_descr, "closed", closed, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Closed::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime closed; _parser.parseSrvTime(closed);
	AtfValidator::validateSrvDateTime(_descr, "closed", closed, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Awards
//=================================================================

TournClient::publication::TournSubscr_Awards::TournSubscr_Awards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_Awards::TournSubscr_Awards(TournSubscr_Awards&& _o)
	: effectivePrizePool(std::move(_o.effectivePrizePool))
	, prizes(std::move(_o.prizes))
	, nTickets(std::move(_o.nTickets))
	, nextTournIds(std::move(_o.nextTournIds))
	, creditPlayer(std::move(_o.creditPlayer))
	, mixTournSatellite(std::move(_o.mixTournSatellite))
{
}

TournClient::publication::TournSubscr_Awards& TournClient::publication::TournSubscr_Awards::operator=(TournSubscr_Awards&& _o)
{
	if(this != &_o)
	{
		effectivePrizePool = std::move(_o.effectivePrizePool);
		prizes = std::move(_o.prizes);
		nTickets = std::move(_o.nTickets);
		nextTournIds = std::move(_o.nextTournIds);
		creditPlayer = std::move(_o.creditPlayer);
		mixTournSatellite = std::move(_o.mixTournSatellite);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_Awards::clear()
{
	effectivePrizePool = 0;
	prizes.clear();
	nTickets = 0;
	nextTournIds.clear();
	creditPlayer = 0;
	mixTournSatellite = 0;
}

bool TournClient::publication::TournSubscr_Awards::equals(const TournSubscr_Awards& _o) const
{
	return effectivePrizePool == _o.effectivePrizePool &&
		prizes.equals(_o.prizes) &&
		nTickets == _o.nTickets &&
		nextTournIds.equals(_o.nextTournIds) &&
		creditPlayer == _o.creditPlayer &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *TournClient::publication::TournSubscr_Awards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("effectivePrizePool=");
	_buf.appendInt(effectivePrizePool);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("nTickets=");
	_buf.appendUint(nTickets);
	_buf.append(',');
	_buf.append("nextTournIds=");
	nextTournIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("creditPlayer=");
	_buf.appendInt(creditPlayer);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendInt(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Awards::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("effectivePrizePool", effectivePrizePool, _buf);
	prizes.toXmlString("prizes", _buf);
	Atf::XmlElement::encodeAsXmlElement("nTickets", nTickets, _buf);
	nextTournIds.toXmlString("nextTournIds", _buf);
	Atf::XmlElement::encodeAsXmlElement("creditPlayer", creditPlayer, _buf);
	Atf::XmlElement::encodeAsXmlElement("mixTournSatellite", mixTournSatellite, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Awards::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("effectivePrizePool"))
		{
			effectivePrizePool = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else if (_element.equals("nTickets"))
		{
			nTickets = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextTournIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, nextTournIds)) return false;
		}
		else if (_element.equals("creditPlayer"))
		{
			creditPlayer = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mixTournSatellite"))
		{
			mixTournSatellite = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Awards::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(effectivePrizePool);
	prizes.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(nTickets);
	nextTournIds.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(creditPlayer);
	_msg.composeINT8(mixTournSatellite);
}

void TournClient::publication::TournSubscr_Awards::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(effectivePrizePool);
	prizes.parseMsg(_parser);
	_parser.parseUINT32(nTickets);
	nextTournIds.parseMsg(_parser);
	_parser.parseINT32(creditPlayer);
	_parser.parseINT8(mixTournSatellite);
}

const char *TournClient::publication::TournSubscr_Awards::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("effectivePrizePool", effectivePrizePool);
	_jsonstr.compose("prizes", prizes);
	_jsonstr.compose("nTickets", nTickets);
	_jsonstr.compose("nextTournIds", nextTournIds);
	_jsonstr.compose("creditPlayer", creditPlayer);
	_jsonstr.compose("mixTournSatellite", mixTournSatellite);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Awards::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("effectivePrizePool", effectivePrizePool);
	_jparser.parseByNameThrow("prizes", prizes);
	_jparser.parseByNameThrow("nTickets", nTickets);
	_jparser.parseByNameThrow("nextTournIds", nextTournIds);
	_jparser.parseByNameThrow("creditPlayer", creditPlayer);
	_jparser.parseByNameThrow("mixTournSatellite", mixTournSatellite);
}

/* static */ void TournClient::publication::TournSubscr_Awards::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 effectivePrizePool; _jparser.validateByNameThrow("effectivePrizePool", effectivePrizePool);
	AtfValidator::validateInt(_descr, "effectivePrizePool", effectivePrizePool, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
	UINT32 nTickets; _jparser.validateByNameThrow("nTickets", nTickets);
	AtfValidator::validateInt(_descr, "nTickets", nTickets, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > nextTournIds; _jparser.validateByNameThrow("nextTournIds", nextTournIds);
	AtfValidator::validateInt(_descr, "nextTournIds", nextTournIds.size(), _checker, __FILE__, __LINE__);
	INT32 creditPlayer; _jparser.validateByNameThrow("creditPlayer", creditPlayer);
	AtfValidator::validateInt(_descr, "creditPlayer", creditPlayer, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _jparser.validateByNameThrow("mixTournSatellite", mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Awards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 effectivePrizePool; _parser.parseINT32(effectivePrizePool);
	AtfValidator::validateInt(_descr, "effectivePrizePool", effectivePrizePool, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	UINT32 nTickets; _parser.parseUINT32(nTickets);
	AtfValidator::validateInt(_descr, "nTickets", nTickets, _checker, __FILE__, __LINE__);
	int szNextTournIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nextTournIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "nextTournIds", szNextTournIds, _checker, __FILE__, __LINE__);
	INT32 creditPlayer; _parser.parseINT32(creditPlayer);
	AtfValidator::validateInt(_descr, "creditPlayer", creditPlayer, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _parser.parseINT8(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_AddOn
//=================================================================

TournClient::publication::TournSubscr_AddOn::TournSubscr_AddOn()
{
	clear();
}

void TournClient::publication::TournSubscr_AddOn::clear()
{
	waiting = 0;
}

bool TournClient::publication::TournSubscr_AddOn::equals(const TournSubscr_AddOn& _o) const
{
	return waiting == _o.waiting;
}

const char *TournClient::publication::TournSubscr_AddOn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("waiting=");
	_buf.appendUint(waiting);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_AddOn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("waiting", waiting, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_AddOn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("waiting"))
		{
			waiting = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_AddOn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(waiting);
}

void TournClient::publication::TournSubscr_AddOn::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(waiting);
}

const char *TournClient::publication::TournSubscr_AddOn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("waiting", waiting);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_AddOn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("waiting", waiting);
}

/* static */ void TournClient::publication::TournSubscr_AddOn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE waiting; _jparser.validateByNameThrow("waiting", waiting);
	AtfValidator::validateInt(_descr, "waiting", waiting, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_AddOn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE waiting; _parser.parseBYTE(waiting);
	AtfValidator::validateInt(_descr, "waiting", waiting, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Stakes
//=================================================================

TournClient::publication::TournSubscr_Stakes::TournSubscr_Stakes()
{
	clear();
}

void TournClient::publication::TournSubscr_Stakes::clear()
{
	minStack = 0;
	maxStack = 0;
	avgStack = 0;
}

bool TournClient::publication::TournSubscr_Stakes::equals(const TournSubscr_Stakes& _o) const
{
	return minStack == _o.minStack &&
		maxStack == _o.maxStack &&
		avgStack == _o.avgStack;
}

const char *TournClient::publication::TournSubscr_Stakes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minStack=");
	_buf.appendUint(minStack);
	_buf.append(',');
	_buf.append("maxStack=");
	_buf.appendUint(maxStack);
	_buf.append(',');
	_buf.append("avgStack=");
	_buf.appendUint(avgStack);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Stakes::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minStack", minStack, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxStack", maxStack, _buf);
	Atf::XmlElement::encodeAsXmlElement("avgStack", avgStack, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Stakes::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minStack"))
		{
			minStack = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxStack"))
		{
			maxStack = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("avgStack"))
		{
			avgStack = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Stakes::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(minStack);
	_msg.composeUINT32(maxStack);
	_msg.composeUINT32(avgStack);
}

void TournClient::publication::TournSubscr_Stakes::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(minStack);
	_parser.parseUINT32(maxStack);
	_parser.parseUINT32(avgStack);
}

const char *TournClient::publication::TournSubscr_Stakes::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minStack", minStack);
	_jsonstr.compose("maxStack", maxStack);
	_jsonstr.compose("avgStack", avgStack);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Stakes::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minStack", minStack);
	_jparser.parseByNameThrow("maxStack", maxStack);
	_jparser.parseByNameThrow("avgStack", avgStack);
}

/* static */ void TournClient::publication::TournSubscr_Stakes::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 minStack; _jparser.validateByNameThrow("minStack", minStack);
	AtfValidator::validateInt(_descr, "minStack", minStack, _checker, __FILE__, __LINE__);
	UINT32 maxStack; _jparser.validateByNameThrow("maxStack", maxStack);
	AtfValidator::validateInt(_descr, "maxStack", maxStack, _checker, __FILE__, __LINE__);
	UINT32 avgStack; _jparser.validateByNameThrow("avgStack", avgStack);
	AtfValidator::validateInt(_descr, "avgStack", avgStack, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Stakes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 minStack; _parser.parseUINT32(minStack);
	AtfValidator::validateInt(_descr, "minStack", minStack, _checker, __FILE__, __LINE__);
	UINT32 maxStack; _parser.parseUINT32(maxStack);
	AtfValidator::validateInt(_descr, "maxStack", maxStack, _checker, __FILE__, __LINE__);
	UINT32 avgStack; _parser.parseUINT32(avgStack);
	AtfValidator::validateInt(_descr, "avgStack", avgStack, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PrizePool
//=================================================================

TournClient::publication::TournSubscr_PrizePool::TournSubscr_PrizePool()
{
	clear();
}

void TournClient::publication::TournSubscr_PrizePool::clear()
{
	numUsers = 0;
	prizePoolToPublish = 0;
	totalRebuysDone = 0;
	totalAddonsDone = 0;
	payouts = 0;
	flightIntermediatePayoutPrizePool = 0;
	flightIntermediatePayoutPerUser = 0;
}

bool TournClient::publication::TournSubscr_PrizePool::equals(const TournSubscr_PrizePool& _o) const
{
	return numUsers == _o.numUsers &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		totalRebuysDone == _o.totalRebuysDone &&
		totalAddonsDone == _o.totalAddonsDone &&
		payouts == _o.payouts &&
		flightIntermediatePayoutPrizePool == _o.flightIntermediatePayoutPrizePool &&
		flightIntermediatePayoutPerUser == _o.flightIntermediatePayoutPerUser;
}

const char *TournClient::publication::TournSubscr_PrizePool::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("totalRebuysDone=");
	_buf.appendUint(totalRebuysDone);
	_buf.append(',');
	_buf.append("totalAddonsDone=");
	_buf.appendUint(totalAddonsDone);
	_buf.append(',');
	_buf.append("payouts=");
	_buf.appendInt(payouts);
	_buf.append(',');
	_buf.append("flightIntermediatePayoutPrizePool=");
	_buf.appendInt(flightIntermediatePayoutPrizePool);
	_buf.append(',');
	_buf.append("flightIntermediatePayoutPerUser=");
	_buf.appendInt(flightIntermediatePayoutPerUser);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_PrizePool::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numUsers", numUsers, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolToPublish", prizePoolToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalRebuysDone", totalRebuysDone, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalAddonsDone", totalAddonsDone, _buf);
	Atf::XmlElement::encodeAsXmlElement("payouts", payouts, _buf);
	Atf::XmlElement::encodeAsXmlElement("flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool, _buf);
	Atf::XmlElement::encodeAsXmlElement("flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_PrizePool::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numUsers"))
		{
			numUsers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolToPublish"))
		{
			prizePoolToPublish = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalRebuysDone"))
		{
			totalRebuysDone = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalAddonsDone"))
		{
			totalAddonsDone = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("payouts"))
		{
			payouts = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flightIntermediatePayoutPrizePool"))
		{
			flightIntermediatePayoutPrizePool = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flightIntermediatePayoutPerUser"))
		{
			flightIntermediatePayoutPerUser = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_PrizePool::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(numUsers);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeUINT32(totalRebuysDone);
	_msg.composeUINT32(totalAddonsDone);
	_msg.composeINT32(payouts);
	_msg.composeINT32(flightIntermediatePayoutPrizePool);
	_msg.composeINT32(flightIntermediatePayoutPerUser);
}

void TournClient::publication::TournSubscr_PrizePool::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(numUsers);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseUINT32(totalRebuysDone);
	_parser.parseUINT32(totalAddonsDone);
	_parser.parseINT32(payouts);
	_parser.parseINT32(flightIntermediatePayoutPrizePool);
	_parser.parseINT32(flightIntermediatePayoutPerUser);
}

const char *TournClient::publication::TournSubscr_PrizePool::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numUsers", numUsers);
	_jsonstr.compose("prizePoolToPublish", prizePoolToPublish);
	_jsonstr.compose("totalRebuysDone", totalRebuysDone);
	_jsonstr.compose("totalAddonsDone", totalAddonsDone);
	_jsonstr.compose("payouts", payouts);
	_jsonstr.compose("flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool);
	_jsonstr.compose("flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_PrizePool::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numUsers", numUsers);
	_jparser.parseByNameThrow("prizePoolToPublish", prizePoolToPublish);
	_jparser.parseByNameThrow("totalRebuysDone", totalRebuysDone);
	_jparser.parseByNameThrow("totalAddonsDone", totalAddonsDone);
	_jparser.parseByNameThrow("payouts", payouts);
	_jparser.parseByNameThrow("flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool);
	_jparser.parseByNameThrow("flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser);
}

/* static */ void TournClient::publication::TournSubscr_PrizePool::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 numUsers; _jparser.validateByNameThrow("numUsers", numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _jparser.validateByNameThrow("prizePoolToPublish", prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	UINT32 totalRebuysDone; _jparser.validateByNameThrow("totalRebuysDone", totalRebuysDone);
	AtfValidator::validateInt(_descr, "totalRebuysDone", totalRebuysDone, _checker, __FILE__, __LINE__);
	UINT32 totalAddonsDone; _jparser.validateByNameThrow("totalAddonsDone", totalAddonsDone);
	AtfValidator::validateInt(_descr, "totalAddonsDone", totalAddonsDone, _checker, __FILE__, __LINE__);
	INT32 payouts; _jparser.validateByNameThrow("payouts", payouts);
	AtfValidator::validateInt(_descr, "payouts", payouts, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPrizePool; _jparser.validateByNameThrow("flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPerUser; _jparser.validateByNameThrow("flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_PrizePool::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 numUsers; _parser.parseUINT32(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	UINT32 totalRebuysDone; _parser.parseUINT32(totalRebuysDone);
	AtfValidator::validateInt(_descr, "totalRebuysDone", totalRebuysDone, _checker, __FILE__, __LINE__);
	UINT32 totalAddonsDone; _parser.parseUINT32(totalAddonsDone);
	AtfValidator::validateInt(_descr, "totalAddonsDone", totalAddonsDone, _checker, __FILE__, __LINE__);
	INT32 payouts; _parser.parseINT32(payouts);
	AtfValidator::validateInt(_descr, "payouts", payouts, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPrizePool; _parser.parseINT32(flightIntermediatePayoutPrizePool);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPerUser; _parser.parseINT32(flightIntermediatePayoutPerUser);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_NumRegistered
//=================================================================

TournClient::publication::TournSubscr_NumRegistered::TournSubscr_NumRegistered()
{
	clear();
}

void TournClient::publication::TournSubscr_NumRegistered::clear()
{
	userCount = 0;
	isBlitz = 0;
	numReg = 0;
	totalReentriesMade = 0;
}

bool TournClient::publication::TournSubscr_NumRegistered::equals(const TournSubscr_NumRegistered& _o) const
{
	return userCount == _o.userCount &&
		isBlitz == _o.isBlitz &&
		numReg == _o.numReg &&
		totalReentriesMade == _o.totalReentriesMade;
}

const char *TournClient::publication::TournSubscr_NumRegistered::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userCount=");
	_buf.appendUint(userCount);
	_buf.append(',');
	_buf.append("isBlitz=");
	_buf.appendUint(isBlitz);
	_buf.append(',');
	_buf.append("numReg=");
	_buf.appendUint(numReg);
	_buf.append(',');
	_buf.append("totalReentriesMade=");
	_buf.appendUint(totalReentriesMade);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_NumRegistered::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userCount", userCount, _buf);
	Atf::XmlElement::encodeAsXmlElement("isBlitz", isBlitz, _buf);
	Atf::XmlElement::encodeAsXmlElement("numReg", numReg, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalReentriesMade", totalReentriesMade, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_NumRegistered::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userCount"))
		{
			userCount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isBlitz"))
		{
			isBlitz = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numReg"))
		{
			numReg = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalReentriesMade"))
		{
			totalReentriesMade = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_NumRegistered::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userCount);
	_msg.composeUINT32(isBlitz);
	_msg.composeUINT32(numReg);
	_msg.composeUINT32(totalReentriesMade);
}

void TournClient::publication::TournSubscr_NumRegistered::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userCount);
	_parser.parseUINT32(isBlitz);
	_parser.parseUINT32(numReg);
	_parser.parseUINT32(totalReentriesMade);
}

const char *TournClient::publication::TournSubscr_NumRegistered::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userCount", userCount);
	_jsonstr.compose("isBlitz", isBlitz);
	_jsonstr.compose("numReg", numReg);
	_jsonstr.compose("totalReentriesMade", totalReentriesMade);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_NumRegistered::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userCount", userCount);
	_jparser.parseByNameThrow("isBlitz", isBlitz);
	_jparser.parseByNameThrow("numReg", numReg);
	_jparser.parseByNameThrow("totalReentriesMade", totalReentriesMade);
}

/* static */ void TournClient::publication::TournSubscr_NumRegistered::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userCount; _jparser.validateByNameThrow("userCount", userCount);
	AtfValidator::validateInt(_descr, "userCount", userCount, _checker, __FILE__, __LINE__);
	UINT32 isBlitz; _jparser.validateByNameThrow("isBlitz", isBlitz);
	AtfValidator::validateInt(_descr, "isBlitz", isBlitz, _checker, __FILE__, __LINE__);
	UINT32 numReg; _jparser.validateByNameThrow("numReg", numReg);
	AtfValidator::validateInt(_descr, "numReg", numReg, _checker, __FILE__, __LINE__);
	UINT32 totalReentriesMade; _jparser.validateByNameThrow("totalReentriesMade", totalReentriesMade);
	AtfValidator::validateInt(_descr, "totalReentriesMade", totalReentriesMade, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_NumRegistered::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 userCount; _parser.parseUINT32(userCount);
	AtfValidator::validateInt(_descr, "userCount", userCount, _checker, __FILE__, __LINE__);
	UINT32 isBlitz; _parser.parseUINT32(isBlitz);
	AtfValidator::validateInt(_descr, "isBlitz", isBlitz, _checker, __FILE__, __LINE__);
	UINT32 numReg; _parser.parseUINT32(numReg);
	AtfValidator::validateInt(_descr, "numReg", numReg, _checker, __FILE__, __LINE__);
	UINT32 totalReentriesMade; _parser.parseUINT32(totalReentriesMade);
	AtfValidator::validateInt(_descr, "totalReentriesMade", totalReentriesMade, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_AwardsPrelim
//=================================================================

TournClient::publication::TournSubscr_AwardsPrelim::TournSubscr_AwardsPrelim()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_AwardsPrelim::TournSubscr_AwardsPrelim(TournSubscr_AwardsPrelim&& _o)
	: prelimAwards(std::move(_o.prelimAwards))
	, numPaid(std::move(_o.numPaid))
	, numTickets(std::move(_o.numTickets))
	, awardRanges(std::move(_o.awardRanges))
{
}

TournClient::publication::TournSubscr_AwardsPrelim& TournClient::publication::TournSubscr_AwardsPrelim::operator=(TournSubscr_AwardsPrelim&& _o)
{
	if(this != &_o)
	{
		prelimAwards = std::move(_o.prelimAwards);
		numPaid = std::move(_o.numPaid);
		numTickets = std::move(_o.numTickets);
		awardRanges = std::move(_o.awardRanges);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_AwardsPrelim::clear()
{
	prelimAwards = 0;
	numPaid = 0;
	numTickets = 0;
	awardRanges.clear();
}

bool TournClient::publication::TournSubscr_AwardsPrelim::equals(const TournSubscr_AwardsPrelim& _o) const
{
	return prelimAwards == _o.prelimAwards &&
		numPaid == _o.numPaid &&
		numTickets == _o.numTickets &&
		awardRanges.equals(_o.awardRanges);
}

const char *TournClient::publication::TournSubscr_AwardsPrelim::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prelimAwards=");
	_buf.appendUint(prelimAwards);
	_buf.append(',');
	_buf.append("numPaid=");
	_buf.appendUint(numPaid);
	_buf.append(',');
	_buf.append("numTickets=");
	_buf.appendUint(numTickets);
	_buf.append(',');
	_buf.append("awardRanges=");
	awardRanges.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_AwardsPrelim::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("prelimAwards", prelimAwards, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPaid", numPaid, _buf);
	Atf::XmlElement::encodeAsXmlElement("numTickets", numTickets, _buf);
	awardRanges.toXmlString("awardRanges", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_AwardsPrelim::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prelimAwards"))
		{
			prelimAwards = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPaid"))
		{
			numPaid = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numTickets"))
		{
			numTickets = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("awardRanges"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< P_AwardRange, 4 > >::FromXmlString(_value, awardRanges)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_AwardsPrelim::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(prelimAwards);
	_msg.composeUINT32(numPaid);
	_msg.composeUINT32(numTickets);
	awardRanges.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournSubscr_AwardsPrelim::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(prelimAwards);
	_parser.parseUINT32(numPaid);
	_parser.parseUINT32(numTickets);
	awardRanges.parseMsg(_parser);
}

const char *TournClient::publication::TournSubscr_AwardsPrelim::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prelimAwards", prelimAwards);
	_jsonstr.compose("numPaid", numPaid);
	_jsonstr.compose("numTickets", numTickets);
	_jsonstr.compose("awardRanges", awardRanges);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_AwardsPrelim::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prelimAwards", prelimAwards);
	_jparser.parseByNameThrow("numPaid", numPaid);
	_jparser.parseByNameThrow("numTickets", numTickets);
	_jparser.parseByNameThrow("awardRanges", awardRanges);
}

/* static */ void TournClient::publication::TournSubscr_AwardsPrelim::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 prelimAwards; _jparser.validateByNameThrow("prelimAwards", prelimAwards);
	AtfValidator::validateInt(_descr, "prelimAwards", prelimAwards, _checker, __FILE__, __LINE__);
	UINT32 numPaid; _jparser.validateByNameThrow("numPaid", numPaid);
	AtfValidator::validateInt(_descr, "numPaid", numPaid, _checker, __FILE__, __LINE__);
	UINT32 numTickets; _jparser.validateByNameThrow("numTickets", numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_AwardRange > awardRanges; _jparser.validateByNameThrow("awardRanges", awardRanges);
	AtfValidator::validateInt(_descr, "awardRanges", awardRanges.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_AwardsPrelim::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 prelimAwards; _parser.parseUINT32(prelimAwards);
	AtfValidator::validateInt(_descr, "prelimAwards", prelimAwards, _checker, __FILE__, __LINE__);
	UINT32 numPaid; _parser.parseUINT32(numPaid);
	AtfValidator::validateInt(_descr, "numPaid", numPaid, _checker, __FILE__, __LINE__);
	UINT32 numTickets; _parser.parseUINT32(numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAwardRanges = Atf::LAtfVector< P_AwardRange, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("awardRanges"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "awardRanges", szAwardRanges, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_TableBanner
//=================================================================

TournClient::publication::TournSubscr_TableBanner::TournSubscr_TableBanner()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_TableBanner::TournSubscr_TableBanner(TournSubscr_TableBanner&& _o)
	: counter(std::move(_o.counter))
	, duration(std::move(_o.duration))
	, options(std::move(_o.options))
	, banner(std::move(_o.banner))
	, when(std::move(_o.when))
	, flags(std::move(_o.flags))
	, licenseMask(std::move(_o.licenseMask))
	, observerBanner(std::move(_o.observerBanner))
	, licenseMaskNew(std::move(_o.licenseMaskNew))
{
}

TournClient::publication::TournSubscr_TableBanner& TournClient::publication::TournSubscr_TableBanner::operator=(TournSubscr_TableBanner&& _o)
{
	if(this != &_o)
	{
		counter = std::move(_o.counter);
		duration = std::move(_o.duration);
		options = std::move(_o.options);
		banner = std::move(_o.banner);
		when = std::move(_o.when);
		flags = std::move(_o.flags);
		licenseMask = std::move(_o.licenseMask);
		observerBanner = std::move(_o.observerBanner);
		licenseMaskNew = std::move(_o.licenseMaskNew);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_TableBanner::clear()
{
	counter = 0;
	duration = 0;
	options = 0;
	banner.clear();
	when.setNull();
	flags = 0;
	licenseMask = 0;
	observerBanner.clear();
	licenseMaskNew.clear();
}

bool TournClient::publication::TournSubscr_TableBanner::equals(const TournSubscr_TableBanner& _o) const
{
	return counter == _o.counter &&
		duration == _o.duration &&
		options == _o.options &&
		banner.equals(_o.banner) &&
		when.equals(_o.when) &&
		flags == _o.flags &&
		licenseMask == _o.licenseMask &&
		observerBanner.equals(_o.observerBanner) &&
		licenseMaskNew.equals(_o.licenseMaskNew);
}

const char *TournClient::publication::TournSubscr_TableBanner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("counter=");
	_buf.appendUint(counter);
	_buf.append(',');
	_buf.append("duration=");
	_buf.appendUint(duration);
	_buf.append(',');
	_buf.append("options=");
	_buf.appendInt(options);
	_buf.append(',');
	_buf.append("banner=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, banner);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("licenseMask=");
	_buf.appendUint(licenseMask);
	_buf.append(',');
	_buf.append("observerBanner=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, observerBanner);
	_buf.append(',');
	_buf.append("licenseMaskNew=");
	licenseMaskNew.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_TableBanner::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("counter", counter, _buf);
	Atf::XmlElement::encodeAsXmlElement("duration", duration, _buf);
	Atf::XmlElement::encodeAsXmlElement("options", options, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "banner", banner);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseMask", licenseMask, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "observerBanner", observerBanner);
	licenseMaskNew.toXmlString("licenseMaskNew", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_TableBanner::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("counter"))
		{
			counter = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duration"))
		{
			duration = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("options"))
		{
			options = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("banner"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, banner);
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("licenseMask"))
		{
			licenseMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("observerBanner"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, observerBanner);
		}
		else if (_element.equals("licenseMaskNew"))
		{
			if(!Atf::AtfTempl< PLicenseMask >::FromXmlString(_value, licenseMaskNew)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_TableBanner::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(counter);
	_msg.composeUINT16(duration);
	_msg.composeINT32(options);
	banner.compose(_msg);
	_msg.composeSrvTime(when);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(licenseMask);
	observerBanner.compose(_msg);
	licenseMaskNew.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournSubscr_TableBanner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(counter);
	_parser.parseUINT16(duration);
	_parser.parseINT32(options);
	banner.parse(_parser);
	_parser.parseSrvTime(when);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(licenseMask);
	observerBanner.parse(_parser);
	licenseMaskNew.parseMsg(_parser);
}

const char *TournClient::publication::TournSubscr_TableBanner::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("counter", counter);
	_jsonstr.compose("duration", duration);
	_jsonstr.compose("options", options);
	_jsonstr.compose("banner", banner);
	_jsonstr.compose("when", when);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("licenseMask", licenseMask);
	_jsonstr.compose("observerBanner", observerBanner);
	_jsonstr.compose("licenseMaskNew", licenseMaskNew);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_TableBanner::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("counter", counter);
	_jparser.parseByNameThrow("duration", duration);
	_jparser.parseByNameThrow("options", options);
	_jparser.parseByNameThrow("banner", banner);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("licenseMask", licenseMask);
	_jparser.parseByNameThrow("observerBanner", observerBanner);
	_jparser.parseByNameThrow("licenseMaskNew", licenseMaskNew);
}

/* static */ void TournClient::publication::TournSubscr_TableBanner::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 counter; _jparser.validateByNameThrow("counter", counter);
	AtfValidator::validateInt(_descr, "counter", counter, _checker, __FILE__, __LINE__);
	UINT16 duration; _jparser.validateByNameThrow("duration", duration);
	AtfValidator::validateInt(_descr, "duration", duration, _checker, __FILE__, __LINE__);
	INT32 options; _jparser.validateByNameThrow("options", options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
	I18nPString banner; _jparser.validateByNameThrow("banner", banner);
	SrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 licenseMask; _jparser.validateByNameThrow("licenseMask", licenseMask);
	AtfValidator::validateInt(_descr, "licenseMask", licenseMask, _checker, __FILE__, __LINE__);
	I18nPString observerBanner; _jparser.validateByNameThrow("observerBanner", observerBanner);
	PLicenseMask licenseMaskNew; _jparser.validateByNameThrow("licenseMaskNew", licenseMaskNew);
}

/*static*/ void TournClient::publication::TournSubscr_TableBanner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 counter; _parser.parseUINT32(counter);
	AtfValidator::validateInt(_descr, "counter", counter, _checker, __FILE__, __LINE__);
	UINT16 duration; _parser.parseUINT16(duration);
	AtfValidator::validateInt(_descr, "duration", duration, _checker, __FILE__, __LINE__);
	INT32 options; _parser.parseINT32(options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
	I18nPString banner; banner.parse(_parser);
	SrvTime when; _parser.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 licenseMask; _parser.parseUINT32(licenseMask);
	AtfValidator::validateInt(_descr, "licenseMask", licenseMask, _checker, __FILE__, __LINE__);
	I18nPString observerBanner; observerBanner.parse(_parser);
	PString _descbuf;
	PLicenseMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("licenseMaskNew"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournSubscr_HappyHours
//=================================================================

TournClient::publication::TournSubscr_HappyHours::TournSubscr_HappyHours()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_HappyHours::TournSubscr_HappyHours(TournSubscr_HappyHours&& _o)
	: happyHourMultipliers(std::move(_o.happyHourMultipliers))
{
}

TournClient::publication::TournSubscr_HappyHours& TournClient::publication::TournSubscr_HappyHours::operator=(TournSubscr_HappyHours&& _o)
{
	if(this != &_o)
	{
		happyHourMultipliers = std::move(_o.happyHourMultipliers);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_HappyHours::clear()
{
	happyHourMultipliers.clear();
}

bool TournClient::publication::TournSubscr_HappyHours::equals(const TournSubscr_HappyHours& _o) const
{
	return happyHourMultipliers.equals(_o.happyHourMultipliers);
}

const char *TournClient::publication::TournSubscr_HappyHours::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("happyHourMultipliers=");
	happyHourMultipliers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_HappyHours::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	happyHourMultipliers.toXmlString("happyHourMultipliers", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_HappyHours::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("happyHourMultipliers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< FppFactor, 2 > >::FromXmlString(_value, happyHourMultipliers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_HappyHours::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	happyHourMultipliers.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournSubscr_HappyHours::parseMsg(CommMsgParser& _parser)
{
	happyHourMultipliers.parseMsg(_parser);
}

const char *TournClient::publication::TournSubscr_HappyHours::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("happyHourMultipliers", happyHourMultipliers);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_HappyHours::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("happyHourMultipliers", happyHourMultipliers);
}

/* static */ void TournClient::publication::TournSubscr_HappyHours::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< FppFactor > happyHourMultipliers; _jparser.validateByNameThrow("happyHourMultipliers", happyHourMultipliers);
	AtfValidator::validateInt(_descr, "happyHourMultipliers", happyHourMultipliers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_HappyHours::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szHappyHourMultipliers = Atf::LAtfVector< FppFactor, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("happyHourMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "happyHourMultipliers", szHappyHourMultipliers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_HandByHand
//=================================================================

TournClient::publication::TournSubscr_HandByHand::TournSubscr_HandByHand()
{
	clear();
}

void TournClient::publication::TournSubscr_HandByHand::clear()
{
	handByHand = false;
}

bool TournClient::publication::TournSubscr_HandByHand::equals(const TournSubscr_HandByHand& _o) const
{
	return handByHand == _o.handByHand;
}

const char *TournClient::publication::TournSubscr_HandByHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handByHand=");
	_buf.appendUint(handByHand);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_HandByHand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handByHand", handByHand, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_HandByHand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handByHand"))
		{
			handByHand = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_HandByHand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(handByHand);
}

void TournClient::publication::TournSubscr_HandByHand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(handByHand);
}

const char *TournClient::publication::TournSubscr_HandByHand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handByHand", handByHand);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_HandByHand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handByHand", handByHand);
}

/* static */ void TournClient::publication::TournSubscr_HandByHand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool handByHand; _jparser.validateByNameThrow("handByHand", handByHand);
	AtfValidator::validateInt(_descr, "handByHand", handByHand, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_HandByHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool handByHand; _parser.parseBOOL(handByHand);
	AtfValidator::validateInt(_descr, "handByHand", handByHand, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Bounty
//=================================================================

TournClient::publication::TournSubscr_Bounty::TournSubscr_Bounty()
{
	clear();
}

void TournClient::publication::TournSubscr_Bounty::clear()
{
	minBounty = 0;
	maxBounty = 0;
	averageBounty = 0;
}

bool TournClient::publication::TournSubscr_Bounty::equals(const TournSubscr_Bounty& _o) const
{
	return minBounty == _o.minBounty &&
		maxBounty == _o.maxBounty &&
		averageBounty == _o.averageBounty;
}

const char *TournClient::publication::TournSubscr_Bounty::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minBounty=");
	_buf.appendInt(minBounty);
	_buf.append(',');
	_buf.append("maxBounty=");
	_buf.appendInt(maxBounty);
	_buf.append(',');
	_buf.append("averageBounty=");
	_buf.appendInt(averageBounty);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Bounty::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minBounty", minBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBounty", maxBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("averageBounty", averageBounty, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Bounty::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minBounty"))
		{
			minBounty = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBounty"))
		{
			maxBounty = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("averageBounty"))
		{
			averageBounty = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Bounty::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(minBounty);
	_msg.composeINT32(maxBounty);
	_msg.composeINT32(averageBounty);
}

void TournClient::publication::TournSubscr_Bounty::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(minBounty);
	_parser.parseINT32(maxBounty);
	_parser.parseINT32(averageBounty);
}

const char *TournClient::publication::TournSubscr_Bounty::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minBounty", minBounty);
	_jsonstr.compose("maxBounty", maxBounty);
	_jsonstr.compose("averageBounty", averageBounty);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Bounty::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minBounty", minBounty);
	_jparser.parseByNameThrow("maxBounty", maxBounty);
	_jparser.parseByNameThrow("averageBounty", averageBounty);
}

/* static */ void TournClient::publication::TournSubscr_Bounty::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 minBounty; _jparser.validateByNameThrow("minBounty", minBounty);
	AtfValidator::validateInt(_descr, "minBounty", minBounty, _checker, __FILE__, __LINE__);
	INT32 maxBounty; _jparser.validateByNameThrow("maxBounty", maxBounty);
	AtfValidator::validateInt(_descr, "maxBounty", maxBounty, _checker, __FILE__, __LINE__);
	INT32 averageBounty; _jparser.validateByNameThrow("averageBounty", averageBounty);
	AtfValidator::validateInt(_descr, "averageBounty", averageBounty, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Bounty::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 minBounty; _parser.parseINT32(minBounty);
	AtfValidator::validateInt(_descr, "minBounty", minBounty, _checker, __FILE__, __LINE__);
	INT32 maxBounty; _parser.parseINT32(maxBounty);
	AtfValidator::validateInt(_descr, "maxBounty", maxBounty, _checker, __FILE__, __LINE__);
	INT32 averageBounty; _parser.parseINT32(averageBounty);
	AtfValidator::validateInt(_descr, "averageBounty", averageBounty, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Golden
//=================================================================

TournClient::publication::TournSubscr_Golden::TournSubscr_Golden()
{
	clear();
}

void TournClient::publication::TournSubscr_Golden::clear()
{
	goldenSnGBuyinAddon = 0;
	goldenSnGPrizepoolAddon = 0;
	goldenSnGPrizepoolMultiplier = 0;
	goldenSnGEligible = false;
	ppAddonForClient = 0;
	goldenSnGPrizepoolEffectiveMultiplier1 = 0;
	goldenSnGMilestoneAddon = 0;
	goldenSnGPrizepoolEffectiveMultiplier2 = 0;
	goldenSnGStartTime = 0;
}

bool TournClient::publication::TournSubscr_Golden::equals(const TournSubscr_Golden& _o) const
{
	return goldenSnGBuyinAddon == _o.goldenSnGBuyinAddon &&
		goldenSnGPrizepoolAddon == _o.goldenSnGPrizepoolAddon &&
		goldenSnGPrizepoolMultiplier == _o.goldenSnGPrizepoolMultiplier &&
		goldenSnGEligible == _o.goldenSnGEligible &&
		ppAddonForClient == _o.ppAddonForClient &&
		goldenSnGPrizepoolEffectiveMultiplier1 == _o.goldenSnGPrizepoolEffectiveMultiplier1 &&
		goldenSnGMilestoneAddon == _o.goldenSnGMilestoneAddon &&
		goldenSnGPrizepoolEffectiveMultiplier2 == _o.goldenSnGPrizepoolEffectiveMultiplier2 &&
		goldenSnGStartTime == _o.goldenSnGStartTime;
}

const char *TournClient::publication::TournSubscr_Golden::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("goldenSnGBuyinAddon=");
	_buf.appendInt(goldenSnGBuyinAddon);
	_buf.append(',');
	_buf.append("goldenSnGPrizepoolAddon=");
	_buf.appendInt(goldenSnGPrizepoolAddon);
	_buf.append(',');
	_buf.append("goldenSnGPrizepoolMultiplier=");
	_buf.appendInt(goldenSnGPrizepoolMultiplier);
	_buf.append(',');
	_buf.append("goldenSnGEligible=");
	_buf.appendUint(goldenSnGEligible);
	_buf.append(',');
	_buf.append("ppAddonForClient=");
	_buf.appendInt(ppAddonForClient);
	_buf.append(',');
	_buf.append("goldenSnGPrizepoolEffectiveMultiplier1=");
	_buf.appendInt(goldenSnGPrizepoolEffectiveMultiplier1);
	_buf.append(',');
	_buf.append("goldenSnGMilestoneAddon=");
	_buf.appendInt(goldenSnGMilestoneAddon);
	_buf.append(',');
	_buf.append("goldenSnGPrizepoolEffectiveMultiplier2=");
	_buf.appendInt64(goldenSnGPrizepoolEffectiveMultiplier2);
	_buf.append(',');
	_buf.append("goldenSnGStartTime=");
	_buf.appendInt(goldenSnGStartTime);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Golden::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("goldenSnGBuyinAddon", goldenSnGBuyinAddon, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGPrizepoolAddon", goldenSnGPrizepoolAddon, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGPrizepoolMultiplier", goldenSnGPrizepoolMultiplier, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGEligible", goldenSnGEligible, _buf);
	Atf::XmlElement::encodeAsXmlElement("ppAddonForClient", ppAddonForClient, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGPrizepoolEffectiveMultiplier1", goldenSnGPrizepoolEffectiveMultiplier1, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGMilestoneAddon", goldenSnGMilestoneAddon, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGPrizepoolEffectiveMultiplier2", goldenSnGPrizepoolEffectiveMultiplier2, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldenSnGStartTime", goldenSnGStartTime, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Golden::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("goldenSnGBuyinAddon"))
		{
			goldenSnGBuyinAddon = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldenSnGPrizepoolAddon"))
		{
			goldenSnGPrizepoolAddon = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldenSnGPrizepoolMultiplier"))
		{
			goldenSnGPrizepoolMultiplier = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldenSnGEligible"))
		{
			goldenSnGEligible = (*_value.ptr() == '1');
		}
		else if (_element.equals("ppAddonForClient"))
		{
			ppAddonForClient = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldenSnGPrizepoolEffectiveMultiplier1"))
		{
			goldenSnGPrizepoolEffectiveMultiplier1 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldenSnGMilestoneAddon"))
		{
			goldenSnGMilestoneAddon = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldenSnGPrizepoolEffectiveMultiplier2"))
		{
			goldenSnGPrizepoolEffectiveMultiplier2 = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldenSnGStartTime"))
		{
			goldenSnGStartTime = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Golden::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(goldenSnGBuyinAddon);
	_msg.composeINT32(goldenSnGPrizepoolAddon);
	_msg.composeINT16(goldenSnGPrizepoolMultiplier);
	_msg.composeBOOL(goldenSnGEligible);
	_msg.composeINT32(ppAddonForClient);
	_msg.composeINT32(goldenSnGPrizepoolEffectiveMultiplier1);
	_msg.composeINT32(goldenSnGMilestoneAddon);
	_msg.composeINT64(goldenSnGPrizepoolEffectiveMultiplier2);
	_msg.composeINT32(goldenSnGStartTime);
}

void TournClient::publication::TournSubscr_Golden::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(goldenSnGBuyinAddon);
	_parser.parseINT32(goldenSnGPrizepoolAddon);
	_parser.parseINT16(goldenSnGPrizepoolMultiplier);
	_parser.parseBOOL(goldenSnGEligible);
	_parser.parseINT32(ppAddonForClient);
	_parser.parseINT32(goldenSnGPrizepoolEffectiveMultiplier1);
	_parser.parseINT32(goldenSnGMilestoneAddon);
	_parser.parseINT64(goldenSnGPrizepoolEffectiveMultiplier2);
	_parser.parseINT32(goldenSnGStartTime);
}

const char *TournClient::publication::TournSubscr_Golden::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("goldenSnGBuyinAddon", goldenSnGBuyinAddon);
	_jsonstr.compose("goldenSnGPrizepoolAddon", goldenSnGPrizepoolAddon);
	_jsonstr.compose("goldenSnGPrizepoolMultiplier", goldenSnGPrizepoolMultiplier);
	_jsonstr.compose("goldenSnGEligible", goldenSnGEligible);
	_jsonstr.compose("ppAddonForClient", ppAddonForClient);
	_jsonstr.compose("goldenSnGPrizepoolEffectiveMultiplier1", goldenSnGPrizepoolEffectiveMultiplier1);
	_jsonstr.compose("goldenSnGMilestoneAddon", goldenSnGMilestoneAddon);
	_jsonstr.compose("goldenSnGPrizepoolEffectiveMultiplier2", goldenSnGPrizepoolEffectiveMultiplier2);
	_jsonstr.compose("goldenSnGStartTime", goldenSnGStartTime);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Golden::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("goldenSnGBuyinAddon", goldenSnGBuyinAddon);
	_jparser.parseByNameThrow("goldenSnGPrizepoolAddon", goldenSnGPrizepoolAddon);
	_jparser.parseByNameThrow("goldenSnGPrizepoolMultiplier", goldenSnGPrizepoolMultiplier);
	_jparser.parseByNameThrow("goldenSnGEligible", goldenSnGEligible);
	_jparser.parseByNameThrow("ppAddonForClient", ppAddonForClient);
	_jparser.parseByNameThrow("goldenSnGPrizepoolEffectiveMultiplier1", goldenSnGPrizepoolEffectiveMultiplier1);
	_jparser.parseByNameThrow("goldenSnGMilestoneAddon", goldenSnGMilestoneAddon);
	_jparser.parseByNameThrow("goldenSnGPrizepoolEffectiveMultiplier2", goldenSnGPrizepoolEffectiveMultiplier2);
	_jparser.parseByNameThrow("goldenSnGStartTime", goldenSnGStartTime);
}

/* static */ void TournClient::publication::TournSubscr_Golden::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 goldenSnGBuyinAddon; _jparser.validateByNameThrow("goldenSnGBuyinAddon", goldenSnGBuyinAddon);
	AtfValidator::validateInt(_descr, "goldenSnGBuyinAddon", goldenSnGBuyinAddon, _checker, __FILE__, __LINE__);
	INT32 goldenSnGPrizepoolAddon; _jparser.validateByNameThrow("goldenSnGPrizepoolAddon", goldenSnGPrizepoolAddon);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolAddon", goldenSnGPrizepoolAddon, _checker, __FILE__, __LINE__);
	INT16 goldenSnGPrizepoolMultiplier; _jparser.validateByNameThrow("goldenSnGPrizepoolMultiplier", goldenSnGPrizepoolMultiplier);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolMultiplier", goldenSnGPrizepoolMultiplier, _checker, __FILE__, __LINE__);
	bool goldenSnGEligible; _jparser.validateByNameThrow("goldenSnGEligible", goldenSnGEligible);
	AtfValidator::validateInt(_descr, "goldenSnGEligible", goldenSnGEligible, _checker, __FILE__, __LINE__);
	INT32 ppAddonForClient; _jparser.validateByNameThrow("ppAddonForClient", ppAddonForClient);
	AtfValidator::validateInt(_descr, "ppAddonForClient", ppAddonForClient, _checker, __FILE__, __LINE__);
	INT32 goldenSnGPrizepoolEffectiveMultiplier1; _jparser.validateByNameThrow("goldenSnGPrizepoolEffectiveMultiplier1", goldenSnGPrizepoolEffectiveMultiplier1);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolEffectiveMultiplier1", goldenSnGPrizepoolEffectiveMultiplier1, _checker, __FILE__, __LINE__);
	INT32 goldenSnGMilestoneAddon; _jparser.validateByNameThrow("goldenSnGMilestoneAddon", goldenSnGMilestoneAddon);
	AtfValidator::validateInt(_descr, "goldenSnGMilestoneAddon", goldenSnGMilestoneAddon, _checker, __FILE__, __LINE__);
	INT64 goldenSnGPrizepoolEffectiveMultiplier2; _jparser.validateByNameThrow("goldenSnGPrizepoolEffectiveMultiplier2", goldenSnGPrizepoolEffectiveMultiplier2);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolEffectiveMultiplier2", goldenSnGPrizepoolEffectiveMultiplier2, _checker, __FILE__, __LINE__);
	INT32 goldenSnGStartTime; _jparser.validateByNameThrow("goldenSnGStartTime", goldenSnGStartTime);
	AtfValidator::validateInt(_descr, "goldenSnGStartTime", goldenSnGStartTime, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Golden::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 goldenSnGBuyinAddon; _parser.parseINT32(goldenSnGBuyinAddon);
	AtfValidator::validateInt(_descr, "goldenSnGBuyinAddon", goldenSnGBuyinAddon, _checker, __FILE__, __LINE__);
	INT32 goldenSnGPrizepoolAddon; _parser.parseINT32(goldenSnGPrizepoolAddon);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolAddon", goldenSnGPrizepoolAddon, _checker, __FILE__, __LINE__);
	INT16 goldenSnGPrizepoolMultiplier; _parser.parseINT16(goldenSnGPrizepoolMultiplier);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolMultiplier", goldenSnGPrizepoolMultiplier, _checker, __FILE__, __LINE__);
	bool goldenSnGEligible; _parser.parseBOOL(goldenSnGEligible);
	AtfValidator::validateInt(_descr, "goldenSnGEligible", goldenSnGEligible, _checker, __FILE__, __LINE__);
	INT32 ppAddonForClient; _parser.parseINT32(ppAddonForClient);
	AtfValidator::validateInt(_descr, "ppAddonForClient", ppAddonForClient, _checker, __FILE__, __LINE__);
	INT32 goldenSnGPrizepoolEffectiveMultiplier1; _parser.parseINT32(goldenSnGPrizepoolEffectiveMultiplier1);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolEffectiveMultiplier1", goldenSnGPrizepoolEffectiveMultiplier1, _checker, __FILE__, __LINE__);
	INT32 goldenSnGMilestoneAddon; _parser.parseINT32(goldenSnGMilestoneAddon);
	AtfValidator::validateInt(_descr, "goldenSnGMilestoneAddon", goldenSnGMilestoneAddon, _checker, __FILE__, __LINE__);
	INT64 goldenSnGPrizepoolEffectiveMultiplier2; _parser.parseINT64(goldenSnGPrizepoolEffectiveMultiplier2);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolEffectiveMultiplier2", goldenSnGPrizepoolEffectiveMultiplier2, _checker, __FILE__, __LINE__);
	INT32 goldenSnGStartTime; _parser.parseINT32(goldenSnGStartTime);
	AtfValidator::validateInt(_descr, "goldenSnGStartTime", goldenSnGStartTime, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Autopublish
//=================================================================

TournClient::publication::TournSubscr_Autopublish::TournSubscr_Autopublish()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_Autopublish::TournSubscr_Autopublish(TournSubscr_Autopublish&& _o)
	: autoPublishBodies(std::move(_o.autoPublishBodies))
{
}

TournClient::publication::TournSubscr_Autopublish& TournClient::publication::TournSubscr_Autopublish::operator=(TournSubscr_Autopublish&& _o)
{
	if(this != &_o)
	{
		autoPublishBodies = std::move(_o.autoPublishBodies);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_Autopublish::clear()
{
	autoPublishBodies.clear();
}

bool TournClient::publication::TournSubscr_Autopublish::equals(const TournSubscr_Autopublish& _o) const
{
	return autoPublishBodies.equals(_o.autoPublishBodies);
}

const char *TournClient::publication::TournSubscr_Autopublish::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("autoPublishBodies=");
	autoPublishBodies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_Autopublish::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	autoPublishBodies.toXmlString("autoPublishBodies", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_Autopublish::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("autoPublishBodies"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< P_AutopublishBody, 4 > >::FromXmlString(_value, autoPublishBodies)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_Autopublish::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	autoPublishBodies.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournSubscr_Autopublish::parseMsg(CommMsgParser& _parser)
{
	autoPublishBodies.parseMsg(_parser);
}

const char *TournClient::publication::TournSubscr_Autopublish::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("autoPublishBodies", autoPublishBodies);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_Autopublish::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("autoPublishBodies", autoPublishBodies);
}

/* static */ void TournClient::publication::TournSubscr_Autopublish::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< P_AutopublishBody > autoPublishBodies; _jparser.validateByNameThrow("autoPublishBodies", autoPublishBodies);
	AtfValidator::validateInt(_descr, "autoPublishBodies", autoPublishBodies.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_Autopublish::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szAutoPublishBodies = Atf::LAtfVector< P_AutopublishBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("autoPublishBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "autoPublishBodies", szAutoPublishBodies, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PrizePoolUnit
//=================================================================

TournClient::publication::TournSubscr_PrizePoolUnit::TournSubscr_PrizePoolUnit()
{
	clear();
}

void TournClient::publication::TournSubscr_PrizePoolUnit::clear()
{
	prizePoolUnit = 0;
	prizePoolToPublish = 0;
	prizePoolMoneyToPublish = 0;
}

bool TournClient::publication::TournSubscr_PrizePoolUnit::equals(const TournSubscr_PrizePoolUnit& _o) const
{
	return prizePoolUnit == _o.prizePoolUnit &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish;
}

const char *TournClient::publication::TournSubscr_PrizePoolUnit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendInt(prizePoolMoneyToPublish);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_PrizePoolUnit::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("prizePoolUnit", prizePoolUnit, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolToPublish", prizePoolToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolMoneyToPublish", prizePoolMoneyToPublish, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_PrizePoolUnit::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prizePoolUnit"))
		{
			prizePoolUnit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolToPublish"))
		{
			prizePoolToPublish = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolMoneyToPublish"))
		{
			prizePoolMoneyToPublish = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_PrizePoolUnit::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(prizePoolUnit);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeINT32(prizePoolMoneyToPublish);
}

void TournClient::publication::TournSubscr_PrizePoolUnit::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(prizePoolUnit);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseINT32(prizePoolMoneyToPublish);
}

const char *TournClient::publication::TournSubscr_PrizePoolUnit::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prizePoolUnit", prizePoolUnit);
	_jsonstr.compose("prizePoolToPublish", prizePoolToPublish);
	_jsonstr.compose("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_PrizePoolUnit::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prizePoolUnit", prizePoolUnit);
	_jparser.parseByNameThrow("prizePoolToPublish", prizePoolToPublish);
	_jparser.parseByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
}

/* static */ void TournClient::publication::TournSubscr_PrizePoolUnit::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE prizePoolUnit; _jparser.validateByNameThrow("prizePoolUnit", prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _jparser.validateByNameThrow("prizePoolToPublish", prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	INT32 prizePoolMoneyToPublish; _jparser.validateByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_PrizePoolUnit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	INT32 prizePoolMoneyToPublish; _parser.parseINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_OptEarlyStart
//=================================================================

TournClient::publication::TournSubscr_OptEarlyStart::TournSubscr_OptEarlyStart()
{
	clear();
}

void TournClient::publication::TournSubscr_OptEarlyStart::clear()
{
	options = 0;
}

bool TournClient::publication::TournSubscr_OptEarlyStart::equals(const TournSubscr_OptEarlyStart& _o) const
{
	return options == _o.options;
}

const char *TournClient::publication::TournSubscr_OptEarlyStart::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("options=");
	_buf.appendUint(options);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_OptEarlyStart::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("options", options, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_OptEarlyStart::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("options"))
		{
			options = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_OptEarlyStart::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(options);
}

void TournClient::publication::TournSubscr_OptEarlyStart::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(options);
}

const char *TournClient::publication::TournSubscr_OptEarlyStart::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("options", options);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_OptEarlyStart::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("options", options);
}

/* static */ void TournClient::publication::TournSubscr_OptEarlyStart::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE options; _jparser.validateByNameThrow("options", options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_OptEarlyStart::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE options; _parser.parseBYTE(options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_NextMilestoneEvent
//=================================================================

TournClient::publication::TournSubscr_NextMilestoneEvent::TournSubscr_NextMilestoneEvent()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_NextMilestoneEvent::TournSubscr_NextMilestoneEvent(TournSubscr_NextMilestoneEvent&& _o)
	: indicator(std::move(_o.indicator))
	, firstMilestone(std::move(_o.firstMilestone))
	, nextMilestone(std::move(_o.nextMilestone))
	, tables(std::move(_o.tables))
	, prize(std::move(_o.prize))
{
}

TournClient::publication::TournSubscr_NextMilestoneEvent& TournClient::publication::TournSubscr_NextMilestoneEvent::operator=(TournSubscr_NextMilestoneEvent&& _o)
{
	if(this != &_o)
	{
		indicator = std::move(_o.indicator);
		firstMilestone = std::move(_o.firstMilestone);
		nextMilestone = std::move(_o.nextMilestone);
		tables = std::move(_o.tables);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_NextMilestoneEvent::clear()
{
	indicator = false;
	firstMilestone = 0;
	nextMilestone = 0;
	tables = 0;
	prize.clear();
}

bool TournClient::publication::TournSubscr_NextMilestoneEvent::equals(const TournSubscr_NextMilestoneEvent& _o) const
{
	return indicator == _o.indicator &&
		firstMilestone == _o.firstMilestone &&
		nextMilestone == _o.nextMilestone &&
		tables == _o.tables &&
		prize.equals(_o.prize);
}

const char *TournClient::publication::TournSubscr_NextMilestoneEvent::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("indicator=");
	_buf.appendUint(indicator);
	_buf.append(',');
	_buf.append("firstMilestone=");
	_buf.appendUint(firstMilestone);
	_buf.append(',');
	_buf.append("nextMilestone=");
	_buf.appendUint(nextMilestone);
	_buf.append(',');
	_buf.append("tables=");
	_buf.appendUint(tables);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_NextMilestoneEvent::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("indicator", indicator, _buf);
	Atf::XmlElement::encodeAsXmlElement("firstMilestone", firstMilestone, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextMilestone", nextMilestone, _buf);
	Atf::XmlElement::encodeAsXmlElement("tables", tables, _buf);
	prize.toXmlString("prize", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_NextMilestoneEvent::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("indicator"))
		{
			indicator = (*_value.ptr() == '1');
		}
		else if (_element.equals("firstMilestone"))
		{
			firstMilestone = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nextMilestone"))
		{
			nextMilestone = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tables"))
		{
			tables = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prize"))
		{
			if(!Atf::AtfTempl< TournMileStonePrize >::FromXmlString(_value, prize)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_NextMilestoneEvent::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(indicator);
	_msg.composeUINT32(firstMilestone);
	_msg.composeUINT32(nextMilestone);
	_msg.composeUINT32(tables);
	prize.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournSubscr_NextMilestoneEvent::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(indicator);
	_parser.parseUINT32(firstMilestone);
	_parser.parseUINT32(nextMilestone);
	_parser.parseUINT32(tables);
	prize.parseMsg(_parser);
}

const char *TournClient::publication::TournSubscr_NextMilestoneEvent::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("indicator", indicator);
	_jsonstr.compose("firstMilestone", firstMilestone);
	_jsonstr.compose("nextMilestone", nextMilestone);
	_jsonstr.compose("tables", tables);
	_jsonstr.compose("prize", prize);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_NextMilestoneEvent::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("indicator", indicator);
	_jparser.parseByNameThrow("firstMilestone", firstMilestone);
	_jparser.parseByNameThrow("nextMilestone", nextMilestone);
	_jparser.parseByNameThrow("tables", tables);
	_jparser.parseByNameThrow("prize", prize);
}

/* static */ void TournClient::publication::TournSubscr_NextMilestoneEvent::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool indicator; _jparser.validateByNameThrow("indicator", indicator);
	AtfValidator::validateInt(_descr, "indicator", indicator, _checker, __FILE__, __LINE__);
	UINT32 firstMilestone; _jparser.validateByNameThrow("firstMilestone", firstMilestone);
	AtfValidator::validateInt(_descr, "firstMilestone", firstMilestone, _checker, __FILE__, __LINE__);
	UINT32 nextMilestone; _jparser.validateByNameThrow("nextMilestone", nextMilestone);
	AtfValidator::validateInt(_descr, "nextMilestone", nextMilestone, _checker, __FILE__, __LINE__);
	UINT32 tables; _jparser.validateByNameThrow("tables", tables);
	AtfValidator::validateInt(_descr, "tables", tables, _checker, __FILE__, __LINE__);
	TournMileStonePrize prize; _jparser.validateByNameThrow("prize", prize);
}

/*static*/ void TournClient::publication::TournSubscr_NextMilestoneEvent::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool indicator; _parser.parseBOOL(indicator);
	AtfValidator::validateInt(_descr, "indicator", indicator, _checker, __FILE__, __LINE__);
	UINT32 firstMilestone; _parser.parseUINT32(firstMilestone);
	AtfValidator::validateInt(_descr, "firstMilestone", firstMilestone, _checker, __FILE__, __LINE__);
	UINT32 nextMilestone; _parser.parseUINT32(nextMilestone);
	AtfValidator::validateInt(_descr, "nextMilestone", nextMilestone, _checker, __FILE__, __LINE__);
	UINT32 tables; _parser.parseUINT32(tables);
	AtfValidator::validateInt(_descr, "tables", tables, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TournMileStonePrize::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournSubscr_SpinGoPrize_Vector
//=================================================================

TournClient::publication::TournSubscr_SpinGoPrize_Vector::TournSubscr_SpinGoPrize_Vector()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_SpinGoPrize_Vector::TournSubscr_SpinGoPrize_Vector(TournSubscr_SpinGoPrize_Vector&& _o)
	: prizes(std::move(_o.prizes))
{
}

TournClient::publication::TournSubscr_SpinGoPrize_Vector& TournClient::publication::TournSubscr_SpinGoPrize_Vector::operator=(TournSubscr_SpinGoPrize_Vector&& _o)
{
	if(this != &_o)
	{
		prizes = std::move(_o.prizes);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_SpinGoPrize_Vector::clear()
{
	prizes.clear();
}

bool TournClient::publication::TournSubscr_SpinGoPrize_Vector::equals(const TournSubscr_SpinGoPrize_Vector& _o) const
{
	return prizes.equals(_o.prizes);
}

const char *TournClient::publication::TournSubscr_SpinGoPrize_Vector::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_SpinGoPrize_Vector::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	prizes.toXmlString("prizes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_SpinGoPrize_Vector::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_SpinGoPrize_Vector::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	prizes.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournSubscr_SpinGoPrize_Vector::parseMsg(CommMsgParser& _parser)
{
	prizes.parseMsg(_parser);
}

const char *TournClient::publication::TournSubscr_SpinGoPrize_Vector::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prizes", prizes);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_SpinGoPrize_Vector::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prizes", prizes);
}

/* static */ void TournClient::publication::TournSubscr_SpinGoPrize_Vector::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT32 > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_SpinGoPrize_Vector::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoPrize
//=================================================================

TournClient::publication::TournSubscr_SpinGoPrize::TournSubscr_SpinGoPrize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_SpinGoPrize::TournSubscr_SpinGoPrize(TournSubscr_SpinGoPrize&& _o)
	: spinGoLevels(std::move(_o.spinGoLevels))
	, spinGoMarker(std::move(_o.spinGoMarker))
	, tickets(std::move(_o.tickets))
	, level(std::move(_o.level))
	, targetReferences(std::move(_o.targetReferences))
	, spinGoMaxCashout(std::move(_o.spinGoMaxCashout))
	, spinGoMaxLevels(std::move(_o.spinGoMaxLevels))
	, animationType(std::move(_o.animationType))
	, animationEndTime(std::move(_o.animationEndTime))
	, isJackpot(std::move(_o.isJackpot))
	, winner(std::move(_o.winner))
	, freeBetStake(std::move(_o.freeBetStake))
	, freeBetCurrency(std::move(_o.freeBetCurrency))
	, freeBetsCampaignId(std::move(_o.freeBetsCampaignId))
	, freeBetsCampaignId64(std::move(_o.freeBetsCampaignId64))
{
}

TournClient::publication::TournSubscr_SpinGoPrize& TournClient::publication::TournSubscr_SpinGoPrize::operator=(TournSubscr_SpinGoPrize&& _o)
{
	if(this != &_o)
	{
		spinGoLevels = std::move(_o.spinGoLevels);
		spinGoMarker = std::move(_o.spinGoMarker);
		tickets = std::move(_o.tickets);
		level = std::move(_o.level);
		targetReferences = std::move(_o.targetReferences);
		spinGoMaxCashout = std::move(_o.spinGoMaxCashout);
		spinGoMaxLevels = std::move(_o.spinGoMaxLevels);
		animationType = std::move(_o.animationType);
		animationEndTime = std::move(_o.animationEndTime);
		isJackpot = std::move(_o.isJackpot);
		winner = std::move(_o.winner);
		freeBetStake = std::move(_o.freeBetStake);
		freeBetCurrency = std::move(_o.freeBetCurrency);
		freeBetsCampaignId = std::move(_o.freeBetsCampaignId);
		freeBetsCampaignId64 = std::move(_o.freeBetsCampaignId64);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_SpinGoPrize::clear()
{
	spinGoLevels.clear();
	spinGoMarker = 0;
	tickets.clear();
	level = 0;
	targetReferences.clear();
	spinGoMaxCashout = 0;
	spinGoMaxLevels.clear();
	animationType = 0;
	animationEndTime.setNull();
	isJackpot = false;
	winner.clear();
	freeBetStake = 0;
	freeBetCurrency.clear();
	freeBetsCampaignId = 0;
	freeBetsCampaignId64 = 0;
}

bool TournClient::publication::TournSubscr_SpinGoPrize::equals(const TournSubscr_SpinGoPrize& _o) const
{
	return spinGoLevels.equals(_o.spinGoLevels) &&
		spinGoMarker == _o.spinGoMarker &&
		tickets.equals(_o.tickets) &&
		level == _o.level &&
		targetReferences.equals(_o.targetReferences) &&
		spinGoMaxCashout == _o.spinGoMaxCashout &&
		spinGoMaxLevels.equals(_o.spinGoMaxLevels) &&
		animationType == _o.animationType &&
		animationEndTime.equals(_o.animationEndTime) &&
		isJackpot == _o.isJackpot &&
		Atf::atfPStringEquals(winner, _o.winner) &&
		freeBetStake == _o.freeBetStake &&
		Atf::atfPStringEquals(freeBetCurrency, _o.freeBetCurrency) &&
		freeBetsCampaignId == _o.freeBetsCampaignId &&
		freeBetsCampaignId64 == _o.freeBetsCampaignId64;
}

const char *TournClient::publication::TournSubscr_SpinGoPrize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("spinGoLevels=");
	spinGoLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("spinGoMarker=");
	_buf.appendUint(spinGoMarker);
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("level=");
	_buf.appendUint(level);
	_buf.append(',');
	_buf.append("targetReferences=");
	targetReferences.toTraceString(_buf);
	_buf.append(',');
	_buf.append("spinGoMaxCashout=");
	_buf.appendInt(spinGoMaxCashout);
	_buf.append(',');
	_buf.append("spinGoMaxLevels=");
	spinGoMaxLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("animationType=");
	_buf.appendUint(animationType);
	_buf.append(',');
	_buf.append("animationEndTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, animationEndTime);
	_buf.append(',');
	_buf.append("isJackpot=");
	_buf.appendUint(isJackpot);
	_buf.append(',');
	_buf.append("winner=");
	_buf.append(winner);
	_buf.append(',');
	_buf.append("freeBetStake=");
	_buf.appendInt(freeBetStake);
	_buf.append(',');
	_buf.append("freeBetCurrency=");
	_buf.append(freeBetCurrency);
	_buf.append(',');
	_buf.append("freeBetsCampaignId=");
	_buf.appendUint(freeBetsCampaignId);
	_buf.append(',');
	_buf.append("freeBetsCampaignId64=");
	_buf.appendUint64(freeBetsCampaignId64);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_SpinGoPrize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	spinGoLevels.toXmlString("spinGoLevels", _buf);
	Atf::XmlElement::encodeAsXmlElement("spinGoMarker", spinGoMarker, _buf);
	tickets.toXmlString("tickets", _buf);
	Atf::XmlElement::encodeAsXmlElement("level", level, _buf);
	targetReferences.toXmlString("targetReferences", _buf);
	Atf::XmlElement::encodeAsXmlElement("spinGoMaxCashout", spinGoMaxCashout, _buf);
	spinGoMaxLevels.toXmlString("spinGoMaxLevels", _buf);
	Atf::XmlElement::encodeAsXmlElement("animationType", animationType, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "animationEndTime", animationEndTime);
	Atf::XmlElement::encodeAsXmlElement("isJackpot", isJackpot, _buf);
	Atf::XmlElement::encodeAsXmlElement("winner", winner, _buf);
	Atf::XmlElement::encodeAsXmlElement("freeBetStake", freeBetStake, _buf);
	Atf::XmlElement::encodeAsXmlElement("freeBetCurrency", freeBetCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("freeBetsCampaignId", freeBetsCampaignId, _buf);
	Atf::XmlElement::encodeAsXmlElement("freeBetsCampaignId64", freeBetsCampaignId64, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_SpinGoPrize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("spinGoLevels"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, spinGoLevels)) return false;
		}
		else if (_element.equals("spinGoMarker"))
		{
			spinGoMarker = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tickets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< I18nPString, 4 > >::FromXmlString(_value, tickets)) return false;
		}
		else if (_element.equals("level"))
		{
			level = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("targetReferences"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournSubscr_SpinGoPrize_TargetReference, 4 > >::FromXmlString(_value, targetReferences)) return false;
		}
		else if (_element.equals("spinGoMaxCashout"))
		{
			spinGoMaxCashout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinGoMaxLevels"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournSubscr_SpinGoPrize_Vector, 4 > >::FromXmlString(_value, spinGoMaxLevels)) return false;
		}
		else if (_element.equals("animationType"))
		{
			animationType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("animationEndTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, animationEndTime);
		}
		else if (_element.equals("isJackpot"))
		{
			isJackpot = (*_value.ptr() == '1');
		}
		else if (_element.equals("winner"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, winner)) return false;
		}
		else if (_element.equals("freeBetStake"))
		{
			freeBetStake = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("freeBetCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, freeBetCurrency)) return false;
		}
		else if (_element.equals("freeBetsCampaignId"))
		{
			freeBetsCampaignId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("freeBetsCampaignId64"))
		{
			freeBetsCampaignId64 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_SpinGoPrize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	spinGoLevels.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(spinGoMarker);
	tickets.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(level);
	targetReferences.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(spinGoMaxCashout);
	spinGoMaxLevels.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(animationType);
	_msg.composeSrvTime(animationEndTime);
	_msg.composeBOOL(isJackpot);
	_msg.composeString(winner);
	_msg.composeINT32(freeBetStake);
	_msg.composeString(freeBetCurrency);
	_msg.composeUINT32(freeBetsCampaignId);
	_msg.composeUINT64(freeBetsCampaignId64);
}

void TournClient::publication::TournSubscr_SpinGoPrize::parseMsg(CommMsgParser& _parser)
{
	spinGoLevels.parseMsg(_parser);
	_parser.parseUINT32(spinGoMarker);
	tickets.parseMsg(_parser);
	_parser.parseUINT32(level);
	targetReferences.parseMsg(_parser);
	_parser.parseINT32(spinGoMaxCashout);
	spinGoMaxLevels.parseMsg(_parser);
	_parser.parseUINT32(animationType);
	_parser.parseSrvTime(animationEndTime);
	_parser.parseBOOL(isJackpot);
	_parser.parseStringP(winner);
	_parser.parseINT32(freeBetStake);
	_parser.parseStringP(freeBetCurrency);
	_parser.parseUINT32(freeBetsCampaignId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(freeBetsCampaignId64);
}

const char *TournClient::publication::TournSubscr_SpinGoPrize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("spinGoLevels", spinGoLevels);
	_jsonstr.compose("spinGoMarker", spinGoMarker);
	_jsonstr.compose("tickets", tickets);
	_jsonstr.compose("level", level);
	_jsonstr.compose("targetReferences", targetReferences);
	_jsonstr.compose("spinGoMaxCashout", spinGoMaxCashout);
	_jsonstr.compose("spinGoMaxLevels", spinGoMaxLevels);
	_jsonstr.compose("animationType", animationType);
	_jsonstr.compose("animationEndTime", animationEndTime);
	_jsonstr.compose("isJackpot", isJackpot);
	_jsonstr.compose("winner", winner);
	_jsonstr.compose("freeBetStake", freeBetStake);
	_jsonstr.compose("freeBetCurrency", freeBetCurrency);
	_jsonstr.compose("freeBetsCampaignId", freeBetsCampaignId);
	_jsonstr.compose("freeBetsCampaignId64", freeBetsCampaignId64);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_SpinGoPrize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("spinGoLevels", spinGoLevels);
	_jparser.parseByNameThrow("spinGoMarker", spinGoMarker);
	_jparser.parseByNameThrow("tickets", tickets);
	_jparser.parseByNameThrow("level", level);
	_jparser.parseByNameThrow("targetReferences", targetReferences);
	_jparser.parseByNameThrow("spinGoMaxCashout", spinGoMaxCashout);
	_jparser.parseByNameThrow("spinGoMaxLevels", spinGoMaxLevels);
	_jparser.parseByNameThrow("animationType", animationType);
	_jparser.parseByNameThrow("animationEndTime", animationEndTime);
	_jparser.parseByNameThrow("isJackpot", isJackpot);
	_jparser.parseByNameThrow("winner", winner);
	_jparser.parseByNameThrow("freeBetStake", freeBetStake);
	_jparser.parseByNameThrow("freeBetCurrency", freeBetCurrency);
	_jparser.parseByNameThrow("freeBetsCampaignId", freeBetsCampaignId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("freeBetsCampaignId64", freeBetsCampaignId64);
}

/* static */ void TournClient::publication::TournSubscr_SpinGoPrize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT64 > spinGoLevels; _jparser.validateByNameThrow("spinGoLevels", spinGoLevels);
	AtfValidator::validateInt(_descr, "spinGoLevels", spinGoLevels.size(), _checker, __FILE__, __LINE__);
	UINT32 spinGoMarker; _jparser.validateByNameThrow("spinGoMarker", spinGoMarker);
	AtfValidator::validateInt(_descr, "spinGoMarker", spinGoMarker, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< I18nPString > tickets; _jparser.validateByNameThrow("tickets", tickets);
	AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
	UINT32 level; _jparser.validateByNameThrow("level", level);
	AtfValidator::validateInt(_descr, "level", level, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournSubscr_SpinGoPrize_TargetReference > targetReferences; _jparser.validateByNameThrow("targetReferences", targetReferences);
	AtfValidator::validateInt(_descr, "targetReferences", targetReferences.size(), _checker, __FILE__, __LINE__);
	INT32 spinGoMaxCashout; _jparser.validateByNameThrow("spinGoMaxCashout", spinGoMaxCashout);
	AtfValidator::validateInt(_descr, "spinGoMaxCashout", spinGoMaxCashout, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournSubscr_SpinGoPrize_Vector > spinGoMaxLevels; _jparser.validateByNameThrow("spinGoMaxLevels", spinGoMaxLevels);
	AtfValidator::validateInt(_descr, "spinGoMaxLevels", spinGoMaxLevels.size(), _checker, __FILE__, __LINE__);
	UINT32 animationType; _jparser.validateByNameThrow("animationType", animationType);
	AtfValidator::validateInt(_descr, "animationType", animationType, _checker, __FILE__, __LINE__);
	SrvTime animationEndTime; _jparser.validateByNameThrow("animationEndTime", animationEndTime);
	AtfValidator::validateSrvDateTime(_descr, "animationEndTime", animationEndTime, _checker, __FILE__, __LINE__);
	bool isJackpot; _jparser.validateByNameThrow("isJackpot", isJackpot);
	AtfValidator::validateInt(_descr, "isJackpot", isJackpot, _checker, __FILE__, __LINE__);
	PString winner; _jparser.validateByNameThrow("winner", winner);
	AtfValidator::validateInt(_descr, "winner", winner.length(), _checker, __FILE__, __LINE__);
	INT32 freeBetStake; _jparser.validateByNameThrow("freeBetStake", freeBetStake);
	AtfValidator::validateInt(_descr, "freeBetStake", freeBetStake, _checker, __FILE__, __LINE__);
	PString freeBetCurrency; _jparser.validateByNameThrow("freeBetCurrency", freeBetCurrency);
	AtfValidator::validateInt(_descr, "freeBetCurrency", freeBetCurrency.length(), _checker, __FILE__, __LINE__);
	UINT32 freeBetsCampaignId; _jparser.validateByNameThrow("freeBetsCampaignId", freeBetsCampaignId);
	AtfValidator::validateInt(_descr, "freeBetsCampaignId", freeBetsCampaignId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 freeBetsCampaignId64; _jparser.validateByNameThrow("freeBetsCampaignId64", freeBetsCampaignId64);
	AtfValidator::validateUint(_descr, "freeBetsCampaignId64", freeBetsCampaignId64, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_SpinGoPrize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	PString _descbuf;
	int szSpinGoLevels = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("spinGoLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinGoLevels", szSpinGoLevels, _checker, __FILE__, __LINE__);
	UINT32 spinGoMarker; _parser.parseUINT32(spinGoMarker);
	AtfValidator::validateInt(_descr, "spinGoMarker", spinGoMarker, _checker, __FILE__, __LINE__);
	int szTickets = Atf::LAtfVector< I18nPString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	UINT32 level; _parser.parseUINT32(level);
	AtfValidator::validateInt(_descr, "level", level, _checker, __FILE__, __LINE__);
	int szTargetReferences = Atf::LAtfVector< TournSubscr_SpinGoPrize_TargetReference, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("targetReferences"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "targetReferences", szTargetReferences, _checker, __FILE__, __LINE__);
	INT32 spinGoMaxCashout; _parser.parseINT32(spinGoMaxCashout);
	AtfValidator::validateInt(_descr, "spinGoMaxCashout", spinGoMaxCashout, _checker, __FILE__, __LINE__);
	int szSpinGoMaxLevels = Atf::LAtfVector< TournSubscr_SpinGoPrize_Vector, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("spinGoMaxLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinGoMaxLevels", szSpinGoMaxLevels, _checker, __FILE__, __LINE__);
	UINT32 animationType; _parser.parseUINT32(animationType);
	AtfValidator::validateInt(_descr, "animationType", animationType, _checker, __FILE__, __LINE__);
	SrvTime animationEndTime; _parser.parseSrvTime(animationEndTime);
	AtfValidator::validateSrvDateTime(_descr, "animationEndTime", animationEndTime, _checker, __FILE__, __LINE__);
	bool isJackpot; _parser.parseBOOL(isJackpot);
	AtfValidator::validateInt(_descr, "isJackpot", isJackpot, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "winner"); size_t szWinner = strlen(_dummy);
	AtfValidator::validateInt(_descr, "winner", szWinner, _checker, __FILE__, __LINE__);
	INT32 freeBetStake; _parser.parseINT32(freeBetStake);
	AtfValidator::validateInt(_descr, "freeBetStake", freeBetStake, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "freeBetCurrency"); size_t szFreeBetCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "freeBetCurrency", szFreeBetCurrency, _checker, __FILE__, __LINE__);
	UINT32 freeBetsCampaignId; _parser.parseUINT32(freeBetsCampaignId);
	AtfValidator::validateInt(_descr, "freeBetsCampaignId", freeBetsCampaignId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 freeBetsCampaignId64; _parser.parseUINT64(freeBetsCampaignId64);
	AtfValidator::validateUint(_descr, "freeBetsCampaignId64", freeBetsCampaignId64, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PerHand
//=================================================================

TournClient::publication::TournSubscr_PerHand::TournSubscr_PerHand()
{
	clear();
}

void TournClient::publication::TournSubscr_PerHand::clear()
{
	intervalInHands = false;
	currentHandInLevel = 0;
	totalHandsInLevel = 0;
	handsUntilAllInLevel = 0;
}

bool TournClient::publication::TournSubscr_PerHand::equals(const TournSubscr_PerHand& _o) const
{
	return intervalInHands == _o.intervalInHands &&
		currentHandInLevel == _o.currentHandInLevel &&
		totalHandsInLevel == _o.totalHandsInLevel &&
		handsUntilAllInLevel == _o.handsUntilAllInLevel;
}

const char *TournClient::publication::TournSubscr_PerHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("intervalInHands=");
	_buf.appendUint(intervalInHands);
	_buf.append(',');
	_buf.append("currentHandInLevel=");
	_buf.appendInt(currentHandInLevel);
	_buf.append(',');
	_buf.append("totalHandsInLevel=");
	_buf.appendInt(totalHandsInLevel);
	_buf.append(',');
	_buf.append("handsUntilAllInLevel=");
	_buf.appendInt(handsUntilAllInLevel);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_PerHand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("intervalInHands", intervalInHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentHandInLevel", currentHandInLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalHandsInLevel", totalHandsInLevel, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsUntilAllInLevel", handsUntilAllInLevel, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_PerHand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("intervalInHands"))
		{
			intervalInHands = (*_value.ptr() == '1');
		}
		else if (_element.equals("currentHandInLevel"))
		{
			currentHandInLevel = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalHandsInLevel"))
		{
			totalHandsInLevel = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsUntilAllInLevel"))
		{
			handsUntilAllInLevel = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_PerHand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(intervalInHands);
	_msg.composeINT32(currentHandInLevel);
	_msg.composeINT32(totalHandsInLevel);
	_msg.composeINT32(handsUntilAllInLevel);
}

void TournClient::publication::TournSubscr_PerHand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(intervalInHands);
	_parser.parseINT32(currentHandInLevel);
	_parser.parseINT32(totalHandsInLevel);
	_parser.parseINT32(handsUntilAllInLevel);
}

const char *TournClient::publication::TournSubscr_PerHand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("intervalInHands", intervalInHands);
	_jsonstr.compose("currentHandInLevel", currentHandInLevel);
	_jsonstr.compose("totalHandsInLevel", totalHandsInLevel);
	_jsonstr.compose("handsUntilAllInLevel", handsUntilAllInLevel);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_PerHand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("intervalInHands", intervalInHands);
	_jparser.parseByNameThrow("currentHandInLevel", currentHandInLevel);
	_jparser.parseByNameThrow("totalHandsInLevel", totalHandsInLevel);
	_jparser.parseByNameThrow("handsUntilAllInLevel", handsUntilAllInLevel);
}

/* static */ void TournClient::publication::TournSubscr_PerHand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool intervalInHands; _jparser.validateByNameThrow("intervalInHands", intervalInHands);
	AtfValidator::validateInt(_descr, "intervalInHands", intervalInHands, _checker, __FILE__, __LINE__);
	INT32 currentHandInLevel; _jparser.validateByNameThrow("currentHandInLevel", currentHandInLevel);
	AtfValidator::validateInt(_descr, "currentHandInLevel", currentHandInLevel, _checker, __FILE__, __LINE__);
	INT32 totalHandsInLevel; _jparser.validateByNameThrow("totalHandsInLevel", totalHandsInLevel);
	AtfValidator::validateInt(_descr, "totalHandsInLevel", totalHandsInLevel, _checker, __FILE__, __LINE__);
	INT32 handsUntilAllInLevel; _jparser.validateByNameThrow("handsUntilAllInLevel", handsUntilAllInLevel);
	AtfValidator::validateInt(_descr, "handsUntilAllInLevel", handsUntilAllInLevel, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_PerHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool intervalInHands; _parser.parseBOOL(intervalInHands);
	AtfValidator::validateInt(_descr, "intervalInHands", intervalInHands, _checker, __FILE__, __LINE__);
	INT32 currentHandInLevel; _parser.parseINT32(currentHandInLevel);
	AtfValidator::validateInt(_descr, "currentHandInLevel", currentHandInLevel, _checker, __FILE__, __LINE__);
	INT32 totalHandsInLevel; _parser.parseINT32(totalHandsInLevel);
	AtfValidator::validateInt(_descr, "totalHandsInLevel", totalHandsInLevel, _checker, __FILE__, __LINE__);
	INT32 handsUntilAllInLevel; _parser.parseINT32(handsUntilAllInLevel);
	AtfValidator::validateInt(_descr, "handsUntilAllInLevel", handsUntilAllInLevel, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_BeatTheClock
//=================================================================

TournClient::publication::TournSubscr_BeatTheClock::TournSubscr_BeatTheClock()
{
	clear();
}

void TournClient::publication::TournSubscr_BeatTheClock::clear()
{
	btcStartAnimation = 0;
}

bool TournClient::publication::TournSubscr_BeatTheClock::equals(const TournSubscr_BeatTheClock& _o) const
{
	return btcStartAnimation == _o.btcStartAnimation;
}

const char *TournClient::publication::TournSubscr_BeatTheClock::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("btcStartAnimation=");
	_buf.appendInt(btcStartAnimation);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_BeatTheClock::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("btcStartAnimation", btcStartAnimation, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_BeatTheClock::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("btcStartAnimation"))
		{
			btcStartAnimation = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_BeatTheClock::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(btcStartAnimation);
}

void TournClient::publication::TournSubscr_BeatTheClock::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(btcStartAnimation);
}

const char *TournClient::publication::TournSubscr_BeatTheClock::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("btcStartAnimation", btcStartAnimation);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_BeatTheClock::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("btcStartAnimation", btcStartAnimation);
}

/* static */ void TournClient::publication::TournSubscr_BeatTheClock::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 btcStartAnimation; _jparser.validateByNameThrow("btcStartAnimation", btcStartAnimation);
	AtfValidator::validateInt(_descr, "btcStartAnimation", btcStartAnimation, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_BeatTheClock::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT16 btcStartAnimation; _parser.parseINT16(btcStartAnimation);
	AtfValidator::validateInt(_descr, "btcStartAnimation", btcStartAnimation, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoSpinner
//=================================================================

TournClient::publication::TournSubscr_SpinGoSpinner::TournSubscr_SpinGoSpinner()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSubscr_SpinGoSpinner::TournSubscr_SpinGoSpinner(TournSubscr_SpinGoSpinner&& _o)
	: time(std::move(_o.time))
	, choice(std::move(_o.choice))
	, spinner1(std::move(_o.spinner1))
	, spinner2(std::move(_o.spinner2))
	, spinner3(std::move(_o.spinner3))
	, cashout(std::move(_o.cashout))
	, timeout(std::move(_o.timeout))
	, spinnerStr(std::move(_o.spinnerStr))
{
}

TournClient::publication::TournSubscr_SpinGoSpinner& TournClient::publication::TournSubscr_SpinGoSpinner::operator=(TournSubscr_SpinGoSpinner&& _o)
{
	if(this != &_o)
	{
		time = std::move(_o.time);
		choice = std::move(_o.choice);
		spinner1 = std::move(_o.spinner1);
		spinner2 = std::move(_o.spinner2);
		spinner3 = std::move(_o.spinner3);
		cashout = std::move(_o.cashout);
		timeout = std::move(_o.timeout);
		spinnerStr = std::move(_o.spinnerStr);
	}
	return *this;
}

#endif

void TournClient::publication::TournSubscr_SpinGoSpinner::clear()
{
	time.setNull();
	choice = 0;
	spinner1 = 0;
	spinner2 = 0;
	spinner3 = 0;
	cashout = 0;
	timeout = false;
	spinnerStr.clear();
}

bool TournClient::publication::TournSubscr_SpinGoSpinner::equals(const TournSubscr_SpinGoSpinner& _o) const
{
	return time.equals(_o.time) &&
		choice == _o.choice &&
		spinner1 == _o.spinner1 &&
		spinner2 == _o.spinner2 &&
		spinner3 == _o.spinner3 &&
		cashout == _o.cashout &&
		timeout == _o.timeout &&
		Atf::atfPStringEquals(spinnerStr, _o.spinnerStr);
}

const char *TournClient::publication::TournSubscr_SpinGoSpinner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("time=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("choice=");
	_buf.appendInt(choice);
	_buf.append(',');
	_buf.append("spinner1=");
	_buf.appendInt(spinner1);
	_buf.append(',');
	_buf.append("spinner2=");
	_buf.appendInt(spinner2);
	_buf.append(',');
	_buf.append("spinner3=");
	_buf.appendInt(spinner3);
	_buf.append(',');
	_buf.append("cashout=");
	_buf.appendInt(cashout);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendUint(timeout);
	_buf.append(',');
	_buf.append("spinnerStr=");
	_buf.append(spinnerStr);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSubscr_SpinGoSpinner::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "time", time);
	Atf::XmlElement::encodeAsXmlElement("choice", choice, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinner1", spinner1, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinner2", spinner2, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinner3", spinner3, _buf);
	Atf::XmlElement::encodeAsXmlElement("cashout", cashout, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeout", timeout, _buf);
	Atf::XmlElement::encodeAsXmlElement("spinnerStr", spinnerStr, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSubscr_SpinGoSpinner::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("time"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, time);
		}
		else if (_element.equals("choice"))
		{
			choice = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinner1"))
		{
			spinner1 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinner2"))
		{
			spinner2 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("spinner3"))
		{
			spinner3 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cashout"))
		{
			cashout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timeout"))
		{
			timeout = (*_value.ptr() == '1');
		}
		else if (_element.equals("spinnerStr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, spinnerStr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSubscr_SpinGoSpinner::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(time);
	_msg.composeINT32(choice);
	_msg.composeINT32(spinner1);
	_msg.composeINT32(spinner2);
	_msg.composeINT32(spinner3);
	_msg.composeINT32(cashout);
	_msg.composeBOOL(timeout);
	_msg.composeString(spinnerStr);
}

void TournClient::publication::TournSubscr_SpinGoSpinner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseINT32(choice);
	_parser.parseINT32(spinner1);
	_parser.parseINT32(spinner2);
	_parser.parseINT32(spinner3);
	_parser.parseINT32(cashout);
	_parser.parseBOOL(timeout);
	_parser.parseStringP(spinnerStr);
}

const char *TournClient::publication::TournSubscr_SpinGoSpinner::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("time", time);
	_jsonstr.compose("choice", choice);
	_jsonstr.compose("spinner1", spinner1);
	_jsonstr.compose("spinner2", spinner2);
	_jsonstr.compose("spinner3", spinner3);
	_jsonstr.compose("cashout", cashout);
	_jsonstr.compose("timeout", timeout);
	_jsonstr.compose("spinnerStr", spinnerStr);
	return _buf.c_str();
}

void TournClient::publication::TournSubscr_SpinGoSpinner::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("time", time);
	_jparser.parseByNameThrow("choice", choice);
	_jparser.parseByNameThrow("spinner1", spinner1);
	_jparser.parseByNameThrow("spinner2", spinner2);
	_jparser.parseByNameThrow("spinner3", spinner3);
	_jparser.parseByNameThrow("cashout", cashout);
	_jparser.parseByNameThrow("timeout", timeout);
	_jparser.parseByNameThrow("spinnerStr", spinnerStr);
}

/* static */ void TournClient::publication::TournSubscr_SpinGoSpinner::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime time; _jparser.validateByNameThrow("time", time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	INT32 choice; _jparser.validateByNameThrow("choice", choice);
	AtfValidator::validateInt(_descr, "choice", choice, _checker, __FILE__, __LINE__);
	INT32 spinner1; _jparser.validateByNameThrow("spinner1", spinner1);
	AtfValidator::validateInt(_descr, "spinner1", spinner1, _checker, __FILE__, __LINE__);
	INT32 spinner2; _jparser.validateByNameThrow("spinner2", spinner2);
	AtfValidator::validateInt(_descr, "spinner2", spinner2, _checker, __FILE__, __LINE__);
	INT32 spinner3; _jparser.validateByNameThrow("spinner3", spinner3);
	AtfValidator::validateInt(_descr, "spinner3", spinner3, _checker, __FILE__, __LINE__);
	INT32 cashout; _jparser.validateByNameThrow("cashout", cashout);
	AtfValidator::validateInt(_descr, "cashout", cashout, _checker, __FILE__, __LINE__);
	bool timeout; _jparser.validateByNameThrow("timeout", timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	PString spinnerStr; _jparser.validateByNameThrow("spinnerStr", spinnerStr);
	AtfValidator::validateInt(_descr, "spinnerStr", spinnerStr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSubscr_SpinGoSpinner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	INT32 choice; _parser.parseINT32(choice);
	AtfValidator::validateInt(_descr, "choice", choice, _checker, __FILE__, __LINE__);
	INT32 spinner1; _parser.parseINT32(spinner1);
	AtfValidator::validateInt(_descr, "spinner1", spinner1, _checker, __FILE__, __LINE__);
	INT32 spinner2; _parser.parseINT32(spinner2);
	AtfValidator::validateInt(_descr, "spinner2", spinner2, _checker, __FILE__, __LINE__);
	INT32 spinner3; _parser.parseINT32(spinner3);
	AtfValidator::validateInt(_descr, "spinner3", spinner3, _checker, __FILE__, __LINE__);
	INT32 cashout; _parser.parseINT32(cashout);
	AtfValidator::validateInt(_descr, "cashout", cashout, _checker, __FILE__, __LINE__);
	bool timeout; _parser.parseBOOL(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "spinnerStr"); size_t szSpinnerStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "spinnerStr", szSpinnerStr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSimpleAutoDealSubscr
//=================================================================

TournClient::publication::TournSimpleAutoDealSubscr::TournSimpleAutoDealSubscr()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSimpleAutoDealSubscr::TournSimpleAutoDealSubscr(TournSimpleAutoDealSubscr&& _o)
	: dealGeneration(std::move(_o.dealGeneration))
	, state(std::move(_o.state))
	, timeout(std::move(_o.timeout))
	, dealFailureState(std::move(_o.dealFailureState))
	, participantsInfo(std::move(_o.participantsInfo))
	, dealExclusion(std::move(_o.dealExclusion))
	, type0(std::move(_o.type0))
	, type1(std::move(_o.type1))
	, playerAgreedType(std::move(_o.playerAgreedType))
	, userAgreed0(std::move(_o.userAgreed0))
	, userAgreed1(std::move(_o.userAgreed1))
	, currency(std::move(_o.currency))
	, dealPayouts(std::move(_o.dealPayouts))
{
}

TournClient::publication::TournSimpleAutoDealSubscr& TournClient::publication::TournSimpleAutoDealSubscr::operator=(TournSimpleAutoDealSubscr&& _o)
{
	if(this != &_o)
	{
		dealGeneration = std::move(_o.dealGeneration);
		state = std::move(_o.state);
		timeout = std::move(_o.timeout);
		dealFailureState = std::move(_o.dealFailureState);
		participantsInfo = std::move(_o.participantsInfo);
		dealExclusion = std::move(_o.dealExclusion);
		type0 = std::move(_o.type0);
		type1 = std::move(_o.type1);
		playerAgreedType = std::move(_o.playerAgreedType);
		userAgreed0 = std::move(_o.userAgreed0);
		userAgreed1 = std::move(_o.userAgreed1);
		currency = std::move(_o.currency);
		dealPayouts = std::move(_o.dealPayouts);
	}
	return *this;
}

#endif

void TournClient::publication::TournSimpleAutoDealSubscr::clear()
{
	dealGeneration = 0;
	state = 0;
	timeout = 0;
	dealFailureState = 0;
	participantsInfo.clear();
	dealExclusion = 0;
	type0 = 0;
	type1 = 0;
	playerAgreedType = 0;
	userAgreed0 = 0;
	userAgreed1 = 0;
	currency.clear();
	dealPayouts.clear();
}

bool TournClient::publication::TournSimpleAutoDealSubscr::equals(const TournSimpleAutoDealSubscr& _o) const
{
	return dealGeneration == _o.dealGeneration &&
		state == _o.state &&
		timeout == _o.timeout &&
		dealFailureState == _o.dealFailureState &&
		participantsInfo.equals(_o.participantsInfo) &&
		dealExclusion == _o.dealExclusion &&
		type0 == _o.type0 &&
		type1 == _o.type1 &&
		playerAgreedType == _o.playerAgreedType &&
		userAgreed0 == _o.userAgreed0 &&
		userAgreed1 == _o.userAgreed1 &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		dealPayouts.equals(_o.dealPayouts);
}

const char *TournClient::publication::TournSimpleAutoDealSubscr::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("dealGeneration=");
	_buf.appendInt(dealGeneration);
	_buf.append(',');
	_buf.append("state=");
	_buf.appendInt(state);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendInt64(timeout);
	_buf.append(',');
	_buf.append("dealFailureState=");
	_buf.appendInt(dealFailureState);
	_buf.append(',');
	_buf.append("participantsInfo=");
	participantsInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dealExclusion=");
	_buf.appendInt(dealExclusion);
	_buf.append(',');
	_buf.append("type0=");
	_buf.appendInt(type0);
	_buf.append(',');
	_buf.append("type1=");
	_buf.appendInt(type1);
	_buf.append(',');
	_buf.append("playerAgreedType=");
	_buf.appendInt(playerAgreedType);
	_buf.append(',');
	_buf.append("userAgreed0=");
	_buf.appendInt(userAgreed0);
	_buf.append(',');
	_buf.append("userAgreed1=");
	_buf.appendInt(userAgreed1);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("dealPayouts=");
	dealPayouts.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSimpleAutoDealSubscr::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("dealGeneration", dealGeneration, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeout", timeout, _buf);
	Atf::XmlElement::encodeAsXmlElement("dealFailureState", dealFailureState, _buf);
	participantsInfo.toXmlString("participantsInfo", _buf);
	Atf::XmlElement::encodeAsXmlElement("dealExclusion", dealExclusion, _buf);
	Atf::XmlElement::encodeAsXmlElement("type0", type0, _buf);
	Atf::XmlElement::encodeAsXmlElement("type1", type1, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerAgreedType", playerAgreedType, _buf);
	Atf::XmlElement::encodeAsXmlElement("userAgreed0", userAgreed0, _buf);
	Atf::XmlElement::encodeAsXmlElement("userAgreed1", userAgreed1, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	dealPayouts.toXmlString("dealPayouts", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSimpleAutoDealSubscr::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("dealGeneration"))
		{
			dealGeneration = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("state"))
		{
			state = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timeout"))
		{
			timeout = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dealFailureState"))
		{
			dealFailureState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("participantsInfo"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< P_ParticipantsInfo, 4 > >::FromXmlString(_value, participantsInfo)) return false;
		}
		else if (_element.equals("dealExclusion"))
		{
			dealExclusion = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("type0"))
		{
			type0 = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("type1"))
		{
			type1 = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerAgreedType"))
		{
			playerAgreedType = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userAgreed0"))
		{
			userAgreed0 = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userAgreed1"))
		{
			userAgreed1 = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("dealPayouts"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< P_DealPayout, 4 > >::FromXmlString(_value, dealPayouts)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSimpleAutoDealSubscr::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(dealGeneration);
	_msg.composeINT8(state);
	_msg.composeINT64(timeout);
	_msg.composeINT32(dealFailureState);
	participantsInfo.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(dealExclusion);
	_msg.composeINT8(type0);
	_msg.composeINT8(type1);
	_msg.composeINT8(playerAgreedType);
	_msg.composeINT8(userAgreed0);
	_msg.composeINT8(userAgreed1);
	_msg.composeString(currency);
	dealPayouts.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournSimpleAutoDealSubscr::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(dealGeneration);
	_parser.parseINT8(state);
	_parser.parseINT64(timeout);
	_parser.parseINT32(dealFailureState);
	participantsInfo.parseMsg(_parser);
	_parser.parseINT32(dealExclusion);
	_parser.parseINT8(type0);
	_parser.parseINT8(type1);
	_parser.parseINT8(playerAgreedType);
	_parser.parseINT8(userAgreed0);
	_parser.parseINT8(userAgreed1);
	_parser.parseStringP(currency);
	dealPayouts.parseMsg(_parser);
}

const char *TournClient::publication::TournSimpleAutoDealSubscr::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dealGeneration", dealGeneration);
	_jsonstr.compose("state", state);
	_jsonstr.compose("timeout", timeout);
	_jsonstr.compose("dealFailureState", dealFailureState);
	_jsonstr.compose("participantsInfo", participantsInfo);
	_jsonstr.compose("dealExclusion", dealExclusion);
	_jsonstr.compose("type0", type0);
	_jsonstr.compose("type1", type1);
	_jsonstr.compose("playerAgreedType", playerAgreedType);
	_jsonstr.compose("userAgreed0", userAgreed0);
	_jsonstr.compose("userAgreed1", userAgreed1);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("dealPayouts", dealPayouts);
	return _buf.c_str();
}

void TournClient::publication::TournSimpleAutoDealSubscr::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dealGeneration", dealGeneration);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("timeout", timeout);
	_jparser.parseByNameThrow("dealFailureState", dealFailureState);
	_jparser.parseByNameThrow("participantsInfo", participantsInfo);
	_jparser.parseByNameThrow("dealExclusion", dealExclusion);
	_jparser.parseByNameThrow("type0", type0);
	_jparser.parseByNameThrow("type1", type1);
	_jparser.parseByNameThrow("playerAgreedType", playerAgreedType);
	_jparser.parseByNameThrow("userAgreed0", userAgreed0);
	_jparser.parseByNameThrow("userAgreed1", userAgreed1);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("dealPayouts", dealPayouts);
}

/* static */ void TournClient::publication::TournSimpleAutoDealSubscr::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 dealGeneration; _jparser.validateByNameThrow("dealGeneration", dealGeneration);
	AtfValidator::validateInt(_descr, "dealGeneration", dealGeneration, _checker, __FILE__, __LINE__);
	INT8 state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateInt(_descr, "state", state, _checker, __FILE__, __LINE__);
	INT64 timeout; _jparser.validateByNameThrow("timeout", timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	INT32 dealFailureState; _jparser.validateByNameThrow("dealFailureState", dealFailureState);
	AtfValidator::validateInt(_descr, "dealFailureState", dealFailureState, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_ParticipantsInfo > participantsInfo; _jparser.validateByNameThrow("participantsInfo", participantsInfo);
	AtfValidator::validateInt(_descr, "participantsInfo", participantsInfo.size(), _checker, __FILE__, __LINE__);
	INT32 dealExclusion; _jparser.validateByNameThrow("dealExclusion", dealExclusion);
	AtfValidator::validateInt(_descr, "dealExclusion", dealExclusion, _checker, __FILE__, __LINE__);
	INT8 type0; _jparser.validateByNameThrow("type0", type0);
	AtfValidator::validateInt(_descr, "type0", type0, _checker, __FILE__, __LINE__);
	INT8 type1; _jparser.validateByNameThrow("type1", type1);
	AtfValidator::validateInt(_descr, "type1", type1, _checker, __FILE__, __LINE__);
	INT8 playerAgreedType; _jparser.validateByNameThrow("playerAgreedType", playerAgreedType);
	AtfValidator::validateInt(_descr, "playerAgreedType", playerAgreedType, _checker, __FILE__, __LINE__);
	INT8 userAgreed0; _jparser.validateByNameThrow("userAgreed0", userAgreed0);
	AtfValidator::validateInt(_descr, "userAgreed0", userAgreed0, _checker, __FILE__, __LINE__);
	INT8 userAgreed1; _jparser.validateByNameThrow("userAgreed1", userAgreed1);
	AtfValidator::validateInt(_descr, "userAgreed1", userAgreed1, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< P_DealPayout > dealPayouts; _jparser.validateByNameThrow("dealPayouts", dealPayouts);
	AtfValidator::validateInt(_descr, "dealPayouts", dealPayouts.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSimpleAutoDealSubscr::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 dealGeneration; _parser.parseINT32(dealGeneration);
	AtfValidator::validateInt(_descr, "dealGeneration", dealGeneration, _checker, __FILE__, __LINE__);
	INT8 state; _parser.parseINT8(state);
	AtfValidator::validateInt(_descr, "state", state, _checker, __FILE__, __LINE__);
	INT64 timeout; _parser.parseINT64(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	INT32 dealFailureState; _parser.parseINT32(dealFailureState);
	AtfValidator::validateInt(_descr, "dealFailureState", dealFailureState, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szParticipantsInfo = Atf::LAtfVector< P_ParticipantsInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("participantsInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "participantsInfo", szParticipantsInfo, _checker, __FILE__, __LINE__);
	INT32 dealExclusion; _parser.parseINT32(dealExclusion);
	AtfValidator::validateInt(_descr, "dealExclusion", dealExclusion, _checker, __FILE__, __LINE__);
	INT8 type0; _parser.parseINT8(type0);
	AtfValidator::validateInt(_descr, "type0", type0, _checker, __FILE__, __LINE__);
	INT8 type1; _parser.parseINT8(type1);
	AtfValidator::validateInt(_descr, "type1", type1, _checker, __FILE__, __LINE__);
	INT8 playerAgreedType; _parser.parseINT8(playerAgreedType);
	AtfValidator::validateInt(_descr, "playerAgreedType", playerAgreedType, _checker, __FILE__, __LINE__);
	INT8 userAgreed0; _parser.parseINT8(userAgreed0);
	AtfValidator::validateInt(_descr, "userAgreed0", userAgreed0, _checker, __FILE__, __LINE__);
	INT8 userAgreed1; _parser.parseINT8(userAgreed1);
	AtfValidator::validateInt(_descr, "userAgreed1", userAgreed1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	int szDealPayouts = Atf::LAtfVector< P_DealPayout, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dealPayouts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "dealPayouts", szDealPayouts, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Stakes
//=================================================================

TournClient::publication::TournExtraSubscr_Stakes::TournExtraSubscr_Stakes()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournExtraSubscr_Stakes::TournExtraSubscr_Stakes(TournExtraSubscr_Stakes&& _o)
	: stakeLevels(std::move(_o.stakeLevels))
	, finalTableTimeBank(std::move(_o.finalTableTimeBank))
	, addRoundTimeBank(std::move(_o.addRoundTimeBank))
	, currRule(std::move(_o.currRule))
	, numRules(std::move(_o.numRules))
{
}

TournClient::publication::TournExtraSubscr_Stakes& TournClient::publication::TournExtraSubscr_Stakes::operator=(TournExtraSubscr_Stakes&& _o)
{
	if(this != &_o)
	{
		stakeLevels = std::move(_o.stakeLevels);
		finalTableTimeBank = std::move(_o.finalTableTimeBank);
		addRoundTimeBank = std::move(_o.addRoundTimeBank);
		currRule = std::move(_o.currRule);
		numRules = std::move(_o.numRules);
	}
	return *this;
}

#endif

void TournClient::publication::TournExtraSubscr_Stakes::clear()
{
	stakeLevels.clear();
	finalTableTimeBank = 0;
	addRoundTimeBank = 0;
	currRule = 0;
	numRules.clear();
}

bool TournClient::publication::TournExtraSubscr_Stakes::equals(const TournExtraSubscr_Stakes& _o) const
{
	return stakeLevels.equals(_o.stakeLevels) &&
		finalTableTimeBank == _o.finalTableTimeBank &&
		addRoundTimeBank == _o.addRoundTimeBank &&
		currRule == _o.currRule &&
		numRules.equals(_o.numRules);
}

const char *TournClient::publication::TournExtraSubscr_Stakes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("stakeLevels=");
	stakeLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("finalTableTimeBank=");
	_buf.appendUint(finalTableTimeBank);
	_buf.append(',');
	_buf.append("addRoundTimeBank=");
	_buf.appendUint(addRoundTimeBank);
	_buf.append(',');
	_buf.append("currRule=");
	_buf.appendInt(currRule);
	_buf.append(',');
	_buf.append("numRules=");
	numRules.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournExtraSubscr_Stakes::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	stakeLevels.toXmlString("stakeLevels", _buf);
	Atf::XmlElement::encodeAsXmlElement("finalTableTimeBank", finalTableTimeBank, _buf);
	Atf::XmlElement::encodeAsXmlElement("addRoundTimeBank", addRoundTimeBank, _buf);
	Atf::XmlElement::encodeAsXmlElement("currRule", currRule, _buf);
	numRules.toXmlString("numRules", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournExtraSubscr_Stakes::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("stakeLevels"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ExtraInfo_StakesLevel, 4 > >::FromXmlString(_value, stakeLevels)) return false;
		}
		else if (_element.equals("finalTableTimeBank"))
		{
			finalTableTimeBank = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addRoundTimeBank"))
		{
			addRoundTimeBank = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currRule"))
		{
			currRule = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numRules"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< BlindLevelIntervalRule, 4 > >::FromXmlString(_value, numRules)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournExtraSubscr_Stakes::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	stakeLevels.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(finalTableTimeBank);
	_msg.composeUINT32(addRoundTimeBank);
	_msg.composeINT32(currRule);
	numRules.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournExtraSubscr_Stakes::parseMsg(CommMsgParser& _parser)
{
	stakeLevels.parseMsg(_parser);
	_parser.parseUINT32(finalTableTimeBank);
	_parser.parseUINT32(addRoundTimeBank);
	_parser.parseINT32(currRule);
	numRules.parseMsg(_parser);
}

const char *TournClient::publication::TournExtraSubscr_Stakes::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("stakeLevels", stakeLevels);
	_jsonstr.compose("finalTableTimeBank", finalTableTimeBank);
	_jsonstr.compose("addRoundTimeBank", addRoundTimeBank);
	_jsonstr.compose("currRule", currRule);
	_jsonstr.compose("numRules", numRules);
	return _buf.c_str();
}

void TournClient::publication::TournExtraSubscr_Stakes::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stakeLevels", stakeLevels);
	_jparser.parseByNameThrow("finalTableTimeBank", finalTableTimeBank);
	_jparser.parseByNameThrow("addRoundTimeBank", addRoundTimeBank);
	_jparser.parseByNameThrow("currRule", currRule);
	_jparser.parseByNameThrow("numRules", numRules);
}

/* static */ void TournClient::publication::TournExtraSubscr_Stakes::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< ExtraInfo_StakesLevel > stakeLevels; _jparser.validateByNameThrow("stakeLevels", stakeLevels);
	AtfValidator::validateInt(_descr, "stakeLevels", stakeLevels.size(), _checker, __FILE__, __LINE__);
	UINT32 finalTableTimeBank; _jparser.validateByNameThrow("finalTableTimeBank", finalTableTimeBank);
	AtfValidator::validateInt(_descr, "finalTableTimeBank", finalTableTimeBank, _checker, __FILE__, __LINE__);
	UINT32 addRoundTimeBank; _jparser.validateByNameThrow("addRoundTimeBank", addRoundTimeBank);
	AtfValidator::validateInt(_descr, "addRoundTimeBank", addRoundTimeBank, _checker, __FILE__, __LINE__);
	INT32 currRule; _jparser.validateByNameThrow("currRule", currRule);
	AtfValidator::validateInt(_descr, "currRule", currRule, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< BlindLevelIntervalRule > numRules; _jparser.validateByNameThrow("numRules", numRules);
	AtfValidator::validateInt(_descr, "numRules", numRules.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournExtraSubscr_Stakes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szStakeLevels = Atf::LAtfVector< ExtraInfo_StakesLevel, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stakeLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "stakeLevels", szStakeLevels, _checker, __FILE__, __LINE__);
	UINT32 finalTableTimeBank; _parser.parseUINT32(finalTableTimeBank);
	AtfValidator::validateInt(_descr, "finalTableTimeBank", finalTableTimeBank, _checker, __FILE__, __LINE__);
	UINT32 addRoundTimeBank; _parser.parseUINT32(addRoundTimeBank);
	AtfValidator::validateInt(_descr, "addRoundTimeBank", addRoundTimeBank, _checker, __FILE__, __LINE__);
	INT32 currRule; _parser.parseINT32(currRule);
	AtfValidator::validateInt(_descr, "currRule", currRule, _checker, __FILE__, __LINE__);
	int szNumRules = Atf::LAtfVector< BlindLevelIntervalRule, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("numRules"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "numRules", szNumRules, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Breaks
//=================================================================

TournClient::publication::TournExtraSubscr_Breaks::TournExtraSubscr_Breaks()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournExtraSubscr_Breaks::TournExtraSubscr_Breaks(TournExtraSubscr_Breaks&& _o)
	: breaks(std::move(_o.breaks))
{
}

TournClient::publication::TournExtraSubscr_Breaks& TournClient::publication::TournExtraSubscr_Breaks::operator=(TournExtraSubscr_Breaks&& _o)
{
	if(this != &_o)
	{
		breaks = std::move(_o.breaks);
	}
	return *this;
}

#endif

void TournClient::publication::TournExtraSubscr_Breaks::clear()
{
	breaks.clear();
}

bool TournClient::publication::TournExtraSubscr_Breaks::equals(const TournExtraSubscr_Breaks& _o) const
{
	return breaks.equals(_o.breaks);
}

const char *TournClient::publication::TournExtraSubscr_Breaks::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("breaks=");
	breaks.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournExtraSubscr_Breaks::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	breaks.toXmlString("breaks", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournExtraSubscr_Breaks::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("breaks"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< P_BreakPub, 4 > >::FromXmlString(_value, breaks)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournExtraSubscr_Breaks::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	breaks.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournExtraSubscr_Breaks::parseMsg(CommMsgParser& _parser)
{
	breaks.parseMsg(_parser);
}

const char *TournClient::publication::TournExtraSubscr_Breaks::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("breaks", breaks);
	return _buf.c_str();
}

void TournClient::publication::TournExtraSubscr_Breaks::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("breaks", breaks);
}

/* static */ void TournClient::publication::TournExtraSubscr_Breaks::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< P_BreakPub > breaks; _jparser.validateByNameThrow("breaks", breaks);
	AtfValidator::validateInt(_descr, "breaks", breaks.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournExtraSubscr_Breaks::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szBreaks = Atf::LAtfVector< P_BreakPub, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("breaks"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "breaks", szBreaks, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_HandByHand
//=================================================================

TournClient::publication::TournExtraSubscr_HandByHand::TournExtraSubscr_HandByHand()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournExtraSubscr_HandByHand::TournExtraSubscr_HandByHand(TournExtraSubscr_HandByHand&& _o)
	: handByHandRanges(std::move(_o.handByHandRanges))
	, targetServer(std::move(_o.targetServer))
	, isSatelliteData(std::move(_o.isSatelliteData))
	, fallBackSatTargetSize(std::move(_o.fallBackSatTargetSize))
{
}

TournClient::publication::TournExtraSubscr_HandByHand& TournClient::publication::TournExtraSubscr_HandByHand::operator=(TournExtraSubscr_HandByHand&& _o)
{
	if(this != &_o)
	{
		handByHandRanges = std::move(_o.handByHandRanges);
		targetServer = std::move(_o.targetServer);
		isSatelliteData = std::move(_o.isSatelliteData);
		fallBackSatTargetSize = std::move(_o.fallBackSatTargetSize);
	}
	return *this;
}

#endif

void TournClient::publication::TournExtraSubscr_HandByHand::clear()
{
	handByHandRanges.clear();
	targetServer.clear();
	isSatelliteData = false;
	fallBackSatTargetSize = 0;
}

bool TournClient::publication::TournExtraSubscr_HandByHand::equals(const TournExtraSubscr_HandByHand& _o) const
{
	return handByHandRanges.equals(_o.handByHandRanges) &&
		Atf::atfPStringEquals(targetServer, _o.targetServer) &&
		isSatelliteData == _o.isSatelliteData &&
		fallBackSatTargetSize == _o.fallBackSatTargetSize;
}

const char *TournClient::publication::TournExtraSubscr_HandByHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handByHandRanges=");
	handByHandRanges.toTraceString(_buf);
	_buf.append(',');
	_buf.append("targetServer=");
	_buf.append(targetServer);
	_buf.append(',');
	_buf.append("isSatelliteData=");
	_buf.appendUint(isSatelliteData);
	_buf.append(',');
	_buf.append("fallBackSatTargetSize=");
	_buf.appendUint(fallBackSatTargetSize);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournExtraSubscr_HandByHand::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	handByHandRanges.toXmlString("handByHandRanges", _buf);
	Atf::XmlElement::encodeAsXmlElement("targetServer", targetServer, _buf);
	Atf::XmlElement::encodeAsXmlElement("isSatelliteData", isSatelliteData, _buf);
	Atf::XmlElement::encodeAsXmlElement("fallBackSatTargetSize", fallBackSatTargetSize, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournExtraSubscr_HandByHand::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handByHandRanges"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournCommon::P_Event, 4 > >::FromXmlString(_value, handByHandRanges)) return false;
		}
		else if (_element.equals("targetServer"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, targetServer)) return false;
		}
		else if (_element.equals("isSatelliteData"))
		{
			isSatelliteData = (*_value.ptr() == '1');
		}
		else if (_element.equals("fallBackSatTargetSize"))
		{
			fallBackSatTargetSize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournExtraSubscr_HandByHand::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	handByHandRanges.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(targetServer);
	_msg.composeBOOL(isSatelliteData);
	_msg.composeUINT32(fallBackSatTargetSize);
}

void TournClient::publication::TournExtraSubscr_HandByHand::parseMsg(CommMsgParser& _parser)
{
	handByHandRanges.parseMsg(_parser);
	_parser.parseStringP(targetServer);
	_parser.parseBOOL(isSatelliteData);
	_parser.parseUINT32(fallBackSatTargetSize);
}

const char *TournClient::publication::TournExtraSubscr_HandByHand::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handByHandRanges", handByHandRanges);
	_jsonstr.compose("targetServer", targetServer);
	_jsonstr.compose("isSatelliteData", isSatelliteData);
	_jsonstr.compose("fallBackSatTargetSize", fallBackSatTargetSize);
	return _buf.c_str();
}

void TournClient::publication::TournExtraSubscr_HandByHand::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handByHandRanges", handByHandRanges);
	_jparser.parseByNameThrow("targetServer", targetServer);
	_jparser.parseByNameThrow("isSatelliteData", isSatelliteData);
	_jparser.parseByNameThrow("fallBackSatTargetSize", fallBackSatTargetSize);
}

/* static */ void TournClient::publication::TournExtraSubscr_HandByHand::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< TournCommon::P_Event > handByHandRanges; _jparser.validateByNameThrow("handByHandRanges", handByHandRanges);
	AtfValidator::validateInt(_descr, "handByHandRanges", handByHandRanges.size(), _checker, __FILE__, __LINE__);
	PString targetServer; _jparser.validateByNameThrow("targetServer", targetServer);
	AtfValidator::validateInt(_descr, "targetServer", targetServer.length(), _checker, __FILE__, __LINE__);
	bool isSatelliteData; _jparser.validateByNameThrow("isSatelliteData", isSatelliteData);
	AtfValidator::validateInt(_descr, "isSatelliteData", isSatelliteData, _checker, __FILE__, __LINE__);
	UINT32 fallBackSatTargetSize; _jparser.validateByNameThrow("fallBackSatTargetSize", fallBackSatTargetSize);
	AtfValidator::validateInt(_descr, "fallBackSatTargetSize", fallBackSatTargetSize, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournExtraSubscr_HandByHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	PString _descbuf;
	int szHandByHandRanges = Atf::LAtfVector< TournCommon::P_Event, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("handByHandRanges"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "handByHandRanges", szHandByHandRanges, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "targetServer"); size_t szTargetServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetServer", szTargetServer, _checker, __FILE__, __LINE__);
	bool isSatelliteData; _parser.parseBOOL(isSatelliteData);
	AtfValidator::validateInt(_descr, "isSatelliteData", isSatelliteData, _checker, __FILE__, __LINE__);
	UINT32 fallBackSatTargetSize; _parser.parseUINT32(fallBackSatTargetSize);
	AtfValidator::validateInt(_descr, "fallBackSatTargetSize", fallBackSatTargetSize, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize
//=================================================================

TournClient::publication::TournExtraSubscr_Prize::TournExtraSubscr_Prize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournExtraSubscr_Prize::TournExtraSubscr_Prize(TournExtraSubscr_Prize&& _o)
	: zero(std::move(_o.zero))
	, creditPlayer(std::move(_o.creditPlayer))
	, returnBuyInValue(std::move(_o.returnBuyInValue))
	, rebuyPrice(std::move(_o.rebuyPrice))
	, rebuyRake(std::move(_o.rebuyRake))
	, addOnPrice(std::move(_o.addOnPrice))
	, addOnRake(std::move(_o.addOnRake))
	, prizes(std::move(_o.prizes))
{
}

TournClient::publication::TournExtraSubscr_Prize& TournClient::publication::TournExtraSubscr_Prize::operator=(TournExtraSubscr_Prize&& _o)
{
	if(this != &_o)
	{
		zero = std::move(_o.zero);
		creditPlayer = std::move(_o.creditPlayer);
		returnBuyInValue = std::move(_o.returnBuyInValue);
		rebuyPrice = std::move(_o.rebuyPrice);
		rebuyRake = std::move(_o.rebuyRake);
		addOnPrice = std::move(_o.addOnPrice);
		addOnRake = std::move(_o.addOnRake);
		prizes = std::move(_o.prizes);
	}
	return *this;
}

#endif

void TournClient::publication::TournExtraSubscr_Prize::clear()
{
	zero = 0;
	creditPlayer = 0;
	returnBuyInValue = 0;
	rebuyPrice = 0;
	rebuyRake = 0;
	addOnPrice = 0;
	addOnRake = 0;
	prizes.clear();
}

bool TournClient::publication::TournExtraSubscr_Prize::equals(const TournExtraSubscr_Prize& _o) const
{
	return zero == _o.zero &&
		creditPlayer == _o.creditPlayer &&
		returnBuyInValue == _o.returnBuyInValue &&
		rebuyPrice == _o.rebuyPrice &&
		rebuyRake == _o.rebuyRake &&
		addOnPrice == _o.addOnPrice &&
		addOnRake == _o.addOnRake &&
		prizes.equals(_o.prizes);
}

const char *TournClient::publication::TournExtraSubscr_Prize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("zero=");
	_buf.appendUint(zero);
	_buf.append(',');
	_buf.append("creditPlayer=");
	_buf.appendUint(creditPlayer);
	_buf.append(',');
	_buf.append("returnBuyInValue=");
	_buf.appendUint(returnBuyInValue);
	_buf.append(',');
	_buf.append("rebuyPrice=");
	_buf.appendInt(rebuyPrice);
	_buf.append(',');
	_buf.append("rebuyRake=");
	_buf.appendInt(rebuyRake);
	_buf.append(',');
	_buf.append("addOnPrice=");
	_buf.appendInt(addOnPrice);
	_buf.append(',');
	_buf.append("addOnRake=");
	_buf.appendInt(addOnRake);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournExtraSubscr_Prize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("zero", zero, _buf);
	Atf::XmlElement::encodeAsXmlElement("creditPlayer", creditPlayer, _buf);
	Atf::XmlElement::encodeAsXmlElement("returnBuyInValue", returnBuyInValue, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyPrice", rebuyPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyRake", rebuyRake, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnPrice", addOnPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOnRake", addOnRake, _buf);
	prizes.toXmlString("prizes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournExtraSubscr_Prize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("zero"))
		{
			zero = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("creditPlayer"))
		{
			creditPlayer = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("returnBuyInValue"))
		{
			returnBuyInValue = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rebuyPrice"))
		{
			rebuyPrice = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rebuyRake"))
		{
			rebuyRake = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addOnPrice"))
		{
			addOnPrice = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addOnRake"))
		{
			addOnRake = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournExtraSubscr_Prize_Prize, 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournExtraSubscr_Prize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(zero);
	_msg.composeUINT32(creditPlayer);
	_msg.composeUINT32(returnBuyInValue);
	_msg.composeINT32(rebuyPrice);
	_msg.composeINT32(rebuyRake);
	_msg.composeINT32(addOnPrice);
	_msg.composeINT32(addOnRake);
	prizes.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournExtraSubscr_Prize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(zero);
	_parser.parseUINT32(creditPlayer);
	_parser.parseUINT32(returnBuyInValue);
	_parser.parseINT32(rebuyPrice);
	_parser.parseINT32(rebuyRake);
	_parser.parseINT32(addOnPrice);
	_parser.parseINT32(addOnRake);
	prizes.parseMsg(_parser);
}

const char *TournClient::publication::TournExtraSubscr_Prize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("zero", zero);
	_jsonstr.compose("creditPlayer", creditPlayer);
	_jsonstr.compose("returnBuyInValue", returnBuyInValue);
	_jsonstr.compose("rebuyPrice", rebuyPrice);
	_jsonstr.compose("rebuyRake", rebuyRake);
	_jsonstr.compose("addOnPrice", addOnPrice);
	_jsonstr.compose("addOnRake", addOnRake);
	_jsonstr.compose("prizes", prizes);
	return _buf.c_str();
}

void TournClient::publication::TournExtraSubscr_Prize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("zero", zero);
	_jparser.parseByNameThrow("creditPlayer", creditPlayer);
	_jparser.parseByNameThrow("returnBuyInValue", returnBuyInValue);
	_jparser.parseByNameThrow("rebuyPrice", rebuyPrice);
	_jparser.parseByNameThrow("rebuyRake", rebuyRake);
	_jparser.parseByNameThrow("addOnPrice", addOnPrice);
	_jparser.parseByNameThrow("addOnRake", addOnRake);
	_jparser.parseByNameThrow("prizes", prizes);
}

/* static */ void TournClient::publication::TournExtraSubscr_Prize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 zero; _jparser.validateByNameThrow("zero", zero);
	AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
	UINT32 creditPlayer; _jparser.validateByNameThrow("creditPlayer", creditPlayer);
	AtfValidator::validateInt(_descr, "creditPlayer", creditPlayer, _checker, __FILE__, __LINE__);
	UINT32 returnBuyInValue; _jparser.validateByNameThrow("returnBuyInValue", returnBuyInValue);
	AtfValidator::validateInt(_descr, "returnBuyInValue", returnBuyInValue, _checker, __FILE__, __LINE__);
	INT32 rebuyPrice; _jparser.validateByNameThrow("rebuyPrice", rebuyPrice);
	AtfValidator::validateInt(_descr, "rebuyPrice", rebuyPrice, _checker, __FILE__, __LINE__);
	INT32 rebuyRake; _jparser.validateByNameThrow("rebuyRake", rebuyRake);
	AtfValidator::validateInt(_descr, "rebuyRake", rebuyRake, _checker, __FILE__, __LINE__);
	INT32 addOnPrice; _jparser.validateByNameThrow("addOnPrice", addOnPrice);
	AtfValidator::validateInt(_descr, "addOnPrice", addOnPrice, _checker, __FILE__, __LINE__);
	INT32 addOnRake; _jparser.validateByNameThrow("addOnRake", addOnRake);
	AtfValidator::validateInt(_descr, "addOnRake", addOnRake, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournExtraSubscr_Prize_Prize > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournExtraSubscr_Prize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 zero; _parser.parseUINT32(zero);
	AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
	UINT32 creditPlayer; _parser.parseUINT32(creditPlayer);
	AtfValidator::validateInt(_descr, "creditPlayer", creditPlayer, _checker, __FILE__, __LINE__);
	UINT32 returnBuyInValue; _parser.parseUINT32(returnBuyInValue);
	AtfValidator::validateInt(_descr, "returnBuyInValue", returnBuyInValue, _checker, __FILE__, __LINE__);
	INT32 rebuyPrice; _parser.parseINT32(rebuyPrice);
	AtfValidator::validateInt(_descr, "rebuyPrice", rebuyPrice, _checker, __FILE__, __LINE__);
	INT32 rebuyRake; _parser.parseINT32(rebuyRake);
	AtfValidator::validateInt(_descr, "rebuyRake", rebuyRake, _checker, __FILE__, __LINE__);
	INT32 addOnPrice; _parser.parseINT32(addOnPrice);
	AtfValidator::validateInt(_descr, "addOnPrice", addOnPrice, _checker, __FILE__, __LINE__);
	INT32 addOnRake; _parser.parseINT32(addOnRake);
	AtfValidator::validateInt(_descr, "addOnRake", addOnRake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< TournExtraSubscr_Prize_Prize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Rake_SitesPerCountry
//=================================================================

TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::TournExtraSubscr_Rake_SitesPerCountry()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::TournExtraSubscr_Rake_SitesPerCountry(TournExtraSubscr_Rake_SitesPerCountry&& _o)
	: country(std::move(_o.country))
	, sites(std::move(_o.sites))
{
}

TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry& TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::operator=(TournExtraSubscr_Rake_SitesPerCountry&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		sites = std::move(_o.sites);
	}
	return *this;
}

#endif

void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::clear()
{
	country.clear();
	sites = 0;
}

bool TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::equals(const TournExtraSubscr_Rake_SitesPerCountry& _o) const
{
	return Atf::atfPStringEquals(country, _o.country) &&
		sites == _o.sites;
}

const char *TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("sites=");
	_buf.appendUint(sites);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("sites", sites, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("sites"))
		{
			sites = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(country);
	_msg.composeUINT32(sites);
}

void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	_parser.parseUINT32(sites);
}

const char *TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("country", country);
	_jsonstr.compose("sites", sites);
	return _buf.c_str();
}

void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("sites", sites);
}

/* static */ void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	UINT32 sites; _jparser.validateByNameThrow("sites", sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	UINT32 sites; _parser.parseUINT32(sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Rake_SitesPerCountryEx
//=================================================================

TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::TournExtraSubscr_Rake_SitesPerCountryEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::TournExtraSubscr_Rake_SitesPerCountryEx(TournExtraSubscr_Rake_SitesPerCountryEx&& _o)
	: country(std::move(_o.country))
	, sitesEx(std::move(_o.sitesEx))
{
}

TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx& TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::operator=(TournExtraSubscr_Rake_SitesPerCountryEx&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		sitesEx = std::move(_o.sitesEx);
	}
	return *this;
}

#endif

void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::clear()
{
	country.clear();
	sitesEx.clear();
}

bool TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::equals(const TournExtraSubscr_Rake_SitesPerCountryEx& _o) const
{
	return Atf::atfPStringEquals(country, _o.country) &&
		sitesEx.equals(_o.sitesEx);
}

const char *TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("sitesEx=");
	sitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	sitesEx.toXmlString("sitesEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("sitesEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, sitesEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(country);
	sitesEx.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	sitesEx.parseMsg(_parser);
}

const char *TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("country", country);
	_jsonstr.compose("sitesEx", sitesEx);
	return _buf.c_str();
}

void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("sitesEx", sitesEx);
}

/* static */ void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	PSiteMask sitesEx; _jparser.validateByNameThrow("sitesEx", sitesEx);
}

/*static*/ void TournClient::publication::TournExtraSubscr_Rake_SitesPerCountryEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesEx"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournExtraSubscr_Rake
//=================================================================

TournClient::publication::TournExtraSubscr_Rake::TournExtraSubscr_Rake()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournExtraSubscr_Rake::TournExtraSubscr_Rake(TournExtraSubscr_Rake&& _o)
	: sites4AllCountries(std::move(_o.sites4AllCountries))
	, sitesNoRake(std::move(_o.sitesNoRake))
	, sitesPerCountry(std::move(_o.sitesPerCountry))
	, sites4AllCountriesEx(std::move(_o.sites4AllCountriesEx))
	, sitesNoRakeEx(std::move(_o.sitesNoRakeEx))
	, sitesPerCountryEx(std::move(_o.sitesPerCountryEx))
{
}

TournClient::publication::TournExtraSubscr_Rake& TournClient::publication::TournExtraSubscr_Rake::operator=(TournExtraSubscr_Rake&& _o)
{
	if(this != &_o)
	{
		sites4AllCountries = std::move(_o.sites4AllCountries);
		sitesNoRake = std::move(_o.sitesNoRake);
		sitesPerCountry = std::move(_o.sitesPerCountry);
		sites4AllCountriesEx = std::move(_o.sites4AllCountriesEx);
		sitesNoRakeEx = std::move(_o.sitesNoRakeEx);
		sitesPerCountryEx = std::move(_o.sitesPerCountryEx);
	}
	return *this;
}

#endif

void TournClient::publication::TournExtraSubscr_Rake::clear()
{
	sites4AllCountries = UINT_MAX;
	sitesNoRake = 0;
	sitesPerCountry.clear();
	sites4AllCountriesEx.clear();
	sitesNoRakeEx.clear();
	sitesPerCountryEx.clear();
}

bool TournClient::publication::TournExtraSubscr_Rake::equals(const TournExtraSubscr_Rake& _o) const
{
	return sites4AllCountries == _o.sites4AllCountries &&
		sitesNoRake == _o.sitesNoRake &&
		sitesPerCountry.equals(_o.sitesPerCountry) &&
		sites4AllCountriesEx.equals(_o.sites4AllCountriesEx) &&
		sitesNoRakeEx.equals(_o.sitesNoRakeEx) &&
		sitesPerCountryEx.equals(_o.sitesPerCountryEx);
}

const char *TournClient::publication::TournExtraSubscr_Rake::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sites4AllCountries=");
	_buf.appendUint(sites4AllCountries);
	_buf.append(',');
	_buf.append("sitesNoRake=");
	_buf.appendUint(sitesNoRake);
	_buf.append(',');
	_buf.append("sitesPerCountry=");
	sitesPerCountry.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sites4AllCountriesEx=");
	sites4AllCountriesEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sitesNoRakeEx=");
	sitesNoRakeEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sitesPerCountryEx=");
	sitesPerCountryEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournExtraSubscr_Rake::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("sites4AllCountries", sites4AllCountries, _buf);
	Atf::XmlElement::encodeAsXmlElement("sitesNoRake", sitesNoRake, _buf);
	sitesPerCountry.toXmlString("sitesPerCountry", _buf);
	sites4AllCountriesEx.toXmlString("sites4AllCountriesEx", _buf);
	sitesNoRakeEx.toXmlString("sitesNoRakeEx", _buf);
	sitesPerCountryEx.toXmlString("sitesPerCountryEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournExtraSubscr_Rake::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("sites4AllCountries"))
		{
			sites4AllCountries = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sitesNoRake"))
		{
			sitesNoRake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sitesPerCountry"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountry , 4 > >::FromXmlString(_value, sitesPerCountry)) return false;
		}
		else if (_element.equals("sites4AllCountriesEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, sites4AllCountriesEx)) return false;
		}
		else if (_element.equals("sitesNoRakeEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, sitesNoRakeEx)) return false;
		}
		else if (_element.equals("sitesPerCountryEx"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountryEx , 4 > >::FromXmlString(_value, sitesPerCountryEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournExtraSubscr_Rake::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sites4AllCountries);
	_msg.composeUINT32(sitesNoRake);
	sitesPerCountry.composeMsg(_msg, _ignoreJSON);
	sites4AllCountriesEx.composeMsg(_msg, _ignoreJSON);
	sitesNoRakeEx.composeMsg(_msg, _ignoreJSON);
	sitesPerCountryEx.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournExtraSubscr_Rake::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sites4AllCountries);
	_parser.parseUINT32(sitesNoRake);
	sitesPerCountry.parseMsg(_parser);
	sites4AllCountriesEx.parseMsg(_parser);
	sitesNoRakeEx.parseMsg(_parser);
	sitesPerCountryEx.parseMsg(_parser);
}

const char *TournClient::publication::TournExtraSubscr_Rake::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sites4AllCountries", sites4AllCountries);
	_jsonstr.compose("sitesNoRake", sitesNoRake);
	_jsonstr.compose("sitesPerCountry", sitesPerCountry);
	_jsonstr.compose("sites4AllCountriesEx", sites4AllCountriesEx);
	_jsonstr.compose("sitesNoRakeEx", sitesNoRakeEx);
	_jsonstr.compose("sitesPerCountryEx", sitesPerCountryEx);
	return _buf.c_str();
}

void TournClient::publication::TournExtraSubscr_Rake::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sites4AllCountries", sites4AllCountries);
	_jparser.parseByNameThrow("sitesNoRake", sitesNoRake);
	_jparser.parseByNameThrow("sitesPerCountry", sitesPerCountry);
	_jparser.parseByNameThrow("sites4AllCountriesEx", sites4AllCountriesEx);
	_jparser.parseByNameThrow("sitesNoRakeEx", sitesNoRakeEx);
	_jparser.parseByNameThrow("sitesPerCountryEx", sitesPerCountryEx);
}

/* static */ void TournClient::publication::TournExtraSubscr_Rake::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sites4AllCountries; _jparser.validateByNameThrow("sites4AllCountries", sites4AllCountries);
	AtfValidator::validateInt(_descr, "sites4AllCountries", sites4AllCountries, _checker, __FILE__, __LINE__);
	UINT32 sitesNoRake; _jparser.validateByNameThrow("sitesNoRake", sitesNoRake);
	AtfValidator::validateInt(_descr, "sitesNoRake", sitesNoRake, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournExtraSubscr_Rake_SitesPerCountry > sitesPerCountry; _jparser.validateByNameThrow("sitesPerCountry", sitesPerCountry);
	AtfValidator::validateInt(_descr, "sitesPerCountry", sitesPerCountry.size(), _checker, __FILE__, __LINE__);
	PSiteMask sites4AllCountriesEx; _jparser.validateByNameThrow("sites4AllCountriesEx", sites4AllCountriesEx);
	PSiteMask sitesNoRakeEx; _jparser.validateByNameThrow("sitesNoRakeEx", sitesNoRakeEx);
	Atf::AtfVectorBase< TournExtraSubscr_Rake_SitesPerCountryEx > sitesPerCountryEx; _jparser.validateByNameThrow("sitesPerCountryEx", sitesPerCountryEx);
	AtfValidator::validateInt(_descr, "sitesPerCountryEx", sitesPerCountryEx.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournExtraSubscr_Rake::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 sites4AllCountries; _parser.parseUINT32(sites4AllCountries);
	AtfValidator::validateInt(_descr, "sites4AllCountries", sites4AllCountries, _checker, __FILE__, __LINE__);
	UINT32 sitesNoRake; _parser.parseUINT32(sitesNoRake);
	AtfValidator::validateInt(_descr, "sitesNoRake", sitesNoRake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSitesPerCountry = Atf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountry , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesPerCountry"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sitesPerCountry", szSitesPerCountry, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sites4AllCountriesEx"), _fieldsWithUnparsedContent);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesNoRakeEx"), _fieldsWithUnparsedContent);
	int szSitesPerCountryEx = Atf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountryEx , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesPerCountryEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sitesPerCountryEx", szSitesPerCountryEx, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournStormSubscr
//=================================================================

TournClient::publication::TournStormSubscr::TournStormSubscr()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournStormSubscr::TournStormSubscr(TournStormSubscr&& _o)
	: stormAllowed(std::move(_o.stormAllowed))
	, powerCostBase(std::move(_o.powerCostBase))
	, powers(std::move(_o.powers))
{
}

TournClient::publication::TournStormSubscr& TournClient::publication::TournStormSubscr::operator=(TournStormSubscr&& _o)
{
	if(this != &_o)
	{
		stormAllowed = std::move(_o.stormAllowed);
		powerCostBase = std::move(_o.powerCostBase);
		powers = std::move(_o.powers);
	}
	return *this;
}

#endif

void TournClient::publication::TournStormSubscr::clear()
{
	stormAllowed = false;
	powerCostBase.clear();
	powers.clear();
}

bool TournClient::publication::TournStormSubscr::equals(const TournStormSubscr& _o) const
{
	return stormAllowed == _o.stormAllowed &&
		powerCostBase.equals(_o.powerCostBase) &&
		powers.equals(_o.powers);
}

const char *TournClient::publication::TournStormSubscr::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("stormAllowed=");
	_buf.appendUint(stormAllowed);
	_buf.append(',');
	_buf.append("powerCostBase=");
	powerCostBase.toTraceString(_buf);
	_buf.append(',');
	_buf.append("powers=");
	powers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournStormSubscr::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("stormAllowed", stormAllowed, _buf);
	powerCostBase.toXmlString("powerCostBase", _buf);
	powers.toXmlString("powers", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournStormSubscr::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("stormAllowed"))
		{
			stormAllowed = (*_value.ptr() == '1');
		}
		else if (_element.equals("powerCostBase"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, powerCostBase)) return false;
		}
		else if (_element.equals("powers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Atf::CopyableMsgBody, 4 > >::FromXmlString(_value, powers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournStormSubscr::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(stormAllowed);
	powerCostBase.composeMsg(_msg, _ignoreJSON);
	powers.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournStormSubscr::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(stormAllowed);
	powerCostBase.parseMsg(_parser);
	powers.parseMsg(_parser);
}

const char *TournClient::publication::TournStormSubscr::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("stormAllowed", stormAllowed);
	_jsonstr.compose("powerCostBase", powerCostBase);
	_jsonstr.compose("powers", powers);
	return _buf.c_str();
}

void TournClient::publication::TournStormSubscr::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stormAllowed", stormAllowed);
	_jparser.parseByNameThrow("powerCostBase", powerCostBase);
	_jparser.parseByNameThrow("powers", powers);
}

/* static */ void TournClient::publication::TournStormSubscr::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool stormAllowed; _jparser.validateByNameThrow("stormAllowed", stormAllowed);
	AtfValidator::validateInt(_descr, "stormAllowed", stormAllowed, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > powerCostBase; _jparser.validateByNameThrow("powerCostBase", powerCostBase);
	AtfValidator::validateInt(_descr, "powerCostBase", powerCostBase.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Atf::CopyableMsgBody > powers; _jparser.validateByNameThrow("powers", powers);
	AtfValidator::validateInt(_descr, "powers", powers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournStormSubscr::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool stormAllowed; _parser.parseBOOL(stormAllowed);
	AtfValidator::validateInt(_descr, "stormAllowed", stormAllowed, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPowerCostBase = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powerCostBase"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powerCostBase", szPowerCostBase, _checker, __FILE__, __LINE__);
	int szPowers = Atf::LAtfVector< Atf::CopyableMsgBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powers", szPowers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSatelliteDataSubscr_Stat
//=================================================================

TournClient::publication::TournSatelliteDataSubscr_Stat::TournSatelliteDataSubscr_Stat()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournSatelliteDataSubscr_Stat::TournSatelliteDataSubscr_Stat(TournSatelliteDataSubscr_Stat&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, minPlayers(std::move(_o.minPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournSites(std::move(_o.tournSites))
	, maxPerTable(std::move(_o.maxPerTable))
	, admissionId(std::move(_o.admissionId))
	, chatLang(std::move(_o.chatLang))
	, currency(std::move(_o.currency))
	, knockout(std::move(_o.knockout))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, scalePM(std::move(_o.scalePM))
	, admissionPrice(std::move(_o.admissionPrice))
	, speedDisplay(std::move(_o.speedDisplay))
	, name(std::move(_o.name))
	, tournFlags2(std::move(_o.tournFlags2))
	, activeFlags(std::move(_o.activeFlags))
	, tournSitesEx(std::move(_o.tournSitesEx))
{
}

TournClient::publication::TournSatelliteDataSubscr_Stat& TournClient::publication::TournSatelliteDataSubscr_Stat::operator=(TournSatelliteDataSubscr_Stat&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPlayMoney = std::move(_o.isPlayMoney);
		minPlayers = std::move(_o.minPlayers);
		tournFlags = std::move(_o.tournFlags);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournSites = std::move(_o.tournSites);
		maxPerTable = std::move(_o.maxPerTable);
		admissionId = std::move(_o.admissionId);
		chatLang = std::move(_o.chatLang);
		currency = std::move(_o.currency);
		knockout = std::move(_o.knockout);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		scalePM = std::move(_o.scalePM);
		admissionPrice = std::move(_o.admissionPrice);
		speedDisplay = std::move(_o.speedDisplay);
		name = std::move(_o.name);
		tournFlags2 = std::move(_o.tournFlags2);
		activeFlags = std::move(_o.activeFlags);
		tournSitesEx = std::move(_o.tournSitesEx);
	}
	return *this;
}

#endif

void TournClient::publication::TournSatelliteDataSubscr_Stat::clear()
{
	tournamentId = 0;
	server.clear();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPlayMoney = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournSites = 0;
	maxPerTable = 0;
	admissionId.clear();
	chatLang = 0;
	currency.clear();
	knockout = 0;
	tournFlagsServInt = 0;
	scalePM = 0;
	admissionPrice = 0;
	speedDisplay = 0;
	name.clear();
	tournFlags2 = 0;
	activeFlags = 0;
	tournSitesEx.clear();
}

bool TournClient::publication::TournSatelliteDataSubscr_Stat::equals(const TournSatelliteDataSubscr_Stat& _o) const
{
	return tournamentId == _o.tournamentId &&
		Atf::atfPStringEquals(server, _o.server) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPlayMoney == _o.isPlayMoney &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournSites == _o.tournSites &&
		maxPerTable == _o.maxPerTable &&
		Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		chatLang == _o.chatLang &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		knockout == _o.knockout &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		scalePM == _o.scalePM &&
		admissionPrice == _o.admissionPrice &&
		speedDisplay == _o.speedDisplay &&
		name.equals(_o.name) &&
		tournFlags2 == _o.tournFlags2 &&
		activeFlags == _o.activeFlags &&
		tournSitesEx.equals(_o.tournSitesEx);
}

const char *TournClient::publication::TournSatelliteDataSubscr_Stat::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("name=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("tournSitesEx=");
	tournSitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSatelliteDataSubscr_Stat::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournamentId", tournamentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppBuyIn", fppBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRestricted", isRestricted, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournSites", tournSites, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("chatLang", chatLang, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlagsServInt", tournFlagsServInt, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionPrice", admissionPrice, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "name", name);
	Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("activeFlags", activeFlags, _buf);
	tournSitesEx.toXmlString("tournSitesEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSatelliteDataSubscr_Stat::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournamentId"))
		{
			tournamentId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppBuyIn"))
		{
			fppBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isRestricted"))
		{
			isRestricted = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minPlayers"))
		{
			minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournSites"))
		{
			tournSites = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxPerTable"))
		{
			maxPerTable = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admissionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
		}
		else if (_element.equals("chatLang"))
		{
			chatLang = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("knockout"))
		{
			knockout = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlagsServInt"))
		{
			tournFlagsServInt = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admissionPrice"))
		{
			admissionPrice = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedDisplay"))
		{
			speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, name);
		}
		else if (_element.equals("tournFlags2"))
		{
			tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("activeFlags"))
		{
			activeFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournSitesEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, tournSitesEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSatelliteDataSubscr_Stat::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeString(server);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeBYTE(isRestricted);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeUINT32(minPlayers);
	_msg.composeUINT32(tournFlags);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(tournSites);
	_msg.composeUINT32(maxPerTable);
	_msg.composeString(admissionId);
	_msg.composeUINT16(chatLang);
	_msg.composeString(currency);
	_msg.composeUINT32(knockout);
	_msg.composeUINT32(tournFlagsServInt);
	_msg.composeUINT32(scalePM);
	_msg.composeINT64(admissionPrice);
	_msg.composeBYTE(speedDisplay);
	name.compose(_msg);
	_msg.composeUINT64(tournFlags2);
	_msg.composeUINT32(activeFlags);
	tournSitesEx.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournSatelliteDataSubscr_Stat::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseStringP(server);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseBYTE(isRestricted);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseUINT32(minPlayers);
	_parser.parseUINT32(tournFlags);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(tournSites);
	_parser.parseUINT32(maxPerTable);
	_parser.parseStringP(admissionId);
	_parser.parseUINT16(chatLang);
	_parser.parseStringP(currency);
	_parser.parseUINT32(knockout);
	_parser.parseUINT32(tournFlagsServInt);
	_parser.parseUINT32(scalePM);
	_parser.parseINT64(admissionPrice);
	_parser.parseBYTE(speedDisplay);
	name.parse(_parser);
	_parser.parseUINT64(tournFlags2);
	_parser.parseUINT32(activeFlags);
	tournSitesEx.parseMsg(_parser);
}

const char *TournClient::publication::TournSatelliteDataSubscr_Stat::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournamentId", tournamentId);
	_jsonstr.compose("server", server);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("fppBuyIn", fppBuyIn);
	_jsonstr.compose("isRestricted", isRestricted);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("minPlayers", minPlayers);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("game", game);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("tournSites", tournSites);
	_jsonstr.compose("maxPerTable", maxPerTable);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("chatLang", chatLang);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("knockout", knockout);
	_jsonstr.compose("tournFlagsServInt", tournFlagsServInt);
	_jsonstr.compose("scalePM", scalePM);
	_jsonstr.compose("admissionPrice", admissionPrice);
	_jsonstr.compose("speedDisplay", speedDisplay);
	_jsonstr.compose("name", name);
	_jsonstr.compose("tournFlags2", tournFlags2);
	_jsonstr.compose("activeFlags", activeFlags);
	_jsonstr.compose("tournSitesEx", tournSitesEx);
	return _buf.c_str();
}

void TournClient::publication::TournSatelliteDataSubscr_Stat::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournamentId", tournamentId);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("fppBuyIn", fppBuyIn);
	_jparser.parseByNameThrow("isRestricted", isRestricted);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("minPlayers", minPlayers);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("tournSites", tournSites);
	_jparser.parseByNameThrow("maxPerTable", maxPerTable);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("chatLang", chatLang);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("knockout", knockout);
	_jparser.parseByNameThrow("tournFlagsServInt", tournFlagsServInt);
	_jparser.parseByNameThrow("scalePM", scalePM);
	_jparser.parseByNameThrow("admissionPrice", admissionPrice);
	_jparser.parseByNameThrow("speedDisplay", speedDisplay);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("tournFlags2", tournFlags2);
	_jparser.parseByNameThrow("activeFlags", activeFlags);
	_jparser.parseByNameThrow("tournSitesEx", tournSitesEx);
}

/* static */ void TournClient::publication::TournSatelliteDataSubscr_Stat::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournamentId; _jparser.validateByNameThrow("tournamentId", tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _jparser.validateByNameThrow("fppBuyIn", fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _jparser.validateByNameThrow("isRestricted", isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _jparser.validateByNameThrow("tournSites", tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	UINT16 chatLang; _jparser.validateByNameThrow("chatLang", chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _jparser.validateByNameThrow("tournFlagsServInt", tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _jparser.validateByNameThrow("admissionPrice", admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _jparser.validateByNameThrow("speedDisplay", speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	I18nPString name; _jparser.validateByNameThrow("name", name);
	UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _jparser.validateByNameThrow("activeFlags", activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	PSiteMask tournSitesEx; _jparser.validateByNameThrow("tournSitesEx", tournSitesEx);
}

/*static*/ void TournClient::publication::TournSatelliteDataSubscr_Stat::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	I18nPString name; name.parse(_parser);
	UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSitesEx"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournSatelliteDataSubscr_Dyna
//=================================================================

TournClient::publication::TournSatelliteDataSubscr_Dyna::TournSatelliteDataSubscr_Dyna()
{
	clear();
}

void TournClient::publication::TournSatelliteDataSubscr_Dyna::clear()
{
	whenStart.setNull();
	status = 0;
	entrants = 0;
	publProp = 0;
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	mixTournSatellite = 0;
}

bool TournClient::publication::TournSatelliteDataSubscr_Dyna::equals(const TournSatelliteDataSubscr_Dyna& _o) const
{
	return whenStart.equals(_o.whenStart) &&
		status == _o.status &&
		entrants == _o.entrants &&
		publProp == _o.publProp &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *TournClient::publication::TournSatelliteDataSubscr_Dyna::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("whenStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendUint(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendInt(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournSatelliteDataSubscr_Dyna::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("entrants", entrants, _buf);
	Atf::XmlElement::encodeAsXmlElement("publProp", publProp, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolToPublish", prizePoolToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolUnit", prizePoolUnit, _buf);
	Atf::XmlElement::encodeAsXmlElement("mixTournSatellite", mixTournSatellite, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournSatelliteDataSubscr_Dyna::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("whenStart"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStart);
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entrants"))
		{
			entrants = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publProp"))
		{
			publProp = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolToPublish"))
		{
			prizePoolToPublish = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolUnit"))
		{
			prizePoolUnit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mixTournSatellite"))
		{
			mixTournSatellite = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournSatelliteDataSubscr_Dyna::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(whenStart);
	_msg.composeUINT32(status);
	_msg.composeUINT32(entrants);
	_msg.composeBYTE(publProp);
	_msg.composeUINT32(prizePoolToPublish);
	_msg.composeBYTE(prizePoolUnit);
	_msg.composeINT8(mixTournSatellite);
}

void TournClient::publication::TournSatelliteDataSubscr_Dyna::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(whenStart);
	_parser.parseUINT32(status);
	_parser.parseUINT32(entrants);
	_parser.parseBYTE(publProp);
	_parser.parseUINT32(prizePoolToPublish);
	_parser.parseBYTE(prizePoolUnit);
	_parser.parseINT8(mixTournSatellite);
}

const char *TournClient::publication::TournSatelliteDataSubscr_Dyna::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("status", status);
	_jsonstr.compose("entrants", entrants);
	_jsonstr.compose("publProp", publProp);
	_jsonstr.compose("prizePoolToPublish", prizePoolToPublish);
	_jsonstr.compose("prizePoolUnit", prizePoolUnit);
	_jsonstr.compose("mixTournSatellite", mixTournSatellite);
	return _buf.c_str();
}

void TournClient::publication::TournSatelliteDataSubscr_Dyna::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("entrants", entrants);
	_jparser.parseByNameThrow("publProp", publProp);
	_jparser.parseByNameThrow("prizePoolToPublish", prizePoolToPublish);
	_jparser.parseByNameThrow("prizePoolUnit", prizePoolUnit);
	_jparser.parseByNameThrow("mixTournSatellite", mixTournSatellite);
}

/* static */ void TournClient::publication::TournSatelliteDataSubscr_Dyna::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 entrants; _jparser.validateByNameThrow("entrants", entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	BYTE publProp; _jparser.validateByNameThrow("publProp", publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 prizePoolToPublish; _jparser.validateByNameThrow("prizePoolToPublish", prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _jparser.validateByNameThrow("prizePoolUnit", prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _jparser.validateByNameThrow("mixTournSatellite", mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournSatelliteDataSubscr_Dyna::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 prizePoolToPublish; _parser.parseUINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _parser.parseINT8(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    LightTournData
//=================================================================

TournClient::publication::LightTournData::LightTournData()
{
	clear();
}

void TournClient::publication::LightTournData::clear()
{
	status = 0;
	whenStart.setNull();
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	prizePoolMoneyToPublish = 0;
	numUsersReg = 0;
}

bool TournClient::publication::LightTournData::equals(const LightTournData& _o) const
{
	return status == _o.status &&
		whenStart.equals(_o.whenStart) &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish &&
		numUsersReg == _o.numUsersReg;
}

const char *TournClient::publication::LightTournData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("whenStart=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendInt(prizePoolMoneyToPublish);
	_buf.append(',');
	_buf.append("numUsersReg=");
	_buf.appendUint(numUsersReg);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::LightTournData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStart", whenStart);
	Atf::XmlElement::encodeAsXmlElement("prizePoolToPublish", prizePoolToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolUnit", prizePoolUnit, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePoolMoneyToPublish", prizePoolMoneyToPublish, _buf);
	Atf::XmlElement::encodeAsXmlElement("numUsersReg", numUsersReg, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::LightTournData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenStart"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStart);
		}
		else if (_element.equals("prizePoolToPublish"))
		{
			prizePoolToPublish = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolUnit"))
		{
			prizePoolUnit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePoolMoneyToPublish"))
		{
			prizePoolMoneyToPublish = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numUsersReg"))
		{
			numUsersReg = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::LightTournData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(status);
	_msg.composeSrvTime(whenStart);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeBYTE(prizePoolUnit);
	_msg.composeINT32(prizePoolMoneyToPublish);
	_msg.composeUINT32(numUsersReg);
}

void TournClient::publication::LightTournData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
	_parser.parseSrvTime(whenStart);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseBYTE(prizePoolUnit);
	_parser.parseINT32(prizePoolMoneyToPublish);
	_parser.parseUINT32(numUsersReg);
}

const char *TournClient::publication::LightTournData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	_jsonstr.compose("whenStart", whenStart);
	_jsonstr.compose("prizePoolToPublish", prizePoolToPublish);
	_jsonstr.compose("prizePoolUnit", prizePoolUnit);
	_jsonstr.compose("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	_jsonstr.compose("numUsersReg", numUsersReg);
	return _buf.c_str();
}

void TournClient::publication::LightTournData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("whenStart", whenStart);
	_jparser.parseByNameThrow("prizePoolToPublish", prizePoolToPublish);
	_jparser.parseByNameThrow("prizePoolUnit", prizePoolUnit);
	_jparser.parseByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	_jparser.parseByNameThrow("numUsersReg", numUsersReg);
}

/* static */ void TournClient::publication::LightTournData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _jparser.validateByNameThrow("whenStart", whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _jparser.validateByNameThrow("prizePoolToPublish", prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _jparser.validateByNameThrow("prizePoolUnit", prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT32 prizePoolMoneyToPublish; _jparser.validateByNameThrow("prizePoolMoneyToPublish", prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 numUsersReg; _jparser.validateByNameThrow("numUsersReg", numUsersReg);
	AtfValidator::validateInt(_descr, "numUsersReg", numUsersReg, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::LightTournData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT32 prizePoolMoneyToPublish; _parser.parseINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 numUsersReg; _parser.parseUINT32(numUsersReg);
	AtfValidator::validateInt(_descr, "numUsersReg", numUsersReg, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournI18nSubscr_Name
//=================================================================

TournClient::publication::TournI18nSubscr_Name::TournI18nSubscr_Name()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournI18nSubscr_Name::TournI18nSubscr_Name(TournI18nSubscr_Name&& _o)
	: name(std::move(_o.name))
{
}

TournClient::publication::TournI18nSubscr_Name& TournClient::publication::TournI18nSubscr_Name::operator=(TournI18nSubscr_Name&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournClient::publication::TournI18nSubscr_Name::clear()
{
	name.clear();
}

bool TournClient::publication::TournI18nSubscr_Name::equals(const TournI18nSubscr_Name& _o) const
{
	return Atf::atfPStringEquals(name, _o.name);
}

const char *TournClient::publication::TournI18nSubscr_Name::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournI18nSubscr_Name::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournI18nSubscr_Name::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournI18nSubscr_Name::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
}

void TournClient::publication::TournI18nSubscr_Name::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
}

const char *TournClient::publication::TournI18nSubscr_Name::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void TournClient::publication::TournI18nSubscr_Name::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void TournClient::publication::TournI18nSubscr_Name::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournI18nSubscr_Name::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournPlayerDataSubscr_User
//=================================================================

TournClient::publication::TournPlayerDataSubscr_User::TournPlayerDataSubscr_User()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournPlayerDataSubscr_User::TournPlayerDataSubscr_User(TournPlayerDataSubscr_User&& _o)
	: name(std::move(_o.name))
	, city(std::move(_o.city))
	, place(std::move(_o.place))
	, placeTo(std::move(_o.placeTo))
	, publProp(std::move(_o.publProp))
	, bounty(std::move(_o.bounty))
	, country(std::move(_o.country))
	, showCity(std::move(_o.showCity))
	, imageId(std::move(_o.imageId))
	, entryNum(std::move(_o.entryNum))
	, brandImageList(std::move(_o.brandImageList))
	, tournId(std::move(_o.tournId))
	, admission(std::move(_o.admission))
	, tChips(std::move(_o.tChips))
	, tournUsersFlags(std::move(_o.tournUsersFlags))
	, pppEntryId(std::move(_o.pppEntryId))
{
}

TournClient::publication::TournPlayerDataSubscr_User& TournClient::publication::TournPlayerDataSubscr_User::operator=(TournPlayerDataSubscr_User&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		city = std::move(_o.city);
		place = std::move(_o.place);
		placeTo = std::move(_o.placeTo);
		publProp = std::move(_o.publProp);
		bounty = std::move(_o.bounty);
		country = std::move(_o.country);
		showCity = std::move(_o.showCity);
		imageId = std::move(_o.imageId);
		entryNum = std::move(_o.entryNum);
		brandImageList = std::move(_o.brandImageList);
		tournId = std::move(_o.tournId);
		admission = std::move(_o.admission);
		tChips = std::move(_o.tChips);
		tournUsersFlags = std::move(_o.tournUsersFlags);
		pppEntryId = std::move(_o.pppEntryId);
	}
	return *this;
}

#endif

void TournClient::publication::TournPlayerDataSubscr_User::clear()
{
	name.clear();
	city.clear();
	place = 0;
	placeTo = 0;
	publProp = 0;
	bounty = 0;
	country.clear();
	showCity = 0;
	imageId = 0;
	entryNum = 0;
	brandImageList.clear();
	tournId = 0;
	admission.clear();
	tChips = 0;
	tournUsersFlags = 0;
	pppEntryId = 0;
}

bool TournClient::publication::TournPlayerDataSubscr_User::equals(const TournPlayerDataSubscr_User& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(city, _o.city) &&
		place == _o.place &&
		placeTo == _o.placeTo &&
		publProp == _o.publProp &&
		bounty == _o.bounty &&
		Atf::atfPStringEquals(country, _o.country) &&
		showCity == _o.showCity &&
		imageId == _o.imageId &&
		entryNum == _o.entryNum &&
		brandImageList.equals(_o.brandImageList) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(admission, _o.admission) &&
		tChips == _o.tChips &&
		tournUsersFlags == _o.tournUsersFlags &&
		pppEntryId == _o.pppEntryId;
}

const char *TournClient::publication::TournPlayerDataSubscr_User::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("place=");
	_buf.appendInt(place);
	_buf.append(',');
	_buf.append("placeTo=");
	_buf.appendInt(placeTo);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt(bounty);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("showCity=");
	_buf.appendUint(showCity);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("entryNum=");
	_buf.appendUint(entryNum);
	_buf.append(',');
	_buf.append("brandImageList=");
	brandImageList.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("tournUsersFlags=");
	_buf.appendUint(tournUsersFlags);
	_buf.append(',');
	_buf.append("pppEntryId=");
	_buf.appendUint64(pppEntryId);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournPlayerDataSubscr_User::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("place", place, _buf);
	Atf::XmlElement::encodeAsXmlElement("placeTo", placeTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("publProp", publProp, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("showCity", showCity, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryNum", entryNum, _buf);
	brandImageList.toXmlString("brandImageList", _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("admission", admission, _buf);
	Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournUsersFlags", tournUsersFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("pppEntryId", pppEntryId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournPlayerDataSubscr_User::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("place"))
		{
			place = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("placeTo"))
		{
			placeTo = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publProp"))
		{
			publProp = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("showCity"))
		{
			showCity = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entryNum"))
		{
			entryNum = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandImageList"))
		{
			if(!Atf::AtfTempl< BrandProt::BrandImageList >::FromXmlString(_value, brandImageList)) return false;
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admission"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admission)) return false;
		}
		else if (_element.equals("tChips"))
		{
			tChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournUsersFlags"))
		{
			tournUsersFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("pppEntryId"))
		{
			pppEntryId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournPlayerDataSubscr_User::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
	_msg.composeString(city);
	_msg.composeINT32(place);
	_msg.composeINT32(placeTo);
	_msg.composeBYTE(publProp);
	_msg.composeINT32(bounty);
	_msg.composeString(country);
	_msg.composeBYTE(showCity);
	_msg.composeUINT32(imageId);
	_msg.composeUINT16(entryNum);
	brandImageList.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT64(tournId);
	_msg.composeString(admission);
	_msg.composeINT32(tChips);
	_msg.composeUINT32(tournUsersFlags);
	_msg.composeUINT64(pppEntryId);
}

void TournClient::publication::TournPlayerDataSubscr_User::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseStringP(city);
	_parser.parseINT32(place);
	_parser.parseINT32(placeTo);
	_parser.parseBYTE(publProp);
	_parser.parseINT32(bounty);
	_parser.parseStringP(country);
	_parser.parseBYTE(showCity);
	_parser.parseUINT32(imageId);
	_parser.parseUINT16(entryNum);
	brandImageList.parseMsg(_parser);
	_parser.parseUINT64(tournId);
	_parser.parseStringP(admission);
	_parser.parseINT32(tChips);
	_parser.parseUINT32(tournUsersFlags);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(pppEntryId);
}

const char *TournClient::publication::TournPlayerDataSubscr_User::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("city", city);
	_jsonstr.compose("place", place);
	_jsonstr.compose("placeTo", placeTo);
	_jsonstr.compose("publProp", publProp);
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("country", country);
	_jsonstr.compose("showCity", showCity);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("entryNum", entryNum);
	_jsonstr.compose("brandImageList", brandImageList);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("admission", admission);
	_jsonstr.compose("tChips", tChips);
	_jsonstr.compose("tournUsersFlags", tournUsersFlags);
	_jsonstr.compose("pppEntryId", pppEntryId);
	return _buf.c_str();
}

void TournClient::publication::TournPlayerDataSubscr_User::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("place", place);
	_jparser.parseByNameThrow("placeTo", placeTo);
	_jparser.parseByNameThrow("publProp", publProp);
	_jparser.parseByNameThrow("bounty", bounty);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("showCity", showCity);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("entryNum", entryNum);
	_jparser.parseByNameThrow("brandImageList", brandImageList);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("admission", admission);
	_jparser.parseByNameThrow("tChips", tChips);
	_jparser.parseByNameThrow("tournUsersFlags", tournUsersFlags);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("pppEntryId", pppEntryId);
}

/* static */ void TournClient::publication::TournPlayerDataSubscr_User::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
	INT32 place; _jparser.validateByNameThrow("place", place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	INT32 placeTo; _jparser.validateByNameThrow("placeTo", placeTo);
	AtfValidator::validateInt(_descr, "placeTo", placeTo, _checker, __FILE__, __LINE__);
	BYTE publProp; _jparser.validateByNameThrow("publProp", publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	INT32 bounty; _jparser.validateByNameThrow("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	PString country; _jparser.validateByNameThrow("country", country);
	AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
	BYTE showCity; _jparser.validateByNameThrow("showCity", showCity);
	AtfValidator::validateInt(_descr, "showCity", showCity, _checker, __FILE__, __LINE__);
	UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	UINT16 entryNum; _jparser.validateByNameThrow("entryNum", entryNum);
	AtfValidator::validateInt(_descr, "entryNum", entryNum, _checker, __FILE__, __LINE__);
	BrandProt::BrandImageList brandImageList; _jparser.validateByNameThrow("brandImageList", brandImageList);
	UINT64 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString admission; _jparser.validateByNameThrow("admission", admission);
	AtfValidator::validateInt(_descr, "admission", admission.length(), _checker, __FILE__, __LINE__);
	INT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	UINT32 tournUsersFlags; _jparser.validateByNameThrow("tournUsersFlags", tournUsersFlags);
	AtfValidator::validateInt(_descr, "tournUsersFlags", tournUsersFlags, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 pppEntryId; _jparser.validateByNameThrow("pppEntryId", pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournPlayerDataSubscr_User::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	INT32 place; _parser.parseINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	INT32 placeTo; _parser.parseINT32(placeTo);
	AtfValidator::validateInt(_descr, "placeTo", placeTo, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	INT32 bounty; _parser.parseINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	BYTE showCity; _parser.parseBYTE(showCity);
	AtfValidator::validateInt(_descr, "showCity", showCity, _checker, __FILE__, __LINE__);
	UINT32 imageId; _parser.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	UINT16 entryNum; _parser.parseUINT16(entryNum);
	AtfValidator::validateInt(_descr, "entryNum", entryNum, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BrandProt::BrandImageList::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("brandImageList"), _fieldsWithUnparsedContent);
	UINT64 tournId; _parser.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	UINT32 tournUsersFlags; _parser.parseUINT32(tournUsersFlags);
	AtfValidator::validateInt(_descr, "tournUsersFlags", tournUsersFlags, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 pppEntryId; _parser.parseUINT64(pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournPlayerDataSubscr_Chips
//=================================================================

TournClient::publication::TournPlayerDataSubscr_Chips::TournPlayerDataSubscr_Chips()
{
	clear();
}

void TournClient::publication::TournPlayerDataSubscr_Chips::clear()
{
	chips = 0;
	rank = 0;
	award = 0;
}

bool TournClient::publication::TournPlayerDataSubscr_Chips::equals(const TournPlayerDataSubscr_Chips& _o) const
{
	return chips == _o.chips &&
		rank == _o.rank &&
		award == _o.award;
}

const char *TournClient::publication::TournPlayerDataSubscr_Chips::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendUint(award);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournPlayerDataSubscr_Chips::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("rank", rank, _buf);
	Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournPlayerDataSubscr_Chips::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chips"))
		{
			chips = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rank"))
		{
			rank = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("award"))
		{
			award = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournPlayerDataSubscr_Chips::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(chips);
	_msg.composeUINT16(rank);
	_msg.composeUINT32(award);
}

void TournClient::publication::TournPlayerDataSubscr_Chips::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(chips);
	_parser.parseUINT16(rank);
	_parser.parseUINT32(award);
}

const char *TournClient::publication::TournPlayerDataSubscr_Chips::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("rank", rank);
	_jsonstr.compose("award", award);
	return _buf.c_str();
}

void TournClient::publication::TournPlayerDataSubscr_Chips::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("rank", rank);
	_jparser.parseByNameThrow("award", award);
}

/* static */ void TournClient::publication::TournPlayerDataSubscr_Chips::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT16 rank; _jparser.validateByNameThrow("rank", rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	UINT32 award; _jparser.validateByNameThrow("award", award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournPlayerDataSubscr_Chips::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT16 rank; _parser.parseUINT16(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	UINT32 award; _parser.parseUINT32(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournPlayerDataSubscr_Knockouts
//=================================================================

TournClient::publication::TournPlayerDataSubscr_Knockouts::TournPlayerDataSubscr_Knockouts()
{
	clear();
}

void TournClient::publication::TournPlayerDataSubscr_Knockouts::clear()
{
	knockouts = 0;
	headBounty = 0;
	collectedTotal = 0;
}

bool TournClient::publication::TournPlayerDataSubscr_Knockouts::equals(const TournPlayerDataSubscr_Knockouts& _o) const
{
	return knockouts == _o.knockouts &&
		headBounty == _o.headBounty &&
		collectedTotal == _o.collectedTotal;
}

const char *TournClient::publication::TournPlayerDataSubscr_Knockouts::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("knockouts=");
	_buf.appendInt(knockouts);
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendInt(headBounty);
	_buf.append(',');
	_buf.append("collectedTotal=");
	_buf.appendInt(collectedTotal);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournPlayerDataSubscr_Knockouts::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("knockouts", knockouts, _buf);
	Atf::XmlElement::encodeAsXmlElement("headBounty", headBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("collectedTotal", collectedTotal, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournPlayerDataSubscr_Knockouts::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("knockouts"))
		{
			knockouts = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("headBounty"))
		{
			headBounty = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("collectedTotal"))
		{
			collectedTotal = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournPlayerDataSubscr_Knockouts::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(knockouts);
	_msg.composeINT32(headBounty);
	_msg.composeINT32(collectedTotal);
}

void TournClient::publication::TournPlayerDataSubscr_Knockouts::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(knockouts);
	_parser.parseINT32(headBounty);
	_parser.parseINT32(collectedTotal);
}

const char *TournClient::publication::TournPlayerDataSubscr_Knockouts::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("knockouts", knockouts);
	_jsonstr.compose("headBounty", headBounty);
	_jsonstr.compose("collectedTotal", collectedTotal);
	return _buf.c_str();
}

void TournClient::publication::TournPlayerDataSubscr_Knockouts::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("knockouts", knockouts);
	_jparser.parseByNameThrow("headBounty", headBounty);
	_jparser.parseByNameThrow("collectedTotal", collectedTotal);
}

/* static */ void TournClient::publication::TournPlayerDataSubscr_Knockouts::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 knockouts; _jparser.validateByNameThrow("knockouts", knockouts);
	AtfValidator::validateInt(_descr, "knockouts", knockouts, _checker, __FILE__, __LINE__);
	INT32 headBounty; _jparser.validateByNameThrow("headBounty", headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	INT32 collectedTotal; _jparser.validateByNameThrow("collectedTotal", collectedTotal);
	AtfValidator::validateInt(_descr, "collectedTotal", collectedTotal, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournPlayerDataSubscr_Knockouts::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 knockouts; _parser.parseINT32(knockouts);
	AtfValidator::validateInt(_descr, "knockouts", knockouts, _checker, __FILE__, __LINE__);
	INT32 headBounty; _parser.parseINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	INT32 collectedTotal; _parser.parseINT32(collectedTotal);
	AtfValidator::validateInt(_descr, "collectedTotal", collectedTotal, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournPlayerDataSubscr_Ticket
//=================================================================

TournClient::publication::TournPlayerDataSubscr_Ticket::TournPlayerDataSubscr_Ticket()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournPlayerDataSubscr_Ticket::TournPlayerDataSubscr_Ticket(TournPlayerDataSubscr_Ticket&& _o)
	: nextTournId(std::move(_o.nextTournId))
	, ticketAdmission(std::move(_o.ticketAdmission))
{
}

TournClient::publication::TournPlayerDataSubscr_Ticket& TournClient::publication::TournPlayerDataSubscr_Ticket::operator=(TournPlayerDataSubscr_Ticket&& _o)
{
	if(this != &_o)
	{
		nextTournId = std::move(_o.nextTournId);
		ticketAdmission = std::move(_o.ticketAdmission);
	}
	return *this;
}

#endif

void TournClient::publication::TournPlayerDataSubscr_Ticket::clear()
{
	nextTournId = 0;
	ticketAdmission.clear();
}

bool TournClient::publication::TournPlayerDataSubscr_Ticket::equals(const TournPlayerDataSubscr_Ticket& _o) const
{
	return nextTournId == _o.nextTournId &&
		Atf::atfPStringEquals(ticketAdmission, _o.ticketAdmission);
}

const char *TournClient::publication::TournPlayerDataSubscr_Ticket::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("nextTournId=");
	_buf.appendUint(nextTournId);
	_buf.append(',');
	_buf.append("ticketAdmission=");
	_buf.append(ticketAdmission);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournPlayerDataSubscr_Ticket::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("nextTournId", nextTournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketAdmission", ticketAdmission, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournPlayerDataSubscr_Ticket::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("nextTournId"))
		{
			nextTournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketAdmission"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketAdmission)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournPlayerDataSubscr_Ticket::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(nextTournId);
	_msg.composeString(ticketAdmission);
}

void TournClient::publication::TournPlayerDataSubscr_Ticket::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(nextTournId);
	_parser.parseStringP(ticketAdmission);
}

const char *TournClient::publication::TournPlayerDataSubscr_Ticket::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("nextTournId", nextTournId);
	_jsonstr.compose("ticketAdmission", ticketAdmission);
	return _buf.c_str();
}

void TournClient::publication::TournPlayerDataSubscr_Ticket::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("nextTournId", nextTournId);
	_jparser.parseByNameThrow("ticketAdmission", ticketAdmission);
}

/* static */ void TournClient::publication::TournPlayerDataSubscr_Ticket::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 nextTournId; _jparser.validateByNameThrow("nextTournId", nextTournId);
	AtfValidator::validateInt(_descr, "nextTournId", nextTournId, _checker, __FILE__, __LINE__);
	PString ticketAdmission; _jparser.validateByNameThrow("ticketAdmission", ticketAdmission);
	AtfValidator::validateInt(_descr, "ticketAdmission", ticketAdmission.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournPlayerDataSubscr_Ticket::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 nextTournId; _parser.parseUINT32(nextTournId);
	AtfValidator::validateInt(_descr, "nextTournId", nextTournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ticketAdmission"); size_t szTicketAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketAdmission", szTicketAdmission, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournTableData_Stat
//=================================================================

TournClient::publication::TournTableData_Stat::TournTableData_Stat()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournTableData_Stat::TournTableData_Stat(TournTableData_Stat&& _o)
	: tableId(std::move(_o.tableId))
	, name(std::move(_o.name))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
	, placeHolder(std::move(_o.placeHolder))
	, tableId64(std::move(_o.tableId64))
{
}

TournClient::publication::TournTableData_Stat& TournClient::publication::TournTableData_Stat::operator=(TournTableData_Stat&& _o)
{
	if(this != &_o)
	{
		tableId = std::move(_o.tableId);
		name = std::move(_o.name);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
		placeHolder = std::move(_o.placeHolder);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void TournClient::publication::TournTableData_Stat::clear()
{
	tableId = 0;
	name.clear();
	server.clear();
	serverObj.clear();
	placeHolder = 0;
	tableId64 = 0;
}

bool TournClient::publication::TournTableData_Stat::equals(const TournTableData_Stat& _o) const
{
	return tableId == _o.tableId &&
		Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObj, _o.serverObj) &&
		placeHolder == _o.placeHolder &&
		tableId64 == _o.tableId64;
}

const char *TournClient::publication::TournTableData_Stat::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint(tableId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("placeHolder=");
	_buf.appendInt(placeHolder);
	_buf.append(',');
	_buf.append("tableId64=");
	_buf.appendUint64(tableId64);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournTableData_Stat::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	Atf::XmlElement::encodeAsXmlElement("placeHolder", placeHolder, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId64", tableId64, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournTableData_Stat::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableId"))
		{
			tableId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObj"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
		}
		else if (_element.equals("placeHolder"))
		{
			placeHolder = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableId64"))
		{
			tableId64 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournTableData_Stat::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableId);
	_msg.composeString(name);
	_msg.composeString(server);
	_msg.composeString(serverObj);
	_msg.composeINT32(placeHolder);
	_msg.composeUINT64(tableId64);
}

void TournClient::publication::TournTableData_Stat::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId);
	_parser.parseStringP(name);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObj);
	_parser.parseINT32(placeHolder);
	_parser.parseUINT64(tableId64);
}

const char *TournClient::publication::TournTableData_Stat::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("name", name);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObj", serverObj);
	_jsonstr.compose("placeHolder", placeHolder);
	_jsonstr.compose("tableId64", tableId64);
	return _buf.c_str();
}

void TournClient::publication::TournTableData_Stat::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObj", serverObj);
	_jparser.parseByNameThrow("placeHolder", placeHolder);
	_jparser.parseByNameThrow("tableId64", tableId64);
}

/* static */ void TournClient::publication::TournTableData_Stat::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
	AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
	INT32 placeHolder; _jparser.validateByNameThrow("placeHolder", placeHolder);
	AtfValidator::validateInt(_descr, "placeHolder", placeHolder, _checker, __FILE__, __LINE__);
	UINT64 tableId64; _jparser.validateByNameThrow("tableId64", tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournTableData_Stat::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tableId; _parser.parseUINT32(tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	INT32 placeHolder; _parser.parseINT32(placeHolder);
	AtfValidator::validateInt(_descr, "placeHolder", placeHolder, _checker, __FILE__, __LINE__);
	UINT64 tableId64; _parser.parseUINT64(tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournTableData_Dyna
//=================================================================

TournClient::publication::TournTableData_Dyna::TournTableData_Dyna()
{
	clear();
}

void TournClient::publication::TournTableData_Dyna::clear()
{
	numUsers = 0;
	minStack = 0;
	maxStack = 0;
}

bool TournClient::publication::TournTableData_Dyna::equals(const TournTableData_Dyna& _o) const
{
	return numUsers == _o.numUsers &&
		minStack == _o.minStack &&
		maxStack == _o.maxStack;
}

const char *TournClient::publication::TournTableData_Dyna::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append(',');
	_buf.append("minStack=");
	_buf.appendUint(minStack);
	_buf.append(',');
	_buf.append("maxStack=");
	_buf.appendUint(maxStack);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournTableData_Dyna::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numUsers", numUsers, _buf);
	Atf::XmlElement::encodeAsXmlElement("minStack", minStack, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxStack", maxStack, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournTableData_Dyna::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numUsers"))
		{
			numUsers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minStack"))
		{
			minStack = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxStack"))
		{
			maxStack = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournTableData_Dyna::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(numUsers);
	_msg.composeUINT32(minStack);
	_msg.composeUINT32(maxStack);
}

void TournClient::publication::TournTableData_Dyna::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(numUsers);
	_parser.parseUINT32(minStack);
	_parser.parseUINT32(maxStack);
}

const char *TournClient::publication::TournTableData_Dyna::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numUsers", numUsers);
	_jsonstr.compose("minStack", minStack);
	_jsonstr.compose("maxStack", maxStack);
	return _buf.c_str();
}

void TournClient::publication::TournTableData_Dyna::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numUsers", numUsers);
	_jparser.parseByNameThrow("minStack", minStack);
	_jparser.parseByNameThrow("maxStack", maxStack);
}

/* static */ void TournClient::publication::TournTableData_Dyna::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 numUsers; _jparser.validateByNameThrow("numUsers", numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	UINT32 minStack; _jparser.validateByNameThrow("minStack", minStack);
	AtfValidator::validateInt(_descr, "minStack", minStack, _checker, __FILE__, __LINE__);
	UINT32 maxStack; _jparser.validateByNameThrow("maxStack", maxStack);
	AtfValidator::validateInt(_descr, "maxStack", maxStack, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournTableData_Dyna::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 numUsers; _parser.parseUINT32(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	UINT32 minStack; _parser.parseUINT32(minStack);
	AtfValidator::validateInt(_descr, "minStack", minStack, _checker, __FILE__, __LINE__);
	UINT32 maxStack; _parser.parseUINT32(maxStack);
	AtfValidator::validateInt(_descr, "maxStack", maxStack, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournTablePlayerSubscr
//=================================================================

TournClient::publication::TournTablePlayerSubscr::TournTablePlayerSubscr()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournTablePlayerSubscr::TournTablePlayerSubscr(TournTablePlayerSubscr&& _o)
	: position(std::move(_o.position))
	, userName(std::move(_o.userName))
	, chips(std::move(_o.chips))
	, cityData(std::move(_o.cityData))
	, showCity(std::move(_o.showCity))
	, publProp(std::move(_o.publProp))
	, headBounty(std::move(_o.headBounty))
	, collectedBountyKnockouts(std::move(_o.collectedBountyKnockouts))
	, imageId(std::move(_o.imageId))
	, brandImageList(std::move(_o.brandImageList))
{
}

TournClient::publication::TournTablePlayerSubscr& TournClient::publication::TournTablePlayerSubscr::operator=(TournTablePlayerSubscr&& _o)
{
	if(this != &_o)
	{
		position = std::move(_o.position);
		userName = std::move(_o.userName);
		chips = std::move(_o.chips);
		cityData = std::move(_o.cityData);
		showCity = std::move(_o.showCity);
		publProp = std::move(_o.publProp);
		headBounty = std::move(_o.headBounty);
		collectedBountyKnockouts = std::move(_o.collectedBountyKnockouts);
		imageId = std::move(_o.imageId);
		brandImageList = std::move(_o.brandImageList);
	}
	return *this;
}

#endif

void TournClient::publication::TournTablePlayerSubscr::clear()
{
	position = 0;
	userName.clear();
	chips = 0;
	cityData.clear();
	showCity = 0;
	publProp = 0;
	headBounty = 0;
	collectedBountyKnockouts = 0;
	imageId = 0;
	brandImageList.clear();
}

bool TournClient::publication::TournTablePlayerSubscr::equals(const TournTablePlayerSubscr& _o) const
{
	return position == _o.position &&
		Atf::atfPStringEquals(userName, _o.userName) &&
		chips == _o.chips &&
		Atf::atfPStringEquals(cityData, _o.cityData) &&
		showCity == _o.showCity &&
		publProp == _o.publProp &&
		headBounty == _o.headBounty &&
		collectedBountyKnockouts == _o.collectedBountyKnockouts &&
		imageId == _o.imageId &&
		brandImageList.equals(_o.brandImageList);
}

const char *TournClient::publication::TournTablePlayerSubscr::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("position=");
	_buf.appendUint(position);
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("cityData=");
	_buf.append(cityData);
	_buf.append(',');
	_buf.append("showCity=");
	_buf.appendUint(showCity);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendInt(headBounty);
	_buf.append(',');
	_buf.append("collectedBountyKnockouts=");
	_buf.appendInt(collectedBountyKnockouts);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("brandImageList=");
	brandImageList.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournTablePlayerSubscr::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("position", position, _buf);
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("cityData", cityData, _buf);
	Atf::XmlElement::encodeAsXmlElement("showCity", showCity, _buf);
	Atf::XmlElement::encodeAsXmlElement("publProp", publProp, _buf);
	Atf::XmlElement::encodeAsXmlElement("headBounty", headBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("collectedBountyKnockouts", collectedBountyKnockouts, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	brandImageList.toXmlString("brandImageList", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournTablePlayerSubscr::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("position"))
		{
			position = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
		}
		else if (_element.equals("chips"))
		{
			chips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cityData"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, cityData)) return false;
		}
		else if (_element.equals("showCity"))
		{
			showCity = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("publProp"))
		{
			publProp = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("headBounty"))
		{
			headBounty = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("collectedBountyKnockouts"))
		{
			collectedBountyKnockouts = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("brandImageList"))
		{
			if(!Atf::AtfTempl< BrandProt::BrandImageList >::FromXmlString(_value, brandImageList)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournTablePlayerSubscr::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournTablePlayerSubscr())) // not empty
	{
		_body.composeBYTE(position);
		_body.composeString(userName);
		_body.composeINT32(chips);
		_body.composeString(cityData);
		_body.composeBYTE(showCity);
		_body.composeBYTE(publProp);
		_body.composeINT32(headBounty);
		_body.composeINT32(collectedBountyKnockouts);
		_body.composeUINT32(imageId);
		brandImageList.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void TournClient::publication::TournTablePlayerSubscr::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(position);
	_parser0.parseStringP(userName);
	_parser0.parseINT32(chips);
	_parser0.parseStringP(cityData);
	_parser0.parseBYTE(showCity);
	_parser0.parseBYTE(publProp);
	_parser0.parseINT32(headBounty);
	_parser0.parseINT32(collectedBountyKnockouts);
	_parser0.parseUINT32(imageId);
	brandImageList.parseMsg(_parser0);
}

const char *TournClient::publication::TournTablePlayerSubscr::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("position", position);
	_jsonstr.compose("userName", userName);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("cityData", cityData);
	_jsonstr.compose("showCity", showCity);
	_jsonstr.compose("publProp", publProp);
	_jsonstr.compose("headBounty", headBounty);
	_jsonstr.compose("collectedBountyKnockouts", collectedBountyKnockouts);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("brandImageList", brandImageList);
	return _buf.c_str();
}

void TournClient::publication::TournTablePlayerSubscr::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("position", position);
	_jparser.parseByNameThrow("userName", userName);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("cityData", cityData);
	_jparser.parseByNameThrow("showCity", showCity);
	_jparser.parseByNameThrow("publProp", publProp);
	_jparser.parseByNameThrow("headBounty", headBounty);
	_jparser.parseByNameThrow("collectedBountyKnockouts", collectedBountyKnockouts);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("brandImageList", brandImageList);
}

/* static */ void TournClient::publication::TournTablePlayerSubscr::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE position; _jparser.validateByNameThrow("position", position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateInt(_descr, "userName", userName.length(), _checker, __FILE__, __LINE__);
	INT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	PString cityData; _jparser.validateByNameThrow("cityData", cityData);
	AtfValidator::validateInt(_descr, "cityData", cityData.length(), _checker, __FILE__, __LINE__);
	BYTE showCity; _jparser.validateByNameThrow("showCity", showCity);
	AtfValidator::validateInt(_descr, "showCity", showCity, _checker, __FILE__, __LINE__);
	BYTE publProp; _jparser.validateByNameThrow("publProp", publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	INT32 headBounty; _jparser.validateByNameThrow("headBounty", headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	INT32 collectedBountyKnockouts; _jparser.validateByNameThrow("collectedBountyKnockouts", collectedBountyKnockouts);
	AtfValidator::validateInt(_descr, "collectedBountyKnockouts", collectedBountyKnockouts, _checker, __FILE__, __LINE__);
	UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	BrandProt::BrandImageList brandImageList; _jparser.validateByNameThrow("brandImageList", brandImageList);
}

/*static*/ void TournClient::publication::TournTablePlayerSubscr::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE position; _parser0.parseBYTE(position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userName", szUserName, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cityData"); size_t szCityData = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cityData", szCityData, _checker, __FILE__, __LINE__);
	BYTE showCity; _parser0.parseBYTE(showCity);
	AtfValidator::validateInt(_descr, "showCity", showCity, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	INT32 headBounty; _parser0.parseINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	INT32 collectedBountyKnockouts; _parser0.parseINT32(collectedBountyKnockouts);
	AtfValidator::validateInt(_descr, "collectedBountyKnockouts", collectedBountyKnockouts, _checker, __FILE__, __LINE__);
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BrandProt::BrandImageList::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("brandImageList"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournTableWithPlayersSubscr
//=================================================================

TournClient::publication::TournTableWithPlayersSubscr::TournTableWithPlayersSubscr()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::publication::TournTableWithPlayersSubscr::TournTableWithPlayersSubscr(TournTableWithPlayersSubscr&& _o)
	: oldSubCount(std::move(_o.oldSubCount))
	, players(std::move(_o.players))
{
}

TournClient::publication::TournTableWithPlayersSubscr& TournClient::publication::TournTableWithPlayersSubscr::operator=(TournTableWithPlayersSubscr&& _o)
{
	if(this != &_o)
	{
		oldSubCount = std::move(_o.oldSubCount);
		players = std::move(_o.players);
	}
	return *this;
}

#endif

void TournClient::publication::TournTableWithPlayersSubscr::clear()
{
	oldSubCount = 0;
	players.clear();
}

bool TournClient::publication::TournTableWithPlayersSubscr::equals(const TournTableWithPlayersSubscr& _o) const
{
	return oldSubCount == _o.oldSubCount &&
		players.equals(_o.players);
}

const char *TournClient::publication::TournTableWithPlayersSubscr::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("oldSubCount=");
	_buf.appendUint(oldSubCount);
	_buf.append(',');
	_buf.append("players=");
	players.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::publication::TournTableWithPlayersSubscr::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("oldSubCount", oldSubCount, _buf);
	players.toXmlString("players", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::publication::TournTableWithPlayersSubscr::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("oldSubCount"))
		{
			oldSubCount = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("players"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournTablePlayerSubscr, 1 > >::FromXmlString(_value, players)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::publication::TournTableWithPlayersSubscr::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(oldSubCount);
	players.composeMsg(_msg, _ignoreJSON);
}

void TournClient::publication::TournTableWithPlayersSubscr::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(oldSubCount);
	players.parseMsg(_parser);
}

const char *TournClient::publication::TournTableWithPlayersSubscr::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("oldSubCount", oldSubCount);
	_jsonstr.compose("players", players);
	return _buf.c_str();
}

void TournClient::publication::TournTableWithPlayersSubscr::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("oldSubCount", oldSubCount);
	_jparser.parseByNameThrow("players", players);
}

/* static */ void TournClient::publication::TournTableWithPlayersSubscr::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE oldSubCount; _jparser.validateByNameThrow("oldSubCount", oldSubCount);
	AtfValidator::validateInt(_descr, "oldSubCount", oldSubCount, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournTablePlayerSubscr > players; _jparser.validateByNameThrow("players", players);
	AtfValidator::validateInt(_descr, "players", players.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::publication::TournTableWithPlayersSubscr::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE oldSubCount; _parser.parseBYTE(oldSubCount);
	AtfValidator::validateInt(_descr, "oldSubCount", oldSubCount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPlayers = Atf::LAtfVector< TournTablePlayerSubscr, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("players"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "players", szPlayers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_UserTicketData
//=================================================================

TournClient::player::P_UserTicketData::P_UserTicketData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::player::P_UserTicketData::P_UserTicketData(P_UserTicketData&& _o)
	: admissionId(std::move(_o.admissionId))
	, totalCount(std::move(_o.totalCount))
	, reserved(std::move(_o.reserved))
{
}

TournClient::player::P_UserTicketData& TournClient::player::P_UserTicketData::operator=(P_UserTicketData&& _o)
{
	if(this != &_o)
	{
		admissionId = std::move(_o.admissionId);
		totalCount = std::move(_o.totalCount);
		reserved = std::move(_o.reserved);
	}
	return *this;
}

#endif

void TournClient::player::P_UserTicketData::clear()
{
	admissionId.clear();
	totalCount = 0;
	reserved = 0;
}

bool TournClient::player::P_UserTicketData::equals(const P_UserTicketData& _o) const
{
	return Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		totalCount == _o.totalCount &&
		reserved == _o.reserved;
}

const char *TournClient::player::P_UserTicketData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("totalCount=");
	_buf.appendUint(totalCount);
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(reserved);
	_buf.append('}');
	return _buf.c_str();
}

const char *TournClient::player::P_UserTicketData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalCount", totalCount, _buf);
	Atf::XmlElement::encodeAsXmlElement("reserved", reserved, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool TournClient::player::P_UserTicketData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("admissionId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
		}
		else if (_element.equals("totalCount"))
		{
			totalCount = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("reserved"))
		{
			reserved = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void TournClient::player::P_UserTicketData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(admissionId);
	_msg.composeUINT32(totalCount);
	_msg.composeUINT32(reserved);
}

void TournClient::player::P_UserTicketData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(admissionId);
	_parser.parseUINT32(totalCount);
	_parser.parseUINT32(reserved);
}

const char *TournClient::player::P_UserTicketData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("admissionId", admissionId);
	_jsonstr.compose("totalCount", totalCount);
	_jsonstr.compose("reserved", reserved);
	return _buf.c_str();
}

void TournClient::player::P_UserTicketData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("admissionId", admissionId);
	_jparser.parseByNameThrow("totalCount", totalCount);
	_jparser.parseByNameThrow("reserved", reserved);
}

/* static */ void TournClient::player::P_UserTicketData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
	AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
	UINT32 totalCount; _jparser.validateByNameThrow("totalCount", totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _jparser.validateByNameThrow("reserved", reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::player::P_UserTicketData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 totalCount; _parser.parseUINT32(totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _parser.parseUINT32(reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO
//=================================================================

TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO(Protocol_MSG_LOBBY_TOURN_REG_INFO&& _o)
	: userId(std::move(_o.userId))
	, tournId(std::move(_o.tournId))
	, tournRegInfoFlags(std::move(_o.tournRegInfoFlags))
{
}

TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO& TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		tournId = std::move(_o.tournId);
		tournRegInfoFlags = std::move(_o.tournRegInfoFlags);
	}
	return *this;
}

#endif

void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::clear()
{
	userId.clear();
	tournId = 0;
	tournRegInfoFlags = 0;
}

bool TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		tournId == _o.tournId &&
		tournRegInfoFlags == _o.tournRegInfoFlags;
}

bool TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TOURN_REG_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TOURN_REG_INFO*)_other));
}

const char *TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournRegInfoFlags=");
	_buf.appendUint(tournRegInfoFlags);
	return _buf.c_str();
}

const char *TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TOURN_REG_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournRegInfoFlags", tournRegInfoFlags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournRegInfoFlags"))
			{
				tournRegInfoFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(tournRegInfoFlags);
}

void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tournRegInfoFlags);
}

const char *TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("tournRegInfoFlags", tournRegInfoFlags);
	return _buf.c_str();
}

void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("tournId", tournId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tournRegInfoFlags", tournRegInfoFlags);
}

/*static*/ void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _jparser.validateByNameThrow("tournRegInfoFlags", tournRegInfoFlags);
	AtfValidator::validateIntMax(_descr, "tournRegInfoFlags", tournRegInfoFlags, static_cast<UINT32>(TournRegInfoFlags::eTournRegInfoFlags_Last), _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _parser.parseUINT32(tournRegInfoFlags);
	AtfValidator::validateIntMax(_descr, "tournRegInfoFlags", tournRegInfoFlags, static_cast<UINT32>(TournRegInfoFlags::eTournRegInfoFlags_Last), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY
//=================================================================

TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errInfo(std::move(_o.errInfo))
	, currency(std::move(_o.currency))
	, buyInAndRake(std::move(_o.buyInAndRake))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fpp(std::move(_o.fpp))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, userChips(std::move(_o.userChips))
	, userPlayChips(std::move(_o.userPlayChips))
	, userFpp(std::move(_o.userFpp))
	, numTickets(std::move(_o.numTickets))
	, tChips(std::move(_o.tChips))
	, wChips(std::move(_o.wChips))
	, preRegMsg(std::move(_o.preRegMsg))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, currencyContext(std::move(_o.currencyContext))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, whenStartAbs(std::move(_o.whenStartAbs))
	, tournName(std::move(_o.tournName))
	, playChips64(std::move(_o.playChips64))
	, scalePM(std::move(_o.scalePM))
	, speed(std::move(_o.speed))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, tournFlags(std::move(_o.tournFlags))
	, knockout(std::move(_o.knockout))
	, isProportional(std::move(_o.isProportional))
	, admPrice(std::move(_o.admPrice))
	, effectiveAdmissions(std::move(_o.effectiveAdmissions))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errInfo = std::move(_o.errInfo);
		currency = std::move(_o.currency);
		buyInAndRake = std::move(_o.buyInAndRake);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		tournSpendLimit = std::move(_o.tournSpendLimit);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fpp = std::move(_o.fpp);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		isPwdProtected = std::move(_o.isPwdProtected);
		userChips = std::move(_o.userChips);
		userPlayChips = std::move(_o.userPlayChips);
		userFpp = std::move(_o.userFpp);
		numTickets = std::move(_o.numTickets);
		tChips = std::move(_o.tChips);
		wChips = std::move(_o.wChips);
		preRegMsg = std::move(_o.preRegMsg);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		currencyContext = std::move(_o.currencyContext);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		whenStartAbs = std::move(_o.whenStartAbs);
		tournName = std::move(_o.tournName);
		playChips64 = std::move(_o.playChips64);
		scalePM = std::move(_o.scalePM);
		speed = std::move(_o.speed);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		tournFlags = std::move(_o.tournFlags);
		knockout = std::move(_o.knockout);
		isProportional = std::move(_o.isProportional);
		admPrice = std::move(_o.admPrice);
		effectiveAdmissions = std::move(_o.effectiveAdmissions);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errInfo.clear();
	currency.clear();
	buyInAndRake = 0;
	enoughMoneyInOtherCurrency = false;
	tournSpendLimit.clear();
	buyIn = 0;
	rake = 0;
	fpp = 0;
	admissionId.clear();
	isPlayMoney = 0;
	isPwdProtected = 0;
	userChips = 0;
	userPlayChips = 0;
	userFpp = 0;
	numTickets = 0;
	tChips = 0;
	wChips = 0;
	preRegMsg.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	currencyContext.clear();
	clientCurrencyContext.clear();
	whenStartAbs.setNull();
	tournName.clear();
	playChips64 = 0;
	scalePM = 0;
	speed = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	knockout = 0;
	isProportional = false;
	admPrice = 0;
	effectiveAdmissions.clear();
	tournFlags2 = 0;
}

bool TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		errInfo.equals(_o.errInfo) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		buyInAndRake == _o.buyInAndRake &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		tournSpendLimit.equals(_o.tournSpendLimit) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fpp == _o.fpp &&
		Atf::atfPStringEquals(admissionId, _o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		isPwdProtected == _o.isPwdProtected &&
		userChips == _o.userChips &&
		userPlayChips == _o.userPlayChips &&
		userFpp == _o.userFpp &&
		numTickets == _o.numTickets &&
		tChips == _o.tChips &&
		wChips == _o.wChips &&
		Atf::atfPStringEquals(preRegMsg, _o.preRegMsg) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		Atf::atfPStringEquals(tournName, _o.tournName) &&
		playChips64 == _o.playChips64 &&
		scalePM == _o.scalePM &&
		speed == _o.speed &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		knockout == _o.knockout &&
		isProportional == _o.isProportional &&
		admPrice == _o.admPrice &&
		effectiveAdmissions.equals(_o.effectiveAdmissions) &&
		tournFlags2 == _o.tournFlags2;
}

bool TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TOURN_REG_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY*)_other));
}

const char *TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errInfo=");
		errInfo.toTraceString(_buf);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInAndRake=");
		_buf.appendUint(buyInAndRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	else if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInAndRake=");
		_buf.appendUint(buyInAndRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendUint(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("fpp=");
		_buf.appendUint(fpp);
		_buf.append(',');
		_buf.append("admissionId=");
		_buf.append(admissionId);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("isPwdProtected=");
		_buf.appendUint(isPwdProtected);
		_buf.append(',');
		_buf.append("userChips=");
		_buf.appendUint(userChips);
		_buf.append(',');
		_buf.append("userPlayChips=");
		_buf.appendUint(userPlayChips);
		_buf.append(',');
		_buf.append("userFpp=");
		_buf.appendUint(userFpp);
		_buf.append(',');
		_buf.append("numTickets=");
		_buf.appendUint(numTickets);
		_buf.append(',');
		_buf.append("tChips=");
		_buf.appendUint(tChips);
		_buf.append(',');
		_buf.append("wChips=");
		_buf.appendUint(wChips);
		_buf.append(',');
		_buf.append("preRegMsg=");
		_buf.append(preRegMsg);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientCurrencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("whenStartAbs=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
		_buf.append(',');
		_buf.append("tournName=");
		_buf.append(tournName);
		_buf.append(',');
		_buf.append("playChips64=");
		_buf.appendUint64(playChips64);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("speed=");
		_buf.appendUint(speed);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("knockout=");
		_buf.appendUint(knockout);
		_buf.append(',');
		_buf.append("isProportional=");
		_buf.appendUint(isProportional);
		_buf.append(',');
		_buf.append("admPrice=");
		_buf.appendInt64(admPrice);
		_buf.append(',');
		_buf.append("effectiveAdmissions=");
		effectiveAdmissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendInt64(tournFlags2);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		errInfo.toXmlString("errInfo", _buf);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyInAndRake", buyInAndRake, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
		tournSpendLimit.toXmlString("tournSpendLimit", _buf);
	}
	else if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyInAndRake", buyInAndRake, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("fpp", fpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPwdProtected", isPwdProtected, _buf);
		Atf::XmlElement::encodeAsXmlElement("userChips", userChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("userPlayChips", userPlayChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("userFpp", userFpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("numTickets", numTickets, _buf);
		Atf::XmlElement::encodeAsXmlElement("tChips", tChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("wChips", wChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("preRegMsg", preRegMsg, _buf);
		Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientCurrencyContext", clientCurrencyContext, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStartAbs", whenStartAbs);
		Atf::XmlElement::encodeAsXmlElement("tournName", tournName, _buf);
		Atf::XmlElement::encodeAsXmlElement("playChips64", playChips64, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
		Atf::XmlElement::encodeAsXmlElement("speed", speed, _buf);
		Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("knockout", knockout, _buf);
		Atf::XmlElement::encodeAsXmlElement("isProportional", isProportional, _buf);
		Atf::XmlElement::encodeAsXmlElement("admPrice", admPrice, _buf);
		effectiveAdmissions.toXmlString("effectiveAdmissions", _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
		tournSpendLimit.toXmlString("tournSpendLimit", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("errInfo"))
			{
				if(!Atf::AtfTempl< TournCommon::Error_InsufficientFunds32 >::FromXmlString(_value, errInfo)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("buyInAndRake"))
			{
				buyInAndRake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("enoughMoneyInOtherCurrency"))
			{
				enoughMoneyInOtherCurrency = (*_value.ptr() == '1');
			}
			else if (_element.equals("tournSpendLimit"))
			{
				if(!Atf::AtfTempl< TournCommon::TournSpendLimit >::FromXmlString(_value, tournSpendLimit)) return false;
			}
			else if (_element.equals("buyIn"))
			{
				buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rake"))
			{
				rake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fpp"))
			{
				fpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admissionId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPwdProtected"))
			{
				isPwdProtected = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userChips"))
			{
				userChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userPlayChips"))
			{
				userPlayChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userFpp"))
			{
				userFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numTickets"))
			{
				numTickets = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tChips"))
			{
				tChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wChips"))
			{
				wChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("preRegMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, preRegMsg)) return false;
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHiLo"))
			{
				isHiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("clientCurrencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientCurrencyContext)) return false;
			}
			else if (_element.equals("whenStartAbs"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStartAbs);
			}
			else if (_element.equals("tournName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournName)) return false;
			}
			else if (_element.equals("playChips64"))
			{
				playChips64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("speed"))
			{
				speed = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayers"))
			{
				minPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayers"))
			{
				maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPerTable"))
			{
				maxPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("knockout"))
			{
				knockout = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isProportional"))
			{
				isProportional = (*_value.ptr() == '1');
			}
			else if (_element.equals("admPrice"))
			{
				admPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("effectiveAdmissions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< P_UserTicketData, 4 > >::FromXmlString(_value, effectiveAdmissions)) return false;
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_msg.composeString(errDescr);
		errInfo.composeMsg(_msg, _ignoreJSON);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeUINT32(buyInAndRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		tournSpendLimit.composeMsg(_msg, _ignoreJSON);
	}
	else if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeUINT32(buyInAndRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_msg.composeUINT32(buyIn);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(fpp);
		_msg.composeString(admissionId);
		_msg.composeBYTE(isPlayMoney);
		_msg.composeBYTE(isPwdProtected);
		_msg.composeUINT32(userChips);
		_msg.composeUINT32(userPlayChips);
		_msg.composeUINT32(userFpp);
		_msg.composeUINT32(numTickets);
		_msg.composeUINT32(tChips);
		_msg.composeUINT32(wChips);
		_msg.composeString(preRegMsg);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeString(currency);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeSrvTime(whenStartAbs);
		_msg.composeString(tournName);
		_msg.composeUINT64(playChips64);
		_msg.composeINT32(scalePM);
		_msg.composeBYTE(speed);
		_msg.composeUINT32(minPlayers);
		_msg.composeUINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(knockout);
		_msg.composeBOOL(isProportional);
		_msg.composeINT64(admPrice);
		effectiveAdmissions.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT64(tournFlags2);
		tournSpendLimit.composeMsg(_msg, _ignoreJSON);
	}
}

void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_parser.parseStringP(errDescr);
		errInfo.parseMsg(_parser);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseUINT32(buyInAndRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		tournSpendLimit.parseMsg(_parser);
	}
	else if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseUINT32(buyInAndRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_parser.parseUINT32(buyIn);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(fpp);
		_parser.parseStringP(admissionId);
		_parser.parseBYTE(isPlayMoney);
		_parser.parseBYTE(isPwdProtected);
		_parser.parseUINT32(userChips);
		_parser.parseUINT32(userPlayChips);
		_parser.parseUINT32(userFpp);
		_parser.parseUINT32(numTickets);
		_parser.parseUINT32(tChips);
		_parser.parseUINT32(wChips);
		_parser.parseStringP(preRegMsg);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseStringP(currency);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseSrvTime(whenStartAbs);
		_parser.parseStringP(tournName);
		_parser.parseUINT64(playChips64);
		_parser.parseINT32(scalePM);
		_parser.parseBYTE(speed);
		_parser.parseUINT32(minPlayers);
		_parser.parseUINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(knockout);
		_parser.parseBOOL(isProportional);
		_parser.parseINT64(admPrice);
		effectiveAdmissions.parseMsg(_parser);
		_parser.parseINT64(tournFlags2);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

const char *TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("errInfo", errInfo);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("buyInAndRake", buyInAndRake);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jsonstr.compose("tournSpendLimit", tournSpendLimit);
	}
	else if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("buyInAndRake", buyInAndRake);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	}
	else
	{
		_jsonstr.compose("buyIn", buyIn);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("fpp", fpp);
		_jsonstr.compose("admissionId", admissionId);
		_jsonstr.compose("isPlayMoney", isPlayMoney);
		_jsonstr.compose("isPwdProtected", isPwdProtected);
		_jsonstr.compose("userChips", userChips);
		_jsonstr.compose("userPlayChips", userPlayChips);
		_jsonstr.compose("userFpp", userFpp);
		_jsonstr.compose("numTickets", numTickets);
		_jsonstr.compose("tChips", tChips);
		_jsonstr.compose("wChips", wChips);
		_jsonstr.compose("preRegMsg", preRegMsg);
		_jsonstr.compose("game", game);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jsonstr.compose("currencyContext", currencyContext);
		_jsonstr.compose("clientCurrencyContext", clientCurrencyContext);
		_jsonstr.compose("whenStartAbs", whenStartAbs);
		_jsonstr.compose("tournName", tournName);
		_jsonstr.compose("playChips64", playChips64);
		_jsonstr.compose("scalePM", scalePM);
		_jsonstr.compose("speed", speed);
		_jsonstr.compose("minPlayers", minPlayers);
		_jsonstr.compose("maxPlayers", maxPlayers);
		_jsonstr.compose("maxPerTable", maxPerTable);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("knockout", knockout);
		_jsonstr.compose("isProportional", isProportional);
		_jsonstr.compose("admPrice", admPrice);
		_jsonstr.compose("effectiveAdmissions", effectiveAdmissions);
		_jsonstr.compose("tournFlags2", tournFlags2);
		_jsonstr.compose("tournSpendLimit", tournSpendLimit);
	}
	return _buf.c_str();
}

void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("errInfo", errInfo);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("buyInAndRake", buyInAndRake);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jparser.parseByNameThrow("tournSpendLimit", tournSpendLimit);
	}
	else if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("buyInAndRake", buyInAndRake);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	}
	else
	{
		_jparser.parseByNameThrow("buyIn", buyIn);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("fpp", fpp);
		_jparser.parseByNameThrow("admissionId", admissionId);
		_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
		_jparser.parseByNameThrow("isPwdProtected", isPwdProtected);
		_jparser.parseByNameThrow("userChips", userChips);
		_jparser.parseByNameThrow("userPlayChips", userPlayChips);
		_jparser.parseByNameThrow("userFpp", userFpp);
		_jparser.parseByNameThrow("numTickets", numTickets);
		_jparser.parseByNameThrow("tChips", tChips);
		_jparser.parseByNameThrow("wChips", wChips);
		_jparser.parseByNameThrow("preRegMsg", preRegMsg);
		_jparser.parseByNameThrow("game", game);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jparser.parseByNameThrow("currencyContext", currencyContext);
		_jparser.parseByNameThrow("clientCurrencyContext", clientCurrencyContext);
		_jparser.parseByNameThrow("whenStartAbs", whenStartAbs);
		_jparser.parseByNameThrow("tournName", tournName);
		_jparser.parseByNameThrow("playChips64", playChips64);
		_jparser.parseByNameThrow("scalePM", scalePM);
		_jparser.parseByNameThrow("speed", speed);
		_jparser.parseByNameThrow("minPlayers", minPlayers);
		_jparser.parseByNameThrow("maxPlayers", maxPlayers);
		_jparser.parseByNameThrow("maxPerTable", maxPerTable);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("knockout", knockout);
		_jparser.parseByNameThrow("isProportional", isProportional);
		_jparser.parseByNameThrow("admPrice", admPrice);
		_jparser.parseByNameThrow("effectiveAdmissions", effectiveAdmissions);
		_jparser.parseByNameThrow("tournFlags2", tournFlags2);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		TournCommon::Error_InsufficientFunds32 errInfo; _jparser.validateByNameThrow("errInfo", errInfo);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _jparser.validateByNameThrow("buyInAndRake", buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		TournCommon::TournSpendLimit tournSpendLimit; _jparser.validateByNameThrow("tournSpendLimit", tournSpendLimit);
	}
	else if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _jparser.validateByNameThrow("buyInAndRake", buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fpp; _jparser.validateByNameThrow("fpp", fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
		AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
		BYTE isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		BYTE isPwdProtected; _jparser.validateByNameThrow("isPwdProtected", isPwdProtected);
		AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
		UINT32 userChips; _jparser.validateByNameThrow("userChips", userChips);
		AtfValidator::validateInt(_descr, "userChips", userChips, _checker, __FILE__, __LINE__);
		UINT32 userPlayChips; _jparser.validateByNameThrow("userPlayChips", userPlayChips);
		AtfValidator::validateInt(_descr, "userPlayChips", userPlayChips, _checker, __FILE__, __LINE__);
		UINT32 userFpp; _jparser.validateByNameThrow("userFpp", userFpp);
		AtfValidator::validateInt(_descr, "userFpp", userFpp, _checker, __FILE__, __LINE__);
		UINT32 numTickets; _jparser.validateByNameThrow("numTickets", numTickets);
		AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
		UINT32 tChips; _jparser.validateByNameThrow("tChips", tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _jparser.validateByNameThrow("wChips", wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		PString preRegMsg; _jparser.validateByNameThrow("preRegMsg", preRegMsg);
		AtfValidator::validateInt(_descr, "preRegMsg", preRegMsg.length(), _checker, __FILE__, __LINE__);
		BYTE game; _jparser.validateByNameThrow("game", game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
		AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody clientCurrencyContext; _jparser.validateByNameThrow("clientCurrencyContext", clientCurrencyContext);
		AtfValidator::validateInt(_descr, "clientCurrencyContext", clientCurrencyContext._size(), _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _jparser.validateByNameThrow("whenStartAbs", whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		PString tournName; _jparser.validateByNameThrow("tournName", tournName);
		AtfValidator::validateInt(_descr, "tournName", tournName.length(), _checker, __FILE__, __LINE__);
		UINT64 playChips64; _jparser.validateByNameThrow("playChips64", playChips64);
		AtfValidator::validateUint(_descr, "playChips64", playChips64, _checker, __FILE__, __LINE__);
		INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speed; _jparser.validateByNameThrow("speed", speed);
		AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _jparser.validateByNameThrow("knockout", knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool isProportional; _jparser.validateByNameThrow("isProportional", isProportional);
		AtfValidator::validateInt(_descr, "isProportional", isProportional, _checker, __FILE__, __LINE__);
		INT64 admPrice; _jparser.validateByNameThrow("admPrice", admPrice);
		AtfValidator::validateInt(_descr, "admPrice", admPrice, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< P_UserTicketData > effectiveAdmissions; _jparser.validateByNameThrow("effectiveAdmissions", effectiveAdmissions);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", effectiveAdmissions.size(), _checker, __FILE__, __LINE__);
		INT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
		AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		TournCommon::TournSpendLimit tournSpendLimit; _jparser.validateByNameThrow("tournSpendLimit", tournSpendLimit);
	}
}

/*static*/ void TournClient::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournCommon::Error_InsufficientFunds32::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("errInfo"), _fieldsWithUnparsedContent);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _parser.parseUINT32(buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournCommon::TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	else if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _parser.parseUINT32(buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyIn; _parser.parseUINT32(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fpp; _parser.parseUINT32(fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
		BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		BYTE isPwdProtected; _parser.parseBYTE(isPwdProtected);
		AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
		UINT32 userChips; _parser.parseUINT32(userChips);
		AtfValidator::validateInt(_descr, "userChips", userChips, _checker, __FILE__, __LINE__);
		UINT32 userPlayChips; _parser.parseUINT32(userPlayChips);
		AtfValidator::validateInt(_descr, "userPlayChips", userPlayChips, _checker, __FILE__, __LINE__);
		UINT32 userFpp; _parser.parseUINT32(userFpp);
		AtfValidator::validateInt(_descr, "userFpp", userFpp, _checker, __FILE__, __LINE__);
		UINT32 numTickets; _parser.parseUINT32(numTickets);
		AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
		UINT32 tChips; _parser.parseUINT32(tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _parser.parseUINT32(wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegMsg"); size_t szPreRegMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegMsg", szPreRegMsg, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _parser.parseSrvTime(whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
		UINT64 playChips64; _parser.parseUINT64(playChips64);
		AtfValidator::validateUint(_descr, "playChips64", playChips64, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speed; _parser.parseBYTE(speed);
		AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _parser.parseUINT32(knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool isProportional; _parser.parseBOOL(isProportional);
		AtfValidator::validateInt(_descr, "isProportional", isProportional, _checker, __FILE__, __LINE__);
		INT64 admPrice; _parser.parseINT64(admPrice);
		AtfValidator::validateInt(_descr, "admPrice", admPrice, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szEffectiveAdmissions = Atf::LAtfVector< P_UserTicketData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("effectiveAdmissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", szEffectiveAdmissions, _checker, __FILE__, __LINE__);
		INT64 tournFlags2; _parser.parseINT64(tournFlags2);
		AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		TournCommon::TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_REGISTER_USER
//=================================================================

TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::Protocol_MTL_LOBBY_REGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::Protocol_MTL_LOBBY_REGISTER_USER(Protocol_MTL_LOBBY_REGISTER_USER&& _o)
	: userId(std::move(_o.userId))
	, buyinRM(std::move(_o.buyinRM))
	, buyinPM(std::move(_o.buyinPM))
	, buyinFpp(std::move(_o.buyinFpp))
	, password(std::move(_o.password))
	, useTicket(std::move(_o.useTicket))
	, buyinTChips(std::move(_o.buyinTChips))
	, buyinWChips(std::move(_o.buyinWChips))
	, currencyContext(std::move(_o.currencyContext))
	, currency(std::move(_o.currency))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, startTime(std::move(_o.startTime))
{
}

TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER& TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::operator=(Protocol_MTL_LOBBY_REGISTER_USER&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		buyinRM = std::move(_o.buyinRM);
		buyinPM = std::move(_o.buyinPM);
		buyinFpp = std::move(_o.buyinFpp);
		password = std::move(_o.password);
		useTicket = std::move(_o.useTicket);
		buyinTChips = std::move(_o.buyinTChips);
		buyinWChips = std::move(_o.buyinWChips);
		currencyContext = std::move(_o.currencyContext);
		currency = std::move(_o.currency);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		startTime = std::move(_o.startTime);
	}
	return *this;
}

#endif

void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::clear()
{
	userId.clear();
	buyinRM = 0;
	buyinPM = 0;
	buyinFpp = 0;
	password.clear();
	useTicket = 0;
	buyinTChips = 0;
	buyinWChips = 0;
	currencyContext.clear();
	currency.clear();
	game = 0;
	hiLo = 0;
	structure = 0;
	startTime.setNull();
}

bool TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::equals(const Protocol_MTL_LOBBY_REGISTER_USER& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		buyinRM == _o.buyinRM &&
		buyinPM == _o.buyinPM &&
		buyinFpp == _o.buyinFpp &&
		Atf::atfPStringEquals(password, _o.password) &&
		useTicket == _o.useTicket &&
		buyinTChips == _o.buyinTChips &&
		buyinWChips == _o.buyinWChips &&
		currencyContext.equals(_o.currencyContext) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		startTime.equals(_o.startTime);
}

bool TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_REGISTER_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_REGISTER_USER*)_other));
}

const char *TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_REGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("buyinRM=");
	_buf.appendUint(buyinRM);
	_buf.append(',');
	_buf.append("buyinPM=");
	_buf.appendUint(buyinPM);
	_buf.append(',');
	_buf.append("buyinFpp=");
	_buf.appendUint(buyinFpp);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("buyinTChips=");
	_buf.appendUint(buyinTChips);
	_buf.append(',');
	_buf.append("buyinWChips=");
	_buf.appendUint(buyinWChips);
	_buf.append(',');
	_buf.append("currencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("startTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	return _buf.c_str();
}

const char *TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_REGISTER_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyinRM", buyinRM, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyinPM", buyinPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyinFpp", buyinFpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("useTicket", useTicket, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyinTChips", buyinTChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyinWChips", buyinWChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("hiLo", hiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startTime", startTime);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("buyinRM"))
			{
				buyinRM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyinPM"))
			{
				buyinPM = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyinFpp"))
			{
				buyinFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("useTicket"))
			{
				useTicket = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyinTChips"))
			{
				buyinTChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyinWChips"))
			{
				buyinWChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hiLo"))
			{
				hiLo = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startTime"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, startTime);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(buyinRM);
	_msg.composeUINT32(buyinPM);
	_msg.composeUINT32(buyinFpp);
	_msg.composeString(password);
	_msg.composeBYTE(useTicket);
	_msg.composeUINT32(buyinTChips);
	_msg.composeUINT32(buyinWChips);
	_msg.composeMsgBody(currencyContext);
	_msg.composeString(currency);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeSrvTime(startTime);
}

void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(buyinRM);
	_parser.parseUINT32(buyinPM);
	_parser.parseUINT32(buyinFpp);
	_parser.parseStringP(password);
	_parser.parseBYTE(useTicket);
	_parser.parseUINT32(buyinTChips);
	_parser.parseUINT32(buyinWChips);
	_parser.parseMsgBody(currencyContext);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(currency);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseSrvTime(startTime);
}

const char *TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("buyinRM", buyinRM);
	_jsonstr.compose("buyinPM", buyinPM);
	_jsonstr.compose("buyinFpp", buyinFpp);
	_jsonstr.compose("password", password);
	_jsonstr.compose("useTicket", useTicket);
	_jsonstr.compose("buyinTChips", buyinTChips);
	_jsonstr.compose("buyinWChips", buyinWChips);
	_jsonstr.compose("currencyContext", currencyContext);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("game", game);
	_jsonstr.compose("hiLo", hiLo);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("startTime", startTime);
	return _buf.c_str();
}

void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("buyinRM", buyinRM);
	_jparser.parseByNameThrow("buyinPM", buyinPM);
	_jparser.parseByNameThrow("buyinFpp", buyinFpp);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("useTicket", useTicket);
	_jparser.parseByNameThrow("buyinTChips", buyinTChips);
	_jparser.parseByNameThrow("buyinWChips", buyinWChips);
	_jparser.parseByNameThrow("currencyContext", currencyContext);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("hiLo", hiLo);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("startTime", startTime);
}

/*static*/ void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 buyinRM; _jparser.validateByNameThrow("buyinRM", buyinRM);
	AtfValidator::validateInt(_descr, "buyinRM", buyinRM, _checker, __FILE__, __LINE__);
	UINT32 buyinPM; _jparser.validateByNameThrow("buyinPM", buyinPM);
	AtfValidator::validateInt(_descr, "buyinPM", buyinPM, _checker, __FILE__, __LINE__);
	UINT32 buyinFpp; _jparser.validateByNameThrow("buyinFpp", buyinFpp);
	AtfValidator::validateInt(_descr, "buyinFpp", buyinFpp, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 100, _checker, __FILE__, __LINE__);
	BYTE useTicket; _jparser.validateByNameThrow("useTicket", useTicket);
	AtfValidator::validateInt(_descr, "useTicket", useTicket, _checker, __FILE__, __LINE__);
	UINT32 buyinTChips; _jparser.validateByNameThrow("buyinTChips", buyinTChips);
	AtfValidator::validateInt(_descr, "buyinTChips", buyinTChips, _checker, __FILE__, __LINE__);
	UINT32 buyinWChips; _jparser.validateByNameThrow("buyinWChips", buyinWChips);
	AtfValidator::validateInt(_descr, "buyinWChips", buyinWChips, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
	AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 5, _checker, __FILE__, __LINE__);
	BYTE game; _jparser.validateByNameThrow("game", game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _jparser.validateByNameThrow("hiLo", hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _jparser.validateByNameThrow("structure", structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	SrvTime startTime; _jparser.validateByNameThrow("startTime", startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 buyinRM; _parser.parseUINT32(buyinRM);
	AtfValidator::validateInt(_descr, "buyinRM", buyinRM, _checker, __FILE__, __LINE__);
	UINT32 buyinPM; _parser.parseUINT32(buyinPM);
	AtfValidator::validateInt(_descr, "buyinPM", buyinPM, _checker, __FILE__, __LINE__);
	UINT32 buyinFpp; _parser.parseUINT32(buyinFpp);
	AtfValidator::validateInt(_descr, "buyinFpp", buyinFpp, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 100, _checker, __FILE__, __LINE__);
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateInt(_descr, "useTicket", useTicket, _checker, __FILE__, __LINE__);
	UINT32 buyinTChips; _parser.parseUINT32(buyinTChips);
	AtfValidator::validateInt(_descr, "buyinTChips", buyinTChips, _checker, __FILE__, __LINE__);
	UINT32 buyinWChips; _parser.parseUINT32(buyinWChips);
	AtfValidator::validateInt(_descr, "buyinWChips", buyinWChips, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_REGISTER_USER_REPLY
//=================================================================

TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::Protocol_MTL_LOBBY_REGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::Protocol_MTL_LOBBY_REGISTER_USER_REPLY(Protocol_MTL_LOBBY_REGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, maxAllins(std::move(_o.maxAllins))
	, registrationMsg(std::move(_o.registrationMsg))
	, seatsAvailable(std::move(_o.seatsAvailable))
	, serverName(std::move(_o.serverName))
	, socialToken(std::move(_o.socialToken))
	, clientNotification(std::move(_o.clientNotification))
{
}

TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY& TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::operator=(Protocol_MTL_LOBBY_REGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		maxAllins = std::move(_o.maxAllins);
		registrationMsg = std::move(_o.registrationMsg);
		seatsAvailable = std::move(_o.seatsAvailable);
		serverName = std::move(_o.serverName);
		socialToken = std::move(_o.socialToken);
		clientNotification = std::move(_o.clientNotification);
	}
	return *this;
}

#endif

void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	maxAllins = 0;
	registrationMsg.clear();
	seatsAvailable = false;
	serverName.clear();
	socialToken.clear();
	clientNotification.clear();
}

bool TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::equals(const Protocol_MTL_LOBBY_REGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		maxAllins == _o.maxAllins &&
		Atf::atfPStringEquals(registrationMsg, _o.registrationMsg) &&
		seatsAvailable == _o.seatsAvailable &&
		Atf::atfPStringEquals(serverName, _o.serverName) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		Atf::atfPStringEquals(clientNotification, _o.clientNotification);
}

bool TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_REGISTER_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_REGISTER_USER_REPLY*)_other));
}

const char *TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_REGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("maxAllins=");
		_buf.appendInt(maxAllins);
		_buf.append(',');
		_buf.append("registrationMsg=");
		_buf.append(registrationMsg);
		_buf.append(',');
		_buf.append("seatsAvailable=");
		_buf.appendUint(seatsAvailable);
		_buf.append(',');
		_buf.append("serverName=");
		_buf.append(serverName);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("clientNotification=");
		_buf.append(clientNotification);
	}
	return _buf.c_str();
}

const char *TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_REGISTER_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	if( !errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("maxAllins", maxAllins, _buf);
		Atf::XmlElement::encodeAsXmlElement("registrationMsg", registrationMsg, _buf);
		Atf::XmlElement::encodeAsXmlElement("seatsAvailable", seatsAvailable, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverName", serverName, _buf);
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientNotification", clientNotification, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("maxAllins"))
			{
				maxAllins = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("registrationMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, registrationMsg)) return false;
			}
			else if (_element.equals("seatsAvailable"))
			{
				seatsAvailable = (*_value.ptr() == '1');
			}
			else if (_element.equals("serverName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverName)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("clientNotification"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clientNotification)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	if( !errCode )
	{
		_msg.composeINT16(maxAllins);
		_msg.composeString(registrationMsg);
		_msg.composeBOOL(seatsAvailable);
		_msg.composeString(serverName);
		_msg.composeString(socialToken);
		_msg.composeString(clientNotification);
	}
}

void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	if( !errCode )
	{
		_parser.parseINT16(maxAllins);
		_parser.parseStringP(registrationMsg);
		_parser.parseBOOL(seatsAvailable);
		_parser.parseStringP(serverName);
		_parser.parseStringP(socialToken);
		_parser.parseStringP(clientNotification);
	}
}

const char *TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDescr", errDescr);
	if( !errCode )
	{
		_jsonstr.compose("maxAllins", maxAllins);
		_jsonstr.compose("registrationMsg", registrationMsg);
		_jsonstr.compose("seatsAvailable", seatsAvailable);
		_jsonstr.compose("serverName", serverName);
		_jsonstr.compose("socialToken", socialToken);
		_jsonstr.compose("clientNotification", clientNotification);
	}
	return _buf.c_str();
}

void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDescr", errDescr);
	if( !errCode )
	{
		_jparser.parseByNameThrow("maxAllins", maxAllins);
		_jparser.parseByNameThrow("registrationMsg", registrationMsg);
		_jparser.parseByNameThrow("seatsAvailable", seatsAvailable);
		_jparser.parseByNameThrow("serverName", serverName);
		_jparser.parseByNameThrow("socialToken", socialToken);
		_jparser.parseByNameThrow("clientNotification", clientNotification);
	}
}

/*static*/ void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		INT16 maxAllins; _jparser.validateByNameThrow("maxAllins", maxAllins);
		AtfValidator::validateInt(_descr, "maxAllins", maxAllins, _checker, __FILE__, __LINE__);
		PString registrationMsg; _jparser.validateByNameThrow("registrationMsg", registrationMsg);
		AtfValidator::validateInt(_descr, "registrationMsg", registrationMsg.length(), _checker, __FILE__, __LINE__);
		bool seatsAvailable; _jparser.validateByNameThrow("seatsAvailable", seatsAvailable);
		AtfValidator::validateInt(_descr, "seatsAvailable", seatsAvailable, _checker, __FILE__, __LINE__);
		PString serverName; _jparser.validateByNameThrow("serverName", serverName);
		AtfValidator::validateInt(_descr, "serverName", serverName.length(), _checker, __FILE__, __LINE__);
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
		PString clientNotification; _jparser.validateByNameThrow("clientNotification", clientNotification);
		AtfValidator::validateInt(_descr, "clientNotification", clientNotification.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void TournClient::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		INT16 maxAllins; _parser.parseINT16(maxAllins);
		AtfValidator::validateInt(_descr, "maxAllins", maxAllins, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "registrationMsg"); size_t szRegistrationMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "registrationMsg", szRegistrationMsg, _checker, __FILE__, __LINE__);
		bool seatsAvailable; _parser.parseBOOL(seatsAvailable);
		AtfValidator::validateInt(_descr, "seatsAvailable", seatsAvailable, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clientNotification"); size_t szClientNotification = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clientNotification", szClientNotification, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_UNREGISTER_USER
//=================================================================

TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::Protocol_MTL_LOBBY_UNREGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::Protocol_MTL_LOBBY_UNREGISTER_USER(Protocol_MTL_LOBBY_UNREGISTER_USER&& _o)
	: tournId(std::move(_o.tournId))
	, userName(std::move(_o.userName))
{
}

TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER& TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::operator=(Protocol_MTL_LOBBY_UNREGISTER_USER&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::clear()
{
	tournId = 0;
	userName.clear();
}

bool TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::equals(const Protocol_MTL_LOBBY_UNREGISTER_USER& _o) const
{
	return tournId == _o.tournId &&
		Atf::atfPStringEquals(userName, _o.userName);
}

bool TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_UNREGISTER_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_UNREGISTER_USER*)_other));
}

const char *TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_UNREGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

const char *TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_UNREGISTER_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userName", userName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
	_msg.composeString(userName);
}

void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseStringP(userName);
}

const char *TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("userName", userName);
	return _buf.c_str();
}

void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("userName", userName);
}

/*static*/ void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString userName; _jparser.validateByNameThrow("userName", userName);
	AtfValidator::validateIntMax(_descr, "userName", userName.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY
//=================================================================

TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY(Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, refund(std::move(_o.refund))
	, refundPlay(std::move(_o.refundPlay))
	, refundFpp(std::move(_o.refundFpp))
	, refundTChips(std::move(_o.refundTChips))
	, refundWChips(std::move(_o.refundWChips))
	, tournamentCurrency(std::move(_o.tournamentCurrency))
	, refundCurrency(std::move(_o.refundCurrency))
	, refundPlay64(std::move(_o.refundPlay64))
{
}

TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY& TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::operator=(Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		refund = std::move(_o.refund);
		refundPlay = std::move(_o.refundPlay);
		refundFpp = std::move(_o.refundFpp);
		refundTChips = std::move(_o.refundTChips);
		refundWChips = std::move(_o.refundWChips);
		tournamentCurrency = std::move(_o.tournamentCurrency);
		refundCurrency = std::move(_o.refundCurrency);
		refundPlay64 = std::move(_o.refundPlay64);
	}
	return *this;
}

#endif

void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	refund = 0;
	refundPlay = 0;
	refundFpp = 0;
	refundTChips = 0;
	refundWChips = 0;
	tournamentCurrency.clear();
	refundCurrency.clear();
	refundPlay64 = 0;
}

bool TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::equals(const Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		refund == _o.refund &&
		refundPlay == _o.refundPlay &&
		refundFpp == _o.refundFpp &&
		refundTChips == _o.refundTChips &&
		refundWChips == _o.refundWChips &&
		Atf::atfPStringEquals(tournamentCurrency, _o.tournamentCurrency) &&
		Atf::atfPStringEquals(refundCurrency, _o.refundCurrency) &&
		refundPlay64 == _o.refundPlay64;
}

bool TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_LOBBY_UNREGISTER_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY*)_other));
}

const char *TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_UNREGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("refund=");
		_buf.appendUint(refund);
		_buf.append(',');
		_buf.append("refundPlay=");
		_buf.appendInt(refundPlay);
		_buf.append(',');
		_buf.append("refundFpp=");
		_buf.appendUint(refundFpp);
		_buf.append(',');
		_buf.append("refundTChips=");
		_buf.appendUint(refundTChips);
		_buf.append(',');
		_buf.append("refundWChips=");
		_buf.appendUint(refundWChips);
		_buf.append(',');
		_buf.append("tournamentCurrency=");
		_buf.append(tournamentCurrency);
		_buf.append(',');
		_buf.append("refundCurrency=");
		_buf.append(refundCurrency);
		_buf.append(',');
		_buf.append("refundPlay64=");
		_buf.appendUint64(refundPlay64);
	}
	return _buf.c_str();
}

const char *TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_LOBBY_UNREGISTER_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	if( !errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("refund", refund, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundPlay", refundPlay, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundFpp", refundFpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundTChips", refundTChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundWChips", refundWChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournamentCurrency", tournamentCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundCurrency", refundCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundPlay64", refundPlay64, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("refund"))
			{
				refund = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundPlay"))
			{
				refundPlay = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundFpp"))
			{
				refundFpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundTChips"))
			{
				refundTChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundWChips"))
			{
				refundWChips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournamentCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournamentCurrency)) return false;
			}
			else if (_element.equals("refundCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, refundCurrency)) return false;
			}
			else if (_element.equals("refundPlay64"))
			{
				refundPlay64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	if( !errCode )
	{
		_msg.composeUINT32(refund);
		_msg.composeINT32(refundPlay);
		_msg.composeUINT32(refundFpp);
		_msg.composeUINT32(refundTChips);
		_msg.composeUINT32(refundWChips);
		_msg.composeString(tournamentCurrency);
		_msg.composeString(refundCurrency);
		_msg.composeUINT64(refundPlay64);
	}
}

void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	if( !errCode )
	{
		_parser.parseUINT32(refund);
		_parser.parseINT32(refundPlay);
		_parser.parseUINT32(refundFpp);
		_parser.parseUINT32(refundTChips);
		_parser.parseUINT32(refundWChips);
		_parser.parseStringP(tournamentCurrency);
		_parser.parseStringP(refundCurrency);
		_parser.parseUINT64(refundPlay64);
	}
}

const char *TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDescr", errDescr);
	if( !errCode )
	{
		_jsonstr.compose("refund", refund);
		_jsonstr.compose("refundPlay", refundPlay);
		_jsonstr.compose("refundFpp", refundFpp);
		_jsonstr.compose("refundTChips", refundTChips);
		_jsonstr.compose("refundWChips", refundWChips);
		_jsonstr.compose("tournamentCurrency", tournamentCurrency);
		_jsonstr.compose("refundCurrency", refundCurrency);
		_jsonstr.compose("refundPlay64", refundPlay64);
	}
	return _buf.c_str();
}

void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDescr", errDescr);
	if( !errCode )
	{
		_jparser.parseByNameThrow("refund", refund);
		_jparser.parseByNameThrow("refundPlay", refundPlay);
		_jparser.parseByNameThrow("refundFpp", refundFpp);
		_jparser.parseByNameThrow("refundTChips", refundTChips);
		_jparser.parseByNameThrow("refundWChips", refundWChips);
		_jparser.parseByNameThrow("tournamentCurrency", tournamentCurrency);
		_jparser.parseByNameThrow("refundCurrency", refundCurrency);
		_jparser.parseByNameThrow("refundPlay64", refundPlay64);
	}
}

/*static*/ void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
	AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		UINT32 refund; _jparser.validateByNameThrow("refund", refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
		INT32 refundPlay; _jparser.validateByNameThrow("refundPlay", refundPlay);
		AtfValidator::validateInt(_descr, "refundPlay", refundPlay, _checker, __FILE__, __LINE__);
		UINT32 refundFpp; _jparser.validateByNameThrow("refundFpp", refundFpp);
		AtfValidator::validateInt(_descr, "refundFpp", refundFpp, _checker, __FILE__, __LINE__);
		UINT32 refundTChips; _jparser.validateByNameThrow("refundTChips", refundTChips);
		AtfValidator::validateInt(_descr, "refundTChips", refundTChips, _checker, __FILE__, __LINE__);
		UINT32 refundWChips; _jparser.validateByNameThrow("refundWChips", refundWChips);
		AtfValidator::validateInt(_descr, "refundWChips", refundWChips, _checker, __FILE__, __LINE__);
		PString tournamentCurrency; _jparser.validateByNameThrow("tournamentCurrency", tournamentCurrency);
		AtfValidator::validateInt(_descr, "tournamentCurrency", tournamentCurrency.length(), _checker, __FILE__, __LINE__);
		PString refundCurrency; _jparser.validateByNameThrow("refundCurrency", refundCurrency);
		AtfValidator::validateInt(_descr, "refundCurrency", refundCurrency.length(), _checker, __FILE__, __LINE__);
		UINT64 refundPlay64; _jparser.validateByNameThrow("refundPlay64", refundPlay64);
		AtfValidator::validateUint(_descr, "refundPlay64", refundPlay64, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void TournClient::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		UINT32 refund; _parser.parseUINT32(refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
		INT32 refundPlay; _parser.parseINT32(refundPlay);
		AtfValidator::validateInt(_descr, "refundPlay", refundPlay, _checker, __FILE__, __LINE__);
		UINT32 refundFpp; _parser.parseUINT32(refundFpp);
		AtfValidator::validateInt(_descr, "refundFpp", refundFpp, _checker, __FILE__, __LINE__);
		UINT32 refundTChips; _parser.parseUINT32(refundTChips);
		AtfValidator::validateInt(_descr, "refundTChips", refundTChips, _checker, __FILE__, __LINE__);
		UINT32 refundWChips; _parser.parseUINT32(refundWChips);
		AtfValidator::validateInt(_descr, "refundWChips", refundWChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournamentCurrency"); size_t szTournamentCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournamentCurrency", szTournamentCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "refundCurrency"); size_t szRefundCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "refundCurrency", szRefundCurrency, _checker, __FILE__, __LINE__);
		UINT64 refundPlay64; _parser.parseUINT64(refundPlay64);
		AtfValidator::validateUint(_descr, "refundPlay64", refundPlay64, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_CLI_GOTO_FINISH
//=================================================================

TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::Protocol_MTL_CLI_GOTO_FINISH()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::Protocol_MTL_CLI_GOTO_FINISH(Protocol_MTL_CLI_GOTO_FINISH&& _o)
	: place(std::move(_o.place))
	, popupText(std::move(_o.popupText))
	, socialToken(std::move(_o.socialToken))
	, nextScheduledTournId(std::move(_o.nextScheduledTournId))
	, startTime(std::move(_o.startTime))
	, clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
	, tournId(std::move(_o.tournId))
	, tournName(std::move(_o.tournName))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, knockoutBounty(std::move(_o.knockoutBounty))
	, numPlayers(std::move(_o.numPlayers))
	, isRegistered(std::move(_o.isRegistered))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, maxPlayers(std::move(_o.maxPlayers))
	, tournState(std::move(_o.tournState))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, flags(std::move(_o.flags))
	, scalePM(std::move(_o.scalePM))
	, isNonFinalFlight(std::move(_o.isNonFinalFlight))
	, nextFlightLevelTargetTournName(std::move(_o.nextFlightLevelTargetTournName))
	, nextFlightLevelTargetServer(std::move(_o.nextFlightLevelTargetServer))
	, headBounty(std::move(_o.headBounty))
	, tournFinishUserFlags(std::move(_o.tournFinishUserFlags))
	, award(std::move(_o.award))
	, collectedBountyAndKnockouts(std::move(_o.collectedBountyAndKnockouts))
	, eligibleForLateReEntryUntil(std::move(_o.eligibleForLateReEntryUntil))
	, progressivePlusInitialBuyInTierId(std::move(_o.progressivePlusInitialBuyInTierId))
{
}

TournClient::player::Protocol_MTL_CLI_GOTO_FINISH& TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::operator=(Protocol_MTL_CLI_GOTO_FINISH&& _o)
{
	if(this != &_o)
	{
		place = std::move(_o.place);
		popupText = std::move(_o.popupText);
		socialToken = std::move(_o.socialToken);
		nextScheduledTournId = std::move(_o.nextScheduledTournId);
		startTime = std::move(_o.startTime);
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
		tournId = std::move(_o.tournId);
		tournName = std::move(_o.tournName);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		knockoutBounty = std::move(_o.knockoutBounty);
		numPlayers = std::move(_o.numPlayers);
		isRegistered = std::move(_o.isRegistered);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
		isPlayMoney = std::move(_o.isPlayMoney);
		maxPlayers = std::move(_o.maxPlayers);
		tournState = std::move(_o.tournState);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		flags = std::move(_o.flags);
		scalePM = std::move(_o.scalePM);
		isNonFinalFlight = std::move(_o.isNonFinalFlight);
		nextFlightLevelTargetTournName = std::move(_o.nextFlightLevelTargetTournName);
		nextFlightLevelTargetServer = std::move(_o.nextFlightLevelTargetServer);
		headBounty = std::move(_o.headBounty);
		tournFinishUserFlags = std::move(_o.tournFinishUserFlags);
		award = std::move(_o.award);
		collectedBountyAndKnockouts = std::move(_o.collectedBountyAndKnockouts);
		eligibleForLateReEntryUntil = std::move(_o.eligibleForLateReEntryUntil);
		progressivePlusInitialBuyInTierId = std::move(_o.progressivePlusInitialBuyInTierId);
	}
	return *this;
}

#endif

void TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::clear()
{
	place = 0;
	popupText.clear();
	socialToken.clear();
	nextScheduledTournId = 0;
	startTime.setNull();
	clubId = 0;
	clubName.clear();
	tournId = 0;
	tournName.clear();
	gameType = 0;
	isHiLo = false;
	buyin = 0;
	rake = 0;
	knockoutBounty = 0;
	numPlayers = 0;
	isRegistered = false;
	limit = 0;
	currency.clear();
	isPlayMoney = false;
	maxPlayers = 0;
	tournState = 0;
	server.clear();
	serverObject.clear();
	flags = 0;
	scalePM = 0;
	isNonFinalFlight = false;
	nextFlightLevelTargetTournName.clear();
	nextFlightLevelTargetServer.clear();
	headBounty = 0;
	tournFinishUserFlags = 0;
	award = 0;
	collectedBountyAndKnockouts = 0;
	eligibleForLateReEntryUntil.setNull();
	progressivePlusInitialBuyInTierId = 0;
}

bool TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::equals(const Protocol_MTL_CLI_GOTO_FINISH& _o) const
{
	return place == _o.place &&
		Atf::atfPStringEquals(popupText, _o.popupText) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		nextScheduledTournId == _o.nextScheduledTournId &&
		startTime.equals(_o.startTime) &&
		clubId == _o.clubId &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(tournName, _o.tournName) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		knockoutBounty == _o.knockoutBounty &&
		numPlayers == _o.numPlayers &&
		isRegistered == _o.isRegistered &&
		limit == _o.limit &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		maxPlayers == _o.maxPlayers &&
		tournState == _o.tournState &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		flags == _o.flags &&
		scalePM == _o.scalePM &&
		isNonFinalFlight == _o.isNonFinalFlight &&
		nextFlightLevelTargetTournName.equals(_o.nextFlightLevelTargetTournName) &&
		Atf::atfPStringEquals(nextFlightLevelTargetServer, _o.nextFlightLevelTargetServer) &&
		headBounty == _o.headBounty &&
		tournFinishUserFlags == _o.tournFinishUserFlags &&
		award == _o.award &&
		collectedBountyAndKnockouts == _o.collectedBountyAndKnockouts &&
		eligibleForLateReEntryUntil.equals(_o.eligibleForLateReEntryUntil) &&
		progressivePlusInitialBuyInTierId == _o.progressivePlusInitialBuyInTierId;
}

bool TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_CLI_GOTO_FINISH != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_CLI_GOTO_FINISH*)_other));
}

const char *TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_CLI_GOTO_FINISH).append(")");
	_buf.append(',');
	_buf.append("place=");
	_buf.appendUint(place);
	_buf.append(',');
	_buf.append("popupText=");
	_buf.append(popupText);
	_buf.append(',');
	_buf.append("socialToken=");
	_buf.append(socialToken);
	_buf.append(',');
	_buf.append("nextScheduledTournId=");
	_buf.appendUint(nextScheduledTournId);
	if( nextScheduledTournId )
	{
		_buf.append(',');
		_buf.append("startTime=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
		_buf.append(',');
		_buf.append("clubId=");
		_buf.appendUint(clubId);
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("tournName=");
		_buf.append(tournName);
		_buf.append(',');
		_buf.append("gameType=");
		_buf.appendUint(gameType);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendUint(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("knockoutBounty=");
		_buf.appendUint(knockoutBounty);
		_buf.append(',');
		_buf.append("numPlayers=");
		_buf.appendUint(numPlayers);
		_buf.append(',');
		_buf.append("isRegistered=");
		_buf.appendUint(isRegistered);
		_buf.append(',');
		_buf.append("limit=");
		_buf.appendUint(limit);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("tournState=");
		_buf.appendUint(tournState);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
	}
	_buf.append(',');
	_buf.append("isNonFinalFlight=");
	_buf.appendUint(isNonFinalFlight);
	if( isNonFinalFlight )
	{
		_buf.append(',');
		_buf.append("nextFlightLevelTargetTournName=");
		Atf::AtfTempl<I18nPString>::ToTraceString(_buf, nextFlightLevelTargetTournName);
		_buf.append(',');
		_buf.append("nextFlightLevelTargetServer=");
		_buf.append(nextFlightLevelTargetServer);
	}
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendInt(headBounty);
	_buf.append(',');
	_buf.append("tournFinishUserFlags=");
	_buf.appendUint(tournFinishUserFlags);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendInt(award);
	_buf.append(',');
	_buf.append("collectedBountyAndKnockouts=");
	_buf.appendInt(collectedBountyAndKnockouts);
	_buf.append(',');
	_buf.append("eligibleForLateReEntryUntil=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, eligibleForLateReEntryUntil);
	_buf.append(',');
	_buf.append("progressivePlusInitialBuyInTierId=");
	_buf.appendUint(progressivePlusInitialBuyInTierId);
	return _buf.c_str();
}

const char *TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_CLI_GOTO_FINISH).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("place", place, _buf);
	Atf::XmlElement::encodeAsXmlElement("popupText", popupText, _buf);
	Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
	Atf::XmlElement::encodeAsXmlElement("nextScheduledTournId", nextScheduledTournId, _buf);
	if( nextScheduledTournId )
	{
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startTime", startTime);
		Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
		Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournName", tournName, _buf);
		Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyin", buyin, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("knockoutBounty", knockoutBounty, _buf);
		Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("isRegistered", isRegistered, _buf);
		Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournState", tournState, _buf);
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
		Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("isNonFinalFlight", isNonFinalFlight, _buf);
	if( isNonFinalFlight )
	{
		Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "nextFlightLevelTargetTournName", nextFlightLevelTargetTournName);
		Atf::XmlElement::encodeAsXmlElement("nextFlightLevelTargetServer", nextFlightLevelTargetServer, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("headBounty", headBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFinishUserFlags", tournFinishUserFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	Atf::XmlElement::encodeAsXmlElement("collectedBountyAndKnockouts", collectedBountyAndKnockouts, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "eligibleForLateReEntryUntil", eligibleForLateReEntryUntil);
	Atf::XmlElement::encodeAsXmlElement("progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("place"))
			{
				place = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("popupText"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, popupText)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("nextScheduledTournId"))
			{
				nextScheduledTournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startTime"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, startTime);
			}
			else if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournName)) return false;
			}
			else if (_element.equals("gameType"))
			{
				gameType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHiLo"))
			{
				isHiLo = (*_value.ptr() == '1');
			}
			else if (_element.equals("buyin"))
			{
				buyin = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rake"))
			{
				rake = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("knockoutBounty"))
			{
				knockoutBounty = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numPlayers"))
			{
				numPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isRegistered"))
			{
				isRegistered = (*_value.ptr() == '1');
			}
			else if (_element.equals("limit"))
			{
				limit = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("maxPlayers"))
			{
				maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournState"))
			{
				tournState = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("serverObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("scalePM"))
			{
				scalePM = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isNonFinalFlight"))
			{
				isNonFinalFlight = (*_value.ptr() == '1');
			}
			else if (_element.equals("nextFlightLevelTargetTournName"))
			{
				Atf::AtfTempl<I18nPString>::FromXmlString(_value, nextFlightLevelTargetTournName);
			}
			else if (_element.equals("nextFlightLevelTargetServer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, nextFlightLevelTargetServer)) return false;
			}
			else if (_element.equals("headBounty"))
			{
				headBounty = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFinishUserFlags"))
			{
				tournFinishUserFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("award"))
			{
				award = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("collectedBountyAndKnockouts"))
			{
				collectedBountyAndKnockouts = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("eligibleForLateReEntryUntil"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, eligibleForLateReEntryUntil);
			}
			else if (_element.equals("progressivePlusInitialBuyInTierId"))
			{
				progressivePlusInitialBuyInTierId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(place);
	_msg.composeString(popupText);
	_msg.composeString(socialToken);
	_msg.composeUINT32(nextScheduledTournId);
	if( nextScheduledTournId )
	{
		_msg.composeSrvTime(startTime);
		_msg.composeUINT32(clubId);
		_msg.composeString(clubName);
		_msg.composeUINT32(tournId);
		_msg.composeString(tournName);
		_msg.composeBYTE(gameType);
		_msg.composeBOOL(isHiLo);
		_msg.composeUINT32(buyin);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(knockoutBounty);
		_msg.composeUINT32(numPlayers);
		_msg.composeBOOL(isRegistered);
		_msg.composeBYTE(limit);
		_msg.composeString(currency);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeUINT32(maxPlayers);
		_msg.composeUINT32(tournState);
		_msg.composeString(server);
		_msg.composeString(serverObject);
		_msg.composeUINT32(flags);
		_msg.composeINT32(scalePM);
	}
	_msg.composeBOOL(isNonFinalFlight);
	if( isNonFinalFlight )
	{
		nextFlightLevelTargetTournName.compose(_msg);
		_msg.composeString(nextFlightLevelTargetServer);
	}
	_msg.composeINT32(headBounty);
	_msg.composeUINT32(tournFinishUserFlags);
	_msg.composeINT32(award);
	_msg.composeINT32(collectedBountyAndKnockouts);
	_msg.composeSrvTime(eligibleForLateReEntryUntil);
	_msg.composeUINT32(progressivePlusInitialBuyInTierId);
}

void TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(place);
	_parser.parseStringP(popupText);
	_parser.parseStringP(socialToken);
	_parser.parseUINT32(nextScheduledTournId);
	if( nextScheduledTournId )
	{
		_parser.parseSrvTime(startTime);
		_parser.parseUINT32(clubId);
		_parser.parseStringP(clubName);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(tournName);
		_parser.parseBYTE(gameType);
		_parser.parseBOOL(isHiLo);
		_parser.parseUINT32(buyin);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(knockoutBounty);
		_parser.parseUINT32(numPlayers);
		_parser.parseBOOL(isRegistered);
		_parser.parseBYTE(limit);
		_parser.parseStringP(currency);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseUINT32(maxPlayers);
		_parser.parseUINT32(tournState);
		_parser.parseStringP(server);
		_parser.parseStringP(serverObject);
		_parser.parseUINT32(flags);
		_parser.parseINT32(scalePM);
	}
	_parser.parseBOOL(isNonFinalFlight);
	if( isNonFinalFlight )
	{
		nextFlightLevelTargetTournName.parse(_parser);
		_parser.parseStringP(nextFlightLevelTargetServer);
	}
	_parser.parseINT32(headBounty);
	_parser.parseUINT32(tournFinishUserFlags);
	_parser.parseINT32(award);
	_parser.parseINT32(collectedBountyAndKnockouts);
	_parser.parseSrvTime(eligibleForLateReEntryUntil);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(progressivePlusInitialBuyInTierId);
}

const char *TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("place", place);
	_jsonstr.compose("popupText", popupText);
	_jsonstr.compose("socialToken", socialToken);
	_jsonstr.compose("nextScheduledTournId", nextScheduledTournId);
	if( nextScheduledTournId )
	{
		_jsonstr.compose("startTime", startTime);
		_jsonstr.compose("clubId", clubId);
		_jsonstr.compose("clubName", clubName);
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("tournName", tournName);
		_jsonstr.compose("gameType", gameType);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("buyin", buyin);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("knockoutBounty", knockoutBounty);
		_jsonstr.compose("numPlayers", numPlayers);
		_jsonstr.compose("isRegistered", isRegistered);
		_jsonstr.compose("limit", limit);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("isPlayMoney", isPlayMoney);
		_jsonstr.compose("maxPlayers", maxPlayers);
		_jsonstr.compose("tournState", tournState);
		_jsonstr.compose("server", server);
		_jsonstr.compose("serverObject", serverObject);
		_jsonstr.compose("flags", flags);
		_jsonstr.compose("scalePM", scalePM);
	}
	_jsonstr.compose("isNonFinalFlight", isNonFinalFlight);
	if( isNonFinalFlight )
	{
		_jsonstr.compose("nextFlightLevelTargetTournName", nextFlightLevelTargetTournName);
		_jsonstr.compose("nextFlightLevelTargetServer", nextFlightLevelTargetServer);
	}
	_jsonstr.compose("headBounty", headBounty);
	_jsonstr.compose("tournFinishUserFlags", tournFinishUserFlags);
	_jsonstr.compose("award", award);
	_jsonstr.compose("collectedBountyAndKnockouts", collectedBountyAndKnockouts);
	_jsonstr.compose("eligibleForLateReEntryUntil", eligibleForLateReEntryUntil);
	_jsonstr.compose("progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId);
	return _buf.c_str();
}

void TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("place", place);
	_jparser.parseByNameThrow("popupText", popupText);
	_jparser.parseByNameThrow("socialToken", socialToken);
	_jparser.parseByNameThrow("nextScheduledTournId", nextScheduledTournId);
	if( nextScheduledTournId )
	{
		_jparser.parseByNameThrow("startTime", startTime);
		_jparser.parseByNameThrow("clubId", clubId);
		_jparser.parseByNameThrow("clubName", clubName);
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("tournName", tournName);
		_jparser.parseByNameThrow("gameType", gameType);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("buyin", buyin);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("knockoutBounty", knockoutBounty);
		_jparser.parseByNameThrow("numPlayers", numPlayers);
		_jparser.parseByNameThrow("isRegistered", isRegistered);
		_jparser.parseByNameThrow("limit", limit);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
		_jparser.parseByNameThrow("maxPlayers", maxPlayers);
		_jparser.parseByNameThrow("tournState", tournState);
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("serverObject", serverObject);
		_jparser.parseByNameThrow("flags", flags);
		_jparser.parseByNameThrow("scalePM", scalePM);
	}
	_jparser.parseByNameThrow("isNonFinalFlight", isNonFinalFlight);
	if( isNonFinalFlight )
	{
		_jparser.parseByNameThrow("nextFlightLevelTargetTournName", nextFlightLevelTargetTournName);
		_jparser.parseByNameThrow("nextFlightLevelTargetServer", nextFlightLevelTargetServer);
	}
	_jparser.parseByNameThrow("headBounty", headBounty);
	_jparser.parseByNameThrow("tournFinishUserFlags", tournFinishUserFlags);
	_jparser.parseByNameThrow("award", award);
	_jparser.parseByNameThrow("collectedBountyAndKnockouts", collectedBountyAndKnockouts);
	_jparser.parseByNameThrow("eligibleForLateReEntryUntil", eligibleForLateReEntryUntil);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId);
}

/*static*/ void TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_FINISH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 nextScheduledTournId = 0;
	bool isNonFinalFlight = false;
	UINT32 place; _jparser.validateByNameThrow("place", place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	PString popupText; _jparser.validateByNameThrow("popupText", popupText);
	AtfValidator::validateInt(_descr, "popupText", popupText.length(), _checker, __FILE__, __LINE__);
	PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
	AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("nextScheduledTournId", nextScheduledTournId);
	AtfValidator::validateInt(_descr, "nextScheduledTournId", nextScheduledTournId, _checker, __FILE__, __LINE__);
	if( nextScheduledTournId )
	{
		SrvTime startTime; _jparser.validateByNameThrow("startTime", startTime);
		AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
		UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		PString clubName; _jparser.validateByNameThrow("clubName", clubName);
		AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString tournName; _jparser.validateByNameThrow("tournName", tournName);
		AtfValidator::validateInt(_descr, "tournName", tournName.length(), _checker, __FILE__, __LINE__);
		BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
		AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
		bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		UINT32 buyin; _jparser.validateByNameThrow("buyin", buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		UINT32 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 knockoutBounty; _jparser.validateByNameThrow("knockoutBounty", knockoutBounty);
		AtfValidator::validateInt(_descr, "knockoutBounty", knockoutBounty, _checker, __FILE__, __LINE__);
		UINT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
		AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
		bool isRegistered; _jparser.validateByNameThrow("isRegistered", isRegistered);
		AtfValidator::validateInt(_descr, "isRegistered", isRegistered, _checker, __FILE__, __LINE__);
		BYTE limit; _jparser.validateByNameThrow("limit", limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		UINT32 tournState; _jparser.validateByNameThrow("tournState", tournState);
		AtfValidator::validateInt(_descr, "tournState", tournState, _checker, __FILE__, __LINE__);
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
		AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
		UINT32 flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	}
	_jparser.validateByNameThrow("isNonFinalFlight", isNonFinalFlight);
	AtfValidator::validateInt(_descr, "isNonFinalFlight", isNonFinalFlight, _checker, __FILE__, __LINE__);
	if( isNonFinalFlight )
	{
		I18nPString nextFlightLevelTargetTournName; _jparser.validateByNameThrow("nextFlightLevelTargetTournName", nextFlightLevelTargetTournName);
		PString nextFlightLevelTargetServer; _jparser.validateByNameThrow("nextFlightLevelTargetServer", nextFlightLevelTargetServer);
		AtfValidator::validateInt(_descr, "nextFlightLevelTargetServer", nextFlightLevelTargetServer.length(), _checker, __FILE__, __LINE__);
	}
	INT32 headBounty; _jparser.validateByNameThrow("headBounty", headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	UINT32 tournFinishUserFlags; _jparser.validateByNameThrow("tournFinishUserFlags", tournFinishUserFlags);
	AtfValidator::validateInt(_descr, "tournFinishUserFlags", tournFinishUserFlags, _checker, __FILE__, __LINE__);
	INT32 award; _jparser.validateByNameThrow("award", award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	INT32 collectedBountyAndKnockouts; _jparser.validateByNameThrow("collectedBountyAndKnockouts", collectedBountyAndKnockouts);
	AtfValidator::validateInt(_descr, "collectedBountyAndKnockouts", collectedBountyAndKnockouts, _checker, __FILE__, __LINE__);
	SrvTime eligibleForLateReEntryUntil; _jparser.validateByNameThrow("eligibleForLateReEntryUntil", eligibleForLateReEntryUntil);
	AtfValidator::validateSrvDateTime(_descr, "eligibleForLateReEntryUntil", eligibleForLateReEntryUntil, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 progressivePlusInitialBuyInTierId; _jparser.validateByNameThrow("progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId);
	AtfValidator::validateInt(_descr, "progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::player::Protocol_MTL_CLI_GOTO_FINISH::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_FINISH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 nextScheduledTournId = 0;
	bool isNonFinalFlight = false;
	UINT32 place; _parser.parseUINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "popupText"); size_t szPopupText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "popupText", szPopupText, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
	AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	_parser.parseUINT32(nextScheduledTournId);
	AtfValidator::validateInt(_descr, "nextScheduledTournId", nextScheduledTournId, _checker, __FILE__, __LINE__);
	if( nextScheduledTournId )
	{
		SrvTime startTime; _parser.parseSrvTime(startTime);
		AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
		UINT32 clubId; _parser.parseUINT32(clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
		BYTE gameType; _parser.parseBYTE(gameType);
		AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		UINT32 buyin; _parser.parseUINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 knockoutBounty; _parser.parseUINT32(knockoutBounty);
		AtfValidator::validateInt(_descr, "knockoutBounty", knockoutBounty, _checker, __FILE__, __LINE__);
		UINT32 numPlayers; _parser.parseUINT32(numPlayers);
		AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
		bool isRegistered; _parser.parseBOOL(isRegistered);
		AtfValidator::validateInt(_descr, "isRegistered", isRegistered, _checker, __FILE__, __LINE__);
		BYTE limit; _parser.parseBYTE(limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		UINT32 tournState; _parser.parseUINT32(tournState);
		AtfValidator::validateInt(_descr, "tournState", tournState, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	}
	_parser.parseBOOL(isNonFinalFlight);
	AtfValidator::validateInt(_descr, "isNonFinalFlight", isNonFinalFlight, _checker, __FILE__, __LINE__);
	if( isNonFinalFlight )
	{
		I18nPString nextFlightLevelTargetTournName; nextFlightLevelTargetTournName.parse(_parser);
		_parser.parseStringN(_dummy, 0, "nextFlightLevelTargetServer"); size_t szNextFlightLevelTargetServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "nextFlightLevelTargetServer", szNextFlightLevelTargetServer, _checker, __FILE__, __LINE__);
	}
	INT32 headBounty; _parser.parseINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	UINT32 tournFinishUserFlags; _parser.parseUINT32(tournFinishUserFlags);
	AtfValidator::validateInt(_descr, "tournFinishUserFlags", tournFinishUserFlags, _checker, __FILE__, __LINE__);
	INT32 award; _parser.parseINT32(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	INT32 collectedBountyAndKnockouts; _parser.parseINT32(collectedBountyAndKnockouts);
	AtfValidator::validateInt(_descr, "collectedBountyAndKnockouts", collectedBountyAndKnockouts, _checker, __FILE__, __LINE__);
	SrvTime eligibleForLateReEntryUntil; _parser.parseSrvTime(eligibleForLateReEntryUntil);
	AtfValidator::validateSrvDateTime(_descr, "eligibleForLateReEntryUntil", eligibleForLateReEntryUntil, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 progressivePlusInitialBuyInTierId; _parser.parseUINT32(progressivePlusInitialBuyInTierId);
	AtfValidator::validateInt(_descr, "progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_CLI_GOTO_TABLE
//=================================================================

TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::Protocol_MTL_CLI_GOTO_TABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::Protocol_MTL_CLI_GOTO_TABLE(Protocol_MTL_CLI_GOTO_TABLE&& _o)
	: serverAddr(std::move(_o.serverAddr))
	, serverObj(std::move(_o.serverObj))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, chips(std::move(_o.chips))
	, sittingIn(std::move(_o.sittingIn))
	, seat(std::move(_o.seat))
	, onConnect(std::move(_o.onConnect))
	, handId(std::move(_o.handId))
	, stats(std::move(_o.stats))
	, actionAmountOld(std::move(_o.actionAmountOld))
	, timeoutOld(std::move(_o.timeoutOld))
	, action(std::move(_o.action))
	, actionAmount(std::move(_o.actionAmount))
	, timeout(std::move(_o.timeout))
{
}

TournClient::player::Protocol_MTL_CLI_GOTO_TABLE& TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::operator=(Protocol_MTL_CLI_GOTO_TABLE&& _o)
{
	if(this != &_o)
	{
		serverAddr = std::move(_o.serverAddr);
		serverObj = std::move(_o.serverObj);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		chips = std::move(_o.chips);
		sittingIn = std::move(_o.sittingIn);
		seat = std::move(_o.seat);
		onConnect = std::move(_o.onConnect);
		handId = std::move(_o.handId);
		stats = std::move(_o.stats);
		actionAmountOld = std::move(_o.actionAmountOld);
		timeoutOld = std::move(_o.timeoutOld);
		action = std::move(_o.action);
		actionAmount = std::move(_o.actionAmount);
		timeout = std::move(_o.timeout);
	}
	return *this;
}

#endif

void TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::clear()
{
	serverAddr.clear();
	serverObj.clear();
	isPlayMoney = false;
	currency.clear();
	chips = 0;
	sittingIn = false;
	seat = 0;
	onConnect = false;
	handId = 0;
	stats = 0;
	actionAmountOld = 0;
	timeoutOld = 0;
	action = 0;
	actionAmount = 0;
	timeout = 0;
}

bool TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::equals(const Protocol_MTL_CLI_GOTO_TABLE& _o) const
{
	return Atf::atfPStringEquals(serverAddr, _o.serverAddr) &&
		Atf::atfPStringEquals(serverObj, _o.serverObj) &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		chips == _o.chips &&
		sittingIn == _o.sittingIn &&
		seat == _o.seat &&
		onConnect == _o.onConnect &&
		handId == _o.handId &&
		stats == _o.stats &&
		actionAmountOld == _o.actionAmountOld &&
		timeoutOld == _o.timeoutOld &&
		action == _o.action &&
		actionAmount == _o.actionAmount &&
		timeout == _o.timeout;
}

bool TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::equals(Atf::MessageProtocol* _other) const
{
	if (MTL_CLI_GOTO_TABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MTL_CLI_GOTO_TABLE*)_other));
}

const char *TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_CLI_GOTO_TABLE).append(")");
	_buf.append(',');
	_buf.append("serverAddr=");
	_buf.append(serverAddr);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("sittingIn=");
	_buf.appendUint(sittingIn);
	_buf.append(',');
	_buf.append("seat=");
	_buf.appendUint(seat);
	_buf.append(',');
	_buf.append("onConnect=");
	_buf.appendUint(onConnect);
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("stats=");
	_buf.appendUint(stats);
	_buf.append(',');
	_buf.append("actionAmountOld=");
	_buf.appendUint(actionAmountOld);
	_buf.append(',');
	_buf.append("timeoutOld=");
	_buf.appendUint(timeoutOld);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendUint(action);
	_buf.append(',');
	_buf.append("actionAmount=");
	_buf.appendUint(actionAmount);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendUint(timeout);
	return _buf.c_str();
}

const char *TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MTL_CLI_GOTO_TABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("serverAddr", serverAddr, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObj", serverObj, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("chips", chips, _buf);
	Atf::XmlElement::encodeAsXmlElement("sittingIn", sittingIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("seat", seat, _buf);
	Atf::XmlElement::encodeAsXmlElement("onConnect", onConnect, _buf);
	Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
	Atf::XmlElement::encodeAsXmlElement("stats", stats, _buf);
	Atf::XmlElement::encodeAsXmlElement("actionAmountOld", actionAmountOld, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeoutOld", timeoutOld, _buf);
	Atf::XmlElement::encodeAsXmlElement("action", action, _buf);
	Atf::XmlElement::encodeAsXmlElement("actionAmount", actionAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeout", timeout, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("serverAddr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverAddr)) return false;
			}
			else if (_element.equals("serverObj"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObj)) return false;
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("chips"))
			{
				chips = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sittingIn"))
			{
				sittingIn = (*_value.ptr() == '1');
			}
			else if (_element.equals("seat"))
			{
				seat = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("onConnect"))
			{
				onConnect = (*_value.ptr() == '1');
			}
			else if (_element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("stats"))
			{
				stats = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("actionAmountOld"))
			{
				actionAmountOld = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeoutOld"))
			{
				timeoutOld = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("action"))
			{
				action = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("actionAmount"))
			{
				actionAmount = (UINT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeout"))
			{
				timeout = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(serverAddr);
	_msg.composeString(serverObj);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeUINT32(chips);
	_msg.composeBOOL(sittingIn);
	_msg.composeBYTE(seat);
	_msg.composeBOOL(onConnect);
	_msg.composeUINT64(handId);
	_msg.composeUINT32(stats);
	_msg.composeUINT16(actionAmountOld);
	_msg.composeUINT32(timeoutOld);
	_msg.composeBYTE(action);
	_msg.composeUINT16(actionAmount);
	_msg.composeUINT32(timeout);
}

void TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverAddr);
	_parser.parseStringP(serverObj);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseUINT32(chips);
	_parser.parseBOOL(sittingIn);
	_parser.parseBYTE(seat);
	_parser.parseBOOL(onConnect);
	_parser.parseUINT64(handId);
	_parser.parseUINT32(stats);
	_parser.parseUINT16(actionAmountOld);
	_parser.parseUINT32(timeoutOld);
	_parser.parseBYTE(action);
	_parser.parseUINT16(actionAmount);
	_parser.parseUINT32(timeout);
}

const char *TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("serverAddr", serverAddr);
	_jsonstr.compose("serverObj", serverObj);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("chips", chips);
	_jsonstr.compose("sittingIn", sittingIn);
	_jsonstr.compose("seat", seat);
	_jsonstr.compose("onConnect", onConnect);
	_jsonstr.compose("handId", handId);
	_jsonstr.compose("stats", stats);
	_jsonstr.compose("actionAmountOld", actionAmountOld);
	_jsonstr.compose("timeoutOld", timeoutOld);
	_jsonstr.compose("action", action);
	_jsonstr.compose("actionAmount", actionAmount);
	_jsonstr.compose("timeout", timeout);
	return _buf.c_str();
}

void TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("serverAddr", serverAddr);
	_jparser.parseByNameThrow("serverObj", serverObj);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("chips", chips);
	_jparser.parseByNameThrow("sittingIn", sittingIn);
	_jparser.parseByNameThrow("seat", seat);
	_jparser.parseByNameThrow("onConnect", onConnect);
	_jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("stats", stats);
	_jparser.parseByNameThrow("actionAmountOld", actionAmountOld);
	_jparser.parseByNameThrow("timeoutOld", timeoutOld);
	_jparser.parseByNameThrow("action", action);
	_jparser.parseByNameThrow("actionAmount", actionAmount);
	_jparser.parseByNameThrow("timeout", timeout);
}

/*static*/ void TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString serverAddr; _jparser.validateByNameThrow("serverAddr", serverAddr);
	AtfValidator::validateInt(_descr, "serverAddr", serverAddr.length(), _checker, __FILE__, __LINE__);
	PString serverObj; _jparser.validateByNameThrow("serverObj", serverObj);
	AtfValidator::validateInt(_descr, "serverObj", serverObj.length(), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 chips; _jparser.validateByNameThrow("chips", chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	bool sittingIn; _jparser.validateByNameThrow("sittingIn", sittingIn);
	AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	BYTE seat; _jparser.validateByNameThrow("seat", seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	bool onConnect; _jparser.validateByNameThrow("onConnect", onConnect);
	AtfValidator::validateInt(_descr, "onConnect", onConnect, _checker, __FILE__, __LINE__);
	UINT64 handId; _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 stats; _jparser.validateByNameThrow("stats", stats);
	AtfValidator::validateInt(_descr, "stats", stats, _checker, __FILE__, __LINE__);
	UINT16 actionAmountOld; _jparser.validateByNameThrow("actionAmountOld", actionAmountOld);
	AtfValidator::validateInt(_descr, "actionAmountOld", actionAmountOld, _checker, __FILE__, __LINE__);
	UINT32 timeoutOld; _jparser.validateByNameThrow("timeoutOld", timeoutOld);
	AtfValidator::validateInt(_descr, "timeoutOld", timeoutOld, _checker, __FILE__, __LINE__);
	BYTE action; _jparser.validateByNameThrow("action", action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT16 actionAmount; _jparser.validateByNameThrow("actionAmount", actionAmount);
	AtfValidator::validateInt(_descr, "actionAmount", actionAmount, _checker, __FILE__, __LINE__);
	UINT32 timeout; _jparser.validateByNameThrow("timeout", timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
}

/*static*/ void TournClient::player::Protocol_MTL_CLI_GOTO_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverAddr"); size_t szServerAddr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddr", szServerAddr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	bool sittingIn; _parser.parseBOOL(sittingIn);
	AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	BYTE seat; _parser.parseBYTE(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	bool onConnect; _parser.parseBOOL(onConnect);
	AtfValidator::validateInt(_descr, "onConnect", onConnect, _checker, __FILE__, __LINE__);
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 stats; _parser.parseUINT32(stats);
	AtfValidator::validateInt(_descr, "stats", stats, _checker, __FILE__, __LINE__);
	UINT16 actionAmountOld; _parser.parseUINT16(actionAmountOld);
	AtfValidator::validateInt(_descr, "actionAmountOld", actionAmountOld, _checker, __FILE__, __LINE__);
	UINT32 timeoutOld; _parser.parseUINT32(timeoutOld);
	AtfValidator::validateInt(_descr, "timeoutOld", timeoutOld, _checker, __FILE__, __LINE__);
	BYTE action; _parser.parseBYTE(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT16 actionAmount; _parser.parseUINT16(actionAmount);
	AtfValidator::validateInt(_descr, "actionAmount", actionAmount, _checker, __FILE__, __LINE__);
	UINT32 timeout; _parser.parseUINT32(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* TournClient::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: _obj = new player::Protocol_MSG_LOBBY_TOURN_REG_INFO(); break;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: _obj = new player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(); break;
			case MTL_CLI_GOTO_FINISH: _obj = new player::Protocol_MTL_CLI_GOTO_FINISH(); break;
			case MTL_CLI_GOTO_TABLE: _obj = new player::Protocol_MTL_CLI_GOTO_TABLE(); break;
			case MTL_LOBBY_REGISTER_USER: _obj = new player::Protocol_MTL_LOBBY_REGISTER_USER(); break;
			case MTL_LOBBY_REGISTER_USER_REPLY: _obj = new player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY(); break;
			case MTL_LOBBY_UNREGISTER_USER: _obj = new player::Protocol_MTL_LOBBY_UNREGISTER_USER(); break;
			case MTL_LOBBY_UNREGISTER_USER_REPLY: _obj = new player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool TournClient::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: player::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_CLI_GOTO_FINISH: player::Protocol_MTL_CLI_GOTO_FINISH::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_CLI_GOTO_TABLE: player::Protocol_MTL_CLI_GOTO_TABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER: player::Protocol_MTL_LOBBY_REGISTER_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER_REPLY: player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER: player::Protocol_MTL_LOBBY_UNREGISTER_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER_REPLY: player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool TournClient::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: player::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_CLI_GOTO_FINISH: player::Protocol_MTL_CLI_GOTO_FINISH::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_CLI_GOTO_TABLE: player::Protocol_MTL_CLI_GOTO_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER: player::Protocol_MTL_LOBBY_REGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER_REPLY: player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER: player::Protocol_MTL_LOBBY_UNREGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER_REPLY: player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

