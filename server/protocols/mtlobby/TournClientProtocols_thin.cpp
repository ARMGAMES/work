/**
 * TournClientProtocols_thin.cpp
 *
 * This file was auto-generated from TournClientProtocols.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin TournClientProtocols.txt
 */
 
#include "TournClientProtocols_thin.h"

//=================================================================
//                    P_BreakPub
//=================================================================

TournClientThin::P_BreakPub::P_BreakPub()
{
	clear();
}

void TournClientThin::P_BreakPub::clear()
{
	breakTime = 0;
	breakLength = 0;
}

bool TournClientThin::P_BreakPub::equals(const P_BreakPub& _o) const
{
	return breakTime == _o.breakTime &&
		breakLength == _o.breakLength;
}

const char *TournClientThin::P_BreakPub::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("breakTime=");
	_buf.appendInt(breakTime);
	_buf.append(',');
	_buf.append("breakLength=");
	_buf.appendUint(breakLength);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::P_BreakPub::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(breakTime);
	_msg.composeUINT32(breakLength);
}

void TournClientThin::P_BreakPub::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(breakTime);
	_parser.parseUINT32(breakLength);
}

/*static*/ void TournClientThin::P_BreakPub::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 breakTime; _parser.parseINT32(breakTime);
	AtfValidator::validateInt(_descr, "breakTime", breakTime, _checker, __FILE__, __LINE__);
	UINT32 breakLength; _parser.parseUINT32(breakLength);
	AtfValidator::validateInt(_descr, "breakLength", breakLength, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_TicketType
//=================================================================

TournClientThin::P_TicketType::P_TicketType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::P_TicketType::P_TicketType(P_TicketType&& _o)
	: ticketTypeId(std::move(_o.ticketTypeId))
	, name(std::move(_o.name))
{
}

TournClientThin::P_TicketType& TournClientThin::P_TicketType::operator=(P_TicketType&& _o)
{
	if(this != &_o)
	{
		ticketTypeId = std::move(_o.ticketTypeId);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournClientThin::P_TicketType::clear()
{
	ticketTypeId = 0;
	name.clear();
}

bool TournClientThin::P_TicketType::equals(const P_TicketType& _o) const
{
	return ticketTypeId == _o.ticketTypeId &&
		name.equals(_o.name);
}

const char *TournClientThin::P_TicketType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketTypeId=");
	_buf.appendUint(ticketTypeId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::P_TicketType::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT16(ticketTypeId);
	_msg.composeString(name);
}

void TournClientThin::P_TicketType::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT16(ticketTypeId);
	_parser.parseStringP(name);
}

/*static*/ void TournClientThin::P_TicketType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT16 ticketTypeId; _parser.parseUINT16(ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_FppReward
//=================================================================

TournClientThin::P_FppReward::P_FppReward()
{
	clear();
}

void TournClientThin::P_FppReward::clear()
{
	siteId = 0;
	reward = 0;
}

bool TournClientThin::P_FppReward::equals(const P_FppReward& _o) const
{
	return siteId == _o.siteId &&
		reward == _o.reward;
}

const char *TournClientThin::P_FppReward::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("reward=");
	_buf.appendUint(reward);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::P_FppReward::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(P_FppReward())) // not empty
	{
		_body.composeUINT32(siteId);
		_body.composeUINT32(reward);
	}

	_msg.composeMsgBody(_body);
}

void TournClientThin::P_FppReward::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(siteId);
	_parser0.parseUINT32(reward);
}

/*static*/ void TournClientThin::P_FppReward::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 siteId; _parser0.parseUINT32(siteId);
	AtfValidator::validateInt(_descr, "siteId", siteId, _checker, __FILE__, __LINE__);
	UINT32 reward; _parser0.parseUINT32(reward);
	AtfValidator::validateInt(_descr, "reward", reward, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_AwardRange
//=================================================================

TournClientThin::P_AwardRange::P_AwardRange()
{
	clear();
}

void TournClientThin::P_AwardRange::clear()
{
	awardAmount = 0;
	nextTournId = 0;
	startPlace = 0;
	endPlace = 0;
}

bool TournClientThin::P_AwardRange::equals(const P_AwardRange& _o) const
{
	return awardAmount == _o.awardAmount &&
		nextTournId == _o.nextTournId &&
		startPlace == _o.startPlace &&
		endPlace == _o.endPlace;
}

const char *TournClientThin::P_AwardRange::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("awardAmount=");
	_buf.appendUint(awardAmount);
	_buf.append(',');
	_buf.append("nextTournId=");
	_buf.appendUint(nextTournId);
	_buf.append(',');
	_buf.append("startPlace=");
	_buf.appendUint(startPlace);
	_buf.append(',');
	_buf.append("endPlace=");
	_buf.appendUint(endPlace);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::P_AwardRange::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(awardAmount);
	_msg.composeUINT32(nextTournId);
	_msg.composeUINT32(startPlace);
	_msg.composeUINT32(endPlace);
}

void TournClientThin::P_AwardRange::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(awardAmount);
	_parser.parseUINT32(nextTournId);
	_parser.parseUINT32(startPlace);
	_parser.parseUINT32(endPlace);
}

/*static*/ void TournClientThin::P_AwardRange::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 awardAmount; _parser.parseUINT32(awardAmount);
	AtfValidator::validateInt(_descr, "awardAmount", awardAmount, _checker, __FILE__, __LINE__);
	UINT32 nextTournId; _parser.parseUINT32(nextTournId);
	AtfValidator::validateInt(_descr, "nextTournId", nextTournId, _checker, __FILE__, __LINE__);
	UINT32 startPlace; _parser.parseUINT32(startPlace);
	AtfValidator::validateInt(_descr, "startPlace", startPlace, _checker, __FILE__, __LINE__);
	UINT32 endPlace; _parser.parseUINT32(endPlace);
	AtfValidator::validateInt(_descr, "endPlace", endPlace, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_AutopublishBody
//=================================================================

TournClientThin::P_AutopublishBody::P_AutopublishBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::P_AutopublishBody::P_AutopublishBody(P_AutopublishBody&& _o)
	: name(std::move(_o.name))
	, value(std::move(_o.value))
{
}

TournClientThin::P_AutopublishBody& TournClientThin::P_AutopublishBody::operator=(P_AutopublishBody&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		value = std::move(_o.value);
	}
	return *this;
}

#endif

void TournClientThin::P_AutopublishBody::clear()
{
	name.clear();
	value.clear();
}

bool TournClientThin::P_AutopublishBody::equals(const P_AutopublishBody& _o) const
{
	return name.equals(_o.name) &&
		value.equals(_o.value);
}

const char *TournClientThin::P_AutopublishBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::P_AutopublishBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(P_AutopublishBody())) // not empty
	{
		_body.composeString(name);
		_body.composeString(value);
	}

	_msg.composeMsgBody(_body);
}

void TournClientThin::P_AutopublishBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	_parser0.parseStringP(value);
}

/*static*/ void TournClientThin::P_AutopublishBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "value"); size_t szValue = strlen(_dummy);
	AtfValidator::validateInt(_descr, "value", szValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSubscr_SpinGoPrize_TargetReference
//=================================================================

TournClientThin::TournSubscr_SpinGoPrize_TargetReference::TournSubscr_SpinGoPrize_TargetReference()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::TournSubscr_SpinGoPrize_TargetReference::TournSubscr_SpinGoPrize_TargetReference(TournSubscr_SpinGoPrize_TargetReference&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, instance(std::move(_o.instance))
	, name(std::move(_o.name))
{
}

TournClientThin::TournSubscr_SpinGoPrize_TargetReference& TournClientThin::TournSubscr_SpinGoPrize_TargetReference::operator=(TournSubscr_SpinGoPrize_TargetReference&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		instance = std::move(_o.instance);
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournClientThin::TournSubscr_SpinGoPrize_TargetReference::clear()
{
	tournamentId = 0;
	server.clear();
	instance.clear();
	name.clear();
}

bool TournClientThin::TournSubscr_SpinGoPrize_TargetReference::equals(const TournSubscr_SpinGoPrize_TargetReference& _o) const
{
	return tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		instance.equals(_o.instance) &&
		name.equals(_o.name);
}

const char *TournClientThin::TournSubscr_SpinGoPrize_TargetReference::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint64(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("instance=");
	_buf.append(instance);
	_buf.append(',');
	_buf.append("name=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::TournSubscr_SpinGoPrize_TargetReference::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(tournamentId);
	_msg.composeString(server);
	_msg.composeString(instance);
	name.compose(_msg);
}

void TournClientThin::TournSubscr_SpinGoPrize_TargetReference::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tournamentId);
	_parser.parseStringP(server);
	_parser.parseStringP(instance);
	name.parse(_parser);
}

/*static*/ void TournClientThin::TournSubscr_SpinGoPrize_TargetReference::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT64 tournamentId; _parser.parseUINT64(tournamentId);
	AtfValidator::validateUint(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "instance"); size_t szInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "instance", szInstance, _checker, __FILE__, __LINE__);
	I18nPString name; name.parse(_parser);
}

//=================================================================
//                    LobbyData_Betting
//=================================================================

TournClientThin::LobbyData_Betting::LobbyData_Betting()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::LobbyData_Betting::LobbyData_Betting(LobbyData_Betting&& _o)
	: blindsLevel(std::move(_o.blindsLevel))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, hilo(std::move(_o.hilo))
	, stakes(std::move(_o.stakes))
{
}

TournClientThin::LobbyData_Betting& TournClientThin::LobbyData_Betting::operator=(LobbyData_Betting&& _o)
{
	if(this != &_o)
	{
		blindsLevel = std::move(_o.blindsLevel);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		hilo = std::move(_o.hilo);
		stakes = std::move(_o.stakes);
	}
	return *this;
}

#endif

void TournClientThin::LobbyData_Betting::clear()
{
	blindsLevel = 0;
	handType = 0;
	structure = 0;
	hilo = 0;
	stakes.clear();
}

bool TournClientThin::LobbyData_Betting::equals(const LobbyData_Betting& _o) const
{
	return blindsLevel == _o.blindsLevel &&
		handType == _o.handType &&
		structure == _o.structure &&
		hilo == _o.hilo &&
		stakes.equals(_o.stakes);
}

const char *TournClientThin::LobbyData_Betting::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("blindsLevel=");
	_buf.appendUint(blindsLevel);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("hilo=");
	_buf.appendUint(hilo);
	_buf.append(',');
	_buf.append("stakes=");
	stakes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::LobbyData_Betting::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(blindsLevel);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(structure);
	_msg.composeBYTE(hilo);
	stakes.composeMsg(_msg);
}

void TournClientThin::LobbyData_Betting::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(blindsLevel);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(structure);
	_parser.parseBYTE(hilo);
	stakes.parseMsg(_parser);
}

/*static*/ void TournClientThin::LobbyData_Betting::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE blindsLevel; _parser.parseBYTE(blindsLevel);
	AtfValidator::validateInt(_descr, "blindsLevel", blindsLevel, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	BYTE hilo; _parser.parseBYTE(hilo);
	AtfValidator::validateInt(_descr, "hilo", hilo, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableCommonThin::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stakes"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    LobbyData_MultidayTourn
//=================================================================

TournClientThin::LobbyData_MultidayTourn::LobbyData_MultidayTourn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::LobbyData_MultidayTourn::LobbyData_MultidayTourn(LobbyData_MultidayTourn&& _o)
	: mt(std::move(_o.mt))
{
}

TournClientThin::LobbyData_MultidayTourn& TournClientThin::LobbyData_MultidayTourn::operator=(LobbyData_MultidayTourn&& _o)
{
	if(this != &_o)
	{
		mt = std::move(_o.mt);
	}
	return *this;
}

#endif

void TournClientThin::LobbyData_MultidayTourn::clear()
{
	mt.clear();
}

bool TournClientThin::LobbyData_MultidayTourn::equals(const LobbyData_MultidayTourn& _o) const
{
	return mt.equals(_o.mt);
}

const char *TournClientThin::LobbyData_MultidayTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("mt=");
	mt.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::LobbyData_MultidayTourn::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(LobbyData_MultidayTourn())) // not empty
	{
		mt.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void TournClientThin::LobbyData_MultidayTourn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	mt.parseMsg(_parser0);
}

/*static*/ void TournClientThin::LobbyData_MultidayTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	MultidayTourn::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("mt"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    P_ParticipantsInfo
//=================================================================

TournClientThin::P_ParticipantsInfo::P_ParticipantsInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::P_ParticipantsInfo::P_ParticipantsInfo(P_ParticipantsInfo&& _o)
	: name(std::move(_o.name))
	, chips(std::move(_o.chips))
	, payment0(std::move(_o.payment0))
	, payment1(std::move(_o.payment1))
{
}

TournClientThin::P_ParticipantsInfo& TournClientThin::P_ParticipantsInfo::operator=(P_ParticipantsInfo&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		chips = std::move(_o.chips);
		payment0 = std::move(_o.payment0);
		payment1 = std::move(_o.payment1);
	}
	return *this;
}

#endif

void TournClientThin::P_ParticipantsInfo::clear()
{
	name.clear();
	chips = 0;
	payment0 = 0;
	payment1 = 0;
}

bool TournClientThin::P_ParticipantsInfo::equals(const P_ParticipantsInfo& _o) const
{
	return name.equals(_o.name) &&
		chips == _o.chips &&
		payment0 == _o.payment0 &&
		payment1 == _o.payment1;
}

const char *TournClientThin::P_ParticipantsInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("payment0=");
	_buf.appendInt(payment0);
	_buf.append(',');
	_buf.append("payment1=");
	_buf.appendInt(payment1);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::P_ParticipantsInfo::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
	_msg.composeINT32(chips);
	_msg.composeINT32(payment0);
	_msg.composeINT32(payment1);
}

void TournClientThin::P_ParticipantsInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseINT32(chips);
	_parser.parseINT32(payment0);
	_parser.parseINT32(payment1);
}

/*static*/ void TournClientThin::P_ParticipantsInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	INT32 chips; _parser.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 payment0; _parser.parseINT32(payment0);
	AtfValidator::validateInt(_descr, "payment0", payment0, _checker, __FILE__, __LINE__);
	INT32 payment1; _parser.parseINT32(payment1);
	AtfValidator::validateInt(_descr, "payment1", payment1, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_DealPayout
//=================================================================

TournClientThin::P_DealPayout::P_DealPayout()
{
	clear();
}

void TournClientThin::P_DealPayout::clear()
{
	position = 0;
	noDealPayout = 0;
}

bool TournClientThin::P_DealPayout::equals(const P_DealPayout& _o) const
{
	return position == _o.position &&
		noDealPayout == _o.noDealPayout;
}

const char *TournClientThin::P_DealPayout::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("position=");
	_buf.appendInt(position);
	_buf.append(',');
	_buf.append("noDealPayout=");
	_buf.appendInt(noDealPayout);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::P_DealPayout::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT8(position);
	_msg.composeINT32(noDealPayout);
}

void TournClientThin::P_DealPayout::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(position);
	_parser.parseINT32(noDealPayout);
}

/*static*/ void TournClientThin::P_DealPayout::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT8 position; _parser.parseINT8(position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	INT32 noDealPayout; _parser.parseINT32(noDealPayout);
	AtfValidator::validateInt(_descr, "noDealPayout", noDealPayout, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    ExtraInfo_StakesLevel
//=================================================================

TournClientThin::ExtraInfo_StakesLevel::ExtraInfo_StakesLevel()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::ExtraInfo_StakesLevel::ExtraInfo_StakesLevel(ExtraInfo_StakesLevel&& _o)
	: stakes(std::move(_o.stakes))
	, levelTime(std::move(_o.levelTime))
	, addTimeBank(std::move(_o.addTimeBank))
{
}

TournClientThin::ExtraInfo_StakesLevel& TournClientThin::ExtraInfo_StakesLevel::operator=(ExtraInfo_StakesLevel&& _o)
{
	if(this != &_o)
	{
		stakes = std::move(_o.stakes);
		levelTime = std::move(_o.levelTime);
		addTimeBank = std::move(_o.addTimeBank);
	}
	return *this;
}

#endif

void TournClientThin::ExtraInfo_StakesLevel::clear()
{
	stakes.clear();
	levelTime = 0;
	addTimeBank = 0;
}

bool TournClientThin::ExtraInfo_StakesLevel::equals(const ExtraInfo_StakesLevel& _o) const
{
	return stakes.equals(_o.stakes) &&
		levelTime == _o.levelTime &&
		addTimeBank == _o.addTimeBank;
}

const char *TournClientThin::ExtraInfo_StakesLevel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("stakes=");
	stakes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("levelTime=");
	_buf.appendUint(levelTime);
	_buf.append(',');
	_buf.append("addTimeBank=");
	_buf.appendUint(addTimeBank);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::ExtraInfo_StakesLevel::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ExtraInfo_StakesLevel())) // not empty
	{
		stakes.composeMsg(_body);
		_body.composeUINT32(levelTime);
		_body.composeUINT32(addTimeBank);
	}

	_msg.composeMsgBody(_body);
}

void TournClientThin::ExtraInfo_StakesLevel::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	stakes.parseMsg(_parser0);
	_parser0.parseUINT32(levelTime);
	_parser0.parseUINT32(addTimeBank);
}

/*static*/ void TournClientThin::ExtraInfo_StakesLevel::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableCommonThin::TableStakes::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("stakes"), _fieldsWithUnparsedContent);
	UINT32 levelTime; _parser0.parseUINT32(levelTime);
	AtfValidator::validateInt(_descr, "levelTime", levelTime, _checker, __FILE__, __LINE__);
	UINT32 addTimeBank; _parser0.parseUINT32(addTimeBank);
	AtfValidator::validateInt(_descr, "addTimeBank", addTimeBank, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournExtraSubscr_Prize_Winner
//=================================================================

TournClientThin::TournExtraSubscr_Prize_Winner::TournExtraSubscr_Prize_Winner()
{
	clear();
}

void TournClientThin::TournExtraSubscr_Prize_Winner::clear()
{
	amount = 0;
	percent = 0;
}

bool TournClientThin::TournExtraSubscr_Prize_Winner::equals(const TournExtraSubscr_Prize_Winner& _o) const
{
	return amount == _o.amount &&
		percent == _o.percent;
}

const char *TournClientThin::TournExtraSubscr_Prize_Winner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("percent=");
	_buf.appendUint(percent);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::TournExtraSubscr_Prize_Winner::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(amount);
	_msg.composeBYTE(percent);
}

void TournClientThin::TournExtraSubscr_Prize_Winner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(amount);
	_parser.parseBYTE(percent);
}

/*static*/ void TournClientThin::TournExtraSubscr_Prize_Winner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	BYTE percent; _parser.parseBYTE(percent);
	AtfValidator::validateInt(_descr, "percent", percent, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize_Prize
//=================================================================

TournClientThin::TournExtraSubscr_Prize_Prize::TournExtraSubscr_Prize_Prize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::TournExtraSubscr_Prize_Prize::TournExtraSubscr_Prize_Prize(TournExtraSubscr_Prize_Prize&& _o)
	: min(std::move(_o.min))
	, max(std::move(_o.max))
	, numTickets(std::move(_o.numTickets))
	, winners(std::move(_o.winners))
{
}

TournClientThin::TournExtraSubscr_Prize_Prize& TournClientThin::TournExtraSubscr_Prize_Prize::operator=(TournExtraSubscr_Prize_Prize&& _o)
{
	if(this != &_o)
	{
		min = std::move(_o.min);
		max = std::move(_o.max);
		numTickets = std::move(_o.numTickets);
		winners = std::move(_o.winners);
	}
	return *this;
}

#endif

void TournClientThin::TournExtraSubscr_Prize_Prize::clear()
{
	min = 0;
	max = 0;
	numTickets = 0;
	winners.clear();
}

bool TournClientThin::TournExtraSubscr_Prize_Prize::equals(const TournExtraSubscr_Prize_Prize& _o) const
{
	return min == _o.min &&
		max == _o.max &&
		numTickets == _o.numTickets &&
		winners.equals(_o.winners);
}

const char *TournClientThin::TournExtraSubscr_Prize_Prize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("min=");
	_buf.appendInt(min);
	_buf.append(',');
	_buf.append("max=");
	_buf.appendInt(max);
	_buf.append(',');
	_buf.append("numTickets=");
	_buf.appendInt(numTickets);
	_buf.append(',');
	_buf.append("winners=");
	winners.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::TournExtraSubscr_Prize_Prize::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(min);
	_msg.composeINT32(max);
	_msg.composeINT32(numTickets);
	winners.composeMsg(_msg);
}

void TournClientThin::TournExtraSubscr_Prize_Prize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(min);
	_parser.parseINT32(max);
	_parser.parseINT32(numTickets);
	winners.parseMsg(_parser);
}

/*static*/ void TournClientThin::TournExtraSubscr_Prize_Prize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 min; _parser.parseINT32(min);
	AtfValidator::validateInt(_descr, "min", min, _checker, __FILE__, __LINE__);
	INT32 max; _parser.parseINT32(max);
	AtfValidator::validateInt(_descr, "max", max, _checker, __FILE__, __LINE__);
	INT32 numTickets; _parser.parseINT32(numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szWinners = ThinAtf::LAtfVector< TournExtraSubscr_Prize_Winner, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("winners"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "winners", szWinners, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Static
//=================================================================

//=================================================================
//                _BountiesType
//=================================================================

TournClientThin::publication::TournSubscr_Static::_BountiesType::_BountiesType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_Static::_BountiesType::_BountiesType(_BountiesType&& _o)
	: teamProBounties(std::move(_o.teamProBounties))
	, bountyMultipliers(std::move(_o.bountyMultipliers))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TournClientThin::publication::TournSubscr_Static::_BountiesType& TournClientThin::publication::TournSubscr_Static::_BountiesType::operator=(_BountiesType&& _o)
{
	if(this != &_o)
	{
		teamProBounties = std::move(_o.teamProBounties);
		bountyMultipliers = std::move(_o.bountyMultipliers);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_Static::_BountiesType::clear()
{
	teamProBounties.clear();
	bountyMultipliers.clear();
	_is_empty_internal = true;
}

bool TournClientThin::publication::TournSubscr_Static::_BountiesType::equals(const _BountiesType& _o) const
{
	return teamProBounties.equals(_o.teamProBounties) &&
		bountyMultipliers.equals(_o.bountyMultipliers);
}

const char *TournClientThin::publication::TournSubscr_Static::_BountiesType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("teamProBounties=");
		teamProBounties.toTraceString(_buf);
		_buf.append(',');
		_buf.append("bountyMultipliers=");
		bountyMultipliers.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Static::_BountiesType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		teamProBounties.composeMsg(_msg0);
		bountyMultipliers.composeMsg(_msg0);
	}

	_msg.composeMsgBody(_msg0);
}

void TournClientThin::publication::TournSubscr_Static::_BountiesType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	teamProBounties.parseMsg(_parser0);
	bountyMultipliers.parseMsg(_parser0);
}

/*static*/ void TournClientThin::publication::TournSubscr_Static::_BountiesType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szTeamProBounties = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("teamProBounties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "teamProBounties", szTeamProBounties, _checker, __FILE__, __LINE__);
	int szBountyMultipliers = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("bountyMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "bountyMultipliers", szBountyMultipliers, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

TournClientThin::publication::TournSubscr_Static::TournSubscr_Static()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_Static::TournSubscr_Static(TournSubscr_Static&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, startingChips(std::move(_o.startingChips))
	, maxPlayers(std::move(_o.maxPlayers))
	, playersPerTable(std::move(_o.playersPerTable))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, startingTime(std::move(_o.startingTime))
	, registrationStarts(std::move(_o.registrationStarts))
	, registrationEnds(std::move(_o.registrationEnds))
	, seatingStarts(std::move(_o.seatingStarts))
	, minPlayers(std::move(_o.minPlayers))
	, restricted(std::move(_o.restricted))
	, fppReward(std::move(_o.fppReward))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, name(std::move(_o.name))
	, numRebuys(std::move(_o.numRebuys))
	, rebuyChips(std::move(_o.rebuyChips))
	, _obsolete_1(std::move(_o._obsolete_1))
	, rebuyMaxChips(std::move(_o.rebuyMaxChips))
	, numAddOns(std::move(_o.numAddOns))
	, addOnChips(std::move(_o.addOnChips))
	, _obsolete_2(std::move(_o._obsolete_2))
	, addOnMaxChips(std::move(_o.addOnMaxChips))
	, scriptPrizeAddOn(std::move(_o.scriptPrizeAddOn))
	, guaranteedPrizePool(std::move(_o.guaranteedPrizePool))
	, tournFlags(std::move(_o.tournFlags))
	, maxAllIns(std::move(_o.maxAllIns))
	, awardSchema(std::move(_o.awardSchema))
	, timeBank(std::move(_o.timeBank))
	, unregistrationEnds_t(std::move(_o.unregistrationEnds_t))
	, satelliteTarget(std::move(_o.satelliteTarget))
	, satelliteTargetBuyIn(std::move(_o.satelliteTargetBuyIn))
	, rebuyFppPrice(std::move(_o.rebuyFppPrice))
	, addonFppPrice(std::move(_o.addonFppPrice))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, startingTime_t(std::move(_o.startingTime_t))
	, registrationStarts_t(std::move(_o.registrationStarts_t))
	, registrationEnds_t(std::move(_o.registrationEnds_t))
	, seatingStarts_t(std::move(_o.seatingStarts_t))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, tournProp2(std::move(_o.tournProp2))
	, ticketTypes(std::move(_o.ticketTypes))
	, tableLogo(std::move(_o.tableLogo))
	, finalTableText(std::move(_o.finalTableText))
	, chatLang(std::move(_o.chatLang))
	, lobbyRestricted(std::move(_o.lobbyRestricted))
	, fppFraction(std::move(_o.fppFraction))
	, currency(std::move(_o.currency))
	, rebuyFppReward(std::move(_o.rebuyFppReward))
	, addOnFppReward(std::move(_o.addOnFppReward))
	, fppRewardPercent(std::move(_o.fppRewardPercent))
	, nPublishLobbyPlayersLess(std::move(_o.nPublishLobbyPlayersLess))
	, bounty(std::move(_o.bounty))
	, placeHolder(std::move(_o.placeHolder))
	, bounties(std::move(_o.bounties))
	, publPropFlag(std::move(_o.publPropFlag))
	, multiday(std::move(_o.multiday))
	, satelliteTargetReference(std::move(_o.satelliteTargetReference))
	, satelliteTargetReferenceLock(std::move(_o.satelliteTargetReferenceLock))
	, clubId(std::move(_o.clubId))
	, timedTournType(std::move(_o.timedTournType))
	, timedTournLevelsOrMinutes(std::move(_o.timedTournLevelsOrMinutes))
	, timedTournPayoutStructure(std::move(_o.timedTournPayoutStructure))
	, _obsolete_3(std::move(_o._obsolete_3))
	, vppToPublish(std::move(_o.vppToPublish))
	, speedDisplay(std::move(_o.speedDisplay))
	, tournBrand(std::move(_o.tournBrand))
	, scalePM(std::move(_o.scalePM))
	, blitzNormalDealingThreshold(std::move(_o.blitzNormalDealingThreshold))
	, _obsolete_4(std::move(_o._obsolete_4))
	, progressiveKnockout(std::move(_o.progressiveKnockout))
	, tableText(std::move(_o.tableText))
	, reEntryAllowed(std::move(_o.reEntryAllowed))
	, tournMask(std::move(_o.tournMask))
	, tournMask2(std::move(_o.tournMask2))
	, tournMask3(std::move(_o.tournMask3))
	, tournMask4(std::move(_o.tournMask4))
	, internalReference(std::move(_o.internalReference))
	, favoriteReference(std::move(_o.favoriteReference))
	, ticketPrice(std::move(_o.ticketPrice))
	, tournFlags2(std::move(_o.tournFlags2))
	, cannotUnregisterFromTarget(std::move(_o.cannotUnregisterFromTarget))
	, nStackInfoMsg(std::move(_o.nStackInfoMsg))
	, targetWhenStarts(std::move(_o.targetWhenStarts))
	, admission(std::move(_o.admission))
	, siteMask(std::move(_o.siteMask))
	, publStartLevel(std::move(_o.publStartLevel))
	, tournMask5(std::move(_o.tournMask5))
	, tournMask6(std::move(_o.tournMask6))
	, dealExclusionType(std::move(_o.dealExclusionType))
	, dealExclusionValue(std::move(_o.dealExclusionValue))
	, timedTournPlayersPercent(std::move(_o.timedTournPlayersPercent))
	, _obsolete_5(std::move(_o._obsolete_5))
	, spinGoStartDelay(std::move(_o.spinGoStartDelay))
	, rmPmLobby(std::move(_o.rmPmLobby))
	, brandMask(std::move(_o.brandMask))
	, playerKnockOutAddOn(std::move(_o.playerKnockOutAddOn))
	, totalKnockOutAddOn(std::move(_o.totalKnockOutAddOn))
	, knockOutAddOnProgressive(std::move(_o.knockOutAddOnProgressive))
	, sitGoStarterGameId(std::move(_o.sitGoStarterGameId))
	, numStandardButton(std::move(_o.numStandardButton))
	, lateRegDelta(std::move(_o.lateRegDelta))
	, finalTablePlusOne(std::move(_o.finalTablePlusOne))
	, multidayIndex(std::move(_o.multidayIndex))
	, multiDayVec(std::move(_o.multiDayVec))
	, criteria(std::move(_o.criteria))
	, groupReference(std::move(_o.groupReference))
	, tournGroup(std::move(_o.tournGroup))
	, prizePool(std::move(_o.prizePool))
	, admissions(std::move(_o.admissions))
	, pokerNgGroup(std::move(_o.pokerNgGroup))
	, siteMaskEx(std::move(_o.siteMaskEx))
	, pppId(std::move(_o.pppId))
	, tableTrait(std::move(_o.tableTrait))
	, highlightColor(std::move(_o.highlightColor))
{
}

TournClientThin::publication::TournSubscr_Static& TournClientThin::publication::TournSubscr_Static::operator=(TournSubscr_Static&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		startingChips = std::move(_o.startingChips);
		maxPlayers = std::move(_o.maxPlayers);
		playersPerTable = std::move(_o.playersPerTable);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		startingTime = std::move(_o.startingTime);
		registrationStarts = std::move(_o.registrationStarts);
		registrationEnds = std::move(_o.registrationEnds);
		seatingStarts = std::move(_o.seatingStarts);
		minPlayers = std::move(_o.minPlayers);
		restricted = std::move(_o.restricted);
		fppReward = std::move(_o.fppReward);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPwdProtected = std::move(_o.isPwdProtected);
		name = std::move(_o.name);
		numRebuys = std::move(_o.numRebuys);
		rebuyChips = std::move(_o.rebuyChips);
		_obsolete_1 = std::move(_o._obsolete_1);
		rebuyMaxChips = std::move(_o.rebuyMaxChips);
		numAddOns = std::move(_o.numAddOns);
		addOnChips = std::move(_o.addOnChips);
		_obsolete_2 = std::move(_o._obsolete_2);
		addOnMaxChips = std::move(_o.addOnMaxChips);
		scriptPrizeAddOn = std::move(_o.scriptPrizeAddOn);
		guaranteedPrizePool = std::move(_o.guaranteedPrizePool);
		tournFlags = std::move(_o.tournFlags);
		maxAllIns = std::move(_o.maxAllIns);
		awardSchema = std::move(_o.awardSchema);
		timeBank = std::move(_o.timeBank);
		unregistrationEnds_t = std::move(_o.unregistrationEnds_t);
		satelliteTarget = std::move(_o.satelliteTarget);
		satelliteTargetBuyIn = std::move(_o.satelliteTargetBuyIn);
		rebuyFppPrice = std::move(_o.rebuyFppPrice);
		addonFppPrice = std::move(_o.addonFppPrice);
		isPlayMoney = std::move(_o.isPlayMoney);
		startingTime_t = std::move(_o.startingTime_t);
		registrationStarts_t = std::move(_o.registrationStarts_t);
		registrationEnds_t = std::move(_o.registrationEnds_t);
		seatingStarts_t = std::move(_o.seatingStarts_t);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		tournProp2 = std::move(_o.tournProp2);
		ticketTypes = std::move(_o.ticketTypes);
		tableLogo = std::move(_o.tableLogo);
		finalTableText = std::move(_o.finalTableText);
		chatLang = std::move(_o.chatLang);
		lobbyRestricted = std::move(_o.lobbyRestricted);
		fppFraction = std::move(_o.fppFraction);
		currency = std::move(_o.currency);
		rebuyFppReward = std::move(_o.rebuyFppReward);
		addOnFppReward = std::move(_o.addOnFppReward);
		fppRewardPercent = std::move(_o.fppRewardPercent);
		nPublishLobbyPlayersLess = std::move(_o.nPublishLobbyPlayersLess);
		bounty = std::move(_o.bounty);
		placeHolder = std::move(_o.placeHolder);
		bounties = std::move(_o.bounties);
		publPropFlag = std::move(_o.publPropFlag);
		multiday = std::move(_o.multiday);
		satelliteTargetReference = std::move(_o.satelliteTargetReference);
		satelliteTargetReferenceLock = std::move(_o.satelliteTargetReferenceLock);
		clubId = std::move(_o.clubId);
		timedTournType = std::move(_o.timedTournType);
		timedTournLevelsOrMinutes = std::move(_o.timedTournLevelsOrMinutes);
		timedTournPayoutStructure = std::move(_o.timedTournPayoutStructure);
		_obsolete_3 = std::move(_o._obsolete_3);
		vppToPublish = std::move(_o.vppToPublish);
		speedDisplay = std::move(_o.speedDisplay);
		tournBrand = std::move(_o.tournBrand);
		scalePM = std::move(_o.scalePM);
		blitzNormalDealingThreshold = std::move(_o.blitzNormalDealingThreshold);
		_obsolete_4 = std::move(_o._obsolete_4);
		progressiveKnockout = std::move(_o.progressiveKnockout);
		tableText = std::move(_o.tableText);
		reEntryAllowed = std::move(_o.reEntryAllowed);
		tournMask = std::move(_o.tournMask);
		tournMask2 = std::move(_o.tournMask2);
		tournMask3 = std::move(_o.tournMask3);
		tournMask4 = std::move(_o.tournMask4);
		internalReference = std::move(_o.internalReference);
		favoriteReference = std::move(_o.favoriteReference);
		ticketPrice = std::move(_o.ticketPrice);
		tournFlags2 = std::move(_o.tournFlags2);
		cannotUnregisterFromTarget = std::move(_o.cannotUnregisterFromTarget);
		nStackInfoMsg = std::move(_o.nStackInfoMsg);
		targetWhenStarts = std::move(_o.targetWhenStarts);
		admission = std::move(_o.admission);
		siteMask = std::move(_o.siteMask);
		publStartLevel = std::move(_o.publStartLevel);
		tournMask5 = std::move(_o.tournMask5);
		tournMask6 = std::move(_o.tournMask6);
		dealExclusionType = std::move(_o.dealExclusionType);
		dealExclusionValue = std::move(_o.dealExclusionValue);
		timedTournPlayersPercent = std::move(_o.timedTournPlayersPercent);
		_obsolete_5 = std::move(_o._obsolete_5);
		spinGoStartDelay = std::move(_o.spinGoStartDelay);
		rmPmLobby = std::move(_o.rmPmLobby);
		brandMask = std::move(_o.brandMask);
		playerKnockOutAddOn = std::move(_o.playerKnockOutAddOn);
		totalKnockOutAddOn = std::move(_o.totalKnockOutAddOn);
		knockOutAddOnProgressive = std::move(_o.knockOutAddOnProgressive);
		sitGoStarterGameId = std::move(_o.sitGoStarterGameId);
		numStandardButton = std::move(_o.numStandardButton);
		lateRegDelta = std::move(_o.lateRegDelta);
		finalTablePlusOne = std::move(_o.finalTablePlusOne);
		multidayIndex = std::move(_o.multidayIndex);
		multiDayVec = std::move(_o.multiDayVec);
		criteria = std::move(_o.criteria);
		groupReference = std::move(_o.groupReference);
		tournGroup = std::move(_o.tournGroup);
		prizePool = std::move(_o.prizePool);
		admissions = std::move(_o.admissions);
		pokerNgGroup = std::move(_o.pokerNgGroup);
		siteMaskEx = std::move(_o.siteMaskEx);
		pppId = std::move(_o.pppId);
		tableTrait = std::move(_o.tableTrait);
		highlightColor = std::move(_o.highlightColor);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_Static::clear()
{
	tournamentId = 0;
	buyIn = 0;
	rake = 0;
	startingChips = 0;
	maxPlayers = 0;
	playersPerTable = 0;
	gameType = 0;
	isHiLo = 0;
	startingTime.setNull();
	registrationStarts.setNull();
	registrationEnds.setNull();
	seatingStarts.setNull();
	minPlayers = 0;
	restricted = 0;
	fppReward = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPwdProtected = 0;
	name.clear();
	numRebuys = 0;
	rebuyChips = 0;
	_obsolete_1 = 0;
	rebuyMaxChips = 0;
	numAddOns = 0;
	addOnChips = 0;
	_obsolete_2 = 0;
	addOnMaxChips = 0;
	scriptPrizeAddOn = 0;
	guaranteedPrizePool = 0;
	tournFlags = 0;
	maxAllIns = 0;
	awardSchema = 0;
	timeBank = 0;
	unregistrationEnds_t = 0;
	satelliteTarget = 0;
	satelliteTargetBuyIn = 0;
	rebuyFppPrice = 0;
	addonFppPrice = 0;
	isPlayMoney = 0;
	startingTime_t = 0;
	registrationStarts_t = 0;
	registrationEnds_t = 0;
	seatingStarts_t = 0;
	tournFlagsServInt = 0;
	tournProp2 = 0;
	ticketTypes.clear();
	tableLogo = 0;
	finalTableText.clear();
	chatLang = 0;
	lobbyRestricted = 0;
	fppFraction = 0;
	currency.clear();
	rebuyFppReward = 0;
	addOnFppReward = 0;
	fppRewardPercent = 0;
	nPublishLobbyPlayersLess = 0;
	bounty = 0;
	placeHolder = 0;
	bounties.clear();
	publPropFlag = 0;
	multiday.clear();
	satelliteTargetReference.clear();
	satelliteTargetReferenceLock = 0;
	clubId = 0;
	timedTournType = 0;
	timedTournLevelsOrMinutes = 0;
	timedTournPayoutStructure = 0;
	_obsolete_3 = false;
	vppToPublish.clear();
	speedDisplay = 0;
	tournBrand.clear();
	scalePM = 0;
	blitzNormalDealingThreshold = 0;
	_obsolete_4 = false;
	progressiveKnockout = 0;
	tableText.clear();
	reEntryAllowed = 0;
	tournMask = 0;
	tournMask2 = 0;
	tournMask3 = 0;
	tournMask4 = 0;
	internalReference.clear();
	favoriteReference.clear();
	ticketPrice = 0;
	tournFlags2 = 0;
	cannotUnregisterFromTarget = false;
	nStackInfoMsg.clear();
	targetWhenStarts.setNull();
	admission.clear();
	siteMask = 0;
	publStartLevel = 0;
	tournMask5 = 0;
	tournMask6 = 0;
	dealExclusionType = 0;
	dealExclusionValue = 0;
	timedTournPlayersPercent = 0;
	_obsolete_5 = 0;
	spinGoStartDelay = 0;
	rmPmLobby = 0;
	brandMask = 0;
	playerKnockOutAddOn = 0;
	totalKnockOutAddOn = 0;
	knockOutAddOnProgressive = 0;
	sitGoStarterGameId = 0;
	numStandardButton = 0;
	lateRegDelta = 0;
	finalTablePlusOne = 0;
	multidayIndex = 0;
	multiDayVec.clear();
	criteria.clear();
	groupReference.clear();
	tournGroup = 0;
	prizePool = 0;
	admissions.clear();
	pokerNgGroup.clear();
	siteMaskEx.clear();
	pppId = 0;
	tableTrait.clear();
	highlightColor.clear();
}

bool TournClientThin::publication::TournSubscr_Static::equals(const TournSubscr_Static& _o) const
{
	return tournamentId == _o.tournamentId &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		startingChips == _o.startingChips &&
		maxPlayers == _o.maxPlayers &&
		playersPerTable == _o.playersPerTable &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		startingTime.equals(_o.startingTime) &&
		registrationStarts.equals(_o.registrationStarts) &&
		registrationEnds.equals(_o.registrationEnds) &&
		seatingStarts.equals(_o.seatingStarts) &&
		minPlayers == _o.minPlayers &&
		restricted == _o.restricted &&
		fppReward == _o.fppReward &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPwdProtected == _o.isPwdProtected &&
		name.equals(_o.name) &&
		numRebuys == _o.numRebuys &&
		rebuyChips == _o.rebuyChips &&
		_obsolete_1 == _o._obsolete_1 &&
		rebuyMaxChips == _o.rebuyMaxChips &&
		numAddOns == _o.numAddOns &&
		addOnChips == _o.addOnChips &&
		_obsolete_2 == _o._obsolete_2 &&
		addOnMaxChips == _o.addOnMaxChips &&
		scriptPrizeAddOn == _o.scriptPrizeAddOn &&
		guaranteedPrizePool == _o.guaranteedPrizePool &&
		tournFlags == _o.tournFlags &&
		maxAllIns == _o.maxAllIns &&
		awardSchema == _o.awardSchema &&
		timeBank == _o.timeBank &&
		unregistrationEnds_t == _o.unregistrationEnds_t &&
		satelliteTarget == _o.satelliteTarget &&
		satelliteTargetBuyIn == _o.satelliteTargetBuyIn &&
		rebuyFppPrice == _o.rebuyFppPrice &&
		addonFppPrice == _o.addonFppPrice &&
		isPlayMoney == _o.isPlayMoney &&
		startingTime_t == _o.startingTime_t &&
		registrationStarts_t == _o.registrationStarts_t &&
		registrationEnds_t == _o.registrationEnds_t &&
		seatingStarts_t == _o.seatingStarts_t &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		tournProp2 == _o.tournProp2 &&
		ticketTypes.equals(_o.ticketTypes) &&
		tableLogo == _o.tableLogo &&
		finalTableText.equals(_o.finalTableText) &&
		chatLang == _o.chatLang &&
		lobbyRestricted == _o.lobbyRestricted &&
		fppFraction == _o.fppFraction &&
		currency.equals(_o.currency) &&
		rebuyFppReward == _o.rebuyFppReward &&
		addOnFppReward == _o.addOnFppReward &&
		fppRewardPercent == _o.fppRewardPercent &&
		nPublishLobbyPlayersLess == _o.nPublishLobbyPlayersLess &&
		bounty == _o.bounty &&
		placeHolder == _o.placeHolder &&
		bounties.equals(_o.bounties) &&
		publPropFlag == _o.publPropFlag &&
		multiday.equals(_o.multiday) &&
		satelliteTargetReference.equals(_o.satelliteTargetReference) &&
		satelliteTargetReferenceLock == _o.satelliteTargetReferenceLock &&
		clubId == _o.clubId &&
		timedTournType == _o.timedTournType &&
		timedTournLevelsOrMinutes == _o.timedTournLevelsOrMinutes &&
		timedTournPayoutStructure == _o.timedTournPayoutStructure &&
		_obsolete_3 == _o._obsolete_3 &&
		vppToPublish.equals(_o.vppToPublish) &&
		speedDisplay == _o.speedDisplay &&
		tournBrand.equals(_o.tournBrand) &&
		scalePM == _o.scalePM &&
		blitzNormalDealingThreshold == _o.blitzNormalDealingThreshold &&
		_obsolete_4 == _o._obsolete_4 &&
		progressiveKnockout == _o.progressiveKnockout &&
		tableText.equals(_o.tableText) &&
		reEntryAllowed == _o.reEntryAllowed &&
		tournMask == _o.tournMask &&
		tournMask2 == _o.tournMask2 &&
		tournMask3 == _o.tournMask3 &&
		tournMask4 == _o.tournMask4 &&
		internalReference.equals(_o.internalReference) &&
		favoriteReference.equals(_o.favoriteReference) &&
		ticketPrice == _o.ticketPrice &&
		tournFlags2 == _o.tournFlags2 &&
		cannotUnregisterFromTarget == _o.cannotUnregisterFromTarget &&
		nStackInfoMsg.equals(_o.nStackInfoMsg) &&
		targetWhenStarts.equals(_o.targetWhenStarts) &&
		admission.equals(_o.admission) &&
		siteMask == _o.siteMask &&
		publStartLevel == _o.publStartLevel &&
		tournMask5 == _o.tournMask5 &&
		tournMask6 == _o.tournMask6 &&
		dealExclusionType == _o.dealExclusionType &&
		dealExclusionValue == _o.dealExclusionValue &&
		timedTournPlayersPercent == _o.timedTournPlayersPercent &&
		_obsolete_5 == _o._obsolete_5 &&
		spinGoStartDelay == _o.spinGoStartDelay &&
		rmPmLobby == _o.rmPmLobby &&
		brandMask == _o.brandMask &&
		playerKnockOutAddOn == _o.playerKnockOutAddOn &&
		totalKnockOutAddOn == _o.totalKnockOutAddOn &&
		knockOutAddOnProgressive == _o.knockOutAddOnProgressive &&
		sitGoStarterGameId == _o.sitGoStarterGameId &&
		numStandardButton == _o.numStandardButton &&
		lateRegDelta == _o.lateRegDelta &&
		finalTablePlusOne == _o.finalTablePlusOne &&
		multidayIndex == _o.multidayIndex &&
		multiDayVec.equals(_o.multiDayVec) &&
		criteria.equals(_o.criteria) &&
		groupReference.equals(_o.groupReference) &&
		tournGroup == _o.tournGroup &&
		prizePool == _o.prizePool &&
		admissions.equals(_o.admissions) &&
		pokerNgGroup.equals(_o.pokerNgGroup) &&
		siteMaskEx.equals(_o.siteMaskEx) &&
		pppId == _o.pppId &&
		tableTrait.equals(_o.tableTrait) &&
		highlightColor.equals(_o.highlightColor);
}

const char *TournClientThin::publication::TournSubscr_Static::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt(rake);
	_buf.append(',');
	_buf.append("startingChips=");
	_buf.appendInt(startingChips);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendInt(maxPlayers);
	_buf.append(',');
	_buf.append("playersPerTable=");
	_buf.appendInt(playersPerTable);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("startingTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startingTime);
	_buf.append(',');
	_buf.append("registrationStarts=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, registrationStarts);
	_buf.append(',');
	_buf.append("registrationEnds=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, registrationEnds);
	_buf.append(',');
	_buf.append("seatingStarts=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, seatingStarts);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendInt(minPlayers);
	_buf.append(',');
	_buf.append("restricted=");
	_buf.appendUint(restricted);
	_buf.append(',');
	_buf.append("fppReward=");
	_buf.appendInt(fppReward);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendInt(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPwdProtected=");
	_buf.appendUint(isPwdProtected);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("numRebuys=");
	_buf.appendInt(numRebuys);
	_buf.append(',');
	_buf.append("rebuyChips=");
	_buf.appendInt(rebuyChips);
	_buf.append(',');
	_buf.append("_obsolete_1=");
	_buf.appendInt(_obsolete_1);
	_buf.append(',');
	_buf.append("rebuyMaxChips=");
	_buf.appendInt(rebuyMaxChips);
	_buf.append(',');
	_buf.append("numAddOns=");
	_buf.appendInt(numAddOns);
	_buf.append(',');
	_buf.append("addOnChips=");
	_buf.appendInt(addOnChips);
	_buf.append(',');
	_buf.append("_obsolete_2=");
	_buf.appendInt(_obsolete_2);
	_buf.append(',');
	_buf.append("addOnMaxChips=");
	_buf.appendInt(addOnMaxChips);
	_buf.append(',');
	_buf.append("scriptPrizeAddOn=");
	_buf.appendInt(scriptPrizeAddOn);
	_buf.append(',');
	_buf.append("guaranteedPrizePool=");
	_buf.appendInt(guaranteedPrizePool);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("maxAllIns=");
	_buf.appendInt(maxAllIns);
	_buf.append(',');
	_buf.append("awardSchema=");
	_buf.appendUint(awardSchema);
	_buf.append(',');
	_buf.append("timeBank=");
	_buf.appendUint(timeBank);
	_buf.append(',');
	_buf.append("unregistrationEnds_t=");
	_buf.appendInt(unregistrationEnds_t);
	_buf.append(',');
	_buf.append("satelliteTarget=");
	_buf.appendUint(satelliteTarget);
	_buf.append(',');
	_buf.append("satelliteTargetBuyIn=");
	_buf.appendInt(satelliteTargetBuyIn);
	_buf.append(',');
	_buf.append("rebuyFppPrice=");
	_buf.appendInt(rebuyFppPrice);
	_buf.append(',');
	_buf.append("addonFppPrice=");
	_buf.appendInt(addonFppPrice);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("startingTime_t=");
	_buf.appendUint(startingTime_t);
	_buf.append(',');
	_buf.append("registrationStarts_t=");
	_buf.appendUint(registrationStarts_t);
	_buf.append(',');
	_buf.append("registrationEnds_t=");
	_buf.appendUint(registrationEnds_t);
	_buf.append(',');
	_buf.append("seatingStarts_t=");
	_buf.appendUint(seatingStarts_t);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("tournProp2=");
	_buf.appendUint(tournProp2);
	_buf.append(',');
	_buf.append("ticketTypes=");
	ticketTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableLogo=");
	_buf.appendUint(tableLogo);
	_buf.append(',');
	_buf.append("finalTableText=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, finalTableText);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("lobbyRestricted=");
	_buf.appendUint(lobbyRestricted);
	_buf.append(',');
	_buf.append("fppFraction=");
	_buf.appendInt(fppFraction);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("rebuyFppReward=");
	_buf.appendInt(rebuyFppReward);
	_buf.append(',');
	_buf.append("addOnFppReward=");
	_buf.appendInt(addOnFppReward);
	_buf.append(',');
	_buf.append("fppRewardPercent=");
	_buf.appendInt(fppRewardPercent);
	_buf.append(',');
	_buf.append("nPublishLobbyPlayersLess=");
	_buf.appendUint(nPublishLobbyPlayersLess);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt(bounty);
	_buf.append(',');
	_buf.append("placeHolder=");
	_buf.appendUint(placeHolder);
	_buf.append(',');
	_buf.append("bounties=");
	bounties.toTraceString(_buf);
	_buf.append(',');
	_buf.append("publPropFlag=");
	_buf.appendUint(publPropFlag);
	_buf.append(',');
	_buf.append("multiday=");
	multiday.toTraceString(_buf);
	_buf.append(',');
	_buf.append("satelliteTargetReference=");
	_buf.append(satelliteTargetReference);
	_buf.append(',');
	_buf.append("satelliteTargetReferenceLock=");
	_buf.appendUint(satelliteTargetReferenceLock);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("timedTournType=");
	_buf.appendUint(timedTournType);
	_buf.append(',');
	_buf.append("timedTournLevelsOrMinutes=");
	_buf.appendUint(timedTournLevelsOrMinutes);
	_buf.append(',');
	_buf.append("timedTournPayoutStructure=");
	_buf.appendUint(timedTournPayoutStructure);
	_buf.append(',');
	_buf.append("_obsolete_3=");
	_buf.appendUint(_obsolete_3);
	_buf.append(',');
	_buf.append("vppToPublish=");
	vppToPublish.toTraceString(_buf);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("tournBrand=");
	_buf.append(tournBrand);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append(',');
	_buf.append("blitzNormalDealingThreshold=");
	_buf.appendUint(blitzNormalDealingThreshold);
	_buf.append(',');
	_buf.append("_obsolete_4=");
	_buf.appendUint(_obsolete_4);
	_buf.append(',');
	_buf.append("progressiveKnockout=");
	_buf.appendUint(progressiveKnockout);
	_buf.append(',');
	_buf.append("tableText=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, tableText);
	_buf.append(',');
	_buf.append("reEntryAllowed=");
	_buf.appendUint(reEntryAllowed);
	_buf.append(',');
	_buf.append("tournMask=");
	_buf.appendUint(tournMask);
	_buf.append(',');
	_buf.append("tournMask2=");
	_buf.appendUint(tournMask2);
	_buf.append(',');
	_buf.append("tournMask3=");
	_buf.appendUint(tournMask3);
	_buf.append(',');
	_buf.append("tournMask4=");
	_buf.appendUint(tournMask4);
	_buf.append(',');
	_buf.append("internalReference=");
	_buf.append(internalReference);
	_buf.append(',');
	_buf.append("favoriteReference=");
	_buf.append(favoriteReference);
	_buf.append(',');
	_buf.append("ticketPrice=");
	_buf.appendInt64(ticketPrice);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("cannotUnregisterFromTarget=");
	_buf.appendUint(cannotUnregisterFromTarget);
	_buf.append(',');
	_buf.append("nStackInfoMsg=");
	nStackInfoMsg.toTraceString(_buf);
	_buf.append(',');
	_buf.append("targetWhenStarts=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, targetWhenStarts);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("publStartLevel=");
	_buf.appendUint(publStartLevel);
	_buf.append(',');
	_buf.append("tournMask5=");
	_buf.appendUint(tournMask5);
	_buf.append(',');
	_buf.append("tournMask6=");
	_buf.appendUint(tournMask6);
	_buf.append(',');
	_buf.append("dealExclusionType=");
	_buf.appendUint(dealExclusionType);
	_buf.append(',');
	_buf.append("dealExclusionValue=");
	_buf.appendInt(dealExclusionValue);
	_buf.append(',');
	_buf.append("timedTournPlayersPercent=");
	_buf.appendUint(timedTournPlayersPercent);
	_buf.append(',');
	_buf.append("_obsolete_5=");
	_buf.appendInt(_obsolete_5);
	_buf.append(',');
	_buf.append("spinGoStartDelay=");
	_buf.appendInt(spinGoStartDelay);
	_buf.append(',');
	_buf.append("rmPmLobby=");
	_buf.appendUint(rmPmLobby);
	_buf.append(',');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("playerKnockOutAddOn=");
	_buf.appendInt(playerKnockOutAddOn);
	_buf.append(',');
	_buf.append("totalKnockOutAddOn=");
	_buf.appendInt(totalKnockOutAddOn);
	_buf.append(',');
	_buf.append("knockOutAddOnProgressive=");
	_buf.appendUint(knockOutAddOnProgressive);
	_buf.append(',');
	_buf.append("sitGoStarterGameId=");
	_buf.appendUint(sitGoStarterGameId);
	_buf.append(',');
	_buf.append("numStandardButton=");
	_buf.appendUint(numStandardButton);
	_buf.append(',');
	_buf.append("lateRegDelta=");
	_buf.appendInt(lateRegDelta);
	_buf.append(',');
	_buf.append("finalTablePlusOne=");
	_buf.appendInt(finalTablePlusOne);
	_buf.append(',');
	_buf.append("multidayIndex=");
	_buf.appendInt(multidayIndex);
	_buf.append(',');
	_buf.append("multiDayVec=");
	multiDayVec.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("groupReference=");
	_buf.append(groupReference);
	_buf.append(',');
	_buf.append("tournGroup=");
	_buf.appendInt(tournGroup);
	_buf.append(',');
	_buf.append("prizePool=");
	_buf.appendInt(prizePool);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pokerNgGroup=");
	_buf.append(pokerNgGroup);
	_buf.append(',');
	_buf.append("siteMaskEx=");
	siteMaskEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("tableTrait=");
	_buf.append(tableTrait);
	_buf.append(',');
	_buf.append("highlightColor=");
	_buf.append(highlightColor);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Static::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeINT32(buyIn);
	_msg.composeINT32(rake);
	_msg.composeINT32(startingChips);
	_msg.composeINT32(maxPlayers);
	_msg.composeINT32(playersPerTable);
	_msg.composeBYTE(gameType);
	_msg.composeBYTE(isHiLo);
	_msg.composeSrvTime(startingTime);
	_msg.composeSrvTime(registrationStarts);
	_msg.composeSrvTime(registrationEnds);
	_msg.composeSrvTime(seatingStarts);
	_msg.composeINT32(minPlayers);
	_msg.composeBYTE(restricted);
	_msg.composeINT32(fppReward);
	_msg.composeINT32(fppBuyIn);
	_msg.composeBYTE(isRestricted);
	_msg.composeBYTE(isPwdProtected);
	_msg.composeString(name);
	_msg.composeINT32(numRebuys);
	_msg.composeINT32(rebuyChips);
	_msg.composeINT32(_obsolete_1);
	_msg.composeINT32(rebuyMaxChips);
	_msg.composeINT32(numAddOns);
	_msg.composeINT32(addOnChips);
	_msg.composeINT32(_obsolete_2);
	_msg.composeINT32(addOnMaxChips);
	_msg.composeINT32(scriptPrizeAddOn);
	_msg.composeINT32(guaranteedPrizePool);
	_msg.composeUINT32(tournFlags);
	_msg.composeINT16(maxAllIns);
	_msg.composeBYTE(awardSchema);
	_msg.composeUINT32(timeBank);
	_msg.composeINT32(unregistrationEnds_t);
	_msg.composeUINT32(satelliteTarget);
	_msg.composeINT32(satelliteTargetBuyIn);
	_msg.composeINT32(rebuyFppPrice);
	_msg.composeINT32(addonFppPrice);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeUINT32(startingTime_t);
	_msg.composeUINT32(registrationStarts_t);
	_msg.composeUINT32(registrationEnds_t);
	_msg.composeUINT32(seatingStarts_t);
	_msg.composeUINT32(tournFlagsServInt);
	_msg.composeUINT32(tournProp2);
	ticketTypes.composeMsg(_msg);
	_msg.composeUINT32(tableLogo);
	finalTableText.compose(_msg);
	_msg.composeUINT16(chatLang);
	_msg.composeUINT32(lobbyRestricted);
	_msg.composeINT32(fppFraction);
	_msg.composeString(currency);
	_msg.composeINT32(rebuyFppReward);
	_msg.composeINT32(addOnFppReward);
	_msg.composeINT8(fppRewardPercent);
	_msg.composeUINT32(nPublishLobbyPlayersLess);
	_msg.composeINT32(bounty);
	_msg.composeUINT32(placeHolder);
	bounties.composeMsg(_msg);
	_msg.composeBYTE(publPropFlag);
	multiday.composeMsg(_msg);
	_msg.composeString(satelliteTargetReference);
	_msg.composeUINT16(satelliteTargetReferenceLock);
	_msg.composeUINT32(clubId);
	_msg.composeBYTE(timedTournType);
	_msg.composeUINT16(timedTournLevelsOrMinutes);
	_msg.composeBYTE(timedTournPayoutStructure);
	_msg.composeBOOL(_obsolete_3);
	vppToPublish.composeMsg(_msg);
	_msg.composeBYTE(speedDisplay);
	_msg.composeString(tournBrand);
	_msg.composeINT32(scalePM);
	_msg.composeUINT32(blitzNormalDealingThreshold);
	_msg.composeBOOL(_obsolete_4);
	_msg.composeBYTE(progressiveKnockout);
	tableText.compose(_msg);
	_msg.composeUINT16(reEntryAllowed);
	_msg.composeUINT32(tournMask);
	_msg.composeUINT32(tournMask2);
	_msg.composeUINT32(tournMask3);
	_msg.composeUINT32(tournMask4);
	_msg.composeString(internalReference);
	_msg.composeString(favoriteReference);
	_msg.composeINT64(ticketPrice);
	_msg.composeUINT64(tournFlags2);
	_msg.composeBOOL(cannotUnregisterFromTarget);
	CommMsgBody _msg0;
	nStackInfoMsg.composeMsg(_msg0);
	_msg.composeMsgBody(_msg0);
	_msg.composeSrvTime(targetWhenStarts);
	_msg.composeString(admission);
	_msg.composeUINT32(siteMask);
	_msg.composeUINT32(publStartLevel);
	_msg.composeUINT32(tournMask5);
	_msg.composeUINT32(tournMask6);
	_msg.composeBYTE(dealExclusionType);
	_msg.composeINT32(dealExclusionValue);
	_msg.composeBYTE(timedTournPlayersPercent);
	_msg.composeINT32(_obsolete_5);
	_msg.composeINT32(spinGoStartDelay);
	_msg.composeBYTE(rmPmLobby);
	_msg.composeUINT32(brandMask);
	_msg.composeINT32(playerKnockOutAddOn);
	_msg.composeINT32(totalKnockOutAddOn);
	_msg.composeBYTE(knockOutAddOnProgressive);
	_msg.composeUINT32(sitGoStarterGameId);
	_msg.composeUINT32(numStandardButton);
	_msg.composeINT32(lateRegDelta);
	_msg.composeINT32(finalTablePlusOne);
	_msg.composeINT32(multidayIndex);
	multiDayVec.composeMsg(_msg);
	_msg.composeString(criteria);
	_msg.composeString(groupReference);
	_msg.composeINT32(tournGroup);
	_msg.composeINT32(prizePool);
	admissions.composeMsg(_msg);
	_msg.composeString(pokerNgGroup);
	siteMaskEx.composeMsg(_msg);
	_msg.composeUINT32(pppId);
	_msg.composeString(tableTrait);
	_msg.composeString(highlightColor);
}

void TournClientThin::publication::TournSubscr_Static::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseINT32(buyIn);
	_parser.parseINT32(rake);
	_parser.parseINT32(startingChips);
	_parser.parseINT32(maxPlayers);
	_parser.parseINT32(playersPerTable);
	_parser.parseBYTE(gameType);
	_parser.parseBYTE(isHiLo);
	_parser.parseSrvTime(startingTime);
	_parser.parseSrvTime(registrationStarts);
	_parser.parseSrvTime(registrationEnds);
	_parser.parseSrvTime(seatingStarts);
	_parser.parseINT32(minPlayers);
	_parser.parseBYTE(restricted);
	_parser.parseINT32(fppReward);
	_parser.parseINT32(fppBuyIn);
	_parser.parseBYTE(isRestricted);
	_parser.parseBYTE(isPwdProtected);
	_parser.parseStringP(name);
	_parser.parseINT32(numRebuys);
	_parser.parseINT32(rebuyChips);
	_parser.parseINT32(_obsolete_1);
	_parser.parseINT32(rebuyMaxChips);
	_parser.parseINT32(numAddOns);
	_parser.parseINT32(addOnChips);
	_parser.parseINT32(_obsolete_2);
	_parser.parseINT32(addOnMaxChips);
	_parser.parseINT32(scriptPrizeAddOn);
	_parser.parseINT32(guaranteedPrizePool);
	_parser.parseUINT32(tournFlags);
	_parser.parseINT16(maxAllIns);
	_parser.parseBYTE(awardSchema);
	_parser.parseUINT32(timeBank);
	_parser.parseINT32(unregistrationEnds_t);
	_parser.parseUINT32(satelliteTarget);
	_parser.parseINT32(satelliteTargetBuyIn);
	_parser.parseINT32(rebuyFppPrice);
	_parser.parseINT32(addonFppPrice);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseUINT32(startingTime_t);
	_parser.parseUINT32(registrationStarts_t);
	_parser.parseUINT32(registrationEnds_t);
	_parser.parseUINT32(seatingStarts_t);
	_parser.parseUINT32(tournFlagsServInt);
	_parser.parseUINT32(tournProp2);
	ticketTypes.parseMsg(_parser);
	_parser.parseUINT32(tableLogo);
	finalTableText.parse(_parser);
	_parser.parseUINT16(chatLang);
	_parser.parseUINT32(lobbyRestricted);
	_parser.parseINT32(fppFraction);
	_parser.parseStringP(currency);
	_parser.parseINT32(rebuyFppReward);
	_parser.parseINT32(addOnFppReward);
	_parser.parseINT8(fppRewardPercent);
	_parser.parseUINT32(nPublishLobbyPlayersLess);
	_parser.parseINT32(bounty);
	_parser.parseUINT32(placeHolder);
	bounties.parseMsg(_parser);
	_parser.parseBYTE(publPropFlag);
	multiday.parseMsg(_parser);
	_parser.parseStringP(satelliteTargetReference);
	_parser.parseUINT16(satelliteTargetReferenceLock);
	_parser.parseUINT32(clubId);
	_parser.parseBYTE(timedTournType);
	_parser.parseUINT16(timedTournLevelsOrMinutes);
	_parser.parseBYTE(timedTournPayoutStructure);
	_parser.parseBOOL(_obsolete_3);
	vppToPublish.parseMsg(_parser);
	_parser.parseBYTE(speedDisplay);
	_parser.parseStringP(tournBrand);
	_parser.parseINT32(scalePM);
	_parser.parseUINT32(blitzNormalDealingThreshold);
	_parser.parseBOOL(_obsolete_4);
	_parser.parseBYTE(progressiveKnockout);
	tableText.parse(_parser);
	_parser.parseUINT16(reEntryAllowed);
	_parser.parseUINT32(tournMask);
	_parser.parseUINT32(tournMask2);
	_parser.parseUINT32(tournMask3);
	_parser.parseUINT32(tournMask4);
	_parser.parseStringP(internalReference);
	_parser.parseStringP(favoriteReference);
	_parser.parseINT64(ticketPrice);
	_parser.parseUINT64(tournFlags2);
	_parser.parseBOOL(cannotUnregisterFromTarget);
	parseAnonymousMsgBody0(_parser);
	_parser.parseSrvTime(targetWhenStarts);
	_parser.parseStringP(admission);
	_parser.parseUINT32(siteMask);
	_parser.parseUINT32(publStartLevel);
	_parser.parseUINT32(tournMask5);
	_parser.parseUINT32(tournMask6);
	_parser.parseBYTE(dealExclusionType);
	_parser.parseINT32(dealExclusionValue);
	_parser.parseBYTE(timedTournPlayersPercent);
	_parser.parseINT32(_obsolete_5);
	_parser.parseINT32(spinGoStartDelay);
	_parser.parseBYTE(rmPmLobby);
	_parser.parseUINT32(brandMask);
	_parser.parseINT32(playerKnockOutAddOn);
	_parser.parseINT32(totalKnockOutAddOn);
	_parser.parseBYTE(knockOutAddOnProgressive);
	_parser.parseUINT32(sitGoStarterGameId);
	_parser.parseUINT32(numStandardButton);
	_parser.parseINT32(lateRegDelta);
	_parser.parseINT32(finalTablePlusOne);
	_parser.parseINT32(multidayIndex);
	multiDayVec.parseMsg(_parser);
	_parser.parseStringP(criteria);
	_parser.parseStringP(groupReference);
	_parser.parseINT32(tournGroup);
	_parser.parseINT32(prizePool);
	admissions.parseMsg(_parser);
	_parser.parseStringP(pokerNgGroup);
	siteMaskEx.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(pppId);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(tableTrait);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(highlightColor);
}

/*static*/ void TournClientThin::publication::TournSubscr_Static::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT32 rake; _parser.parseINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	INT32 startingChips; _parser.parseINT32(startingChips);
	AtfValidator::validateInt(_descr, "startingChips", startingChips, _checker, __FILE__, __LINE__);
	INT32 maxPlayers; _parser.parseINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	INT32 playersPerTable; _parser.parseINT32(playersPerTable);
	AtfValidator::validateInt(_descr, "playersPerTable", playersPerTable, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	SrvTime startingTime; _parser.parseSrvTime(startingTime);
	AtfValidator::validateSrvDateTime(_descr, "startingTime", startingTime, _checker, __FILE__, __LINE__);
	SrvTime registrationStarts; _parser.parseSrvTime(registrationStarts);
	AtfValidator::validateSrvDateTime(_descr, "registrationStarts", registrationStarts, _checker, __FILE__, __LINE__);
	SrvTime registrationEnds; _parser.parseSrvTime(registrationEnds);
	AtfValidator::validateSrvDateTime(_descr, "registrationEnds", registrationEnds, _checker, __FILE__, __LINE__);
	SrvTime seatingStarts; _parser.parseSrvTime(seatingStarts);
	AtfValidator::validateSrvDateTime(_descr, "seatingStarts", seatingStarts, _checker, __FILE__, __LINE__);
	INT32 minPlayers; _parser.parseINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	BYTE restricted; _parser.parseBYTE(restricted);
	AtfValidator::validateInt(_descr, "restricted", restricted, _checker, __FILE__, __LINE__);
	INT32 fppReward; _parser.parseINT32(fppReward);
	AtfValidator::validateInt(_descr, "fppReward", fppReward, _checker, __FILE__, __LINE__);
	INT32 fppBuyIn; _parser.parseINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPwdProtected; _parser.parseBYTE(isPwdProtected);
	AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	INT32 numRebuys; _parser.parseINT32(numRebuys);
	AtfValidator::validateInt(_descr, "numRebuys", numRebuys, _checker, __FILE__, __LINE__);
	INT32 rebuyChips; _parser.parseINT32(rebuyChips);
	AtfValidator::validateInt(_descr, "rebuyChips", rebuyChips, _checker, __FILE__, __LINE__);
	INT32 _obsolete_1; _parser.parseINT32(_obsolete_1);
	AtfValidator::validateInt(_descr, "_obsolete_1", _obsolete_1, _checker, __FILE__, __LINE__);
	INT32 rebuyMaxChips; _parser.parseINT32(rebuyMaxChips);
	AtfValidator::validateInt(_descr, "rebuyMaxChips", rebuyMaxChips, _checker, __FILE__, __LINE__);
	INT32 numAddOns; _parser.parseINT32(numAddOns);
	AtfValidator::validateInt(_descr, "numAddOns", numAddOns, _checker, __FILE__, __LINE__);
	INT32 addOnChips; _parser.parseINT32(addOnChips);
	AtfValidator::validateInt(_descr, "addOnChips", addOnChips, _checker, __FILE__, __LINE__);
	INT32 _obsolete_2; _parser.parseINT32(_obsolete_2);
	AtfValidator::validateInt(_descr, "_obsolete_2", _obsolete_2, _checker, __FILE__, __LINE__);
	INT32 addOnMaxChips; _parser.parseINT32(addOnMaxChips);
	AtfValidator::validateInt(_descr, "addOnMaxChips", addOnMaxChips, _checker, __FILE__, __LINE__);
	INT32 scriptPrizeAddOn; _parser.parseINT32(scriptPrizeAddOn);
	AtfValidator::validateInt(_descr, "scriptPrizeAddOn", scriptPrizeAddOn, _checker, __FILE__, __LINE__);
	INT32 guaranteedPrizePool; _parser.parseINT32(guaranteedPrizePool);
	AtfValidator::validateInt(_descr, "guaranteedPrizePool", guaranteedPrizePool, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	INT16 maxAllIns; _parser.parseINT16(maxAllIns);
	AtfValidator::validateInt(_descr, "maxAllIns", maxAllIns, _checker, __FILE__, __LINE__);
	BYTE awardSchema; _parser.parseBYTE(awardSchema);
	AtfValidator::validateInt(_descr, "awardSchema", awardSchema, _checker, __FILE__, __LINE__);
	UINT32 timeBank; _parser.parseUINT32(timeBank);
	AtfValidator::validateInt(_descr, "timeBank", timeBank, _checker, __FILE__, __LINE__);
	INT32 unregistrationEnds_t; _parser.parseINT32(unregistrationEnds_t);
	AtfValidator::validateInt(_descr, "unregistrationEnds_t", unregistrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 satelliteTarget; _parser.parseUINT32(satelliteTarget);
	AtfValidator::validateInt(_descr, "satelliteTarget", satelliteTarget, _checker, __FILE__, __LINE__);
	INT32 satelliteTargetBuyIn; _parser.parseINT32(satelliteTargetBuyIn);
	AtfValidator::validateInt(_descr, "satelliteTargetBuyIn", satelliteTargetBuyIn, _checker, __FILE__, __LINE__);
	INT32 rebuyFppPrice; _parser.parseINT32(rebuyFppPrice);
	AtfValidator::validateInt(_descr, "rebuyFppPrice", rebuyFppPrice, _checker, __FILE__, __LINE__);
	INT32 addonFppPrice; _parser.parseINT32(addonFppPrice);
	AtfValidator::validateInt(_descr, "addonFppPrice", addonFppPrice, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 startingTime_t; _parser.parseUINT32(startingTime_t);
	AtfValidator::validateInt(_descr, "startingTime_t", startingTime_t, _checker, __FILE__, __LINE__);
	UINT32 registrationStarts_t; _parser.parseUINT32(registrationStarts_t);
	AtfValidator::validateInt(_descr, "registrationStarts_t", registrationStarts_t, _checker, __FILE__, __LINE__);
	UINT32 registrationEnds_t; _parser.parseUINT32(registrationEnds_t);
	AtfValidator::validateInt(_descr, "registrationEnds_t", registrationEnds_t, _checker, __FILE__, __LINE__);
	UINT32 seatingStarts_t; _parser.parseUINT32(seatingStarts_t);
	AtfValidator::validateInt(_descr, "seatingStarts_t", seatingStarts_t, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 tournProp2; _parser.parseUINT32(tournProp2);
	AtfValidator::validateInt(_descr, "tournProp2", tournProp2, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTicketTypes = ThinAtf::LAtfVector< P_TicketType, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketTypes", szTicketTypes, _checker, __FILE__, __LINE__);
	UINT32 tableLogo; _parser.parseUINT32(tableLogo);
	AtfValidator::validateInt(_descr, "tableLogo", tableLogo, _checker, __FILE__, __LINE__);
	I18nPString finalTableText; finalTableText.parse(_parser);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	UINT32 lobbyRestricted; _parser.parseUINT32(lobbyRestricted);
	AtfValidator::validateInt(_descr, "lobbyRestricted", lobbyRestricted, _checker, __FILE__, __LINE__);
	INT32 fppFraction; _parser.parseINT32(fppFraction);
	AtfValidator::validateInt(_descr, "fppFraction", fppFraction, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 rebuyFppReward; _parser.parseINT32(rebuyFppReward);
	AtfValidator::validateInt(_descr, "rebuyFppReward", rebuyFppReward, _checker, __FILE__, __LINE__);
	INT32 addOnFppReward; _parser.parseINT32(addOnFppReward);
	AtfValidator::validateInt(_descr, "addOnFppReward", addOnFppReward, _checker, __FILE__, __LINE__);
	INT8 fppRewardPercent; _parser.parseINT8(fppRewardPercent);
	AtfValidator::validateInt(_descr, "fppRewardPercent", fppRewardPercent, _checker, __FILE__, __LINE__);
	UINT32 nPublishLobbyPlayersLess; _parser.parseUINT32(nPublishLobbyPlayersLess);
	AtfValidator::validateInt(_descr, "nPublishLobbyPlayersLess", nPublishLobbyPlayersLess, _checker, __FILE__, __LINE__);
	INT32 bounty; _parser.parseINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	UINT32 placeHolder; _parser.parseUINT32(placeHolder);
	AtfValidator::validateInt(_descr, "placeHolder", placeHolder, _checker, __FILE__, __LINE__);
	_BountiesType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("bounties"), _fieldsWithUnparsedContent);
	BYTE publPropFlag; _parser.parseBYTE(publPropFlag);
	AtfValidator::validateInt(_descr, "publPropFlag", publPropFlag, _checker, __FILE__, __LINE__);
	MultidayTourn::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("multiday"), _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "satelliteTargetReference"); size_t szSatelliteTargetReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "satelliteTargetReference", szSatelliteTargetReference, _checker, __FILE__, __LINE__);
	UINT16 satelliteTargetReferenceLock; _parser.parseUINT16(satelliteTargetReferenceLock);
	AtfValidator::validateInt(_descr, "satelliteTargetReferenceLock", satelliteTargetReferenceLock, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	BYTE timedTournType; _parser.parseBYTE(timedTournType);
	AtfValidator::validateInt(_descr, "timedTournType", timedTournType, _checker, __FILE__, __LINE__);
	UINT16 timedTournLevelsOrMinutes; _parser.parseUINT16(timedTournLevelsOrMinutes);
	AtfValidator::validateInt(_descr, "timedTournLevelsOrMinutes", timedTournLevelsOrMinutes, _checker, __FILE__, __LINE__);
	BYTE timedTournPayoutStructure; _parser.parseBYTE(timedTournPayoutStructure);
	AtfValidator::validateInt(_descr, "timedTournPayoutStructure", timedTournPayoutStructure, _checker, __FILE__, __LINE__);
	bool _obsolete_3; _parser.parseBOOL(_obsolete_3);
	AtfValidator::validateInt(_descr, "_obsolete_3", _obsolete_3, _checker, __FILE__, __LINE__);
	int szVppToPublish = ThinAtf::LAtfVector< P_FppReward, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("vppToPublish"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "vppToPublish", szVppToPublish, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournBrand"); size_t szTournBrand = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournBrand", szTournBrand, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 blitzNormalDealingThreshold; _parser.parseUINT32(blitzNormalDealingThreshold);
	AtfValidator::validateInt(_descr, "blitzNormalDealingThreshold", blitzNormalDealingThreshold, _checker, __FILE__, __LINE__);
	bool _obsolete_4; _parser.parseBOOL(_obsolete_4);
	AtfValidator::validateInt(_descr, "_obsolete_4", _obsolete_4, _checker, __FILE__, __LINE__);
	BYTE progressiveKnockout; _parser.parseBYTE(progressiveKnockout);
	AtfValidator::validateInt(_descr, "progressiveKnockout", progressiveKnockout, _checker, __FILE__, __LINE__);
	I18nPString tableText; tableText.parse(_parser);
	UINT16 reEntryAllowed; _parser.parseUINT16(reEntryAllowed);
	AtfValidator::validateInt(_descr, "reEntryAllowed", reEntryAllowed, _checker, __FILE__, __LINE__);
	UINT32 tournMask; _parser.parseUINT32(tournMask);
	AtfValidator::validateInt(_descr, "tournMask", tournMask, _checker, __FILE__, __LINE__);
	UINT32 tournMask2; _parser.parseUINT32(tournMask2);
	AtfValidator::validateInt(_descr, "tournMask2", tournMask2, _checker, __FILE__, __LINE__);
	UINT32 tournMask3; _parser.parseUINT32(tournMask3);
	AtfValidator::validateInt(_descr, "tournMask3", tournMask3, _checker, __FILE__, __LINE__);
	UINT32 tournMask4; _parser.parseUINT32(tournMask4);
	AtfValidator::validateInt(_descr, "tournMask4", tournMask4, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "internalReference"); size_t szInternalReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "internalReference", szInternalReference, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "favoriteReference"); size_t szFavoriteReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "favoriteReference", szFavoriteReference, _checker, __FILE__, __LINE__);
	INT64 ticketPrice; _parser.parseINT64(ticketPrice);
	AtfValidator::validateInt(_descr, "ticketPrice", ticketPrice, _checker, __FILE__, __LINE__);
	UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	bool cannotUnregisterFromTarget; _parser.parseBOOL(cannotUnregisterFromTarget);
	AtfValidator::validateInt(_descr, "cannotUnregisterFromTarget", cannotUnregisterFromTarget, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime targetWhenStarts; _parser.parseSrvTime(targetWhenStarts);
	AtfValidator::validateSrvDateTime(_descr, "targetWhenStarts", targetWhenStarts, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	UINT32 siteMask; _parser.parseUINT32(siteMask);
	AtfValidator::validateInt(_descr, "siteMask", siteMask, _checker, __FILE__, __LINE__);
	UINT32 publStartLevel; _parser.parseUINT32(publStartLevel);
	AtfValidator::validateInt(_descr, "publStartLevel", publStartLevel, _checker, __FILE__, __LINE__);
	UINT32 tournMask5; _parser.parseUINT32(tournMask5);
	AtfValidator::validateInt(_descr, "tournMask5", tournMask5, _checker, __FILE__, __LINE__);
	UINT32 tournMask6; _parser.parseUINT32(tournMask6);
	AtfValidator::validateInt(_descr, "tournMask6", tournMask6, _checker, __FILE__, __LINE__);
	BYTE dealExclusionType; _parser.parseBYTE(dealExclusionType);
	AtfValidator::validateInt(_descr, "dealExclusionType", dealExclusionType, _checker, __FILE__, __LINE__);
	INT32 dealExclusionValue; _parser.parseINT32(dealExclusionValue);
	AtfValidator::validateInt(_descr, "dealExclusionValue", dealExclusionValue, _checker, __FILE__, __LINE__);
	BYTE timedTournPlayersPercent; _parser.parseBYTE(timedTournPlayersPercent);
	AtfValidator::validateInt(_descr, "timedTournPlayersPercent", timedTournPlayersPercent, _checker, __FILE__, __LINE__);
	INT32 _obsolete_5; _parser.parseINT32(_obsolete_5);
	AtfValidator::validateInt(_descr, "_obsolete_5", _obsolete_5, _checker, __FILE__, __LINE__);
	INT32 spinGoStartDelay; _parser.parseINT32(spinGoStartDelay);
	AtfValidator::validateInt(_descr, "spinGoStartDelay", spinGoStartDelay, _checker, __FILE__, __LINE__);
	BYTE rmPmLobby; _parser.parseBYTE(rmPmLobby);
	AtfValidator::validateInt(_descr, "rmPmLobby", rmPmLobby, _checker, __FILE__, __LINE__);
	UINT32 brandMask; _parser.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	INT32 playerKnockOutAddOn; _parser.parseINT32(playerKnockOutAddOn);
	AtfValidator::validateInt(_descr, "playerKnockOutAddOn", playerKnockOutAddOn, _checker, __FILE__, __LINE__);
	INT32 totalKnockOutAddOn; _parser.parseINT32(totalKnockOutAddOn);
	AtfValidator::validateInt(_descr, "totalKnockOutAddOn", totalKnockOutAddOn, _checker, __FILE__, __LINE__);
	BYTE knockOutAddOnProgressive; _parser.parseBYTE(knockOutAddOnProgressive);
	AtfValidator::validateInt(_descr, "knockOutAddOnProgressive", knockOutAddOnProgressive, _checker, __FILE__, __LINE__);
	UINT32 sitGoStarterGameId; _parser.parseUINT32(sitGoStarterGameId);
	AtfValidator::validateInt(_descr, "sitGoStarterGameId", sitGoStarterGameId, _checker, __FILE__, __LINE__);
	UINT32 numStandardButton; _parser.parseUINT32(numStandardButton);
	AtfValidator::validateInt(_descr, "numStandardButton", numStandardButton, _checker, __FILE__, __LINE__);
	INT32 lateRegDelta; _parser.parseINT32(lateRegDelta);
	AtfValidator::validateInt(_descr, "lateRegDelta", lateRegDelta, _checker, __FILE__, __LINE__);
	INT32 finalTablePlusOne; _parser.parseINT32(finalTablePlusOne);
	AtfValidator::validateInt(_descr, "finalTablePlusOne", finalTablePlusOne, _checker, __FILE__, __LINE__);
	INT32 multidayIndex; _parser.parseINT32(multidayIndex);
	AtfValidator::validateInt(_descr, "multidayIndex", multidayIndex, _checker, __FILE__, __LINE__);
	int szMultiDayVec = ThinAtf::LAtfVector< LobbyData_MultidayTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("multiDayVec"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "multiDayVec", szMultiDayVec, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "groupReference"); size_t szGroupReference = strlen(_dummy);
	AtfValidator::validateInt(_descr, "groupReference", szGroupReference, _checker, __FILE__, __LINE__);
	INT32 tournGroup; _parser.parseINT32(tournGroup);
	AtfValidator::validateInt(_descr, "tournGroup", tournGroup, _checker, __FILE__, __LINE__);
	INT32 prizePool; _parser.parseINT32(prizePool);
	AtfValidator::validateInt(_descr, "prizePool", prizePool, _checker, __FILE__, __LINE__);
	int szAdmissions = ThinAtf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("admissions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "admissions", szAdmissions, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pokerNgGroup"); size_t szPokerNgGroup = strlen(_dummy);
	AtfValidator::validateInt(_descr, "pokerNgGroup", szPokerNgGroup, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("siteMaskEx"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "tableTrait"); size_t szTableTrait = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableTrait", szTableTrait, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "highlightColor"); size_t szHighlightColor = strlen(_dummy);
	AtfValidator::validateInt(_descr, "highlightColor", szHighlightColor, _checker, __FILE__, __LINE__);
}

void TournClientThin::publication::TournSubscr_Static::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	nStackInfoMsg.parseMsg(_parser0);
}

/*static*/ void TournClientThin::publication::TournSubscr_Static::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	NStackTournInfoStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("nStackInfoMsg"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournSubscr_Betting
//=================================================================

TournClientThin::publication::TournSubscr_Betting::TournSubscr_Betting()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_Betting::TournSubscr_Betting(TournSubscr_Betting&& _o)
	: loBet(std::move(_o.loBet))
	, hiBet(std::move(_o.hiBet))
	, bringIn(std::move(_o.bringIn))
	, smallBlind(std::move(_o.smallBlind))
	, structure(std::move(_o.structure))
	, ante(std::move(_o.ante))
	, blindsLevel(std::move(_o.blindsLevel))
	, nextLevelOrdinal(std::move(_o.nextLevelOrdinal))
	, nextAnte(std::move(_o.nextAnte))
	, nextSmallBlind(std::move(_o.nextSmallBlind))
	, nextLoBet(std::move(_o.nextLoBet))
	, nextHiBet(std::move(_o.nextHiBet))
	, nextBringIn(std::move(_o.nextBringIn))
	, nextLevelStart_t(std::move(_o.nextLevelStart_t))
	, nextLevelStart(std::move(_o.nextLevelStart))
	, olympicLevel(std::move(_o.olympicLevel))
	, gameType(std::move(_o.gameType))
	, limit(std::move(_o.limit))
	, isHiLo(std::move(_o.isHiLo))
{
}

TournClientThin::publication::TournSubscr_Betting& TournClientThin::publication::TournSubscr_Betting::operator=(TournSubscr_Betting&& _o)
{
	if(this != &_o)
	{
		loBet = std::move(_o.loBet);
		hiBet = std::move(_o.hiBet);
		bringIn = std::move(_o.bringIn);
		smallBlind = std::move(_o.smallBlind);
		structure = std::move(_o.structure);
		ante = std::move(_o.ante);
		blindsLevel = std::move(_o.blindsLevel);
		nextLevelOrdinal = std::move(_o.nextLevelOrdinal);
		nextAnte = std::move(_o.nextAnte);
		nextSmallBlind = std::move(_o.nextSmallBlind);
		nextLoBet = std::move(_o.nextLoBet);
		nextHiBet = std::move(_o.nextHiBet);
		nextBringIn = std::move(_o.nextBringIn);
		nextLevelStart_t = std::move(_o.nextLevelStart_t);
		nextLevelStart = std::move(_o.nextLevelStart);
		olympicLevel = std::move(_o.olympicLevel);
		gameType = std::move(_o.gameType);
		limit = std::move(_o.limit);
		isHiLo = std::move(_o.isHiLo);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_Betting::clear()
{
	loBet = 0;
	hiBet = 0;
	bringIn = 0;
	smallBlind = 0;
	structure = 0;
	ante = 0;
	blindsLevel = 0;
	nextLevelOrdinal = 0;
	nextAnte = 0;
	nextSmallBlind = 0;
	nextLoBet = 0;
	nextHiBet = 0;
	nextBringIn = 0;
	nextLevelStart_t = 0;
	nextLevelStart.setNull();
	olympicLevel = 0;
	gameType = 0;
	limit = 0;
	isHiLo = 0;
}

bool TournClientThin::publication::TournSubscr_Betting::equals(const TournSubscr_Betting& _o) const
{
	return loBet == _o.loBet &&
		hiBet == _o.hiBet &&
		bringIn == _o.bringIn &&
		smallBlind == _o.smallBlind &&
		structure == _o.structure &&
		ante == _o.ante &&
		blindsLevel == _o.blindsLevel &&
		nextLevelOrdinal == _o.nextLevelOrdinal &&
		nextAnte == _o.nextAnte &&
		nextSmallBlind == _o.nextSmallBlind &&
		nextLoBet == _o.nextLoBet &&
		nextHiBet == _o.nextHiBet &&
		nextBringIn == _o.nextBringIn &&
		nextLevelStart_t == _o.nextLevelStart_t &&
		nextLevelStart.equals(_o.nextLevelStart) &&
		olympicLevel == _o.olympicLevel &&
		gameType == _o.gameType &&
		limit == _o.limit &&
		isHiLo == _o.isHiLo;
}

const char *TournClientThin::publication::TournSubscr_Betting::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("loBet=");
	_buf.appendUint(loBet);
	_buf.append(',');
	_buf.append("hiBet=");
	_buf.appendUint(hiBet);
	_buf.append(',');
	_buf.append("bringIn=");
	_buf.appendUint(bringIn);
	_buf.append(',');
	_buf.append("smallBlind=");
	_buf.appendUint(smallBlind);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("blindsLevel=");
	_buf.appendUint(blindsLevel);
	_buf.append(',');
	_buf.append("nextLevelOrdinal=");
	_buf.appendUint(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_buf.append(',');
		_buf.append("nextAnte=");
		_buf.appendUint(nextAnte);
		_buf.append(',');
		_buf.append("nextSmallBlind=");
		_buf.appendUint(nextSmallBlind);
		_buf.append(',');
		_buf.append("nextLoBet=");
		_buf.appendUint(nextLoBet);
		_buf.append(',');
		_buf.append("nextHiBet=");
		_buf.appendUint(nextHiBet);
		_buf.append(',');
		_buf.append("nextBringIn=");
		_buf.appendUint(nextBringIn);
		_buf.append(',');
		_buf.append("nextLevelStart_t=");
		_buf.appendUint(nextLevelStart_t);
		_buf.append(',');
		_buf.append("nextLevelStart=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, nextLevelStart);
	}
	_buf.append(',');
	_buf.append("olympicLevel=");
	_buf.appendUint(olympicLevel);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Betting::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(loBet);
	_msg.composeUINT32(hiBet);
	_msg.composeUINT32(bringIn);
	_msg.composeUINT32(smallBlind);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(ante);
	_msg.composeBYTE(blindsLevel);
	_msg.composeBYTE(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_msg.composeUINT32(nextAnte);
		_msg.composeUINT32(nextSmallBlind);
		_msg.composeUINT32(nextLoBet);
		_msg.composeUINT32(nextHiBet);
		_msg.composeUINT32(nextBringIn);
		_msg.composeUINT32(nextLevelStart_t);
		_msg.composeSrvTime(nextLevelStart);
	}
	_msg.composeUINT16(olympicLevel);
	_msg.composeBYTE(gameType);
	_msg.composeBYTE(limit);
	_msg.composeBYTE(isHiLo);
}

void TournClientThin::publication::TournSubscr_Betting::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(loBet);
	_parser.parseUINT32(hiBet);
	_parser.parseUINT32(bringIn);
	_parser.parseUINT32(smallBlind);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(ante);
	_parser.parseBYTE(blindsLevel);
	_parser.parseBYTE(nextLevelOrdinal);
	if( nextLevelOrdinal )
	{
		_parser.parseUINT32(nextAnte);
		_parser.parseUINT32(nextSmallBlind);
		_parser.parseUINT32(nextLoBet);
		_parser.parseUINT32(nextHiBet);
		_parser.parseUINT32(nextBringIn);
		_parser.parseUINT32(nextLevelStart_t);
		_parser.parseSrvTime(nextLevelStart);
	}
	_parser.parseUINT16(olympicLevel);
	_parser.parseBYTE(gameType);
	_parser.parseBYTE(limit);
	_parser.parseBYTE(isHiLo);
}

/*static*/ void TournClientThin::publication::TournSubscr_Betting::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE nextLevelOrdinal = 0;
	UINT32 loBet; _parser.parseUINT32(loBet);
	AtfValidator::validateInt(_descr, "loBet", loBet, _checker, __FILE__, __LINE__);
	UINT32 hiBet; _parser.parseUINT32(hiBet);
	AtfValidator::validateInt(_descr, "hiBet", hiBet, _checker, __FILE__, __LINE__);
	UINT32 bringIn; _parser.parseUINT32(bringIn);
	AtfValidator::validateInt(_descr, "bringIn", bringIn, _checker, __FILE__, __LINE__);
	UINT32 smallBlind; _parser.parseUINT32(smallBlind);
	AtfValidator::validateInt(_descr, "smallBlind", smallBlind, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	BYTE blindsLevel; _parser.parseBYTE(blindsLevel);
	AtfValidator::validateInt(_descr, "blindsLevel", blindsLevel, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(nextLevelOrdinal);
	AtfValidator::validateInt(_descr, "nextLevelOrdinal", nextLevelOrdinal, _checker, __FILE__, __LINE__);
	if( nextLevelOrdinal )
	{
		UINT32 nextAnte; _parser.parseUINT32(nextAnte);
		AtfValidator::validateInt(_descr, "nextAnte", nextAnte, _checker, __FILE__, __LINE__);
		UINT32 nextSmallBlind; _parser.parseUINT32(nextSmallBlind);
		AtfValidator::validateInt(_descr, "nextSmallBlind", nextSmallBlind, _checker, __FILE__, __LINE__);
		UINT32 nextLoBet; _parser.parseUINT32(nextLoBet);
		AtfValidator::validateInt(_descr, "nextLoBet", nextLoBet, _checker, __FILE__, __LINE__);
		UINT32 nextHiBet; _parser.parseUINT32(nextHiBet);
		AtfValidator::validateInt(_descr, "nextHiBet", nextHiBet, _checker, __FILE__, __LINE__);
		UINT32 nextBringIn; _parser.parseUINT32(nextBringIn);
		AtfValidator::validateInt(_descr, "nextBringIn", nextBringIn, _checker, __FILE__, __LINE__);
		UINT32 nextLevelStart_t; _parser.parseUINT32(nextLevelStart_t);
		AtfValidator::validateInt(_descr, "nextLevelStart_t", nextLevelStart_t, _checker, __FILE__, __LINE__);
		SrvTime nextLevelStart; _parser.parseSrvTime(nextLevelStart);
		AtfValidator::validateSrvDateTime(_descr, "nextLevelStart", nextLevelStart, _checker, __FILE__, __LINE__);
	}
	UINT16 olympicLevel; _parser.parseUINT16(olympicLevel);
	AtfValidator::validateInt(_descr, "olympicLevel", olympicLevel, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	BYTE limit; _parser.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_BettingNew
//=================================================================

//=================================================================
//                _CLevelType
//=================================================================

TournClientThin::publication::TournSubscr_BettingNew::_CLevelType::_CLevelType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_BettingNew::_CLevelType::_CLevelType(_CLevelType&& _o)
	: currentLevel(std::move(_o.currentLevel))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TournClientThin::publication::TournSubscr_BettingNew::_CLevelType& TournClientThin::publication::TournSubscr_BettingNew::_CLevelType::operator=(_CLevelType&& _o)
{
	if(this != &_o)
	{
		currentLevel = std::move(_o.currentLevel);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_BettingNew::_CLevelType::clear()
{
	currentLevel.clear();
	_is_empty_internal = true;
}

bool TournClientThin::publication::TournSubscr_BettingNew::_CLevelType::equals(const _CLevelType& _o) const
{
	return currentLevel.equals(_o.currentLevel);
}

const char *TournClientThin::publication::TournSubscr_BettingNew::_CLevelType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("currentLevel=");
		currentLevel.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_BettingNew::_CLevelType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		currentLevel.composeMsg(_msg0);
	}

	_msg.composeMsgBody(_msg0);
}

void TournClientThin::publication::TournSubscr_BettingNew::_CLevelType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	currentLevel.parseMsg(_parser0);
}

/*static*/ void TournClientThin::publication::TournSubscr_BettingNew::_CLevelType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	LobbyData_Betting::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("currentLevel"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                _NLevelType
//=================================================================

TournClientThin::publication::TournSubscr_BettingNew::_NLevelType::_NLevelType()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_BettingNew::_NLevelType::_NLevelType(_NLevelType&& _o)
	: nextLevel(std::move(_o.nextLevel))
	, _is_empty_internal(std::move(_o._is_empty_internal))
{
}

TournClientThin::publication::TournSubscr_BettingNew::_NLevelType& TournClientThin::publication::TournSubscr_BettingNew::_NLevelType::operator=(_NLevelType&& _o)
{
	if(this != &_o)
	{
		nextLevel = std::move(_o.nextLevel);
		_is_empty_internal = std::move(_o._is_empty_internal);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_BettingNew::_NLevelType::clear()
{
	nextLevel.clear();
	_is_empty_internal = true;
}

bool TournClientThin::publication::TournSubscr_BettingNew::_NLevelType::equals(const _NLevelType& _o) const
{
	return nextLevel.equals(_o.nextLevel);
}

const char *TournClientThin::publication::TournSubscr_BettingNew::_NLevelType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	if (!isEmptyMsg())
	{
		_buf.append("nextLevel=");
		nextLevel.toTraceString(_buf);
	}
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_BettingNew::_NLevelType::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	if (!isEmptyMsg())
	{
		nextLevel.composeMsg(_msg0);
	}

	_msg.composeMsgBody(_msg0);
}

void TournClientThin::publication::TournSubscr_BettingNew::_NLevelType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	
	if(!_body._size())
	{
		_is_empty_internal = true;
		return;
	}

	_is_empty_internal = false;
	CommMsgParser _parser0(_body);
	nextLevel.parseMsg(_parser0);
}

/*static*/ void TournClientThin::publication::TournSubscr_BettingNew::_NLevelType::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.msgBodyViewSize() == 0) return;

	PString _descbuf;
	LobbyData_Betting::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("nextLevel"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

TournClientThin::publication::TournSubscr_BettingNew::TournSubscr_BettingNew()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_BettingNew::TournSubscr_BettingNew(TournSubscr_BettingNew&& _o)
	: cLevel(std::move(_o.cLevel))
	, nLevel(std::move(_o.nLevel))
	, nextLevelStart(std::move(_o.nextLevelStart))
	, nextLevelStartTime(std::move(_o.nextLevelStartTime))
	, olympicLevel(std::move(_o.olympicLevel))
{
}

TournClientThin::publication::TournSubscr_BettingNew& TournClientThin::publication::TournSubscr_BettingNew::operator=(TournSubscr_BettingNew&& _o)
{
	if(this != &_o)
	{
		cLevel = std::move(_o.cLevel);
		nLevel = std::move(_o.nLevel);
		nextLevelStart = std::move(_o.nextLevelStart);
		nextLevelStartTime = std::move(_o.nextLevelStartTime);
		olympicLevel = std::move(_o.olympicLevel);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_BettingNew::clear()
{
	cLevel.clear();
	nLevel.clear();
	nextLevelStart = 0;
	nextLevelStartTime.setNull();
	olympicLevel = 0;
}

bool TournClientThin::publication::TournSubscr_BettingNew::equals(const TournSubscr_BettingNew& _o) const
{
	return cLevel.equals(_o.cLevel) &&
		nLevel.equals(_o.nLevel) &&
		nextLevelStart == _o.nextLevelStart &&
		nextLevelStartTime.equals(_o.nextLevelStartTime) &&
		olympicLevel == _o.olympicLevel;
}

const char *TournClientThin::publication::TournSubscr_BettingNew::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cLevel=");
	cLevel.toTraceString(_buf);
	_buf.append(',');
	_buf.append("nLevel=");
	nLevel.toTraceString(_buf);
	_buf.append(',');
	_buf.append("nextLevelStart=");
	_buf.appendUint(nextLevelStart);
	_buf.append(',');
	_buf.append("nextLevelStartTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, nextLevelStartTime);
	_buf.append(',');
	_buf.append("olympicLevel=");
	_buf.appendInt(olympicLevel);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_BettingNew::composeMsg(CommMsgBody& _msg) const
{
	cLevel.composeMsg(_msg);
	nLevel.composeMsg(_msg);
	_msg.composeUINT32(nextLevelStart);
	_msg.composeSrvTime(nextLevelStartTime);
	_msg.composeINT16(olympicLevel);
}

void TournClientThin::publication::TournSubscr_BettingNew::parseMsg(CommMsgParser& _parser)
{
	cLevel.parseMsg(_parser);
	nLevel.parseMsg(_parser);
	_parser.parseUINT32(nextLevelStart);
	_parser.parseSrvTime(nextLevelStartTime);
	_parser.parseINT16(olympicLevel);
}

/*static*/ void TournClientThin::publication::TournSubscr_BettingNew::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	_CLevelType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cLevel"), _fieldsWithUnparsedContent);
	_NLevelType::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nLevel"), _fieldsWithUnparsedContent);
	UINT32 nextLevelStart; _parser.parseUINT32(nextLevelStart);
	AtfValidator::validateInt(_descr, "nextLevelStart", nextLevelStart, _checker, __FILE__, __LINE__);
	SrvTime nextLevelStartTime; _parser.parseSrvTime(nextLevelStartTime);
	AtfValidator::validateSrvDateTime(_descr, "nextLevelStartTime", nextLevelStartTime, _checker, __FILE__, __LINE__);
	INT16 olympicLevel; _parser.parseINT16(olympicLevel);
	AtfValidator::validateInt(_descr, "olympicLevel", olympicLevel, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Status
//=================================================================

TournClientThin::publication::TournSubscr_Status::TournSubscr_Status()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_Status::TournSubscr_Status(TournSubscr_Status&& _o)
	: status(std::move(_o.status))
	, newStartTimeFlightTourn(std::move(_o.newStartTimeFlightTourn))
	, minutesLateFlightTourn(std::move(_o.minutesLateFlightTourn))
	, createdBy(std::move(_o.createdBy))
	, cancelledBy(std::move(_o.cancelledBy))
	, isBlitzTourn(std::move(_o.isBlitzTourn))
	, timedTournPlayersThreshold(std::move(_o.timedTournPlayersThreshold))
	, sameLevelFlightsAvailable(std::move(_o.sameLevelFlightsAvailable))
	, nextLevelFlightsAvailable(std::move(_o.nextLevelFlightsAvailable))
	, delayedPlaceDelta(std::move(_o.delayedPlaceDelta))
	, activeFlags(std::move(_o.activeFlags))
	, isWinTheButtonTourn(std::move(_o.isWinTheButtonTourn))
{
}

TournClientThin::publication::TournSubscr_Status& TournClientThin::publication::TournSubscr_Status::operator=(TournSubscr_Status&& _o)
{
	if(this != &_o)
	{
		status = std::move(_o.status);
		newStartTimeFlightTourn = std::move(_o.newStartTimeFlightTourn);
		minutesLateFlightTourn = std::move(_o.minutesLateFlightTourn);
		createdBy = std::move(_o.createdBy);
		cancelledBy = std::move(_o.cancelledBy);
		isBlitzTourn = std::move(_o.isBlitzTourn);
		timedTournPlayersThreshold = std::move(_o.timedTournPlayersThreshold);
		sameLevelFlightsAvailable = std::move(_o.sameLevelFlightsAvailable);
		nextLevelFlightsAvailable = std::move(_o.nextLevelFlightsAvailable);
		delayedPlaceDelta = std::move(_o.delayedPlaceDelta);
		activeFlags = std::move(_o.activeFlags);
		isWinTheButtonTourn = std::move(_o.isWinTheButtonTourn);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_Status::clear()
{
	status = 0;
	newStartTimeFlightTourn.setNull();
	minutesLateFlightTourn = 0;
	createdBy.clear();
	cancelledBy.clear();
	isBlitzTourn = false;
	timedTournPlayersThreshold = 0;
	sameLevelFlightsAvailable = false;
	nextLevelFlightsAvailable = false;
	delayedPlaceDelta = 0;
	activeFlags = 0;
	isWinTheButtonTourn = false;
}

bool TournClientThin::publication::TournSubscr_Status::equals(const TournSubscr_Status& _o) const
{
	return status == _o.status &&
		newStartTimeFlightTourn.equals(_o.newStartTimeFlightTourn) &&
		minutesLateFlightTourn == _o.minutesLateFlightTourn &&
		createdBy.equals(_o.createdBy) &&
		cancelledBy.equals(_o.cancelledBy) &&
		isBlitzTourn == _o.isBlitzTourn &&
		timedTournPlayersThreshold == _o.timedTournPlayersThreshold &&
		sameLevelFlightsAvailable == _o.sameLevelFlightsAvailable &&
		nextLevelFlightsAvailable == _o.nextLevelFlightsAvailable &&
		delayedPlaceDelta == _o.delayedPlaceDelta &&
		activeFlags == _o.activeFlags &&
		isWinTheButtonTourn == _o.isWinTheButtonTourn;
}

const char *TournClientThin::publication::TournSubscr_Status::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("newStartTimeFlightTourn=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, newStartTimeFlightTourn);
	_buf.append(',');
	_buf.append("minutesLateFlightTourn=");
	_buf.appendUint(minutesLateFlightTourn);
	_buf.append(',');
	_buf.append("createdBy=");
	_buf.append(createdBy);
	_buf.append(',');
	_buf.append("cancelledBy=");
	_buf.append(cancelledBy);
	_buf.append(',');
	_buf.append("isBlitzTourn=");
	_buf.appendUint(isBlitzTourn);
	_buf.append(',');
	_buf.append("timedTournPlayersThreshold=");
	_buf.appendUint(timedTournPlayersThreshold);
	_buf.append(',');
	_buf.append("sameLevelFlightsAvailable=");
	_buf.appendUint(sameLevelFlightsAvailable);
	_buf.append(',');
	_buf.append("nextLevelFlightsAvailable=");
	_buf.appendUint(nextLevelFlightsAvailable);
	_buf.append(',');
	_buf.append("delayedPlaceDelta=");
	_buf.appendInt(delayedPlaceDelta);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("isWinTheButtonTourn=");
	_buf.appendUint(isWinTheButtonTourn);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Status::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(status);
	_msg.composeSrvTime(newStartTimeFlightTourn);
	_msg.composeUINT32(minutesLateFlightTourn);
	_msg.composeString(createdBy);
	_msg.composeString(cancelledBy);
	_msg.composeBOOL(isBlitzTourn);
	_msg.composeUINT32(timedTournPlayersThreshold);
	_msg.composeBOOL(sameLevelFlightsAvailable);
	_msg.composeBOOL(nextLevelFlightsAvailable);
	_msg.composeINT32(delayedPlaceDelta);
	_msg.composeUINT32(activeFlags);
	_msg.composeBOOL(isWinTheButtonTourn);
}

void TournClientThin::publication::TournSubscr_Status::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
	_parser.parseSrvTime(newStartTimeFlightTourn);
	_parser.parseUINT32(minutesLateFlightTourn);
	_parser.parseStringP(createdBy);
	_parser.parseStringP(cancelledBy);
	_parser.parseBOOL(isBlitzTourn);
	_parser.parseUINT32(timedTournPlayersThreshold);
	_parser.parseBOOL(sameLevelFlightsAvailable);
	_parser.parseBOOL(nextLevelFlightsAvailable);
	_parser.parseINT32(delayedPlaceDelta);
	_parser.parseUINT32(activeFlags);
	_parser.parseBOOL(isWinTheButtonTourn);
}

/*static*/ void TournClientThin::publication::TournSubscr_Status::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime newStartTimeFlightTourn; _parser.parseSrvTime(newStartTimeFlightTourn);
	AtfValidator::validateSrvDateTime(_descr, "newStartTimeFlightTourn", newStartTimeFlightTourn, _checker, __FILE__, __LINE__);
	UINT32 minutesLateFlightTourn; _parser.parseUINT32(minutesLateFlightTourn);
	AtfValidator::validateInt(_descr, "minutesLateFlightTourn", minutesLateFlightTourn, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "createdBy"); size_t szCreatedBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "createdBy", szCreatedBy, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "cancelledBy"); size_t szCancelledBy = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cancelledBy", szCancelledBy, _checker, __FILE__, __LINE__);
	bool isBlitzTourn; _parser.parseBOOL(isBlitzTourn);
	AtfValidator::validateInt(_descr, "isBlitzTourn", isBlitzTourn, _checker, __FILE__, __LINE__);
	UINT32 timedTournPlayersThreshold; _parser.parseUINT32(timedTournPlayersThreshold);
	AtfValidator::validateInt(_descr, "timedTournPlayersThreshold", timedTournPlayersThreshold, _checker, __FILE__, __LINE__);
	bool sameLevelFlightsAvailable; _parser.parseBOOL(sameLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "sameLevelFlightsAvailable", sameLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	bool nextLevelFlightsAvailable; _parser.parseBOOL(nextLevelFlightsAvailable);
	AtfValidator::validateInt(_descr, "nextLevelFlightsAvailable", nextLevelFlightsAvailable, _checker, __FILE__, __LINE__);
	INT32 delayedPlaceDelta; _parser.parseINT32(delayedPlaceDelta);
	AtfValidator::validateInt(_descr, "delayedPlaceDelta", delayedPlaceDelta, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	bool isWinTheButtonTourn; _parser.parseBOOL(isWinTheButtonTourn);
	AtfValidator::validateInt(_descr, "isWinTheButtonTourn", isWinTheButtonTourn, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Board
//=================================================================

TournClientThin::publication::TournSubscr_Board::TournSubscr_Board()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_Board::TournSubscr_Board(TournSubscr_Board&& _o)
	: itSessionId(std::move(_o.itSessionId))
{
}

TournClientThin::publication::TournSubscr_Board& TournClientThin::publication::TournSubscr_Board::operator=(TournSubscr_Board&& _o)
{
	if(this != &_o)
	{
		itSessionId = std::move(_o.itSessionId);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_Board::clear()
{
	itSessionId.clear();
}

bool TournClientThin::publication::TournSubscr_Board::equals(const TournSubscr_Board& _o) const
{
	return itSessionId.equals(_o.itSessionId);
}

const char *TournClientThin::publication::TournSubscr_Board::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("itSessionId=");
	_buf.append(itSessionId);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Board::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(itSessionId);
}

void TournClientThin::publication::TournSubscr_Board::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(itSessionId);
}

/*static*/ void TournClientThin::publication::TournSubscr_Board::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "itSessionId"); size_t szItSessionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "itSessionId", szItSessionId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Break
//=================================================================

TournClientThin::publication::TournSubscr_Break::TournSubscr_Break()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_Break::TournSubscr_Break(TournSubscr_Break&& _o)
	: nextBreakStarts(std::move(_o.nextBreakStarts))
	, currentBreakStops(std::move(_o.currentBreakStops))
	, currentBreakDuration(std::move(_o.currentBreakDuration))
	, nextBreakStarts_t(std::move(_o.nextBreakStarts_t))
	, currentBreakStops_t(std::move(_o.currentBreakStops_t))
	, addOnEligibleBreak(std::move(_o.addOnEligibleBreak))
	, blitzTableRound(std::move(_o.blitzTableRound))
	, message(std::move(_o.message))
{
}

TournClientThin::publication::TournSubscr_Break& TournClientThin::publication::TournSubscr_Break::operator=(TournSubscr_Break&& _o)
{
	if(this != &_o)
	{
		nextBreakStarts = std::move(_o.nextBreakStarts);
		currentBreakStops = std::move(_o.currentBreakStops);
		currentBreakDuration = std::move(_o.currentBreakDuration);
		nextBreakStarts_t = std::move(_o.nextBreakStarts_t);
		currentBreakStops_t = std::move(_o.currentBreakStops_t);
		addOnEligibleBreak = std::move(_o.addOnEligibleBreak);
		blitzTableRound = std::move(_o.blitzTableRound);
		message = std::move(_o.message);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_Break::clear()
{
	nextBreakStarts.setNull();
	currentBreakStops.setNull();
	currentBreakDuration = 0;
	nextBreakStarts_t = 0;
	currentBreakStops_t = 0;
	addOnEligibleBreak = false;
	blitzTableRound = 0;
	message.clear();
}

bool TournClientThin::publication::TournSubscr_Break::equals(const TournSubscr_Break& _o) const
{
	return nextBreakStarts.equals(_o.nextBreakStarts) &&
		currentBreakStops.equals(_o.currentBreakStops) &&
		currentBreakDuration == _o.currentBreakDuration &&
		nextBreakStarts_t == _o.nextBreakStarts_t &&
		currentBreakStops_t == _o.currentBreakStops_t &&
		addOnEligibleBreak == _o.addOnEligibleBreak &&
		blitzTableRound == _o.blitzTableRound &&
		message.equals(_o.message);
}

const char *TournClientThin::publication::TournSubscr_Break::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("nextBreakStarts=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, nextBreakStarts);
	_buf.append(',');
	_buf.append("currentBreakStops=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, currentBreakStops);
	_buf.append(',');
	_buf.append("currentBreakDuration=");
	_buf.appendUint(currentBreakDuration);
	_buf.append(',');
	_buf.append("nextBreakStarts_t=");
	_buf.appendUint(nextBreakStarts_t);
	_buf.append(',');
	_buf.append("currentBreakStops_t=");
	_buf.appendUint(currentBreakStops_t);
	_buf.append(',');
	_buf.append("addOnEligibleBreak=");
	_buf.appendUint(addOnEligibleBreak);
	_buf.append(',');
	_buf.append("blitzTableRound=");
	_buf.appendInt(blitzTableRound);
	_buf.append(',');
	_buf.append("message=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, message);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Break::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(nextBreakStarts);
	_msg.composeSrvTime(currentBreakStops);
	_msg.composeUINT32(currentBreakDuration);
	_msg.composeUINT32(nextBreakStarts_t);
	_msg.composeUINT32(currentBreakStops_t);
	_msg.composeBOOL(addOnEligibleBreak);
	_msg.composeINT32(blitzTableRound);
	message.compose(_msg);
}

void TournClientThin::publication::TournSubscr_Break::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(nextBreakStarts);
	_parser.parseSrvTime(currentBreakStops);
	_parser.parseUINT32(currentBreakDuration);
	_parser.parseUINT32(nextBreakStarts_t);
	_parser.parseUINT32(currentBreakStops_t);
	_parser.parseBOOL(addOnEligibleBreak);
	_parser.parseINT32(blitzTableRound);
	message.parse(_parser);
}

/*static*/ void TournClientThin::publication::TournSubscr_Break::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime nextBreakStarts; _parser.parseSrvTime(nextBreakStarts);
	AtfValidator::validateSrvDateTime(_descr, "nextBreakStarts", nextBreakStarts, _checker, __FILE__, __LINE__);
	SrvTime currentBreakStops; _parser.parseSrvTime(currentBreakStops);
	AtfValidator::validateSrvDateTime(_descr, "currentBreakStops", currentBreakStops, _checker, __FILE__, __LINE__);
	UINT32 currentBreakDuration; _parser.parseUINT32(currentBreakDuration);
	AtfValidator::validateInt(_descr, "currentBreakDuration", currentBreakDuration, _checker, __FILE__, __LINE__);
	UINT32 nextBreakStarts_t; _parser.parseUINT32(nextBreakStarts_t);
	AtfValidator::validateInt(_descr, "nextBreakStarts_t", nextBreakStarts_t, _checker, __FILE__, __LINE__);
	UINT32 currentBreakStops_t; _parser.parseUINT32(currentBreakStops_t);
	AtfValidator::validateInt(_descr, "currentBreakStops_t", currentBreakStops_t, _checker, __FILE__, __LINE__);
	bool addOnEligibleBreak; _parser.parseBOOL(addOnEligibleBreak);
	AtfValidator::validateInt(_descr, "addOnEligibleBreak", addOnEligibleBreak, _checker, __FILE__, __LINE__);
	INT32 blitzTableRound; _parser.parseINT32(blitzTableRound);
	AtfValidator::validateInt(_descr, "blitzTableRound", blitzTableRound, _checker, __FILE__, __LINE__);
	I18nPString message; message.parse(_parser);
}

//=================================================================
//                    TournSubscr_Closed
//=================================================================

TournClientThin::publication::TournSubscr_Closed::TournSubscr_Closed()
{
	clear();
}

void TournClientThin::publication::TournSubscr_Closed::clear()
{
	closed.setNull();
}

bool TournClientThin::publication::TournSubscr_Closed::equals(const TournSubscr_Closed& _o) const
{
	return closed.equals(_o.closed);
}

const char *TournClientThin::publication::TournSubscr_Closed::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("closed=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, closed);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Closed::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(closed);
}

void TournClientThin::publication::TournSubscr_Closed::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(closed);
}

/*static*/ void TournClientThin::publication::TournSubscr_Closed::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime closed; _parser.parseSrvTime(closed);
	AtfValidator::validateSrvDateTime(_descr, "closed", closed, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Awards
//=================================================================

TournClientThin::publication::TournSubscr_Awards::TournSubscr_Awards()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_Awards::TournSubscr_Awards(TournSubscr_Awards&& _o)
	: effectivePrizePool(std::move(_o.effectivePrizePool))
	, prizes(std::move(_o.prizes))
	, nTickets(std::move(_o.nTickets))
	, nextTournIds(std::move(_o.nextTournIds))
	, creditPlayer(std::move(_o.creditPlayer))
	, mixTournSatellite(std::move(_o.mixTournSatellite))
{
}

TournClientThin::publication::TournSubscr_Awards& TournClientThin::publication::TournSubscr_Awards::operator=(TournSubscr_Awards&& _o)
{
	if(this != &_o)
	{
		effectivePrizePool = std::move(_o.effectivePrizePool);
		prizes = std::move(_o.prizes);
		nTickets = std::move(_o.nTickets);
		nextTournIds = std::move(_o.nextTournIds);
		creditPlayer = std::move(_o.creditPlayer);
		mixTournSatellite = std::move(_o.mixTournSatellite);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_Awards::clear()
{
	effectivePrizePool = 0;
	prizes.clear();
	nTickets = 0;
	nextTournIds.clear();
	creditPlayer = 0;
	mixTournSatellite = 0;
}

bool TournClientThin::publication::TournSubscr_Awards::equals(const TournSubscr_Awards& _o) const
{
	return effectivePrizePool == _o.effectivePrizePool &&
		prizes.equals(_o.prizes) &&
		nTickets == _o.nTickets &&
		nextTournIds.equals(_o.nextTournIds) &&
		creditPlayer == _o.creditPlayer &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *TournClientThin::publication::TournSubscr_Awards::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("effectivePrizePool=");
	_buf.appendInt(effectivePrizePool);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("nTickets=");
	_buf.appendUint(nTickets);
	_buf.append(',');
	_buf.append("nextTournIds=");
	nextTournIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("creditPlayer=");
	_buf.appendInt(creditPlayer);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendInt(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Awards::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(effectivePrizePool);
	prizes.composeMsg(_msg);
	_msg.composeUINT32(nTickets);
	nextTournIds.composeMsg(_msg);
	_msg.composeINT32(creditPlayer);
	_msg.composeINT8(mixTournSatellite);
}

void TournClientThin::publication::TournSubscr_Awards::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(effectivePrizePool);
	prizes.parseMsg(_parser);
	_parser.parseUINT32(nTickets);
	nextTournIds.parseMsg(_parser);
	_parser.parseINT32(creditPlayer);
	_parser.parseINT8(mixTournSatellite);
}

/*static*/ void TournClientThin::publication::TournSubscr_Awards::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 effectivePrizePool; _parser.parseINT32(effectivePrizePool);
	AtfValidator::validateInt(_descr, "effectivePrizePool", effectivePrizePool, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	UINT32 nTickets; _parser.parseUINT32(nTickets);
	AtfValidator::validateInt(_descr, "nTickets", nTickets, _checker, __FILE__, __LINE__);
	int szNextTournIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("nextTournIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "nextTournIds", szNextTournIds, _checker, __FILE__, __LINE__);
	INT32 creditPlayer; _parser.parseINT32(creditPlayer);
	AtfValidator::validateInt(_descr, "creditPlayer", creditPlayer, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _parser.parseINT8(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_AddOn
//=================================================================

TournClientThin::publication::TournSubscr_AddOn::TournSubscr_AddOn()
{
	clear();
}

void TournClientThin::publication::TournSubscr_AddOn::clear()
{
	waiting = 0;
}

bool TournClientThin::publication::TournSubscr_AddOn::equals(const TournSubscr_AddOn& _o) const
{
	return waiting == _o.waiting;
}

const char *TournClientThin::publication::TournSubscr_AddOn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("waiting=");
	_buf.appendUint(waiting);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_AddOn::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(waiting);
}

void TournClientThin::publication::TournSubscr_AddOn::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(waiting);
}

/*static*/ void TournClientThin::publication::TournSubscr_AddOn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE waiting; _parser.parseBYTE(waiting);
	AtfValidator::validateInt(_descr, "waiting", waiting, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Stakes
//=================================================================

TournClientThin::publication::TournSubscr_Stakes::TournSubscr_Stakes()
{
	clear();
}

void TournClientThin::publication::TournSubscr_Stakes::clear()
{
	minStack = 0;
	maxStack = 0;
	avgStack = 0;
}

bool TournClientThin::publication::TournSubscr_Stakes::equals(const TournSubscr_Stakes& _o) const
{
	return minStack == _o.minStack &&
		maxStack == _o.maxStack &&
		avgStack == _o.avgStack;
}

const char *TournClientThin::publication::TournSubscr_Stakes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minStack=");
	_buf.appendUint(minStack);
	_buf.append(',');
	_buf.append("maxStack=");
	_buf.appendUint(maxStack);
	_buf.append(',');
	_buf.append("avgStack=");
	_buf.appendUint(avgStack);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Stakes::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(minStack);
	_msg.composeUINT32(maxStack);
	_msg.composeUINT32(avgStack);
}

void TournClientThin::publication::TournSubscr_Stakes::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(minStack);
	_parser.parseUINT32(maxStack);
	_parser.parseUINT32(avgStack);
}

/*static*/ void TournClientThin::publication::TournSubscr_Stakes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 minStack; _parser.parseUINT32(minStack);
	AtfValidator::validateInt(_descr, "minStack", minStack, _checker, __FILE__, __LINE__);
	UINT32 maxStack; _parser.parseUINT32(maxStack);
	AtfValidator::validateInt(_descr, "maxStack", maxStack, _checker, __FILE__, __LINE__);
	UINT32 avgStack; _parser.parseUINT32(avgStack);
	AtfValidator::validateInt(_descr, "avgStack", avgStack, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PrizePool
//=================================================================

TournClientThin::publication::TournSubscr_PrizePool::TournSubscr_PrizePool()
{
	clear();
}

void TournClientThin::publication::TournSubscr_PrizePool::clear()
{
	numUsers = 0;
	prizePoolToPublish = 0;
	totalRebuysDone = 0;
	totalAddonsDone = 0;
	payouts = 0;
	flightIntermediatePayoutPrizePool = 0;
	flightIntermediatePayoutPerUser = 0;
}

bool TournClientThin::publication::TournSubscr_PrizePool::equals(const TournSubscr_PrizePool& _o) const
{
	return numUsers == _o.numUsers &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		totalRebuysDone == _o.totalRebuysDone &&
		totalAddonsDone == _o.totalAddonsDone &&
		payouts == _o.payouts &&
		flightIntermediatePayoutPrizePool == _o.flightIntermediatePayoutPrizePool &&
		flightIntermediatePayoutPerUser == _o.flightIntermediatePayoutPerUser;
}

const char *TournClientThin::publication::TournSubscr_PrizePool::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("totalRebuysDone=");
	_buf.appendUint(totalRebuysDone);
	_buf.append(',');
	_buf.append("totalAddonsDone=");
	_buf.appendUint(totalAddonsDone);
	_buf.append(',');
	_buf.append("payouts=");
	_buf.appendInt(payouts);
	_buf.append(',');
	_buf.append("flightIntermediatePayoutPrizePool=");
	_buf.appendInt(flightIntermediatePayoutPrizePool);
	_buf.append(',');
	_buf.append("flightIntermediatePayoutPerUser=");
	_buf.appendInt(flightIntermediatePayoutPerUser);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_PrizePool::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(numUsers);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeUINT32(totalRebuysDone);
	_msg.composeUINT32(totalAddonsDone);
	_msg.composeINT32(payouts);
	_msg.composeINT32(flightIntermediatePayoutPrizePool);
	_msg.composeINT32(flightIntermediatePayoutPerUser);
}

void TournClientThin::publication::TournSubscr_PrizePool::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(numUsers);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseUINT32(totalRebuysDone);
	_parser.parseUINT32(totalAddonsDone);
	_parser.parseINT32(payouts);
	_parser.parseINT32(flightIntermediatePayoutPrizePool);
	_parser.parseINT32(flightIntermediatePayoutPerUser);
}

/*static*/ void TournClientThin::publication::TournSubscr_PrizePool::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 numUsers; _parser.parseUINT32(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	UINT32 totalRebuysDone; _parser.parseUINT32(totalRebuysDone);
	AtfValidator::validateInt(_descr, "totalRebuysDone", totalRebuysDone, _checker, __FILE__, __LINE__);
	UINT32 totalAddonsDone; _parser.parseUINT32(totalAddonsDone);
	AtfValidator::validateInt(_descr, "totalAddonsDone", totalAddonsDone, _checker, __FILE__, __LINE__);
	INT32 payouts; _parser.parseINT32(payouts);
	AtfValidator::validateInt(_descr, "payouts", payouts, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPrizePool; _parser.parseINT32(flightIntermediatePayoutPrizePool);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPrizePool", flightIntermediatePayoutPrizePool, _checker, __FILE__, __LINE__);
	INT32 flightIntermediatePayoutPerUser; _parser.parseINT32(flightIntermediatePayoutPerUser);
	AtfValidator::validateInt(_descr, "flightIntermediatePayoutPerUser", flightIntermediatePayoutPerUser, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_NumRegistered
//=================================================================

TournClientThin::publication::TournSubscr_NumRegistered::TournSubscr_NumRegistered()
{
	clear();
}

void TournClientThin::publication::TournSubscr_NumRegistered::clear()
{
	userCount = 0;
	isBlitz = 0;
	numReg = 0;
	totalReentriesMade = 0;
}

bool TournClientThin::publication::TournSubscr_NumRegistered::equals(const TournSubscr_NumRegistered& _o) const
{
	return userCount == _o.userCount &&
		isBlitz == _o.isBlitz &&
		numReg == _o.numReg &&
		totalReentriesMade == _o.totalReentriesMade;
}

const char *TournClientThin::publication::TournSubscr_NumRegistered::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userCount=");
	_buf.appendUint(userCount);
	_buf.append(',');
	_buf.append("isBlitz=");
	_buf.appendUint(isBlitz);
	_buf.append(',');
	_buf.append("numReg=");
	_buf.appendUint(numReg);
	_buf.append(',');
	_buf.append("totalReentriesMade=");
	_buf.appendUint(totalReentriesMade);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_NumRegistered::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(userCount);
	_msg.composeUINT32(isBlitz);
	_msg.composeUINT32(numReg);
	_msg.composeUINT32(totalReentriesMade);
}

void TournClientThin::publication::TournSubscr_NumRegistered::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userCount);
	_parser.parseUINT32(isBlitz);
	_parser.parseUINT32(numReg);
	_parser.parseUINT32(totalReentriesMade);
}

/*static*/ void TournClientThin::publication::TournSubscr_NumRegistered::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 userCount; _parser.parseUINT32(userCount);
	AtfValidator::validateInt(_descr, "userCount", userCount, _checker, __FILE__, __LINE__);
	UINT32 isBlitz; _parser.parseUINT32(isBlitz);
	AtfValidator::validateInt(_descr, "isBlitz", isBlitz, _checker, __FILE__, __LINE__);
	UINT32 numReg; _parser.parseUINT32(numReg);
	AtfValidator::validateInt(_descr, "numReg", numReg, _checker, __FILE__, __LINE__);
	UINT32 totalReentriesMade; _parser.parseUINT32(totalReentriesMade);
	AtfValidator::validateInt(_descr, "totalReentriesMade", totalReentriesMade, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_AwardsPrelim
//=================================================================

TournClientThin::publication::TournSubscr_AwardsPrelim::TournSubscr_AwardsPrelim()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_AwardsPrelim::TournSubscr_AwardsPrelim(TournSubscr_AwardsPrelim&& _o)
	: prelimAwards(std::move(_o.prelimAwards))
	, numPaid(std::move(_o.numPaid))
	, numTickets(std::move(_o.numTickets))
	, awardRanges(std::move(_o.awardRanges))
{
}

TournClientThin::publication::TournSubscr_AwardsPrelim& TournClientThin::publication::TournSubscr_AwardsPrelim::operator=(TournSubscr_AwardsPrelim&& _o)
{
	if(this != &_o)
	{
		prelimAwards = std::move(_o.prelimAwards);
		numPaid = std::move(_o.numPaid);
		numTickets = std::move(_o.numTickets);
		awardRanges = std::move(_o.awardRanges);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_AwardsPrelim::clear()
{
	prelimAwards = 0;
	numPaid = 0;
	numTickets = 0;
	awardRanges.clear();
}

bool TournClientThin::publication::TournSubscr_AwardsPrelim::equals(const TournSubscr_AwardsPrelim& _o) const
{
	return prelimAwards == _o.prelimAwards &&
		numPaid == _o.numPaid &&
		numTickets == _o.numTickets &&
		awardRanges.equals(_o.awardRanges);
}

const char *TournClientThin::publication::TournSubscr_AwardsPrelim::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prelimAwards=");
	_buf.appendUint(prelimAwards);
	_buf.append(',');
	_buf.append("numPaid=");
	_buf.appendUint(numPaid);
	_buf.append(',');
	_buf.append("numTickets=");
	_buf.appendUint(numTickets);
	_buf.append(',');
	_buf.append("awardRanges=");
	awardRanges.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_AwardsPrelim::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(prelimAwards);
	_msg.composeUINT32(numPaid);
	_msg.composeUINT32(numTickets);
	awardRanges.composeMsg(_msg);
}

void TournClientThin::publication::TournSubscr_AwardsPrelim::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(prelimAwards);
	_parser.parseUINT32(numPaid);
	_parser.parseUINT32(numTickets);
	awardRanges.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournSubscr_AwardsPrelim::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 prelimAwards; _parser.parseUINT32(prelimAwards);
	AtfValidator::validateInt(_descr, "prelimAwards", prelimAwards, _checker, __FILE__, __LINE__);
	UINT32 numPaid; _parser.parseUINT32(numPaid);
	AtfValidator::validateInt(_descr, "numPaid", numPaid, _checker, __FILE__, __LINE__);
	UINT32 numTickets; _parser.parseUINT32(numTickets);
	AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAwardRanges = ThinAtf::LAtfVector< P_AwardRange, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("awardRanges"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "awardRanges", szAwardRanges, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_TableBanner
//=================================================================

TournClientThin::publication::TournSubscr_TableBanner::TournSubscr_TableBanner()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_TableBanner::TournSubscr_TableBanner(TournSubscr_TableBanner&& _o)
	: counter(std::move(_o.counter))
	, duration(std::move(_o.duration))
	, options(std::move(_o.options))
	, banner(std::move(_o.banner))
	, when(std::move(_o.when))
	, flags(std::move(_o.flags))
	, licenseMask(std::move(_o.licenseMask))
	, observerBanner(std::move(_o.observerBanner))
	, licenseMaskNew(std::move(_o.licenseMaskNew))
{
}

TournClientThin::publication::TournSubscr_TableBanner& TournClientThin::publication::TournSubscr_TableBanner::operator=(TournSubscr_TableBanner&& _o)
{
	if(this != &_o)
	{
		counter = std::move(_o.counter);
		duration = std::move(_o.duration);
		options = std::move(_o.options);
		banner = std::move(_o.banner);
		when = std::move(_o.when);
		flags = std::move(_o.flags);
		licenseMask = std::move(_o.licenseMask);
		observerBanner = std::move(_o.observerBanner);
		licenseMaskNew = std::move(_o.licenseMaskNew);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_TableBanner::clear()
{
	counter = 0;
	duration = 0;
	options = 0;
	banner.clear();
	when.setNull();
	flags = 0;
	licenseMask = 0;
	observerBanner.clear();
	licenseMaskNew.clear();
}

bool TournClientThin::publication::TournSubscr_TableBanner::equals(const TournSubscr_TableBanner& _o) const
{
	return counter == _o.counter &&
		duration == _o.duration &&
		options == _o.options &&
		banner.equals(_o.banner) &&
		when.equals(_o.when) &&
		flags == _o.flags &&
		licenseMask == _o.licenseMask &&
		observerBanner.equals(_o.observerBanner) &&
		licenseMaskNew.equals(_o.licenseMaskNew);
}

const char *TournClientThin::publication::TournSubscr_TableBanner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("counter=");
	_buf.appendUint(counter);
	_buf.append(',');
	_buf.append("duration=");
	_buf.appendUint(duration);
	_buf.append(',');
	_buf.append("options=");
	_buf.appendInt(options);
	_buf.append(',');
	_buf.append("banner=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, banner);
	_buf.append(',');
	_buf.append("when=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("licenseMask=");
	_buf.appendUint(licenseMask);
	_buf.append(',');
	_buf.append("observerBanner=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, observerBanner);
	_buf.append(',');
	_buf.append("licenseMaskNew=");
	licenseMaskNew.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_TableBanner::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(counter);
	_msg.composeUINT16(duration);
	_msg.composeINT32(options);
	banner.compose(_msg);
	_msg.composeSrvTime(when);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(licenseMask);
	observerBanner.compose(_msg);
	licenseMaskNew.composeMsg(_msg);
}

void TournClientThin::publication::TournSubscr_TableBanner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(counter);
	_parser.parseUINT16(duration);
	_parser.parseINT32(options);
	banner.parse(_parser);
	_parser.parseSrvTime(when);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(licenseMask);
	observerBanner.parse(_parser);
	licenseMaskNew.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournSubscr_TableBanner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 counter; _parser.parseUINT32(counter);
	AtfValidator::validateInt(_descr, "counter", counter, _checker, __FILE__, __LINE__);
	UINT16 duration; _parser.parseUINT16(duration);
	AtfValidator::validateInt(_descr, "duration", duration, _checker, __FILE__, __LINE__);
	INT32 options; _parser.parseINT32(options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
	I18nPString banner; banner.parse(_parser);
	SrvTime when; _parser.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 licenseMask; _parser.parseUINT32(licenseMask);
	AtfValidator::validateInt(_descr, "licenseMask", licenseMask, _checker, __FILE__, __LINE__);
	I18nPString observerBanner; observerBanner.parse(_parser);
	PString _descbuf;
	PLicenseMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("licenseMaskNew"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournSubscr_HappyHours
//=================================================================

TournClientThin::publication::TournSubscr_HappyHours::TournSubscr_HappyHours()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_HappyHours::TournSubscr_HappyHours(TournSubscr_HappyHours&& _o)
	: happyHourMultipliers(std::move(_o.happyHourMultipliers))
{
}

TournClientThin::publication::TournSubscr_HappyHours& TournClientThin::publication::TournSubscr_HappyHours::operator=(TournSubscr_HappyHours&& _o)
{
	if(this != &_o)
	{
		happyHourMultipliers = std::move(_o.happyHourMultipliers);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_HappyHours::clear()
{
	happyHourMultipliers.clear();
}

bool TournClientThin::publication::TournSubscr_HappyHours::equals(const TournSubscr_HappyHours& _o) const
{
	return happyHourMultipliers.equals(_o.happyHourMultipliers);
}

const char *TournClientThin::publication::TournSubscr_HappyHours::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("happyHourMultipliers=");
	happyHourMultipliers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_HappyHours::composeMsg(CommMsgBody& _msg) const
{
	happyHourMultipliers.composeMsg(_msg);
}

void TournClientThin::publication::TournSubscr_HappyHours::parseMsg(CommMsgParser& _parser)
{
	happyHourMultipliers.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournSubscr_HappyHours::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szHappyHourMultipliers = ThinAtf::LAtfVector< FppFactor, 2 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("happyHourMultipliers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "happyHourMultipliers", szHappyHourMultipliers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_HandByHand
//=================================================================

TournClientThin::publication::TournSubscr_HandByHand::TournSubscr_HandByHand()
{
	clear();
}

void TournClientThin::publication::TournSubscr_HandByHand::clear()
{
	handByHand = false;
}

bool TournClientThin::publication::TournSubscr_HandByHand::equals(const TournSubscr_HandByHand& _o) const
{
	return handByHand == _o.handByHand;
}

const char *TournClientThin::publication::TournSubscr_HandByHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handByHand=");
	_buf.appendUint(handByHand);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_HandByHand::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(handByHand);
}

void TournClientThin::publication::TournSubscr_HandByHand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(handByHand);
}

/*static*/ void TournClientThin::publication::TournSubscr_HandByHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool handByHand; _parser.parseBOOL(handByHand);
	AtfValidator::validateInt(_descr, "handByHand", handByHand, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Bounty
//=================================================================

TournClientThin::publication::TournSubscr_Bounty::TournSubscr_Bounty()
{
	clear();
}

void TournClientThin::publication::TournSubscr_Bounty::clear()
{
	minBounty = 0;
	maxBounty = 0;
	averageBounty = 0;
}

bool TournClientThin::publication::TournSubscr_Bounty::equals(const TournSubscr_Bounty& _o) const
{
	return minBounty == _o.minBounty &&
		maxBounty == _o.maxBounty &&
		averageBounty == _o.averageBounty;
}

const char *TournClientThin::publication::TournSubscr_Bounty::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minBounty=");
	_buf.appendInt(minBounty);
	_buf.append(',');
	_buf.append("maxBounty=");
	_buf.appendInt(maxBounty);
	_buf.append(',');
	_buf.append("averageBounty=");
	_buf.appendInt(averageBounty);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Bounty::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(minBounty);
	_msg.composeINT32(maxBounty);
	_msg.composeINT32(averageBounty);
}

void TournClientThin::publication::TournSubscr_Bounty::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(minBounty);
	_parser.parseINT32(maxBounty);
	_parser.parseINT32(averageBounty);
}

/*static*/ void TournClientThin::publication::TournSubscr_Bounty::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 minBounty; _parser.parseINT32(minBounty);
	AtfValidator::validateInt(_descr, "minBounty", minBounty, _checker, __FILE__, __LINE__);
	INT32 maxBounty; _parser.parseINT32(maxBounty);
	AtfValidator::validateInt(_descr, "maxBounty", maxBounty, _checker, __FILE__, __LINE__);
	INT32 averageBounty; _parser.parseINT32(averageBounty);
	AtfValidator::validateInt(_descr, "averageBounty", averageBounty, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Golden
//=================================================================

TournClientThin::publication::TournSubscr_Golden::TournSubscr_Golden()
{
	clear();
}

void TournClientThin::publication::TournSubscr_Golden::clear()
{
	goldenSnGBuyinAddon = 0;
	goldenSnGPrizepoolAddon = 0;
	goldenSnGPrizepoolMultiplier = 0;
	goldenSnGEligible = false;
	ppAddonForClient = 0;
	goldenSnGPrizepoolEffectiveMultiplier1 = 0;
	goldenSnGMilestoneAddon = 0;
	goldenSnGPrizepoolEffectiveMultiplier2 = 0;
	goldenSnGStartTime = 0;
}

bool TournClientThin::publication::TournSubscr_Golden::equals(const TournSubscr_Golden& _o) const
{
	return goldenSnGBuyinAddon == _o.goldenSnGBuyinAddon &&
		goldenSnGPrizepoolAddon == _o.goldenSnGPrizepoolAddon &&
		goldenSnGPrizepoolMultiplier == _o.goldenSnGPrizepoolMultiplier &&
		goldenSnGEligible == _o.goldenSnGEligible &&
		ppAddonForClient == _o.ppAddonForClient &&
		goldenSnGPrizepoolEffectiveMultiplier1 == _o.goldenSnGPrizepoolEffectiveMultiplier1 &&
		goldenSnGMilestoneAddon == _o.goldenSnGMilestoneAddon &&
		goldenSnGPrizepoolEffectiveMultiplier2 == _o.goldenSnGPrizepoolEffectiveMultiplier2 &&
		goldenSnGStartTime == _o.goldenSnGStartTime;
}

const char *TournClientThin::publication::TournSubscr_Golden::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("goldenSnGBuyinAddon=");
	_buf.appendInt(goldenSnGBuyinAddon);
	_buf.append(',');
	_buf.append("goldenSnGPrizepoolAddon=");
	_buf.appendInt(goldenSnGPrizepoolAddon);
	_buf.append(',');
	_buf.append("goldenSnGPrizepoolMultiplier=");
	_buf.appendInt(goldenSnGPrizepoolMultiplier);
	_buf.append(',');
	_buf.append("goldenSnGEligible=");
	_buf.appendUint(goldenSnGEligible);
	_buf.append(',');
	_buf.append("ppAddonForClient=");
	_buf.appendInt(ppAddonForClient);
	_buf.append(',');
	_buf.append("goldenSnGPrizepoolEffectiveMultiplier1=");
	_buf.appendInt(goldenSnGPrizepoolEffectiveMultiplier1);
	_buf.append(',');
	_buf.append("goldenSnGMilestoneAddon=");
	_buf.appendInt(goldenSnGMilestoneAddon);
	_buf.append(',');
	_buf.append("goldenSnGPrizepoolEffectiveMultiplier2=");
	_buf.appendInt64(goldenSnGPrizepoolEffectiveMultiplier2);
	_buf.append(',');
	_buf.append("goldenSnGStartTime=");
	_buf.appendInt(goldenSnGStartTime);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Golden::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(goldenSnGBuyinAddon);
	_msg.composeINT32(goldenSnGPrizepoolAddon);
	_msg.composeINT16(goldenSnGPrizepoolMultiplier);
	_msg.composeBOOL(goldenSnGEligible);
	_msg.composeINT32(ppAddonForClient);
	_msg.composeINT32(goldenSnGPrizepoolEffectiveMultiplier1);
	_msg.composeINT32(goldenSnGMilestoneAddon);
	_msg.composeINT64(goldenSnGPrizepoolEffectiveMultiplier2);
	_msg.composeINT32(goldenSnGStartTime);
}

void TournClientThin::publication::TournSubscr_Golden::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(goldenSnGBuyinAddon);
	_parser.parseINT32(goldenSnGPrizepoolAddon);
	_parser.parseINT16(goldenSnGPrizepoolMultiplier);
	_parser.parseBOOL(goldenSnGEligible);
	_parser.parseINT32(ppAddonForClient);
	_parser.parseINT32(goldenSnGPrizepoolEffectiveMultiplier1);
	_parser.parseINT32(goldenSnGMilestoneAddon);
	_parser.parseINT64(goldenSnGPrizepoolEffectiveMultiplier2);
	_parser.parseINT32(goldenSnGStartTime);
}

/*static*/ void TournClientThin::publication::TournSubscr_Golden::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 goldenSnGBuyinAddon; _parser.parseINT32(goldenSnGBuyinAddon);
	AtfValidator::validateInt(_descr, "goldenSnGBuyinAddon", goldenSnGBuyinAddon, _checker, __FILE__, __LINE__);
	INT32 goldenSnGPrizepoolAddon; _parser.parseINT32(goldenSnGPrizepoolAddon);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolAddon", goldenSnGPrizepoolAddon, _checker, __FILE__, __LINE__);
	INT16 goldenSnGPrizepoolMultiplier; _parser.parseINT16(goldenSnGPrizepoolMultiplier);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolMultiplier", goldenSnGPrizepoolMultiplier, _checker, __FILE__, __LINE__);
	bool goldenSnGEligible; _parser.parseBOOL(goldenSnGEligible);
	AtfValidator::validateInt(_descr, "goldenSnGEligible", goldenSnGEligible, _checker, __FILE__, __LINE__);
	INT32 ppAddonForClient; _parser.parseINT32(ppAddonForClient);
	AtfValidator::validateInt(_descr, "ppAddonForClient", ppAddonForClient, _checker, __FILE__, __LINE__);
	INT32 goldenSnGPrizepoolEffectiveMultiplier1; _parser.parseINT32(goldenSnGPrizepoolEffectiveMultiplier1);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolEffectiveMultiplier1", goldenSnGPrizepoolEffectiveMultiplier1, _checker, __FILE__, __LINE__);
	INT32 goldenSnGMilestoneAddon; _parser.parseINT32(goldenSnGMilestoneAddon);
	AtfValidator::validateInt(_descr, "goldenSnGMilestoneAddon", goldenSnGMilestoneAddon, _checker, __FILE__, __LINE__);
	INT64 goldenSnGPrizepoolEffectiveMultiplier2; _parser.parseINT64(goldenSnGPrizepoolEffectiveMultiplier2);
	AtfValidator::validateInt(_descr, "goldenSnGPrizepoolEffectiveMultiplier2", goldenSnGPrizepoolEffectiveMultiplier2, _checker, __FILE__, __LINE__);
	INT32 goldenSnGStartTime; _parser.parseINT32(goldenSnGStartTime);
	AtfValidator::validateInt(_descr, "goldenSnGStartTime", goldenSnGStartTime, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_Autopublish
//=================================================================

TournClientThin::publication::TournSubscr_Autopublish::TournSubscr_Autopublish()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_Autopublish::TournSubscr_Autopublish(TournSubscr_Autopublish&& _o)
	: autoPublishBodies(std::move(_o.autoPublishBodies))
{
}

TournClientThin::publication::TournSubscr_Autopublish& TournClientThin::publication::TournSubscr_Autopublish::operator=(TournSubscr_Autopublish&& _o)
{
	if(this != &_o)
	{
		autoPublishBodies = std::move(_o.autoPublishBodies);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_Autopublish::clear()
{
	autoPublishBodies.clear();
}

bool TournClientThin::publication::TournSubscr_Autopublish::equals(const TournSubscr_Autopublish& _o) const
{
	return autoPublishBodies.equals(_o.autoPublishBodies);
}

const char *TournClientThin::publication::TournSubscr_Autopublish::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("autoPublishBodies=");
	autoPublishBodies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_Autopublish::composeMsg(CommMsgBody& _msg) const
{
	autoPublishBodies.composeMsg(_msg);
}

void TournClientThin::publication::TournSubscr_Autopublish::parseMsg(CommMsgParser& _parser)
{
	autoPublishBodies.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournSubscr_Autopublish::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szAutoPublishBodies = ThinAtf::LAtfVector< P_AutopublishBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("autoPublishBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "autoPublishBodies", szAutoPublishBodies, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PrizePoolUnit
//=================================================================

TournClientThin::publication::TournSubscr_PrizePoolUnit::TournSubscr_PrizePoolUnit()
{
	clear();
}

void TournClientThin::publication::TournSubscr_PrizePoolUnit::clear()
{
	prizePoolUnit = 0;
	prizePoolToPublish = 0;
	prizePoolMoneyToPublish = 0;
}

bool TournClientThin::publication::TournSubscr_PrizePoolUnit::equals(const TournSubscr_PrizePoolUnit& _o) const
{
	return prizePoolUnit == _o.prizePoolUnit &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish;
}

const char *TournClientThin::publication::TournSubscr_PrizePoolUnit::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendInt(prizePoolMoneyToPublish);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_PrizePoolUnit::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(prizePoolUnit);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeINT32(prizePoolMoneyToPublish);
}

void TournClientThin::publication::TournSubscr_PrizePoolUnit::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(prizePoolUnit);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseINT32(prizePoolMoneyToPublish);
}

/*static*/ void TournClientThin::publication::TournSubscr_PrizePoolUnit::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	INT32 prizePoolMoneyToPublish; _parser.parseINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_OptEarlyStart
//=================================================================

TournClientThin::publication::TournSubscr_OptEarlyStart::TournSubscr_OptEarlyStart()
{
	clear();
}

void TournClientThin::publication::TournSubscr_OptEarlyStart::clear()
{
	options = 0;
}

bool TournClientThin::publication::TournSubscr_OptEarlyStart::equals(const TournSubscr_OptEarlyStart& _o) const
{
	return options == _o.options;
}

const char *TournClientThin::publication::TournSubscr_OptEarlyStart::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("options=");
	_buf.appendUint(options);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_OptEarlyStart::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(options);
}

void TournClientThin::publication::TournSubscr_OptEarlyStart::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(options);
}

/*static*/ void TournClientThin::publication::TournSubscr_OptEarlyStart::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE options; _parser.parseBYTE(options);
	AtfValidator::validateInt(_descr, "options", options, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_NextMilestoneEvent
//=================================================================

TournClientThin::publication::TournSubscr_NextMilestoneEvent::TournSubscr_NextMilestoneEvent()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_NextMilestoneEvent::TournSubscr_NextMilestoneEvent(TournSubscr_NextMilestoneEvent&& _o)
	: indicator(std::move(_o.indicator))
	, firstMilestone(std::move(_o.firstMilestone))
	, nextMilestone(std::move(_o.nextMilestone))
	, tables(std::move(_o.tables))
	, prize(std::move(_o.prize))
{
}

TournClientThin::publication::TournSubscr_NextMilestoneEvent& TournClientThin::publication::TournSubscr_NextMilestoneEvent::operator=(TournSubscr_NextMilestoneEvent&& _o)
{
	if(this != &_o)
	{
		indicator = std::move(_o.indicator);
		firstMilestone = std::move(_o.firstMilestone);
		nextMilestone = std::move(_o.nextMilestone);
		tables = std::move(_o.tables);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_NextMilestoneEvent::clear()
{
	indicator = false;
	firstMilestone = 0;
	nextMilestone = 0;
	tables = 0;
	prize.clear();
}

bool TournClientThin::publication::TournSubscr_NextMilestoneEvent::equals(const TournSubscr_NextMilestoneEvent& _o) const
{
	return indicator == _o.indicator &&
		firstMilestone == _o.firstMilestone &&
		nextMilestone == _o.nextMilestone &&
		tables == _o.tables &&
		prize.equals(_o.prize);
}

const char *TournClientThin::publication::TournSubscr_NextMilestoneEvent::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("indicator=");
	_buf.appendUint(indicator);
	_buf.append(',');
	_buf.append("firstMilestone=");
	_buf.appendUint(firstMilestone);
	_buf.append(',');
	_buf.append("nextMilestone=");
	_buf.appendUint(nextMilestone);
	_buf.append(',');
	_buf.append("tables=");
	_buf.appendUint(tables);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_NextMilestoneEvent::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(indicator);
	_msg.composeUINT32(firstMilestone);
	_msg.composeUINT32(nextMilestone);
	_msg.composeUINT32(tables);
	prize.composeMsg(_msg);
}

void TournClientThin::publication::TournSubscr_NextMilestoneEvent::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(indicator);
	_parser.parseUINT32(firstMilestone);
	_parser.parseUINT32(nextMilestone);
	_parser.parseUINT32(tables);
	prize.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournSubscr_NextMilestoneEvent::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool indicator; _parser.parseBOOL(indicator);
	AtfValidator::validateInt(_descr, "indicator", indicator, _checker, __FILE__, __LINE__);
	UINT32 firstMilestone; _parser.parseUINT32(firstMilestone);
	AtfValidator::validateInt(_descr, "firstMilestone", firstMilestone, _checker, __FILE__, __LINE__);
	UINT32 nextMilestone; _parser.parseUINT32(nextMilestone);
	AtfValidator::validateInt(_descr, "nextMilestone", nextMilestone, _checker, __FILE__, __LINE__);
	UINT32 tables; _parser.parseUINT32(tables);
	AtfValidator::validateInt(_descr, "tables", tables, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TournMileStonePrize::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournSubscr_SpinGoPrize_Vector
//=================================================================

TournClientThin::publication::TournSubscr_SpinGoPrize_Vector::TournSubscr_SpinGoPrize_Vector()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_SpinGoPrize_Vector::TournSubscr_SpinGoPrize_Vector(TournSubscr_SpinGoPrize_Vector&& _o)
	: prizes(std::move(_o.prizes))
{
}

TournClientThin::publication::TournSubscr_SpinGoPrize_Vector& TournClientThin::publication::TournSubscr_SpinGoPrize_Vector::operator=(TournSubscr_SpinGoPrize_Vector&& _o)
{
	if(this != &_o)
	{
		prizes = std::move(_o.prizes);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_SpinGoPrize_Vector::clear()
{
	prizes.clear();
}

bool TournClientThin::publication::TournSubscr_SpinGoPrize_Vector::equals(const TournSubscr_SpinGoPrize_Vector& _o) const
{
	return prizes.equals(_o.prizes);
}

const char *TournClientThin::publication::TournSubscr_SpinGoPrize_Vector::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_SpinGoPrize_Vector::composeMsg(CommMsgBody& _msg) const
{
	prizes.composeMsg(_msg);
}

void TournClientThin::publication::TournSubscr_SpinGoPrize_Vector::parseMsg(CommMsgParser& _parser)
{
	prizes.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournSubscr_SpinGoPrize_Vector::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szPrizes = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoPrize
//=================================================================

TournClientThin::publication::TournSubscr_SpinGoPrize::TournSubscr_SpinGoPrize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_SpinGoPrize::TournSubscr_SpinGoPrize(TournSubscr_SpinGoPrize&& _o)
	: spinGoLevels(std::move(_o.spinGoLevels))
	, spinGoMarker(std::move(_o.spinGoMarker))
	, tickets(std::move(_o.tickets))
	, level(std::move(_o.level))
	, targetReferences(std::move(_o.targetReferences))
	, spinGoMaxCashout(std::move(_o.spinGoMaxCashout))
	, spinGoMaxLevels(std::move(_o.spinGoMaxLevels))
	, animationType(std::move(_o.animationType))
	, animationEndTime(std::move(_o.animationEndTime))
	, isJackpot(std::move(_o.isJackpot))
	, winner(std::move(_o.winner))
	, freeBetStake(std::move(_o.freeBetStake))
	, freeBetCurrency(std::move(_o.freeBetCurrency))
	, freeBetsCampaignId(std::move(_o.freeBetsCampaignId))
	, freeBetsCampaignId64(std::move(_o.freeBetsCampaignId64))
{
}

TournClientThin::publication::TournSubscr_SpinGoPrize& TournClientThin::publication::TournSubscr_SpinGoPrize::operator=(TournSubscr_SpinGoPrize&& _o)
{
	if(this != &_o)
	{
		spinGoLevels = std::move(_o.spinGoLevels);
		spinGoMarker = std::move(_o.spinGoMarker);
		tickets = std::move(_o.tickets);
		level = std::move(_o.level);
		targetReferences = std::move(_o.targetReferences);
		spinGoMaxCashout = std::move(_o.spinGoMaxCashout);
		spinGoMaxLevels = std::move(_o.spinGoMaxLevels);
		animationType = std::move(_o.animationType);
		animationEndTime = std::move(_o.animationEndTime);
		isJackpot = std::move(_o.isJackpot);
		winner = std::move(_o.winner);
		freeBetStake = std::move(_o.freeBetStake);
		freeBetCurrency = std::move(_o.freeBetCurrency);
		freeBetsCampaignId = std::move(_o.freeBetsCampaignId);
		freeBetsCampaignId64 = std::move(_o.freeBetsCampaignId64);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_SpinGoPrize::clear()
{
	spinGoLevels.clear();
	spinGoMarker = 0;
	tickets.clear();
	level = 0;
	targetReferences.clear();
	spinGoMaxCashout = 0;
	spinGoMaxLevels.clear();
	animationType = 0;
	animationEndTime.setNull();
	isJackpot = false;
	winner.clear();
	freeBetStake = 0;
	freeBetCurrency.clear();
	freeBetsCampaignId = 0;
	freeBetsCampaignId64 = 0;
}

bool TournClientThin::publication::TournSubscr_SpinGoPrize::equals(const TournSubscr_SpinGoPrize& _o) const
{
	return spinGoLevels.equals(_o.spinGoLevels) &&
		spinGoMarker == _o.spinGoMarker &&
		tickets.equals(_o.tickets) &&
		level == _o.level &&
		targetReferences.equals(_o.targetReferences) &&
		spinGoMaxCashout == _o.spinGoMaxCashout &&
		spinGoMaxLevels.equals(_o.spinGoMaxLevels) &&
		animationType == _o.animationType &&
		animationEndTime.equals(_o.animationEndTime) &&
		isJackpot == _o.isJackpot &&
		winner.equals(_o.winner) &&
		freeBetStake == _o.freeBetStake &&
		freeBetCurrency.equals(_o.freeBetCurrency) &&
		freeBetsCampaignId == _o.freeBetsCampaignId &&
		freeBetsCampaignId64 == _o.freeBetsCampaignId64;
}

const char *TournClientThin::publication::TournSubscr_SpinGoPrize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("spinGoLevels=");
	spinGoLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("spinGoMarker=");
	_buf.appendUint(spinGoMarker);
	_buf.append(',');
	_buf.append("tickets=");
	tickets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("level=");
	_buf.appendUint(level);
	_buf.append(',');
	_buf.append("targetReferences=");
	targetReferences.toTraceString(_buf);
	_buf.append(',');
	_buf.append("spinGoMaxCashout=");
	_buf.appendInt(spinGoMaxCashout);
	_buf.append(',');
	_buf.append("spinGoMaxLevels=");
	spinGoMaxLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("animationType=");
	_buf.appendUint(animationType);
	_buf.append(',');
	_buf.append("animationEndTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, animationEndTime);
	_buf.append(',');
	_buf.append("isJackpot=");
	_buf.appendUint(isJackpot);
	_buf.append(',');
	_buf.append("winner=");
	_buf.append(winner);
	_buf.append(',');
	_buf.append("freeBetStake=");
	_buf.appendInt(freeBetStake);
	_buf.append(',');
	_buf.append("freeBetCurrency=");
	_buf.append(freeBetCurrency);
	_buf.append(',');
	_buf.append("freeBetsCampaignId=");
	_buf.appendUint(freeBetsCampaignId);
	_buf.append(',');
	_buf.append("freeBetsCampaignId64=");
	_buf.appendUint64(freeBetsCampaignId64);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_SpinGoPrize::composeMsg(CommMsgBody& _msg) const
{
	spinGoLevels.composeMsg(_msg);
	_msg.composeUINT32(spinGoMarker);
	tickets.composeMsg(_msg);
	_msg.composeUINT32(level);
	targetReferences.composeMsg(_msg);
	_msg.composeINT32(spinGoMaxCashout);
	spinGoMaxLevels.composeMsg(_msg);
	_msg.composeUINT32(animationType);
	_msg.composeSrvTime(animationEndTime);
	_msg.composeBOOL(isJackpot);
	_msg.composeString(winner);
	_msg.composeINT32(freeBetStake);
	_msg.composeString(freeBetCurrency);
	_msg.composeUINT32(freeBetsCampaignId);
	_msg.composeUINT64(freeBetsCampaignId64);
}

void TournClientThin::publication::TournSubscr_SpinGoPrize::parseMsg(CommMsgParser& _parser)
{
	spinGoLevels.parseMsg(_parser);
	_parser.parseUINT32(spinGoMarker);
	tickets.parseMsg(_parser);
	_parser.parseUINT32(level);
	targetReferences.parseMsg(_parser);
	_parser.parseINT32(spinGoMaxCashout);
	spinGoMaxLevels.parseMsg(_parser);
	_parser.parseUINT32(animationType);
	_parser.parseSrvTime(animationEndTime);
	_parser.parseBOOL(isJackpot);
	_parser.parseStringP(winner);
	_parser.parseINT32(freeBetStake);
	_parser.parseStringP(freeBetCurrency);
	_parser.parseUINT32(freeBetsCampaignId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(freeBetsCampaignId64);
}

/*static*/ void TournClientThin::publication::TournSubscr_SpinGoPrize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	PString _descbuf;
	int szSpinGoLevels = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("spinGoLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinGoLevels", szSpinGoLevels, _checker, __FILE__, __LINE__);
	UINT32 spinGoMarker; _parser.parseUINT32(spinGoMarker);
	AtfValidator::validateInt(_descr, "spinGoMarker", spinGoMarker, _checker, __FILE__, __LINE__);
	int szTickets = ThinAtf::LAtfVector< I18nPString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	UINT32 level; _parser.parseUINT32(level);
	AtfValidator::validateInt(_descr, "level", level, _checker, __FILE__, __LINE__);
	int szTargetReferences = ThinAtf::LAtfVector< TournSubscr_SpinGoPrize_TargetReference, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("targetReferences"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "targetReferences", szTargetReferences, _checker, __FILE__, __LINE__);
	INT32 spinGoMaxCashout; _parser.parseINT32(spinGoMaxCashout);
	AtfValidator::validateInt(_descr, "spinGoMaxCashout", spinGoMaxCashout, _checker, __FILE__, __LINE__);
	int szSpinGoMaxLevels = ThinAtf::LAtfVector< TournSubscr_SpinGoPrize_Vector, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("spinGoMaxLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "spinGoMaxLevels", szSpinGoMaxLevels, _checker, __FILE__, __LINE__);
	UINT32 animationType; _parser.parseUINT32(animationType);
	AtfValidator::validateInt(_descr, "animationType", animationType, _checker, __FILE__, __LINE__);
	SrvTime animationEndTime; _parser.parseSrvTime(animationEndTime);
	AtfValidator::validateSrvDateTime(_descr, "animationEndTime", animationEndTime, _checker, __FILE__, __LINE__);
	bool isJackpot; _parser.parseBOOL(isJackpot);
	AtfValidator::validateInt(_descr, "isJackpot", isJackpot, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "winner"); size_t szWinner = strlen(_dummy);
	AtfValidator::validateInt(_descr, "winner", szWinner, _checker, __FILE__, __LINE__);
	INT32 freeBetStake; _parser.parseINT32(freeBetStake);
	AtfValidator::validateInt(_descr, "freeBetStake", freeBetStake, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "freeBetCurrency"); size_t szFreeBetCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "freeBetCurrency", szFreeBetCurrency, _checker, __FILE__, __LINE__);
	UINT32 freeBetsCampaignId; _parser.parseUINT32(freeBetsCampaignId);
	AtfValidator::validateInt(_descr, "freeBetsCampaignId", freeBetsCampaignId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 freeBetsCampaignId64; _parser.parseUINT64(freeBetsCampaignId64);
	AtfValidator::validateUint(_descr, "freeBetsCampaignId64", freeBetsCampaignId64, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_PerHand
//=================================================================

TournClientThin::publication::TournSubscr_PerHand::TournSubscr_PerHand()
{
	clear();
}

void TournClientThin::publication::TournSubscr_PerHand::clear()
{
	intervalInHands = false;
	currentHandInLevel = 0;
	totalHandsInLevel = 0;
	handsUntilAllInLevel = 0;
}

bool TournClientThin::publication::TournSubscr_PerHand::equals(const TournSubscr_PerHand& _o) const
{
	return intervalInHands == _o.intervalInHands &&
		currentHandInLevel == _o.currentHandInLevel &&
		totalHandsInLevel == _o.totalHandsInLevel &&
		handsUntilAllInLevel == _o.handsUntilAllInLevel;
}

const char *TournClientThin::publication::TournSubscr_PerHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("intervalInHands=");
	_buf.appendUint(intervalInHands);
	_buf.append(',');
	_buf.append("currentHandInLevel=");
	_buf.appendInt(currentHandInLevel);
	_buf.append(',');
	_buf.append("totalHandsInLevel=");
	_buf.appendInt(totalHandsInLevel);
	_buf.append(',');
	_buf.append("handsUntilAllInLevel=");
	_buf.appendInt(handsUntilAllInLevel);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_PerHand::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(intervalInHands);
	_msg.composeINT32(currentHandInLevel);
	_msg.composeINT32(totalHandsInLevel);
	_msg.composeINT32(handsUntilAllInLevel);
}

void TournClientThin::publication::TournSubscr_PerHand::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(intervalInHands);
	_parser.parseINT32(currentHandInLevel);
	_parser.parseINT32(totalHandsInLevel);
	_parser.parseINT32(handsUntilAllInLevel);
}

/*static*/ void TournClientThin::publication::TournSubscr_PerHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool intervalInHands; _parser.parseBOOL(intervalInHands);
	AtfValidator::validateInt(_descr, "intervalInHands", intervalInHands, _checker, __FILE__, __LINE__);
	INT32 currentHandInLevel; _parser.parseINT32(currentHandInLevel);
	AtfValidator::validateInt(_descr, "currentHandInLevel", currentHandInLevel, _checker, __FILE__, __LINE__);
	INT32 totalHandsInLevel; _parser.parseINT32(totalHandsInLevel);
	AtfValidator::validateInt(_descr, "totalHandsInLevel", totalHandsInLevel, _checker, __FILE__, __LINE__);
	INT32 handsUntilAllInLevel; _parser.parseINT32(handsUntilAllInLevel);
	AtfValidator::validateInt(_descr, "handsUntilAllInLevel", handsUntilAllInLevel, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_BeatTheClock
//=================================================================

TournClientThin::publication::TournSubscr_BeatTheClock::TournSubscr_BeatTheClock()
{
	clear();
}

void TournClientThin::publication::TournSubscr_BeatTheClock::clear()
{
	btcStartAnimation = 0;
}

bool TournClientThin::publication::TournSubscr_BeatTheClock::equals(const TournSubscr_BeatTheClock& _o) const
{
	return btcStartAnimation == _o.btcStartAnimation;
}

const char *TournClientThin::publication::TournSubscr_BeatTheClock::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("btcStartAnimation=");
	_buf.appendInt(btcStartAnimation);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_BeatTheClock::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(btcStartAnimation);
}

void TournClientThin::publication::TournSubscr_BeatTheClock::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(btcStartAnimation);
}

/*static*/ void TournClientThin::publication::TournSubscr_BeatTheClock::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT16 btcStartAnimation; _parser.parseINT16(btcStartAnimation);
	AtfValidator::validateInt(_descr, "btcStartAnimation", btcStartAnimation, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSubscr_SpinGoSpinner
//=================================================================

TournClientThin::publication::TournSubscr_SpinGoSpinner::TournSubscr_SpinGoSpinner()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSubscr_SpinGoSpinner::TournSubscr_SpinGoSpinner(TournSubscr_SpinGoSpinner&& _o)
	: time(std::move(_o.time))
	, choice(std::move(_o.choice))
	, spinner1(std::move(_o.spinner1))
	, spinner2(std::move(_o.spinner2))
	, spinner3(std::move(_o.spinner3))
	, cashout(std::move(_o.cashout))
	, timeout(std::move(_o.timeout))
	, spinnerStr(std::move(_o.spinnerStr))
{
}

TournClientThin::publication::TournSubscr_SpinGoSpinner& TournClientThin::publication::TournSubscr_SpinGoSpinner::operator=(TournSubscr_SpinGoSpinner&& _o)
{
	if(this != &_o)
	{
		time = std::move(_o.time);
		choice = std::move(_o.choice);
		spinner1 = std::move(_o.spinner1);
		spinner2 = std::move(_o.spinner2);
		spinner3 = std::move(_o.spinner3);
		cashout = std::move(_o.cashout);
		timeout = std::move(_o.timeout);
		spinnerStr = std::move(_o.spinnerStr);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSubscr_SpinGoSpinner::clear()
{
	time.setNull();
	choice = 0;
	spinner1 = 0;
	spinner2 = 0;
	spinner3 = 0;
	cashout = 0;
	timeout = false;
	spinnerStr.clear();
}

bool TournClientThin::publication::TournSubscr_SpinGoSpinner::equals(const TournSubscr_SpinGoSpinner& _o) const
{
	return time.equals(_o.time) &&
		choice == _o.choice &&
		spinner1 == _o.spinner1 &&
		spinner2 == _o.spinner2 &&
		spinner3 == _o.spinner3 &&
		cashout == _o.cashout &&
		timeout == _o.timeout &&
		spinnerStr.equals(_o.spinnerStr);
}

const char *TournClientThin::publication::TournSubscr_SpinGoSpinner::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("time=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, time);
	_buf.append(',');
	_buf.append("choice=");
	_buf.appendInt(choice);
	_buf.append(',');
	_buf.append("spinner1=");
	_buf.appendInt(spinner1);
	_buf.append(',');
	_buf.append("spinner2=");
	_buf.appendInt(spinner2);
	_buf.append(',');
	_buf.append("spinner3=");
	_buf.appendInt(spinner3);
	_buf.append(',');
	_buf.append("cashout=");
	_buf.appendInt(cashout);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendUint(timeout);
	_buf.append(',');
	_buf.append("spinnerStr=");
	_buf.append(spinnerStr);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSubscr_SpinGoSpinner::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(time);
	_msg.composeINT32(choice);
	_msg.composeINT32(spinner1);
	_msg.composeINT32(spinner2);
	_msg.composeINT32(spinner3);
	_msg.composeINT32(cashout);
	_msg.composeBOOL(timeout);
	_msg.composeString(spinnerStr);
}

void TournClientThin::publication::TournSubscr_SpinGoSpinner::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(time);
	_parser.parseINT32(choice);
	_parser.parseINT32(spinner1);
	_parser.parseINT32(spinner2);
	_parser.parseINT32(spinner3);
	_parser.parseINT32(cashout);
	_parser.parseBOOL(timeout);
	_parser.parseStringP(spinnerStr);
}

/*static*/ void TournClientThin::publication::TournSubscr_SpinGoSpinner::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	SrvTime time; _parser.parseSrvTime(time);
	AtfValidator::validateSrvDateTime(_descr, "time", time, _checker, __FILE__, __LINE__);
	INT32 choice; _parser.parseINT32(choice);
	AtfValidator::validateInt(_descr, "choice", choice, _checker, __FILE__, __LINE__);
	INT32 spinner1; _parser.parseINT32(spinner1);
	AtfValidator::validateInt(_descr, "spinner1", spinner1, _checker, __FILE__, __LINE__);
	INT32 spinner2; _parser.parseINT32(spinner2);
	AtfValidator::validateInt(_descr, "spinner2", spinner2, _checker, __FILE__, __LINE__);
	INT32 spinner3; _parser.parseINT32(spinner3);
	AtfValidator::validateInt(_descr, "spinner3", spinner3, _checker, __FILE__, __LINE__);
	INT32 cashout; _parser.parseINT32(cashout);
	AtfValidator::validateInt(_descr, "cashout", cashout, _checker, __FILE__, __LINE__);
	bool timeout; _parser.parseBOOL(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "spinnerStr"); size_t szSpinnerStr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "spinnerStr", szSpinnerStr, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSimpleAutoDealSubscr
//=================================================================

TournClientThin::publication::TournSimpleAutoDealSubscr::TournSimpleAutoDealSubscr()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSimpleAutoDealSubscr::TournSimpleAutoDealSubscr(TournSimpleAutoDealSubscr&& _o)
	: dealGeneration(std::move(_o.dealGeneration))
	, state(std::move(_o.state))
	, timeout(std::move(_o.timeout))
	, dealFailureState(std::move(_o.dealFailureState))
	, participantsInfo(std::move(_o.participantsInfo))
	, dealExclusion(std::move(_o.dealExclusion))
	, type0(std::move(_o.type0))
	, type1(std::move(_o.type1))
	, playerAgreedType(std::move(_o.playerAgreedType))
	, userAgreed0(std::move(_o.userAgreed0))
	, userAgreed1(std::move(_o.userAgreed1))
	, currency(std::move(_o.currency))
	, dealPayouts(std::move(_o.dealPayouts))
{
}

TournClientThin::publication::TournSimpleAutoDealSubscr& TournClientThin::publication::TournSimpleAutoDealSubscr::operator=(TournSimpleAutoDealSubscr&& _o)
{
	if(this != &_o)
	{
		dealGeneration = std::move(_o.dealGeneration);
		state = std::move(_o.state);
		timeout = std::move(_o.timeout);
		dealFailureState = std::move(_o.dealFailureState);
		participantsInfo = std::move(_o.participantsInfo);
		dealExclusion = std::move(_o.dealExclusion);
		type0 = std::move(_o.type0);
		type1 = std::move(_o.type1);
		playerAgreedType = std::move(_o.playerAgreedType);
		userAgreed0 = std::move(_o.userAgreed0);
		userAgreed1 = std::move(_o.userAgreed1);
		currency = std::move(_o.currency);
		dealPayouts = std::move(_o.dealPayouts);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSimpleAutoDealSubscr::clear()
{
	dealGeneration = 0;
	state = 0;
	timeout = 0;
	dealFailureState = 0;
	participantsInfo.clear();
	dealExclusion = 0;
	type0 = 0;
	type1 = 0;
	playerAgreedType = 0;
	userAgreed0 = 0;
	userAgreed1 = 0;
	currency.clear();
	dealPayouts.clear();
}

bool TournClientThin::publication::TournSimpleAutoDealSubscr::equals(const TournSimpleAutoDealSubscr& _o) const
{
	return dealGeneration == _o.dealGeneration &&
		state == _o.state &&
		timeout == _o.timeout &&
		dealFailureState == _o.dealFailureState &&
		participantsInfo.equals(_o.participantsInfo) &&
		dealExclusion == _o.dealExclusion &&
		type0 == _o.type0 &&
		type1 == _o.type1 &&
		playerAgreedType == _o.playerAgreedType &&
		userAgreed0 == _o.userAgreed0 &&
		userAgreed1 == _o.userAgreed1 &&
		currency.equals(_o.currency) &&
		dealPayouts.equals(_o.dealPayouts);
}

const char *TournClientThin::publication::TournSimpleAutoDealSubscr::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("dealGeneration=");
	_buf.appendInt(dealGeneration);
	_buf.append(',');
	_buf.append("state=");
	_buf.appendInt(state);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendInt64(timeout);
	_buf.append(',');
	_buf.append("dealFailureState=");
	_buf.appendInt(dealFailureState);
	_buf.append(',');
	_buf.append("participantsInfo=");
	participantsInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dealExclusion=");
	_buf.appendInt(dealExclusion);
	_buf.append(',');
	_buf.append("type0=");
	_buf.appendInt(type0);
	_buf.append(',');
	_buf.append("type1=");
	_buf.appendInt(type1);
	_buf.append(',');
	_buf.append("playerAgreedType=");
	_buf.appendInt(playerAgreedType);
	_buf.append(',');
	_buf.append("userAgreed0=");
	_buf.appendInt(userAgreed0);
	_buf.append(',');
	_buf.append("userAgreed1=");
	_buf.appendInt(userAgreed1);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("dealPayouts=");
	dealPayouts.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSimpleAutoDealSubscr::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(dealGeneration);
	_msg.composeINT8(state);
	_msg.composeINT64(timeout);
	_msg.composeINT32(dealFailureState);
	participantsInfo.composeMsg(_msg);
	_msg.composeINT32(dealExclusion);
	_msg.composeINT8(type0);
	_msg.composeINT8(type1);
	_msg.composeINT8(playerAgreedType);
	_msg.composeINT8(userAgreed0);
	_msg.composeINT8(userAgreed1);
	_msg.composeString(currency);
	dealPayouts.composeMsg(_msg);
}

void TournClientThin::publication::TournSimpleAutoDealSubscr::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(dealGeneration);
	_parser.parseINT8(state);
	_parser.parseINT64(timeout);
	_parser.parseINT32(dealFailureState);
	participantsInfo.parseMsg(_parser);
	_parser.parseINT32(dealExclusion);
	_parser.parseINT8(type0);
	_parser.parseINT8(type1);
	_parser.parseINT8(playerAgreedType);
	_parser.parseINT8(userAgreed0);
	_parser.parseINT8(userAgreed1);
	_parser.parseStringP(currency);
	dealPayouts.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournSimpleAutoDealSubscr::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 dealGeneration; _parser.parseINT32(dealGeneration);
	AtfValidator::validateInt(_descr, "dealGeneration", dealGeneration, _checker, __FILE__, __LINE__);
	INT8 state; _parser.parseINT8(state);
	AtfValidator::validateInt(_descr, "state", state, _checker, __FILE__, __LINE__);
	INT64 timeout; _parser.parseINT64(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	INT32 dealFailureState; _parser.parseINT32(dealFailureState);
	AtfValidator::validateInt(_descr, "dealFailureState", dealFailureState, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szParticipantsInfo = ThinAtf::LAtfVector< P_ParticipantsInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("participantsInfo"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "participantsInfo", szParticipantsInfo, _checker, __FILE__, __LINE__);
	INT32 dealExclusion; _parser.parseINT32(dealExclusion);
	AtfValidator::validateInt(_descr, "dealExclusion", dealExclusion, _checker, __FILE__, __LINE__);
	INT8 type0; _parser.parseINT8(type0);
	AtfValidator::validateInt(_descr, "type0", type0, _checker, __FILE__, __LINE__);
	INT8 type1; _parser.parseINT8(type1);
	AtfValidator::validateInt(_descr, "type1", type1, _checker, __FILE__, __LINE__);
	INT8 playerAgreedType; _parser.parseINT8(playerAgreedType);
	AtfValidator::validateInt(_descr, "playerAgreedType", playerAgreedType, _checker, __FILE__, __LINE__);
	INT8 userAgreed0; _parser.parseINT8(userAgreed0);
	AtfValidator::validateInt(_descr, "userAgreed0", userAgreed0, _checker, __FILE__, __LINE__);
	INT8 userAgreed1; _parser.parseINT8(userAgreed1);
	AtfValidator::validateInt(_descr, "userAgreed1", userAgreed1, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	int szDealPayouts = ThinAtf::LAtfVector< P_DealPayout, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dealPayouts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "dealPayouts", szDealPayouts, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Stakes
//=================================================================

TournClientThin::publication::TournExtraSubscr_Stakes::TournExtraSubscr_Stakes()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournExtraSubscr_Stakes::TournExtraSubscr_Stakes(TournExtraSubscr_Stakes&& _o)
	: stakeLevels(std::move(_o.stakeLevels))
	, finalTableTimeBank(std::move(_o.finalTableTimeBank))
	, addRoundTimeBank(std::move(_o.addRoundTimeBank))
	, currRule(std::move(_o.currRule))
	, numRules(std::move(_o.numRules))
{
}

TournClientThin::publication::TournExtraSubscr_Stakes& TournClientThin::publication::TournExtraSubscr_Stakes::operator=(TournExtraSubscr_Stakes&& _o)
{
	if(this != &_o)
	{
		stakeLevels = std::move(_o.stakeLevels);
		finalTableTimeBank = std::move(_o.finalTableTimeBank);
		addRoundTimeBank = std::move(_o.addRoundTimeBank);
		currRule = std::move(_o.currRule);
		numRules = std::move(_o.numRules);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournExtraSubscr_Stakes::clear()
{
	stakeLevels.clear();
	finalTableTimeBank = 0;
	addRoundTimeBank = 0;
	currRule = 0;
	numRules.clear();
}

bool TournClientThin::publication::TournExtraSubscr_Stakes::equals(const TournExtraSubscr_Stakes& _o) const
{
	return stakeLevels.equals(_o.stakeLevels) &&
		finalTableTimeBank == _o.finalTableTimeBank &&
		addRoundTimeBank == _o.addRoundTimeBank &&
		currRule == _o.currRule &&
		numRules.equals(_o.numRules);
}

const char *TournClientThin::publication::TournExtraSubscr_Stakes::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("stakeLevels=");
	stakeLevels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("finalTableTimeBank=");
	_buf.appendUint(finalTableTimeBank);
	_buf.append(',');
	_buf.append("addRoundTimeBank=");
	_buf.appendUint(addRoundTimeBank);
	_buf.append(',');
	_buf.append("currRule=");
	_buf.appendInt(currRule);
	_buf.append(',');
	_buf.append("numRules=");
	numRules.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournExtraSubscr_Stakes::composeMsg(CommMsgBody& _msg) const
{
	stakeLevels.composeMsg(_msg);
	_msg.composeUINT32(finalTableTimeBank);
	_msg.composeUINT32(addRoundTimeBank);
	_msg.composeINT32(currRule);
	numRules.composeMsg(_msg);
}

void TournClientThin::publication::TournExtraSubscr_Stakes::parseMsg(CommMsgParser& _parser)
{
	stakeLevels.parseMsg(_parser);
	_parser.parseUINT32(finalTableTimeBank);
	_parser.parseUINT32(addRoundTimeBank);
	_parser.parseINT32(currRule);
	numRules.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournExtraSubscr_Stakes::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szStakeLevels = ThinAtf::LAtfVector< ExtraInfo_StakesLevel, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stakeLevels"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "stakeLevels", szStakeLevels, _checker, __FILE__, __LINE__);
	UINT32 finalTableTimeBank; _parser.parseUINT32(finalTableTimeBank);
	AtfValidator::validateInt(_descr, "finalTableTimeBank", finalTableTimeBank, _checker, __FILE__, __LINE__);
	UINT32 addRoundTimeBank; _parser.parseUINT32(addRoundTimeBank);
	AtfValidator::validateInt(_descr, "addRoundTimeBank", addRoundTimeBank, _checker, __FILE__, __LINE__);
	INT32 currRule; _parser.parseINT32(currRule);
	AtfValidator::validateInt(_descr, "currRule", currRule, _checker, __FILE__, __LINE__);
	int szNumRules = ThinAtf::LAtfVector< BlindLevelIntervalRule, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("numRules"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "numRules", szNumRules, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Breaks
//=================================================================

TournClientThin::publication::TournExtraSubscr_Breaks::TournExtraSubscr_Breaks()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournExtraSubscr_Breaks::TournExtraSubscr_Breaks(TournExtraSubscr_Breaks&& _o)
	: breaks(std::move(_o.breaks))
{
}

TournClientThin::publication::TournExtraSubscr_Breaks& TournClientThin::publication::TournExtraSubscr_Breaks::operator=(TournExtraSubscr_Breaks&& _o)
{
	if(this != &_o)
	{
		breaks = std::move(_o.breaks);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournExtraSubscr_Breaks::clear()
{
	breaks.clear();
}

bool TournClientThin::publication::TournExtraSubscr_Breaks::equals(const TournExtraSubscr_Breaks& _o) const
{
	return breaks.equals(_o.breaks);
}

const char *TournClientThin::publication::TournExtraSubscr_Breaks::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("breaks=");
	breaks.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournExtraSubscr_Breaks::composeMsg(CommMsgBody& _msg) const
{
	breaks.composeMsg(_msg);
}

void TournClientThin::publication::TournExtraSubscr_Breaks::parseMsg(CommMsgParser& _parser)
{
	breaks.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournExtraSubscr_Breaks::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	int szBreaks = ThinAtf::LAtfVector< P_BreakPub, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("breaks"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "breaks", szBreaks, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_HandByHand
//=================================================================

TournClientThin::publication::TournExtraSubscr_HandByHand::TournExtraSubscr_HandByHand()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournExtraSubscr_HandByHand::TournExtraSubscr_HandByHand(TournExtraSubscr_HandByHand&& _o)
	: handByHandRanges(std::move(_o.handByHandRanges))
	, targetServer(std::move(_o.targetServer))
	, isSatelliteData(std::move(_o.isSatelliteData))
	, fallBackSatTargetSize(std::move(_o.fallBackSatTargetSize))
{
}

TournClientThin::publication::TournExtraSubscr_HandByHand& TournClientThin::publication::TournExtraSubscr_HandByHand::operator=(TournExtraSubscr_HandByHand&& _o)
{
	if(this != &_o)
	{
		handByHandRanges = std::move(_o.handByHandRanges);
		targetServer = std::move(_o.targetServer);
		isSatelliteData = std::move(_o.isSatelliteData);
		fallBackSatTargetSize = std::move(_o.fallBackSatTargetSize);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournExtraSubscr_HandByHand::clear()
{
	handByHandRanges.clear();
	targetServer.clear();
	isSatelliteData = false;
	fallBackSatTargetSize = 0;
}

bool TournClientThin::publication::TournExtraSubscr_HandByHand::equals(const TournExtraSubscr_HandByHand& _o) const
{
	return handByHandRanges.equals(_o.handByHandRanges) &&
		targetServer.equals(_o.targetServer) &&
		isSatelliteData == _o.isSatelliteData &&
		fallBackSatTargetSize == _o.fallBackSatTargetSize;
}

const char *TournClientThin::publication::TournExtraSubscr_HandByHand::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handByHandRanges=");
	handByHandRanges.toTraceString(_buf);
	_buf.append(',');
	_buf.append("targetServer=");
	_buf.append(targetServer);
	_buf.append(',');
	_buf.append("isSatelliteData=");
	_buf.appendUint(isSatelliteData);
	_buf.append(',');
	_buf.append("fallBackSatTargetSize=");
	_buf.appendUint(fallBackSatTargetSize);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournExtraSubscr_HandByHand::composeMsg(CommMsgBody& _msg) const
{
	handByHandRanges.composeMsg(_msg);
	_msg.composeString(targetServer);
	_msg.composeBOOL(isSatelliteData);
	_msg.composeUINT32(fallBackSatTargetSize);
}

void TournClientThin::publication::TournExtraSubscr_HandByHand::parseMsg(CommMsgParser& _parser)
{
	handByHandRanges.parseMsg(_parser);
	_parser.parseStringP(targetServer);
	_parser.parseBOOL(isSatelliteData);
	_parser.parseUINT32(fallBackSatTargetSize);
}

/*static*/ void TournClientThin::publication::TournExtraSubscr_HandByHand::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	PString _descbuf;
	int szHandByHandRanges = ThinAtf::LAtfVector< TournCommonThin::P_Event, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("handByHandRanges"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "handByHandRanges", szHandByHandRanges, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "targetServer"); size_t szTargetServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "targetServer", szTargetServer, _checker, __FILE__, __LINE__);
	bool isSatelliteData; _parser.parseBOOL(isSatelliteData);
	AtfValidator::validateInt(_descr, "isSatelliteData", isSatelliteData, _checker, __FILE__, __LINE__);
	UINT32 fallBackSatTargetSize; _parser.parseUINT32(fallBackSatTargetSize);
	AtfValidator::validateInt(_descr, "fallBackSatTargetSize", fallBackSatTargetSize, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Prize
//=================================================================

TournClientThin::publication::TournExtraSubscr_Prize::TournExtraSubscr_Prize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournExtraSubscr_Prize::TournExtraSubscr_Prize(TournExtraSubscr_Prize&& _o)
	: zero(std::move(_o.zero))
	, creditPlayer(std::move(_o.creditPlayer))
	, returnBuyInValue(std::move(_o.returnBuyInValue))
	, rebuyPrice(std::move(_o.rebuyPrice))
	, rebuyRake(std::move(_o.rebuyRake))
	, addOnPrice(std::move(_o.addOnPrice))
	, addOnRake(std::move(_o.addOnRake))
	, prizes(std::move(_o.prizes))
{
}

TournClientThin::publication::TournExtraSubscr_Prize& TournClientThin::publication::TournExtraSubscr_Prize::operator=(TournExtraSubscr_Prize&& _o)
{
	if(this != &_o)
	{
		zero = std::move(_o.zero);
		creditPlayer = std::move(_o.creditPlayer);
		returnBuyInValue = std::move(_o.returnBuyInValue);
		rebuyPrice = std::move(_o.rebuyPrice);
		rebuyRake = std::move(_o.rebuyRake);
		addOnPrice = std::move(_o.addOnPrice);
		addOnRake = std::move(_o.addOnRake);
		prizes = std::move(_o.prizes);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournExtraSubscr_Prize::clear()
{
	zero = 0;
	creditPlayer = 0;
	returnBuyInValue = 0;
	rebuyPrice = 0;
	rebuyRake = 0;
	addOnPrice = 0;
	addOnRake = 0;
	prizes.clear();
}

bool TournClientThin::publication::TournExtraSubscr_Prize::equals(const TournExtraSubscr_Prize& _o) const
{
	return zero == _o.zero &&
		creditPlayer == _o.creditPlayer &&
		returnBuyInValue == _o.returnBuyInValue &&
		rebuyPrice == _o.rebuyPrice &&
		rebuyRake == _o.rebuyRake &&
		addOnPrice == _o.addOnPrice &&
		addOnRake == _o.addOnRake &&
		prizes.equals(_o.prizes);
}

const char *TournClientThin::publication::TournExtraSubscr_Prize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("zero=");
	_buf.appendUint(zero);
	_buf.append(',');
	_buf.append("creditPlayer=");
	_buf.appendUint(creditPlayer);
	_buf.append(',');
	_buf.append("returnBuyInValue=");
	_buf.appendUint(returnBuyInValue);
	_buf.append(',');
	_buf.append("rebuyPrice=");
	_buf.appendInt(rebuyPrice);
	_buf.append(',');
	_buf.append("rebuyRake=");
	_buf.appendInt(rebuyRake);
	_buf.append(',');
	_buf.append("addOnPrice=");
	_buf.appendInt(addOnPrice);
	_buf.append(',');
	_buf.append("addOnRake=");
	_buf.appendInt(addOnRake);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournExtraSubscr_Prize::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(zero);
	_msg.composeUINT32(creditPlayer);
	_msg.composeUINT32(returnBuyInValue);
	_msg.composeINT32(rebuyPrice);
	_msg.composeINT32(rebuyRake);
	_msg.composeINT32(addOnPrice);
	_msg.composeINT32(addOnRake);
	prizes.composeMsg(_msg);
}

void TournClientThin::publication::TournExtraSubscr_Prize::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(zero);
	_parser.parseUINT32(creditPlayer);
	_parser.parseUINT32(returnBuyInValue);
	_parser.parseINT32(rebuyPrice);
	_parser.parseINT32(rebuyRake);
	_parser.parseINT32(addOnPrice);
	_parser.parseINT32(addOnRake);
	prizes.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournExtraSubscr_Prize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 zero; _parser.parseUINT32(zero);
	AtfValidator::validateInt(_descr, "zero", zero, _checker, __FILE__, __LINE__);
	UINT32 creditPlayer; _parser.parseUINT32(creditPlayer);
	AtfValidator::validateInt(_descr, "creditPlayer", creditPlayer, _checker, __FILE__, __LINE__);
	UINT32 returnBuyInValue; _parser.parseUINT32(returnBuyInValue);
	AtfValidator::validateInt(_descr, "returnBuyInValue", returnBuyInValue, _checker, __FILE__, __LINE__);
	INT32 rebuyPrice; _parser.parseINT32(rebuyPrice);
	AtfValidator::validateInt(_descr, "rebuyPrice", rebuyPrice, _checker, __FILE__, __LINE__);
	INT32 rebuyRake; _parser.parseINT32(rebuyRake);
	AtfValidator::validateInt(_descr, "rebuyRake", rebuyRake, _checker, __FILE__, __LINE__);
	INT32 addOnPrice; _parser.parseINT32(addOnPrice);
	AtfValidator::validateInt(_descr, "addOnPrice", addOnPrice, _checker, __FILE__, __LINE__);
	INT32 addOnRake; _parser.parseINT32(addOnRake);
	AtfValidator::validateInt(_descr, "addOnRake", addOnRake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = ThinAtf::LAtfVector< TournExtraSubscr_Prize_Prize, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Rake_SitesPerCountry
//=================================================================

TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry::TournExtraSubscr_Rake_SitesPerCountry()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry::TournExtraSubscr_Rake_SitesPerCountry(TournExtraSubscr_Rake_SitesPerCountry&& _o)
	: country(std::move(_o.country))
	, sites(std::move(_o.sites))
{
}

TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry& TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry::operator=(TournExtraSubscr_Rake_SitesPerCountry&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		sites = std::move(_o.sites);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry::clear()
{
	country.clear();
	sites = 0;
}

bool TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry::equals(const TournExtraSubscr_Rake_SitesPerCountry& _o) const
{
	return country.equals(_o.country) &&
		sites == _o.sites;
}

const char *TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("sites=");
	_buf.appendUint(sites);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(country);
	_msg.composeUINT32(sites);
}

void TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	_parser.parseUINT32(sites);
}

/*static*/ void TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	UINT32 sites; _parser.parseUINT32(sites);
	AtfValidator::validateInt(_descr, "sites", sites, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournExtraSubscr_Rake_SitesPerCountryEx
//=================================================================

TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx::TournExtraSubscr_Rake_SitesPerCountryEx()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx::TournExtraSubscr_Rake_SitesPerCountryEx(TournExtraSubscr_Rake_SitesPerCountryEx&& _o)
	: country(std::move(_o.country))
	, sitesEx(std::move(_o.sitesEx))
{
}

TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx& TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx::operator=(TournExtraSubscr_Rake_SitesPerCountryEx&& _o)
{
	if(this != &_o)
	{
		country = std::move(_o.country);
		sitesEx = std::move(_o.sitesEx);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx::clear()
{
	country.clear();
	sitesEx.clear();
}

bool TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx::equals(const TournExtraSubscr_Rake_SitesPerCountryEx& _o) const
{
	return country.equals(_o.country) &&
		sitesEx.equals(_o.sitesEx);
}

const char *TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("sitesEx=");
	sitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(country);
	sitesEx.composeMsg(_msg);
}

void TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(country);
	sitesEx.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournExtraSubscr_Rake_SitesPerCountryEx::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesEx"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournExtraSubscr_Rake
//=================================================================

TournClientThin::publication::TournExtraSubscr_Rake::TournExtraSubscr_Rake()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournExtraSubscr_Rake::TournExtraSubscr_Rake(TournExtraSubscr_Rake&& _o)
	: sites4AllCountries(std::move(_o.sites4AllCountries))
	, sitesNoRake(std::move(_o.sitesNoRake))
	, sitesPerCountry(std::move(_o.sitesPerCountry))
	, sites4AllCountriesEx(std::move(_o.sites4AllCountriesEx))
	, sitesNoRakeEx(std::move(_o.sitesNoRakeEx))
	, sitesPerCountryEx(std::move(_o.sitesPerCountryEx))
{
}

TournClientThin::publication::TournExtraSubscr_Rake& TournClientThin::publication::TournExtraSubscr_Rake::operator=(TournExtraSubscr_Rake&& _o)
{
	if(this != &_o)
	{
		sites4AllCountries = std::move(_o.sites4AllCountries);
		sitesNoRake = std::move(_o.sitesNoRake);
		sitesPerCountry = std::move(_o.sitesPerCountry);
		sites4AllCountriesEx = std::move(_o.sites4AllCountriesEx);
		sitesNoRakeEx = std::move(_o.sitesNoRakeEx);
		sitesPerCountryEx = std::move(_o.sitesPerCountryEx);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournExtraSubscr_Rake::clear()
{
	sites4AllCountries = UINT_MAX;
	sitesNoRake = 0;
	sitesPerCountry.clear();
	sites4AllCountriesEx.clear();
	sitesNoRakeEx.clear();
	sitesPerCountryEx.clear();
}

bool TournClientThin::publication::TournExtraSubscr_Rake::equals(const TournExtraSubscr_Rake& _o) const
{
	return sites4AllCountries == _o.sites4AllCountries &&
		sitesNoRake == _o.sitesNoRake &&
		sitesPerCountry.equals(_o.sitesPerCountry) &&
		sites4AllCountriesEx.equals(_o.sites4AllCountriesEx) &&
		sitesNoRakeEx.equals(_o.sitesNoRakeEx) &&
		sitesPerCountryEx.equals(_o.sitesPerCountryEx);
}

const char *TournClientThin::publication::TournExtraSubscr_Rake::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sites4AllCountries=");
	_buf.appendUint(sites4AllCountries);
	_buf.append(',');
	_buf.append("sitesNoRake=");
	_buf.appendUint(sitesNoRake);
	_buf.append(',');
	_buf.append("sitesPerCountry=");
	sitesPerCountry.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sites4AllCountriesEx=");
	sites4AllCountriesEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sitesNoRakeEx=");
	sitesNoRakeEx.toTraceString(_buf);
	_buf.append(',');
	_buf.append("sitesPerCountryEx=");
	sitesPerCountryEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournExtraSubscr_Rake::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(sites4AllCountries);
	_msg.composeUINT32(sitesNoRake);
	sitesPerCountry.composeMsg(_msg);
	sites4AllCountriesEx.composeMsg(_msg);
	sitesNoRakeEx.composeMsg(_msg);
	sitesPerCountryEx.composeMsg(_msg);
}

void TournClientThin::publication::TournExtraSubscr_Rake::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sites4AllCountries);
	_parser.parseUINT32(sitesNoRake);
	sitesPerCountry.parseMsg(_parser);
	sites4AllCountriesEx.parseMsg(_parser);
	sitesNoRakeEx.parseMsg(_parser);
	sitesPerCountryEx.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournExtraSubscr_Rake::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 sites4AllCountries; _parser.parseUINT32(sites4AllCountries);
	AtfValidator::validateInt(_descr, "sites4AllCountries", sites4AllCountries, _checker, __FILE__, __LINE__);
	UINT32 sitesNoRake; _parser.parseUINT32(sitesNoRake);
	AtfValidator::validateInt(_descr, "sitesNoRake", sitesNoRake, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSitesPerCountry = ThinAtf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountry , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesPerCountry"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sitesPerCountry", szSitesPerCountry, _checker, __FILE__, __LINE__);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sites4AllCountriesEx"), _fieldsWithUnparsedContent);
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesNoRakeEx"), _fieldsWithUnparsedContent);
	int szSitesPerCountryEx = ThinAtf::LAtfVector< TournExtraSubscr_Rake_SitesPerCountryEx , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sitesPerCountryEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sitesPerCountryEx", szSitesPerCountryEx, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournStormSubscr
//=================================================================

TournClientThin::publication::TournStormSubscr::TournStormSubscr()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournStormSubscr::TournStormSubscr(TournStormSubscr&& _o)
	: stormAllowed(std::move(_o.stormAllowed))
	, powerCostBase(std::move(_o.powerCostBase))
	, powers(std::move(_o.powers))
{
}

TournClientThin::publication::TournStormSubscr& TournClientThin::publication::TournStormSubscr::operator=(TournStormSubscr&& _o)
{
	if(this != &_o)
	{
		stormAllowed = std::move(_o.stormAllowed);
		powerCostBase = std::move(_o.powerCostBase);
		powers = std::move(_o.powers);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournStormSubscr::clear()
{
	stormAllowed = false;
	powerCostBase.clear();
	powers.clear();
}

bool TournClientThin::publication::TournStormSubscr::equals(const TournStormSubscr& _o) const
{
	return stormAllowed == _o.stormAllowed &&
		powerCostBase.equals(_o.powerCostBase) &&
		powers.equals(_o.powers);
}

const char *TournClientThin::publication::TournStormSubscr::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("stormAllowed=");
	_buf.appendUint(stormAllowed);
	_buf.append(',');
	_buf.append("powerCostBase=");
	powerCostBase.toTraceString(_buf);
	_buf.append(',');
	_buf.append("powers=");
	powers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournStormSubscr::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(stormAllowed);
	powerCostBase.composeMsg(_msg);
	powers.composeMsg(_msg);
}

void TournClientThin::publication::TournStormSubscr::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(stormAllowed);
	powerCostBase.parseMsg(_parser);
	powers.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournStormSubscr::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	bool stormAllowed; _parser.parseBOOL(stormAllowed);
	AtfValidator::validateInt(_descr, "stormAllowed", stormAllowed, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPowerCostBase = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powerCostBase"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powerCostBase", szPowerCostBase, _checker, __FILE__, __LINE__);
	int szPowers = ThinAtf::LAtfVector< ThinAtf::CopyableMsgBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("powers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "powers", szPowers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournSatelliteDataSubscr_Stat
//=================================================================

TournClientThin::publication::TournSatelliteDataSubscr_Stat::TournSatelliteDataSubscr_Stat()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournSatelliteDataSubscr_Stat::TournSatelliteDataSubscr_Stat(TournSatelliteDataSubscr_Stat&& _o)
	: tournamentId(std::move(_o.tournamentId))
	, server(std::move(_o.server))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fppBuyIn(std::move(_o.fppBuyIn))
	, isRestricted(std::move(_o.isRestricted))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, minPlayers(std::move(_o.minPlayers))
	, tournFlags(std::move(_o.tournFlags))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, tournSites(std::move(_o.tournSites))
	, maxPerTable(std::move(_o.maxPerTable))
	, admissionId(std::move(_o.admissionId))
	, chatLang(std::move(_o.chatLang))
	, currency(std::move(_o.currency))
	, knockout(std::move(_o.knockout))
	, tournFlagsServInt(std::move(_o.tournFlagsServInt))
	, scalePM(std::move(_o.scalePM))
	, admissionPrice(std::move(_o.admissionPrice))
	, speedDisplay(std::move(_o.speedDisplay))
	, name(std::move(_o.name))
	, tournFlags2(std::move(_o.tournFlags2))
	, activeFlags(std::move(_o.activeFlags))
	, tournSitesEx(std::move(_o.tournSitesEx))
{
}

TournClientThin::publication::TournSatelliteDataSubscr_Stat& TournClientThin::publication::TournSatelliteDataSubscr_Stat::operator=(TournSatelliteDataSubscr_Stat&& _o)
{
	if(this != &_o)
	{
		tournamentId = std::move(_o.tournamentId);
		server = std::move(_o.server);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fppBuyIn = std::move(_o.fppBuyIn);
		isRestricted = std::move(_o.isRestricted);
		isPlayMoney = std::move(_o.isPlayMoney);
		minPlayers = std::move(_o.minPlayers);
		tournFlags = std::move(_o.tournFlags);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		tournSites = std::move(_o.tournSites);
		maxPerTable = std::move(_o.maxPerTable);
		admissionId = std::move(_o.admissionId);
		chatLang = std::move(_o.chatLang);
		currency = std::move(_o.currency);
		knockout = std::move(_o.knockout);
		tournFlagsServInt = std::move(_o.tournFlagsServInt);
		scalePM = std::move(_o.scalePM);
		admissionPrice = std::move(_o.admissionPrice);
		speedDisplay = std::move(_o.speedDisplay);
		name = std::move(_o.name);
		tournFlags2 = std::move(_o.tournFlags2);
		activeFlags = std::move(_o.activeFlags);
		tournSitesEx = std::move(_o.tournSitesEx);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournSatelliteDataSubscr_Stat::clear()
{
	tournamentId = 0;
	server.clear();
	buyIn = 0;
	rake = 0;
	fppBuyIn = 0;
	isRestricted = 0;
	isPlayMoney = 0;
	minPlayers = 0;
	tournFlags = 0;
	game = 0;
	isHiLo = 0;
	structure = 0;
	tournSites = 0;
	maxPerTable = 0;
	admissionId.clear();
	chatLang = 0;
	currency.clear();
	knockout = 0;
	tournFlagsServInt = 0;
	scalePM = 0;
	admissionPrice = 0;
	speedDisplay = 0;
	name.clear();
	tournFlags2 = 0;
	activeFlags = 0;
	tournSitesEx.clear();
}

bool TournClientThin::publication::TournSatelliteDataSubscr_Stat::equals(const TournSatelliteDataSubscr_Stat& _o) const
{
	return tournamentId == _o.tournamentId &&
		server.equals(_o.server) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fppBuyIn == _o.fppBuyIn &&
		isRestricted == _o.isRestricted &&
		isPlayMoney == _o.isPlayMoney &&
		minPlayers == _o.minPlayers &&
		tournFlags == _o.tournFlags &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		tournSites == _o.tournSites &&
		maxPerTable == _o.maxPerTable &&
		admissionId.equals(_o.admissionId) &&
		chatLang == _o.chatLang &&
		currency.equals(_o.currency) &&
		knockout == _o.knockout &&
		tournFlagsServInt == _o.tournFlagsServInt &&
		scalePM == _o.scalePM &&
		admissionPrice == _o.admissionPrice &&
		speedDisplay == _o.speedDisplay &&
		name.equals(_o.name) &&
		tournFlags2 == _o.tournFlags2 &&
		activeFlags == _o.activeFlags &&
		tournSitesEx.equals(_o.tournSitesEx);
}

const char *TournClientThin::publication::TournSatelliteDataSubscr_Stat::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournamentId=");
	_buf.appendUint(tournamentId);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("fppBuyIn=");
	_buf.appendUint(fppBuyIn);
	_buf.append(',');
	_buf.append("isRestricted=");
	_buf.appendUint(isRestricted);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("minPlayers=");
	_buf.appendUint(minPlayers);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("tournSites=");
	_buf.appendUint(tournSites);
	_buf.append(',');
	_buf.append("maxPerTable=");
	_buf.appendUint(maxPerTable);
	_buf.append(',');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("knockout=");
	_buf.appendUint(knockout);
	_buf.append(',');
	_buf.append("tournFlagsServInt=");
	_buf.appendUint(tournFlagsServInt);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("admissionPrice=");
	_buf.appendInt64(admissionPrice);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("name=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
	_buf.append(',');
	_buf.append("tournFlags2=");
	_buf.appendUint64(tournFlags2);
	_buf.append(',');
	_buf.append("activeFlags=");
	_buf.appendUint(activeFlags);
	_buf.append(',');
	_buf.append("tournSitesEx=");
	tournSitesEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSatelliteDataSubscr_Stat::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournamentId);
	_msg.composeString(server);
	_msg.composeUINT32(buyIn);
	_msg.composeUINT32(rake);
	_msg.composeUINT32(fppBuyIn);
	_msg.composeBYTE(isRestricted);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeUINT32(minPlayers);
	_msg.composeUINT32(tournFlags);
	_msg.composeBYTE(game);
	_msg.composeBYTE(isHiLo);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(tournSites);
	_msg.composeUINT32(maxPerTable);
	_msg.composeString(admissionId);
	_msg.composeUINT16(chatLang);
	_msg.composeString(currency);
	_msg.composeUINT32(knockout);
	_msg.composeUINT32(tournFlagsServInt);
	_msg.composeUINT32(scalePM);
	_msg.composeINT64(admissionPrice);
	_msg.composeBYTE(speedDisplay);
	name.compose(_msg);
	_msg.composeUINT64(tournFlags2);
	_msg.composeUINT32(activeFlags);
	tournSitesEx.composeMsg(_msg);
}

void TournClientThin::publication::TournSatelliteDataSubscr_Stat::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournamentId);
	_parser.parseStringP(server);
	_parser.parseUINT32(buyIn);
	_parser.parseUINT32(rake);
	_parser.parseUINT32(fppBuyIn);
	_parser.parseBYTE(isRestricted);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseUINT32(minPlayers);
	_parser.parseUINT32(tournFlags);
	_parser.parseBYTE(game);
	_parser.parseBYTE(isHiLo);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(tournSites);
	_parser.parseUINT32(maxPerTable);
	_parser.parseStringP(admissionId);
	_parser.parseUINT16(chatLang);
	_parser.parseStringP(currency);
	_parser.parseUINT32(knockout);
	_parser.parseUINT32(tournFlagsServInt);
	_parser.parseUINT32(scalePM);
	_parser.parseINT64(admissionPrice);
	_parser.parseBYTE(speedDisplay);
	name.parse(_parser);
	_parser.parseUINT64(tournFlags2);
	_parser.parseUINT32(activeFlags);
	tournSitesEx.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournSatelliteDataSubscr_Stat::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tournamentId; _parser.parseUINT32(tournamentId);
	AtfValidator::validateInt(_descr, "tournamentId", tournamentId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 fppBuyIn; _parser.parseUINT32(fppBuyIn);
	AtfValidator::validateInt(_descr, "fppBuyIn", fppBuyIn, _checker, __FILE__, __LINE__);
	BYTE isRestricted; _parser.parseBYTE(isRestricted);
	AtfValidator::validateInt(_descr, "isRestricted", isRestricted, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 minPlayers; _parser.parseUINT32(minPlayers);
	AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournFlags; _parser.parseUINT32(tournFlags);
	AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE isHiLo; _parser.parseBYTE(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 tournSites; _parser.parseUINT32(tournSites);
	AtfValidator::validateInt(_descr, "tournSites", tournSites, _checker, __FILE__, __LINE__);
	UINT32 maxPerTable; _parser.parseUINT32(maxPerTable);
	AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 knockout; _parser.parseUINT32(knockout);
	AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
	UINT32 tournFlagsServInt; _parser.parseUINT32(tournFlagsServInt);
	AtfValidator::validateInt(_descr, "tournFlagsServInt", tournFlagsServInt, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	INT64 admissionPrice; _parser.parseINT64(admissionPrice);
	AtfValidator::validateInt(_descr, "admissionPrice", admissionPrice, _checker, __FILE__, __LINE__);
	BYTE speedDisplay; _parser.parseBYTE(speedDisplay);
	AtfValidator::validateInt(_descr, "speedDisplay", speedDisplay, _checker, __FILE__, __LINE__);
	I18nPString name; name.parse(_parser);
	UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
	AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
	UINT32 activeFlags; _parser.parseUINT32(activeFlags);
	AtfValidator::validateInt(_descr, "activeFlags", activeFlags, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSitesEx"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    TournSatelliteDataSubscr_Dyna
//=================================================================

TournClientThin::publication::TournSatelliteDataSubscr_Dyna::TournSatelliteDataSubscr_Dyna()
{
	clear();
}

void TournClientThin::publication::TournSatelliteDataSubscr_Dyna::clear()
{
	whenStart.setNull();
	status = 0;
	entrants = 0;
	publProp = 0;
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	mixTournSatellite = 0;
}

bool TournClientThin::publication::TournSatelliteDataSubscr_Dyna::equals(const TournSatelliteDataSubscr_Dyna& _o) const
{
	return whenStart.equals(_o.whenStart) &&
		status == _o.status &&
		entrants == _o.entrants &&
		publProp == _o.publProp &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		mixTournSatellite == _o.mixTournSatellite;
}

const char *TournClientThin::publication::TournSatelliteDataSubscr_Dyna::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("entrants=");
	_buf.appendUint(entrants);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendUint(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("mixTournSatellite=");
	_buf.appendInt(mixTournSatellite);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournSatelliteDataSubscr_Dyna::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeSrvTime(whenStart);
	_msg.composeUINT32(status);
	_msg.composeUINT32(entrants);
	_msg.composeBYTE(publProp);
	_msg.composeUINT32(prizePoolToPublish);
	_msg.composeBYTE(prizePoolUnit);
	_msg.composeINT8(mixTournSatellite);
}

void TournClientThin::publication::TournSatelliteDataSubscr_Dyna::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(whenStart);
	_parser.parseUINT32(status);
	_parser.parseUINT32(entrants);
	_parser.parseBYTE(publProp);
	_parser.parseUINT32(prizePoolToPublish);
	_parser.parseBYTE(prizePoolUnit);
	_parser.parseINT8(mixTournSatellite);
}

/*static*/ void TournClientThin::publication::TournSatelliteDataSubscr_Dyna::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	SrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 entrants; _parser.parseUINT32(entrants);
	AtfValidator::validateInt(_descr, "entrants", entrants, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	UINT32 prizePoolToPublish; _parser.parseUINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT8 mixTournSatellite; _parser.parseINT8(mixTournSatellite);
	AtfValidator::validateInt(_descr, "mixTournSatellite", mixTournSatellite, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    LightTournData
//=================================================================

TournClientThin::publication::LightTournData::LightTournData()
{
	clear();
}

void TournClientThin::publication::LightTournData::clear()
{
	status = 0;
	whenStart.setNull();
	prizePoolToPublish = 0;
	prizePoolUnit = 0;
	prizePoolMoneyToPublish = 0;
	numUsersReg = 0;
}

bool TournClientThin::publication::LightTournData::equals(const LightTournData& _o) const
{
	return status == _o.status &&
		whenStart.equals(_o.whenStart) &&
		prizePoolToPublish == _o.prizePoolToPublish &&
		prizePoolUnit == _o.prizePoolUnit &&
		prizePoolMoneyToPublish == _o.prizePoolMoneyToPublish &&
		numUsersReg == _o.numUsersReg;
}

const char *TournClientThin::publication::LightTournData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("whenStart=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStart);
	_buf.append(',');
	_buf.append("prizePoolToPublish=");
	_buf.appendInt(prizePoolToPublish);
	_buf.append(',');
	_buf.append("prizePoolUnit=");
	_buf.appendUint(prizePoolUnit);
	_buf.append(',');
	_buf.append("prizePoolMoneyToPublish=");
	_buf.appendInt(prizePoolMoneyToPublish);
	_buf.append(',');
	_buf.append("numUsersReg=");
	_buf.appendUint(numUsersReg);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::LightTournData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(status);
	_msg.composeSrvTime(whenStart);
	_msg.composeINT32(prizePoolToPublish);
	_msg.composeBYTE(prizePoolUnit);
	_msg.composeINT32(prizePoolMoneyToPublish);
	_msg.composeUINT32(numUsersReg);
}

void TournClientThin::publication::LightTournData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
	_parser.parseSrvTime(whenStart);
	_parser.parseINT32(prizePoolToPublish);
	_parser.parseBYTE(prizePoolUnit);
	_parser.parseINT32(prizePoolMoneyToPublish);
	_parser.parseUINT32(numUsersReg);
}

/*static*/ void TournClientThin::publication::LightTournData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	SrvTime whenStart; _parser.parseSrvTime(whenStart);
	AtfValidator::validateSrvDateTime(_descr, "whenStart", whenStart, _checker, __FILE__, __LINE__);
	INT32 prizePoolToPublish; _parser.parseINT32(prizePoolToPublish);
	AtfValidator::validateInt(_descr, "prizePoolToPublish", prizePoolToPublish, _checker, __FILE__, __LINE__);
	BYTE prizePoolUnit; _parser.parseBYTE(prizePoolUnit);
	AtfValidator::validateInt(_descr, "prizePoolUnit", prizePoolUnit, _checker, __FILE__, __LINE__);
	INT32 prizePoolMoneyToPublish; _parser.parseINT32(prizePoolMoneyToPublish);
	AtfValidator::validateInt(_descr, "prizePoolMoneyToPublish", prizePoolMoneyToPublish, _checker, __FILE__, __LINE__);
	UINT32 numUsersReg; _parser.parseUINT32(numUsersReg);
	AtfValidator::validateInt(_descr, "numUsersReg", numUsersReg, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournI18nSubscr_Name
//=================================================================

TournClientThin::publication::TournI18nSubscr_Name::TournI18nSubscr_Name()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournI18nSubscr_Name::TournI18nSubscr_Name(TournI18nSubscr_Name&& _o)
	: name(std::move(_o.name))
{
}

TournClientThin::publication::TournI18nSubscr_Name& TournClientThin::publication::TournI18nSubscr_Name::operator=(TournI18nSubscr_Name&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournI18nSubscr_Name::clear()
{
	name.clear();
}

bool TournClientThin::publication::TournI18nSubscr_Name::equals(const TournI18nSubscr_Name& _o) const
{
	return name.equals(_o.name);
}

const char *TournClientThin::publication::TournI18nSubscr_Name::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournI18nSubscr_Name::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
}

void TournClientThin::publication::TournI18nSubscr_Name::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
}

/*static*/ void TournClientThin::publication::TournI18nSubscr_Name::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournPlayerDataSubscr_User
//=================================================================

TournClientThin::publication::TournPlayerDataSubscr_User::TournPlayerDataSubscr_User()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournPlayerDataSubscr_User::TournPlayerDataSubscr_User(TournPlayerDataSubscr_User&& _o)
	: name(std::move(_o.name))
	, city(std::move(_o.city))
	, place(std::move(_o.place))
	, placeTo(std::move(_o.placeTo))
	, publProp(std::move(_o.publProp))
	, bounty(std::move(_o.bounty))
	, country(std::move(_o.country))
	, showCity(std::move(_o.showCity))
	, imageId(std::move(_o.imageId))
	, entryNum(std::move(_o.entryNum))
	, brandImageList(std::move(_o.brandImageList))
	, tournId(std::move(_o.tournId))
	, admission(std::move(_o.admission))
	, tChips(std::move(_o.tChips))
	, tournUsersFlags(std::move(_o.tournUsersFlags))
	, pppEntryId(std::move(_o.pppEntryId))
{
}

TournClientThin::publication::TournPlayerDataSubscr_User& TournClientThin::publication::TournPlayerDataSubscr_User::operator=(TournPlayerDataSubscr_User&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		city = std::move(_o.city);
		place = std::move(_o.place);
		placeTo = std::move(_o.placeTo);
		publProp = std::move(_o.publProp);
		bounty = std::move(_o.bounty);
		country = std::move(_o.country);
		showCity = std::move(_o.showCity);
		imageId = std::move(_o.imageId);
		entryNum = std::move(_o.entryNum);
		brandImageList = std::move(_o.brandImageList);
		tournId = std::move(_o.tournId);
		admission = std::move(_o.admission);
		tChips = std::move(_o.tChips);
		tournUsersFlags = std::move(_o.tournUsersFlags);
		pppEntryId = std::move(_o.pppEntryId);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournPlayerDataSubscr_User::clear()
{
	name.clear();
	city.clear();
	place = 0;
	placeTo = 0;
	publProp = 0;
	bounty = 0;
	country.clear();
	showCity = 0;
	imageId = 0;
	entryNum = 0;
	brandImageList.clear();
	tournId = 0;
	admission.clear();
	tChips = 0;
	tournUsersFlags = 0;
	pppEntryId = 0;
}

bool TournClientThin::publication::TournPlayerDataSubscr_User::equals(const TournPlayerDataSubscr_User& _o) const
{
	return name.equals(_o.name) &&
		city.equals(_o.city) &&
		place == _o.place &&
		placeTo == _o.placeTo &&
		publProp == _o.publProp &&
		bounty == _o.bounty &&
		country.equals(_o.country) &&
		showCity == _o.showCity &&
		imageId == _o.imageId &&
		entryNum == _o.entryNum &&
		brandImageList.equals(_o.brandImageList) &&
		tournId == _o.tournId &&
		admission.equals(_o.admission) &&
		tChips == _o.tChips &&
		tournUsersFlags == _o.tournUsersFlags &&
		pppEntryId == _o.pppEntryId;
}

const char *TournClientThin::publication::TournPlayerDataSubscr_User::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("place=");
	_buf.appendInt(place);
	_buf.append(',');
	_buf.append("placeTo=");
	_buf.appendInt(placeTo);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendInt(bounty);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("showCity=");
	_buf.appendUint(showCity);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("entryNum=");
	_buf.appendUint(entryNum);
	_buf.append(',');
	_buf.append("brandImageList=");
	brandImageList.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append(',');
	_buf.append("admission=");
	_buf.append(admission);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("tournUsersFlags=");
	_buf.appendUint(tournUsersFlags);
	_buf.append(',');
	_buf.append("pppEntryId=");
	_buf.appendUint64(pppEntryId);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournPlayerDataSubscr_User::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
	_msg.composeString(city);
	_msg.composeINT32(place);
	_msg.composeINT32(placeTo);
	_msg.composeBYTE(publProp);
	_msg.composeINT32(bounty);
	_msg.composeString(country);
	_msg.composeBYTE(showCity);
	_msg.composeUINT32(imageId);
	_msg.composeUINT16(entryNum);
	brandImageList.composeMsg(_msg);
	_msg.composeUINT64(tournId);
	_msg.composeString(admission);
	_msg.composeINT32(tChips);
	_msg.composeUINT32(tournUsersFlags);
	_msg.composeUINT64(pppEntryId);
}

void TournClientThin::publication::TournPlayerDataSubscr_User::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseStringP(city);
	_parser.parseINT32(place);
	_parser.parseINT32(placeTo);
	_parser.parseBYTE(publProp);
	_parser.parseINT32(bounty);
	_parser.parseStringP(country);
	_parser.parseBYTE(showCity);
	_parser.parseUINT32(imageId);
	_parser.parseUINT16(entryNum);
	brandImageList.parseMsg(_parser);
	_parser.parseUINT64(tournId);
	_parser.parseStringP(admission);
	_parser.parseINT32(tChips);
	_parser.parseUINT32(tournUsersFlags);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(pppEntryId);
}

/*static*/ void TournClientThin::publication::TournPlayerDataSubscr_User::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	INT32 place; _parser.parseINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	INT32 placeTo; _parser.parseINT32(placeTo);
	AtfValidator::validateInt(_descr, "placeTo", placeTo, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	INT32 bounty; _parser.parseINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
	BYTE showCity; _parser.parseBYTE(showCity);
	AtfValidator::validateInt(_descr, "showCity", showCity, _checker, __FILE__, __LINE__);
	UINT32 imageId; _parser.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	UINT16 entryNum; _parser.parseUINT16(entryNum);
	AtfValidator::validateInt(_descr, "entryNum", entryNum, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BrandProtThin::BrandImageList::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("brandImageList"), _fieldsWithUnparsedContent);
	UINT64 tournId; _parser.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "admission"); size_t szAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admission", szAdmission, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	UINT32 tournUsersFlags; _parser.parseUINT32(tournUsersFlags);
	AtfValidator::validateInt(_descr, "tournUsersFlags", tournUsersFlags, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 pppEntryId; _parser.parseUINT64(pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournPlayerDataSubscr_Chips
//=================================================================

TournClientThin::publication::TournPlayerDataSubscr_Chips::TournPlayerDataSubscr_Chips()
{
	clear();
}

void TournClientThin::publication::TournPlayerDataSubscr_Chips::clear()
{
	chips = 0;
	rank = 0;
	award = 0;
}

bool TournClientThin::publication::TournPlayerDataSubscr_Chips::equals(const TournPlayerDataSubscr_Chips& _o) const
{
	return chips == _o.chips &&
		rank == _o.rank &&
		award == _o.award;
}

const char *TournClientThin::publication::TournPlayerDataSubscr_Chips::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendUint(award);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournPlayerDataSubscr_Chips::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(chips);
	_msg.composeUINT16(rank);
	_msg.composeUINT32(award);
}

void TournClientThin::publication::TournPlayerDataSubscr_Chips::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(chips);
	_parser.parseUINT16(rank);
	_parser.parseUINT32(award);
}

/*static*/ void TournClientThin::publication::TournPlayerDataSubscr_Chips::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	UINT16 rank; _parser.parseUINT16(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	UINT32 award; _parser.parseUINT32(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournPlayerDataSubscr_Knockouts
//=================================================================

TournClientThin::publication::TournPlayerDataSubscr_Knockouts::TournPlayerDataSubscr_Knockouts()
{
	clear();
}

void TournClientThin::publication::TournPlayerDataSubscr_Knockouts::clear()
{
	knockouts = 0;
	headBounty = 0;
	collectedTotal = 0;
}

bool TournClientThin::publication::TournPlayerDataSubscr_Knockouts::equals(const TournPlayerDataSubscr_Knockouts& _o) const
{
	return knockouts == _o.knockouts &&
		headBounty == _o.headBounty &&
		collectedTotal == _o.collectedTotal;
}

const char *TournClientThin::publication::TournPlayerDataSubscr_Knockouts::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("knockouts=");
	_buf.appendInt(knockouts);
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendInt(headBounty);
	_buf.append(',');
	_buf.append("collectedTotal=");
	_buf.appendInt(collectedTotal);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournPlayerDataSubscr_Knockouts::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(knockouts);
	_msg.composeINT32(headBounty);
	_msg.composeINT32(collectedTotal);
}

void TournClientThin::publication::TournPlayerDataSubscr_Knockouts::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(knockouts);
	_parser.parseINT32(headBounty);
	_parser.parseINT32(collectedTotal);
}

/*static*/ void TournClientThin::publication::TournPlayerDataSubscr_Knockouts::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	INT32 knockouts; _parser.parseINT32(knockouts);
	AtfValidator::validateInt(_descr, "knockouts", knockouts, _checker, __FILE__, __LINE__);
	INT32 headBounty; _parser.parseINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	INT32 collectedTotal; _parser.parseINT32(collectedTotal);
	AtfValidator::validateInt(_descr, "collectedTotal", collectedTotal, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournPlayerDataSubscr_Ticket
//=================================================================

TournClientThin::publication::TournPlayerDataSubscr_Ticket::TournPlayerDataSubscr_Ticket()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournPlayerDataSubscr_Ticket::TournPlayerDataSubscr_Ticket(TournPlayerDataSubscr_Ticket&& _o)
	: nextTournId(std::move(_o.nextTournId))
	, ticketAdmission(std::move(_o.ticketAdmission))
{
}

TournClientThin::publication::TournPlayerDataSubscr_Ticket& TournClientThin::publication::TournPlayerDataSubscr_Ticket::operator=(TournPlayerDataSubscr_Ticket&& _o)
{
	if(this != &_o)
	{
		nextTournId = std::move(_o.nextTournId);
		ticketAdmission = std::move(_o.ticketAdmission);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournPlayerDataSubscr_Ticket::clear()
{
	nextTournId = 0;
	ticketAdmission.clear();
}

bool TournClientThin::publication::TournPlayerDataSubscr_Ticket::equals(const TournPlayerDataSubscr_Ticket& _o) const
{
	return nextTournId == _o.nextTournId &&
		ticketAdmission.equals(_o.ticketAdmission);
}

const char *TournClientThin::publication::TournPlayerDataSubscr_Ticket::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("nextTournId=");
	_buf.appendUint(nextTournId);
	_buf.append(',');
	_buf.append("ticketAdmission=");
	_buf.append(ticketAdmission);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournPlayerDataSubscr_Ticket::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(nextTournId);
	_msg.composeString(ticketAdmission);
}

void TournClientThin::publication::TournPlayerDataSubscr_Ticket::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(nextTournId);
	_parser.parseStringP(ticketAdmission);
}

/*static*/ void TournClientThin::publication::TournPlayerDataSubscr_Ticket::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 nextTournId; _parser.parseUINT32(nextTournId);
	AtfValidator::validateInt(_descr, "nextTournId", nextTournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ticketAdmission"); size_t szTicketAdmission = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketAdmission", szTicketAdmission, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournTableData_Stat
//=================================================================

TournClientThin::publication::TournTableData_Stat::TournTableData_Stat()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournTableData_Stat::TournTableData_Stat(TournTableData_Stat&& _o)
	: tableId(std::move(_o.tableId))
	, name(std::move(_o.name))
	, server(std::move(_o.server))
	, serverObj(std::move(_o.serverObj))
	, placeHolder(std::move(_o.placeHolder))
	, tableId64(std::move(_o.tableId64))
{
}

TournClientThin::publication::TournTableData_Stat& TournClientThin::publication::TournTableData_Stat::operator=(TournTableData_Stat&& _o)
{
	if(this != &_o)
	{
		tableId = std::move(_o.tableId);
		name = std::move(_o.name);
		server = std::move(_o.server);
		serverObj = std::move(_o.serverObj);
		placeHolder = std::move(_o.placeHolder);
		tableId64 = std::move(_o.tableId64);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournTableData_Stat::clear()
{
	tableId = 0;
	name.clear();
	server.clear();
	serverObj.clear();
	placeHolder = 0;
	tableId64 = 0;
}

bool TournClientThin::publication::TournTableData_Stat::equals(const TournTableData_Stat& _o) const
{
	return tableId == _o.tableId &&
		name.equals(_o.name) &&
		server.equals(_o.server) &&
		serverObj.equals(_o.serverObj) &&
		placeHolder == _o.placeHolder &&
		tableId64 == _o.tableId64;
}

const char *TournClientThin::publication::TournTableData_Stat::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint(tableId);
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("placeHolder=");
	_buf.appendInt(placeHolder);
	_buf.append(',');
	_buf.append("tableId64=");
	_buf.appendUint64(tableId64);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournTableData_Stat::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tableId);
	_msg.composeString(name);
	_msg.composeString(server);
	_msg.composeString(serverObj);
	_msg.composeINT32(placeHolder);
	_msg.composeUINT64(tableId64);
}

void TournClientThin::publication::TournTableData_Stat::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId);
	_parser.parseStringP(name);
	_parser.parseStringP(server);
	_parser.parseStringP(serverObj);
	_parser.parseINT32(placeHolder);
	_parser.parseUINT64(tableId64);
}

/*static*/ void TournClientThin::publication::TournTableData_Stat::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 tableId; _parser.parseUINT32(tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	INT32 placeHolder; _parser.parseINT32(placeHolder);
	AtfValidator::validateInt(_descr, "placeHolder", placeHolder, _checker, __FILE__, __LINE__);
	UINT64 tableId64; _parser.parseUINT64(tableId64);
	AtfValidator::validateUint(_descr, "tableId64", tableId64, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournTableData_Dyna
//=================================================================

TournClientThin::publication::TournTableData_Dyna::TournTableData_Dyna()
{
	clear();
}

void TournClientThin::publication::TournTableData_Dyna::clear()
{
	numUsers = 0;
	minStack = 0;
	maxStack = 0;
}

bool TournClientThin::publication::TournTableData_Dyna::equals(const TournTableData_Dyna& _o) const
{
	return numUsers == _o.numUsers &&
		minStack == _o.minStack &&
		maxStack == _o.maxStack;
}

const char *TournClientThin::publication::TournTableData_Dyna::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numUsers=");
	_buf.appendUint(numUsers);
	_buf.append(',');
	_buf.append("minStack=");
	_buf.appendUint(minStack);
	_buf.append(',');
	_buf.append("maxStack=");
	_buf.appendUint(maxStack);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournTableData_Dyna::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(numUsers);
	_msg.composeUINT32(minStack);
	_msg.composeUINT32(maxStack);
}

void TournClientThin::publication::TournTableData_Dyna::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(numUsers);
	_parser.parseUINT32(minStack);
	_parser.parseUINT32(maxStack);
}

/*static*/ void TournClientThin::publication::TournTableData_Dyna::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 numUsers; _parser.parseUINT32(numUsers);
	AtfValidator::validateInt(_descr, "numUsers", numUsers, _checker, __FILE__, __LINE__);
	UINT32 minStack; _parser.parseUINT32(minStack);
	AtfValidator::validateInt(_descr, "minStack", minStack, _checker, __FILE__, __LINE__);
	UINT32 maxStack; _parser.parseUINT32(maxStack);
	AtfValidator::validateInt(_descr, "maxStack", maxStack, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournTablePlayerSubscr
//=================================================================

TournClientThin::publication::TournTablePlayerSubscr::TournTablePlayerSubscr()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournTablePlayerSubscr::TournTablePlayerSubscr(TournTablePlayerSubscr&& _o)
	: position(std::move(_o.position))
	, userName(std::move(_o.userName))
	, chips(std::move(_o.chips))
	, cityData(std::move(_o.cityData))
	, showCity(std::move(_o.showCity))
	, publProp(std::move(_o.publProp))
	, headBounty(std::move(_o.headBounty))
	, collectedBountyKnockouts(std::move(_o.collectedBountyKnockouts))
	, imageId(std::move(_o.imageId))
	, brandImageList(std::move(_o.brandImageList))
{
}

TournClientThin::publication::TournTablePlayerSubscr& TournClientThin::publication::TournTablePlayerSubscr::operator=(TournTablePlayerSubscr&& _o)
{
	if(this != &_o)
	{
		position = std::move(_o.position);
		userName = std::move(_o.userName);
		chips = std::move(_o.chips);
		cityData = std::move(_o.cityData);
		showCity = std::move(_o.showCity);
		publProp = std::move(_o.publProp);
		headBounty = std::move(_o.headBounty);
		collectedBountyKnockouts = std::move(_o.collectedBountyKnockouts);
		imageId = std::move(_o.imageId);
		brandImageList = std::move(_o.brandImageList);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournTablePlayerSubscr::clear()
{
	position = 0;
	userName.clear();
	chips = 0;
	cityData.clear();
	showCity = 0;
	publProp = 0;
	headBounty = 0;
	collectedBountyKnockouts = 0;
	imageId = 0;
	brandImageList.clear();
}

bool TournClientThin::publication::TournTablePlayerSubscr::equals(const TournTablePlayerSubscr& _o) const
{
	return position == _o.position &&
		userName.equals(_o.userName) &&
		chips == _o.chips &&
		cityData.equals(_o.cityData) &&
		showCity == _o.showCity &&
		publProp == _o.publProp &&
		headBounty == _o.headBounty &&
		collectedBountyKnockouts == _o.collectedBountyKnockouts &&
		imageId == _o.imageId &&
		brandImageList.equals(_o.brandImageList);
}

const char *TournClientThin::publication::TournTablePlayerSubscr::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("position=");
	_buf.appendUint(position);
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("cityData=");
	_buf.append(cityData);
	_buf.append(',');
	_buf.append("showCity=");
	_buf.appendUint(showCity);
	_buf.append(',');
	_buf.append("publProp=");
	_buf.appendUint(publProp);
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendInt(headBounty);
	_buf.append(',');
	_buf.append("collectedBountyKnockouts=");
	_buf.appendInt(collectedBountyKnockouts);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("brandImageList=");
	brandImageList.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournTablePlayerSubscr::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(TournTablePlayerSubscr())) // not empty
	{
		_body.composeBYTE(position);
		_body.composeString(userName);
		_body.composeINT32(chips);
		_body.composeString(cityData);
		_body.composeBYTE(showCity);
		_body.composeBYTE(publProp);
		_body.composeINT32(headBounty);
		_body.composeINT32(collectedBountyKnockouts);
		_body.composeUINT32(imageId);
		brandImageList.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void TournClientThin::publication::TournTablePlayerSubscr::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(position);
	_parser0.parseStringP(userName);
	_parser0.parseINT32(chips);
	_parser0.parseStringP(cityData);
	_parser0.parseBYTE(showCity);
	_parser0.parseBYTE(publProp);
	_parser0.parseINT32(headBounty);
	_parser0.parseINT32(collectedBountyKnockouts);
	_parser0.parseUINT32(imageId);
	brandImageList.parseMsg(_parser0);
}

/*static*/ void TournClientThin::publication::TournTablePlayerSubscr::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE position; _parser0.parseBYTE(position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userName", szUserName, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "cityData"); size_t szCityData = strlen(_dummy);
	AtfValidator::validateInt(_descr, "cityData", szCityData, _checker, __FILE__, __LINE__);
	BYTE showCity; _parser0.parseBYTE(showCity);
	AtfValidator::validateInt(_descr, "showCity", showCity, _checker, __FILE__, __LINE__);
	BYTE publProp; _parser0.parseBYTE(publProp);
	AtfValidator::validateInt(_descr, "publProp", publProp, _checker, __FILE__, __LINE__);
	INT32 headBounty; _parser0.parseINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	INT32 collectedBountyKnockouts; _parser0.parseINT32(collectedBountyKnockouts);
	AtfValidator::validateInt(_descr, "collectedBountyKnockouts", collectedBountyKnockouts, _checker, __FILE__, __LINE__);
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BrandProtThin::BrandImageList::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("brandImageList"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournTableWithPlayersSubscr
//=================================================================

TournClientThin::publication::TournTableWithPlayersSubscr::TournTableWithPlayersSubscr()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::publication::TournTableWithPlayersSubscr::TournTableWithPlayersSubscr(TournTableWithPlayersSubscr&& _o)
	: oldSubCount(std::move(_o.oldSubCount))
	, players(std::move(_o.players))
{
}

TournClientThin::publication::TournTableWithPlayersSubscr& TournClientThin::publication::TournTableWithPlayersSubscr::operator=(TournTableWithPlayersSubscr&& _o)
{
	if(this != &_o)
	{
		oldSubCount = std::move(_o.oldSubCount);
		players = std::move(_o.players);
	}
	return *this;
}

#endif

void TournClientThin::publication::TournTableWithPlayersSubscr::clear()
{
	oldSubCount = 0;
	players.clear();
}

bool TournClientThin::publication::TournTableWithPlayersSubscr::equals(const TournTableWithPlayersSubscr& _o) const
{
	return oldSubCount == _o.oldSubCount &&
		players.equals(_o.players);
}

const char *TournClientThin::publication::TournTableWithPlayersSubscr::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("oldSubCount=");
	_buf.appendUint(oldSubCount);
	_buf.append(',');
	_buf.append("players=");
	players.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::publication::TournTableWithPlayersSubscr::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(oldSubCount);
	players.composeMsg(_msg);
}

void TournClientThin::publication::TournTableWithPlayersSubscr::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(oldSubCount);
	players.parseMsg(_parser);
}

/*static*/ void TournClientThin::publication::TournTableWithPlayersSubscr::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE oldSubCount; _parser.parseBYTE(oldSubCount);
	AtfValidator::validateInt(_descr, "oldSubCount", oldSubCount, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPlayers = ThinAtf::LAtfVector< TournTablePlayerSubscr, 1 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("players"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "players", szPlayers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    P_UserTicketData
//=================================================================

TournClientThin::player::P_UserTicketData::P_UserTicketData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::player::P_UserTicketData::P_UserTicketData(P_UserTicketData&& _o)
	: admissionId(std::move(_o.admissionId))
	, totalCount(std::move(_o.totalCount))
	, reserved(std::move(_o.reserved))
{
}

TournClientThin::player::P_UserTicketData& TournClientThin::player::P_UserTicketData::operator=(P_UserTicketData&& _o)
{
	if(this != &_o)
	{
		admissionId = std::move(_o.admissionId);
		totalCount = std::move(_o.totalCount);
		reserved = std::move(_o.reserved);
	}
	return *this;
}

#endif

void TournClientThin::player::P_UserTicketData::clear()
{
	admissionId.clear();
	totalCount = 0;
	reserved = 0;
}

bool TournClientThin::player::P_UserTicketData::equals(const P_UserTicketData& _o) const
{
	return admissionId.equals(_o.admissionId) &&
		totalCount == _o.totalCount &&
		reserved == _o.reserved;
}

const char *TournClientThin::player::P_UserTicketData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("admissionId=");
	_buf.append(admissionId);
	_buf.append(',');
	_buf.append("totalCount=");
	_buf.appendUint(totalCount);
	_buf.append(',');
	_buf.append("reserved=");
	_buf.appendUint(reserved);
	_buf.append('}');
	return _buf.c_str();
}

void TournClientThin::player::P_UserTicketData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(admissionId);
	_msg.composeUINT32(totalCount);
	_msg.composeUINT32(reserved);
}

void TournClientThin::player::P_UserTicketData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(admissionId);
	_parser.parseUINT32(totalCount);
	_parser.parseUINT32(reserved);
}

/*static*/ void TournClientThin::player::P_UserTicketData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
	UINT32 totalCount; _parser.parseUINT32(totalCount);
	AtfValidator::validateInt(_descr, "totalCount", totalCount, _checker, __FILE__, __LINE__);
	UINT32 reserved; _parser.parseUINT32(reserved);
	AtfValidator::validateInt(_descr, "reserved", reserved, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO
//=================================================================

TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::Protocol_MSG_LOBBY_TOURN_REG_INFO(Protocol_MSG_LOBBY_TOURN_REG_INFO&& _o)
	: userId(std::move(_o.userId))
	, tournId(std::move(_o.tournId))
	, tournRegInfoFlags(std::move(_o.tournRegInfoFlags))
{
}

TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO& TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		tournId = std::move(_o.tournId);
		tournRegInfoFlags = std::move(_o.tournRegInfoFlags);
	}
	return *this;
}

#endif

void TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::clear()
{
	userId.clear();
	tournId = 0;
	tournRegInfoFlags = 0;
}

bool TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO& _o) const
{
	return userId.equals(_o.userId) &&
		tournId == _o.tournId &&
		tournRegInfoFlags == _o.tournRegInfoFlags;
}

const char *TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournRegInfoFlags=");
	_buf.appendUint(tournRegInfoFlags);
	return _buf.c_str();
}

void TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(tournRegInfoFlags);
}

void TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(tournRegInfoFlags);
}

/*static*/ void TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 tournRegInfoFlags; _parser.parseUINT32(tournRegInfoFlags);
	AtfValidator::validateIntMax(_descr, "tournRegInfoFlags", tournRegInfoFlags, static_cast<UINT32>(TournRegInfoFlags::eTournRegInfoFlags_Last), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY
//=================================================================

TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errInfo(std::move(_o.errInfo))
	, currency(std::move(_o.currency))
	, buyInAndRake(std::move(_o.buyInAndRake))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, tournSpendLimit(std::move(_o.tournSpendLimit))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, fpp(std::move(_o.fpp))
	, admissionId(std::move(_o.admissionId))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, isPwdProtected(std::move(_o.isPwdProtected))
	, userChips(std::move(_o.userChips))
	, userPlayChips(std::move(_o.userPlayChips))
	, userFpp(std::move(_o.userFpp))
	, numTickets(std::move(_o.numTickets))
	, tChips(std::move(_o.tChips))
	, wChips(std::move(_o.wChips))
	, preRegMsg(std::move(_o.preRegMsg))
	, game(std::move(_o.game))
	, isHiLo(std::move(_o.isHiLo))
	, structure(std::move(_o.structure))
	, currencyContext(std::move(_o.currencyContext))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, whenStartAbs(std::move(_o.whenStartAbs))
	, tournName(std::move(_o.tournName))
	, playChips64(std::move(_o.playChips64))
	, scalePM(std::move(_o.scalePM))
	, speed(std::move(_o.speed))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, tournFlags(std::move(_o.tournFlags))
	, knockout(std::move(_o.knockout))
	, isProportional(std::move(_o.isProportional))
	, admPrice(std::move(_o.admPrice))
	, effectiveAdmissions(std::move(_o.effectiveAdmissions))
	, tournFlags2(std::move(_o.tournFlags2))
{
}

TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::operator=(Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errInfo = std::move(_o.errInfo);
		currency = std::move(_o.currency);
		buyInAndRake = std::move(_o.buyInAndRake);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		tournSpendLimit = std::move(_o.tournSpendLimit);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		fpp = std::move(_o.fpp);
		admissionId = std::move(_o.admissionId);
		isPlayMoney = std::move(_o.isPlayMoney);
		isPwdProtected = std::move(_o.isPwdProtected);
		userChips = std::move(_o.userChips);
		userPlayChips = std::move(_o.userPlayChips);
		userFpp = std::move(_o.userFpp);
		numTickets = std::move(_o.numTickets);
		tChips = std::move(_o.tChips);
		wChips = std::move(_o.wChips);
		preRegMsg = std::move(_o.preRegMsg);
		game = std::move(_o.game);
		isHiLo = std::move(_o.isHiLo);
		structure = std::move(_o.structure);
		currencyContext = std::move(_o.currencyContext);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		whenStartAbs = std::move(_o.whenStartAbs);
		tournName = std::move(_o.tournName);
		playChips64 = std::move(_o.playChips64);
		scalePM = std::move(_o.scalePM);
		speed = std::move(_o.speed);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		tournFlags = std::move(_o.tournFlags);
		knockout = std::move(_o.knockout);
		isProportional = std::move(_o.isProportional);
		admPrice = std::move(_o.admPrice);
		effectiveAdmissions = std::move(_o.effectiveAdmissions);
		tournFlags2 = std::move(_o.tournFlags2);
	}
	return *this;
}

#endif

void TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errInfo.clear();
	currency.clear();
	buyInAndRake = 0;
	enoughMoneyInOtherCurrency = false;
	tournSpendLimit.clear();
	buyIn = 0;
	rake = 0;
	fpp = 0;
	admissionId.clear();
	isPlayMoney = 0;
	isPwdProtected = 0;
	userChips = 0;
	userPlayChips = 0;
	userFpp = 0;
	numTickets = 0;
	tChips = 0;
	wChips = 0;
	preRegMsg.clear();
	game = 0;
	isHiLo = 0;
	structure = 0;
	currencyContext.clear();
	clientCurrencyContext.clear();
	whenStartAbs.setNull();
	tournName.clear();
	playChips64 = 0;
	scalePM = 0;
	speed = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	knockout = 0;
	isProportional = false;
	admPrice = 0;
	effectiveAdmissions.clear();
	tournFlags2 = 0;
}

bool TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::equals(const Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		errInfo.equals(_o.errInfo) &&
		currency.equals(_o.currency) &&
		buyInAndRake == _o.buyInAndRake &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		tournSpendLimit.equals(_o.tournSpendLimit) &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		fpp == _o.fpp &&
		admissionId.equals(_o.admissionId) &&
		isPlayMoney == _o.isPlayMoney &&
		isPwdProtected == _o.isPwdProtected &&
		userChips == _o.userChips &&
		userPlayChips == _o.userPlayChips &&
		userFpp == _o.userFpp &&
		numTickets == _o.numTickets &&
		tChips == _o.tChips &&
		wChips == _o.wChips &&
		preRegMsg.equals(_o.preRegMsg) &&
		game == _o.game &&
		isHiLo == _o.isHiLo &&
		structure == _o.structure &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		whenStartAbs.equals(_o.whenStartAbs) &&
		tournName.equals(_o.tournName) &&
		playChips64 == _o.playChips64 &&
		scalePM == _o.scalePM &&
		speed == _o.speed &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		knockout == _o.knockout &&
		isProportional == _o.isProportional &&
		admPrice == _o.admPrice &&
		effectiveAdmissions.equals(_o.effectiveAdmissions) &&
		tournFlags2 == _o.tournFlags2;
}

const char *TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TOURN_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errInfo=");
		errInfo.toTraceString(_buf);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInAndRake=");
		_buf.appendUint(buyInAndRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	else if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInAndRake=");
		_buf.appendUint(buyInAndRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendUint(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("fpp=");
		_buf.appendUint(fpp);
		_buf.append(',');
		_buf.append("admissionId=");
		_buf.append(admissionId);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("isPwdProtected=");
		_buf.appendUint(isPwdProtected);
		_buf.append(',');
		_buf.append("userChips=");
		_buf.appendUint(userChips);
		_buf.append(',');
		_buf.append("userPlayChips=");
		_buf.appendUint(userPlayChips);
		_buf.append(',');
		_buf.append("userFpp=");
		_buf.appendUint(userFpp);
		_buf.append(',');
		_buf.append("numTickets=");
		_buf.appendUint(numTickets);
		_buf.append(',');
		_buf.append("tChips=");
		_buf.appendUint(tChips);
		_buf.append(',');
		_buf.append("wChips=");
		_buf.appendUint(wChips);
		_buf.append(',');
		_buf.append("preRegMsg=");
		_buf.append(preRegMsg);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		currencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		clientCurrencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("whenStartAbs=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStartAbs);
		_buf.append(',');
		_buf.append("tournName=");
		_buf.append(tournName);
		_buf.append(',');
		_buf.append("playChips64=");
		_buf.appendUint64(playChips64);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("speed=");
		_buf.appendUint(speed);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendUint(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("knockout=");
		_buf.appendUint(knockout);
		_buf.append(',');
		_buf.append("isProportional=");
		_buf.appendUint(isProportional);
		_buf.append(',');
		_buf.append("admPrice=");
		_buf.appendInt64(admPrice);
		_buf.append(',');
		_buf.append("effectiveAdmissions=");
		effectiveAdmissions.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendInt64(tournFlags2);
		_buf.append(',');
		_buf.append("tournSpendLimit=");
		tournSpendLimit.toTraceString(_buf);
	}
	return _buf.c_str();
}

void TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_msg.composeString(errDescr);
		errInfo.composeMsg(_msg);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeUINT32(buyInAndRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		tournSpendLimit.composeMsg(_msg);
	}
	else if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeUINT32(buyInAndRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_msg.composeUINT32(buyIn);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(fpp);
		_msg.composeString(admissionId);
		_msg.composeBYTE(isPlayMoney);
		_msg.composeBYTE(isPwdProtected);
		_msg.composeUINT32(userChips);
		_msg.composeUINT32(userPlayChips);
		_msg.composeUINT32(userFpp);
		_msg.composeUINT32(numTickets);
		_msg.composeUINT32(tChips);
		_msg.composeUINT32(wChips);
		_msg.composeString(preRegMsg);
		_msg.composeBYTE(game);
		_msg.composeBYTE(isHiLo);
		_msg.composeBYTE(structure);
		_msg.composeString(currency);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeSrvTime(whenStartAbs);
		_msg.composeString(tournName);
		_msg.composeUINT64(playChips64);
		_msg.composeINT32(scalePM);
		_msg.composeBYTE(speed);
		_msg.composeUINT32(minPlayers);
		_msg.composeUINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT32(knockout);
		_msg.composeBOOL(isProportional);
		_msg.composeINT64(admPrice);
		effectiveAdmissions.composeMsg(_msg);
		_msg.composeINT64(tournFlags2);
		tournSpendLimit.composeMsg(_msg);
	}
}

void TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_parser.parseStringP(errDescr);
		errInfo.parseMsg(_parser);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseUINT32(buyInAndRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		tournSpendLimit.parseMsg(_parser);
	}
	else if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseUINT32(buyInAndRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_parser.parseUINT32(buyIn);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(fpp);
		_parser.parseStringP(admissionId);
		_parser.parseBYTE(isPlayMoney);
		_parser.parseBYTE(isPwdProtected);
		_parser.parseUINT32(userChips);
		_parser.parseUINT32(userPlayChips);
		_parser.parseUINT32(userFpp);
		_parser.parseUINT32(numTickets);
		_parser.parseUINT32(tChips);
		_parser.parseUINT32(wChips);
		_parser.parseStringP(preRegMsg);
		_parser.parseBYTE(game);
		_parser.parseBYTE(isHiLo);
		_parser.parseBYTE(structure);
		_parser.parseStringP(currency);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseSrvTime(whenStartAbs);
		_parser.parseStringP(tournName);
		_parser.parseUINT64(playChips64);
		_parser.parseINT32(scalePM);
		_parser.parseBYTE(speed);
		_parser.parseUINT32(minPlayers);
		_parser.parseUINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT32(knockout);
		_parser.parseBOOL(isProportional);
		_parser.parseINT64(admPrice);
		effectiveAdmissions.parseMsg(_parser);
		_parser.parseINT64(tournFlags2);
		if(_parser.parseEnded()) return;
		tournSpendLimit.parseMsg(_parser);
	}
}

/*static*/ void TournClientThin::player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TOURN_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournCommonThin::Error_InsufficientFunds32::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("errInfo"), _fieldsWithUnparsedContent);
	}
	else if( errCode == TOURN_SPEND_LIMIT_EXCEEDED )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _parser.parseUINT32(buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournCommonThin::TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	else if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 buyInAndRake; _parser.parseUINT32(buyInAndRake);
		AtfValidator::validateInt(_descr, "buyInAndRake", buyInAndRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 buyIn; _parser.parseUINT32(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 fpp; _parser.parseUINT32(fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
		BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		BYTE isPwdProtected; _parser.parseBYTE(isPwdProtected);
		AtfValidator::validateInt(_descr, "isPwdProtected", isPwdProtected, _checker, __FILE__, __LINE__);
		UINT32 userChips; _parser.parseUINT32(userChips);
		AtfValidator::validateInt(_descr, "userChips", userChips, _checker, __FILE__, __LINE__);
		UINT32 userPlayChips; _parser.parseUINT32(userPlayChips);
		AtfValidator::validateInt(_descr, "userPlayChips", userPlayChips, _checker, __FILE__, __LINE__);
		UINT32 userFpp; _parser.parseUINT32(userFpp);
		AtfValidator::validateInt(_descr, "userFpp", userFpp, _checker, __FILE__, __LINE__);
		UINT32 numTickets; _parser.parseUINT32(numTickets);
		AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
		UINT32 tChips; _parser.parseUINT32(tChips);
		AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
		UINT32 wChips; _parser.parseUINT32(wChips);
		AtfValidator::validateInt(_descr, "wChips", wChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegMsg"); size_t szPreRegMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegMsg", szPreRegMsg, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE isHiLo; _parser.parseBYTE(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		SrvTime whenStartAbs; _parser.parseSrvTime(whenStartAbs);
		AtfValidator::validateSrvDateTime(_descr, "whenStartAbs", whenStartAbs, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
		UINT64 playChips64; _parser.parseUINT64(playChips64);
		AtfValidator::validateUint(_descr, "playChips64", playChips64, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE speed; _parser.parseBYTE(speed);
		AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
		UINT32 minPlayers; _parser.parseUINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT32 knockout; _parser.parseUINT32(knockout);
		AtfValidator::validateInt(_descr, "knockout", knockout, _checker, __FILE__, __LINE__);
		bool isProportional; _parser.parseBOOL(isProportional);
		AtfValidator::validateInt(_descr, "isProportional", isProportional, _checker, __FILE__, __LINE__);
		INT64 admPrice; _parser.parseINT64(admPrice);
		AtfValidator::validateInt(_descr, "admPrice", admPrice, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szEffectiveAdmissions = ThinAtf::LAtfVector< P_UserTicketData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("effectiveAdmissions"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "effectiveAdmissions", szEffectiveAdmissions, _checker, __FILE__, __LINE__);
		INT64 tournFlags2; _parser.parseINT64(tournFlags2);
		AtfValidator::validateInt(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		TournCommonThin::TournSpendLimit::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSpendLimit"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_REGISTER_USER
//=================================================================

TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER::Protocol_MTL_LOBBY_REGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER::Protocol_MTL_LOBBY_REGISTER_USER(Protocol_MTL_LOBBY_REGISTER_USER&& _o)
	: userId(std::move(_o.userId))
	, buyinRM(std::move(_o.buyinRM))
	, buyinPM(std::move(_o.buyinPM))
	, buyinFpp(std::move(_o.buyinFpp))
	, password(std::move(_o.password))
	, useTicket(std::move(_o.useTicket))
	, buyinTChips(std::move(_o.buyinTChips))
	, buyinWChips(std::move(_o.buyinWChips))
	, currencyContext(std::move(_o.currencyContext))
	, currency(std::move(_o.currency))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, structure(std::move(_o.structure))
	, startTime(std::move(_o.startTime))
{
}

TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER& TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER::operator=(Protocol_MTL_LOBBY_REGISTER_USER&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		buyinRM = std::move(_o.buyinRM);
		buyinPM = std::move(_o.buyinPM);
		buyinFpp = std::move(_o.buyinFpp);
		password = std::move(_o.password);
		useTicket = std::move(_o.useTicket);
		buyinTChips = std::move(_o.buyinTChips);
		buyinWChips = std::move(_o.buyinWChips);
		currencyContext = std::move(_o.currencyContext);
		currency = std::move(_o.currency);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		structure = std::move(_o.structure);
		startTime = std::move(_o.startTime);
	}
	return *this;
}

#endif

void TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER::clear()
{
	userId.clear();
	buyinRM = 0;
	buyinPM = 0;
	buyinFpp = 0;
	password.clear();
	useTicket = 0;
	buyinTChips = 0;
	buyinWChips = 0;
	currencyContext.clear();
	currency.clear();
	game = 0;
	hiLo = 0;
	structure = 0;
	startTime.setNull();
}

bool TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER::equals(const Protocol_MTL_LOBBY_REGISTER_USER& _o) const
{
	return userId.equals(_o.userId) &&
		buyinRM == _o.buyinRM &&
		buyinPM == _o.buyinPM &&
		buyinFpp == _o.buyinFpp &&
		password.equals(_o.password) &&
		useTicket == _o.useTicket &&
		buyinTChips == _o.buyinTChips &&
		buyinWChips == _o.buyinWChips &&
		currencyContext.equals(_o.currencyContext) &&
		currency.equals(_o.currency) &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		structure == _o.structure &&
		startTime.equals(_o.startTime);
}

const char *TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_REGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("buyinRM=");
	_buf.appendUint(buyinRM);
	_buf.append(',');
	_buf.append("buyinPM=");
	_buf.appendUint(buyinPM);
	_buf.append(',');
	_buf.append("buyinFpp=");
	_buf.appendUint(buyinFpp);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("buyinTChips=");
	_buf.appendUint(buyinTChips);
	_buf.append(',');
	_buf.append("buyinWChips=");
	_buf.appendUint(buyinWChips);
	_buf.append(',');
	_buf.append("currencyContext=");
	currencyContext.toTraceString(_buf);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("startTime=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	return _buf.c_str();
}

void TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(buyinRM);
	_msg.composeUINT32(buyinPM);
	_msg.composeUINT32(buyinFpp);
	_msg.composeString(password);
	_msg.composeBYTE(useTicket);
	_msg.composeUINT32(buyinTChips);
	_msg.composeUINT32(buyinWChips);
	_msg.composeMsgBody(currencyContext);
	_msg.composeString(currency);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeBYTE(structure);
	_msg.composeSrvTime(startTime);
}

void TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(buyinRM);
	_parser.parseUINT32(buyinPM);
	_parser.parseUINT32(buyinFpp);
	_parser.parseStringP(password);
	_parser.parseBYTE(useTicket);
	_parser.parseUINT32(buyinTChips);
	_parser.parseUINT32(buyinWChips);
	_parser.parseMsgBody(currencyContext);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(currency);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseBYTE(structure);
	_parser.parseSrvTime(startTime);
}

/*static*/ void TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 buyinRM; _parser.parseUINT32(buyinRM);
	AtfValidator::validateInt(_descr, "buyinRM", buyinRM, _checker, __FILE__, __LINE__);
	UINT32 buyinPM; _parser.parseUINT32(buyinPM);
	AtfValidator::validateInt(_descr, "buyinPM", buyinPM, _checker, __FILE__, __LINE__);
	UINT32 buyinFpp; _parser.parseUINT32(buyinFpp);
	AtfValidator::validateInt(_descr, "buyinFpp", buyinFpp, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 100, _checker, __FILE__, __LINE__);
	BYTE useTicket; _parser.parseBYTE(useTicket);
	AtfValidator::validateInt(_descr, "useTicket", useTicket, _checker, __FILE__, __LINE__);
	UINT32 buyinTChips; _parser.parseUINT32(buyinTChips);
	AtfValidator::validateInt(_descr, "buyinTChips", buyinTChips, _checker, __FILE__, __LINE__);
	UINT32 buyinWChips; _parser.parseUINT32(buyinWChips);
	AtfValidator::validateInt(_descr, "buyinWChips", buyinWChips, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	SrvTime startTime; _parser.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_REGISTER_USER_REPLY
//=================================================================

TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::Protocol_MTL_LOBBY_REGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::Protocol_MTL_LOBBY_REGISTER_USER_REPLY(Protocol_MTL_LOBBY_REGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, maxAllins(std::move(_o.maxAllins))
	, registrationMsg(std::move(_o.registrationMsg))
	, seatsAvailable(std::move(_o.seatsAvailable))
	, serverName(std::move(_o.serverName))
	, socialToken(std::move(_o.socialToken))
	, clientNotification(std::move(_o.clientNotification))
{
}

TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY& TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::operator=(Protocol_MTL_LOBBY_REGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		maxAllins = std::move(_o.maxAllins);
		registrationMsg = std::move(_o.registrationMsg);
		seatsAvailable = std::move(_o.seatsAvailable);
		serverName = std::move(_o.serverName);
		socialToken = std::move(_o.socialToken);
		clientNotification = std::move(_o.clientNotification);
	}
	return *this;
}

#endif

void TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	maxAllins = 0;
	registrationMsg.clear();
	seatsAvailable = false;
	serverName.clear();
	socialToken.clear();
	clientNotification.clear();
}

bool TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::equals(const Protocol_MTL_LOBBY_REGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		maxAllins == _o.maxAllins &&
		registrationMsg.equals(_o.registrationMsg) &&
		seatsAvailable == _o.seatsAvailable &&
		serverName.equals(_o.serverName) &&
		socialToken.equals(_o.socialToken) &&
		clientNotification.equals(_o.clientNotification);
}

const char *TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_REGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("maxAllins=");
		_buf.appendInt(maxAllins);
		_buf.append(',');
		_buf.append("registrationMsg=");
		_buf.append(registrationMsg);
		_buf.append(',');
		_buf.append("seatsAvailable=");
		_buf.appendUint(seatsAvailable);
		_buf.append(',');
		_buf.append("serverName=");
		_buf.append(serverName);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("clientNotification=");
		_buf.append(clientNotification);
	}
	return _buf.c_str();
}

void TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	if( !errCode )
	{
		_msg.composeINT16(maxAllins);
		_msg.composeString(registrationMsg);
		_msg.composeBOOL(seatsAvailable);
		_msg.composeString(serverName);
		_msg.composeString(socialToken);
		_msg.composeString(clientNotification);
	}
}

void TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	if( !errCode )
	{
		_parser.parseINT16(maxAllins);
		_parser.parseStringP(registrationMsg);
		_parser.parseBOOL(seatsAvailable);
		_parser.parseStringP(serverName);
		_parser.parseStringP(socialToken);
		_parser.parseStringP(clientNotification);
	}
}

/*static*/ void TournClientThin::player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_REGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		INT16 maxAllins; _parser.parseINT16(maxAllins);
		AtfValidator::validateInt(_descr, "maxAllins", maxAllins, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "registrationMsg"); size_t szRegistrationMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "registrationMsg", szRegistrationMsg, _checker, __FILE__, __LINE__);
		bool seatsAvailable; _parser.parseBOOL(seatsAvailable);
		AtfValidator::validateInt(_descr, "seatsAvailable", seatsAvailable, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverName"); size_t szServerName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverName", szServerName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clientNotification"); size_t szClientNotification = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clientNotification", szClientNotification, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_UNREGISTER_USER
//=================================================================

TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER::Protocol_MTL_LOBBY_UNREGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER::Protocol_MTL_LOBBY_UNREGISTER_USER(Protocol_MTL_LOBBY_UNREGISTER_USER&& _o)
	: tournId(std::move(_o.tournId))
	, userName(std::move(_o.userName))
{
}

TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER& TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER::operator=(Protocol_MTL_LOBBY_UNREGISTER_USER&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		userName = std::move(_o.userName);
	}
	return *this;
}

#endif

void TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER::clear()
{
	tournId = 0;
	userName.clear();
}

bool TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER::equals(const Protocol_MTL_LOBBY_UNREGISTER_USER& _o) const
{
	return tournId == _o.tournId &&
		userName.equals(_o.userName);
}

const char *TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_UNREGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("userName=");
	_buf.append(userName);
	return _buf.c_str();
}

void TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(tournId);
	_msg.composeString(userName);
}

void TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	_parser.parseStringP(userName);
}

/*static*/ void TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userName"); size_t szUserName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userName", szUserName, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY
//=================================================================

TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY(Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, refund(std::move(_o.refund))
	, refundPlay(std::move(_o.refundPlay))
	, refundFpp(std::move(_o.refundFpp))
	, refundTChips(std::move(_o.refundTChips))
	, refundWChips(std::move(_o.refundWChips))
	, tournamentCurrency(std::move(_o.tournamentCurrency))
	, refundCurrency(std::move(_o.refundCurrency))
	, refundPlay64(std::move(_o.refundPlay64))
{
}

TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY& TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::operator=(Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		refund = std::move(_o.refund);
		refundPlay = std::move(_o.refundPlay);
		refundFpp = std::move(_o.refundFpp);
		refundTChips = std::move(_o.refundTChips);
		refundWChips = std::move(_o.refundWChips);
		tournamentCurrency = std::move(_o.tournamentCurrency);
		refundCurrency = std::move(_o.refundCurrency);
		refundPlay64 = std::move(_o.refundPlay64);
	}
	return *this;
}

#endif

void TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	refund = 0;
	refundPlay = 0;
	refundFpp = 0;
	refundTChips = 0;
	refundWChips = 0;
	tournamentCurrency.clear();
	refundCurrency.clear();
	refundPlay64 = 0;
}

bool TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::equals(const Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		refund == _o.refund &&
		refundPlay == _o.refundPlay &&
		refundFpp == _o.refundFpp &&
		refundTChips == _o.refundTChips &&
		refundWChips == _o.refundWChips &&
		tournamentCurrency.equals(_o.tournamentCurrency) &&
		refundCurrency.equals(_o.refundCurrency) &&
		refundPlay64 == _o.refundPlay64;
}

const char *TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_LOBBY_UNREGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDescr=");
	_buf.append(errDescr);
	if( !errCode )
	{
		_buf.append(',');
		_buf.append("refund=");
		_buf.appendUint(refund);
		_buf.append(',');
		_buf.append("refundPlay=");
		_buf.appendInt(refundPlay);
		_buf.append(',');
		_buf.append("refundFpp=");
		_buf.appendUint(refundFpp);
		_buf.append(',');
		_buf.append("refundTChips=");
		_buf.appendUint(refundTChips);
		_buf.append(',');
		_buf.append("refundWChips=");
		_buf.appendUint(refundWChips);
		_buf.append(',');
		_buf.append("tournamentCurrency=");
		_buf.append(tournamentCurrency);
		_buf.append(',');
		_buf.append("refundCurrency=");
		_buf.append(refundCurrency);
		_buf.append(',');
		_buf.append("refundPlay64=");
		_buf.appendUint64(refundPlay64);
	}
	return _buf.c_str();
}

void TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDescr);
	if( !errCode )
	{
		_msg.composeUINT32(refund);
		_msg.composeINT32(refundPlay);
		_msg.composeUINT32(refundFpp);
		_msg.composeUINT32(refundTChips);
		_msg.composeUINT32(refundWChips);
		_msg.composeString(tournamentCurrency);
		_msg.composeString(refundCurrency);
		_msg.composeUINT64(refundPlay64);
	}
}

void TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDescr);
	if( !errCode )
	{
		_parser.parseUINT32(refund);
		_parser.parseINT32(refundPlay);
		_parser.parseUINT32(refundFpp);
		_parser.parseUINT32(refundTChips);
		_parser.parseUINT32(refundWChips);
		_parser.parseStringP(tournamentCurrency);
		_parser.parseStringP(refundCurrency);
		_parser.parseUINT64(refundPlay64);
	}
}

/*static*/ void TournClientThin::player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_LOBBY_UNREGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	if( !errCode )
	{
		UINT32 refund; _parser.parseUINT32(refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
		INT32 refundPlay; _parser.parseINT32(refundPlay);
		AtfValidator::validateInt(_descr, "refundPlay", refundPlay, _checker, __FILE__, __LINE__);
		UINT32 refundFpp; _parser.parseUINT32(refundFpp);
		AtfValidator::validateInt(_descr, "refundFpp", refundFpp, _checker, __FILE__, __LINE__);
		UINT32 refundTChips; _parser.parseUINT32(refundTChips);
		AtfValidator::validateInt(_descr, "refundTChips", refundTChips, _checker, __FILE__, __LINE__);
		UINT32 refundWChips; _parser.parseUINT32(refundWChips);
		AtfValidator::validateInt(_descr, "refundWChips", refundWChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournamentCurrency"); size_t szTournamentCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournamentCurrency", szTournamentCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "refundCurrency"); size_t szRefundCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "refundCurrency", szRefundCurrency, _checker, __FILE__, __LINE__);
		UINT64 refundPlay64; _parser.parseUINT64(refundPlay64);
		AtfValidator::validateUint(_descr, "refundPlay64", refundPlay64, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_CLI_GOTO_FINISH
//=================================================================

TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH::Protocol_MTL_CLI_GOTO_FINISH()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH::Protocol_MTL_CLI_GOTO_FINISH(Protocol_MTL_CLI_GOTO_FINISH&& _o)
	: place(std::move(_o.place))
	, popupText(std::move(_o.popupText))
	, socialToken(std::move(_o.socialToken))
	, nextScheduledTournId(std::move(_o.nextScheduledTournId))
	, startTime(std::move(_o.startTime))
	, clubId(std::move(_o.clubId))
	, clubName(std::move(_o.clubName))
	, tournId(std::move(_o.tournId))
	, tournName(std::move(_o.tournName))
	, gameType(std::move(_o.gameType))
	, isHiLo(std::move(_o.isHiLo))
	, buyin(std::move(_o.buyin))
	, rake(std::move(_o.rake))
	, knockoutBounty(std::move(_o.knockoutBounty))
	, numPlayers(std::move(_o.numPlayers))
	, isRegistered(std::move(_o.isRegistered))
	, limit(std::move(_o.limit))
	, currency(std::move(_o.currency))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, maxPlayers(std::move(_o.maxPlayers))
	, tournState(std::move(_o.tournState))
	, server(std::move(_o.server))
	, serverObject(std::move(_o.serverObject))
	, flags(std::move(_o.flags))
	, scalePM(std::move(_o.scalePM))
	, isNonFinalFlight(std::move(_o.isNonFinalFlight))
	, nextFlightLevelTargetTournName(std::move(_o.nextFlightLevelTargetTournName))
	, nextFlightLevelTargetServer(std::move(_o.nextFlightLevelTargetServer))
	, headBounty(std::move(_o.headBounty))
	, tournFinishUserFlags(std::move(_o.tournFinishUserFlags))
	, award(std::move(_o.award))
	, collectedBountyAndKnockouts(std::move(_o.collectedBountyAndKnockouts))
	, eligibleForLateReEntryUntil(std::move(_o.eligibleForLateReEntryUntil))
	, progressivePlusInitialBuyInTierId(std::move(_o.progressivePlusInitialBuyInTierId))
{
}

TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH& TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH::operator=(Protocol_MTL_CLI_GOTO_FINISH&& _o)
{
	if(this != &_o)
	{
		place = std::move(_o.place);
		popupText = std::move(_o.popupText);
		socialToken = std::move(_o.socialToken);
		nextScheduledTournId = std::move(_o.nextScheduledTournId);
		startTime = std::move(_o.startTime);
		clubId = std::move(_o.clubId);
		clubName = std::move(_o.clubName);
		tournId = std::move(_o.tournId);
		tournName = std::move(_o.tournName);
		gameType = std::move(_o.gameType);
		isHiLo = std::move(_o.isHiLo);
		buyin = std::move(_o.buyin);
		rake = std::move(_o.rake);
		knockoutBounty = std::move(_o.knockoutBounty);
		numPlayers = std::move(_o.numPlayers);
		isRegistered = std::move(_o.isRegistered);
		limit = std::move(_o.limit);
		currency = std::move(_o.currency);
		isPlayMoney = std::move(_o.isPlayMoney);
		maxPlayers = std::move(_o.maxPlayers);
		tournState = std::move(_o.tournState);
		server = std::move(_o.server);
		serverObject = std::move(_o.serverObject);
		flags = std::move(_o.flags);
		scalePM = std::move(_o.scalePM);
		isNonFinalFlight = std::move(_o.isNonFinalFlight);
		nextFlightLevelTargetTournName = std::move(_o.nextFlightLevelTargetTournName);
		nextFlightLevelTargetServer = std::move(_o.nextFlightLevelTargetServer);
		headBounty = std::move(_o.headBounty);
		tournFinishUserFlags = std::move(_o.tournFinishUserFlags);
		award = std::move(_o.award);
		collectedBountyAndKnockouts = std::move(_o.collectedBountyAndKnockouts);
		eligibleForLateReEntryUntil = std::move(_o.eligibleForLateReEntryUntil);
		progressivePlusInitialBuyInTierId = std::move(_o.progressivePlusInitialBuyInTierId);
	}
	return *this;
}

#endif

void TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH::clear()
{
	place = 0;
	popupText.clear();
	socialToken.clear();
	nextScheduledTournId = 0;
	startTime.setNull();
	clubId = 0;
	clubName.clear();
	tournId = 0;
	tournName.clear();
	gameType = 0;
	isHiLo = false;
	buyin = 0;
	rake = 0;
	knockoutBounty = 0;
	numPlayers = 0;
	isRegistered = false;
	limit = 0;
	currency.clear();
	isPlayMoney = false;
	maxPlayers = 0;
	tournState = 0;
	server.clear();
	serverObject.clear();
	flags = 0;
	scalePM = 0;
	isNonFinalFlight = false;
	nextFlightLevelTargetTournName.clear();
	nextFlightLevelTargetServer.clear();
	headBounty = 0;
	tournFinishUserFlags = 0;
	award = 0;
	collectedBountyAndKnockouts = 0;
	eligibleForLateReEntryUntil.setNull();
	progressivePlusInitialBuyInTierId = 0;
}

bool TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH::equals(const Protocol_MTL_CLI_GOTO_FINISH& _o) const
{
	return place == _o.place &&
		popupText.equals(_o.popupText) &&
		socialToken.equals(_o.socialToken) &&
		nextScheduledTournId == _o.nextScheduledTournId &&
		startTime.equals(_o.startTime) &&
		clubId == _o.clubId &&
		clubName.equals(_o.clubName) &&
		tournId == _o.tournId &&
		tournName.equals(_o.tournName) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		knockoutBounty == _o.knockoutBounty &&
		numPlayers == _o.numPlayers &&
		isRegistered == _o.isRegistered &&
		limit == _o.limit &&
		currency.equals(_o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		maxPlayers == _o.maxPlayers &&
		tournState == _o.tournState &&
		server.equals(_o.server) &&
		serverObject.equals(_o.serverObject) &&
		flags == _o.flags &&
		scalePM == _o.scalePM &&
		isNonFinalFlight == _o.isNonFinalFlight &&
		nextFlightLevelTargetTournName.equals(_o.nextFlightLevelTargetTournName) &&
		nextFlightLevelTargetServer.equals(_o.nextFlightLevelTargetServer) &&
		headBounty == _o.headBounty &&
		tournFinishUserFlags == _o.tournFinishUserFlags &&
		award == _o.award &&
		collectedBountyAndKnockouts == _o.collectedBountyAndKnockouts &&
		eligibleForLateReEntryUntil.equals(_o.eligibleForLateReEntryUntil) &&
		progressivePlusInitialBuyInTierId == _o.progressivePlusInitialBuyInTierId;
}

const char *TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_CLI_GOTO_FINISH).append(")");
	_buf.append(',');
	_buf.append("place=");
	_buf.appendUint(place);
	_buf.append(',');
	_buf.append("popupText=");
	_buf.append(popupText);
	_buf.append(',');
	_buf.append("socialToken=");
	_buf.append(socialToken);
	_buf.append(',');
	_buf.append("nextScheduledTournId=");
	_buf.appendUint(nextScheduledTournId);
	if( nextScheduledTournId )
	{
		_buf.append(',');
		_buf.append("startTime=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
		_buf.append(',');
		_buf.append("clubId=");
		_buf.appendUint(clubId);
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("tournName=");
		_buf.append(tournName);
		_buf.append(',');
		_buf.append("gameType=");
		_buf.appendUint(gameType);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("buyin=");
		_buf.appendUint(buyin);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendUint(rake);
		_buf.append(',');
		_buf.append("knockoutBounty=");
		_buf.appendUint(knockoutBounty);
		_buf.append(',');
		_buf.append("numPlayers=");
		_buf.appendUint(numPlayers);
		_buf.append(',');
		_buf.append("isRegistered=");
		_buf.appendUint(isRegistered);
		_buf.append(',');
		_buf.append("limit=");
		_buf.appendUint(limit);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("tournState=");
		_buf.appendUint(tournState);
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
	}
	_buf.append(',');
	_buf.append("isNonFinalFlight=");
	_buf.appendUint(isNonFinalFlight);
	if( isNonFinalFlight )
	{
		_buf.append(',');
		_buf.append("nextFlightLevelTargetTournName=");
		ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, nextFlightLevelTargetTournName);
		_buf.append(',');
		_buf.append("nextFlightLevelTargetServer=");
		_buf.append(nextFlightLevelTargetServer);
	}
	_buf.append(',');
	_buf.append("headBounty=");
	_buf.appendInt(headBounty);
	_buf.append(',');
	_buf.append("tournFinishUserFlags=");
	_buf.appendUint(tournFinishUserFlags);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendInt(award);
	_buf.append(',');
	_buf.append("collectedBountyAndKnockouts=");
	_buf.appendInt(collectedBountyAndKnockouts);
	_buf.append(',');
	_buf.append("eligibleForLateReEntryUntil=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, eligibleForLateReEntryUntil);
	_buf.append(',');
	_buf.append("progressivePlusInitialBuyInTierId=");
	_buf.appendUint(progressivePlusInitialBuyInTierId);
	return _buf.c_str();
}

void TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(place);
	_msg.composeString(popupText);
	_msg.composeString(socialToken);
	_msg.composeUINT32(nextScheduledTournId);
	if( nextScheduledTournId )
	{
		_msg.composeSrvTime(startTime);
		_msg.composeUINT32(clubId);
		_msg.composeString(clubName);
		_msg.composeUINT32(tournId);
		_msg.composeString(tournName);
		_msg.composeBYTE(gameType);
		_msg.composeBOOL(isHiLo);
		_msg.composeUINT32(buyin);
		_msg.composeUINT32(rake);
		_msg.composeUINT32(knockoutBounty);
		_msg.composeUINT32(numPlayers);
		_msg.composeBOOL(isRegistered);
		_msg.composeBYTE(limit);
		_msg.composeString(currency);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeUINT32(maxPlayers);
		_msg.composeUINT32(tournState);
		_msg.composeString(server);
		_msg.composeString(serverObject);
		_msg.composeUINT32(flags);
		_msg.composeINT32(scalePM);
	}
	_msg.composeBOOL(isNonFinalFlight);
	if( isNonFinalFlight )
	{
		nextFlightLevelTargetTournName.compose(_msg);
		_msg.composeString(nextFlightLevelTargetServer);
	}
	_msg.composeINT32(headBounty);
	_msg.composeUINT32(tournFinishUserFlags);
	_msg.composeINT32(award);
	_msg.composeINT32(collectedBountyAndKnockouts);
	_msg.composeSrvTime(eligibleForLateReEntryUntil);
	_msg.composeUINT32(progressivePlusInitialBuyInTierId);
}

void TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(place);
	_parser.parseStringP(popupText);
	_parser.parseStringP(socialToken);
	_parser.parseUINT32(nextScheduledTournId);
	if( nextScheduledTournId )
	{
		_parser.parseSrvTime(startTime);
		_parser.parseUINT32(clubId);
		_parser.parseStringP(clubName);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(tournName);
		_parser.parseBYTE(gameType);
		_parser.parseBOOL(isHiLo);
		_parser.parseUINT32(buyin);
		_parser.parseUINT32(rake);
		_parser.parseUINT32(knockoutBounty);
		_parser.parseUINT32(numPlayers);
		_parser.parseBOOL(isRegistered);
		_parser.parseBYTE(limit);
		_parser.parseStringP(currency);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseUINT32(maxPlayers);
		_parser.parseUINT32(tournState);
		_parser.parseStringP(server);
		_parser.parseStringP(serverObject);
		_parser.parseUINT32(flags);
		_parser.parseINT32(scalePM);
	}
	_parser.parseBOOL(isNonFinalFlight);
	if( isNonFinalFlight )
	{
		nextFlightLevelTargetTournName.parse(_parser);
		_parser.parseStringP(nextFlightLevelTargetServer);
	}
	_parser.parseINT32(headBounty);
	_parser.parseUINT32(tournFinishUserFlags);
	_parser.parseINT32(award);
	_parser.parseINT32(collectedBountyAndKnockouts);
	_parser.parseSrvTime(eligibleForLateReEntryUntil);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(progressivePlusInitialBuyInTierId);
}

/*static*/ void TournClientThin::player::Protocol_MTL_CLI_GOTO_FINISH::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_FINISH";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 nextScheduledTournId = 0;
	bool isNonFinalFlight = false;
	UINT32 place; _parser.parseUINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "popupText"); size_t szPopupText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "popupText", szPopupText, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
	AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	_parser.parseUINT32(nextScheduledTournId);
	AtfValidator::validateInt(_descr, "nextScheduledTournId", nextScheduledTournId, _checker, __FILE__, __LINE__);
	if( nextScheduledTournId )
	{
		SrvTime startTime; _parser.parseSrvTime(startTime);
		AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
		UINT32 clubId; _parser.parseUINT32(clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
		BYTE gameType; _parser.parseBYTE(gameType);
		AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		UINT32 buyin; _parser.parseUINT32(buyin);
		AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
		UINT32 rake; _parser.parseUINT32(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		UINT32 knockoutBounty; _parser.parseUINT32(knockoutBounty);
		AtfValidator::validateInt(_descr, "knockoutBounty", knockoutBounty, _checker, __FILE__, __LINE__);
		UINT32 numPlayers; _parser.parseUINT32(numPlayers);
		AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
		bool isRegistered; _parser.parseBOOL(isRegistered);
		AtfValidator::validateInt(_descr, "isRegistered", isRegistered, _checker, __FILE__, __LINE__);
		BYTE limit; _parser.parseBYTE(limit);
		AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		UINT32 maxPlayers; _parser.parseUINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		UINT32 tournState; _parser.parseUINT32(tournState);
		AtfValidator::validateInt(_descr, "tournState", tournState, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	}
	_parser.parseBOOL(isNonFinalFlight);
	AtfValidator::validateInt(_descr, "isNonFinalFlight", isNonFinalFlight, _checker, __FILE__, __LINE__);
	if( isNonFinalFlight )
	{
		I18nPString nextFlightLevelTargetTournName; nextFlightLevelTargetTournName.parse(_parser);
		_parser.parseStringN(_dummy, 0, "nextFlightLevelTargetServer"); size_t szNextFlightLevelTargetServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "nextFlightLevelTargetServer", szNextFlightLevelTargetServer, _checker, __FILE__, __LINE__);
	}
	INT32 headBounty; _parser.parseINT32(headBounty);
	AtfValidator::validateInt(_descr, "headBounty", headBounty, _checker, __FILE__, __LINE__);
	UINT32 tournFinishUserFlags; _parser.parseUINT32(tournFinishUserFlags);
	AtfValidator::validateInt(_descr, "tournFinishUserFlags", tournFinishUserFlags, _checker, __FILE__, __LINE__);
	INT32 award; _parser.parseINT32(award);
	AtfValidator::validateInt(_descr, "award", award, _checker, __FILE__, __LINE__);
	INT32 collectedBountyAndKnockouts; _parser.parseINT32(collectedBountyAndKnockouts);
	AtfValidator::validateInt(_descr, "collectedBountyAndKnockouts", collectedBountyAndKnockouts, _checker, __FILE__, __LINE__);
	SrvTime eligibleForLateReEntryUntil; _parser.parseSrvTime(eligibleForLateReEntryUntil);
	AtfValidator::validateSrvDateTime(_descr, "eligibleForLateReEntryUntil", eligibleForLateReEntryUntil, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 progressivePlusInitialBuyInTierId; _parser.parseUINT32(progressivePlusInitialBuyInTierId);
	AtfValidator::validateInt(_descr, "progressivePlusInitialBuyInTierId", progressivePlusInitialBuyInTierId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MTL_CLI_GOTO_TABLE
//=================================================================

TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE::Protocol_MTL_CLI_GOTO_TABLE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE::Protocol_MTL_CLI_GOTO_TABLE(Protocol_MTL_CLI_GOTO_TABLE&& _o)
	: serverAddr(std::move(_o.serverAddr))
	, serverObj(std::move(_o.serverObj))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, chips(std::move(_o.chips))
	, sittingIn(std::move(_o.sittingIn))
	, seat(std::move(_o.seat))
	, onConnect(std::move(_o.onConnect))
	, handId(std::move(_o.handId))
	, stats(std::move(_o.stats))
	, actionAmountOld(std::move(_o.actionAmountOld))
	, timeoutOld(std::move(_o.timeoutOld))
	, action(std::move(_o.action))
	, actionAmount(std::move(_o.actionAmount))
	, timeout(std::move(_o.timeout))
{
}

TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE& TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE::operator=(Protocol_MTL_CLI_GOTO_TABLE&& _o)
{
	if(this != &_o)
	{
		serverAddr = std::move(_o.serverAddr);
		serverObj = std::move(_o.serverObj);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		chips = std::move(_o.chips);
		sittingIn = std::move(_o.sittingIn);
		seat = std::move(_o.seat);
		onConnect = std::move(_o.onConnect);
		handId = std::move(_o.handId);
		stats = std::move(_o.stats);
		actionAmountOld = std::move(_o.actionAmountOld);
		timeoutOld = std::move(_o.timeoutOld);
		action = std::move(_o.action);
		actionAmount = std::move(_o.actionAmount);
		timeout = std::move(_o.timeout);
	}
	return *this;
}

#endif

void TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE::clear()
{
	serverAddr.clear();
	serverObj.clear();
	isPlayMoney = false;
	currency.clear();
	chips = 0;
	sittingIn = false;
	seat = 0;
	onConnect = false;
	handId = 0;
	stats = 0;
	actionAmountOld = 0;
	timeoutOld = 0;
	action = 0;
	actionAmount = 0;
	timeout = 0;
}

bool TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE::equals(const Protocol_MTL_CLI_GOTO_TABLE& _o) const
{
	return serverAddr.equals(_o.serverAddr) &&
		serverObj.equals(_o.serverObj) &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		chips == _o.chips &&
		sittingIn == _o.sittingIn &&
		seat == _o.seat &&
		onConnect == _o.onConnect &&
		handId == _o.handId &&
		stats == _o.stats &&
		actionAmountOld == _o.actionAmountOld &&
		timeoutOld == _o.timeoutOld &&
		action == _o.action &&
		actionAmount == _o.actionAmount &&
		timeout == _o.timeout;
}

const char *TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MTL_CLI_GOTO_TABLE).append(")");
	_buf.append(',');
	_buf.append("serverAddr=");
	_buf.append(serverAddr);
	_buf.append(',');
	_buf.append("serverObj=");
	_buf.append(serverObj);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("sittingIn=");
	_buf.appendUint(sittingIn);
	_buf.append(',');
	_buf.append("seat=");
	_buf.appendUint(seat);
	_buf.append(',');
	_buf.append("onConnect=");
	_buf.appendUint(onConnect);
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("stats=");
	_buf.appendUint(stats);
	_buf.append(',');
	_buf.append("actionAmountOld=");
	_buf.appendUint(actionAmountOld);
	_buf.append(',');
	_buf.append("timeoutOld=");
	_buf.appendUint(timeoutOld);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendUint(action);
	_buf.append(',');
	_buf.append("actionAmount=");
	_buf.appendUint(actionAmount);
	_buf.append(',');
	_buf.append("timeout=");
	_buf.appendUint(timeout);
	return _buf.c_str();
}

void TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(serverAddr);
	_msg.composeString(serverObj);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeUINT32(chips);
	_msg.composeBOOL(sittingIn);
	_msg.composeBYTE(seat);
	_msg.composeBOOL(onConnect);
	_msg.composeUINT64(handId);
	_msg.composeUINT32(stats);
	_msg.composeUINT16(actionAmountOld);
	_msg.composeUINT32(timeoutOld);
	_msg.composeBYTE(action);
	_msg.composeUINT16(actionAmount);
	_msg.composeUINT32(timeout);
}

void TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(serverAddr);
	_parser.parseStringP(serverObj);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseUINT32(chips);
	_parser.parseBOOL(sittingIn);
	_parser.parseBYTE(seat);
	_parser.parseBOOL(onConnect);
	_parser.parseUINT64(handId);
	_parser.parseUINT32(stats);
	_parser.parseUINT16(actionAmountOld);
	_parser.parseUINT32(timeoutOld);
	_parser.parseBYTE(action);
	_parser.parseUINT16(actionAmount);
	_parser.parseUINT32(timeout);
}

/*static*/ void TournClientThin::player::Protocol_MTL_CLI_GOTO_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MTL_CLI_GOTO_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "serverAddr"); size_t szServerAddr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverAddr", szServerAddr, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "serverObj"); size_t szServerObj = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObj", szServerObj, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	bool sittingIn; _parser.parseBOOL(sittingIn);
	AtfValidator::validateInt(_descr, "sittingIn", sittingIn, _checker, __FILE__, __LINE__);
	BYTE seat; _parser.parseBYTE(seat);
	AtfValidator::validateInt(_descr, "seat", seat, _checker, __FILE__, __LINE__);
	bool onConnect; _parser.parseBOOL(onConnect);
	AtfValidator::validateInt(_descr, "onConnect", onConnect, _checker, __FILE__, __LINE__);
	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	UINT32 stats; _parser.parseUINT32(stats);
	AtfValidator::validateInt(_descr, "stats", stats, _checker, __FILE__, __LINE__);
	UINT16 actionAmountOld; _parser.parseUINT16(actionAmountOld);
	AtfValidator::validateInt(_descr, "actionAmountOld", actionAmountOld, _checker, __FILE__, __LINE__);
	UINT32 timeoutOld; _parser.parseUINT32(timeoutOld);
	AtfValidator::validateInt(_descr, "timeoutOld", timeoutOld, _checker, __FILE__, __LINE__);
	BYTE action; _parser.parseBYTE(action);
	AtfValidator::validateInt(_descr, "action", action, _checker, __FILE__, __LINE__);
	UINT16 actionAmount; _parser.parseUINT16(actionAmount);
	AtfValidator::validateInt(_descr, "actionAmount", actionAmount, _checker, __FILE__, __LINE__);
	UINT32 timeout; _parser.parseUINT32(timeout);
	AtfValidator::validateInt(_descr, "timeout", timeout, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool TournClientThin::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "player"))
	{
		switch(_msgId)
		{
			case MSG_LOBBY_TOURN_REG_INFO: player::Protocol_MSG_LOBBY_TOURN_REG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TOURN_REG_INFO_REPLY: player::Protocol_MSG_LOBBY_TOURN_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_CLI_GOTO_FINISH: player::Protocol_MTL_CLI_GOTO_FINISH::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_CLI_GOTO_TABLE: player::Protocol_MTL_CLI_GOTO_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER: player::Protocol_MTL_LOBBY_REGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_REGISTER_USER_REPLY: player::Protocol_MTL_LOBBY_REGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER: player::Protocol_MTL_LOBBY_UNREGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MTL_LOBBY_UNREGISTER_USER_REPLY: player::Protocol_MTL_LOBBY_UNREGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

