/**
 * ..\CRMServer\upserverdbmprot.cpp
 *
 * This file was auto-generated from ..\CRMServer\upserverdbmprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor ..\CRMServer\upserverdbmprot.txt
 */
 
#include "upserverdbmprot.h"

//=================================================================
//                    DBData
//=================================================================

UPServerDBM::DBData::DBData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::DBData::DBData(DBData&& _o)
	: property(std::move(_o.property))
	, userIntIds(std::move(_o.userIntIds))
{
}

UPServerDBM::DBData& UPServerDBM::DBData::operator=(DBData&& _o)
{
	if(this != &_o)
	{
		property = std::move(_o.property);
		userIntIds = std::move(_o.userIntIds);
	}
	return *this;
}

#endif

void UPServerDBM::DBData::clear()
{
	property.clear();
	userIntIds.clear();
}

bool UPServerDBM::DBData::equals(const DBData& _o) const
{
	return property.equals(_o.property) &&
		userIntIds.equals(_o.userIntIds);
}

const char *UPServerDBM::DBData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("property=");
	property.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServerDBM::DBData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	property.toXmlString("property", _buf);
	userIntIds.toXmlString("userIntIds", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServerDBM::DBData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("property"))
		{
			if(!Atf::AtfTempl< UPServerCommon::Property >::FromXmlString(_value, property)) return false;
		}
		else if (_element.equals("userIntIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, userIntIds)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServerDBM::DBData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(DBData())) // not empty
	{
		property.composeMsg(_body, _ignoreJSON);
		userIntIds.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void UPServerDBM::DBData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	property.parseMsg(_parser0);
	userIntIds.parseMsg(_parser0);
}

const char *UPServerDBM::DBData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("property", property);
	_jsonstr.compose("userIntIds", userIntIds);
	return _buf.c_str();
}

void UPServerDBM::DBData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("property", property);
	_jparser.parseByNameThrow("userIntIds", userIntIds);
}

/* static */ void UPServerDBM::DBData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UPServerCommon::Property property; _jparser.validateByNameThrow("property", property);
	Atf::AtfVectorBase< UINT32 > userIntIds; _jparser.validateByNameThrow("userIntIds", userIntIds);
	AtfValidator::validateInt(_descr, "userIntIds", userIntIds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServerDBM::DBData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	UPServerCommon::Property::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("property"), _fieldsWithUnparsedContent);
	int szUserIntIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    IsUpdateAndPrevValidUntil
//=================================================================

UPServerDBM::IsUpdateAndPrevValidUntil::IsUpdateAndPrevValidUntil()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::IsUpdateAndPrevValidUntil::IsUpdateAndPrevValidUntil(IsUpdateAndPrevValidUntil&& _o)
	: isUpdate(std::move(_o.isUpdate))
	, validUntilPrev(std::move(_o.validUntilPrev))
{
}

UPServerDBM::IsUpdateAndPrevValidUntil& UPServerDBM::IsUpdateAndPrevValidUntil::operator=(IsUpdateAndPrevValidUntil&& _o)
{
	if(this != &_o)
	{
		isUpdate = std::move(_o.isUpdate);
		validUntilPrev = std::move(_o.validUntilPrev);
	}
	return *this;
}

#endif

void UPServerDBM::IsUpdateAndPrevValidUntil::clear()
{
	isUpdate = false;
	validUntilPrev.setNull();
}

bool UPServerDBM::IsUpdateAndPrevValidUntil::equals(const IsUpdateAndPrevValidUntil& _o) const
{
	return isUpdate == _o.isUpdate &&
		validUntilPrev.equals(_o.validUntilPrev);
}

const char *UPServerDBM::IsUpdateAndPrevValidUntil::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isUpdate=");
	_buf.appendUint(isUpdate);
	_buf.append(',');
	_buf.append("validUntilPrev=");
	Atf::AtfTempl<CommUtcTime>::ToTraceString(_buf, validUntilPrev);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServerDBM::IsUpdateAndPrevValidUntil::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("isUpdate", isUpdate, _buf);
	Atf::AtfTempl<CommUtcTime>::ToXmlString(_buf, "validUntilPrev", validUntilPrev);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServerDBM::IsUpdateAndPrevValidUntil::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isUpdate"))
		{
			isUpdate = (*_value.ptr() == '1');
		}
		else if (_element.equals("validUntilPrev"))
		{
			Atf::AtfTempl<CommUtcTime>::FromXmlString(_value, validUntilPrev);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServerDBM::IsUpdateAndPrevValidUntil::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(IsUpdateAndPrevValidUntil())) // not empty
	{
		_body.composeBOOL(isUpdate);
		validUntilPrev.compose(_body);
	}

	_msg.composeMsgBody(_body);
}

void UPServerDBM::IsUpdateAndPrevValidUntil::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isUpdate);
	validUntilPrev.parse(_parser0);
}

const char *UPServerDBM::IsUpdateAndPrevValidUntil::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("isUpdate", isUpdate);
	_jsonstr.compose("validUntilPrev", validUntilPrev);
	return _buf.c_str();
}

void UPServerDBM::IsUpdateAndPrevValidUntil::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isUpdate", isUpdate);
	_jparser.parseByNameThrow("validUntilPrev", validUntilPrev);
}

/* static */ void UPServerDBM::IsUpdateAndPrevValidUntil::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isUpdate; _jparser.validateByNameThrow("isUpdate", isUpdate);
	AtfValidator::validateInt(_descr, "isUpdate", isUpdate, _checker, __FILE__, __LINE__);
	CommUtcTime validUntilPrev; _jparser.validateByNameThrow("validUntilPrev", validUntilPrev);
}

/*static*/ void UPServerDBM::IsUpdateAndPrevValidUntil::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool isUpdate; _parser0.parseBOOL(isUpdate);
	AtfValidator::validateInt(_descr, "isUpdate", isUpdate, _checker, __FILE__, __LINE__);
	_parser0.skip(8);  /*validUntilPrev*/
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    DBDataIsUpdate
//=================================================================

UPServerDBM::DBDataIsUpdate::DBDataIsUpdate()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::DBDataIsUpdate::DBDataIsUpdate(DBDataIsUpdate&& _o)
	: property(std::move(_o.property))
	, userIntIds(std::move(_o.userIntIds))
	, isUpdateForUserAndValidUntil(std::move(_o.isUpdateForUserAndValidUntil))
	, when(std::move(_o.when))
{
}

UPServerDBM::DBDataIsUpdate& UPServerDBM::DBDataIsUpdate::operator=(DBDataIsUpdate&& _o)
{
	if(this != &_o)
	{
		property = std::move(_o.property);
		userIntIds = std::move(_o.userIntIds);
		isUpdateForUserAndValidUntil = std::move(_o.isUpdateForUserAndValidUntil);
		when = std::move(_o.when);
	}
	return *this;
}

#endif

void UPServerDBM::DBDataIsUpdate::clear()
{
	property.clear();
	userIntIds.clear();
	isUpdateForUserAndValidUntil.clear();
	when.setNull();
}

bool UPServerDBM::DBDataIsUpdate::equals(const DBDataIsUpdate& _o) const
{
	return property.equals(_o.property) &&
		userIntIds.equals(_o.userIntIds) &&
		isUpdateForUserAndValidUntil.equals(_o.isUpdateForUserAndValidUntil) &&
		when.equals(_o.when);
}

const char *UPServerDBM::DBDataIsUpdate::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("property=");
	property.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isUpdateForUserAndValidUntil=");
	isUpdateForUserAndValidUntil.toTraceString(_buf);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServerDBM::DBDataIsUpdate::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	property.toXmlString("property", _buf);
	userIntIds.toXmlString("userIntIds", _buf);
	isUpdateForUserAndValidUntil.toXmlString("isUpdateForUserAndValidUntil", _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServerDBM::DBDataIsUpdate::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("property"))
		{
			if(!Atf::AtfTempl< UPServerCommon::Property >::FromXmlString(_value, property)) return false;
		}
		else if (_element.equals("userIntIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, userIntIds)) return false;
		}
		else if (_element.equals("isUpdateForUserAndValidUntil"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< IsUpdateAndPrevValidUntil, 4 > >::FromXmlString(_value, isUpdateForUserAndValidUntil)) return false;
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, when);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServerDBM::DBDataIsUpdate::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(DBDataIsUpdate())) // not empty
	{
		property.composeMsg(_body, _ignoreJSON);
		userIntIds.composeMsg(_body, _ignoreJSON);
		isUpdateForUserAndValidUntil.composeMsg(_body, _ignoreJSON);
		_body.composeSrvTime(when);
	}

	_msg.composeMsgBody(_body);
}

void UPServerDBM::DBDataIsUpdate::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	property.parseMsg(_parser0);
	userIntIds.parseMsg(_parser0);
	isUpdateForUserAndValidUntil.parseMsg(_parser0);
	_parser0.parseSrvTime(when);
}

const char *UPServerDBM::DBDataIsUpdate::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("property", property);
	_jsonstr.compose("userIntIds", userIntIds);
	_jsonstr.compose("isUpdateForUserAndValidUntil", isUpdateForUserAndValidUntil);
	_jsonstr.compose("when", when);
	return _buf.c_str();
}

void UPServerDBM::DBDataIsUpdate::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("property", property);
	_jparser.parseByNameThrow("userIntIds", userIntIds);
	_jparser.parseByNameThrow("isUpdateForUserAndValidUntil", isUpdateForUserAndValidUntil);
	_jparser.parseByNameThrow("when", when);
}

/* static */ void UPServerDBM::DBDataIsUpdate::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UPServerCommon::Property property; _jparser.validateByNameThrow("property", property);
	Atf::AtfVectorBase< UINT32 > userIntIds; _jparser.validateByNameThrow("userIntIds", userIntIds);
	AtfValidator::validateInt(_descr, "userIntIds", userIntIds.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< IsUpdateAndPrevValidUntil > isUpdateForUserAndValidUntil; _jparser.validateByNameThrow("isUpdateForUserAndValidUntil", isUpdateForUserAndValidUntil);
	AtfValidator::validateInt(_descr, "isUpdateForUserAndValidUntil", isUpdateForUserAndValidUntil.size(), _checker, __FILE__, __LINE__);
	CommSrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServerDBM::DBDataIsUpdate::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	UPServerCommon::Property::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("property"), _fieldsWithUnparsedContent);
	int szUserIntIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	int szIsUpdateForUserAndValidUntil = Atf::LAtfVector< IsUpdateAndPrevValidUntil, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("isUpdateForUserAndValidUntil"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "isUpdateForUserAndValidUntil", szIsUpdateForUserAndValidUntil, _checker, __FILE__, __LINE__);
	CommSrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY
//=================================================================

UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY(Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY&& _o)
	: dataRow(std::move(_o.dataRow))
{
}

UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY& UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::operator=(Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY&& _o)
{
	if(this != &_o)
	{
		dataRow = std::move(_o.dataRow);
	}
	return *this;
}

#endif

void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::clear()
{
	dataRow.clear();
}

bool UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::equals(const Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY& _o) const
{
	return dataRow.equals(_o.dataRow);
}

bool UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::equals(Atf::MessageProtocol* _other) const
{
	if (CRMDBM_Q_UPS_SAVE_PROPERTY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY*)_other));
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRMDBM_Q_UPS_SAVE_PROPERTY).append(")");
	_buf.append(',');
	_buf.append("dataRow=");
	dataRow.toTraceString(_buf);
	return _buf.c_str();
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CRMDBM_Q_UPS_SAVE_PROPERTY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	dataRow.toXmlString("dataRow", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("dataRow"))
			{
				if(!Atf::AtfTempl< DBDataIsUpdate >::FromXmlString(_value, dataRow)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	dataRow.composeMsg(_msg, _ignoreJSON);
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::parseMsg(CommMsgParser& _parser)
{
	dataRow.parseMsg(_parser);
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dataRow", dataRow);
	return _buf.c_str();
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dataRow", dataRow);
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_Q_UPS_SAVE_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	DBDataIsUpdate dataRow; _jparser.validateByNameThrow("dataRow", dataRow);
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_Q_UPS_SAVE_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	DBDataIsUpdate::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dataRow"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CRMDBM_A_UPS_SAVE_PROPERTY
//=================================================================

UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY(Protocol_CRMDBM_A_UPS_SAVE_PROPERTY&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY& UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::operator=(Protocol_CRMDBM_A_UPS_SAVE_PROPERTY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::equals(const Protocol_CRMDBM_A_UPS_SAVE_PROPERTY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::equals(Atf::MessageProtocol* _other) const
{
	if (CRMDBM_A_UPS_SAVE_PROPERTY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CRMDBM_A_UPS_SAVE_PROPERTY*)_other));
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRMDBM_A_UPS_SAVE_PROPERTY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CRMDBM_A_UPS_SAVE_PROPERTY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_A_UPS_SAVE_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_A_UPS_SAVE_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CRMDBM_Q_UPS_GET_DATA
//=================================================================

UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::Protocol_CRMDBM_Q_UPS_GET_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::Protocol_CRMDBM_Q_UPS_GET_DATA(Protocol_CRMDBM_Q_UPS_GET_DATA&& _o)
{
}

UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA& UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::operator=(Protocol_CRMDBM_Q_UPS_GET_DATA&& _o)
{
	if(this != &_o)
	{
	}
	return *this;
}

#endif

void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::clear()
{
}

bool UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::equals(const Protocol_CRMDBM_Q_UPS_GET_DATA& _o) const
{
	return true;
}

bool UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (CRMDBM_Q_UPS_GET_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CRMDBM_Q_UPS_GET_DATA*)_other));
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRMDBM_Q_UPS_GET_DATA).append(")");
	return _buf.c_str();
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CRMDBM_Q_UPS_GET_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::parseMsg(CommMsgParser& _parser)
{
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_Q_UPS_GET_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_Q_UPS_GET_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CRMDBM_A_UPS_GET_DATA
//=================================================================

UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::Protocol_CRMDBM_A_UPS_GET_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::Protocol_CRMDBM_A_UPS_GET_DATA(Protocol_CRMDBM_A_UPS_GET_DATA&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, userPropertiesWithExpiry(std::move(_o.userPropertiesWithExpiry))
{
}

UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA& UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::operator=(Protocol_CRMDBM_A_UPS_GET_DATA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		userPropertiesWithExpiry = std::move(_o.userPropertiesWithExpiry);
	}
	return *this;
}

#endif

void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::clear()
{
	errCode = 0;
	errStr.clear();
	userPropertiesWithExpiry.clear();
}

bool UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::equals(const Protocol_CRMDBM_A_UPS_GET_DATA& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		userPropertiesWithExpiry.equals(_o.userPropertiesWithExpiry);
}

bool UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (CRMDBM_A_UPS_GET_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_CRMDBM_A_UPS_GET_DATA*)_other));
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRMDBM_A_UPS_GET_DATA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userPropertiesWithExpiry=");
		userPropertiesWithExpiry.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(CRMDBM_A_UPS_GET_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		userPropertiesWithExpiry.toXmlString("userPropertiesWithExpiry", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("userPropertiesWithExpiry"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DBData , 4 > >::FromXmlString(_value, userPropertiesWithExpiry)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		userPropertiesWithExpiry.composeMsg(_msg, _ignoreJSON);
	}
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		userPropertiesWithExpiry.parseMsg(_parser);
	}
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("userPropertiesWithExpiry", userPropertiesWithExpiry);
	}
	return _buf.c_str();
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("userPropertiesWithExpiry", userPropertiesWithExpiry);
	}
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_A_UPS_GET_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< DBData > userPropertiesWithExpiry; _jparser.validateByNameThrow("userPropertiesWithExpiry", userPropertiesWithExpiry);
		AtfValidator::validateInt(_descr, "userPropertiesWithExpiry", userPropertiesWithExpiry.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_A_UPS_GET_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUserPropertiesWithExpiry = Atf::LAtfVector< DBData , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userPropertiesWithExpiry"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userPropertiesWithExpiry", szUserPropertiesWithExpiry, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* UPServerDBM::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case CRMDBM_A_UPS_GET_DATA: _obj = new Protocol_CRMDBM_A_UPS_GET_DATA(); break;
			case CRMDBM_A_UPS_SAVE_PROPERTY: _obj = new Protocol_CRMDBM_A_UPS_SAVE_PROPERTY(); break;
			case CRMDBM_Q_UPS_GET_DATA: _obj = new Protocol_CRMDBM_Q_UPS_GET_DATA(); break;
			case CRMDBM_Q_UPS_SAVE_PROPERTY: _obj = new Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool UPServerDBM::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case CRMDBM_A_UPS_GET_DATA: Protocol_CRMDBM_A_UPS_GET_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CRMDBM_A_UPS_SAVE_PROPERTY: Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CRMDBM_Q_UPS_GET_DATA: Protocol_CRMDBM_Q_UPS_GET_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case CRMDBM_Q_UPS_SAVE_PROPERTY: Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool UPServerDBM::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case CRMDBM_A_UPS_GET_DATA: Protocol_CRMDBM_A_UPS_GET_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CRMDBM_A_UPS_SAVE_PROPERTY: Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CRMDBM_Q_UPS_GET_DATA: Protocol_CRMDBM_Q_UPS_GET_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CRMDBM_Q_UPS_SAVE_PROPERTY: Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

