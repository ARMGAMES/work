/**
 * ..\CRMServer\upserverdbmprot_thin.cpp
 *
 * This file was auto-generated from ..\CRMServer\upserverdbmprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin ..\CRMServer\upserverdbmprot.txt
 */
 
#include "upserverdbmprot_thin.h"

//=================================================================
//                    DBData
//=================================================================

UPServerDBM::DBData::DBData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::DBData::DBData(DBData&& _o)
	: property(std::move(_o.property))
	, userIntIds(std::move(_o.userIntIds))
{
}

UPServerDBM::DBData& UPServerDBM::DBData::operator=(DBData&& _o)
{
	if(this != &_o)
	{
		property = std::move(_o.property);
		userIntIds = std::move(_o.userIntIds);
	}
	return *this;
}

#endif

void UPServerDBM::DBData::clear()
{
	property.clear();
	userIntIds.clear();
}

bool UPServerDBM::DBData::equals(const DBData& _o) const
{
	return property.equals(_o.property) &&
		userIntIds.equals(_o.userIntIds);
}

const char *UPServerDBM::DBData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("property=");
	property.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void UPServerDBM::DBData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(DBData())) // not empty
	{
		property.composeMsg(_body);
		userIntIds.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void UPServerDBM::DBData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	property.parseMsg(_parser0);
	userIntIds.parseMsg(_parser0);
}

/*static*/ void UPServerDBM::DBData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	UPServerCommon::Property::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("property"), _fieldsWithUnparsedContent);
	int szUserIntIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    IsUpdateAndPrevValidUntil
//=================================================================

UPServerDBM::IsUpdateAndPrevValidUntil::IsUpdateAndPrevValidUntil()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::IsUpdateAndPrevValidUntil::IsUpdateAndPrevValidUntil(IsUpdateAndPrevValidUntil&& _o)
	: isUpdate(std::move(_o.isUpdate))
	, validUntilPrev(std::move(_o.validUntilPrev))
{
}

UPServerDBM::IsUpdateAndPrevValidUntil& UPServerDBM::IsUpdateAndPrevValidUntil::operator=(IsUpdateAndPrevValidUntil&& _o)
{
	if(this != &_o)
	{
		isUpdate = std::move(_o.isUpdate);
		validUntilPrev = std::move(_o.validUntilPrev);
	}
	return *this;
}

#endif

void UPServerDBM::IsUpdateAndPrevValidUntil::clear()
{
	isUpdate = false;
	validUntilPrev.setNull();
}

bool UPServerDBM::IsUpdateAndPrevValidUntil::equals(const IsUpdateAndPrevValidUntil& _o) const
{
	return isUpdate == _o.isUpdate &&
		validUntilPrev.equals(_o.validUntilPrev);
}

const char *UPServerDBM::IsUpdateAndPrevValidUntil::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isUpdate=");
	_buf.appendUint(isUpdate);
	_buf.append(',');
	_buf.append("validUntilPrev=");
	ThinAtf::AtfTempl<CommUtcTime>::ToTraceString(_buf, validUntilPrev);
	_buf.append('}');
	return _buf.c_str();
}

void UPServerDBM::IsUpdateAndPrevValidUntil::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(IsUpdateAndPrevValidUntil())) // not empty
	{
		_body.composeBOOL(isUpdate);
		validUntilPrev.compose(_body);
	}

	_msg.composeMsgBody(_body);
}

void UPServerDBM::IsUpdateAndPrevValidUntil::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(isUpdate);
	validUntilPrev.parse(_parser0);
}

/*static*/ void UPServerDBM::IsUpdateAndPrevValidUntil::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool isUpdate; _parser0.parseBOOL(isUpdate);
	AtfValidator::validateInt(_descr, "isUpdate", isUpdate, _checker, __FILE__, __LINE__);
	_parser0.skip(8);  /*validUntilPrev*/
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    DBDataIsUpdate
//=================================================================

UPServerDBM::DBDataIsUpdate::DBDataIsUpdate()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::DBDataIsUpdate::DBDataIsUpdate(DBDataIsUpdate&& _o)
	: property(std::move(_o.property))
	, userIntIds(std::move(_o.userIntIds))
	, isUpdateForUserAndValidUntil(std::move(_o.isUpdateForUserAndValidUntil))
	, when(std::move(_o.when))
{
}

UPServerDBM::DBDataIsUpdate& UPServerDBM::DBDataIsUpdate::operator=(DBDataIsUpdate&& _o)
{
	if(this != &_o)
	{
		property = std::move(_o.property);
		userIntIds = std::move(_o.userIntIds);
		isUpdateForUserAndValidUntil = std::move(_o.isUpdateForUserAndValidUntil);
		when = std::move(_o.when);
	}
	return *this;
}

#endif

void UPServerDBM::DBDataIsUpdate::clear()
{
	property.clear();
	userIntIds.clear();
	isUpdateForUserAndValidUntil.clear();
	when.setNull();
}

bool UPServerDBM::DBDataIsUpdate::equals(const DBDataIsUpdate& _o) const
{
	return property.equals(_o.property) &&
		userIntIds.equals(_o.userIntIds) &&
		isUpdateForUserAndValidUntil.equals(_o.isUpdateForUserAndValidUntil) &&
		when.equals(_o.when);
}

const char *UPServerDBM::DBDataIsUpdate::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("property=");
	property.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("isUpdateForUserAndValidUntil=");
	isUpdateForUserAndValidUntil.toTraceString(_buf);
	_buf.append(',');
	_buf.append("when=");
	ThinAtf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	_buf.append('}');
	return _buf.c_str();
}

void UPServerDBM::DBDataIsUpdate::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(DBDataIsUpdate())) // not empty
	{
		property.composeMsg(_body);
		userIntIds.composeMsg(_body);
		isUpdateForUserAndValidUntil.composeMsg(_body);
		_body.composeSrvTime(when);
	}

	_msg.composeMsgBody(_body);
}

void UPServerDBM::DBDataIsUpdate::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	property.parseMsg(_parser0);
	userIntIds.parseMsg(_parser0);
	isUpdateForUserAndValidUntil.parseMsg(_parser0);
	_parser0.parseSrvTime(when);
}

/*static*/ void UPServerDBM::DBDataIsUpdate::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	UPServerCommon::Property::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("property"), _fieldsWithUnparsedContent);
	int szUserIntIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	int szIsUpdateForUserAndValidUntil = ThinAtf::LAtfVector< IsUpdateAndPrevValidUntil, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("isUpdateForUserAndValidUntil"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "isUpdateForUserAndValidUntil", szIsUpdateForUserAndValidUntil, _checker, __FILE__, __LINE__);
	CommSrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY
//=================================================================

UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY(Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY&& _o)
	: dataRow(std::move(_o.dataRow))
{
}

UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY& UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::operator=(Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY&& _o)
{
	if(this != &_o)
	{
		dataRow = std::move(_o.dataRow);
	}
	return *this;
}

#endif

void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::clear()
{
	dataRow.clear();
}

bool UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::equals(const Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY& _o) const
{
	return dataRow.equals(_o.dataRow);
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRMDBM_Q_UPS_SAVE_PROPERTY).append(")");
	_buf.append(',');
	_buf.append("dataRow=");
	dataRow.toTraceString(_buf);
	return _buf.c_str();
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::composeMsg(CommMsgBody& _msg) const
{
	dataRow.composeMsg(_msg);
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::parseMsg(CommMsgParser& _parser)
{
	dataRow.parseMsg(_parser);
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_Q_UPS_SAVE_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	DBDataIsUpdate::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("dataRow"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CRMDBM_A_UPS_SAVE_PROPERTY
//=================================================================

UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY(Protocol_CRMDBM_A_UPS_SAVE_PROPERTY&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY& UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::operator=(Protocol_CRMDBM_A_UPS_SAVE_PROPERTY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::equals(const Protocol_CRMDBM_A_UPS_SAVE_PROPERTY& _o) const
{
	return errCode == _o.errCode &&
		errStr.equals(_o.errStr);
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRMDBM_A_UPS_SAVE_PROPERTY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_A_UPS_SAVE_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CRMDBM_Q_UPS_GET_DATA
//=================================================================

UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::Protocol_CRMDBM_Q_UPS_GET_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::Protocol_CRMDBM_Q_UPS_GET_DATA(Protocol_CRMDBM_Q_UPS_GET_DATA&& _o)
{
}

UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA& UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::operator=(Protocol_CRMDBM_Q_UPS_GET_DATA&& _o)
{
	if(this != &_o)
	{
	}
	return *this;
}

#endif

void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::clear()
{
}

bool UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::equals(const Protocol_CRMDBM_Q_UPS_GET_DATA& _o) const
{
	return true;
}

const char *UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRMDBM_Q_UPS_GET_DATA).append(")");
	return _buf.c_str();
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::composeMsg(CommMsgBody& _msg) const
{
}

void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_Q_UPS_GET_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_Q_UPS_GET_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_CRMDBM_A_UPS_GET_DATA
//=================================================================

UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::Protocol_CRMDBM_A_UPS_GET_DATA()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::Protocol_CRMDBM_A_UPS_GET_DATA(Protocol_CRMDBM_A_UPS_GET_DATA&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, userPropertiesWithExpiry(std::move(_o.userPropertiesWithExpiry))
{
}

UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA& UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::operator=(Protocol_CRMDBM_A_UPS_GET_DATA&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		userPropertiesWithExpiry = std::move(_o.userPropertiesWithExpiry);
	}
	return *this;
}

#endif

void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::clear()
{
	errCode = 0;
	errStr.clear();
	userPropertiesWithExpiry.clear();
}

bool UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::equals(const Protocol_CRMDBM_A_UPS_GET_DATA& _o) const
{
	return errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		userPropertiesWithExpiry.equals(_o.userPropertiesWithExpiry);
}

const char *UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(CRMDBM_A_UPS_GET_DATA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userPropertiesWithExpiry=");
		userPropertiesWithExpiry.toTraceString(_buf);
	}
	return _buf.c_str();
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		userPropertiesWithExpiry.composeMsg(_msg);
	}
}

void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		userPropertiesWithExpiry.parseMsg(_parser);
	}
}

/*static*/ void UPServerDBM::Protocol_CRMDBM_A_UPS_GET_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "CRMDBM_A_UPS_GET_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUserPropertiesWithExpiry = ThinAtf::LAtfVector< DBData , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userPropertiesWithExpiry"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userPropertiesWithExpiry", szUserPropertiesWithExpiry, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool UPServerDBM::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case CRMDBM_A_UPS_GET_DATA: Protocol_CRMDBM_A_UPS_GET_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CRMDBM_A_UPS_SAVE_PROPERTY: Protocol_CRMDBM_A_UPS_SAVE_PROPERTY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CRMDBM_Q_UPS_GET_DATA: Protocol_CRMDBM_Q_UPS_GET_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case CRMDBM_Q_UPS_SAVE_PROPERTY: Protocol_CRMDBM_Q_UPS_SAVE_PROPERTY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

