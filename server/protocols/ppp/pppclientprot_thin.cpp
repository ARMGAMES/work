/**
 * pppclientprot_thin.cpp
 *
 * This file was auto-generated from pppclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin pppclientprot.txt
 */
 
#include "pppclientprot_thin.h"

//=================================================================
//                    PppBuyInTierInfo
//=================================================================

PPPClient::publication::PppBuyInTierInfo::PppBuyInTierInfo()
{
	clear();
}

void PPPClient::publication::PppBuyInTierInfo::clear()
{
	buyInTierId = 0;
	buyIn = 0;
	rake = 0;
}

bool PPPClient::publication::PppBuyInTierInfo::equals(const PppBuyInTierInfo& _o) const
{
	return buyInTierId == _o.buyInTierId &&
		buyIn == _o.buyIn &&
		rake == _o.rake;
}

const char *PPPClient::publication::PppBuyInTierInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("buyInTierId=");
	_buf.appendUint(buyInTierId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt64(rake);
	_buf.append('}');
	return _buf.c_str();
}

void PPPClient::publication::PppBuyInTierInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PppBuyInTierInfo())) // not empty
	{
		_body.composeUINT32(buyInTierId);
		_body.composeINT64(buyIn);
		_body.composeINT64(rake);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppBuyInTierInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(buyInTierId);
	_parser0.parseINT64(buyIn);
	_parser0.parseINT64(rake);
}

/*static*/ void PPPClient::publication::PppBuyInTierInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 buyInTierId; _parser0.parseUINT32(buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	INT64 buyIn; _parser0.parseINT64(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT64 rake; _parser0.parseINT64(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppVisibility
//=================================================================

PPPClient::publication::PppVisibility::PppVisibility()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppVisibility::PppVisibility(PppVisibility&& _o)
	: brandMask(std::move(_o.brandMask))
	, siteMask(std::move(_o.siteMask))
	, excludeCountries(std::move(_o.excludeCountries))
	, countries(std::move(_o.countries))
	, criteria(std::move(_o.criteria))
{
}

PPPClient::publication::PppVisibility& PPPClient::publication::PppVisibility::operator=(PppVisibility&& _o)
{
	if(this != &_o)
	{
		brandMask = std::move(_o.brandMask);
		siteMask = std::move(_o.siteMask);
		excludeCountries = std::move(_o.excludeCountries);
		countries = std::move(_o.countries);
		criteria = std::move(_o.criteria);
	}
	return *this;
}

#endif

void PPPClient::publication::PppVisibility::clear()
{
	brandMask = 0;
	siteMask.clear();
	excludeCountries = false;
	countries.clear();
	criteria.clear();
}

bool PPPClient::publication::PppVisibility::equals(const PppVisibility& _o) const
{
	return brandMask == _o.brandMask &&
		siteMask.equals(_o.siteMask) &&
		excludeCountries == _o.excludeCountries &&
		countries.equals(_o.countries) &&
		criteria.equals(_o.criteria);
}

const char *PPPClient::publication::PppVisibility::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("siteMask=");
	siteMask.toTraceString(_buf);
	_buf.append(',');
	_buf.append("excludeCountries=");
	_buf.appendUint(excludeCountries);
	_buf.append(',');
	_buf.append("countries=");
	countries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append('}');
	return _buf.c_str();
}

void PPPClient::publication::PppVisibility::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PppVisibility())) // not empty
	{
		_body.composeUINT32(brandMask);
		siteMask.composeMsg(_body);
		CommMsgBody _body0;
		_body0.composeBOOL(excludeCountries);
		countries.composeMsg(_body0);
		_body.composeMsgBody(_body0);
		_body.composeString(criteria);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppVisibility::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(brandMask);
	siteMask.parseMsg(_parser0);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseStringP(criteria);
}

/*static*/ void PPPClient::publication::PppVisibility::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("siteMask"), _fieldsWithUnparsedContent);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void PPPClient::publication::PppVisibility::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(excludeCountries);
	countries.parseMsg(_parser0);
}

/*static*/ void PPPClient::publication::PppVisibility::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool excludeCountries; _parser0.parseBOOL(excludeCountries);
	AtfValidator::validateInt(_descr, "excludeCountries", excludeCountries, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCountries = ThinAtf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppStaticLeaf
//=================================================================

PPPClient::publication::PppStaticLeaf::PppStaticLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppStaticLeaf::PppStaticLeaf(PppStaticLeaf&& _o)
	: visible(std::move(_o.visible))
	, pppId(std::move(_o.pppId))
	, seqId(std::move(_o.seqId))
	, regOpen(std::move(_o.regOpen))
	, name(std::move(_o.name))
	, visibility(std::move(_o.visibility))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, buyInTiers(std::move(_o.buyInTiers))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, maxEntriesPerPlayer(std::move(_o.maxEntriesPerPlayer))
	, winnerCashoutThreshold(std::move(_o.winnerCashoutThreshold))
{
}

PPPClient::publication::PppStaticLeaf& PPPClient::publication::PppStaticLeaf::operator=(PppStaticLeaf&& _o)
{
	if(this != &_o)
	{
		visible = std::move(_o.visible);
		pppId = std::move(_o.pppId);
		seqId = std::move(_o.seqId);
		regOpen = std::move(_o.regOpen);
		name = std::move(_o.name);
		visibility = std::move(_o.visibility);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		buyInTiers = std::move(_o.buyInTiers);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		maxEntriesPerPlayer = std::move(_o.maxEntriesPerPlayer);
		winnerCashoutThreshold = std::move(_o.winnerCashoutThreshold);
	}
	return *this;
}

#endif

void PPPClient::publication::PppStaticLeaf::clear()
{
	visible = false;
	pppId = 0;
	seqId = 0;
	regOpen = false;
	name.clear();
	visibility.clear();
	isPlayMoney = false;
	currency.clear();
	buyInTiers.clear();
	handType = 0;
	structure = 0;
	isHiLo = false;
	maxEntriesPerPlayer = 0;
	winnerCashoutThreshold = 0;
}

bool PPPClient::publication::PppStaticLeaf::equals(const PppStaticLeaf& _o) const
{
	return visible == _o.visible &&
		pppId == _o.pppId &&
		seqId == _o.seqId &&
		regOpen == _o.regOpen &&
		name.equals(_o.name) &&
		visibility.equals(_o.visibility) &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		buyInTiers.equals(_o.buyInTiers) &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxEntriesPerPlayer == _o.maxEntriesPerPlayer &&
		winnerCashoutThreshold == _o.winnerCashoutThreshold;
}

const char *PPPClient::publication::PppStaticLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("visible=");
	_buf.appendUint(visible);
	if( visible )
	{
		_buf.append(',');
		_buf.append("pppId=");
		_buf.appendUint(pppId);
		_buf.append(',');
		_buf.append("seqId=");
		_buf.appendUint(seqId);
		_buf.append(',');
		_buf.append("regOpen=");
		_buf.appendUint(regOpen);
		_buf.append(',');
		_buf.append("name=");
		ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
		_buf.append(',');
		_buf.append("visibility=");
		visibility.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInTiers=");
		buyInTiers.toTraceString(_buf);
		_buf.append(',');
		_buf.append("handType=");
		_buf.appendUint(handType);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("maxEntriesPerPlayer=");
		_buf.appendInt(maxEntriesPerPlayer);
		_buf.append(',');
		_buf.append("winnerCashoutThreshold=");
		_buf.appendInt64(winnerCashoutThreshold);
	}
	_buf.append('}');
	return _buf.c_str();
}

void PPPClient::publication::PppStaticLeaf::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(visible);
	if( visible )
	{
		_msg.composeUINT32(pppId);
		_msg.composeUINT32(seqId);
		_msg.composeBOOL(regOpen);
		name.compose(_msg);
		visibility.composeMsg(_msg);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeString(currency);
		buyInTiers.composeMsg(_msg);
		_msg.composeBYTE(handType);
		_msg.composeBYTE(structure);
		_msg.composeBOOL(isHiLo);
		_msg.composeINT32(maxEntriesPerPlayer);
		_msg.composeINT64(winnerCashoutThreshold);
	}
}

void PPPClient::publication::PppStaticLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(visible);
	if( visible )
	{
		_parser.parseUINT32(pppId);
		_parser.parseUINT32(seqId);
		_parser.parseBOOL(regOpen);
		name.parse(_parser);
		visibility.parseMsg(_parser);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseStringP(currency);
		buyInTiers.parseMsg(_parser);
		_parser.parseBYTE(handType);
		_parser.parseBYTE(structure);
		_parser.parseBOOL(isHiLo);
		_parser.parseINT32(maxEntriesPerPlayer);
		if(_parser.parseEnded()) return;
		_parser.parseINT64(winnerCashoutThreshold);
	}
}

/*static*/ void PPPClient::publication::PppStaticLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool visible = false;
	_parser.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	if( visible )
	{
		UINT32 pppId; _parser.parseUINT32(pppId);
		AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
		UINT32 seqId; _parser.parseUINT32(seqId);
		AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
		bool regOpen; _parser.parseBOOL(regOpen);
		AtfValidator::validateInt(_descr, "regOpen", regOpen, _checker, __FILE__, __LINE__);
		I18nPString name; name.parse(_parser);
		PString _descbuf;
		PppVisibility::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibility"), _fieldsWithUnparsedContent);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		int szBuyInTiers = ThinAtf::LAtfVector< PppBuyInTierInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buyInTiers"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "buyInTiers", szBuyInTiers, _checker, __FILE__, __LINE__);
		BYTE handType; _parser.parseBYTE(handType);
		AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		INT32 maxEntriesPerPlayer; _parser.parseINT32(maxEntriesPerPlayer);
		AtfValidator::validateInt(_descr, "maxEntriesPerPlayer", maxEntriesPerPlayer, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT64 winnerCashoutThreshold; _parser.parseINT64(winnerCashoutThreshold);
		AtfValidator::validateInt(_descr, "winnerCashoutThreshold", winnerCashoutThreshold, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    PppFeaturedTable
//=================================================================

PPPClient::publication::PppFeaturedTable::PppFeaturedTable()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppFeaturedTable::PppFeaturedTable(PppFeaturedTable&& _o)
	: tournId(std::move(_o.tournId))
	, mtLobbyAddress(std::move(_o.mtLobbyAddress))
	, mtLobbyObject(std::move(_o.mtLobbyObject))
	, tableAddress(std::move(_o.tableAddress))
	, tableObject(std::move(_o.tableObject))
{
}

PPPClient::publication::PppFeaturedTable& PPPClient::publication::PppFeaturedTable::operator=(PppFeaturedTable&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		mtLobbyAddress = std::move(_o.mtLobbyAddress);
		mtLobbyObject = std::move(_o.mtLobbyObject);
		tableAddress = std::move(_o.tableAddress);
		tableObject = std::move(_o.tableObject);
	}
	return *this;
}

#endif

void PPPClient::publication::PppFeaturedTable::clear()
{
	tournId = 0;
	mtLobbyAddress.clear();
	mtLobbyObject.clear();
	tableAddress.clear();
	tableObject.clear();
}

bool PPPClient::publication::PppFeaturedTable::equals(const PppFeaturedTable& _o) const
{
	return tournId == _o.tournId &&
		mtLobbyAddress.equals(_o.mtLobbyAddress) &&
		mtLobbyObject.equals(_o.mtLobbyObject) &&
		tableAddress.equals(_o.tableAddress) &&
		tableObject.equals(_o.tableObject);
}

const char *PPPClient::publication::PppFeaturedTable::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append(',');
	_buf.append("mtLobbyAddress=");
	_buf.append(mtLobbyAddress);
	_buf.append(',');
	_buf.append("mtLobbyObject=");
	_buf.append(mtLobbyObject);
	_buf.append(',');
	_buf.append("tableAddress=");
	_buf.append(tableAddress);
	_buf.append(',');
	_buf.append("tableObject=");
	_buf.append(tableObject);
	_buf.append('}');
	return _buf.c_str();
}

void PPPClient::publication::PppFeaturedTable::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PppFeaturedTable())) // not empty
	{
		_body.composeUINT64(tournId);
		_body.composeString(mtLobbyAddress);
		_body.composeString(mtLobbyObject);
		_body.composeString(tableAddress);
		_body.composeString(tableObject);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppFeaturedTable::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(tournId);
	_parser0.parseStringP(mtLobbyAddress);
	_parser0.parseStringP(mtLobbyObject);
	_parser0.parseStringP(tableAddress);
	_parser0.parseStringP(tableObject);
}

/*static*/ void PPPClient::publication::PppFeaturedTable::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 tournId; _parser0.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mtLobbyAddress"); size_t szMtLobbyAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mtLobbyAddress", szMtLobbyAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mtLobbyObject"); size_t szMtLobbyObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mtLobbyObject", szMtLobbyObject, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableAddress"); size_t szTableAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableAddress", szTableAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppFeaturedKO
//=================================================================

PPPClient::publication::PppFeaturedKO::PppFeaturedKO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppFeaturedKO::PppFeaturedKO(PppFeaturedKO&& _o)
	: userId(std::move(_o.userId))
	, winAmount(std::move(_o.winAmount))
	, knockedOutPlayerValue(std::move(_o.knockedOutPlayerValue))
{
}

PPPClient::publication::PppFeaturedKO& PPPClient::publication::PppFeaturedKO::operator=(PppFeaturedKO&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		winAmount = std::move(_o.winAmount);
		knockedOutPlayerValue = std::move(_o.knockedOutPlayerValue);
	}
	return *this;
}

#endif

void PPPClient::publication::PppFeaturedKO::clear()
{
	userId.clear();
	winAmount = 0;
	knockedOutPlayerValue = 0;
}

bool PPPClient::publication::PppFeaturedKO::equals(const PppFeaturedKO& _o) const
{
	return userId.equals(_o.userId) &&
		winAmount == _o.winAmount &&
		knockedOutPlayerValue == _o.knockedOutPlayerValue;
}

const char *PPPClient::publication::PppFeaturedKO::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("winAmount=");
	_buf.appendInt64(winAmount);
	_buf.append(',');
	_buf.append("knockedOutPlayerValue=");
	_buf.appendInt64(knockedOutPlayerValue);
	_buf.append('}');
	return _buf.c_str();
}

void PPPClient::publication::PppFeaturedKO::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PppFeaturedKO())) // not empty
	{
		_body.composeString(userId);
		_body.composeINT64(winAmount);
		_body.composeINT64(knockedOutPlayerValue);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppFeaturedKO::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseINT64(winAmount);
	_parser0.parseINT64(knockedOutPlayerValue);
}

/*static*/ void PPPClient::publication::PppFeaturedKO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	INT64 winAmount; _parser0.parseINT64(winAmount);
	AtfValidator::validateInt(_descr, "winAmount", winAmount, _checker, __FILE__, __LINE__);
	INT64 knockedOutPlayerValue; _parser0.parseINT64(knockedOutPlayerValue);
	AtfValidator::validateInt(_descr, "knockedOutPlayerValue", knockedOutPlayerValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppFeaturedFinisher
//=================================================================

PPPClient::publication::PppFeaturedFinisher::PppFeaturedFinisher()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppFeaturedFinisher::PppFeaturedFinisher(PppFeaturedFinisher&& _o)
	: userId(std::move(_o.userId))
	, cashoutAmount(std::move(_o.cashoutAmount))
	, totalKOAmount(std::move(_o.totalKOAmount))
{
}

PPPClient::publication::PppFeaturedFinisher& PPPClient::publication::PppFeaturedFinisher::operator=(PppFeaturedFinisher&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		cashoutAmount = std::move(_o.cashoutAmount);
		totalKOAmount = std::move(_o.totalKOAmount);
	}
	return *this;
}

#endif

void PPPClient::publication::PppFeaturedFinisher::clear()
{
	userId.clear();
	cashoutAmount = 0;
	totalKOAmount = 0;
}

bool PPPClient::publication::PppFeaturedFinisher::equals(const PppFeaturedFinisher& _o) const
{
	return userId.equals(_o.userId) &&
		cashoutAmount == _o.cashoutAmount &&
		totalKOAmount == _o.totalKOAmount;
}

const char *PPPClient::publication::PppFeaturedFinisher::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("cashoutAmount=");
	_buf.appendInt64(cashoutAmount);
	_buf.append(',');
	_buf.append("totalKOAmount=");
	_buf.appendInt64(totalKOAmount);
	_buf.append('}');
	return _buf.c_str();
}

void PPPClient::publication::PppFeaturedFinisher::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PppFeaturedFinisher())) // not empty
	{
		_body.composeString(userId);
		_body.composeINT64(cashoutAmount);
		_body.composeINT64(totalKOAmount);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppFeaturedFinisher::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseINT64(cashoutAmount);
	_parser0.parseINT64(totalKOAmount);
}

/*static*/ void PPPClient::publication::PppFeaturedFinisher::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	INT64 cashoutAmount; _parser0.parseINT64(cashoutAmount);
	AtfValidator::validateInt(_descr, "cashoutAmount", cashoutAmount, _checker, __FILE__, __LINE__);
	INT64 totalKOAmount; _parser0.parseINT64(totalKOAmount);
	AtfValidator::validateInt(_descr, "totalKOAmount", totalKOAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppDynamicLeaf
//=================================================================

PPPClient::publication::PppDynamicLeaf::PppDynamicLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppDynamicLeaf::PppDynamicLeaf(PppDynamicLeaf&& _o)
	: featuredTable(std::move(_o.featuredTable))
	, featuredKOs(std::move(_o.featuredKOs))
	, featuredFinishers(std::move(_o.featuredFinishers))
{
}

PPPClient::publication::PppDynamicLeaf& PPPClient::publication::PppDynamicLeaf::operator=(PppDynamicLeaf&& _o)
{
	if(this != &_o)
	{
		featuredTable = std::move(_o.featuredTable);
		featuredKOs = std::move(_o.featuredKOs);
		featuredFinishers = std::move(_o.featuredFinishers);
	}
	return *this;
}

#endif

void PPPClient::publication::PppDynamicLeaf::clear()
{
	featuredTable.clear();
	featuredKOs.clear();
	featuredFinishers.clear();
}

bool PPPClient::publication::PppDynamicLeaf::equals(const PppDynamicLeaf& _o) const
{
	return featuredTable.equals(_o.featuredTable) &&
		featuredKOs.equals(_o.featuredKOs) &&
		featuredFinishers.equals(_o.featuredFinishers);
}

const char *PPPClient::publication::PppDynamicLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("featuredTable=");
	featuredTable.toTraceString(_buf);
	_buf.append(',');
	_buf.append("featuredKOs=");
	featuredKOs.toTraceString(_buf);
	_buf.append(',');
	_buf.append("featuredFinishers=");
	featuredFinishers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void PPPClient::publication::PppDynamicLeaf::composeMsg(CommMsgBody& _msg) const
{
	featuredTable.composeMsg(_msg);
	featuredKOs.composeMsg(_msg);
	featuredFinishers.composeMsg(_msg);
}

void PPPClient::publication::PppDynamicLeaf::parseMsg(CommMsgParser& _parser)
{
	featuredTable.parseMsg(_parser);
	featuredKOs.parseMsg(_parser);
	featuredFinishers.parseMsg(_parser);
}

/*static*/ void PPPClient::publication::PppDynamicLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	PppFeaturedTable::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("featuredTable"), _fieldsWithUnparsedContent);
	int szFeaturedKOs = ThinAtf::LAtfVector< PppFeaturedKO , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("featuredKOs"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "featuredKOs", szFeaturedKOs, _checker, __FILE__, __LINE__);
	int szFeaturedFinishers = ThinAtf::LAtfVector< PppFeaturedFinisher , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("featuredFinishers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "featuredFinishers", szFeaturedFinishers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_PPP_REG_INFO
//=================================================================

PPPClient::client::Protocol_MSG_PPP_REG_INFO::Protocol_MSG_PPP_REG_INFO()
{
	clear();
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO::clear()
{
	pppId = 0;
	seqId = 0;
	buyInTierId = 0;
}

bool PPPClient::client::Protocol_MSG_PPP_REG_INFO::equals(const Protocol_MSG_PPP_REG_INFO& _o) const
{
	return pppId == _o.pppId &&
		seqId == _o.seqId &&
		buyInTierId == _o.buyInTierId;
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_REG_INFO).append(")");
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("seqId=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("buyInTierId=");
	_buf.appendUint(buyInTierId);
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(pppId);
	_msg.composeUINT32(seqId);
	_msg.composeUINT32(buyInTierId);
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(pppId);
	_parser.parseUINT32(seqId);
	_parser.parseUINT32(buyInTierId);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	UINT32 buyInTierId; _parser.parseUINT32(buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_REG_INFO_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::Protocol_MSG_PPP_REG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::Protocol_MSG_PPP_REG_INFO_REPLY(Protocol_MSG_PPP_REG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errInfo(std::move(_o.errInfo))
	, currency(std::move(_o.currency))
	, buyInPlusRake(std::move(_o.buyInPlusRake))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, admissionId(std::move(_o.admissionId))
	, admPrice(std::move(_o.admPrice))
	, numTickets(std::move(_o.numTickets))
	, name(std::move(_o.name))
	, userRmBalance(std::move(_o.userRmBalance))
	, userPmBalance(std::move(_o.userPmBalance))
	, userTChipsBalance(std::move(_o.userTChipsBalance))
	, currencyContext(std::move(_o.currencyContext))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, speed(std::move(_o.speed))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, preRegMsg(std::move(_o.preRegMsg))
{
}

PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY& PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::operator=(Protocol_MSG_PPP_REG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errInfo = std::move(_o.errInfo);
		currency = std::move(_o.currency);
		buyInPlusRake = std::move(_o.buyInPlusRake);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		isPlayMoney = std::move(_o.isPlayMoney);
		admissionId = std::move(_o.admissionId);
		admPrice = std::move(_o.admPrice);
		numTickets = std::move(_o.numTickets);
		name = std::move(_o.name);
		userRmBalance = std::move(_o.userRmBalance);
		userPmBalance = std::move(_o.userPmBalance);
		userTChipsBalance = std::move(_o.userTChipsBalance);
		currencyContext = std::move(_o.currencyContext);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		speed = std::move(_o.speed);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		preRegMsg = std::move(_o.preRegMsg);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errInfo.clear();
	currency.clear();
	buyInPlusRake = 0;
	enoughMoneyInOtherCurrency = false;
	buyIn = 0;
	rake = 0;
	isPlayMoney = false;
	admissionId.clear();
	admPrice = 0;
	numTickets = 0;
	name.clear();
	userRmBalance = 0;
	userPmBalance = 0;
	userTChipsBalance = 0;
	currencyContext.clear();
	clientCurrencyContext.clear();
	speed = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	tournFlags2 = 0;
	handType = 0;
	structure = 0;
	isHiLo = false;
	preRegMsg.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::equals(const Protocol_MSG_PPP_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		errInfo.equals(_o.errInfo) &&
		currency.equals(_o.currency) &&
		buyInPlusRake == _o.buyInPlusRake &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		isPlayMoney == _o.isPlayMoney &&
		admissionId.equals(_o.admissionId) &&
		admPrice == _o.admPrice &&
		numTickets == _o.numTickets &&
		name.equals(_o.name) &&
		userRmBalance == _o.userRmBalance &&
		userPmBalance == _o.userPmBalance &&
		userTChipsBalance == _o.userTChipsBalance &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		speed == _o.speed &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		preRegMsg.equals(_o.preRegMsg);
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errInfo=");
		errInfo.toTraceString(_buf);
	}
	else if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInPlusRake=");
		_buf.appendInt64(buyInPlusRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendInt64(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendInt64(rake);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("admissionId=");
		_buf.append(admissionId);
		_buf.append(',');
		_buf.append("admPrice=");
		_buf.appendInt64(admPrice);
		_buf.append(',');
		_buf.append("numTickets=");
		_buf.appendInt(numTickets);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("userRmBalance=");
		_buf.appendInt64(userRmBalance);
		_buf.append(',');
		_buf.append("userPmBalance=");
		_buf.appendInt64(userPmBalance);
		_buf.append(',');
		_buf.append("userTChipsBalance=");
		_buf.appendInt64(userTChipsBalance);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		currencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		clientCurrencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("speed=");
		_buf.appendUint(speed);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendInt(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendInt(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
		_buf.append(',');
		_buf.append("handType=");
		_buf.appendUint(handType);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("preRegMsg=");
		_buf.append(preRegMsg);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_msg.composeString(errDescr);
		errInfo.composeMsg(_msg);
	}
	else if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeINT64(buyInPlusRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_msg.composeINT64(buyIn);
		_msg.composeINT64(rake);
		_msg.composeString(currency);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeString(admissionId);
		_msg.composeINT64(admPrice);
		_msg.composeINT32(numTickets);
		_msg.composeString(name);
		_msg.composeINT64(userRmBalance);
		_msg.composeINT64(userPmBalance);
		_msg.composeINT64(userTChipsBalance);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeBYTE(speed);
		_msg.composeINT32(minPlayers);
		_msg.composeINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT64(tournFlags2);
		_msg.composeBYTE(handType);
		_msg.composeBYTE(structure);
		_msg.composeBOOL(isHiLo);
		_msg.composeString(preRegMsg);
	}
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_parser.parseStringP(errDescr);
		errInfo.parseMsg(_parser);
	}
	else if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseINT64(buyInPlusRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_parser.parseINT64(buyIn);
		_parser.parseINT64(rake);
		_parser.parseStringP(currency);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseStringP(admissionId);
		_parser.parseINT64(admPrice);
		_parser.parseINT32(numTickets);
		_parser.parseStringP(name);
		_parser.parseINT64(userRmBalance);
		_parser.parseINT64(userPmBalance);
		_parser.parseINT64(userTChipsBalance);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseBYTE(speed);
		_parser.parseINT32(minPlayers);
		_parser.parseINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT64(tournFlags2);
		_parser.parseBYTE(handType);
		_parser.parseBYTE(structure);
		_parser.parseBOOL(isHiLo);
		_parser.parseStringP(preRegMsg);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournCommonThin::Error_InsufficientFunds::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("errInfo"), _fieldsWithUnparsedContent);
	}
	else if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		INT64 buyInPlusRake; _parser.parseINT64(buyInPlusRake);
		AtfValidator::validateInt(_descr, "buyInPlusRake", buyInPlusRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 buyIn; _parser.parseINT64(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		INT64 rake; _parser.parseINT64(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
		INT64 admPrice; _parser.parseINT64(admPrice);
		AtfValidator::validateInt(_descr, "admPrice", admPrice, _checker, __FILE__, __LINE__);
		INT32 numTickets; _parser.parseINT32(numTickets);
		AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		INT64 userRmBalance; _parser.parseINT64(userRmBalance);
		AtfValidator::validateInt(_descr, "userRmBalance", userRmBalance, _checker, __FILE__, __LINE__);
		INT64 userPmBalance; _parser.parseINT64(userPmBalance);
		AtfValidator::validateInt(_descr, "userPmBalance", userPmBalance, _checker, __FILE__, __LINE__);
		INT64 userTChipsBalance; _parser.parseINT64(userTChipsBalance);
		AtfValidator::validateInt(_descr, "userTChipsBalance", userTChipsBalance, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		BYTE speed; _parser.parseBYTE(speed);
		AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
		INT32 minPlayers; _parser.parseINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		INT32 maxPlayers; _parser.parseINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		BYTE handType; _parser.parseBYTE(handType);
		AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegMsg"); size_t szPreRegMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegMsg", szPreRegMsg, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_REGISTER_USER
//=================================================================

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::Protocol_MSG_PPP_REGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::Protocol_MSG_PPP_REGISTER_USER(Protocol_MSG_PPP_REGISTER_USER&& _o)
	: pppId(std::move(_o.pppId))
	, seqId(std::move(_o.seqId))
	, buyInTierId(std::move(_o.buyInTierId))
	, buyInRM(std::move(_o.buyInRM))
	, buyInTChips(std::move(_o.buyInTChips))
	, buyInPM(std::move(_o.buyInPM))
	, useTicket(std::move(_o.useTicket))
	, currencyContext(std::move(_o.currencyContext))
{
}

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER& PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::operator=(Protocol_MSG_PPP_REGISTER_USER&& _o)
{
	if(this != &_o)
	{
		pppId = std::move(_o.pppId);
		seqId = std::move(_o.seqId);
		buyInTierId = std::move(_o.buyInTierId);
		buyInRM = std::move(_o.buyInRM);
		buyInTChips = std::move(_o.buyInTChips);
		buyInPM = std::move(_o.buyInPM);
		useTicket = std::move(_o.useTicket);
		currencyContext = std::move(_o.currencyContext);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::clear()
{
	pppId = 0;
	seqId = 0;
	buyInTierId = 0;
	buyInRM = 0;
	buyInTChips = 0;
	buyInPM = 0;
	useTicket = false;
	currencyContext.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::equals(const Protocol_MSG_PPP_REGISTER_USER& _o) const
{
	return pppId == _o.pppId &&
		seqId == _o.seqId &&
		buyInTierId == _o.buyInTierId &&
		buyInRM == _o.buyInRM &&
		buyInTChips == _o.buyInTChips &&
		buyInPM == _o.buyInPM &&
		useTicket == _o.useTicket &&
		currencyContext.equals(_o.currencyContext);
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_REGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("seqId=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("buyInTierId=");
	_buf.appendUint(buyInTierId);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendInt64(buyInRM);
	_buf.append(',');
	_buf.append("buyInTChips=");
	_buf.appendInt64(buyInTChips);
	_buf.append(',');
	_buf.append("buyInPM=");
	_buf.appendInt64(buyInPM);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("currencyContext=");
	currencyContext.toTraceString(_buf);
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(pppId);
	_msg.composeUINT32(seqId);
	_msg.composeUINT32(buyInTierId);
	_msg.composeINT64(buyInRM);
	_msg.composeINT64(buyInTChips);
	_msg.composeINT64(buyInPM);
	_msg.composeBOOL(useTicket);
	_msg.composeMsgBody(currencyContext);
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(pppId);
	_parser.parseUINT32(seqId);
	_parser.parseUINT32(buyInTierId);
	_parser.parseINT64(buyInRM);
	_parser.parseINT64(buyInTChips);
	_parser.parseINT64(buyInPM);
	_parser.parseBOOL(useTicket);
	_parser.parseMsgBody(currencyContext);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	UINT32 buyInTierId; _parser.parseUINT32(buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	INT64 buyInRM; _parser.parseINT64(buyInRM);
	AtfValidator::validateInt(_descr, "buyInRM", buyInRM, _checker, __FILE__, __LINE__);
	INT64 buyInTChips; _parser.parseINT64(buyInTChips);
	AtfValidator::validateInt(_descr, "buyInTChips", buyInTChips, _checker, __FILE__, __LINE__);
	INT64 buyInPM; _parser.parseINT64(buyInPM);
	AtfValidator::validateInt(_descr, "buyInPM", buyInPM, _checker, __FILE__, __LINE__);
	bool useTicket; _parser.parseBOOL(useTicket);
	AtfValidator::validateInt(_descr, "useTicket", useTicket, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_REGISTER_USER_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::Protocol_MSG_PPP_REGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::Protocol_MSG_PPP_REGISTER_USER_REPLY(Protocol_MSG_PPP_REGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, pppEntryId(std::move(_o.pppEntryId))
{
}

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY& PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::operator=(Protocol_MSG_PPP_REGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		pppEntryId = std::move(_o.pppEntryId);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	pppEntryId = 0;
}

bool PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::equals(const Protocol_MSG_PPP_REGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		pppEntryId == _o.pppEntryId;
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_REGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("pppEntryId=");
		_buf.appendUint64(pppEntryId);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT64(pppEntryId);
	}
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT64(pppEntryId);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 pppEntryId; _parser.parseUINT64(pppEntryId);
		AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_UNREGISTER_USER
//=================================================================

PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::Protocol_MSG_PPP_UNREGISTER_USER()
{
	clear();
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::clear()
{
	pppId = 0;
	pppEntryId = 0;
}

bool PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::equals(const Protocol_MSG_PPP_UNREGISTER_USER& _o) const
{
	return pppId == _o.pppId &&
		pppEntryId == _o.pppEntryId;
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_UNREGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("pppEntryId=");
	_buf.appendUint64(pppEntryId);
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(pppId);
	_msg.composeUINT64(pppEntryId);
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(pppId);
	_parser.parseUINT64(pppEntryId);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_UNREGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT64 pppEntryId; _parser.parseUINT64(pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_UNREGISTER_USER_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::Protocol_MSG_PPP_UNREGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::Protocol_MSG_PPP_UNREGISTER_USER_REPLY(Protocol_MSG_PPP_UNREGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, refund(std::move(_o.refund))
	, refundPlay(std::move(_o.refundPlay))
	, refundTChips(std::move(_o.refundTChips))
	, tournamentCurrency(std::move(_o.tournamentCurrency))
	, refundCurrency(std::move(_o.refundCurrency))
{
}

PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY& PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::operator=(Protocol_MSG_PPP_UNREGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		refund = std::move(_o.refund);
		refundPlay = std::move(_o.refundPlay);
		refundTChips = std::move(_o.refundTChips);
		tournamentCurrency = std::move(_o.tournamentCurrency);
		refundCurrency = std::move(_o.refundCurrency);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	refund = 0;
	refundPlay = 0;
	refundTChips = 0;
	tournamentCurrency.clear();
	refundCurrency.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::equals(const Protocol_MSG_PPP_UNREGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		refund == _o.refund &&
		refundPlay == _o.refundPlay &&
		refundTChips == _o.refundTChips &&
		tournamentCurrency.equals(_o.tournamentCurrency) &&
		refundCurrency.equals(_o.refundCurrency);
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_UNREGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("refund=");
		_buf.appendInt(refund);
		_buf.append(',');
		_buf.append("refundPlay=");
		_buf.appendInt64(refundPlay);
		_buf.append(',');
		_buf.append("refundTChips=");
		_buf.appendInt(refundTChips);
		_buf.append(',');
		_buf.append("tournamentCurrency=");
		_buf.append(tournamentCurrency);
		_buf.append(',');
		_buf.append("refundCurrency=");
		_buf.append(refundCurrency);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(refund);
		_msg.composeINT64(refundPlay);
		_msg.composeINT32(refundTChips);
		_msg.composeString(tournamentCurrency);
		_msg.composeString(refundCurrency);
	}
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(refund);
		_parser.parseINT64(refundPlay);
		_parser.parseINT32(refundTChips);
		_parser.parseStringP(tournamentCurrency);
		_parser.parseStringP(refundCurrency);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_UNREGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 refund; _parser.parseINT32(refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
		INT64 refundPlay; _parser.parseINT64(refundPlay);
		AtfValidator::validateInt(_descr, "refundPlay", refundPlay, _checker, __FILE__, __LINE__);
		INT32 refundTChips; _parser.parseINT32(refundTChips);
		AtfValidator::validateInt(_descr, "refundTChips", refundTChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournamentCurrency"); size_t szTournamentCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournamentCurrency", szTournamentCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "refundCurrency"); size_t szRefundCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "refundCurrency", szRefundCurrency, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PppEntry
//=================================================================

PPPClient::client::PppEntry::PppEntry()
{
	clear();
}

void PPPClient::client::PppEntry::clear()
{
	pppId = 0;
	pppEntryId = 0;
	status = 0;
	amountOnHead = 0;
	canUnregister = false;
	tournId = 0;
	buyInTierId = 0;
}

bool PPPClient::client::PppEntry::equals(const PppEntry& _o) const
{
	return pppId == _o.pppId &&
		pppEntryId == _o.pppEntryId &&
		status == _o.status &&
		amountOnHead == _o.amountOnHead &&
		canUnregister == _o.canUnregister &&
		tournId == _o.tournId &&
		buyInTierId == _o.buyInTierId;
}

const char *PPPClient::client::PppEntry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("pppEntryId=");
	_buf.appendUint64(pppEntryId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("amountOnHead=");
	_buf.appendInt64(amountOnHead);
	_buf.append(',');
	_buf.append("canUnregister=");
	_buf.appendUint(canUnregister);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append(',');
	_buf.append("buyInTierId=");
	_buf.appendUint(buyInTierId);
	_buf.append('}');
	return _buf.c_str();
}

void PPPClient::client::PppEntry::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PppEntry())) // not empty
	{
		_body.composeUINT32(pppId);
		_body.composeUINT64(pppEntryId);
		_body.composeINT16(status);
		_body.composeINT64(amountOnHead);
		_body.composeBOOL(canUnregister);
		_body.composeUINT64(tournId);
		_body.composeUINT32(buyInTierId);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::client::PppEntry::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(pppId);
	_parser0.parseUINT64(pppEntryId);
	_parser0.parseINT16(status);
	_parser0.parseINT64(amountOnHead);
	_parser0.parseBOOL(canUnregister);
	_parser0.parseUINT64(tournId);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(buyInTierId);
}

/*static*/ void PPPClient::client::PppEntry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 pppId; _parser0.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT64 pppEntryId; _parser0.parseUINT64(pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	INT16 status; _parser0.parseINT16(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	INT64 amountOnHead; _parser0.parseINT64(amountOnHead);
	AtfValidator::validateInt(_descr, "amountOnHead", amountOnHead, _checker, __FILE__, __LINE__);
	bool canUnregister; _parser0.parseBOOL(canUnregister);
	AtfValidator::validateInt(_descr, "canUnregister", canUnregister, _checker, __FILE__, __LINE__);
	UINT64 tournId; _parser0.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 buyInTierId; _parser0.parseUINT32(buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_PPP_GET_ENTRIES
//=================================================================

PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::Protocol_MSG_PPP_GET_ENTRIES()
{
	clear();
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::clear()
{
}

bool PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::equals(const Protocol_MSG_PPP_GET_ENTRIES& _o) const
{
	return true;
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_GET_ENTRIES).append(")");
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::composeMsg(CommMsgBody& _msg) const
{
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_GET_ENTRIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_GET_ENTRIES_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::Protocol_MSG_PPP_GET_ENTRIES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::Protocol_MSG_PPP_GET_ENTRIES_REPLY(Protocol_MSG_PPP_GET_ENTRIES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, entries(std::move(_o.entries))
{
}

PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY& PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::operator=(Protocol_MSG_PPP_GET_ENTRIES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		entries = std::move(_o.entries);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	entries.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::equals(const Protocol_MSG_PPP_GET_ENTRIES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg) &&
		entries.equals(_o.entries);
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_GET_ENTRIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("entries=");
		entries.toTraceString(_buf);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		entries.composeMsg(_msg);
	}
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		entries.parseMsg(_parser);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_GET_ENTRIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szEntries = ThinAtf::LAtfVector< PppEntry, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("entries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "entries", szEntries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_SET_ENTRY_STATUS
//=================================================================

PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::Protocol_MSG_PPP_SET_ENTRY_STATUS()
{
	clear();
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::clear()
{
	pppId = 0;
	pppEntryId = 0;
	newStatus = 0;
}

bool PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::equals(const Protocol_MSG_PPP_SET_ENTRY_STATUS& _o) const
{
	return pppId == _o.pppId &&
		pppEntryId == _o.pppEntryId &&
		newStatus == _o.newStatus;
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_SET_ENTRY_STATUS).append(")");
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("pppEntryId=");
	_buf.appendUint64(pppEntryId);
	_buf.append(',');
	_buf.append("newStatus=");
	_buf.appendInt(newStatus);
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(pppId);
	_msg.composeUINT64(pppEntryId);
	_msg.composeINT16(newStatus);
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(pppId);
	_parser.parseUINT64(pppEntryId);
	_parser.parseINT16(newStatus);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_SET_ENTRY_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT64 pppEntryId; _parser.parseUINT64(pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	INT16 newStatus; _parser.parseINT16(newStatus);
	AtfValidator::validateInt(_descr, "newStatus", newStatus, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY(Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
{
}

PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY& PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::operator=(Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::equals(const Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg);
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_SET_ENTRY_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errMsg);
	}
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errMsg);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_SET_ENTRY_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool PPPClient::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "client"))
	{
		switch(_msgId)
		{
			case MSG_PPP_GET_ENTRIES: client::Protocol_MSG_PPP_GET_ENTRIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_GET_ENTRIES_REPLY: client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REGISTER_USER: client::Protocol_MSG_PPP_REGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REGISTER_USER_REPLY: client::Protocol_MSG_PPP_REGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REG_INFO: client::Protocol_MSG_PPP_REG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REG_INFO_REPLY: client::Protocol_MSG_PPP_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_SET_ENTRY_STATUS: client::Protocol_MSG_PPP_SET_ENTRY_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_SET_ENTRY_STATUS_REPLY: client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_UNREGISTER_USER: client::Protocol_MSG_PPP_UNREGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_UNREGISTER_USER_REPLY: client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

