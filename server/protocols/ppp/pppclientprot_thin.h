/**
 * pppclientprot_thin.h
 *
 * This file was auto-generated from pppclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin pppclientprot.txt
 */

#ifndef ATF_PROTOCOL_DEFFILE_PPPCLIENTPROT_THIN_H
#define ATF_PROTOCOL_DEFFILE_PPPCLIENTPROT_THIN_H

//------------------------------------------------------------------------------
//	PPP (progressive plus pool) starter <-> Client Protocol
//------------------------------------------------------------------------------
//
// Copyright (C) 2019 Stars Technologies Services All rights reserved.
//
//------------------------------------------------------------------------------

#include "ThinAtfUserDefStructs.h"
#include "mtlobby/TournCommonStructs_thin.h"
#include "sitemasks.h"
#include "pyrtime.h"
#include "lobby.h"
#include "dbm.h"


namespace PPPClient
{
	class ProtocolFactory
	{
	public:
		static bool validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded);
	};


	//------------------------------------------------------------------------------

	//------------------------------------------------------------------------------

	namespace publication
	{
		struct PppBuyInTierInfo
		{
			// M(488) - M(buyInTierId,buyIn,rake)
			UINT32 buyInTierId;
			INT64 buyIn;
			INT64 rake;

			PppBuyInTierInfo();
			void clear();
			bool equals(const PppBuyInTierInfo&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct PppVisibility
		{
			// M(4mM(b4<s>)s) - M(brandMask,siteMask,M(excludeCountries,numCountries<countries>),criteria)
			UINT32 brandMask;	// visibility mask
			PSiteMask siteMask;	// visibility mask

			bool excludeCountries;
			ThinAtf::LAtfVector< PString , 4 > countries;	// country inclusion/exclusion list

			PString criteria;	// criteria name to look up in Help Support Portal

			PppVisibility();
			void clear();
			bool equals(const PppVisibility&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PppVisibility(PppVisibility&&);
			PppVisibility& operator=(PppVisibility&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			PppVisibility(const PppVisibility&) = default;
			PppVisibility& operator=(const PppVisibility&) = default;
#endif
#endif

		private: // helper functions
			void parseAnonymousMsgBody0(CommMsgParser& _parser);
			static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		// TODO @move_only_no_copy?
		struct PppStaticLeaf	// Leaf { 0, n, 0 }
		{
			// b[44bIM(4mM(b4<s>)s)bs4<M(488)>11b48] - visible[pppId,seqId,regOpen,name,M(brandMask,siteMask,M(excludeCountries,numCountries<countries>),criteria),isPlayMoney,currency,numBuyInTiers<M(buyInTierId,buyIn,rake)>,handType,structure,isHiLo,maxEntriesPerPlayer,winnerCashoutThreshold]
			bool visible;

			UINT32 pppId;	// unique identifier for this progressive plus pool
			UINT32 seqId;	// pool definition version

			bool regOpen;

			I18nPString name;

			PppVisibility visibility;

			bool isPlayMoney;
			PString currency;

			ThinAtf::LAtfVector< PppBuyInTierInfo, 4 > buyInTiers;

			BYTE handType;
			BYTE structure;
			bool isHiLo;

			INT32 maxEntriesPerPlayer;

			INT64 winnerCashoutThreshold;	// players returning to the pool after a tournament win with >= this amount are cashed out as winners

			// add any other info needed by client to the end

			PppStaticLeaf();
			void clear();
			bool equals(const PppStaticLeaf&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PppStaticLeaf(PppStaticLeaf&&);
			PppStaticLeaf& operator=(PppStaticLeaf&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			PppStaticLeaf(const PppStaticLeaf&) = default;
			PppStaticLeaf& operator=(const PppStaticLeaf&) = default;
#endif
#endif
		};

		struct PppFeaturedTable
		{
			// M(8ssss) - M(tournId,mtLobbyAddress,mtLobbyObject,tableAddress,tableObject)
			UINT64 tournId;	// tournId of MTLobby object where featured table is
			PString mtLobbyAddress;	// address of MTLobby object where featured table is
			PString mtLobbyObject;	// instance of MTLobby object where featured table is
			PString tableAddress;	// address of featured table owned by MTLobby object
			PString tableObject;	// instance of featured table owned by MTLobby object

			PppFeaturedTable();
			void clear();
			bool equals(const PppFeaturedTable&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PppFeaturedTable(PppFeaturedTable&&);
			PppFeaturedTable& operator=(PppFeaturedTable&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			PppFeaturedTable(const PppFeaturedTable&) = default;
			PppFeaturedTable& operator=(const PppFeaturedTable&) = default;
#endif
#endif
		};

		struct PppFeaturedKO
		{
			// M(s88) - M(userId,winAmount,knockedOutPlayerValue)
			PString userId;	// userId of player who knocked out another player
			INT64 winAmount;	// amount won by userId for knocking out other player
			INT64 knockedOutPlayerValue;	// value of knocked out player

			PppFeaturedKO();
			void clear();
			bool equals(const PppFeaturedKO&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PppFeaturedKO(PppFeaturedKO&&);
			PppFeaturedKO& operator=(PppFeaturedKO&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			PppFeaturedKO(const PppFeaturedKO&) = default;
			PppFeaturedKO& operator=(const PppFeaturedKO&) = default;
#endif
#endif
		};

		struct PppFeaturedFinisher
		{
			// M(s88) - M(userId,cashoutAmount,totalKOAmount)
			PString userId;
			INT64 cashoutAmount;	// amount cashed out by the player
			INT64 totalKOAmount;	// total knockout values won

			PppFeaturedFinisher();
			void clear();
			bool equals(const PppFeaturedFinisher&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PppFeaturedFinisher(PppFeaturedFinisher&&);
			PppFeaturedFinisher& operator=(PppFeaturedFinisher&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			PppFeaturedFinisher(const PppFeaturedFinisher&) = default;
			PppFeaturedFinisher& operator=(const PppFeaturedFinisher&) = default;
#endif
#endif
		};

		// TODO @move_only_no_copy?
		struct PppDynamicLeaf	// Leaf { 0, n, 1 }
		{
			// M(8ssss)4<M(s88)>4<M(s88)> - M(tournId,mtLobbyAddress,mtLobbyObject,tableAddress,tableObject),numFeaturedKOs<M(userId,winAmount,knockedOutPlayerValue)>,numFeaturedFinishers<M(userId,cashoutAmount,totalKOAmount)>
			PppFeaturedTable featuredTable;	// featured table info
			ThinAtf::LAtfVector< PppFeaturedKO , 4 > featuredKOs;	// featured KOs info
			ThinAtf::LAtfVector< PppFeaturedFinisher , 4 > featuredFinishers;	// featured finishers info

			PppDynamicLeaf();
			void clear();
			bool equals(const PppDynamicLeaf&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PppDynamicLeaf(PppDynamicLeaf&&);
			PppDynamicLeaf& operator=(PppDynamicLeaf&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			PppDynamicLeaf(const PppDynamicLeaf&) = default;
			PppDynamicLeaf& operator=(const PppDynamicLeaf&) = default;
#endif
#endif
		};
	};

	namespace client
	{
		struct Protocol_MSG_PPP_REG_INFO
		{
			// 444 - pppId,seqId,buyInTierId
			UINT32 pppId;	// progressive plus pool id to request reg info for
			UINT32 seqId;	// version of pool definition shown to player - request will fail if it differs from current definition
			UINT32 buyInTierId;	// buyin tier id for buyin requested

			Protocol_MSG_PPP_REG_INFO();
			void clear();
			bool equals(const Protocol_MSG_PPP_REG_INFO&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_REG_INFO; }
			static const char *getMsgIdString() { return "MSG_PPP_REG_INFO"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_MSG_PPP_REG_INFO_REPLY
		{
			//! 2 <FIXME_COND_IF> s <FIXME>TournCommonThin::Error_InsufficientFunds</FIXME>  <FIXME_COND_ELSE> ss8b <FIXME_COND_ELSE> 88sbs84s888bM()M()14414811bs <FIXME_COND_ENDIF>  - errCode <FIXME_COND_IF> ,errDescr, <FIXME>errInfo</FIXME>  <FIXME_COND_ELSE> ,errDescr,currency,buyInPlusRake,enoughMoneyInOtherCurrency <FIXME_COND_ELSE> ,buyIn,rake,currency,isPlayMoney,admissionId,admPrice,numTickets,name,userRmBalance,userPmBalance,userTChipsBalance,enoughMoneyInOtherCurrency,M(),M(),speed,minPlayers,maxPlayers,maxPerTable,tournFlags,tournFlags2,handType,structure,isHiLo,preRegMsg <FIXME_COND_ENDIF> 
			INT16 errCode;

			PString errDescr;
			TournCommonThin::Error_InsufficientFunds errInfo;

			PString currency;
			INT64 buyInPlusRake;
			bool enoughMoneyInOtherCurrency;

			//entry parameters
			INT64 buyIn;
			INT64 rake;

			bool isPlayMoney;

			PString admissionId;
			INT64 admPrice;
			INT32 numTickets;	//total of that kind at user's disposal

			PString name;	//similar to tournamentName

			//user standing
			INT64 userRmBalance;
			INT64 userPmBalance;
			INT64 userTChipsBalance;

			ThinAtf::CopyableMsgBody currencyContext;
			ThinAtf::CopyableMsgBody clientCurrencyContext;

			//convenience stuff
			BYTE speed;
			INT32 minPlayers;
			INT32 maxPlayers;
			BYTE maxPerTable;
			UINT32 tournFlags;
			UINT64 tournFlags2;
			BYTE handType;
			BYTE structure;
			bool isHiLo;
			PString preRegMsg;

			Protocol_MSG_PPP_REG_INFO_REPLY();
			void clear();
			bool equals(const Protocol_MSG_PPP_REG_INFO_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_REG_INFO_REPLY; }
			static const char *getMsgIdString() { return "MSG_PPP_REG_INFO_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_MSG_PPP_REG_INFO_REPLY(Protocol_MSG_PPP_REG_INFO_REPLY&&);
			Protocol_MSG_PPP_REG_INFO_REPLY& operator=(Protocol_MSG_PPP_REG_INFO_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_MSG_PPP_REG_INFO_REPLY(const Protocol_MSG_PPP_REG_INFO_REPLY&) = default;
			Protocol_MSG_PPP_REG_INFO_REPLY& operator=(const Protocol_MSG_PPP_REG_INFO_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_MSG_PPP_REGISTER_USER
		{
			// 444888bM() - pppId,seqId,buyInTierId,buyInRM,buyInTChips,buyInPM,useTicket,M()
			UINT32 pppId;	// progressive plus pool id to request reg info for
			UINT32 seqId;	// version of pool definition shown to player - request will fail if it differs from current definition
			UINT32 buyInTierId;	// buyin tier id for buyin requested
			INT64 buyInRM;
			INT64 buyInTChips;
			INT64 buyInPM;
			bool useTicket;
			ThinAtf::CopyableMsgBody currencyContext;

			Protocol_MSG_PPP_REGISTER_USER();
			void clear();
			bool equals(const Protocol_MSG_PPP_REGISTER_USER&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_REGISTER_USER; }
			static const char *getMsgIdString() { return "MSG_PPP_REGISTER_USER"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_MSG_PPP_REGISTER_USER(Protocol_MSG_PPP_REGISTER_USER&&);
			Protocol_MSG_PPP_REGISTER_USER& operator=(Protocol_MSG_PPP_REGISTER_USER&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_MSG_PPP_REGISTER_USER(const Protocol_MSG_PPP_REGISTER_USER&) = default;
			Protocol_MSG_PPP_REGISTER_USER& operator=(const Protocol_MSG_PPP_REGISTER_USER&) = default;
#endif
#endif
		};

		struct Protocol_MSG_PPP_REGISTER_USER_REPLY
		{
			// 2[s|8] - errCode[errDescr|pppEntryId]
			INT16 errCode;

			PString errDescr;

			UINT64 pppEntryId;
			// TODO - what else is needed?
			/*
			   INT16 maxAllins;
			   PString registrationMsg;
			   bool seatsAvailable; // TODO: check name is appropriate
			   PString clientNotification;
			 */

			Protocol_MSG_PPP_REGISTER_USER_REPLY();
			void clear();
			bool equals(const Protocol_MSG_PPP_REGISTER_USER_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_REGISTER_USER_REPLY; }
			static const char *getMsgIdString() { return "MSG_PPP_REGISTER_USER_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_MSG_PPP_REGISTER_USER_REPLY(Protocol_MSG_PPP_REGISTER_USER_REPLY&&);
			Protocol_MSG_PPP_REGISTER_USER_REPLY& operator=(Protocol_MSG_PPP_REGISTER_USER_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_MSG_PPP_REGISTER_USER_REPLY(const Protocol_MSG_PPP_REGISTER_USER_REPLY&) = default;
			Protocol_MSG_PPP_REGISTER_USER_REPLY& operator=(const Protocol_MSG_PPP_REGISTER_USER_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_MSG_PPP_UNREGISTER_USER
		{
			// 48 - pppId,pppEntryId
			UINT32 pppId;
			UINT64 pppEntryId;

			Protocol_MSG_PPP_UNREGISTER_USER();
			void clear();
			bool equals(const Protocol_MSG_PPP_UNREGISTER_USER&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_UNREGISTER_USER; }
			static const char *getMsgIdString() { return "MSG_PPP_UNREGISTER_USER"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_MSG_PPP_UNREGISTER_USER_REPLY
		{
			// 2[s|484ss] - errCode[errDescr|refund,refundPlay,refundTChips,tournamentCurrency,refundCurrency]
			INT16 errCode;

			PString errDescr;

			INT32 refund;
			INT64 refundPlay;
			INT32 refundTChips;
			PString tournamentCurrency;
			PString refundCurrency;

			Protocol_MSG_PPP_UNREGISTER_USER_REPLY();
			void clear();
			bool equals(const Protocol_MSG_PPP_UNREGISTER_USER_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_UNREGISTER_USER_REPLY; }
			static const char *getMsgIdString() { return "MSG_PPP_UNREGISTER_USER_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_MSG_PPP_UNREGISTER_USER_REPLY(Protocol_MSG_PPP_UNREGISTER_USER_REPLY&&);
			Protocol_MSG_PPP_UNREGISTER_USER_REPLY& operator=(Protocol_MSG_PPP_UNREGISTER_USER_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_MSG_PPP_UNREGISTER_USER_REPLY(const Protocol_MSG_PPP_UNREGISTER_USER_REPLY&) = default;
			Protocol_MSG_PPP_UNREGISTER_USER_REPLY& operator=(const Protocol_MSG_PPP_UNREGISTER_USER_REPLY&) = default;
#endif
#endif
		};

		enum ePppEntryStatus
		{
			ePppEntryStatus_Inactive = 0, 	// entry is inactive and not available for matchmaking
			ePppEntryStatus_Ready = 1,    	// entry is eligible for matchmaking
			ePppEntryStatus_InUse = 2,    	// entry is currently allocated to a tournament
		};

		struct PppEntry
		{
			// M(4828b84) - M(pppId,pppEntryId,status,amountOnHead,canUnregister,tournId,buyInTierId)
			UINT32 pppId;	// identifier for the Progressive Plus Pool
			UINT64 pppEntryId;	// identifier for the player's entry within the pool
			INT16 status;	// ePppEntryStatus_*
			INT64 amountOnHead;	// current value of this entry
			bool canUnregister;	// set if this entry is eligible for unregistration
			// TODO - additional stats like num tourns played, num knockouts, winnings so far, etc?
			UINT64 tournId;	// tournId this entry is currently registered in, or 0 if inactive/matchmaking
			UINT32 buyInTierId;	// buyin tier at which this entry originally registered into the pool

			PppEntry();
			void clear();
			bool equals(const PppEntry&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_MSG_PPP_GET_ENTRIES
		{
			// empty msg

			Protocol_MSG_PPP_GET_ENTRIES();
			void clear();
			bool equals(const Protocol_MSG_PPP_GET_ENTRIES&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_GET_ENTRIES; }
			static const char *getMsgIdString() { return "MSG_PPP_GET_ENTRIES"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_MSG_PPP_GET_ENTRIES_REPLY
		{
			// 2[s|4<M(4828b84)>] - errCode[errMsg|numEntries<M(pppId,pppEntryId,status,amountOnHead,canUnregister,tournId,buyInTierId)>]
			INT16 errCode;

			PString errMsg;

			ThinAtf::LAtfVector< PppEntry, 4 > entries;

			Protocol_MSG_PPP_GET_ENTRIES_REPLY();
			void clear();
			bool equals(const Protocol_MSG_PPP_GET_ENTRIES_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_GET_ENTRIES_REPLY; }
			static const char *getMsgIdString() { return "MSG_PPP_GET_ENTRIES_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_MSG_PPP_GET_ENTRIES_REPLY(Protocol_MSG_PPP_GET_ENTRIES_REPLY&&);
			Protocol_MSG_PPP_GET_ENTRIES_REPLY& operator=(Protocol_MSG_PPP_GET_ENTRIES_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_MSG_PPP_GET_ENTRIES_REPLY(const Protocol_MSG_PPP_GET_ENTRIES_REPLY&) = default;
			Protocol_MSG_PPP_GET_ENTRIES_REPLY& operator=(const Protocol_MSG_PPP_GET_ENTRIES_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_MSG_PPP_SET_ENTRY_STATUS
		{
			// 482 - pppId,pppEntryId,newStatus
			UINT32 pppId;
			UINT64 pppEntryId;
			INT16 newStatus;	// one of ePppEntryStatus_Inactive or ePppEntryStatus_Ready

			Protocol_MSG_PPP_SET_ENTRY_STATUS();
			void clear();
			bool equals(const Protocol_MSG_PPP_SET_ENTRY_STATUS&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_SET_ENTRY_STATUS; }
			static const char *getMsgIdString() { return "MSG_PPP_SET_ENTRY_STATUS"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY
		{
			// 2[s] - errCode[errMsg]
			INT16 errCode;

			PString errMsg;

			Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY();
			void clear();
			bool equals(const Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return MSG_PPP_SET_ENTRY_STATUS_REPLY; }
			static const char *getMsgIdString() { return "MSG_PPP_SET_ENTRY_STATUS_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY(Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY&&);
			Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY& operator=(Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY(const Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY&) = default;
			Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY& operator=(const Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY&) = default;
#endif
#endif
		};
	};
};

#endif
