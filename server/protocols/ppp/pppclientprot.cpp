/**
 * pppclientprot.cpp
 *
 * This file was auto-generated from pppclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor pppclientprot.txt
 */
 
#include "pppclientprot.h"

//=================================================================
//                    PppBuyInTierInfo
//=================================================================

PPPClient::publication::PppBuyInTierInfo::PppBuyInTierInfo()
{
	clear();
}

void PPPClient::publication::PppBuyInTierInfo::clear()
{
	buyInTierId = 0;
	buyIn = 0;
	rake = 0;
}

bool PPPClient::publication::PppBuyInTierInfo::equals(const PppBuyInTierInfo& _o) const
{
	return buyInTierId == _o.buyInTierId &&
		buyIn == _o.buyIn &&
		rake == _o.rake;
}

const char *PPPClient::publication::PppBuyInTierInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("buyInTierId=");
	_buf.appendUint(buyInTierId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt64(rake);
	_buf.append('}');
	return _buf.c_str();
}

const char *PPPClient::publication::PppBuyInTierInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("buyInTierId", buyInTierId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PPPClient::publication::PppBuyInTierInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("buyInTierId"))
		{
			buyInTierId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PPPClient::publication::PppBuyInTierInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PppBuyInTierInfo())) // not empty
	{
		_body.composeUINT32(buyInTierId);
		_body.composeINT64(buyIn);
		_body.composeINT64(rake);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppBuyInTierInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(buyInTierId);
	_parser0.parseINT64(buyIn);
	_parser0.parseINT64(rake);
}

void PPPClient::publication::PppBuyInTierInfo::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("buyInTierId", buyInTierId);
	_parser0.parse("buyIn", buyIn);
	_parser0.parse("rake", rake);
}

const char *PPPClient::publication::PppBuyInTierInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("buyInTierId", buyInTierId);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	return _buf.c_str();
}

void PPPClient::publication::PppBuyInTierInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("buyInTierId", buyInTierId);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
}

/* static */ void PPPClient::publication::PppBuyInTierInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 buyInTierId; _jparser.validateByNameThrow("buyInTierId", buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	INT64 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT64 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::publication::PppBuyInTierInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 buyInTierId; _parser0.parseUINT32(buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	INT64 buyIn; _parser0.parseINT64(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	INT64 rake; _parser0.parseINT64(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppVisibility
//=================================================================

PPPClient::publication::PppVisibility::PppVisibility()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppVisibility::PppVisibility(PppVisibility&& _o)
	: brandMask(std::move(_o.brandMask))
	, siteMask(std::move(_o.siteMask))
	, excludeCountries(std::move(_o.excludeCountries))
	, countries(std::move(_o.countries))
	, criteria(std::move(_o.criteria))
{
}

PPPClient::publication::PppVisibility& PPPClient::publication::PppVisibility::operator=(PppVisibility&& _o)
{
	if(this != &_o)
	{
		brandMask = std::move(_o.brandMask);
		siteMask = std::move(_o.siteMask);
		excludeCountries = std::move(_o.excludeCountries);
		countries = std::move(_o.countries);
		criteria = std::move(_o.criteria);
	}
	return *this;
}

#endif

void PPPClient::publication::PppVisibility::clear()
{
	brandMask = 0;
	siteMask.clear();
	excludeCountries = false;
	countries.clear();
	criteria.clear();
}

bool PPPClient::publication::PppVisibility::equals(const PppVisibility& _o) const
{
	return brandMask == _o.brandMask &&
		siteMask.equals(_o.siteMask) &&
		excludeCountries == _o.excludeCountries &&
		countries.equals(_o.countries) &&
		criteria.equals(_o.criteria);
}

const char *PPPClient::publication::PppVisibility::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("brandMask=");
	_buf.appendUint(brandMask);
	_buf.append(',');
	_buf.append("siteMask=");
	siteMask.toTraceString(_buf);
	_buf.append(',');
	_buf.append("excludeCountries=");
	_buf.appendUint(excludeCountries);
	_buf.append(',');
	_buf.append("countries=");
	countries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append('}');
	return _buf.c_str();
}

const char *PPPClient::publication::PppVisibility::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("brandMask", brandMask, _buf);
	siteMask.toXmlString("siteMask", _buf);
	Atf::XmlElement::encodeAsXmlElement("excludeCountries", excludeCountries, _buf);
	countries.toXmlString("countries", _buf);
	Atf::XmlElement::encodeAsXmlElement("criteria", criteria, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PPPClient::publication::PppVisibility::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("brandMask"))
		{
			brandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteMask"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, siteMask)) return false;
		}
		else if (_element.equals("excludeCountries"))
		{
			excludeCountries = (*_value.ptr() == '1');
		}
		else if (_element.equals("countries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, countries)) return false;
		}
		else if (_element.equals("criteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, criteria)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PPPClient::publication::PppVisibility::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PppVisibility())) // not empty
	{
		_body.composeUINT32(brandMask);
		siteMask.composeMsg(_body, _ignoreJSON);
		CommMsgBody _body0;
		_body0.composeBOOL(excludeCountries);
		countries.composeMsg(_body0, _ignoreJSON);
		_body.composeMsgBody(_body0);
		_body.composeString(criteria);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppVisibility::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(brandMask);
	siteMask.parseMsg(_parser0);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseStringP(criteria);
}

void PPPClient::publication::PppVisibility::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("brandMask", brandMask);
	_parser0.parse("siteMask", siteMask);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parse("criteria", criteria);
}

const char *PPPClient::publication::PppVisibility::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("brandMask", brandMask);
	_jsonstr.compose("siteMask", siteMask);
	_jsonstr.compose("excludeCountries", excludeCountries);
	_jsonstr.compose("countries", countries);
	_jsonstr.compose("criteria", criteria);
	return _buf.c_str();
}

void PPPClient::publication::PppVisibility::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("brandMask", brandMask);
	_jparser.parseByNameThrow("siteMask", siteMask);
	_jparser.parseByNameThrow("excludeCountries", excludeCountries);
	_jparser.parseByNameThrow("countries", countries);
	_jparser.parseByNameThrow("criteria", criteria);
}

/* static */ void PPPClient::publication::PppVisibility::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 brandMask; _jparser.validateByNameThrow("brandMask", brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	PSiteMask siteMask; _jparser.validateByNameThrow("siteMask", siteMask);
	bool excludeCountries; _jparser.validateByNameThrow("excludeCountries", excludeCountries);
	AtfValidator::validateInt(_descr, "excludeCountries", excludeCountries, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > countries; _jparser.validateByNameThrow("countries", countries);
	AtfValidator::validateInt(_descr, "countries", countries.size(), _checker, __FILE__, __LINE__);
	PString criteria; _jparser.validateByNameThrow("criteria", criteria);
	AtfValidator::validateInt(_descr, "criteria", criteria.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::publication::PppVisibility::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 brandMask; _parser0.parseUINT32(brandMask);
	AtfValidator::validateInt(_descr, "brandMask", brandMask, _checker, __FILE__, __LINE__);
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("siteMask"), _fieldsWithUnparsedContent);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void PPPClient::publication::PppVisibility::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBOOL(excludeCountries);
	countries.parseMsg(_parser0);
}

void PPPClient::publication::PppVisibility::parseAnonymousMsgBody0(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("excludeCountries", excludeCountries);
	_parser0.parse("countries", countries);
}

/*static*/ void PPPClient::publication::PppVisibility::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool excludeCountries; _parser0.parseBOOL(excludeCountries);
	AtfValidator::validateInt(_descr, "excludeCountries", excludeCountries, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCountries = Atf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppStaticLeaf
//=================================================================

PPPClient::publication::PppStaticLeaf::PppStaticLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppStaticLeaf::PppStaticLeaf(PppStaticLeaf&& _o)
	: visible(std::move(_o.visible))
	, pppId(std::move(_o.pppId))
	, seqId(std::move(_o.seqId))
	, regOpen(std::move(_o.regOpen))
	, name(std::move(_o.name))
	, visibility(std::move(_o.visibility))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, currency(std::move(_o.currency))
	, buyInTiers(std::move(_o.buyInTiers))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, maxEntriesPerPlayer(std::move(_o.maxEntriesPerPlayer))
	, winnerCashoutThreshold(std::move(_o.winnerCashoutThreshold))
{
}

PPPClient::publication::PppStaticLeaf& PPPClient::publication::PppStaticLeaf::operator=(PppStaticLeaf&& _o)
{
	if(this != &_o)
	{
		visible = std::move(_o.visible);
		pppId = std::move(_o.pppId);
		seqId = std::move(_o.seqId);
		regOpen = std::move(_o.regOpen);
		name = std::move(_o.name);
		visibility = std::move(_o.visibility);
		isPlayMoney = std::move(_o.isPlayMoney);
		currency = std::move(_o.currency);
		buyInTiers = std::move(_o.buyInTiers);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		maxEntriesPerPlayer = std::move(_o.maxEntriesPerPlayer);
		winnerCashoutThreshold = std::move(_o.winnerCashoutThreshold);
	}
	return *this;
}

#endif

void PPPClient::publication::PppStaticLeaf::clear()
{
	visible = false;
	pppId = 0;
	seqId = 0;
	regOpen = false;
	name.clear();
	visibility.clear();
	isPlayMoney = false;
	currency.clear();
	buyInTiers.clear();
	handType = 0;
	structure = 0;
	isHiLo = false;
	maxEntriesPerPlayer = 0;
	winnerCashoutThreshold = 0;
}

bool PPPClient::publication::PppStaticLeaf::equals(const PppStaticLeaf& _o) const
{
	return visible == _o.visible &&
		pppId == _o.pppId &&
		seqId == _o.seqId &&
		regOpen == _o.regOpen &&
		name.equals(_o.name) &&
		visibility.equals(_o.visibility) &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		buyInTiers.equals(_o.buyInTiers) &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		maxEntriesPerPlayer == _o.maxEntriesPerPlayer &&
		winnerCashoutThreshold == _o.winnerCashoutThreshold;
}

const char *PPPClient::publication::PppStaticLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("visible=");
	_buf.appendUint(visible);
	if( visible )
	{
		_buf.append(',');
		_buf.append("pppId=");
		_buf.appendUint(pppId);
		_buf.append(',');
		_buf.append("seqId=");
		_buf.appendUint(seqId);
		_buf.append(',');
		_buf.append("regOpen=");
		_buf.appendUint(regOpen);
		_buf.append(',');
		_buf.append("name=");
		Atf::AtfTempl<I18nPString>::ToTraceString(_buf, name);
		_buf.append(',');
		_buf.append("visibility=");
		visibility.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInTiers=");
		buyInTiers.toTraceString(_buf);
		_buf.append(',');
		_buf.append("handType=");
		_buf.appendUint(handType);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("maxEntriesPerPlayer=");
		_buf.appendInt(maxEntriesPerPlayer);
		_buf.append(',');
		_buf.append("winnerCashoutThreshold=");
		_buf.appendInt64(winnerCashoutThreshold);
	}
	_buf.append('}');
	return _buf.c_str();
}

const char *PPPClient::publication::PppStaticLeaf::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("visible", visible, _buf);
	if( visible )
	{
		Atf::XmlElement::encodeAsXmlElement("pppId", pppId, _buf);
		Atf::XmlElement::encodeAsXmlElement("seqId", seqId, _buf);
		Atf::XmlElement::encodeAsXmlElement("regOpen", regOpen, _buf);
		Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "name", name);
		visibility.toXmlString("visibility", _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		buyInTiers.toXmlString("buyInTiers", _buf);
		Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxEntriesPerPlayer", maxEntriesPerPlayer, _buf);
		Atf::XmlElement::encodeAsXmlElement("winnerCashoutThreshold", winnerCashoutThreshold, _buf);
	}
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PPPClient::publication::PppStaticLeaf::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("visible"))
		{
			visible = (*_value.ptr() == '1');
		}
		else if (_element.equals("pppId"))
		{
			pppId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("seqId"))
		{
			seqId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("regOpen"))
		{
			regOpen = (*_value.ptr() == '1');
		}
		else if (_element.equals("name"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, name);
		}
		else if (_element.equals("visibility"))
		{
			if(!Atf::AtfTempl< PppVisibility >::FromXmlString(_value, visibility)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("buyInTiers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PppBuyInTierInfo, 4 > >::FromXmlString(_value, buyInTiers)) return false;
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("maxEntriesPerPlayer"))
		{
			maxEntriesPerPlayer = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winnerCashoutThreshold"))
		{
			winnerCashoutThreshold = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PPPClient::publication::PppStaticLeaf::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(visible);
	if( visible )
	{
		_msg.composeUINT32(pppId);
		_msg.composeUINT32(seqId);
		_msg.composeBOOL(regOpen);
		name.compose(_msg);
		visibility.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeString(currency);
		buyInTiers.composeMsg(_msg, _ignoreJSON);
		_msg.composeBYTE(handType);
		_msg.composeBYTE(structure);
		_msg.composeBOOL(isHiLo);
		_msg.composeINT32(maxEntriesPerPlayer);
		_msg.composeINT64(winnerCashoutThreshold);
	}
}

void PPPClient::publication::PppStaticLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(visible);
	if( visible )
	{
		_parser.parseUINT32(pppId);
		_parser.parseUINT32(seqId);
		_parser.parseBOOL(regOpen);
		name.parse(_parser);
		visibility.parseMsg(_parser);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseStringP(currency);
		buyInTiers.parseMsg(_parser);
		_parser.parseBYTE(handType);
		_parser.parseBYTE(structure);
		_parser.parseBOOL(isHiLo);
		_parser.parseINT32(maxEntriesPerPlayer);
		if(_parser.parseEnded()) return;
		_parser.parseINT64(winnerCashoutThreshold);
	}
}

void PPPClient::publication::PppStaticLeaf::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("visible", visible);
	if( visible )
	{
		_parser.parse("pppId", pppId);
		_parser.parse("seqId", seqId);
		_parser.parse("regOpen", regOpen);
		_parser.parse("name", name);
		_parser.parse("visibility", visibility);
		_parser.parse("isPlayMoney", isPlayMoney);
		_parser.parse("currency", currency);
		_parser.parse("buyInTiers", buyInTiers);
		_parser.parse("handType", handType);
		_parser.parse("structure", structure);
		_parser.parse("isHiLo", isHiLo);
		_parser.parse("maxEntriesPerPlayer", maxEntriesPerPlayer);
		if(_parser.parseEnded()) return;
		_parser.parse("winnerCashoutThreshold", winnerCashoutThreshold);
	}
}

const char *PPPClient::publication::PppStaticLeaf::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("visible", visible);
	if( visible )
	{
		_jsonstr.compose("pppId", pppId);
		_jsonstr.compose("seqId", seqId);
		_jsonstr.compose("regOpen", regOpen);
		_jsonstr.compose("name", name);
		_jsonstr.compose("visibility", visibility);
		_jsonstr.compose("isPlayMoney", isPlayMoney);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("buyInTiers", buyInTiers);
		_jsonstr.compose("handType", handType);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("maxEntriesPerPlayer", maxEntriesPerPlayer);
		_jsonstr.compose("winnerCashoutThreshold", winnerCashoutThreshold);
	}
	return _buf.c_str();
}

void PPPClient::publication::PppStaticLeaf::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("visible", visible);
	if( visible )
	{
		_jparser.parseByNameThrow("pppId", pppId);
		_jparser.parseByNameThrow("seqId", seqId);
		_jparser.parseByNameThrow("regOpen", regOpen);
		_jparser.parseByNameThrow("name", name);
		_jparser.parseByNameThrow("visibility", visibility);
		_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("buyInTiers", buyInTiers);
		_jparser.parseByNameThrow("handType", handType);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("maxEntriesPerPlayer", maxEntriesPerPlayer);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("winnerCashoutThreshold", winnerCashoutThreshold);
	}
}

/* static */ void PPPClient::publication::PppStaticLeaf::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool visible = false;
	_jparser.validateByNameThrow("visible", visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	if( visible )
	{
		UINT32 pppId; _jparser.validateByNameThrow("pppId", pppId);
		AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
		UINT32 seqId; _jparser.validateByNameThrow("seqId", seqId);
		AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
		bool regOpen; _jparser.validateByNameThrow("regOpen", regOpen);
		AtfValidator::validateInt(_descr, "regOpen", regOpen, _checker, __FILE__, __LINE__);
		I18nPString name; _jparser.validateByNameThrow("name", name);
		PppVisibility visibility; _jparser.validateByNameThrow("visibility", visibility);
		bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< PppBuyInTierInfo > buyInTiers; _jparser.validateByNameThrow("buyInTiers", buyInTiers);
		AtfValidator::validateInt(_descr, "buyInTiers", buyInTiers.size(), _checker, __FILE__, __LINE__);
		BYTE handType; _jparser.validateByNameThrow("handType", handType);
		AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		INT32 maxEntriesPerPlayer; _jparser.validateByNameThrow("maxEntriesPerPlayer", maxEntriesPerPlayer);
		AtfValidator::validateInt(_descr, "maxEntriesPerPlayer", maxEntriesPerPlayer, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		INT64 winnerCashoutThreshold; _jparser.validateByNameThrow("winnerCashoutThreshold", winnerCashoutThreshold);
		AtfValidator::validateInt(_descr, "winnerCashoutThreshold", winnerCashoutThreshold, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void PPPClient::publication::PppStaticLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool visible = false;
	_parser.parseBOOL(visible);
	AtfValidator::validateInt(_descr, "visible", visible, _checker, __FILE__, __LINE__);
	if( visible )
	{
		UINT32 pppId; _parser.parseUINT32(pppId);
		AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
		UINT32 seqId; _parser.parseUINT32(seqId);
		AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
		bool regOpen; _parser.parseBOOL(regOpen);
		AtfValidator::validateInt(_descr, "regOpen", regOpen, _checker, __FILE__, __LINE__);
		I18nPString name; name.parse(_parser);
		PString _descbuf;
		PppVisibility::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibility"), _fieldsWithUnparsedContent);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		int szBuyInTiers = Atf::LAtfVector< PppBuyInTierInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("buyInTiers"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "buyInTiers", szBuyInTiers, _checker, __FILE__, __LINE__);
		BYTE handType; _parser.parseBYTE(handType);
		AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		INT32 maxEntriesPerPlayer; _parser.parseINT32(maxEntriesPerPlayer);
		AtfValidator::validateInt(_descr, "maxEntriesPerPlayer", maxEntriesPerPlayer, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT64 winnerCashoutThreshold; _parser.parseINT64(winnerCashoutThreshold);
		AtfValidator::validateInt(_descr, "winnerCashoutThreshold", winnerCashoutThreshold, _checker, __FILE__, __LINE__);
	}
}

//=================================================================
//                    PppFeaturedTable
//=================================================================

PPPClient::publication::PppFeaturedTable::PppFeaturedTable()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppFeaturedTable::PppFeaturedTable(PppFeaturedTable&& _o)
	: tournId(std::move(_o.tournId))
	, mtLobbyAddress(std::move(_o.mtLobbyAddress))
	, mtLobbyObject(std::move(_o.mtLobbyObject))
	, tableAddress(std::move(_o.tableAddress))
	, tableObject(std::move(_o.tableObject))
{
}

PPPClient::publication::PppFeaturedTable& PPPClient::publication::PppFeaturedTable::operator=(PppFeaturedTable&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		mtLobbyAddress = std::move(_o.mtLobbyAddress);
		mtLobbyObject = std::move(_o.mtLobbyObject);
		tableAddress = std::move(_o.tableAddress);
		tableObject = std::move(_o.tableObject);
	}
	return *this;
}

#endif

void PPPClient::publication::PppFeaturedTable::clear()
{
	tournId = 0;
	mtLobbyAddress.clear();
	mtLobbyObject.clear();
	tableAddress.clear();
	tableObject.clear();
}

bool PPPClient::publication::PppFeaturedTable::equals(const PppFeaturedTable& _o) const
{
	return tournId == _o.tournId &&
		mtLobbyAddress.equals(_o.mtLobbyAddress) &&
		mtLobbyObject.equals(_o.mtLobbyObject) &&
		tableAddress.equals(_o.tableAddress) &&
		tableObject.equals(_o.tableObject);
}

const char *PPPClient::publication::PppFeaturedTable::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append(',');
	_buf.append("mtLobbyAddress=");
	_buf.append(mtLobbyAddress);
	_buf.append(',');
	_buf.append("mtLobbyObject=");
	_buf.append(mtLobbyObject);
	_buf.append(',');
	_buf.append("tableAddress=");
	_buf.append(tableAddress);
	_buf.append(',');
	_buf.append("tableObject=");
	_buf.append(tableObject);
	_buf.append('}');
	return _buf.c_str();
}

const char *PPPClient::publication::PppFeaturedTable::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("mtLobbyAddress", mtLobbyAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("mtLobbyObject", mtLobbyObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableAddress", tableAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableObject", tableObject, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PPPClient::publication::PppFeaturedTable::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournId"))
		{
			tournId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mtLobbyAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mtLobbyAddress)) return false;
		}
		else if (_element.equals("mtLobbyObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mtLobbyObject)) return false;
		}
		else if (_element.equals("tableAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableAddress)) return false;
		}
		else if (_element.equals("tableObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableObject)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PPPClient::publication::PppFeaturedTable::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PppFeaturedTable())) // not empty
	{
		_body.composeUINT64(tournId);
		_body.composeString(mtLobbyAddress);
		_body.composeString(mtLobbyObject);
		_body.composeString(tableAddress);
		_body.composeString(tableObject);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppFeaturedTable::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(tournId);
	_parser0.parseStringP(mtLobbyAddress);
	_parser0.parseStringP(mtLobbyObject);
	_parser0.parseStringP(tableAddress);
	_parser0.parseStringP(tableObject);
}

void PPPClient::publication::PppFeaturedTable::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("tournId", tournId);
	_parser0.parse("mtLobbyAddress", mtLobbyAddress);
	_parser0.parse("mtLobbyObject", mtLobbyObject);
	_parser0.parse("tableAddress", tableAddress);
	_parser0.parse("tableObject", tableObject);
}

const char *PPPClient::publication::PppFeaturedTable::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("mtLobbyAddress", mtLobbyAddress);
	_jsonstr.compose("mtLobbyObject", mtLobbyObject);
	_jsonstr.compose("tableAddress", tableAddress);
	_jsonstr.compose("tableObject", tableObject);
	return _buf.c_str();
}

void PPPClient::publication::PppFeaturedTable::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("mtLobbyAddress", mtLobbyAddress);
	_jparser.parseByNameThrow("mtLobbyObject", mtLobbyObject);
	_jparser.parseByNameThrow("tableAddress", tableAddress);
	_jparser.parseByNameThrow("tableObject", tableObject);
}

/* static */ void PPPClient::publication::PppFeaturedTable::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString mtLobbyAddress; _jparser.validateByNameThrow("mtLobbyAddress", mtLobbyAddress);
	AtfValidator::validateInt(_descr, "mtLobbyAddress", mtLobbyAddress.length(), _checker, __FILE__, __LINE__);
	PString mtLobbyObject; _jparser.validateByNameThrow("mtLobbyObject", mtLobbyObject);
	AtfValidator::validateInt(_descr, "mtLobbyObject", mtLobbyObject.length(), _checker, __FILE__, __LINE__);
	PString tableAddress; _jparser.validateByNameThrow("tableAddress", tableAddress);
	AtfValidator::validateInt(_descr, "tableAddress", tableAddress.length(), _checker, __FILE__, __LINE__);
	PString tableObject; _jparser.validateByNameThrow("tableObject", tableObject);
	AtfValidator::validateInt(_descr, "tableObject", tableObject.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::publication::PppFeaturedTable::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 tournId; _parser0.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mtLobbyAddress"); size_t szMtLobbyAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mtLobbyAddress", szMtLobbyAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mtLobbyObject"); size_t szMtLobbyObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mtLobbyObject", szMtLobbyObject, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableAddress"); size_t szTableAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableAddress", szTableAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppFeaturedKO
//=================================================================

PPPClient::publication::PppFeaturedKO::PppFeaturedKO()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppFeaturedKO::PppFeaturedKO(PppFeaturedKO&& _o)
	: userId(std::move(_o.userId))
	, winAmount(std::move(_o.winAmount))
	, knockedOutPlayerValue(std::move(_o.knockedOutPlayerValue))
{
}

PPPClient::publication::PppFeaturedKO& PPPClient::publication::PppFeaturedKO::operator=(PppFeaturedKO&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		winAmount = std::move(_o.winAmount);
		knockedOutPlayerValue = std::move(_o.knockedOutPlayerValue);
	}
	return *this;
}

#endif

void PPPClient::publication::PppFeaturedKO::clear()
{
	userId.clear();
	winAmount = 0;
	knockedOutPlayerValue = 0;
}

bool PPPClient::publication::PppFeaturedKO::equals(const PppFeaturedKO& _o) const
{
	return userId.equals(_o.userId) &&
		winAmount == _o.winAmount &&
		knockedOutPlayerValue == _o.knockedOutPlayerValue;
}

const char *PPPClient::publication::PppFeaturedKO::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("winAmount=");
	_buf.appendInt64(winAmount);
	_buf.append(',');
	_buf.append("knockedOutPlayerValue=");
	_buf.appendInt64(knockedOutPlayerValue);
	_buf.append('}');
	return _buf.c_str();
}

const char *PPPClient::publication::PppFeaturedKO::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("winAmount", winAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockedOutPlayerValue", knockedOutPlayerValue, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PPPClient::publication::PppFeaturedKO::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("winAmount"))
		{
			winAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockedOutPlayerValue"))
		{
			knockedOutPlayerValue = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PPPClient::publication::PppFeaturedKO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PppFeaturedKO())) // not empty
	{
		_body.composeString(userId);
		_body.composeINT64(winAmount);
		_body.composeINT64(knockedOutPlayerValue);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppFeaturedKO::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseINT64(winAmount);
	_parser0.parseINT64(knockedOutPlayerValue);
}

void PPPClient::publication::PppFeaturedKO::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("userId", userId);
	_parser0.parse("winAmount", winAmount);
	_parser0.parse("knockedOutPlayerValue", knockedOutPlayerValue);
}

const char *PPPClient::publication::PppFeaturedKO::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("winAmount", winAmount);
	_jsonstr.compose("knockedOutPlayerValue", knockedOutPlayerValue);
	return _buf.c_str();
}

void PPPClient::publication::PppFeaturedKO::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("winAmount", winAmount);
	_jparser.parseByNameThrow("knockedOutPlayerValue", knockedOutPlayerValue);
}

/* static */ void PPPClient::publication::PppFeaturedKO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	INT64 winAmount; _jparser.validateByNameThrow("winAmount", winAmount);
	AtfValidator::validateInt(_descr, "winAmount", winAmount, _checker, __FILE__, __LINE__);
	INT64 knockedOutPlayerValue; _jparser.validateByNameThrow("knockedOutPlayerValue", knockedOutPlayerValue);
	AtfValidator::validateInt(_descr, "knockedOutPlayerValue", knockedOutPlayerValue, _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::publication::PppFeaturedKO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	INT64 winAmount; _parser0.parseINT64(winAmount);
	AtfValidator::validateInt(_descr, "winAmount", winAmount, _checker, __FILE__, __LINE__);
	INT64 knockedOutPlayerValue; _parser0.parseINT64(knockedOutPlayerValue);
	AtfValidator::validateInt(_descr, "knockedOutPlayerValue", knockedOutPlayerValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppFeaturedFinisher
//=================================================================

PPPClient::publication::PppFeaturedFinisher::PppFeaturedFinisher()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppFeaturedFinisher::PppFeaturedFinisher(PppFeaturedFinisher&& _o)
	: userId(std::move(_o.userId))
	, cashoutAmount(std::move(_o.cashoutAmount))
	, totalKOAmount(std::move(_o.totalKOAmount))
{
}

PPPClient::publication::PppFeaturedFinisher& PPPClient::publication::PppFeaturedFinisher::operator=(PppFeaturedFinisher&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		cashoutAmount = std::move(_o.cashoutAmount);
		totalKOAmount = std::move(_o.totalKOAmount);
	}
	return *this;
}

#endif

void PPPClient::publication::PppFeaturedFinisher::clear()
{
	userId.clear();
	cashoutAmount = 0;
	totalKOAmount = 0;
}

bool PPPClient::publication::PppFeaturedFinisher::equals(const PppFeaturedFinisher& _o) const
{
	return userId.equals(_o.userId) &&
		cashoutAmount == _o.cashoutAmount &&
		totalKOAmount == _o.totalKOAmount;
}

const char *PPPClient::publication::PppFeaturedFinisher::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("cashoutAmount=");
	_buf.appendInt64(cashoutAmount);
	_buf.append(',');
	_buf.append("totalKOAmount=");
	_buf.appendInt64(totalKOAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *PPPClient::publication::PppFeaturedFinisher::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("cashoutAmount", cashoutAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalKOAmount", totalKOAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PPPClient::publication::PppFeaturedFinisher::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("cashoutAmount"))
		{
			cashoutAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalKOAmount"))
		{
			totalKOAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PPPClient::publication::PppFeaturedFinisher::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PppFeaturedFinisher())) // not empty
	{
		_body.composeString(userId);
		_body.composeINT64(cashoutAmount);
		_body.composeINT64(totalKOAmount);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::publication::PppFeaturedFinisher::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseINT64(cashoutAmount);
	_parser0.parseINT64(totalKOAmount);
}

void PPPClient::publication::PppFeaturedFinisher::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("userId", userId);
	_parser0.parse("cashoutAmount", cashoutAmount);
	_parser0.parse("totalKOAmount", totalKOAmount);
}

const char *PPPClient::publication::PppFeaturedFinisher::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("cashoutAmount", cashoutAmount);
	_jsonstr.compose("totalKOAmount", totalKOAmount);
	return _buf.c_str();
}

void PPPClient::publication::PppFeaturedFinisher::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("cashoutAmount", cashoutAmount);
	_jparser.parseByNameThrow("totalKOAmount", totalKOAmount);
}

/* static */ void PPPClient::publication::PppFeaturedFinisher::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	INT64 cashoutAmount; _jparser.validateByNameThrow("cashoutAmount", cashoutAmount);
	AtfValidator::validateInt(_descr, "cashoutAmount", cashoutAmount, _checker, __FILE__, __LINE__);
	INT64 totalKOAmount; _jparser.validateByNameThrow("totalKOAmount", totalKOAmount);
	AtfValidator::validateInt(_descr, "totalKOAmount", totalKOAmount, _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::publication::PppFeaturedFinisher::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	INT64 cashoutAmount; _parser0.parseINT64(cashoutAmount);
	AtfValidator::validateInt(_descr, "cashoutAmount", cashoutAmount, _checker, __FILE__, __LINE__);
	INT64 totalKOAmount; _parser0.parseINT64(totalKOAmount);
	AtfValidator::validateInt(_descr, "totalKOAmount", totalKOAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PppDynamicLeaf
//=================================================================

PPPClient::publication::PppDynamicLeaf::PppDynamicLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::publication::PppDynamicLeaf::PppDynamicLeaf(PppDynamicLeaf&& _o)
	: featuredTable(std::move(_o.featuredTable))
	, featuredKOs(std::move(_o.featuredKOs))
	, featuredFinishers(std::move(_o.featuredFinishers))
{
}

PPPClient::publication::PppDynamicLeaf& PPPClient::publication::PppDynamicLeaf::operator=(PppDynamicLeaf&& _o)
{
	if(this != &_o)
	{
		featuredTable = std::move(_o.featuredTable);
		featuredKOs = std::move(_o.featuredKOs);
		featuredFinishers = std::move(_o.featuredFinishers);
	}
	return *this;
}

#endif

void PPPClient::publication::PppDynamicLeaf::clear()
{
	featuredTable.clear();
	featuredKOs.clear();
	featuredFinishers.clear();
}

bool PPPClient::publication::PppDynamicLeaf::equals(const PppDynamicLeaf& _o) const
{
	return featuredTable.equals(_o.featuredTable) &&
		featuredKOs.equals(_o.featuredKOs) &&
		featuredFinishers.equals(_o.featuredFinishers);
}

const char *PPPClient::publication::PppDynamicLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("featuredTable=");
	featuredTable.toTraceString(_buf);
	_buf.append(',');
	_buf.append("featuredKOs=");
	featuredKOs.toTraceString(_buf);
	_buf.append(',');
	_buf.append("featuredFinishers=");
	featuredFinishers.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *PPPClient::publication::PppDynamicLeaf::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	featuredTable.toXmlString("featuredTable", _buf);
	featuredKOs.toXmlString("featuredKOs", _buf);
	featuredFinishers.toXmlString("featuredFinishers", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PPPClient::publication::PppDynamicLeaf::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("featuredTable"))
		{
			if(!Atf::AtfTempl< PppFeaturedTable >::FromXmlString(_value, featuredTable)) return false;
		}
		else if (_element.equals("featuredKOs"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PppFeaturedKO , 4 > >::FromXmlString(_value, featuredKOs)) return false;
		}
		else if (_element.equals("featuredFinishers"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PppFeaturedFinisher , 4 > >::FromXmlString(_value, featuredFinishers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PPPClient::publication::PppDynamicLeaf::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	featuredTable.composeMsg(_msg, _ignoreJSON);
	featuredKOs.composeMsg(_msg, _ignoreJSON);
	featuredFinishers.composeMsg(_msg, _ignoreJSON);
}

void PPPClient::publication::PppDynamicLeaf::parseMsg(CommMsgParser& _parser)
{
	featuredTable.parseMsg(_parser);
	featuredKOs.parseMsg(_parser);
	featuredFinishers.parseMsg(_parser);
}

void PPPClient::publication::PppDynamicLeaf::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("featuredTable", featuredTable);
	_parser.parse("featuredKOs", featuredKOs);
	_parser.parse("featuredFinishers", featuredFinishers);
}

const char *PPPClient::publication::PppDynamicLeaf::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("featuredTable", featuredTable);
	_jsonstr.compose("featuredKOs", featuredKOs);
	_jsonstr.compose("featuredFinishers", featuredFinishers);
	return _buf.c_str();
}

void PPPClient::publication::PppDynamicLeaf::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("featuredTable", featuredTable);
	_jparser.parseByNameThrow("featuredKOs", featuredKOs);
	_jparser.parseByNameThrow("featuredFinishers", featuredFinishers);
}

/* static */ void PPPClient::publication::PppDynamicLeaf::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PppFeaturedTable featuredTable; _jparser.validateByNameThrow("featuredTable", featuredTable);
	Atf::AtfVectorBase< PppFeaturedKO > featuredKOs; _jparser.validateByNameThrow("featuredKOs", featuredKOs);
	AtfValidator::validateInt(_descr, "featuredKOs", featuredKOs.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PppFeaturedFinisher > featuredFinishers; _jparser.validateByNameThrow("featuredFinishers", featuredFinishers);
	AtfValidator::validateInt(_descr, "featuredFinishers", featuredFinishers.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::publication::PppDynamicLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	PString _descbuf;
	PppFeaturedTable::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("featuredTable"), _fieldsWithUnparsedContent);
	int szFeaturedKOs = Atf::LAtfVector< PppFeaturedKO , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("featuredKOs"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "featuredKOs", szFeaturedKOs, _checker, __FILE__, __LINE__);
	int szFeaturedFinishers = Atf::LAtfVector< PppFeaturedFinisher , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("featuredFinishers"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "featuredFinishers", szFeaturedFinishers, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_PPP_REG_INFO
//=================================================================

PPPClient::client::Protocol_MSG_PPP_REG_INFO::Protocol_MSG_PPP_REG_INFO()
{
	clear();
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO::clear()
{
	pppId = 0;
	seqId = 0;
	buyInTierId = 0;
}

bool PPPClient::client::Protocol_MSG_PPP_REG_INFO::equals(const Protocol_MSG_PPP_REG_INFO& _o) const
{
	return pppId == _o.pppId &&
		seqId == _o.seqId &&
		buyInTierId == _o.buyInTierId;
}

bool PPPClient::client::Protocol_MSG_PPP_REG_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_REG_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_REG_INFO*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_REG_INFO).append(")");
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("seqId=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("buyInTierId=");
	_buf.appendUint(buyInTierId);
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_REG_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pppId", pppId, _buf);
	Atf::XmlElement::encodeAsXmlElement("seqId", seqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInTierId", buyInTierId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_REG_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pppId"))
			{
				pppId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInTierId"))
			{
				buyInTierId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(pppId);
	_msg.composeUINT32(seqId);
	_msg.composeUINT32(buyInTierId);
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(pppId);
	_parser.parseUINT32(seqId);
	_parser.parseUINT32(buyInTierId);
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pppId", pppId);
	_jsonstr.compose("seqId", seqId);
	_jsonstr.compose("buyInTierId", buyInTierId);
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pppId", pppId);
	_jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("buyInTierId", buyInTierId);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REG_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 pppId; _jparser.validateByNameThrow("pppId", pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT32 seqId; _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	UINT32 buyInTierId; _jparser.validateByNameThrow("buyInTierId", buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REG_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REG_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	UINT32 buyInTierId; _parser.parseUINT32(buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_REG_INFO_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::Protocol_MSG_PPP_REG_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::Protocol_MSG_PPP_REG_INFO_REPLY(Protocol_MSG_PPP_REG_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, errInfo(std::move(_o.errInfo))
	, currency(std::move(_o.currency))
	, buyInPlusRake(std::move(_o.buyInPlusRake))
	, enoughMoneyInOtherCurrency(std::move(_o.enoughMoneyInOtherCurrency))
	, buyIn(std::move(_o.buyIn))
	, rake(std::move(_o.rake))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, admissionId(std::move(_o.admissionId))
	, admPrice(std::move(_o.admPrice))
	, numTickets(std::move(_o.numTickets))
	, name(std::move(_o.name))
	, userRmBalance(std::move(_o.userRmBalance))
	, userPmBalance(std::move(_o.userPmBalance))
	, userTChipsBalance(std::move(_o.userTChipsBalance))
	, currencyContext(std::move(_o.currencyContext))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, speed(std::move(_o.speed))
	, minPlayers(std::move(_o.minPlayers))
	, maxPlayers(std::move(_o.maxPlayers))
	, maxPerTable(std::move(_o.maxPerTable))
	, tournFlags(std::move(_o.tournFlags))
	, tournFlags2(std::move(_o.tournFlags2))
	, handType(std::move(_o.handType))
	, structure(std::move(_o.structure))
	, isHiLo(std::move(_o.isHiLo))
	, preRegMsg(std::move(_o.preRegMsg))
{
}

PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY& PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::operator=(Protocol_MSG_PPP_REG_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		errInfo = std::move(_o.errInfo);
		currency = std::move(_o.currency);
		buyInPlusRake = std::move(_o.buyInPlusRake);
		enoughMoneyInOtherCurrency = std::move(_o.enoughMoneyInOtherCurrency);
		buyIn = std::move(_o.buyIn);
		rake = std::move(_o.rake);
		isPlayMoney = std::move(_o.isPlayMoney);
		admissionId = std::move(_o.admissionId);
		admPrice = std::move(_o.admPrice);
		numTickets = std::move(_o.numTickets);
		name = std::move(_o.name);
		userRmBalance = std::move(_o.userRmBalance);
		userPmBalance = std::move(_o.userPmBalance);
		userTChipsBalance = std::move(_o.userTChipsBalance);
		currencyContext = std::move(_o.currencyContext);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		speed = std::move(_o.speed);
		minPlayers = std::move(_o.minPlayers);
		maxPlayers = std::move(_o.maxPlayers);
		maxPerTable = std::move(_o.maxPerTable);
		tournFlags = std::move(_o.tournFlags);
		tournFlags2 = std::move(_o.tournFlags2);
		handType = std::move(_o.handType);
		structure = std::move(_o.structure);
		isHiLo = std::move(_o.isHiLo);
		preRegMsg = std::move(_o.preRegMsg);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	errInfo.clear();
	currency.clear();
	buyInPlusRake = 0;
	enoughMoneyInOtherCurrency = false;
	buyIn = 0;
	rake = 0;
	isPlayMoney = false;
	admissionId.clear();
	admPrice = 0;
	numTickets = 0;
	name.clear();
	userRmBalance = 0;
	userPmBalance = 0;
	userTChipsBalance = 0;
	currencyContext.clear();
	clientCurrencyContext.clear();
	speed = 0;
	minPlayers = 0;
	maxPlayers = 0;
	maxPerTable = 0;
	tournFlags = 0;
	tournFlags2 = 0;
	handType = 0;
	structure = 0;
	isHiLo = false;
	preRegMsg.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::equals(const Protocol_MSG_PPP_REG_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		errInfo.equals(_o.errInfo) &&
		currency.equals(_o.currency) &&
		buyInPlusRake == _o.buyInPlusRake &&
		enoughMoneyInOtherCurrency == _o.enoughMoneyInOtherCurrency &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		isPlayMoney == _o.isPlayMoney &&
		admissionId.equals(_o.admissionId) &&
		admPrice == _o.admPrice &&
		numTickets == _o.numTickets &&
		name.equals(_o.name) &&
		userRmBalance == _o.userRmBalance &&
		userPmBalance == _o.userPmBalance &&
		userTChipsBalance == _o.userTChipsBalance &&
		currencyContext.equals(_o.currencyContext) &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		speed == _o.speed &&
		minPlayers == _o.minPlayers &&
		maxPlayers == _o.maxPlayers &&
		maxPerTable == _o.maxPerTable &&
		tournFlags == _o.tournFlags &&
		tournFlags2 == _o.tournFlags2 &&
		handType == _o.handType &&
		structure == _o.structure &&
		isHiLo == _o.isHiLo &&
		Atf::atfPStringEquals(preRegMsg, _o.preRegMsg);
}

bool PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_REG_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_REG_INFO_REPLY*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_REG_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("errInfo=");
		errInfo.toTraceString(_buf);
	}
	else if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("buyInPlusRake=");
		_buf.appendInt64(buyInPlusRake);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
	}
	else
	{
		_buf.append(',');
		_buf.append("buyIn=");
		_buf.appendInt64(buyIn);
		_buf.append(',');
		_buf.append("rake=");
		_buf.appendInt64(rake);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("isPlayMoney=");
		_buf.appendUint(isPlayMoney);
		_buf.append(',');
		_buf.append("admissionId=");
		_buf.append(admissionId);
		_buf.append(',');
		_buf.append("admPrice=");
		_buf.appendInt64(admPrice);
		_buf.append(',');
		_buf.append("numTickets=");
		_buf.appendInt(numTickets);
		_buf.append(',');
		_buf.append("name=");
		_buf.append(name);
		_buf.append(',');
		_buf.append("userRmBalance=");
		_buf.appendInt64(userRmBalance);
		_buf.append(',');
		_buf.append("userPmBalance=");
		_buf.appendInt64(userPmBalance);
		_buf.append(',');
		_buf.append("userTChipsBalance=");
		_buf.appendInt64(userTChipsBalance);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrency=");
		_buf.appendUint(enoughMoneyInOtherCurrency);
		_buf.append(',');
		_buf.append("currencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		_buf.append('{'); Atf::XmlElement::encodeMsgBody(clientCurrencyContext, _buf); _buf.append('}');
		_buf.append(',');
		_buf.append("speed=");
		_buf.appendUint(speed);
		_buf.append(',');
		_buf.append("minPlayers=");
		_buf.appendInt(minPlayers);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendInt(maxPlayers);
		_buf.append(',');
		_buf.append("maxPerTable=");
		_buf.appendUint(maxPerTable);
		_buf.append(',');
		_buf.append("tournFlags=");
		_buf.appendUint(tournFlags);
		_buf.append(',');
		_buf.append("tournFlags2=");
		_buf.appendUint64(tournFlags2);
		_buf.append(',');
		_buf.append("handType=");
		_buf.appendUint(handType);
		_buf.append(',');
		_buf.append("structure=");
		_buf.appendUint(structure);
		_buf.append(',');
		_buf.append("isHiLo=");
		_buf.appendUint(isHiLo);
		_buf.append(',');
		_buf.append("preRegMsg=");
		_buf.append(preRegMsg);
	}
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_REG_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		errInfo.toXmlString("errInfo", _buf);
	}
	else if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("buyInPlusRake", buyInPlusRake, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
		Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
		Atf::XmlElement::encodeAsXmlElement("admissionId", admissionId, _buf);
		Atf::XmlElement::encodeAsXmlElement("admPrice", admPrice, _buf);
		Atf::XmlElement::encodeAsXmlElement("numTickets", numTickets, _buf);
		Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
		Atf::XmlElement::encodeAsXmlElement("userRmBalance", userRmBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("userPmBalance", userPmBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("userTChipsBalance", userTChipsBalance, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientCurrencyContext", clientCurrencyContext, _buf);
		Atf::XmlElement::encodeAsXmlElement("speed", speed, _buf);
		Atf::XmlElement::encodeAsXmlElement("minPlayers", minPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPerTable", maxPerTable, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournFlags2", tournFlags2, _buf);
		Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
		Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
		Atf::XmlElement::encodeAsXmlElement("preRegMsg", preRegMsg, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("errInfo"))
			{
				if(!Atf::AtfTempl< TournCommon::Error_InsufficientFunds >::FromXmlString(_value, errInfo)) return false;
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("buyInPlusRake"))
			{
				buyInPlusRake = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("enoughMoneyInOtherCurrency"))
			{
				enoughMoneyInOtherCurrency = (*_value.ptr() == '1');
			}
			else if (_element.equals("buyIn"))
			{
				buyIn = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rake"))
			{
				rake = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("admissionId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, admissionId)) return false;
			}
			else if (_element.equals("admPrice"))
			{
				admPrice = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numTickets"))
			{
				numTickets = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("name"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
			}
			else if (_element.equals("userRmBalance"))
			{
				userRmBalance = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userPmBalance"))
			{
				userPmBalance = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userTChipsBalance"))
			{
				userTChipsBalance = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else if (_element.equals("clientCurrencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, clientCurrencyContext)) return false;
			}
			else if (_element.equals("speed"))
			{
				speed = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minPlayers"))
			{
				minPlayers = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayers"))
			{
				maxPlayers = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPerTable"))
			{
				maxPerTable = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags2"))
			{
				tournFlags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("handType"))
			{
				handType = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("structure"))
			{
				structure = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHiLo"))
			{
				isHiLo = (*_value.ptr() == '1');
			}
			else if (_element.equals("preRegMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, preRegMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_msg.composeString(errDescr);
		errInfo.composeMsg(_msg, _ignoreJSON);
	}
	else if( errCode )
	{
		_msg.composeString(errDescr);
		_msg.composeString(currency);
		_msg.composeINT64(buyInPlusRake);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_msg.composeINT64(buyIn);
		_msg.composeINT64(rake);
		_msg.composeString(currency);
		_msg.composeBOOL(isPlayMoney);
		_msg.composeString(admissionId);
		_msg.composeINT64(admPrice);
		_msg.composeINT32(numTickets);
		_msg.composeString(name);
		_msg.composeINT64(userRmBalance);
		_msg.composeINT64(userPmBalance);
		_msg.composeINT64(userTChipsBalance);
		_msg.composeBOOL(enoughMoneyInOtherCurrency);
		_msg.composeMsgBody(currencyContext);
		_msg.composeMsgBody(clientCurrencyContext);
		_msg.composeBYTE(speed);
		_msg.composeINT32(minPlayers);
		_msg.composeINT32(maxPlayers);
		_msg.composeBYTE(maxPerTable);
		_msg.composeUINT32(tournFlags);
		_msg.composeUINT64(tournFlags2);
		_msg.composeBYTE(handType);
		_msg.composeBYTE(structure);
		_msg.composeBOOL(isHiLo);
		_msg.composeString(preRegMsg);
	}
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_parser.parseStringP(errDescr);
		errInfo.parseMsg(_parser);
	}
	else if( errCode )
	{
		_parser.parseStringP(errDescr);
		_parser.parseStringP(currency);
		_parser.parseINT64(buyInPlusRake);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
	}
	else
	{
		_parser.parseINT64(buyIn);
		_parser.parseINT64(rake);
		_parser.parseStringP(currency);
		_parser.parseBOOL(isPlayMoney);
		_parser.parseStringP(admissionId);
		_parser.parseINT64(admPrice);
		_parser.parseINT32(numTickets);
		_parser.parseStringP(name);
		_parser.parseINT64(userRmBalance);
		_parser.parseINT64(userPmBalance);
		_parser.parseINT64(userTChipsBalance);
		_parser.parseBOOL(enoughMoneyInOtherCurrency);
		_parser.parseMsgBody(currencyContext);
		_parser.parseMsgBody(clientCurrencyContext);
		_parser.parseBYTE(speed);
		_parser.parseINT32(minPlayers);
		_parser.parseINT32(maxPlayers);
		_parser.parseBYTE(maxPerTable);
		_parser.parseUINT32(tournFlags);
		_parser.parseUINT64(tournFlags2);
		_parser.parseBYTE(handType);
		_parser.parseBYTE(structure);
		_parser.parseBOOL(isHiLo);
		_parser.parseStringP(preRegMsg);
	}
}

const char *PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("errInfo", errInfo);
	}
	else if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("buyInPlusRake", buyInPlusRake);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	}
	else
	{
		_jsonstr.compose("buyIn", buyIn);
		_jsonstr.compose("rake", rake);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("isPlayMoney", isPlayMoney);
		_jsonstr.compose("admissionId", admissionId);
		_jsonstr.compose("admPrice", admPrice);
		_jsonstr.compose("numTickets", numTickets);
		_jsonstr.compose("name", name);
		_jsonstr.compose("userRmBalance", userRmBalance);
		_jsonstr.compose("userPmBalance", userPmBalance);
		_jsonstr.compose("userTChipsBalance", userTChipsBalance);
		_jsonstr.compose("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jsonstr.compose("currencyContext", currencyContext);
		_jsonstr.compose("clientCurrencyContext", clientCurrencyContext);
		_jsonstr.compose("speed", speed);
		_jsonstr.compose("minPlayers", minPlayers);
		_jsonstr.compose("maxPlayers", maxPlayers);
		_jsonstr.compose("maxPerTable", maxPerTable);
		_jsonstr.compose("tournFlags", tournFlags);
		_jsonstr.compose("tournFlags2", tournFlags2);
		_jsonstr.compose("handType", handType);
		_jsonstr.compose("structure", structure);
		_jsonstr.compose("isHiLo", isHiLo);
		_jsonstr.compose("preRegMsg", preRegMsg);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("errInfo", errInfo);
	}
	else if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("buyInPlusRake", buyInPlusRake);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
	}
	else
	{
		_jparser.parseByNameThrow("buyIn", buyIn);
		_jparser.parseByNameThrow("rake", rake);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
		_jparser.parseByNameThrow("admissionId", admissionId);
		_jparser.parseByNameThrow("admPrice", admPrice);
		_jparser.parseByNameThrow("numTickets", numTickets);
		_jparser.parseByNameThrow("name", name);
		_jparser.parseByNameThrow("userRmBalance", userRmBalance);
		_jparser.parseByNameThrow("userPmBalance", userPmBalance);
		_jparser.parseByNameThrow("userTChipsBalance", userTChipsBalance);
		_jparser.parseByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		_jparser.parseByNameThrow("currencyContext", currencyContext);
		_jparser.parseByNameThrow("clientCurrencyContext", clientCurrencyContext);
		_jparser.parseByNameThrow("speed", speed);
		_jparser.parseByNameThrow("minPlayers", minPlayers);
		_jparser.parseByNameThrow("maxPlayers", maxPlayers);
		_jparser.parseByNameThrow("maxPerTable", maxPerTable);
		_jparser.parseByNameThrow("tournFlags", tournFlags);
		_jparser.parseByNameThrow("tournFlags2", tournFlags2);
		_jparser.parseByNameThrow("handType", handType);
		_jparser.parseByNameThrow("structure", structure);
		_jparser.parseByNameThrow("isHiLo", isHiLo);
		_jparser.parseByNameThrow("preRegMsg", preRegMsg);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		TournCommon::Error_InsufficientFunds errInfo; _jparser.validateByNameThrow("errInfo", errInfo);
	}
	else if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		INT64 buyInPlusRake; _jparser.validateByNameThrow("buyInPlusRake", buyInPlusRake);
		AtfValidator::validateInt(_descr, "buyInPlusRake", buyInPlusRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		INT64 rake; _jparser.validateByNameThrow("rake", rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		PString admissionId; _jparser.validateByNameThrow("admissionId", admissionId);
		AtfValidator::validateInt(_descr, "admissionId", admissionId.length(), _checker, __FILE__, __LINE__);
		INT64 admPrice; _jparser.validateByNameThrow("admPrice", admPrice);
		AtfValidator::validateInt(_descr, "admPrice", admPrice, _checker, __FILE__, __LINE__);
		INT32 numTickets; _jparser.validateByNameThrow("numTickets", numTickets);
		AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
		PString name; _jparser.validateByNameThrow("name", name);
		AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
		INT64 userRmBalance; _jparser.validateByNameThrow("userRmBalance", userRmBalance);
		AtfValidator::validateInt(_descr, "userRmBalance", userRmBalance, _checker, __FILE__, __LINE__);
		INT64 userPmBalance; _jparser.validateByNameThrow("userPmBalance", userPmBalance);
		AtfValidator::validateInt(_descr, "userPmBalance", userPmBalance, _checker, __FILE__, __LINE__);
		INT64 userTChipsBalance; _jparser.validateByNameThrow("userTChipsBalance", userTChipsBalance);
		AtfValidator::validateInt(_descr, "userTChipsBalance", userTChipsBalance, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _jparser.validateByNameThrow("enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
		AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
		Atf::CopyableMsgBody clientCurrencyContext; _jparser.validateByNameThrow("clientCurrencyContext", clientCurrencyContext);
		AtfValidator::validateInt(_descr, "clientCurrencyContext", clientCurrencyContext._size(), _checker, __FILE__, __LINE__);
		BYTE speed; _jparser.validateByNameThrow("speed", speed);
		AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
		INT32 minPlayers; _jparser.validateByNameThrow("minPlayers", minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		INT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _jparser.validateByNameThrow("maxPerTable", maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _jparser.validateByNameThrow("tournFlags", tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _jparser.validateByNameThrow("tournFlags2", tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		BYTE handType; _jparser.validateByNameThrow("handType", handType);
		AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
		BYTE structure; _jparser.validateByNameThrow("structure", structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		PString preRegMsg; _jparser.validateByNameThrow("preRegMsg", preRegMsg);
		AtfValidator::validateInt(_descr, "preRegMsg", preRegMsg.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REG_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REG_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode == ERR_INSUFFICIENT_FUNDS )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		PString _descbuf;
		TournCommon::Error_InsufficientFunds::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("errInfo"), _fieldsWithUnparsedContent);
	}
	else if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		INT64 buyInPlusRake; _parser.parseINT64(buyInPlusRake);
		AtfValidator::validateInt(_descr, "buyInPlusRake", buyInPlusRake, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT64 buyIn; _parser.parseINT64(buyIn);
		AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
		INT64 rake; _parser.parseINT64(rake);
		AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
		AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "admissionId"); size_t szAdmissionId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "admissionId", szAdmissionId, _checker, __FILE__, __LINE__);
		INT64 admPrice; _parser.parseINT64(admPrice);
		AtfValidator::validateInt(_descr, "admPrice", admPrice, _checker, __FILE__, __LINE__);
		INT32 numTickets; _parser.parseINT32(numTickets);
		AtfValidator::validateInt(_descr, "numTickets", numTickets, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
		INT64 userRmBalance; _parser.parseINT64(userRmBalance);
		AtfValidator::validateInt(_descr, "userRmBalance", userRmBalance, _checker, __FILE__, __LINE__);
		INT64 userPmBalance; _parser.parseINT64(userPmBalance);
		AtfValidator::validateInt(_descr, "userPmBalance", userPmBalance, _checker, __FILE__, __LINE__);
		INT64 userTChipsBalance; _parser.parseINT64(userTChipsBalance);
		AtfValidator::validateInt(_descr, "userTChipsBalance", userTChipsBalance, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrency; _parser.parseBOOL(enoughMoneyInOtherCurrency);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrency", enoughMoneyInOtherCurrency, _checker, __FILE__, __LINE__);
		size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
		AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
		size_t szClientCurrencyContext; _parser.skipMsgBody(szClientCurrencyContext);  /*clientCurrencyContext*/
		AtfValidator::validateInt(_descr, "clientCurrencyContext", szClientCurrencyContext, _checker, __FILE__, __LINE__);
		BYTE speed; _parser.parseBYTE(speed);
		AtfValidator::validateInt(_descr, "speed", speed, _checker, __FILE__, __LINE__);
		INT32 minPlayers; _parser.parseINT32(minPlayers);
		AtfValidator::validateInt(_descr, "minPlayers", minPlayers, _checker, __FILE__, __LINE__);
		INT32 maxPlayers; _parser.parseINT32(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		BYTE maxPerTable; _parser.parseBYTE(maxPerTable);
		AtfValidator::validateInt(_descr, "maxPerTable", maxPerTable, _checker, __FILE__, __LINE__);
		UINT32 tournFlags; _parser.parseUINT32(tournFlags);
		AtfValidator::validateInt(_descr, "tournFlags", tournFlags, _checker, __FILE__, __LINE__);
		UINT64 tournFlags2; _parser.parseUINT64(tournFlags2);
		AtfValidator::validateUint(_descr, "tournFlags2", tournFlags2, _checker, __FILE__, __LINE__);
		BYTE handType; _parser.parseBYTE(handType);
		AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
		BYTE structure; _parser.parseBYTE(structure);
		AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
		bool isHiLo; _parser.parseBOOL(isHiLo);
		AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "preRegMsg"); size_t szPreRegMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "preRegMsg", szPreRegMsg, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_REGISTER_USER
//=================================================================

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::Protocol_MSG_PPP_REGISTER_USER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::Protocol_MSG_PPP_REGISTER_USER(Protocol_MSG_PPP_REGISTER_USER&& _o)
	: pppId(std::move(_o.pppId))
	, seqId(std::move(_o.seqId))
	, buyInTierId(std::move(_o.buyInTierId))
	, buyInRM(std::move(_o.buyInRM))
	, buyInTChips(std::move(_o.buyInTChips))
	, buyInPM(std::move(_o.buyInPM))
	, useTicket(std::move(_o.useTicket))
	, currencyContext(std::move(_o.currencyContext))
{
}

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER& PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::operator=(Protocol_MSG_PPP_REGISTER_USER&& _o)
{
	if(this != &_o)
	{
		pppId = std::move(_o.pppId);
		seqId = std::move(_o.seqId);
		buyInTierId = std::move(_o.buyInTierId);
		buyInRM = std::move(_o.buyInRM);
		buyInTChips = std::move(_o.buyInTChips);
		buyInPM = std::move(_o.buyInPM);
		useTicket = std::move(_o.useTicket);
		currencyContext = std::move(_o.currencyContext);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::clear()
{
	pppId = 0;
	seqId = 0;
	buyInTierId = 0;
	buyInRM = 0;
	buyInTChips = 0;
	buyInPM = 0;
	useTicket = false;
	currencyContext.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::equals(const Protocol_MSG_PPP_REGISTER_USER& _o) const
{
	return pppId == _o.pppId &&
		seqId == _o.seqId &&
		buyInTierId == _o.buyInTierId &&
		buyInRM == _o.buyInRM &&
		buyInTChips == _o.buyInTChips &&
		buyInPM == _o.buyInPM &&
		useTicket == _o.useTicket &&
		currencyContext.equals(_o.currencyContext);
}

bool PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_REGISTER_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_REGISTER_USER*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_REGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("seqId=");
	_buf.appendUint(seqId);
	_buf.append(',');
	_buf.append("buyInTierId=");
	_buf.appendUint(buyInTierId);
	_buf.append(',');
	_buf.append("buyInRM=");
	_buf.appendInt64(buyInRM);
	_buf.append(',');
	_buf.append("buyInTChips=");
	_buf.appendInt64(buyInTChips);
	_buf.append(',');
	_buf.append("buyInPM=");
	_buf.appendInt64(buyInPM);
	_buf.append(',');
	_buf.append("useTicket=");
	_buf.appendUint(useTicket);
	_buf.append(',');
	_buf.append("currencyContext=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(currencyContext, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_REGISTER_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pppId", pppId, _buf);
	Atf::XmlElement::encodeAsXmlElement("seqId", seqId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInTierId", buyInTierId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInRM", buyInRM, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInTChips", buyInTChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInPM", buyInPM, _buf);
	Atf::XmlElement::encodeAsXmlElement("useTicket", useTicket, _buf);
	Atf::XmlElement::encodeAsXmlElement("currencyContext", currencyContext, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pppId"))
			{
				pppId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seqId"))
			{
				seqId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInTierId"))
			{
				buyInTierId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInRM"))
			{
				buyInRM = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInTChips"))
			{
				buyInTChips = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyInPM"))
			{
				buyInPM = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("useTicket"))
			{
				useTicket = (*_value.ptr() == '1');
			}
			else if (_element.equals("currencyContext"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, currencyContext)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(pppId);
	_msg.composeUINT32(seqId);
	_msg.composeUINT32(buyInTierId);
	_msg.composeINT64(buyInRM);
	_msg.composeINT64(buyInTChips);
	_msg.composeINT64(buyInPM);
	_msg.composeBOOL(useTicket);
	_msg.composeMsgBody(currencyContext);
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(pppId);
	_parser.parseUINT32(seqId);
	_parser.parseUINT32(buyInTierId);
	_parser.parseINT64(buyInRM);
	_parser.parseINT64(buyInTChips);
	_parser.parseINT64(buyInPM);
	_parser.parseBOOL(useTicket);
	_parser.parseMsgBody(currencyContext);
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pppId", pppId);
	_jsonstr.compose("seqId", seqId);
	_jsonstr.compose("buyInTierId", buyInTierId);
	_jsonstr.compose("buyInRM", buyInRM);
	_jsonstr.compose("buyInTChips", buyInTChips);
	_jsonstr.compose("buyInPM", buyInPM);
	_jsonstr.compose("useTicket", useTicket);
	_jsonstr.compose("currencyContext", currencyContext);
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pppId", pppId);
	_jparser.parseByNameThrow("seqId", seqId);
	_jparser.parseByNameThrow("buyInTierId", buyInTierId);
	_jparser.parseByNameThrow("buyInRM", buyInRM);
	_jparser.parseByNameThrow("buyInTChips", buyInTChips);
	_jparser.parseByNameThrow("buyInPM", buyInPM);
	_jparser.parseByNameThrow("useTicket", useTicket);
	_jparser.parseByNameThrow("currencyContext", currencyContext);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 pppId; _jparser.validateByNameThrow("pppId", pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT32 seqId; _jparser.validateByNameThrow("seqId", seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	UINT32 buyInTierId; _jparser.validateByNameThrow("buyInTierId", buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	INT64 buyInRM; _jparser.validateByNameThrow("buyInRM", buyInRM);
	AtfValidator::validateInt(_descr, "buyInRM", buyInRM, _checker, __FILE__, __LINE__);
	INT64 buyInTChips; _jparser.validateByNameThrow("buyInTChips", buyInTChips);
	AtfValidator::validateInt(_descr, "buyInTChips", buyInTChips, _checker, __FILE__, __LINE__);
	INT64 buyInPM; _jparser.validateByNameThrow("buyInPM", buyInPM);
	AtfValidator::validateInt(_descr, "buyInPM", buyInPM, _checker, __FILE__, __LINE__);
	bool useTicket; _jparser.validateByNameThrow("useTicket", useTicket);
	AtfValidator::validateInt(_descr, "useTicket", useTicket, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody currencyContext; _jparser.validateByNameThrow("currencyContext", currencyContext);
	AtfValidator::validateInt(_descr, "currencyContext", currencyContext._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT32 seqId; _parser.parseUINT32(seqId);
	AtfValidator::validateInt(_descr, "seqId", seqId, _checker, __FILE__, __LINE__);
	UINT32 buyInTierId; _parser.parseUINT32(buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	INT64 buyInRM; _parser.parseINT64(buyInRM);
	AtfValidator::validateInt(_descr, "buyInRM", buyInRM, _checker, __FILE__, __LINE__);
	INT64 buyInTChips; _parser.parseINT64(buyInTChips);
	AtfValidator::validateInt(_descr, "buyInTChips", buyInTChips, _checker, __FILE__, __LINE__);
	INT64 buyInPM; _parser.parseINT64(buyInPM);
	AtfValidator::validateInt(_descr, "buyInPM", buyInPM, _checker, __FILE__, __LINE__);
	bool useTicket; _parser.parseBOOL(useTicket);
	AtfValidator::validateInt(_descr, "useTicket", useTicket, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_REGISTER_USER_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::Protocol_MSG_PPP_REGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::Protocol_MSG_PPP_REGISTER_USER_REPLY(Protocol_MSG_PPP_REGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, pppEntryId(std::move(_o.pppEntryId))
{
}

PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY& PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::operator=(Protocol_MSG_PPP_REGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		pppEntryId = std::move(_o.pppEntryId);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	pppEntryId = 0;
}

bool PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::equals(const Protocol_MSG_PPP_REGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		pppEntryId == _o.pppEntryId;
}

bool PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_REGISTER_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_REGISTER_USER_REPLY*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_REGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("pppEntryId=");
		_buf.appendUint64(pppEntryId);
	}
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_REGISTER_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("pppEntryId", pppEntryId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("pppEntryId"))
			{
				pppEntryId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT64(pppEntryId);
	}
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT64(pppEntryId);
	}
}

const char *PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("pppEntryId", pppEntryId);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("pppEntryId", pppEntryId);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 pppEntryId; _jparser.validateByNameThrow("pppEntryId", pppEntryId);
		AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_REGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_REGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 pppEntryId; _parser.parseUINT64(pppEntryId);
		AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_UNREGISTER_USER
//=================================================================

PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::Protocol_MSG_PPP_UNREGISTER_USER()
{
	clear();
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::clear()
{
	pppId = 0;
	pppEntryId = 0;
}

bool PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::equals(const Protocol_MSG_PPP_UNREGISTER_USER& _o) const
{
	return pppId == _o.pppId &&
		pppEntryId == _o.pppEntryId;
}

bool PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_UNREGISTER_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_UNREGISTER_USER*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_UNREGISTER_USER).append(")");
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("pppEntryId=");
	_buf.appendUint64(pppEntryId);
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_UNREGISTER_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pppId", pppId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pppEntryId", pppEntryId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pppId"))
			{
				pppId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pppEntryId"))
			{
				pppEntryId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(pppId);
	_msg.composeUINT64(pppEntryId);
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(pppId);
	_parser.parseUINT64(pppEntryId);
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pppId", pppId);
	_jsonstr.compose("pppEntryId", pppEntryId);
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pppId", pppId);
	_jparser.parseByNameThrow("pppEntryId", pppEntryId);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_UNREGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 pppId; _jparser.validateByNameThrow("pppId", pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT64 pppEntryId; _jparser.validateByNameThrow("pppEntryId", pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_UNREGISTER_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT64 pppEntryId; _parser.parseUINT64(pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_UNREGISTER_USER_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::Protocol_MSG_PPP_UNREGISTER_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::Protocol_MSG_PPP_UNREGISTER_USER_REPLY(Protocol_MSG_PPP_UNREGISTER_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, refund(std::move(_o.refund))
	, refundPlay(std::move(_o.refundPlay))
	, refundTChips(std::move(_o.refundTChips))
	, tournamentCurrency(std::move(_o.tournamentCurrency))
	, refundCurrency(std::move(_o.refundCurrency))
{
}

PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY& PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::operator=(Protocol_MSG_PPP_UNREGISTER_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		refund = std::move(_o.refund);
		refundPlay = std::move(_o.refundPlay);
		refundTChips = std::move(_o.refundTChips);
		tournamentCurrency = std::move(_o.tournamentCurrency);
		refundCurrency = std::move(_o.refundCurrency);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	refund = 0;
	refundPlay = 0;
	refundTChips = 0;
	tournamentCurrency.clear();
	refundCurrency.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::equals(const Protocol_MSG_PPP_UNREGISTER_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescr.equals(_o.errDescr) &&
		refund == _o.refund &&
		refundPlay == _o.refundPlay &&
		refundTChips == _o.refundTChips &&
		tournamentCurrency.equals(_o.tournamentCurrency) &&
		refundCurrency.equals(_o.refundCurrency);
}

bool PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_UNREGISTER_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_UNREGISTER_USER_REPLY*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_UNREGISTER_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("refund=");
		_buf.appendInt(refund);
		_buf.append(',');
		_buf.append("refundPlay=");
		_buf.appendInt64(refundPlay);
		_buf.append(',');
		_buf.append("refundTChips=");
		_buf.appendInt(refundTChips);
		_buf.append(',');
		_buf.append("tournamentCurrency=");
		_buf.append(tournamentCurrency);
		_buf.append(',');
		_buf.append("refundCurrency=");
		_buf.append(refundCurrency);
	}
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_UNREGISTER_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("refund", refund, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundPlay", refundPlay, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundTChips", refundTChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournamentCurrency", tournamentCurrency, _buf);
		Atf::XmlElement::encodeAsXmlElement("refundCurrency", refundCurrency, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("refund"))
			{
				refund = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundPlay"))
			{
				refundPlay = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("refundTChips"))
			{
				refundTChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournamentCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournamentCurrency)) return false;
			}
			else if (_element.equals("refundCurrency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, refundCurrency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(refund);
		_msg.composeINT64(refundPlay);
		_msg.composeINT32(refundTChips);
		_msg.composeString(tournamentCurrency);
		_msg.composeString(refundCurrency);
	}
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(refund);
		_parser.parseINT64(refundPlay);
		_parser.parseINT32(refundTChips);
		_parser.parseStringP(tournamentCurrency);
		_parser.parseStringP(refundCurrency);
	}
}

const char *PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("refund", refund);
		_jsonstr.compose("refundPlay", refundPlay);
		_jsonstr.compose("refundTChips", refundTChips);
		_jsonstr.compose("tournamentCurrency", tournamentCurrency);
		_jsonstr.compose("refundCurrency", refundCurrency);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("refund", refund);
		_jparser.parseByNameThrow("refundPlay", refundPlay);
		_jparser.parseByNameThrow("refundTChips", refundTChips);
		_jparser.parseByNameThrow("tournamentCurrency", tournamentCurrency);
		_jparser.parseByNameThrow("refundCurrency", refundCurrency);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_UNREGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 refund; _jparser.validateByNameThrow("refund", refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
		INT64 refundPlay; _jparser.validateByNameThrow("refundPlay", refundPlay);
		AtfValidator::validateInt(_descr, "refundPlay", refundPlay, _checker, __FILE__, __LINE__);
		INT32 refundTChips; _jparser.validateByNameThrow("refundTChips", refundTChips);
		AtfValidator::validateInt(_descr, "refundTChips", refundTChips, _checker, __FILE__, __LINE__);
		PString tournamentCurrency; _jparser.validateByNameThrow("tournamentCurrency", tournamentCurrency);
		AtfValidator::validateInt(_descr, "tournamentCurrency", tournamentCurrency.length(), _checker, __FILE__, __LINE__);
		PString refundCurrency; _jparser.validateByNameThrow("refundCurrency", refundCurrency);
		AtfValidator::validateInt(_descr, "refundCurrency", refundCurrency.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_UNREGISTER_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 refund; _parser.parseINT32(refund);
		AtfValidator::validateInt(_descr, "refund", refund, _checker, __FILE__, __LINE__);
		INT64 refundPlay; _parser.parseINT64(refundPlay);
		AtfValidator::validateInt(_descr, "refundPlay", refundPlay, _checker, __FILE__, __LINE__);
		INT32 refundTChips; _parser.parseINT32(refundTChips);
		AtfValidator::validateInt(_descr, "refundTChips", refundTChips, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournamentCurrency"); size_t szTournamentCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournamentCurrency", szTournamentCurrency, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "refundCurrency"); size_t szRefundCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "refundCurrency", szRefundCurrency, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PppEntry
//=================================================================

PPPClient::client::PppEntry::PppEntry()
{
	clear();
}

void PPPClient::client::PppEntry::clear()
{
	pppId = 0;
	pppEntryId = 0;
	status = 0;
	amountOnHead = 0;
	canUnregister = false;
	tournId = 0;
	buyInTierId = 0;
}

bool PPPClient::client::PppEntry::equals(const PppEntry& _o) const
{
	return pppId == _o.pppId &&
		pppEntryId == _o.pppEntryId &&
		status == _o.status &&
		amountOnHead == _o.amountOnHead &&
		canUnregister == _o.canUnregister &&
		tournId == _o.tournId &&
		buyInTierId == _o.buyInTierId;
}

const char *PPPClient::client::PppEntry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("pppEntryId=");
	_buf.appendUint64(pppEntryId);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("amountOnHead=");
	_buf.appendInt64(amountOnHead);
	_buf.append(',');
	_buf.append("canUnregister=");
	_buf.appendUint(canUnregister);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append(',');
	_buf.append("buyInTierId=");
	_buf.appendUint(buyInTierId);
	_buf.append('}');
	return _buf.c_str();
}

const char *PPPClient::client::PppEntry::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("pppId", pppId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pppEntryId", pppEntryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountOnHead", amountOnHead, _buf);
	Atf::XmlElement::encodeAsXmlElement("canUnregister", canUnregister, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyInTierId", buyInTierId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool PPPClient::client::PppEntry::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("pppId"))
		{
			pppId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("pppEntryId"))
		{
			pppEntryId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amountOnHead"))
		{
			amountOnHead = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("canUnregister"))
		{
			canUnregister = (*_value.ptr() == '1');
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyInTierId"))
		{
			buyInTierId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void PPPClient::client::PppEntry::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PppEntry())) // not empty
	{
		_body.composeUINT32(pppId);
		_body.composeUINT64(pppEntryId);
		_body.composeINT16(status);
		_body.composeINT64(amountOnHead);
		_body.composeBOOL(canUnregister);
		_body.composeUINT64(tournId);
		_body.composeUINT32(buyInTierId);
	}

	_msg.composeMsgBody(_body);
}

void PPPClient::client::PppEntry::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(pppId);
	_parser0.parseUINT64(pppEntryId);
	_parser0.parseINT16(status);
	_parser0.parseINT64(amountOnHead);
	_parser0.parseBOOL(canUnregister);
	_parser0.parseUINT64(tournId);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(buyInTierId);
}

void PPPClient::client::PppEntry::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("pppId", pppId);
	_parser0.parse("pppEntryId", pppEntryId);
	_parser0.parse("status", status);
	_parser0.parse("amountOnHead", amountOnHead);
	_parser0.parse("canUnregister", canUnregister);
	_parser0.parse("tournId", tournId);
	if(_parser0.parseEnded()) return;
	_parser0.parse("buyInTierId", buyInTierId);
}

const char *PPPClient::client::PppEntry::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pppId", pppId);
	_jsonstr.compose("pppEntryId", pppEntryId);
	_jsonstr.compose("status", status);
	_jsonstr.compose("amountOnHead", amountOnHead);
	_jsonstr.compose("canUnregister", canUnregister);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("buyInTierId", buyInTierId);
	return _buf.c_str();
}

void PPPClient::client::PppEntry::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pppId", pppId);
	_jparser.parseByNameThrow("pppEntryId", pppEntryId);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("amountOnHead", amountOnHead);
	_jparser.parseByNameThrow("canUnregister", canUnregister);
	_jparser.parseByNameThrow("tournId", tournId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("buyInTierId", buyInTierId);
}

/* static */ void PPPClient::client::PppEntry::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 pppId; _jparser.validateByNameThrow("pppId", pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT64 pppEntryId; _jparser.validateByNameThrow("pppEntryId", pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	INT16 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	INT64 amountOnHead; _jparser.validateByNameThrow("amountOnHead", amountOnHead);
	AtfValidator::validateInt(_descr, "amountOnHead", amountOnHead, _checker, __FILE__, __LINE__);
	bool canUnregister; _jparser.validateByNameThrow("canUnregister", canUnregister);
	AtfValidator::validateInt(_descr, "canUnregister", canUnregister, _checker, __FILE__, __LINE__);
	UINT64 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 buyInTierId; _jparser.validateByNameThrow("buyInTierId", buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::client::PppEntry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 pppId; _parser0.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT64 pppEntryId; _parser0.parseUINT64(pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	INT16 status; _parser0.parseINT16(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	INT64 amountOnHead; _parser0.parseINT64(amountOnHead);
	AtfValidator::validateInt(_descr, "amountOnHead", amountOnHead, _checker, __FILE__, __LINE__);
	bool canUnregister; _parser0.parseBOOL(canUnregister);
	AtfValidator::validateInt(_descr, "canUnregister", canUnregister, _checker, __FILE__, __LINE__);
	UINT64 tournId; _parser0.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT32 buyInTierId; _parser0.parseUINT32(buyInTierId);
	AtfValidator::validateInt(_descr, "buyInTierId", buyInTierId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_PPP_GET_ENTRIES
//=================================================================

PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::Protocol_MSG_PPP_GET_ENTRIES()
{
	clear();
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::clear()
{
}

bool PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::equals(const Protocol_MSG_PPP_GET_ENTRIES& _o) const
{
	return true;
}

bool PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_GET_ENTRIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_GET_ENTRIES*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_GET_ENTRIES).append(")");
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_GET_ENTRIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::parseMsg(CommMsgParser& _parser)
{
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_GET_ENTRIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_GET_ENTRIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_GET_ENTRIES_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::Protocol_MSG_PPP_GET_ENTRIES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::Protocol_MSG_PPP_GET_ENTRIES_REPLY(Protocol_MSG_PPP_GET_ENTRIES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
	, entries(std::move(_o.entries))
{
}

PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY& PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::operator=(Protocol_MSG_PPP_GET_ENTRIES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
		entries = std::move(_o.entries);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
	entries.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::equals(const Protocol_MSG_PPP_GET_ENTRIES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg) &&
		entries.equals(_o.entries);
}

bool PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_GET_ENTRIES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_GET_ENTRIES_REPLY*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_GET_ENTRIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	else
	{
		_buf.append(',');
		_buf.append("entries=");
		entries.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_GET_ENTRIES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	else
	{
		entries.toXmlString("entries", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else if (_element.equals("entries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PppEntry, 4 > >::FromXmlString(_value, entries)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errMsg);
	}
	else
	{
		entries.composeMsg(_msg, _ignoreJSON);
	}
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errMsg);
	}
	else
	{
		entries.parseMsg(_parser);
	}
}

const char *PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	else
	{
		_jsonstr.compose("entries", entries);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
	else
	{
		_jparser.parseByNameThrow("entries", entries);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_GET_ENTRIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< PppEntry > entries; _jparser.validateByNameThrow("entries", entries);
		AtfValidator::validateInt(_descr, "entries", entries.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_GET_ENTRIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szEntries = Atf::LAtfVector< PppEntry, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("entries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "entries", szEntries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_SET_ENTRY_STATUS
//=================================================================

PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::Protocol_MSG_PPP_SET_ENTRY_STATUS()
{
	clear();
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::clear()
{
	pppId = 0;
	pppEntryId = 0;
	newStatus = 0;
}

bool PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::equals(const Protocol_MSG_PPP_SET_ENTRY_STATUS& _o) const
{
	return pppId == _o.pppId &&
		pppEntryId == _o.pppEntryId &&
		newStatus == _o.newStatus;
}

bool PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_SET_ENTRY_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_SET_ENTRY_STATUS*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_SET_ENTRY_STATUS).append(")");
	_buf.append(',');
	_buf.append("pppId=");
	_buf.appendUint(pppId);
	_buf.append(',');
	_buf.append("pppEntryId=");
	_buf.appendUint64(pppEntryId);
	_buf.append(',');
	_buf.append("newStatus=");
	_buf.appendInt(newStatus);
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_SET_ENTRY_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pppId", pppId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pppEntryId", pppEntryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("newStatus", newStatus, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pppId"))
			{
				pppId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("pppEntryId"))
			{
				pppEntryId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("newStatus"))
			{
				newStatus = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(pppId);
	_msg.composeUINT64(pppEntryId);
	_msg.composeINT16(newStatus);
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(pppId);
	_parser.parseUINT64(pppEntryId);
	_parser.parseINT16(newStatus);
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pppId", pppId);
	_jsonstr.compose("pppEntryId", pppEntryId);
	_jsonstr.compose("newStatus", newStatus);
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pppId", pppId);
	_jparser.parseByNameThrow("pppEntryId", pppEntryId);
	_jparser.parseByNameThrow("newStatus", newStatus);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_SET_ENTRY_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 pppId; _jparser.validateByNameThrow("pppId", pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT64 pppEntryId; _jparser.validateByNameThrow("pppEntryId", pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	INT16 newStatus; _jparser.validateByNameThrow("newStatus", newStatus);
	AtfValidator::validateInt(_descr, "newStatus", newStatus, _checker, __FILE__, __LINE__);
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_SET_ENTRY_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 pppId; _parser.parseUINT32(pppId);
	AtfValidator::validateInt(_descr, "pppId", pppId, _checker, __FILE__, __LINE__);
	UINT64 pppEntryId; _parser.parseUINT64(pppEntryId);
	AtfValidator::validateUint(_descr, "pppEntryId", pppEntryId, _checker, __FILE__, __LINE__);
	INT16 newStatus; _parser.parseINT16(newStatus);
	AtfValidator::validateInt(_descr, "newStatus", newStatus, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY
//=================================================================

PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY(Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errMsg(std::move(_o.errMsg))
{
}

PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY& PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::operator=(Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errMsg = std::move(_o.errMsg);
	}
	return *this;
}

#endif

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::clear()
{
	errCode = 0;
	errMsg.clear();
}

bool PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::equals(const Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errMsg.equals(_o.errMsg);
}

bool PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_PPP_SET_ENTRY_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY*)_other));
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_PPP_SET_ENTRY_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errMsg=");
		_buf.append(errMsg);
	}
	return _buf.c_str();
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_PPP_SET_ENTRY_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errMsg", errMsg, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errMsg"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errMsg);
	}
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errMsg);
	}
}

const char *PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errMsg", errMsg);
	}
	return _buf.c_str();
}

void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errMsg", errMsg);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_SET_ENTRY_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errMsg; _jparser.validateByNameThrow("errMsg", errMsg);
		AtfValidator::validateInt(_descr, "errMsg", errMsg.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void PPPClient::client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_PPP_SET_ENTRY_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errMsg"); size_t szErrMsg = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errMsg", szErrMsg, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* PPPClient::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "client"))
	{
		switch(_msgId)
		{
			case MSG_PPP_GET_ENTRIES: _obj = new client::Protocol_MSG_PPP_GET_ENTRIES(); break;
			case MSG_PPP_GET_ENTRIES_REPLY: _obj = new client::Protocol_MSG_PPP_GET_ENTRIES_REPLY(); break;
			case MSG_PPP_REGISTER_USER: _obj = new client::Protocol_MSG_PPP_REGISTER_USER(); break;
			case MSG_PPP_REGISTER_USER_REPLY: _obj = new client::Protocol_MSG_PPP_REGISTER_USER_REPLY(); break;
			case MSG_PPP_REG_INFO: _obj = new client::Protocol_MSG_PPP_REG_INFO(); break;
			case MSG_PPP_REG_INFO_REPLY: _obj = new client::Protocol_MSG_PPP_REG_INFO_REPLY(); break;
			case MSG_PPP_SET_ENTRY_STATUS: _obj = new client::Protocol_MSG_PPP_SET_ENTRY_STATUS(); break;
			case MSG_PPP_SET_ENTRY_STATUS_REPLY: _obj = new client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY(); break;
			case MSG_PPP_UNREGISTER_USER: _obj = new client::Protocol_MSG_PPP_UNREGISTER_USER(); break;
			case MSG_PPP_UNREGISTER_USER_REPLY: _obj = new client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool PPPClient::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "client"))
	{
		switch(_msgId)
		{
			case MSG_PPP_GET_ENTRIES: client::Protocol_MSG_PPP_GET_ENTRIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_GET_ENTRIES_REPLY: client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REGISTER_USER: client::Protocol_MSG_PPP_REGISTER_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REGISTER_USER_REPLY: client::Protocol_MSG_PPP_REGISTER_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REG_INFO: client::Protocol_MSG_PPP_REG_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REG_INFO_REPLY: client::Protocol_MSG_PPP_REG_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_SET_ENTRY_STATUS: client::Protocol_MSG_PPP_SET_ENTRY_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_SET_ENTRY_STATUS_REPLY: client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_UNREGISTER_USER: client::Protocol_MSG_PPP_UNREGISTER_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_UNREGISTER_USER_REPLY: client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool PPPClient::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "client"))
	{
		switch(_msgId)
		{
			case MSG_PPP_GET_ENTRIES: client::Protocol_MSG_PPP_GET_ENTRIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_GET_ENTRIES_REPLY: client::Protocol_MSG_PPP_GET_ENTRIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REGISTER_USER: client::Protocol_MSG_PPP_REGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REGISTER_USER_REPLY: client::Protocol_MSG_PPP_REGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REG_INFO: client::Protocol_MSG_PPP_REG_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_REG_INFO_REPLY: client::Protocol_MSG_PPP_REG_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_SET_ENTRY_STATUS: client::Protocol_MSG_PPP_SET_ENTRY_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_SET_ENTRY_STATUS_REPLY: client::Protocol_MSG_PPP_SET_ENTRY_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_UNREGISTER_USER: client::Protocol_MSG_PPP_UNREGISTER_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_PPP_UNREGISTER_USER_REPLY: client::Protocol_MSG_PPP_UNREGISTER_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

