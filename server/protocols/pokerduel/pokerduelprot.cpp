/**
 * pokerduelprot.cpp
 *
 * This file was auto-generated from pokerduelprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 */
 
#include "pokerduelprot.h"

//=================================================================
//                    P_I18NLangStringPair
//=================================================================

pokerduel::P_I18NLangStringPair::P_I18NLangStringPair()
{
	clear();
}

void pokerduel::P_I18NLangStringPair::clear()
{
	locale = 0;
	msg.clear();
}

bool pokerduel::P_I18NLangStringPair::equals(const P_I18NLangStringPair& _o) const
{
	return locale == _o.locale &&
		msg.equals(_o.msg);
}

const char *pokerduel::P_I18NLangStringPair::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("msg=");
	_buf.append(msg);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::P_I18NLangStringPair::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("msg", msg, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::P_I18NLangStringPair::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("msg"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, msg)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::P_I18NLangStringPair::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(locale);
	_msg.composeString(msg);
}

void pokerduel::P_I18NLangStringPair::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
	_parser.parseStringPN(msg, 0, "msg");
}

void pokerduel::P_I18NLangStringPair::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("locale", locale);
	_parser.parse("msg", msg);
}

const char *pokerduel::P_I18NLangStringPair::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("msg", msg);
	return _buf.c_str();
}

void pokerduel::P_I18NLangStringPair::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("msg", msg);
}

void pokerduel::P_I18NLangStringPair::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("locale", locale);
	_jparser.validateByNameThrow("msg", msg);
}

/*static*/ void pokerduel::P_I18NLangStringPair::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*locale*/
	_parser.parseStringN(_dummy, 0, "msg");  /*msg*/
}

//=================================================================
//                    P_I18nPString
//=================================================================

// @Override
UINT32 pokerduel::P_I18nPString::size() const
{
	return v.size();
}

// @Override
const char* pokerduel::P_I18nPString::getPString(UINT32 locale) const
{
	for(vector<P_I18NLangStringPair>::const_iterator cit = v.begin(); cit != v.end(); ++cit)
	{
		if(cit->locale == locale)
		{
			return cit->msg;
		}
	}

	if(locale != LOCALE_DEFAULT)
	{
		return getPString(LOCALE_DEFAULT);
	}
	else
	{
		return "";
	}
}

// @Override
void pokerduel::P_I18nPString::appendPString(const char* msg, UINT32 locale)
{
	for(vector<P_I18NLangStringPair>::iterator it = v.begin(); it != v.end(); ++it)
	{
		if(it->locale == locale)
		{
			it->msg.append(msg);
			return;
		}
	}

	P_I18NLangStringPair p;
	p.locale = locale;
	p.msg = msg;
	v.push_back(p);
}

pokerduel::P_I18nPString::P_I18nPString()
{
	clear();
}

void pokerduel::P_I18nPString::clear()
{
	v.clear();
}

bool pokerduel::P_I18nPString::equals(const P_I18nPString& _o) const
{
	return v.equals(_o.v);
}

const char *pokerduel::P_I18nPString::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("v=");
	v.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::P_I18nPString::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	v.toXmlString("v", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::P_I18nPString::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("v"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< P_I18NLangStringPair, 4 > >::FromXmlString(_value, v)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::P_I18nPString::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	v.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::P_I18nPString::parseMsg(CommMsgParser& _parser)
{
	v.parseMsg(_parser);
}

void pokerduel::P_I18nPString::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("v", v);
}

const char *pokerduel::P_I18nPString::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("v", v);
	return _buf.c_str();
}

void pokerduel::P_I18nPString::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("v", v);
}

void pokerduel::P_I18nPString::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("v", v);
}

/*static*/ void pokerduel::P_I18nPString::validateMsg(CommMsgParser& _parser)
{
	Atf::LAtfVector< P_I18NLangStringPair, 4 >::validateMsg(_parser);  /*v*/
}

//=================================================================
//                    XINT64
//=================================================================

// @Override
const char *pokerduel::XINT64::toTraceString(PString& _buf) const
{
	return _buf.append("0x").appendHexInt64(value);
}

// @Override
const char *pokerduel::XINT64::toJSONString(PString& _buf) const
{
	return _buf.append("\"0x").appendHexInt64(value).append('\"');
}

// @Override
void pokerduel::XINT64::fromJSONString(const PString& _jsonString)
{
	if(_jsonString.startsWith("0x") || _jsonString.startsWith("0X"))
	{
		value = p_atohex64(_jsonString.c_str() + 2);
	}
	else
	{
		value = p_atohex64(_jsonString);
	}
}

// @Override
pokerduel::XINT64::operator INT64() const
{
	return value;
}

// @Override
pokerduel::XINT64::operator UINT64() const
{
	return (UINT64)value;
}

// @Override
pokerduel::XINT64& pokerduel::XINT64::operator=(INT64 v)
{
	value = v;
	return *this;
}

// @Override
pokerduel::XINT64& pokerduel::XINT64::operator=(UINT64 v)
{
	value = (INT64)v;
	return *this;
}

pokerduel::XINT64::XINT64()
{
	clear();
}

void pokerduel::XINT64::clear()
{
	value = 0;
}

bool pokerduel::XINT64::equals(const XINT64& _o) const
{
	return value == _o.value;
}

const char *pokerduel::XINT64::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::XINT64::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("value"))
		{
			value = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::XINT64::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(value);
}

void pokerduel::XINT64::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(value);
}

void pokerduel::XINT64::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("value", value);
}

void pokerduel::XINT64::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("value", value);
}

/*static*/ void pokerduel::XINT64::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*value*/
}

//=================================================================
//                    DuelTypeProperty
//=================================================================

pokerduel::DuelTypeProperty::DuelTypeProperty()
{
	clear();
}

void pokerduel::DuelTypeProperty::clear()
{
	id = 0;
	value.clear();
}

bool pokerduel::DuelTypeProperty::equals(const DuelTypeProperty& _o) const
{
	return id == _o.id &&
		value.equals(_o.value);
}

const char *pokerduel::DuelTypeProperty::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("id=");
	_buf.appendInt(id);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::DuelTypeProperty::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::DuelTypeProperty::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("id"))
		{
			id = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("value"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, value)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::DuelTypeProperty::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(id);
	_msg.composeString(value);
}

void pokerduel::DuelTypeProperty::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(id);
	_parser.parseStringPN(value, 0, "value");
}

void pokerduel::DuelTypeProperty::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("id", id);
	_parser.parse("value", value);
}

const char *pokerduel::DuelTypeProperty::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("id", id);
	_jsonstr.compose("value", value);
	return _buf.c_str();
}

void pokerduel::DuelTypeProperty::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("value", value);
}

void pokerduel::DuelTypeProperty::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("id", id);
	_jparser.validateByNameThrow("value", value);
}

/*static*/ void pokerduel::DuelTypeProperty::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*id*/
	_parser.parseStringN(_dummy, 0, "value");  /*value*/
}

//=================================================================
//                    DuelType
//=================================================================

pokerduel::DuelType::DuelType()
{
	clear();
}

void pokerduel::DuelType::clear()
{
	duelTypeId = 0;
	name.clear();
	siteMask = 0;
	status = 0;
	matchType = 0;
	numHands = 0;
	smallBlind = 0;
	bigBlind = 0;
	startingChips = 0;
	timeToAct_Deprecated = 0;
	timerBank = 0;
	buyIn = 0;
	rake = 0;
	isPlayMoney = false;
	currency.clear();
	game = 0;
	structure = 0;
	speedDisplay = 0;
	tournFlags = 0;
	admissions.clear();
	destroyDelay_Deprecated = 0;
	properties.clear();
	fromDate.setNull();
	toDate.setNull();
	timeBankIncrement = 0;
	timeoutTimeBankIncrement = 0;
	randomMatchTimeout = 0;
	pendingChallengeTimeout = 0;
}

bool pokerduel::DuelType::equals(const DuelType& _o) const
{
	return duelTypeId == _o.duelTypeId &&
		name.equals(_o.name) &&
		siteMask == _o.siteMask &&
		status == _o.status &&
		matchType == _o.matchType &&
		numHands == _o.numHands &&
		smallBlind == _o.smallBlind &&
		bigBlind == _o.bigBlind &&
		startingChips == _o.startingChips &&
		timeToAct_Deprecated == _o.timeToAct_Deprecated &&
		timerBank == _o.timerBank &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		game == _o.game &&
		structure == _o.structure &&
		speedDisplay == _o.speedDisplay &&
		tournFlags == _o.tournFlags &&
		admissions.equals(_o.admissions) &&
		destroyDelay_Deprecated == _o.destroyDelay_Deprecated &&
		properties.equals(_o.properties) &&
		fromDate.equals(_o.fromDate) &&
		toDate.equals(_o.toDate) &&
		timeBankIncrement == _o.timeBankIncrement &&
		timeoutTimeBankIncrement == _o.timeoutTimeBankIncrement &&
		randomMatchTimeout == _o.randomMatchTimeout &&
		pendingChallengeTimeout == _o.pendingChallengeTimeout;
}

const char *pokerduel::DuelType::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("name=");
	name.toTraceString(_buf);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("matchType=");
	_buf.appendInt(matchType);
	_buf.append(',');
	_buf.append("numHands=");
	_buf.appendInt(numHands);
	_buf.append(',');
	_buf.append("smallBlind=");
	_buf.appendInt(smallBlind);
	_buf.append(',');
	_buf.append("bigBlind=");
	_buf.appendInt(bigBlind);
	_buf.append(',');
	_buf.append("startingChips=");
	_buf.appendInt(startingChips);
	_buf.append(',');
	_buf.append("timeToAct_Deprecated=");
	_buf.appendInt(timeToAct_Deprecated);
	_buf.append(',');
	_buf.append("timerBank=");
	_buf.appendInt(timerBank);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt64(rake);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("speedDisplay=");
	_buf.appendUint(speedDisplay);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("destroyDelay_Deprecated=");
	_buf.appendInt(destroyDelay_Deprecated);
	_buf.append(',');
	_buf.append("properties=");
	properties.toTraceString(_buf);
	_buf.append(',');
	_buf.append("fromDate=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, fromDate);
	_buf.append(',');
	_buf.append("toDate=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, toDate);
	_buf.append(',');
	_buf.append("timeBankIncrement=");
	_buf.appendInt(timeBankIncrement);
	_buf.append(',');
	_buf.append("timeoutTimeBankIncrement=");
	_buf.appendInt(timeoutTimeBankIncrement);
	_buf.append(',');
	_buf.append("randomMatchTimeout=");
	_buf.appendInt(randomMatchTimeout);
	_buf.append(',');
	_buf.append("pendingChallengeTimeout=");
	_buf.appendInt(pendingChallengeTimeout);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::DuelType::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	name.toXmlString("name", _buf);
	Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("matchType", matchType, _buf);
	Atf::XmlElement::encodeAsXmlElement("numHands", numHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("smallBlind", smallBlind, _buf);
	Atf::XmlElement::encodeAsXmlElement("bigBlind", bigBlind, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingChips", startingChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeToAct_Deprecated", timeToAct_Deprecated, _buf);
	Atf::XmlElement::encodeAsXmlElement("timerBank", timerBank, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
	Atf::XmlElement::encodeAsXmlElement("structure", structure, _buf);
	Atf::XmlElement::encodeAsXmlElement("speedDisplay", speedDisplay, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	admissions.toXmlString("admissions", _buf);
	Atf::XmlElement::encodeAsXmlElement("destroyDelay_Deprecated", destroyDelay_Deprecated, _buf);
	properties.toXmlString("properties", _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "fromDate", fromDate);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "toDate", toDate);
	Atf::XmlElement::encodeAsXmlElement("timeBankIncrement", timeBankIncrement, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeoutTimeBankIncrement", timeoutTimeBankIncrement, _buf);
	Atf::XmlElement::encodeAsXmlElement("randomMatchTimeout", randomMatchTimeout, _buf);
	Atf::XmlElement::encodeAsXmlElement("pendingChallengeTimeout", pendingChallengeTimeout, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::DuelType::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("name"))
		{
			if(!Atf::AtfTempl< P_I18nPString >::FromXmlString(_value, name)) return false;
		}
		else if (_element.equals("siteMask"))
		{
			siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("matchType"))
		{
			matchType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numHands"))
		{
			numHands = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("smallBlind"))
		{
			smallBlind = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bigBlind"))
		{
			bigBlind = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startingChips"))
		{
			startingChips = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timeToAct_Deprecated"))
		{
			timeToAct_Deprecated = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timerBank"))
		{
			timerBank = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("game"))
		{
			game = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("structure"))
		{
			structure = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("speedDisplay"))
		{
			speedDisplay = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournFlags"))
		{
			tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admissions"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, admissions)) return false;
		}
		else if (_element.equals("destroyDelay_Deprecated"))
		{
			destroyDelay_Deprecated = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("properties"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< DuelTypeProperty , 4 > >::FromXmlString(_value, properties)) return false;
		}
		else if (_element.equals("fromDate"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, fromDate);
		}
		else if (_element.equals("toDate"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, toDate);
		}
		else if (_element.equals("timeBankIncrement"))
		{
			timeBankIncrement = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timeoutTimeBankIncrement"))
		{
			timeoutTimeBankIncrement = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("randomMatchTimeout"))
		{
			randomMatchTimeout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("pendingChallengeTimeout"))
		{
			pendingChallengeTimeout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::DuelType::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(DuelType())) // not empty
	{
		_body.composeUINT32(duelTypeId);
		name.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(siteMask);
		_body.composeBYTE(status);
		_body.composeINT32(matchType);
		_body.composeINT32(numHands);
		_body.composeINT32(smallBlind);
		_body.composeINT32(bigBlind);
		_body.composeINT32(startingChips);
		_body.composeINT32(timeToAct_Deprecated);
		_body.composeINT32(timerBank);
		_body.composeINT64(buyIn);
		_body.composeINT64(rake);
		_body.composeBOOL(isPlayMoney);
		_body.composeString(currency);
		_body.composeBYTE(game);
		_body.composeBYTE(structure);
		_body.composeBYTE(speedDisplay);
		_body.composeUINT32(tournFlags);
		admissions.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(destroyDelay_Deprecated);
		properties.composeMsg(_body, _ignoreJSON);
		_body.composeSrvTime(fromDate);
		_body.composeSrvTime(toDate);
		_body.composeINT32(timeBankIncrement);
		_body.composeINT32(timeoutTimeBankIncrement);
		_body.composeINT32(randomMatchTimeout);
		_body.composeINT32(pendingChallengeTimeout);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::DuelType::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(duelTypeId);
	name.parseMsg(_parser0);
	_parser0.parseUINT32(siteMask);
	_parser0.parseBYTE(status);
	_parser0.parseINT32(matchType);
	_parser0.parseINT32(numHands);
	_parser0.parseINT32(smallBlind);
	_parser0.parseINT32(bigBlind);
	_parser0.parseINT32(startingChips);
	_parser0.parseINT32(timeToAct_Deprecated);
	_parser0.parseINT32(timerBank);
	_parser0.parseINT64(buyIn);
	_parser0.parseINT64(rake);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseStringPN(currency, 0, "currency");
	_parser0.parseBYTE(game);
	_parser0.parseBYTE(structure);
	_parser0.parseBYTE(speedDisplay);
	_parser0.parseUINT32(tournFlags);
	admissions.parseMsg(_parser0);
	_parser0.parseINT32(destroyDelay_Deprecated);
	properties.parseMsg(_parser0);
	_parser0.parseSrvTime(fromDate);
	_parser0.parseSrvTime(toDate);
	_parser0.parseINT32(timeBankIncrement);
	_parser0.parseINT32(timeoutTimeBankIncrement);
	_parser0.parseINT32(randomMatchTimeout);
	_parser0.parseINT32(pendingChallengeTimeout);
}

void pokerduel::DuelType::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("name", name);
	_parser0.parse("siteMask", siteMask);
	_parser0.parse("status", status);
	_parser0.parse("matchType", matchType);
	_parser0.parse("numHands", numHands);
	_parser0.parse("smallBlind", smallBlind);
	_parser0.parse("bigBlind", bigBlind);
	_parser0.parse("startingChips", startingChips);
	_parser0.parse("timeToAct_Deprecated", timeToAct_Deprecated);
	_parser0.parse("timerBank", timerBank);
	_parser0.parse("buyIn", buyIn);
	_parser0.parse("rake", rake);
	_parser0.parse("isPlayMoney", isPlayMoney);
	_parser0.parse("currency", currency);
	_parser0.parse("game", game);
	_parser0.parse("structure", structure);
	_parser0.parse("speedDisplay", speedDisplay);
	_parser0.parse("tournFlags", tournFlags);
	_parser0.parse("admissions", admissions);
	_parser0.parse("destroyDelay_Deprecated", destroyDelay_Deprecated);
	_parser0.parse("properties", properties);
	_parser0.parse("fromDate", fromDate);
	_parser0.parse("toDate", toDate);
	_parser0.parse("timeBankIncrement", timeBankIncrement);
	_parser0.parse("timeoutTimeBankIncrement", timeoutTimeBankIncrement);
	_parser0.parse("randomMatchTimeout", randomMatchTimeout);
	_parser0.parse("pendingChallengeTimeout", pendingChallengeTimeout);
}

const char *pokerduel::DuelType::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("name", name);
	_jsonstr.compose("siteMask", siteMask);
	_jsonstr.compose("status", status);
	_jsonstr.compose("matchType", matchType);
	_jsonstr.compose("numHands", numHands);
	_jsonstr.compose("smallBlind", smallBlind);
	_jsonstr.compose("bigBlind", bigBlind);
	_jsonstr.compose("startingChips", startingChips);
	_jsonstr.compose("timeToAct_Deprecated", timeToAct_Deprecated);
	_jsonstr.compose("timerBank", timerBank);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("game", game);
	_jsonstr.compose("structure", structure);
	_jsonstr.compose("speedDisplay", speedDisplay);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("admissions", admissions);
	_jsonstr.compose("destroyDelay_Deprecated", destroyDelay_Deprecated);
	_jsonstr.compose("properties", properties);
	_jsonstr.compose("fromDate", fromDate);
	_jsonstr.compose("toDate", toDate);
	_jsonstr.compose("timeBankIncrement", timeBankIncrement);
	_jsonstr.compose("timeoutTimeBankIncrement", timeoutTimeBankIncrement);
	_jsonstr.compose("randomMatchTimeout", randomMatchTimeout);
	_jsonstr.compose("pendingChallengeTimeout", pendingChallengeTimeout);
	return _buf.c_str();
}

void pokerduel::DuelType::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("siteMask", siteMask);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("matchType", matchType);
	_jparser.parseByNameThrow("numHands", numHands);
	_jparser.parseByNameThrow("smallBlind", smallBlind);
	_jparser.parseByNameThrow("bigBlind", bigBlind);
	_jparser.parseByNameThrow("startingChips", startingChips);
	_jparser.parseByNameThrow("timeToAct_Deprecated", timeToAct_Deprecated);
	_jparser.parseByNameThrow("timerBank", timerBank);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("game", game);
	_jparser.parseByNameThrow("structure", structure);
	_jparser.parseByNameThrow("speedDisplay", speedDisplay);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("admissions", admissions);
	_jparser.parseByNameThrow("destroyDelay_Deprecated", destroyDelay_Deprecated);
	_jparser.parseByNameThrow("properties", properties);
	_jparser.parseByNameThrow("fromDate", fromDate);
	_jparser.parseByNameThrow("toDate", toDate);
	_jparser.parseByNameThrow("timeBankIncrement", timeBankIncrement);
	_jparser.parseByNameThrow("timeoutTimeBankIncrement", timeoutTimeBankIncrement);
	_jparser.parseByNameThrow("randomMatchTimeout", randomMatchTimeout);
	_jparser.parseByNameThrow("pendingChallengeTimeout", pendingChallengeTimeout);
}

void pokerduel::DuelType::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("name", name);
	_jparser.validateByNameThrow("siteMask", siteMask);
	_jparser.validateByNameThrow("status", status);
	_jparser.validateByNameThrow("matchType", matchType);
	_jparser.validateByNameThrow("numHands", numHands);
	_jparser.validateByNameThrow("smallBlind", smallBlind);
	_jparser.validateByNameThrow("bigBlind", bigBlind);
	_jparser.validateByNameThrow("startingChips", startingChips);
	_jparser.validateByNameThrow("timeToAct_Deprecated", timeToAct_Deprecated);
	_jparser.validateByNameThrow("timerBank", timerBank);
	_jparser.validateByNameThrow("buyIn", buyIn);
	_jparser.validateByNameThrow("rake", rake);
	_jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.validateByNameThrow("currency", currency);
	_jparser.validateByNameThrow("game", game);
	_jparser.validateByNameThrow("structure", structure);
	_jparser.validateByNameThrow("speedDisplay", speedDisplay);
	_jparser.validateByNameThrow("tournFlags", tournFlags);
	_jparser.validateByNameThrow("admissions", admissions);
	_jparser.validateByNameThrow("destroyDelay_Deprecated", destroyDelay_Deprecated);
	_jparser.validateByNameThrow("properties", properties);
	_jparser.validateByNameThrow("fromDate", fromDate);
	_jparser.validateByNameThrow("toDate", toDate);
	_jparser.validateByNameThrow("timeBankIncrement", timeBankIncrement);
	_jparser.validateByNameThrow("timeoutTimeBankIncrement", timeoutTimeBankIncrement);
	_jparser.validateByNameThrow("randomMatchTimeout", randomMatchTimeout);
	_jparser.validateByNameThrow("pendingChallengeTimeout", pendingChallengeTimeout);
}

/*static*/ void pokerduel::DuelType::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy;
	_parser0.skip(4);  /*duelTypeId*/
	P_I18nPString::validateMsg(_parser0);  /*name*/
	_parser0.skip(4);  /*siteMask*/
	_parser0.skip(1);  /*status*/
	_parser0.skip(4);  /*matchType*/
	_parser0.skip(4);  /*numHands*/
	_parser0.skip(4);  /*smallBlind*/
	_parser0.skip(4);  /*bigBlind*/
	_parser0.skip(4);  /*startingChips*/
	_parser0.skip(4);  /*timeToAct_Deprecated*/
	_parser0.skip(4);  /*timerBank*/
	_parser0.skip(8);  /*buyIn*/
	_parser0.skip(8);  /*rake*/
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	_parser0.parseStringN(_dummy, 0, "currency");  /*currency*/
	_parser0.skip(1);  /*game*/
	_parser0.skip(1);  /*structure*/
	_parser0.skip(1);  /*speedDisplay*/
	_parser0.skip(4);  /*tournFlags*/
	Atf::LAtfVector< PString , 4 >::validateMsg(_parser0);  /*admissions*/
	_parser0.skip(4);  /*destroyDelay_Deprecated*/
	Atf::LAtfVector< DuelTypeProperty , 4 >::validateMsg(_parser0);  /*properties*/
	_parser0.skip(8);  /*fromDate*/
	_parser0.skip(8);  /*toDate*/
	_parser0.skip(4);  /*timeBankIncrement*/
	_parser0.skip(4);  /*timeoutTimeBankIncrement*/
	_parser0.skip(4);  /*randomMatchTimeout*/
	_parser0.skip(4);  /*pendingChallengeTimeout*/
	AtfValidator::validateEmbeddedMsgbodyParser("DuelType", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    DuelPlayer
//=================================================================

pokerduel::DuelPlayer::DuelPlayer()
{
	clear();
}

void pokerduel::DuelPlayer::clear()
{
	userId.clear();
	userIntId = 0;
	licenseId = 0;
	timeBankInSec = 0;
	imageId = 0;
	playerFlag = 0;
	myLastOrdinalId = 0;
}

bool pokerduel::DuelPlayer::equals(const DuelPlayer& _o) const
{
	return userId.equals(_o.userId) &&
		userIntId == _o.userIntId &&
		licenseId == _o.licenseId &&
		timeBankInSec == _o.timeBankInSec &&
		imageId == _o.imageId &&
		playerFlag == _o.playerFlag &&
		myLastOrdinalId == _o.myLastOrdinalId;
}

const char *pokerduel::DuelPlayer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	_buf.append(',');
	_buf.append("timeBankInSec=");
	_buf.appendInt(timeBankInSec);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("playerFlag=");
	_buf.appendUint(playerFlag);
	_buf.append(',');
	_buf.append("myLastOrdinalId=");
	_buf.appendInt(myLastOrdinalId);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::DuelPlayer::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("licenseId", licenseId, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeBankInSec", timeBankInSec, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerFlag", playerFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("myLastOrdinalId", myLastOrdinalId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::DuelPlayer::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("userIntId"))
		{
			userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("licenseId"))
		{
			licenseId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timeBankInSec"))
		{
			timeBankInSec = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerFlag"))
		{
			playerFlag = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("myLastOrdinalId"))
		{
			myLastOrdinalId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::DuelPlayer::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(DuelPlayer())) // not empty
	{
		_body.composeString(userId);
		_body.composeUINT32(userIntId);
		_body.composeUINT32(licenseId);
		_body.composeINT32(timeBankInSec);
		_body.composeUINT32(imageId);
		_body.composeUINT32(playerFlag);
		_body.composeINT32(myLastOrdinalId);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::DuelPlayer::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringPN(userId, 0, "userId");
	_parser0.parseUINT32(userIntId);
	_parser0.parseUINT32(licenseId);
	_parser0.parseINT32(timeBankInSec);
	_parser0.parseUINT32(imageId);
	_parser0.parseUINT32(playerFlag);
	_parser0.parseINT32(myLastOrdinalId);
}

void pokerduel::DuelPlayer::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("userId", userId);
	_parser0.parse("userIntId", userIntId);
	_parser0.parse("licenseId", licenseId);
	_parser0.parse("timeBankInSec", timeBankInSec);
	_parser0.parse("imageId", imageId);
	_parser0.parse("playerFlag", playerFlag);
	_parser0.parse("myLastOrdinalId", myLastOrdinalId);
}

const char *pokerduel::DuelPlayer::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("licenseId", licenseId);
	_jsonstr.compose("timeBankInSec", timeBankInSec);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("playerFlag", playerFlag);
	_jsonstr.compose("myLastOrdinalId", myLastOrdinalId);
	return _buf.c_str();
}

void pokerduel::DuelPlayer::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("licenseId", licenseId);
	_jparser.parseByNameThrow("timeBankInSec", timeBankInSec);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("playerFlag", playerFlag);
	_jparser.parseByNameThrow("myLastOrdinalId", myLastOrdinalId);
}

void pokerduel::DuelPlayer::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("userIntId", userIntId);
	_jparser.validateByNameThrow("licenseId", licenseId);
	_jparser.validateByNameThrow("timeBankInSec", timeBankInSec);
	_jparser.validateByNameThrow("imageId", imageId);
	_jparser.validateByNameThrow("playerFlag", playerFlag);
	_jparser.validateByNameThrow("myLastOrdinalId", myLastOrdinalId);
}

/*static*/ void pokerduel::DuelPlayer::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy;
	_parser0.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser0.skip(4);  /*userIntId*/
	_parser0.skip(4);  /*licenseId*/
	_parser0.skip(4);  /*timeBankInSec*/
	_parser0.skip(4);  /*imageId*/
	_parser0.skip(4);  /*playerFlag*/
	_parser0.skip(4);  /*myLastOrdinalId*/
	AtfValidator::validateEmbeddedMsgbodyParser("DuelPlayer", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    RunningDuel
//=================================================================

pokerduel::RunningDuel::RunningDuel()
{
	clear();
}

void pokerduel::RunningDuel::clear()
{
	duelId = 0;
	player1.clear();
	player2.clear();
	dbmId = 0;
	tableId = 0;
	duelTypeId = 0;
	startTime.setNull();
	whenClosed.setNull();
	status = 0;
	lastChatOrdinal = 0;
	vppMultipliers.clear();
	ticketUsed1 = false;
	ticketUsed2 = false;
}

bool pokerduel::RunningDuel::equals(const RunningDuel& _o) const
{
	return duelId == _o.duelId &&
		player1.equals(_o.player1) &&
		player2.equals(_o.player2) &&
		dbmId == _o.dbmId &&
		tableId == _o.tableId &&
		duelTypeId == _o.duelTypeId &&
		startTime.equals(_o.startTime) &&
		whenClosed.equals(_o.whenClosed) &&
		status == _o.status &&
		lastChatOrdinal == _o.lastChatOrdinal &&
		vppMultipliers.equals(_o.vppMultipliers) &&
		ticketUsed1 == _o.ticketUsed1 &&
		ticketUsed2 == _o.ticketUsed2;
}

const char *pokerduel::RunningDuel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("player1=");
	player1.toTraceString(_buf);
	_buf.append(',');
	_buf.append("player2=");
	player2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("dbmId=");
	_buf.appendInt(dbmId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("startTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("whenClosed=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenClosed);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("lastChatOrdinal=");
	_buf.appendInt(lastChatOrdinal);
	_buf.append(',');
	_buf.append("vppMultipliers=");
	_buf.append(vppMultipliers);
	_buf.append(',');
	_buf.append("ticketUsed1=");
	_buf.appendUint(ticketUsed1);
	_buf.append(',');
	_buf.append("ticketUsed2=");
	_buf.appendUint(ticketUsed2);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::RunningDuel::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	player1.toXmlString("player1", _buf);
	player2.toXmlString("player2", _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmId", dbmId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "startTime", startTime);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenClosed", whenClosed);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastChatOrdinal", lastChatOrdinal, _buf);
	Atf::XmlElement::encodeAsXmlElement("vppMultipliers", vppMultipliers, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketUsed1", ticketUsed1, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketUsed2", ticketUsed2, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::RunningDuel::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("duelId"))
		{
			duelId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("player1"))
		{
			if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player1)) return false;
		}
		else if (_element.equals("player2"))
		{
			if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player2)) return false;
		}
		else if (_element.equals("dbmId"))
		{
			dbmId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startTime"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, startTime);
		}
		else if (_element.equals("whenClosed"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenClosed);
		}
		else if (_element.equals("status"))
		{
			status = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastChatOrdinal"))
		{
			lastChatOrdinal = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vppMultipliers"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, vppMultipliers)) return false;
		}
		else if (_element.equals("ticketUsed1"))
		{
			ticketUsed1 = (*_value.ptr() == '1');
		}
		else if (_element.equals("ticketUsed2"))
		{
			ticketUsed2 = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::RunningDuel::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(RunningDuel())) // not empty
	{
		_body.composeUINT64(duelId);
		player1.composeMsg(_body, _ignoreJSON);
		player2.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(dbmId);
		_body.composeUINT64(tableId);
		_body.composeUINT32(duelTypeId);
		_body.composeSrvTime(startTime);
		_body.composeSrvTime(whenClosed);
		_body.composeBYTE(status);
		_body.composeINT32(lastChatOrdinal);
		_body.composeString(vppMultipliers);
		_body.composeBOOL(ticketUsed1);
		_body.composeBOOL(ticketUsed2);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::RunningDuel::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(duelId);
	player1.parseMsg(_parser0);
	player2.parseMsg(_parser0);
	_parser0.parseINT32(dbmId);
	_parser0.parseUINT64(tableId);
	_parser0.parseUINT32(duelTypeId);
	_parser0.parseSrvTime(startTime);
	_parser0.parseSrvTime(whenClosed);
	_parser0.parseBYTE(status);
	_parser0.parseINT32(lastChatOrdinal);
	_parser0.parseStringPN(vppMultipliers, 0, "vppMultipliers");
	_parser0.parseBOOL(ticketUsed1);
	_parser0.parseBOOL(ticketUsed2);
}

void pokerduel::RunningDuel::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("duelId", duelId);
	_parser0.parse("player1", player1);
	_parser0.parse("player2", player2);
	_parser0.parse("dbmId", dbmId);
	_parser0.parse("tableId", tableId);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("startTime", startTime);
	_parser0.parse("whenClosed", whenClosed);
	_parser0.parse("status", status);
	_parser0.parse("lastChatOrdinal", lastChatOrdinal);
	_parser0.parse("vppMultipliers", vppMultipliers);
	_parser0.parse("ticketUsed1", ticketUsed1);
	_parser0.parse("ticketUsed2", ticketUsed2);
}

const char *pokerduel::RunningDuel::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player2", player2);
	_jsonstr.compose("dbmId", dbmId);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("startTime", startTime);
	_jsonstr.compose("whenClosed", whenClosed);
	_jsonstr.compose("status", status);
	_jsonstr.compose("lastChatOrdinal", lastChatOrdinal);
	_jsonstr.compose("vppMultipliers", vppMultipliers);
	_jsonstr.compose("ticketUsed1", ticketUsed1);
	_jsonstr.compose("ticketUsed2", ticketUsed2);
	return _buf.c_str();
}

void pokerduel::RunningDuel::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player2", player2);
	_jparser.parseByNameThrow("dbmId", dbmId);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("startTime", startTime);
	_jparser.parseByNameThrow("whenClosed", whenClosed);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.parseByNameThrow("vppMultipliers", vppMultipliers);
	_jparser.parseByNameThrow("ticketUsed1", ticketUsed1);
	_jparser.parseByNameThrow("ticketUsed2", ticketUsed2);
}

void pokerduel::RunningDuel::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player2", player2);
	_jparser.validateByNameThrow("dbmId", dbmId);
	_jparser.validateByNameThrow("tableId", tableId);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("startTime", startTime);
	_jparser.validateByNameThrow("whenClosed", whenClosed);
	_jparser.validateByNameThrow("status", status);
	_jparser.validateByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.validateByNameThrow("vppMultipliers", vppMultipliers);
	_jparser.validateByNameThrow("ticketUsed1", ticketUsed1);
	_jparser.validateByNameThrow("ticketUsed2", ticketUsed2);
}

/*static*/ void pokerduel::RunningDuel::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy;
	_parser0.skip(8);  /*duelId*/
	DuelPlayer::validateMsg(_parser0);  /*player1*/
	DuelPlayer::validateMsg(_parser0);  /*player2*/
	_parser0.skip(4);  /*dbmId*/
	_parser0.skip(8);  /*tableId*/
	_parser0.skip(4);  /*duelTypeId*/
	_parser0.skip(8);  /*startTime*/
	_parser0.skip(8);  /*whenClosed*/
	_parser0.skip(1);  /*status*/
	_parser0.skip(4);  /*lastChatOrdinal*/
	_parser0.parseStringN(_dummy, 0, "vppMultipliers");  /*vppMultipliers*/
	bool ticketUsed1; _parser0.parseBOOL(ticketUsed1);
	bool ticketUsed2; _parser0.parseBOOL(ticketUsed2);
	AtfValidator::validateEmbeddedMsgbodyParser("RunningDuel", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    DuelChallenge
//=================================================================

pokerduel::DuelChallenge::DuelChallenge()
{
	clear();
}

void pokerduel::DuelChallenge::clear()
{
	challengeId = 0;
	dbmId = 0;
	player1.clear();
	player1ImageId = 0;
	player2.clear();
	player2ImageId = 0;
	duelTypeId = 0;
	response = 0;
	whenOffered.setNull();
	whenResponse.setNull();
	buyInPlusRake = 0;
	currency.clear();
	isPlayMoney = false;
	ticketId1 = 0;
	challengeType = 0;
}

bool pokerduel::DuelChallenge::equals(const DuelChallenge& _o) const
{
	return challengeId == _o.challengeId &&
		dbmId == _o.dbmId &&
		player1.equals(_o.player1) &&
		player1ImageId == _o.player1ImageId &&
		player2.equals(_o.player2) &&
		player2ImageId == _o.player2ImageId &&
		duelTypeId == _o.duelTypeId &&
		response == _o.response &&
		whenOffered.equals(_o.whenOffered) &&
		whenResponse.equals(_o.whenResponse) &&
		buyInPlusRake == _o.buyInPlusRake &&
		currency.equals(_o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		ticketId1 == _o.ticketId1 &&
		challengeType == _o.challengeType;
}

const char *pokerduel::DuelChallenge::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("dbmId=");
	_buf.appendInt(dbmId);
	_buf.append(',');
	_buf.append("player1=");
	_buf.append(player1);
	_buf.append(',');
	_buf.append("player1ImageId=");
	_buf.appendUint(player1ImageId);
	_buf.append(',');
	_buf.append("player2=");
	_buf.append(player2);
	_buf.append(',');
	_buf.append("player2ImageId=");
	_buf.appendUint(player2ImageId);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("response=");
	_buf.appendInt(response);
	_buf.append(',');
	_buf.append("whenOffered=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenOffered);
	_buf.append(',');
	_buf.append("whenResponse=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenResponse);
	_buf.append(',');
	_buf.append("buyInPlusRake=");
	_buf.appendInt64(buyInPlusRake);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("ticketId1=");
	_buf.appendUint(ticketId1);
	_buf.append(',');
	_buf.append("challengeType=");
	_buf.appendInt(challengeType);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::DuelChallenge::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmId", dbmId, _buf);
	Atf::XmlElement::encodeAsXmlElement("player1", player1, _buf);
	Atf::XmlElement::encodeAsXmlElement("player1ImageId", player1ImageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("player2", player2, _buf);
	Atf::XmlElement::encodeAsXmlElement("player2ImageId", player2ImageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("response", response, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenOffered", whenOffered);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenResponse", whenResponse);
	Atf::XmlElement::encodeAsXmlElement("buyInPlusRake", buyInPlusRake, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketId1", ticketId1, _buf);
	Atf::XmlElement::encodeAsXmlElement("challengeType", challengeType, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::DuelChallenge::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("challengeId"))
		{
			challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dbmId"))
		{
			dbmId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("player1"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, player1)) return false;
		}
		else if (_element.equals("player1ImageId"))
		{
			player1ImageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("player2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, player2)) return false;
		}
		else if (_element.equals("player2ImageId"))
		{
			player2ImageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("response"))
		{
			response = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenOffered"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenOffered);
		}
		else if (_element.equals("whenResponse"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenResponse);
		}
		else if (_element.equals("buyInPlusRake"))
		{
			buyInPlusRake = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("ticketId1"))
		{
			ticketId1 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("challengeType"))
		{
			challengeType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::DuelChallenge::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(DuelChallenge())) // not empty
	{
		_body.composeUINT64(challengeId);
		_body.composeINT32(dbmId);
		_body.composeString(player1);
		_body.composeUINT32(player1ImageId);
		_body.composeString(player2);
		_body.composeUINT32(player2ImageId);
		_body.composeUINT32(duelTypeId);
		_body.composeINT32(response);
		_body.composeSrvTime(whenOffered);
		_body.composeSrvTime(whenResponse);
		_body.composeINT64(buyInPlusRake);
		_body.composeString(currency);
		_body.composeBOOL(isPlayMoney);
		_body.composeUINT32(ticketId1);
		_body.composeINT32(challengeType);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::DuelChallenge::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(challengeId);
	_parser0.parseINT32(dbmId);
	_parser0.parseStringPN(player1, 0, "player1");
	_parser0.parseUINT32(player1ImageId);
	_parser0.parseStringPN(player2, 0, "player2");
	_parser0.parseUINT32(player2ImageId);
	_parser0.parseUINT32(duelTypeId);
	_parser0.parseINT32(response);
	_parser0.parseSrvTime(whenOffered);
	_parser0.parseSrvTime(whenResponse);
	_parser0.parseINT64(buyInPlusRake);
	_parser0.parseStringPN(currency, 0, "currency");
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseUINT32(ticketId1);
	_parser0.parseINT32(challengeType);
}

void pokerduel::DuelChallenge::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("challengeId", challengeId);
	_parser0.parse("dbmId", dbmId);
	_parser0.parse("player1", player1);
	_parser0.parse("player1ImageId", player1ImageId);
	_parser0.parse("player2", player2);
	_parser0.parse("player2ImageId", player2ImageId);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("response", response);
	_parser0.parse("whenOffered", whenOffered);
	_parser0.parse("whenResponse", whenResponse);
	_parser0.parse("buyInPlusRake", buyInPlusRake);
	_parser0.parse("currency", currency);
	_parser0.parse("isPlayMoney", isPlayMoney);
	_parser0.parse("ticketId1", ticketId1);
	_parser0.parse("challengeType", challengeType);
}

const char *pokerduel::DuelChallenge::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("dbmId", dbmId);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player1ImageId", player1ImageId);
	_jsonstr.compose("player2", player2);
	_jsonstr.compose("player2ImageId", player2ImageId);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("response", response);
	_jsonstr.compose("whenOffered", whenOffered);
	_jsonstr.compose("whenResponse", whenResponse);
	_jsonstr.compose("buyInPlusRake", buyInPlusRake);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("ticketId1", ticketId1);
	_jsonstr.compose("challengeType", challengeType);
	return _buf.c_str();
}

void pokerduel::DuelChallenge::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeId", challengeId);
	_jparser.parseByNameThrow("dbmId", dbmId);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player1ImageId", player1ImageId);
	_jparser.parseByNameThrow("player2", player2);
	_jparser.parseByNameThrow("player2ImageId", player2ImageId);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("response", response);
	_jparser.parseByNameThrow("whenOffered", whenOffered);
	_jparser.parseByNameThrow("whenResponse", whenResponse);
	_jparser.parseByNameThrow("buyInPlusRake", buyInPlusRake);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("ticketId1", ticketId1);
	_jparser.parseByNameThrow("challengeType", challengeType);
}

void pokerduel::DuelChallenge::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeId", challengeId);
	_jparser.validateByNameThrow("dbmId", dbmId);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player1ImageId", player1ImageId);
	_jparser.validateByNameThrow("player2", player2);
	_jparser.validateByNameThrow("player2ImageId", player2ImageId);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("response", response);
	_jparser.validateByNameThrow("whenOffered", whenOffered);
	_jparser.validateByNameThrow("whenResponse", whenResponse);
	_jparser.validateByNameThrow("buyInPlusRake", buyInPlusRake);
	_jparser.validateByNameThrow("currency", currency);
	_jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.validateByNameThrow("ticketId1", ticketId1);
	_jparser.validateByNameThrow("challengeType", challengeType);
}

/*static*/ void pokerduel::DuelChallenge::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy;
	_parser0.skip(8);  /*challengeId*/
	_parser0.skip(4);  /*dbmId*/
	_parser0.parseStringN(_dummy, 0, "player1");  /*player1*/
	_parser0.skip(4);  /*player1ImageId*/
	_parser0.parseStringN(_dummy, 0, "player2");  /*player2*/
	_parser0.skip(4);  /*player2ImageId*/
	_parser0.skip(4);  /*duelTypeId*/
	_parser0.skip(4);  /*response*/
	_parser0.skip(8);  /*whenOffered*/
	_parser0.skip(8);  /*whenResponse*/
	_parser0.skip(8);  /*buyInPlusRake*/
	_parser0.parseStringN(_dummy, 0, "currency");  /*currency*/
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	_parser0.skip(4);  /*ticketId1*/
	_parser0.skip(4);  /*challengeType*/
	AtfValidator::validateEmbeddedMsgbodyParser("DuelChallenge", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    IceDuelsAchievement
//=================================================================

pokerduel::IceDuelsAchievement::IceDuelsAchievement()
{
	clear();
}

void pokerduel::IceDuelsAchievement::clear()
{
	achievementId = 0;
	levels.clear();
	title.clear();
	descr.clear();
	descr2.clear();
	descr3.clear();
	infoMsg.clear();
}

bool pokerduel::IceDuelsAchievement::equals(const IceDuelsAchievement& _o) const
{
	return achievementId == _o.achievementId &&
		levels.equals(_o.levels) &&
		title.equals(_o.title) &&
		descr.equals(_o.descr) &&
		descr2.equals(_o.descr2) &&
		descr3.equals(_o.descr3) &&
		infoMsg.equals(_o.infoMsg);
}

const char *pokerduel::IceDuelsAchievement::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("achievementId=");
	_buf.appendInt(achievementId);
	_buf.append(',');
	_buf.append("levels=");
	levels.toTraceString(_buf);
	_buf.append(',');
	_buf.append("title=");
	_buf.append(title);
	_buf.append(',');
	_buf.append("descr=");
	_buf.append(descr);
	_buf.append(',');
	_buf.append("descr2=");
	_buf.append(descr2);
	_buf.append(',');
	_buf.append("descr3=");
	_buf.append(descr3);
	_buf.append(',');
	_buf.append("infoMsg=");
	_buf.append(infoMsg);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::IceDuelsAchievement::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("achievementId", achievementId, _buf);
	levels.toXmlString("levels", _buf);
	Atf::XmlElement::encodeAsXmlElement("title", title, _buf);
	Atf::XmlElement::encodeAsXmlElement("descr", descr, _buf);
	Atf::XmlElement::encodeAsXmlElement("descr2", descr2, _buf);
	Atf::XmlElement::encodeAsXmlElement("descr3", descr3, _buf);
	Atf::XmlElement::encodeAsXmlElement("infoMsg", infoMsg, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::IceDuelsAchievement::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("achievementId"))
		{
			achievementId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("levels"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, levels)) return false;
		}
		else if (_element.equals("title"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, title)) return false;
		}
		else if (_element.equals("descr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, descr)) return false;
		}
		else if (_element.equals("descr2"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, descr2)) return false;
		}
		else if (_element.equals("descr3"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, descr3)) return false;
		}
		else if (_element.equals("infoMsg"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, infoMsg)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::IceDuelsAchievement::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(achievementId);
	levels.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(title);
	_msg.composeString(descr);
	_msg.composeString(descr2);
	_msg.composeString(descr3);
	_msg.composeString(infoMsg);
}

void pokerduel::IceDuelsAchievement::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(achievementId);
	levels.parseMsg(_parser);
	_parser.parseStringPN(title, 0, "title");
	_parser.parseStringPN(descr, 0, "descr");
	_parser.parseStringPN(descr2, 0, "descr2");
	_parser.parseStringPN(descr3, 0, "descr3");
	_parser.parseStringPN(infoMsg, 0, "infoMsg");
}

void pokerduel::IceDuelsAchievement::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("achievementId", achievementId);
	_parser.parse("levels", levels);
	_parser.parse("title", title);
	_parser.parse("descr", descr);
	_parser.parse("descr2", descr2);
	_parser.parse("descr3", descr3);
	_parser.parse("infoMsg", infoMsg);
}

const char *pokerduel::IceDuelsAchievement::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("achievementId", achievementId);
	_jsonstr.compose("levels", levels);
	_jsonstr.compose("title", title);
	_jsonstr.compose("descr", descr);
	_jsonstr.compose("descr2", descr2);
	_jsonstr.compose("descr3", descr3);
	_jsonstr.compose("infoMsg", infoMsg);
	return _buf.c_str();
}

void pokerduel::IceDuelsAchievement::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("achievementId", achievementId);
	_jparser.parseByNameThrow("levels", levels);
	_jparser.parseByNameThrow("title", title);
	_jparser.parseByNameThrow("descr", descr);
	_jparser.parseByNameThrow("descr2", descr2);
	_jparser.parseByNameThrow("descr3", descr3);
	_jparser.parseByNameThrow("infoMsg", infoMsg);
}

void pokerduel::IceDuelsAchievement::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("achievementId", achievementId);
	_jparser.validateByNameThrow("levels", levels);
	_jparser.validateByNameThrow("title", title);
	_jparser.validateByNameThrow("descr", descr);
	_jparser.validateByNameThrow("descr2", descr2);
	_jparser.validateByNameThrow("descr3", descr3);
	_jparser.validateByNameThrow("infoMsg", infoMsg);
}

/*static*/ void pokerduel::IceDuelsAchievement::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*achievementId*/
	Atf::LAtfVector< INT64, 4 >::validateMsg(_parser);  /*levels*/
	_parser.parseStringN(_dummy, 0, "title");  /*title*/
	_parser.parseStringN(_dummy, 0, "descr");  /*descr*/
	_parser.parseStringN(_dummy, 0, "descr2");  /*descr2*/
	_parser.parseStringN(_dummy, 0, "descr3");  /*descr3*/
	_parser.parseStringN(_dummy, 0, "infoMsg");  /*infoMsg*/
}

//=================================================================
//                    IceDuelUserStats
//=================================================================

pokerduel::IceDuelUserStats::IceDuelUserStats()
{
	clear();
}

void pokerduel::IceDuelUserStats::clear()
{
	userIntId = 0;
	duelsWon = 0;
	duelsLost = 0;
	duelsDraw = 0;
	totalEarnedChips = 0;
	totalStartChips = 0;
	handsWon = 0;
	handsPlayed = 0;
	winStreak = 0;
	bestFive.clear();
}

bool pokerduel::IceDuelUserStats::equals(const IceDuelUserStats& _o) const
{
	return userIntId == _o.userIntId &&
		duelsWon == _o.duelsWon &&
		duelsLost == _o.duelsLost &&
		duelsDraw == _o.duelsDraw &&
		totalEarnedChips == _o.totalEarnedChips &&
		totalStartChips == _o.totalStartChips &&
		handsWon == _o.handsWon &&
		handsPlayed == _o.handsPlayed &&
		winStreak == _o.winStreak &&
		bestFive.equals(_o.bestFive);
}

const char *pokerduel::IceDuelUserStats::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userIntId=");
	_buf.appendInt(userIntId);
	_buf.append(',');
	_buf.append("duelsWon=");
	_buf.appendInt(duelsWon);
	_buf.append(',');
	_buf.append("duelsLost=");
	_buf.appendInt(duelsLost);
	_buf.append(',');
	_buf.append("duelsDraw=");
	_buf.appendInt(duelsDraw);
	_buf.append(',');
	_buf.append("totalEarnedChips=");
	_buf.appendInt64(totalEarnedChips);
	_buf.append(',');
	_buf.append("totalStartChips=");
	_buf.appendInt64(totalStartChips);
	_buf.append(',');
	_buf.append("handsWon=");
	_buf.appendInt(handsWon);
	_buf.append(',');
	_buf.append("handsPlayed=");
	_buf.appendInt(handsPlayed);
	_buf.append(',');
	_buf.append("winStreak=");
	_buf.appendInt(winStreak);
	_buf.append(',');
	_buf.append("bestFive=");
	bestFive.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::IceDuelUserStats::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelsWon", duelsWon, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelsLost", duelsLost, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelsDraw", duelsDraw, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalEarnedChips", totalEarnedChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalStartChips", totalStartChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsWon", handsWon, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsPlayed", handsPlayed, _buf);
	Atf::XmlElement::encodeAsXmlElement("winStreak", winStreak, _buf);
	bestFive.toXmlString("bestFive", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::IceDuelUserStats::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("userIntId"))
		{
			userIntId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelsWon"))
		{
			duelsWon = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelsLost"))
		{
			duelsLost = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelsDraw"))
		{
			duelsDraw = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalEarnedChips"))
		{
			totalEarnedChips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalStartChips"))
		{
			totalStartChips = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsWon"))
		{
			handsWon = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsPlayed"))
		{
			handsPlayed = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winStreak"))
		{
			winStreak = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bestFive"))
		{
			if(!Atf::AtfTempl< XINT64 >::FromXmlString(_value, bestFive)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::IceDuelUserStats::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(userIntId);
	_msg.composeINT32(duelsWon);
	_msg.composeINT32(duelsLost);
	_msg.composeINT32(duelsDraw);
	_msg.composeINT64(totalEarnedChips);
	_msg.composeINT64(totalStartChips);
	_msg.composeINT32(handsWon);
	_msg.composeINT32(handsPlayed);
	_msg.composeINT32(winStreak);
	bestFive.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::IceDuelUserStats::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(userIntId);
	_parser.parseINT32(duelsWon);
	_parser.parseINT32(duelsLost);
	_parser.parseINT32(duelsDraw);
	_parser.parseINT64(totalEarnedChips);
	_parser.parseINT64(totalStartChips);
	_parser.parseINT32(handsWon);
	_parser.parseINT32(handsPlayed);
	_parser.parseINT32(winStreak);
	bestFive.parseMsg(_parser);
}

void pokerduel::IceDuelUserStats::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("userIntId", userIntId);
	_parser.parse("duelsWon", duelsWon);
	_parser.parse("duelsLost", duelsLost);
	_parser.parse("duelsDraw", duelsDraw);
	_parser.parse("totalEarnedChips", totalEarnedChips);
	_parser.parse("totalStartChips", totalStartChips);
	_parser.parse("handsWon", handsWon);
	_parser.parse("handsPlayed", handsPlayed);
	_parser.parse("winStreak", winStreak);
	_parser.parse("bestFive", bestFive);
}

const char *pokerduel::IceDuelUserStats::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("duelsWon", duelsWon);
	_jsonstr.compose("duelsLost", duelsLost);
	_jsonstr.compose("duelsDraw", duelsDraw);
	_jsonstr.compose("totalEarnedChips", totalEarnedChips);
	_jsonstr.compose("totalStartChips", totalStartChips);
	_jsonstr.compose("handsWon", handsWon);
	_jsonstr.compose("handsPlayed", handsPlayed);
	_jsonstr.compose("winStreak", winStreak);
	_jsonstr.compose("bestFive", bestFive);
	return _buf.c_str();
}

void pokerduel::IceDuelUserStats::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("duelsWon", duelsWon);
	_jparser.parseByNameThrow("duelsLost", duelsLost);
	_jparser.parseByNameThrow("duelsDraw", duelsDraw);
	_jparser.parseByNameThrow("totalEarnedChips", totalEarnedChips);
	_jparser.parseByNameThrow("totalStartChips", totalStartChips);
	_jparser.parseByNameThrow("handsWon", handsWon);
	_jparser.parseByNameThrow("handsPlayed", handsPlayed);
	_jparser.parseByNameThrow("winStreak", winStreak);
	_jparser.parseByNameThrow("bestFive", bestFive);
}

void pokerduel::IceDuelUserStats::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userIntId", userIntId);
	_jparser.validateByNameThrow("duelsWon", duelsWon);
	_jparser.validateByNameThrow("duelsLost", duelsLost);
	_jparser.validateByNameThrow("duelsDraw", duelsDraw);
	_jparser.validateByNameThrow("totalEarnedChips", totalEarnedChips);
	_jparser.validateByNameThrow("totalStartChips", totalStartChips);
	_jparser.validateByNameThrow("handsWon", handsWon);
	_jparser.validateByNameThrow("handsPlayed", handsPlayed);
	_jparser.validateByNameThrow("winStreak", winStreak);
	_jparser.validateByNameThrow("bestFive", bestFive);
}

/*static*/ void pokerduel::IceDuelUserStats::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(4);  /*userIntId*/
	_parser.skip(4);  /*duelsWon*/
	_parser.skip(4);  /*duelsLost*/
	_parser.skip(4);  /*duelsDraw*/
	_parser.skip(8);  /*totalEarnedChips*/
	_parser.skip(8);  /*totalStartChips*/
	_parser.skip(4);  /*handsWon*/
	_parser.skip(4);  /*handsPlayed*/
	_parser.skip(4);  /*winStreak*/
	XINT64::validateMsg(_parser);  /*bestFive*/
}

//=================================================================
//                    IceDuelUserPVPStats
//=================================================================

pokerduel::IceDuelUserPVPStats::IceDuelUserPVPStats()
{
	clear();
}

void pokerduel::IceDuelUserPVPStats::clear()
{
	userIntId1 = 0;
	userIntId2 = 0;
	duelsWon = 0;
	duelsLost = 0;
	duelsDraw = 0;
}

bool pokerduel::IceDuelUserPVPStats::equals(const IceDuelUserPVPStats& _o) const
{
	return userIntId1 == _o.userIntId1 &&
		userIntId2 == _o.userIntId2 &&
		duelsWon == _o.duelsWon &&
		duelsLost == _o.duelsLost &&
		duelsDraw == _o.duelsDraw;
}

const char *pokerduel::IceDuelUserPVPStats::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userIntId1=");
	_buf.appendInt(userIntId1);
	_buf.append(',');
	_buf.append("userIntId2=");
	_buf.appendInt(userIntId2);
	_buf.append(',');
	_buf.append("duelsWon=");
	_buf.appendInt(duelsWon);
	_buf.append(',');
	_buf.append("duelsLost=");
	_buf.appendInt(duelsLost);
	_buf.append(',');
	_buf.append("duelsDraw=");
	_buf.appendInt(duelsDraw);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::IceDuelUserPVPStats::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userIntId1", userIntId1, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId2", userIntId2, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelsWon", duelsWon, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelsLost", duelsLost, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelsDraw", duelsDraw, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::IceDuelUserPVPStats::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("userIntId1"))
		{
			userIntId1 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userIntId2"))
		{
			userIntId2 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelsWon"))
		{
			duelsWon = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelsLost"))
		{
			duelsLost = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelsDraw"))
		{
			duelsDraw = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::IceDuelUserPVPStats::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(userIntId1);
	_msg.composeINT32(userIntId2);
	_msg.composeINT32(duelsWon);
	_msg.composeINT32(duelsLost);
	_msg.composeINT32(duelsDraw);
}

void pokerduel::IceDuelUserPVPStats::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(userIntId1);
	_parser.parseINT32(userIntId2);
	_parser.parseINT32(duelsWon);
	_parser.parseINT32(duelsLost);
	_parser.parseINT32(duelsDraw);
}

void pokerduel::IceDuelUserPVPStats::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("userIntId1", userIntId1);
	_parser.parse("userIntId2", userIntId2);
	_parser.parse("duelsWon", duelsWon);
	_parser.parse("duelsLost", duelsLost);
	_parser.parse("duelsDraw", duelsDraw);
}

const char *pokerduel::IceDuelUserPVPStats::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId1", userIntId1);
	_jsonstr.compose("userIntId2", userIntId2);
	_jsonstr.compose("duelsWon", duelsWon);
	_jsonstr.compose("duelsLost", duelsLost);
	_jsonstr.compose("duelsDraw", duelsDraw);
	return _buf.c_str();
}

void pokerduel::IceDuelUserPVPStats::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId1", userIntId1);
	_jparser.parseByNameThrow("userIntId2", userIntId2);
	_jparser.parseByNameThrow("duelsWon", duelsWon);
	_jparser.parseByNameThrow("duelsLost", duelsLost);
	_jparser.parseByNameThrow("duelsDraw", duelsDraw);
}

void pokerduel::IceDuelUserPVPStats::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userIntId1", userIntId1);
	_jparser.validateByNameThrow("userIntId2", userIntId2);
	_jparser.validateByNameThrow("duelsWon", duelsWon);
	_jparser.validateByNameThrow("duelsLost", duelsLost);
	_jparser.validateByNameThrow("duelsDraw", duelsDraw);
}

/*static*/ void pokerduel::IceDuelUserPVPStats::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(4);  /*userIntId1*/
	_parser.skip(4);  /*userIntId2*/
	_parser.skip(4);  /*duelsWon*/
	_parser.skip(4);  /*duelsLost*/
	_parser.skip(4);  /*duelsDraw*/
}

//=================================================================
//                    IceDuelsUserAchievement
//=================================================================

pokerduel::IceDuelsUserAchievement::IceDuelsUserAchievement()
{
	clear();
}

void pokerduel::IceDuelsUserAchievement::clear()
{
	achievementId = 0;
	counter1.clear();
}

bool pokerduel::IceDuelsUserAchievement::equals(const IceDuelsUserAchievement& _o) const
{
	return achievementId == _o.achievementId &&
		counter1.equals(_o.counter1);
}

const char *pokerduel::IceDuelsUserAchievement::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("achievementId=");
	_buf.appendInt(achievementId);
	_buf.append(',');
	_buf.append("counter1=");
	counter1.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::IceDuelsUserAchievement::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("achievementId", achievementId, _buf);
	counter1.toXmlString("counter1", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::IceDuelsUserAchievement::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("achievementId"))
		{
			achievementId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("counter1"))
		{
			if(!Atf::AtfTempl< XINT64 >::FromXmlString(_value, counter1)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::IceDuelsUserAchievement::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(achievementId);
	counter1.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::IceDuelsUserAchievement::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(achievementId);
	counter1.parseMsg(_parser);
}

void pokerduel::IceDuelsUserAchievement::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("achievementId", achievementId);
	_parser.parse("counter1", counter1);
}

const char *pokerduel::IceDuelsUserAchievement::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("achievementId", achievementId);
	_jsonstr.compose("counter1", counter1);
	return _buf.c_str();
}

void pokerduel::IceDuelsUserAchievement::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("achievementId", achievementId);
	_jparser.parseByNameThrow("counter1", counter1);
}

void pokerduel::IceDuelsUserAchievement::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("achievementId", achievementId);
	_jparser.validateByNameThrow("counter1", counter1);
}

/*static*/ void pokerduel::IceDuelsUserAchievement::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(4);  /*achievementId*/
	XINT64::validateMsg(_parser);  /*counter1*/
}

//=================================================================
//                    DbmInfo
//=================================================================

pokerduel::dbm::DbmInfo::DbmInfo()
{
	clear();
}

void pokerduel::dbm::DbmInfo::clear()
{
	dbmId = 0;
	dbmAddressRO.clear();
	dbmInstanceRO.clear();
	dbmAddressRW.clear();
	dbmInstanceRW.clear();
}

bool pokerduel::dbm::DbmInfo::equals(const DbmInfo& _o) const
{
	return dbmId == _o.dbmId &&
		dbmAddressRO.equals(_o.dbmAddressRO) &&
		dbmInstanceRO.equals(_o.dbmInstanceRO) &&
		dbmAddressRW.equals(_o.dbmAddressRW) &&
		dbmInstanceRW.equals(_o.dbmInstanceRW);
}

const char *pokerduel::dbm::DbmInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("dbmId=");
	_buf.appendInt(dbmId);
	_buf.append(',');
	_buf.append("dbmAddressRO=");
	_buf.append(dbmAddressRO);
	_buf.append(',');
	_buf.append("dbmInstanceRO=");
	_buf.append(dbmInstanceRO);
	_buf.append(',');
	_buf.append("dbmAddressRW=");
	_buf.append(dbmAddressRW);
	_buf.append(',');
	_buf.append("dbmInstanceRW=");
	_buf.append(dbmInstanceRW);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::dbm::DbmInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("dbmId", dbmId, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmAddressRO", dbmAddressRO, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmInstanceRO", dbmInstanceRO, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmAddressRW", dbmAddressRW, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmInstanceRW", dbmInstanceRW, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::dbm::DbmInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("dbmId"))
		{
			dbmId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dbmAddressRO"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, dbmAddressRO)) return false;
		}
		else if (_element.equals("dbmInstanceRO"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, dbmInstanceRO)) return false;
		}
		else if (_element.equals("dbmAddressRW"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, dbmAddressRW)) return false;
		}
		else if (_element.equals("dbmInstanceRW"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, dbmInstanceRW)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::dbm::DbmInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(dbmId);
	_msg.composeString(dbmAddressRO);
	_msg.composeString(dbmInstanceRO);
	_msg.composeString(dbmAddressRW);
	_msg.composeString(dbmInstanceRW);
}

void pokerduel::dbm::DbmInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(dbmId);
	_parser.parseStringPN(dbmAddressRO, 0, "dbmAddressRO");
	_parser.parseStringPN(dbmInstanceRO, 0, "dbmInstanceRO");
	_parser.parseStringPN(dbmAddressRW, 0, "dbmAddressRW");
	_parser.parseStringPN(dbmInstanceRW, 0, "dbmInstanceRW");
}

void pokerduel::dbm::DbmInfo::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("dbmId", dbmId);
	_parser.parse("dbmAddressRO", dbmAddressRO);
	_parser.parse("dbmInstanceRO", dbmInstanceRO);
	_parser.parse("dbmAddressRW", dbmAddressRW);
	_parser.parse("dbmInstanceRW", dbmInstanceRW);
}

const char *pokerduel::dbm::DbmInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dbmId", dbmId);
	_jsonstr.compose("dbmAddressRO", dbmAddressRO);
	_jsonstr.compose("dbmInstanceRO", dbmInstanceRO);
	_jsonstr.compose("dbmAddressRW", dbmAddressRW);
	_jsonstr.compose("dbmInstanceRW", dbmInstanceRW);
	return _buf.c_str();
}

void pokerduel::dbm::DbmInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dbmId", dbmId);
	_jparser.parseByNameThrow("dbmAddressRO", dbmAddressRO);
	_jparser.parseByNameThrow("dbmInstanceRO", dbmInstanceRO);
	_jparser.parseByNameThrow("dbmAddressRW", dbmAddressRW);
	_jparser.parseByNameThrow("dbmInstanceRW", dbmInstanceRW);
}

void pokerduel::dbm::DbmInfo::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("dbmId", dbmId);
	_jparser.validateByNameThrow("dbmAddressRO", dbmAddressRO);
	_jparser.validateByNameThrow("dbmInstanceRO", dbmInstanceRO);
	_jparser.validateByNameThrow("dbmAddressRW", dbmAddressRW);
	_jparser.validateByNameThrow("dbmInstanceRW", dbmInstanceRW);
}

/*static*/ void pokerduel::dbm::DbmInfo::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*dbmId*/
	_parser.parseStringN(_dummy, 0, "dbmAddressRO");  /*dbmAddressRO*/
	_parser.parseStringN(_dummy, 0, "dbmInstanceRO");  /*dbmInstanceRO*/
	_parser.parseStringN(_dummy, 0, "dbmAddressRW");  /*dbmAddressRW*/
	_parser.parseStringN(_dummy, 0, "dbmInstanceRW");  /*dbmInstanceRW*/
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_GET_INIT_DATA
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::Protocol_DBM_Q_PDUEL_GET_INIT_DATA()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::clear()
{
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::equals(const Protocol_DBM_Q_PDUEL_GET_INIT_DATA& _o) const
{
	return true;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_GET_INIT_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_GET_INIT_DATA*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_GET_INIT_DATA).append(")");
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_GET_INIT_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_DBM_A_PDUEL_GET_INIT_DATA
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::Protocol_DBM_A_PDUEL_GET_INIT_DATA()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::clear()
{
	errCode = 0;
	errString.clear();
	dbmList.clear();
	duelTypes.clear();
	runningDuels.clear();
	challenges.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::equals(const Protocol_DBM_A_PDUEL_GET_INIT_DATA& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		dbmList.equals(_o.dbmList) &&
		duelTypes.equals(_o.duelTypes) &&
		runningDuels.equals(_o.runningDuels) &&
		challenges.equals(_o.challenges);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_GET_INIT_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_GET_INIT_DATA*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_GET_INIT_DATA).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("dbmList=");
		dbmList.toTraceString(_buf);
		_buf.append(',');
		_buf.append("duelTypes=");
		duelTypes.toTraceString(_buf);
		_buf.append(',');
		_buf.append("runningDuels=");
		runningDuels.toTraceString(_buf);
		_buf.append(',');
		_buf.append("challenges=");
		challenges.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_GET_INIT_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		dbmList.toXmlString("dbmList", _buf);
		duelTypes.toXmlString("duelTypes", _buf);
		runningDuels.toXmlString("runningDuels", _buf);
		challenges.toXmlString("challenges", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("dbmList"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DbmInfo, 4 > >::FromXmlString(_value, dbmList)) return false;
			}
			else if (_element.equals("duelTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DuelType, 4 > >::FromXmlString(_value, duelTypes)) return false;
			}
			else if (_element.equals("runningDuels"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< RunningDuel, 4 > >::FromXmlString(_value, runningDuels)) return false;
			}
			else if (_element.equals("challenges"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DuelChallenge, 4 > >::FromXmlString(_value, challenges)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		dbmList.composeMsg(_msg, _ignoreJSON);
		duelTypes.composeMsg(_msg, _ignoreJSON);
		runningDuels.composeMsg(_msg, _ignoreJSON);
		challenges.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
	else
	{
		dbmList.parseMsg(_parser);
		duelTypes.parseMsg(_parser);
		runningDuels.parseMsg(_parser);
		challenges.parseMsg(_parser);
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("dbmList", dbmList);
		_jsonstr.compose("duelTypes", duelTypes);
		_jsonstr.compose("runningDuels", runningDuels);
		_jsonstr.compose("challenges", challenges);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("dbmList", dbmList);
		_jparser.parseByNameThrow("duelTypes", duelTypes);
		_jparser.parseByNameThrow("runningDuels", runningDuels);
		_jparser.parseByNameThrow("challenges", challenges);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
	else
	{
		_jparser.validateByNameThrow("dbmList", dbmList);
		_jparser.validateByNameThrow("duelTypes", duelTypes);
		_jparser.validateByNameThrow("runningDuels", runningDuels);
		_jparser.validateByNameThrow("challenges", challenges);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
	else
	{
		Atf::LAtfVector< DbmInfo, 4 >::validateMsg(_parser);  /*dbmList*/
		Atf::LAtfVector< DuelType, 4 >::validateMsg(_parser);  /*duelTypes*/
		Atf::LAtfVector< RunningDuel, 4 >::validateMsg(_parser);  /*runningDuels*/
		Atf::LAtfVector< DuelChallenge, 4 >::validateMsg(_parser);  /*challenges*/
	}
}

//=================================================================
//                    RunningState
//=================================================================

pokerduel::dbm::RunningState::RunningState()
{
	clear();
}

void pokerduel::dbm::RunningState::clear()
{
	stateSeq = 0;
	state.clear();
	algorId = 0;
	flags = 0;
}

bool pokerduel::dbm::RunningState::equals(const RunningState& _o) const
{
	return stateSeq == _o.stateSeq &&
		state.equals(_o.state) &&
		algorId == _o.algorId &&
		flags == _o.flags;
}

const char *pokerduel::dbm::RunningState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("stateSeq=");
	_buf.appendUint(stateSeq);
	_buf.append(',');
	_buf.append("state=");
	_buf.append(state);
	_buf.append(',');
	_buf.append("algorId=");
	_buf.appendUint(algorId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::dbm::RunningState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("stateSeq", stateSeq, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	Atf::XmlElement::encodeAsXmlElement("algorId", algorId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::dbm::RunningState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("stateSeq"))
		{
			stateSeq = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("state"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, state)) return false;
		}
		else if (_element.equals("algorId"))
		{
			algorId = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::dbm::RunningState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(stateSeq);
	_msg.composeString(state);
	_msg.composeBYTE(algorId);
	_msg.composeUINT32(flags);
}

void pokerduel::dbm::RunningState::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(stateSeq);
	_parser.parseStringPN(state, 0, "state");
	_parser.parseBYTE(algorId);
	_parser.parseUINT32(flags);
}

void pokerduel::dbm::RunningState::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("stateSeq", stateSeq);
	_parser.parse("state", state);
	_parser.parse("algorId", algorId);
	_parser.parse("flags", flags);
}

const char *pokerduel::dbm::RunningState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("stateSeq", stateSeq);
	_jsonstr.compose("state", state);
	_jsonstr.compose("algorId", algorId);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void pokerduel::dbm::RunningState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("stateSeq", stateSeq);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("algorId", algorId);
	_jparser.parseByNameThrow("flags", flags);
}

void pokerduel::dbm::RunningState::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("stateSeq", stateSeq);
	_jparser.validateByNameThrow("state", state);
	_jparser.validateByNameThrow("algorId", algorId);
	_jparser.validateByNameThrow("flags", flags);
}

/*static*/ void pokerduel::dbm::RunningState::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*stateSeq*/
	_parser.parseStringN(_dummy, 0, "state");  /*state*/
	_parser.skip(1);  /*algorId*/
	_parser.skip(4);  /*flags*/
}

//=================================================================
//                    CreatedDuelInfo
//=================================================================

pokerduel::dbm::CreatedDuelInfo::CreatedDuelInfo()
{
	clear();
}

void pokerduel::dbm::CreatedDuelInfo::clear()
{
	duelId = 0;
	tableId = 0;
	handIds.clear();
	player1.clear();
	player2.clear();
	vppMultipliers.clear();
}

bool pokerduel::dbm::CreatedDuelInfo::equals(const CreatedDuelInfo& _o) const
{
	return duelId == _o.duelId &&
		tableId == _o.tableId &&
		handIds.equals(_o.handIds) &&
		player1.equals(_o.player1) &&
		player2.equals(_o.player2) &&
		vppMultipliers.equals(_o.vppMultipliers);
}

const char *pokerduel::dbm::CreatedDuelInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("handIds=");
	handIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("player1=");
	player1.toTraceString(_buf);
	_buf.append(',');
	_buf.append("player2=");
	player2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("vppMultipliers=");
	_buf.append(vppMultipliers);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::dbm::CreatedDuelInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	handIds.toXmlString("handIds", _buf);
	player1.toXmlString("player1", _buf);
	player2.toXmlString("player2", _buf);
	Atf::XmlElement::encodeAsXmlElement("vppMultipliers", vppMultipliers, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::dbm::CreatedDuelInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("duelId"))
		{
			duelId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, handIds)) return false;
		}
		else if (_element.equals("player1"))
		{
			if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player1)) return false;
		}
		else if (_element.equals("player2"))
		{
			if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player2)) return false;
		}
		else if (_element.equals("vppMultipliers"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, vppMultipliers)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::dbm::CreatedDuelInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeUINT64(tableId);
	handIds.composeMsg(_msg, _ignoreJSON);
	player1.composeMsg(_msg, _ignoreJSON);
	player2.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(vppMultipliers);
}

void pokerduel::dbm::CreatedDuelInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseUINT64(tableId);
	handIds.parseMsg(_parser);
	player1.parseMsg(_parser);
	player2.parseMsg(_parser);
	_parser.parseStringPN(vppMultipliers, 0, "vppMultipliers");
}

void pokerduel::dbm::CreatedDuelInfo::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("duelId", duelId);
	_parser.parse("tableId", tableId);
	_parser.parse("handIds", handIds);
	_parser.parse("player1", player1);
	_parser.parse("player2", player2);
	_parser.parse("vppMultipliers", vppMultipliers);
}

const char *pokerduel::dbm::CreatedDuelInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("handIds", handIds);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player2", player2);
	_jsonstr.compose("vppMultipliers", vppMultipliers);
	return _buf.c_str();
}

void pokerduel::dbm::CreatedDuelInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("handIds", handIds);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player2", player2);
	_jparser.parseByNameThrow("vppMultipliers", vppMultipliers);
}

void pokerduel::dbm::CreatedDuelInfo::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("tableId", tableId);
	_jparser.validateByNameThrow("handIds", handIds);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player2", player2);
	_jparser.validateByNameThrow("vppMultipliers", vppMultipliers);
}

/*static*/ void pokerduel::dbm::CreatedDuelInfo::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.skip(8);  /*tableId*/
	Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser);  /*handIds*/
	DuelPlayer::validateMsg(_parser);  /*player1*/
	DuelPlayer::validateMsg(_parser);  /*player2*/
	_parser.parseStringN(_dummy, 0, "vppMultipliers");  /*vppMultipliers*/
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::clear()
{
	duelId = 0;
	runningState.clear();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::equals(const Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE& _o) const
{
	return duelId == _o.duelId &&
		runningState.equals(_o.runningState);
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_SAVE_RUNNING_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_SAVE_RUNNING_STATE).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("runningState=");
	runningState.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_SAVE_RUNNING_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	runningState.toXmlString("runningState", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("runningState"))
			{
				if(!Atf::AtfTempl< RunningState >::FromXmlString(_value, runningState)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	runningState.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	runningState.parseMsg(_parser);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("runningState", runningState);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("runningState", runningState);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("runningState", runningState);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	RunningState::validateMsg(_parser);  /*runningState*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::equals(const Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_SAVE_RUNNING_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_SAVE_RUNNING_STATE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_SAVE_RUNNING_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                    SingleStateUpdate
//=================================================================

pokerduel::dbm::SingleStateUpdate::SingleStateUpdate()
{
	clear();
}

void pokerduel::dbm::SingleStateUpdate::clear()
{
	userIntId = 0;
	stateKey = 0;
	stateValue.clear();
}

bool pokerduel::dbm::SingleStateUpdate::equals(const SingleStateUpdate& _o) const
{
	return userIntId == _o.userIntId &&
		stateKey == _o.stateKey &&
		stateValue.equals(_o.stateValue);
}

const char *pokerduel::dbm::SingleStateUpdate::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("stateKey=");
	_buf.appendInt(stateKey);
	_buf.append(',');
	_buf.append("stateValue=");
	_buf.append(stateValue);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::dbm::SingleStateUpdate::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("stateKey", stateKey, _buf);
	Atf::XmlElement::encodeAsXmlElement("stateValue", stateValue, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::dbm::SingleStateUpdate::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("userIntId"))
		{
			userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stateKey"))
		{
			stateKey = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stateValue"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, stateValue)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::dbm::SingleStateUpdate::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userIntId);
	_msg.composeINT32(stateKey);
	_msg.composeString(stateValue);
}

void pokerduel::dbm::SingleStateUpdate::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
	_parser.parseINT32(stateKey);
	_parser.parseStringPN(stateValue, 0, "stateValue");
}

void pokerduel::dbm::SingleStateUpdate::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("userIntId", userIntId);
	_parser.parse("stateKey", stateKey);
	_parser.parse("stateValue", stateValue);
}

const char *pokerduel::dbm::SingleStateUpdate::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("stateKey", stateKey);
	_jsonstr.compose("stateValue", stateValue);
	return _buf.c_str();
}

void pokerduel::dbm::SingleStateUpdate::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("stateKey", stateKey);
	_jparser.parseByNameThrow("stateValue", stateValue);
}

void pokerduel::dbm::SingleStateUpdate::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userIntId", userIntId);
	_jparser.validateByNameThrow("stateKey", stateKey);
	_jparser.validateByNameThrow("stateValue", stateValue);
}

/*static*/ void pokerduel::dbm::SingleStateUpdate::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*userIntId*/
	_parser.skip(4);  /*stateKey*/
	_parser.parseStringN(_dummy, 0, "stateValue");  /*stateValue*/
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::clear()
{
	duelId = 0;
	states.clear();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::equals(const Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE& _o) const
{
	return duelId == _o.duelId &&
		states.equals(_o.states);
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_UPDATE_RUNNING_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_UPDATE_RUNNING_STATE).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("states=");
	states.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_UPDATE_RUNNING_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	states.toXmlString("states", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("states"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SingleStateUpdate, 4 > >::FromXmlString(_value, states)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	states.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	states.parseMsg(_parser);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("states", states);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("states", states);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("states", states);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	Atf::LAtfVector< SingleStateUpdate, 4 >::validateMsg(_parser);  /*states*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::equals(const Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_UPDATE_RUNNING_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_UPDATE_RUNNING_STATE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_UPDATE_RUNNING_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::clear()
{
	duelId = 0;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::equals(const Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE& _o) const
{
	return duelId == _o.duelId;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_GET_RUNNING_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_GET_RUNNING_STATE).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_GET_RUNNING_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_GET_RUNNING_STATE
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::clear()
{
	errCode = 0;
	errString.clear();
	duelId = 0;
	runningStates.clear();
	runningStates2.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::equals(const Protocol_DBM_A_PDUEL_GET_RUNNING_STATE& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelId == _o.duelId &&
		runningStates.equals(_o.runningStates) &&
		runningStates2.equals(_o.runningStates2);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_GET_RUNNING_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_GET_RUNNING_STATE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_GET_RUNNING_STATE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("duelId=");
		_buf.appendUint64(duelId);
		_buf.append(',');
		_buf.append("runningStates=");
		runningStates.toTraceString(_buf);
		_buf.append(',');
		_buf.append("runningStates2=");
		runningStates2.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_GET_RUNNING_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
		runningStates.toXmlString("runningStates", _buf);
		runningStates2.toXmlString("runningStates2", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("runningStates"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< RunningState, 4 > >::FromXmlString(_value, runningStates)) return false;
			}
			else if (_element.equals("runningStates2"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SingleStateUpdate, 4 > >::FromXmlString(_value, runningStates2)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeUINT64(duelId);
		runningStates.composeMsg(_msg, _ignoreJSON);
		runningStates2.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
	else
	{
		_parser.parseUINT64(duelId);
		runningStates.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		runningStates2.parseMsg(_parser);
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("duelId", duelId);
		_jsonstr.compose("runningStates", runningStates);
		_jsonstr.compose("runningStates2", runningStates2);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("duelId", duelId);
		_jparser.parseByNameThrow("runningStates", runningStates);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("runningStates2", runningStates2);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
	else
	{
		_jparser.validateByNameThrow("duelId", duelId);
		_jparser.validateByNameThrow("runningStates", runningStates);
		if(_jparser.parseEnded()) return;
		_jparser.validateByNameThrow("runningStates2", runningStates2);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
	else
	{
		_parser.skip(8);  /*duelId*/
		Atf::LAtfVector< RunningState, 4 >::validateMsg(_parser);  /*runningStates*/
		if(_parser.parseEnded()) return;
		Atf::LAtfVector< SingleStateUpdate, 4 >::validateMsg(_parser);  /*runningStates2*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::clear()
{
	newDuelTypes.clear();
	adminUserId.clear();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::equals(const Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES& _o) const
{
	return newDuelTypes.equals(_o.newDuelTypes) &&
		adminUserId.equals(_o.adminUserId);
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_ADD_DUEL_TYPES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_ADD_DUEL_TYPES).append(")");
	_buf.append(',');
	_buf.append("newDuelTypes=");
	newDuelTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("adminUserId=");
	_buf.append(adminUserId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_ADD_DUEL_TYPES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	newDuelTypes.toXmlString("newDuelTypes", _buf);
	Atf::XmlElement::encodeAsXmlElement("adminUserId", adminUserId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("newDuelTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DuelType, 4 > >::FromXmlString(_value, newDuelTypes)) return false;
			}
			else if (_element.equals("adminUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, adminUserId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	newDuelTypes.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::parseMsg(CommMsgParser& _parser)
{
	newDuelTypes.parseMsg(_parser);
	_parser.parseStringPN(adminUserId, 0, "adminUserId");
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("newDuelTypes", newDuelTypes);
	_jsonstr.compose("adminUserId", adminUserId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("newDuelTypes", newDuelTypes);
	_jparser.parseByNameThrow("adminUserId", adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("newDuelTypes", newDuelTypes);
	_jparser.validateByNameThrow("adminUserId", adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	Atf::LAtfVector< DuelType, 4 >::validateMsg(_parser);  /*newDuelTypes*/
	_parser.parseStringN(_dummy, 0, "adminUserId");  /*adminUserId*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::clear()
{
	errCode = 0;
	errString.clear();
	duelTypeIds.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::equals(const Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelTypeIds.equals(_o.duelTypeIds);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_ADD_DUEL_TYPES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_ADD_DUEL_TYPES).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("duelTypeIds=");
		duelTypeIds.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_ADD_DUEL_TYPES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		duelTypeIds.toXmlString("duelTypeIds", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelTypeIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, duelTypeIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		duelTypeIds.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
	else
	{
		duelTypeIds.parseMsg(_parser);
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("duelTypeIds", duelTypeIds);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("duelTypeIds", duelTypeIds);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
	else
	{
		_jparser.validateByNameThrow("duelTypeIds", duelTypeIds);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
	else
	{
		Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser);  /*duelTypeIds*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::clear()
{
	duelTypeId = 0;
	adminUserId.clear();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::equals(const Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE& _o) const
{
	return duelTypeId == _o.duelTypeId &&
		adminUserId.equals(_o.adminUserId);
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_CANCEL_DUEL_TYPE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_CANCEL_DUEL_TYPE).append(")");
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("adminUserId=");
	_buf.append(adminUserId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_CANCEL_DUEL_TYPE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("adminUserId", adminUserId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("adminUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, adminUserId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(duelTypeId);
	_msg.composeString(adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(duelTypeId);
	_parser.parseStringPN(adminUserId, 0, "adminUserId");
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("adminUserId", adminUserId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("adminUserId", adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("adminUserId", adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*duelTypeId*/
	_parser.parseStringN(_dummy, 0, "adminUserId");  /*adminUserId*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::equals(const Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_CANCEL_DUEL_TYPE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_CANCEL_DUEL_TYPE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_CANCEL_DUEL_TYPE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::clear()
{
	duelTypeId = 0;
	newStatus = 0;
	adminUserId.clear();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::equals(const Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS& _o) const
{
	return duelTypeId == _o.duelTypeId &&
		newStatus == _o.newStatus &&
		adminUserId.equals(_o.adminUserId);
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS).append(")");
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("newStatus=");
	_buf.appendInt(newStatus);
	_buf.append(',');
	_buf.append("adminUserId=");
	_buf.append(adminUserId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("newStatus", newStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("adminUserId", adminUserId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("newStatus"))
			{
				newStatus = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("adminUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, adminUserId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(duelTypeId);
	_msg.composeINT32(newStatus);
	_msg.composeString(adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(duelTypeId);
	_parser.parseINT32(newStatus);
	_parser.parseStringPN(adminUserId, 0, "adminUserId");
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("newStatus", newStatus);
	_jsonstr.compose("adminUserId", adminUserId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("newStatus", newStatus);
	_jparser.parseByNameThrow("adminUserId", adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("newStatus", newStatus);
	_jparser.validateByNameThrow("adminUserId", adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*duelTypeId*/
	_parser.skip(4);  /*newStatus*/
	_parser.parseStringN(_dummy, 0, "adminUserId");  /*adminUserId*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::equals(const Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::clear()
{
	duelId = 0;
	newStatus = 0;
	adminId.clear();
	when.setNull();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::equals(const Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS& _o) const
{
	return duelId == _o.duelId &&
		newStatus == _o.newStatus &&
		adminId.equals(_o.adminId) &&
		when.equals(_o.when);
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_UPDATE_DUEL_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_UPDATE_DUEL_STATUS).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("newStatus=");
	_buf.appendInt(newStatus);
	_buf.append(',');
	_buf.append("adminId=");
	_buf.append(adminId);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_UPDATE_DUEL_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("newStatus", newStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("adminId", adminId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "when", when);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("newStatus"))
			{
				newStatus = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("adminId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, adminId)) return false;
			}
			else if (_element.equals("when"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, when);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeINT32(newStatus);
	_msg.composeString(adminId);
	_msg.composeSrvTime(when);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseINT32(newStatus);
	_parser.parseStringPN(adminId, 0, "adminId");
	_parser.parseSrvTime(when);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("newStatus", newStatus);
	_jsonstr.compose("adminId", adminId);
	_jsonstr.compose("when", when);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("newStatus", newStatus);
	_jparser.parseByNameThrow("adminId", adminId);
	_jparser.parseByNameThrow("when", when);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("newStatus", newStatus);
	_jparser.validateByNameThrow("adminId", adminId);
	_jparser.validateByNameThrow("when", when);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*newStatus*/
	_parser.parseStringN(_dummy, 0, "adminId");  /*adminId*/
	_parser.skip(8);  /*when*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::equals(const Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_UPDATE_DUEL_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_UPDATE_DUEL_STATUS).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_UPDATE_DUEL_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::clear()
{
	userId1.clear();
	userIntId1 = 0;
	userId2.clear();
	userIntId2 = 0;
	duelTypeId = 0;
	whenOffered.setNull();
	buyInPlusRake = 0;
	currency.clear();
	isPlayMoney = false;
	ticketId1 = 0;
	challengeType = 0;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::equals(const Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE& _o) const
{
	return userId1.equals(_o.userId1) &&
		userIntId1 == _o.userIntId1 &&
		userId2.equals(_o.userId2) &&
		userIntId2 == _o.userIntId2 &&
		duelTypeId == _o.duelTypeId &&
		whenOffered.equals(_o.whenOffered) &&
		buyInPlusRake == _o.buyInPlusRake &&
		currency.equals(_o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		ticketId1 == _o.ticketId1 &&
		challengeType == _o.challengeType;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_CREATE_CHALLENGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_CREATE_CHALLENGE).append(")");
	_buf.append(',');
	_buf.append("userId1=");
	_buf.append(userId1);
	_buf.append(',');
	_buf.append("userIntId1=");
	_buf.appendUint(userIntId1);
	_buf.append(',');
	_buf.append("userId2=");
	_buf.append(userId2);
	_buf.append(',');
	_buf.append("userIntId2=");
	_buf.appendUint(userIntId2);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("whenOffered=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenOffered);
	_buf.append(',');
	_buf.append("buyInPlusRake=");
	_buf.appendInt64(buyInPlusRake);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("ticketId1=");
	_buf.appendUint(ticketId1);
	_buf.append(',');
	_buf.append("challengeType=");
	_buf.appendInt(challengeType);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_CREATE_CHALLENGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId1", userId1, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId1", userIntId1, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId2", userId2, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId2", userIntId2, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenOffered", whenOffered);
	Atf::XmlElement::encodeAsXmlElement("buyInPlusRake", buyInPlusRake, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketId1", ticketId1, _buf);
	Atf::XmlElement::encodeAsXmlElement("challengeType", challengeType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("userId1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId1)) return false;
			}
			else if (_element.equals("userIntId1"))
			{
				userIntId1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId2)) return false;
			}
			else if (_element.equals("userIntId2"))
			{
				userIntId2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("whenOffered"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenOffered);
			}
			else if (_element.equals("buyInPlusRake"))
			{
				buyInPlusRake = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("ticketId1"))
			{
				ticketId1 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("challengeType"))
			{
				challengeType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId1);
	_msg.composeUINT32(userIntId1);
	_msg.composeString(userId2);
	_msg.composeUINT32(userIntId2);
	_msg.composeUINT32(duelTypeId);
	_msg.composeSrvTime(whenOffered);
	_msg.composeINT64(buyInPlusRake);
	_msg.composeString(currency);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeUINT32(ticketId1);
	_msg.composeINT32(challengeType);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringPN(userId1, 0, "userId1");
	_parser.parseUINT32(userIntId1);
	_parser.parseStringPN(userId2, 0, "userId2");
	_parser.parseUINT32(userIntId2);
	_parser.parseUINT32(duelTypeId);
	_parser.parseSrvTime(whenOffered);
	_parser.parseINT64(buyInPlusRake);
	_parser.parseStringPN(currency, 0, "currency");
	_parser.parseBOOL(isPlayMoney);
	_parser.parseUINT32(ticketId1);
	_parser.parseINT32(challengeType);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId1", userId1);
	_jsonstr.compose("userIntId1", userIntId1);
	_jsonstr.compose("userId2", userId2);
	_jsonstr.compose("userIntId2", userIntId2);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("whenOffered", whenOffered);
	_jsonstr.compose("buyInPlusRake", buyInPlusRake);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("ticketId1", ticketId1);
	_jsonstr.compose("challengeType", challengeType);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId1", userId1);
	_jparser.parseByNameThrow("userIntId1", userIntId1);
	_jparser.parseByNameThrow("userId2", userId2);
	_jparser.parseByNameThrow("userIntId2", userIntId2);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("whenOffered", whenOffered);
	_jparser.parseByNameThrow("buyInPlusRake", buyInPlusRake);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("ticketId1", ticketId1);
	_jparser.parseByNameThrow("challengeType", challengeType);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userId1", userId1);
	_jparser.validateByNameThrow("userIntId1", userIntId1);
	_jparser.validateByNameThrow("userId2", userId2);
	_jparser.validateByNameThrow("userIntId2", userIntId2);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("whenOffered", whenOffered);
	_jparser.validateByNameThrow("buyInPlusRake", buyInPlusRake);
	_jparser.validateByNameThrow("currency", currency);
	_jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.validateByNameThrow("ticketId1", ticketId1);
	_jparser.validateByNameThrow("challengeType", challengeType);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.parseStringN(_dummy, 0, "userId1");  /*userId1*/
	_parser.skip(4);  /*userIntId1*/
	_parser.parseStringN(_dummy, 0, "userId2");  /*userId2*/
	_parser.skip(4);  /*userIntId2*/
	_parser.skip(4);  /*duelTypeId*/
	_parser.skip(8);  /*whenOffered*/
	_parser.skip(8);  /*buyInPlusRake*/
	_parser.parseStringN(_dummy, 0, "currency");  /*currency*/
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	_parser.skip(4);  /*ticketId1*/
	_parser.skip(4);  /*challengeType*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_CREATE_CHALLENGE
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::clear()
{
	errCode = 0;
	errString.clear();
	challengeID = 0;
	ticketUsed = false;
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::equals(const Protocol_DBM_A_PDUEL_CREATE_CHALLENGE& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		challengeID == _o.challengeID &&
		ticketUsed == _o.ticketUsed;
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_CREATE_CHALLENGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_CREATE_CHALLENGE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_CREATE_CHALLENGE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("challengeID=");
		_buf.appendUint64(challengeID);
		_buf.append(',');
		_buf.append("ticketUsed=");
		_buf.appendUint(ticketUsed);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_CREATE_CHALLENGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("challengeID", challengeID, _buf);
		Atf::XmlElement::encodeAsXmlElement("ticketUsed", ticketUsed, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("challengeID"))
			{
				challengeID = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ticketUsed"))
			{
				ticketUsed = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeUINT64(challengeID);
		_msg.composeBOOL(ticketUsed);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
	else
	{
		_parser.parseUINT64(challengeID);
		_parser.parseBOOL(ticketUsed);
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("challengeID", challengeID);
		_jsonstr.compose("ticketUsed", ticketUsed);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("challengeID", challengeID);
		_jparser.parseByNameThrow("ticketUsed", ticketUsed);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
	else
	{
		_jparser.validateByNameThrow("challengeID", challengeID);
		_jparser.validateByNameThrow("ticketUsed", ticketUsed);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
	else
	{
		_parser.skip(8);  /*challengeID*/
		bool ticketUsed; _parser.parseBOOL(ticketUsed);
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::clear()
{
	challengeID = 0;
	whenResponded.setNull();
	timeBankInSeconds = 0;
	siteMask = 0;
	numHands = 0;
	vppMultipliers.clear();
	ticketIdPlayer2 = 0;
	player2.clear();
	userIntId2 = 0;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::equals(const Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE& _o) const
{
	return challengeID == _o.challengeID &&
		whenResponded.equals(_o.whenResponded) &&
		timeBankInSeconds == _o.timeBankInSeconds &&
		siteMask == _o.siteMask &&
		numHands == _o.numHands &&
		vppMultipliers.equals(_o.vppMultipliers) &&
		ticketIdPlayer2 == _o.ticketIdPlayer2 &&
		player2.equals(_o.player2) &&
		userIntId2 == _o.userIntId2;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_ACCEPT_CHALLENGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_ACCEPT_CHALLENGE).append(")");
	_buf.append(',');
	_buf.append("challengeID=");
	_buf.appendUint64(challengeID);
	_buf.append(',');
	_buf.append("whenResponded=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenResponded);
	_buf.append(',');
	_buf.append("timeBankInSeconds=");
	_buf.appendInt(timeBankInSeconds);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("numHands=");
	_buf.appendInt(numHands);
	_buf.append(',');
	_buf.append("vppMultipliers=");
	_buf.append(vppMultipliers);
	_buf.append(',');
	_buf.append("ticketIdPlayer2=");
	_buf.appendUint(ticketIdPlayer2);
	_buf.append(',');
	_buf.append("player2=");
	_buf.append(player2);
	_buf.append(',');
	_buf.append("userIntId2=");
	_buf.appendUint(userIntId2);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_ACCEPT_CHALLENGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("challengeID", challengeID, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenResponded", whenResponded);
	Atf::XmlElement::encodeAsXmlElement("timeBankInSeconds", timeBankInSeconds, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("numHands", numHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("vppMultipliers", vppMultipliers, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketIdPlayer2", ticketIdPlayer2, _buf);
	Atf::XmlElement::encodeAsXmlElement("player2", player2, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId2", userIntId2, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("challengeID"))
			{
				challengeID = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("whenResponded"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenResponded);
			}
			else if (_element.equals("timeBankInSeconds"))
			{
				timeBankInSeconds = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("siteMask"))
			{
				siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numHands"))
			{
				numHands = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vppMultipliers"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, vppMultipliers)) return false;
			}
			else if (_element.equals("ticketIdPlayer2"))
			{
				ticketIdPlayer2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("player2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, player2)) return false;
			}
			else if (_element.equals("userIntId2"))
			{
				userIntId2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(challengeID);
	_msg.composeSrvTime(whenResponded);
	_msg.composeINT32(timeBankInSeconds);
	_msg.composeUINT32(siteMask);
	_msg.composeINT32(numHands);
	_msg.composeString(vppMultipliers);
	_msg.composeUINT32(ticketIdPlayer2);
	_msg.composeString(player2);
	_msg.composeUINT32(userIntId2);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(challengeID);
	_parser.parseSrvTime(whenResponded);
	_parser.parseINT32(timeBankInSeconds);
	_parser.parseUINT32(siteMask);
	_parser.parseINT32(numHands);
	_parser.parseStringPN(vppMultipliers, 0, "vppMultipliers");
	_parser.parseUINT32(ticketIdPlayer2);
	_parser.parseStringPN(player2, 0, "player2");
	_parser.parseUINT32(userIntId2);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeID", challengeID);
	_jsonstr.compose("whenResponded", whenResponded);
	_jsonstr.compose("timeBankInSeconds", timeBankInSeconds);
	_jsonstr.compose("siteMask", siteMask);
	_jsonstr.compose("numHands", numHands);
	_jsonstr.compose("vppMultipliers", vppMultipliers);
	_jsonstr.compose("ticketIdPlayer2", ticketIdPlayer2);
	_jsonstr.compose("player2", player2);
	_jsonstr.compose("userIntId2", userIntId2);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeID", challengeID);
	_jparser.parseByNameThrow("whenResponded", whenResponded);
	_jparser.parseByNameThrow("timeBankInSeconds", timeBankInSeconds);
	_jparser.parseByNameThrow("siteMask", siteMask);
	_jparser.parseByNameThrow("numHands", numHands);
	_jparser.parseByNameThrow("vppMultipliers", vppMultipliers);
	_jparser.parseByNameThrow("ticketIdPlayer2", ticketIdPlayer2);
	_jparser.parseByNameThrow("player2", player2);
	_jparser.parseByNameThrow("userIntId2", userIntId2);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeID", challengeID);
	_jparser.validateByNameThrow("whenResponded", whenResponded);
	_jparser.validateByNameThrow("timeBankInSeconds", timeBankInSeconds);
	_jparser.validateByNameThrow("siteMask", siteMask);
	_jparser.validateByNameThrow("numHands", numHands);
	_jparser.validateByNameThrow("vppMultipliers", vppMultipliers);
	_jparser.validateByNameThrow("ticketIdPlayer2", ticketIdPlayer2);
	_jparser.validateByNameThrow("player2", player2);
	_jparser.validateByNameThrow("userIntId2", userIntId2);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*challengeID*/
	_parser.skip(8);  /*whenResponded*/
	_parser.skip(4);  /*timeBankInSeconds*/
	_parser.skip(4);  /*siteMask*/
	_parser.skip(4);  /*numHands*/
	_parser.parseStringN(_dummy, 0, "vppMultipliers");  /*vppMultipliers*/
	_parser.skip(4);  /*ticketIdPlayer2*/
	_parser.parseStringN(_dummy, 0, "player2");  /*player2*/
	_parser.skip(4);  /*userIntId2*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::clear()
{
	errCode = 0;
	errString.clear();
	newDuelInfo.clear();
	player2TicketUsed = false;
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::equals(const Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		newDuelInfo.equals(_o.newDuelInfo) &&
		player2TicketUsed == _o.player2TicketUsed;
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_ACCEPT_CHALLENGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_ACCEPT_CHALLENGE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("newDuelInfo=");
		newDuelInfo.toTraceString(_buf);
		_buf.append(',');
		_buf.append("player2TicketUsed=");
		_buf.appendUint(player2TicketUsed);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_ACCEPT_CHALLENGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		newDuelInfo.toXmlString("newDuelInfo", _buf);
		Atf::XmlElement::encodeAsXmlElement("player2TicketUsed", player2TicketUsed, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("newDuelInfo"))
			{
				if(!Atf::AtfTempl< CreatedDuelInfo >::FromXmlString(_value, newDuelInfo)) return false;
			}
			else if (_element.equals("player2TicketUsed"))
			{
				player2TicketUsed = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		newDuelInfo.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(player2TicketUsed);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
	else
	{
		newDuelInfo.parseMsg(_parser);
		_parser.parseBOOL(player2TicketUsed);
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("newDuelInfo", newDuelInfo);
		_jsonstr.compose("player2TicketUsed", player2TicketUsed);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("newDuelInfo", newDuelInfo);
		_jparser.parseByNameThrow("player2TicketUsed", player2TicketUsed);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
	else
	{
		_jparser.validateByNameThrow("newDuelInfo", newDuelInfo);
		_jparser.validateByNameThrow("player2TicketUsed", player2TicketUsed);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
	else
	{
		CreatedDuelInfo::validateMsg(_parser);  /*newDuelInfo*/
		bool player2TicketUsed; _parser.parseBOOL(player2TicketUsed);
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::clear()
{
	challengeID = 0;
	challengeResponse = 0;
	whenResponded.setNull();
	adminUserId.clear();
	adminUserIntId = 0;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::equals(const Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE& _o) const
{
	return challengeID == _o.challengeID &&
		challengeResponse == _o.challengeResponse &&
		whenResponded.equals(_o.whenResponded) &&
		adminUserId.equals(_o.adminUserId) &&
		adminUserIntId == _o.adminUserIntId;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_CANCEL_CHALLENGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_CANCEL_CHALLENGE).append(")");
	_buf.append(',');
	_buf.append("challengeID=");
	_buf.appendUint64(challengeID);
	_buf.append(',');
	_buf.append("challengeResponse=");
	_buf.appendInt(challengeResponse);
	_buf.append(',');
	_buf.append("whenResponded=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenResponded);
	_buf.append(',');
	_buf.append("adminUserId=");
	_buf.append(adminUserId);
	_buf.append(',');
	_buf.append("adminUserIntId=");
	_buf.appendUint(adminUserIntId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_CANCEL_CHALLENGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("challengeID", challengeID, _buf);
	Atf::XmlElement::encodeAsXmlElement("challengeResponse", challengeResponse, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenResponded", whenResponded);
	Atf::XmlElement::encodeAsXmlElement("adminUserId", adminUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("adminUserIntId", adminUserIntId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("challengeID"))
			{
				challengeID = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("challengeResponse"))
			{
				challengeResponse = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("whenResponded"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenResponded);
			}
			else if (_element.equals("adminUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, adminUserId)) return false;
			}
			else if (_element.equals("adminUserIntId"))
			{
				adminUserIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(challengeID);
	_msg.composeINT32(challengeResponse);
	_msg.composeSrvTime(whenResponded);
	_msg.composeString(adminUserId);
	_msg.composeUINT32(adminUserIntId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(challengeID);
	_parser.parseINT32(challengeResponse);
	_parser.parseSrvTime(whenResponded);
	_parser.parseStringPN(adminUserId, 0, "adminUserId");
	_parser.parseUINT32(adminUserIntId);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeID", challengeID);
	_jsonstr.compose("challengeResponse", challengeResponse);
	_jsonstr.compose("whenResponded", whenResponded);
	_jsonstr.compose("adminUserId", adminUserId);
	_jsonstr.compose("adminUserIntId", adminUserIntId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeID", challengeID);
	_jparser.parseByNameThrow("challengeResponse", challengeResponse);
	_jparser.parseByNameThrow("whenResponded", whenResponded);
	_jparser.parseByNameThrow("adminUserId", adminUserId);
	_jparser.parseByNameThrow("adminUserIntId", adminUserIntId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeID", challengeID);
	_jparser.validateByNameThrow("challengeResponse", challengeResponse);
	_jparser.validateByNameThrow("whenResponded", whenResponded);
	_jparser.validateByNameThrow("adminUserId", adminUserId);
	_jparser.validateByNameThrow("adminUserIntId", adminUserIntId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*challengeID*/
	_parser.skip(4);  /*challengeResponse*/
	_parser.skip(8);  /*whenResponded*/
	_parser.parseStringN(_dummy, 0, "adminUserId");  /*adminUserId*/
	_parser.skip(4);  /*adminUserIntId*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::equals(const Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_CANCEL_CHALLENGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_CANCEL_CHALLENGE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_CANCEL_CHALLENGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::clear()
{
	duelId = 0;
	playerUserId.clear();
	playerScore = 0;
	isPlaymoney = false;
	currency.clear();
	award = 0;
	fppReward = 0;
	isLastUser = false;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::equals(const Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT& _o) const
{
	return duelId == _o.duelId &&
		playerUserId.equals(_o.playerUserId) &&
		playerScore == _o.playerScore &&
		isPlaymoney == _o.isPlaymoney &&
		currency.equals(_o.currency) &&
		award == _o.award &&
		fppReward == _o.fppReward &&
		isLastUser == _o.isLastUser;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_SAVE_DUEL_RESULT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_SAVE_DUEL_RESULT).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("playerUserId=");
	_buf.append(playerUserId);
	_buf.append(',');
	_buf.append("playerScore=");
	_buf.appendInt(playerScore);
	_buf.append(',');
	_buf.append("isPlaymoney=");
	_buf.appendUint(isPlaymoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("award=");
	_buf.appendInt64(award);
	_buf.append(',');
	_buf.append("fppReward=");
	_buf.appendInt64(fppReward);
	_buf.append(',');
	_buf.append("isLastUser=");
	_buf.appendUint(isLastUser);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_SAVE_DUEL_RESULT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerUserId", playerUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerScore", playerScore, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlaymoney", isPlaymoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("award", award, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppReward", fppReward, _buf);
	Atf::XmlElement::encodeAsXmlElement("isLastUser", isLastUser, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playerUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, playerUserId)) return false;
			}
			else if (_element.equals("playerScore"))
			{
				playerScore = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlaymoney"))
			{
				isPlaymoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("award"))
			{
				award = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fppReward"))
			{
				fppReward = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isLastUser"))
			{
				isLastUser = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(playerUserId);
	_msg.composeINT32(playerScore);
	_msg.composeBOOL(isPlaymoney);
	_msg.composeString(currency);
	_msg.composeINT64(award);
	_msg.composeINT64(fppReward);
	_msg.composeBOOL(isLastUser);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(playerUserId, 0, "playerUserId");
	_parser.parseINT32(playerScore);
	_parser.parseBOOL(isPlaymoney);
	_parser.parseStringPN(currency, 0, "currency");
	_parser.parseINT64(award);
	_parser.parseINT64(fppReward);
	_parser.parseBOOL(isLastUser);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("playerUserId", playerUserId);
	_jsonstr.compose("playerScore", playerScore);
	_jsonstr.compose("isPlaymoney", isPlaymoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("award", award);
	_jsonstr.compose("fppReward", fppReward);
	_jsonstr.compose("isLastUser", isLastUser);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("playerUserId", playerUserId);
	_jparser.parseByNameThrow("playerScore", playerScore);
	_jparser.parseByNameThrow("isPlaymoney", isPlaymoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("award", award);
	_jparser.parseByNameThrow("fppReward", fppReward);
	_jparser.parseByNameThrow("isLastUser", isLastUser);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("playerUserId", playerUserId);
	_jparser.validateByNameThrow("playerScore", playerScore);
	_jparser.validateByNameThrow("isPlaymoney", isPlaymoney);
	_jparser.validateByNameThrow("currency", currency);
	_jparser.validateByNameThrow("award", award);
	_jparser.validateByNameThrow("fppReward", fppReward);
	_jparser.validateByNameThrow("isLastUser", isLastUser);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "playerUserId");  /*playerUserId*/
	_parser.skip(4);  /*playerScore*/
	bool isPlaymoney; _parser.parseBOOL(isPlaymoney);
	_parser.parseStringN(_dummy, 0, "currency");  /*currency*/
	_parser.skip(8);  /*award*/
	_parser.skip(8);  /*fppReward*/
	bool isLastUser; _parser.parseBOOL(isLastUser);
}

//=================================================================
//                Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::equals(const Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_SAVE_DUEL_RESULT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_SAVE_DUEL_RESULT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_SAVE_DUEL_RESULT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                    PlayerTimeBank
//=================================================================

pokerduel::dbm::PlayerTimeBank::PlayerTimeBank()
{
	clear();
}

void pokerduel::dbm::PlayerTimeBank::clear()
{
	userId.clear();
	timeBankInSec = 0;
}

bool pokerduel::dbm::PlayerTimeBank::equals(const PlayerTimeBank& _o) const
{
	return userId.equals(_o.userId) &&
		timeBankInSec == _o.timeBankInSec;
}

const char *pokerduel::dbm::PlayerTimeBank::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("timeBankInSec=");
	_buf.appendInt(timeBankInSec);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::dbm::PlayerTimeBank::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeBankInSec", timeBankInSec, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::dbm::PlayerTimeBank::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("timeBankInSec"))
		{
			timeBankInSec = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::dbm::PlayerTimeBank::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(timeBankInSec);
}

void pokerduel::dbm::PlayerTimeBank::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseINT32(timeBankInSec);
}

void pokerduel::dbm::PlayerTimeBank::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("userId", userId);
	_parser.parse("timeBankInSec", timeBankInSec);
}

const char *pokerduel::dbm::PlayerTimeBank::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("timeBankInSec", timeBankInSec);
	return _buf.c_str();
}

void pokerduel::dbm::PlayerTimeBank::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("timeBankInSec", timeBankInSec);
}

void pokerduel::dbm::PlayerTimeBank::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("timeBankInSec", timeBankInSec);
}

/*static*/ void pokerduel::dbm::PlayerTimeBank::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*timeBankInSec*/
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::clear()
{
	duelId = 0;
	players.clear();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::equals(const Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK& _o) const
{
	return duelId == _o.duelId &&
		players.equals(_o.players);
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("players=");
	players.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	players.toXmlString("players", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("players"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerTimeBank, 4 > >::FromXmlString(_value, players)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	players.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	players.parseMsg(_parser);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("players", players);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("players", players);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("players", players);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	Atf::LAtfVector< PlayerTimeBank, 4 >::validateMsg(_parser);  /*players*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::equals(const Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_CANCEL_DUEL
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::Protocol_DBM_Q_PDUEL_CANCEL_DUEL()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::clear()
{
	duelId = 0;
	duelTypeId = 0;
	adminUserId.clear();
	adminUserIntId = 0;
	when.setNull();
	dbmId = 0;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::equals(const Protocol_DBM_Q_PDUEL_CANCEL_DUEL& _o) const
{
	return duelId == _o.duelId &&
		duelTypeId == _o.duelTypeId &&
		adminUserId.equals(_o.adminUserId) &&
		adminUserIntId == _o.adminUserIntId &&
		when.equals(_o.when) &&
		dbmId == _o.dbmId;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_CANCEL_DUEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_CANCEL_DUEL*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_CANCEL_DUEL).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("adminUserId=");
	_buf.append(adminUserId);
	_buf.append(',');
	_buf.append("adminUserIntId=");
	_buf.appendUint(adminUserIntId);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("dbmId=");
	_buf.appendInt(dbmId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_CANCEL_DUEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("adminUserId", adminUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("adminUserIntId", adminUserIntId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("dbmId", dbmId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("adminUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, adminUserId)) return false;
			}
			else if (_element.equals("adminUserIntId"))
			{
				adminUserIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("when"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, when);
			}
			else if (_element.equals("dbmId"))
			{
				dbmId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeUINT32(duelTypeId);
	_msg.composeString(adminUserId);
	_msg.composeUINT32(adminUserIntId);
	_msg.composeSrvTime(when);
	_msg.composeINT32(dbmId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseUINT32(duelTypeId);
	_parser.parseStringPN(adminUserId, 0, "adminUserId");
	_parser.parseUINT32(adminUserIntId);
	_parser.parseSrvTime(when);
	_parser.parseINT32(dbmId);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("adminUserId", adminUserId);
	_jsonstr.compose("adminUserIntId", adminUserIntId);
	_jsonstr.compose("when", when);
	_jsonstr.compose("dbmId", dbmId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("adminUserId", adminUserId);
	_jparser.parseByNameThrow("adminUserIntId", adminUserIntId);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("dbmId", dbmId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("adminUserId", adminUserId);
	_jparser.validateByNameThrow("adminUserIntId", adminUserIntId);
	_jparser.validateByNameThrow("when", when);
	_jparser.validateByNameThrow("dbmId", dbmId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*duelTypeId*/
	_parser.parseStringN(_dummy, 0, "adminUserId");  /*adminUserId*/
	_parser.skip(4);  /*adminUserIntId*/
	_parser.skip(8);  /*when*/
	_parser.skip(4);  /*dbmId*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_CANCEL_DUEL
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::Protocol_DBM_A_PDUEL_CANCEL_DUEL()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::equals(const Protocol_DBM_A_PDUEL_CANCEL_DUEL& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_CANCEL_DUEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_CANCEL_DUEL*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_CANCEL_DUEL).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_CANCEL_DUEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_A_ALLOWED_AT_PLAY
//=================================================================

pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::Protocol_DBM_A_ALLOWED_AT_PLAY()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::clear()
{
	errCode = 0;
	errString.clear();
	availChips = 0;
	enoughOnAllAccounts = false;
	ticketId = 0;
	userIntId = 0;
	imageId = 0;
}

bool pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::equals(const Protocol_DBM_A_ALLOWED_AT_PLAY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		availChips == _o.availChips &&
		enoughOnAllAccounts == _o.enoughOnAllAccounts &&
		ticketId == _o.ticketId &&
		userIntId == _o.userIntId &&
		imageId == _o.imageId;
}

bool pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_ALLOWED_AT_PLAY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_ALLOWED_AT_PLAY*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_ALLOWED_AT_PLAY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("availChips=");
		_buf.appendInt64(availChips);
		_buf.append(',');
		_buf.append("enoughOnAllAccounts=");
		_buf.appendUint(enoughOnAllAccounts);
	}
	else
	{
		_buf.append(',');
		_buf.append("ticketId=");
		_buf.appendUint(ticketId);
	}
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_ALLOWED_AT_PLAY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("availChips", availChips, _buf);
		Atf::XmlElement::encodeAsXmlElement("enoughOnAllAccounts", enoughOnAllAccounts, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("availChips"))
			{
				availChips = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("enoughOnAllAccounts"))
			{
				enoughOnAllAccounts = (*_value.ptr() == '1');
			}
			else if (_element.equals("ticketId"))
			{
				ticketId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("imageId"))
			{
				imageId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeINT64(availChips);
		_msg.composeBOOL(enoughOnAllAccounts);
	}
	else
	{
		_msg.composeUINT32(ticketId);
	}
	_msg.composeUINT32(userIntId);
	_msg.composeUINT32(imageId);
}

void pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseINT64(availChips);
		_parser.parseBOOL(enoughOnAllAccounts);
	}
	else
	{
		_parser.parseUINT32(ticketId);
	}
	_parser.parseUINT32(userIntId);
	_parser.parseUINT32(imageId);
}

const char *pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("availChips", availChips);
		_jsonstr.compose("enoughOnAllAccounts", enoughOnAllAccounts);
	}
	else
	{
		_jsonstr.compose("ticketId", ticketId);
	}
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("imageId", imageId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("availChips", availChips);
		_jparser.parseByNameThrow("enoughOnAllAccounts", enoughOnAllAccounts);
	}
	else
	{
		_jparser.parseByNameThrow("ticketId", ticketId);
	}
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("imageId", imageId);
}

void pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("availChips", availChips);
		_jparser.validateByNameThrow("enoughOnAllAccounts", enoughOnAllAccounts);
	}
	else
	{
		_jparser.validateByNameThrow("ticketId", ticketId);
	}
	_jparser.validateByNameThrow("userIntId", userIntId);
	_jparser.validateByNameThrow("imageId", imageId);
}

void pokerduel::dbm::Protocol_DBM_A_ALLOWED_AT_PLAY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.skip(8);  /*availChips*/
		bool enoughOnAllAccounts; _parser.parseBOOL(enoughOnAllAccounts);
	}
	else
	{
		_parser.skip(4);  /*ticketId*/
	}
	_parser.skip(4);  /*userIntId*/
	_parser.skip(4);  /*imageId*/
}

//=================================================================
//                Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::clear()
{
	duelId = 0;
	logLocation.clear();
}

bool pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::equals(const Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION& _o) const
{
	return duelId == _o.duelId &&
		logLocation.equals(_o.logLocation);
}

bool pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_UPDATE_DUEL_LOGLOCATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_UPDATE_DUEL_LOGLOCATION).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("logLocation=");
	_buf.append(logLocation);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_UPDATE_DUEL_LOGLOCATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("logLocation", logLocation, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("logLocation"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, logLocation)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(logLocation);
}

void pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(logLocation, 0, "logLocation");
}

const char *pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("logLocation", logLocation);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("logLocation", logLocation);
}

void pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("logLocation", logLocation);
}

void pokerduel::dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "logLocation");  /*logLocation*/
}

//=================================================================
//                Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION
//=================================================================

pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::equals(const Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_UPDATE_DUEL_LOGLOCATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_UPDATE_DUEL_LOGLOCATION).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_UPDATE_DUEL_LOGLOCATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::clear()
{
	duelId = 0;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::equals(const Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL& _o) const
{
	return duelId == _o.duelId;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_UNPUBLISH_DUEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_UNPUBLISH_DUEL).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_UNPUBLISH_DUEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::equals(const Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_UNPUBLISH_DUEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_UNPUBLISH_DUEL).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_UNPUBLISH_DUEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::clear()
{
	duelId = 0;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::equals(const Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL& _o) const
{
	return duelId == _o.duelId;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_GET_LASTCHATORDINAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_GET_LASTCHATORDINAL).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_GET_LASTCHATORDINAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::clear()
{
	errCode = 0;
	errString.clear();
	duelId = 0;
	lastChatOrdinal = 0;
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::equals(const Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelId == _o.duelId &&
		lastChatOrdinal == _o.lastChatOrdinal;
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_GET_LASTCHATORDINAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_GET_LASTCHATORDINAL).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("duelId=");
		_buf.appendUint64(duelId);
		_buf.append(',');
		_buf.append("lastChatOrdinal=");
		_buf.appendInt(lastChatOrdinal);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_GET_LASTCHATORDINAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
		Atf::XmlElement::encodeAsXmlElement("lastChatOrdinal", lastChatOrdinal, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("lastChatOrdinal"))
			{
				lastChatOrdinal = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeUINT64(duelId);
		_msg.composeINT32(lastChatOrdinal);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
	else
	{
		_parser.parseUINT64(duelId);
		_parser.parseINT32(lastChatOrdinal);
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("duelId", duelId);
		_jsonstr.compose("lastChatOrdinal", lastChatOrdinal);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("duelId", duelId);
		_jparser.parseByNameThrow("lastChatOrdinal", lastChatOrdinal);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
	else
	{
		_jparser.validateByNameThrow("duelId", duelId);
		_jparser.validateByNameThrow("lastChatOrdinal", lastChatOrdinal);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
	else
	{
		_parser.skip(8);  /*duelId*/
		_parser.skip(4);  /*lastChatOrdinal*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::clear()
{
	duelId = 0;
	tableId = 0;
	from = 0;
	to = 0;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::equals(const Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS& _o) const
{
	return duelId == _o.duelId &&
		tableId == _o.tableId &&
		from == _o.from &&
		to == _o.to;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_LOAD_CHAT_ITEMS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_LOAD_CHAT_ITEMS).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("from=");
	_buf.appendInt(from);
	_buf.append(',');
	_buf.append("to=");
	_buf.appendInt(to);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_LOAD_CHAT_ITEMS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("from", from, _buf);
	Atf::XmlElement::encodeAsXmlElement("to", to, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("from"))
			{
				from = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("to"))
			{
				to = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeUINT64(tableId);
	_msg.composeINT32(from);
	_msg.composeINT32(to);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseUINT64(tableId);
	_parser.parseINT32(from);
	_parser.parseINT32(to);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("from", from);
	_jsonstr.compose("to", to);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("from", from);
	_jparser.parseByNameThrow("to", to);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("tableId", tableId);
	_jparser.validateByNameThrow("from", from);
	_jparser.validateByNameThrow("to", to);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(8);  /*tableId*/
	_parser.skip(4);  /*from*/
	_parser.skip(4);  /*to*/
}

//=================================================================
//                    DuelChatItem
//=================================================================

pokerduel::dbm::DuelChatItem::DuelChatItem()
{
	clear();
}

void pokerduel::dbm::DuelChatItem::clear()
{
	ordinal = 0;
	userId.clear();
	when.setNull();
	content.clear();
}

bool pokerduel::dbm::DuelChatItem::equals(const DuelChatItem& _o) const
{
	return ordinal == _o.ordinal &&
		userId.equals(_o.userId) &&
		when.equals(_o.when) &&
		content.equals(_o.content);
}

const char *pokerduel::dbm::DuelChatItem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ordinal=");
	_buf.appendInt(ordinal);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("content=");
	_buf.append(content);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::dbm::DuelChatItem::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ordinal", ordinal, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("content", content, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::dbm::DuelChatItem::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("ordinal"))
		{
			ordinal = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("content"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, content)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::dbm::DuelChatItem::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(ordinal);
	_msg.composeString(userId);
	_msg.composeSrvTime(when);
	_msg.composeString(content);
}

void pokerduel::dbm::DuelChatItem::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(ordinal);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseSrvTime(when);
	_parser.parseStringPN(content, 0, "content");
}

void pokerduel::dbm::DuelChatItem::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("ordinal", ordinal);
	_parser.parse("userId", userId);
	_parser.parse("when", when);
	_parser.parse("content", content);
}

const char *pokerduel::dbm::DuelChatItem::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ordinal", ordinal);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("when", when);
	_jsonstr.compose("content", content);
	return _buf.c_str();
}

void pokerduel::dbm::DuelChatItem::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ordinal", ordinal);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("content", content);
}

void pokerduel::dbm::DuelChatItem::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("ordinal", ordinal);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("when", when);
	_jparser.validateByNameThrow("content", content);
}

/*static*/ void pokerduel::dbm::DuelChatItem::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*ordinal*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(8);  /*when*/
	_parser.parseStringN(_dummy, 0, "content");  /*content*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::clear()
{
	errCode = 0;
	errString.clear();
	duelId = 0;
	chats.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::equals(const Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelId == _o.duelId &&
		chats.equals(_o.chats);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_LOAD_CHAT_ITEMS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_LOAD_CHAT_ITEMS).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("duelId=");
		_buf.appendUint64(duelId);
		_buf.append(',');
		_buf.append("chats=");
		chats.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_LOAD_CHAT_ITEMS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
		chats.toXmlString("chats", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chats"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DuelChatItem , 4 > >::FromXmlString(_value, chats)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeUINT64(duelId);
		chats.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
	else
	{
		_parser.parseUINT64(duelId);
		chats.parseMsg(_parser);
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("duelId", duelId);
		_jsonstr.compose("chats", chats);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("duelId", duelId);
		_jparser.parseByNameThrow("chats", chats);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
	else
	{
		_jparser.validateByNameThrow("duelId", duelId);
		_jparser.validateByNameThrow("chats", chats);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
	else
	{
		_parser.skip(8);  /*duelId*/
		Atf::LAtfVector< DuelChatItem , 4 >::validateMsg(_parser);  /*chats*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::clear()
{
	duelId = 0;
	userId.clear();
	clientChatLastOrdinal = 0;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::equals(const Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId) &&
		clientChatLastOrdinal == _o.clientChatLastOrdinal;
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("clientChatLastOrdinal=");
	_buf.appendUint(clientChatLastOrdinal);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientChatLastOrdinal", clientChatLastOrdinal, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("clientChatLastOrdinal"))
			{
				clientChatLastOrdinal = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
	_msg.composeUINT32(clientChatLastOrdinal);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseUINT32(clientChatLastOrdinal);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("clientChatLastOrdinal", clientChatLastOrdinal);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("clientChatLastOrdinal", clientChatLastOrdinal);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("clientChatLastOrdinal", clientChatLastOrdinal);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*clientChatLastOrdinal*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::equals(const Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE
//=================================================================

pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::clear()
{
	duelTypeId = 0;
	tournFlags = 0;
	admissions.clear();
	adminUserId.clear();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::equals(const Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE& _o) const
{
	return duelTypeId == _o.duelTypeId &&
		tournFlags == _o.tournFlags &&
		admissions.equals(_o.admissions) &&
		adminUserId.equals(_o.adminUserId);
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_Q_PDUEL_UPDATE_DUELTYPE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_Q_PDUEL_UPDATE_DUELTYPE).append(")");
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("tournFlags=");
	_buf.appendUint(tournFlags);
	_buf.append(',');
	_buf.append("admissions=");
	admissions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("adminUserId=");
	_buf.append(adminUserId);
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_Q_PDUEL_UPDATE_DUELTYPE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFlags", tournFlags, _buf);
	admissions.toXmlString("admissions", _buf);
	Atf::XmlElement::encodeAsXmlElement("adminUserId", adminUserId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFlags"))
			{
				tournFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("admissions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, admissions)) return false;
			}
			else if (_element.equals("adminUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, adminUserId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(duelTypeId);
	_msg.composeUINT32(tournFlags);
	admissions.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(duelTypeId);
	_parser.parseUINT32(tournFlags);
	admissions.parseMsg(_parser);
	_parser.parseStringPN(adminUserId, 0, "adminUserId");
}

const char *pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("tournFlags", tournFlags);
	_jsonstr.compose("admissions", admissions);
	_jsonstr.compose("adminUserId", adminUserId);
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("tournFlags", tournFlags);
	_jparser.parseByNameThrow("admissions", admissions);
	_jparser.parseByNameThrow("adminUserId", adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("tournFlags", tournFlags);
	_jparser.validateByNameThrow("admissions", admissions);
	_jparser.validateByNameThrow("adminUserId", adminUserId);
}

void pokerduel::dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*duelTypeId*/
	_parser.skip(4);  /*tournFlags*/
	Atf::LAtfVector< PString, 4 >::validateMsg(_parser);  /*admissions*/
	_parser.parseStringN(_dummy, 0, "adminUserId");  /*adminUserId*/
}

//=================================================================
//                Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE
//=================================================================

pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE()
{
	clear();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::equals(const Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::equals(Atf::MessageProtocol* _other) const
{
	if (DBM_A_PDUEL_UPDATE_DUELTYPE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE*)_other));
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(DBM_A_PDUEL_UPDATE_DUELTYPE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(DBM_A_PDUEL_UPDATE_DUELTYPE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                    DServerInitMsg
//=================================================================

pokerduel::dserver::DServerInitMsg::DServerInitMsg()
{
	clear();
}

void pokerduel::dserver::DServerInitMsg::clear()
{
	dlobbyAddress.clear();
	dlobbyInstance.clear();
}

bool pokerduel::dserver::DServerInitMsg::equals(const DServerInitMsg& _o) const
{
	return dlobbyAddress.equals(_o.dlobbyAddress) &&
		dlobbyInstance.equals(_o.dlobbyInstance);
}

const char *pokerduel::dserver::DServerInitMsg::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("dlobbyAddress=");
	_buf.append(dlobbyAddress);
	_buf.append(',');
	_buf.append("dlobbyInstance=");
	_buf.append(dlobbyInstance);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::dserver::DServerInitMsg::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("dlobbyAddress", dlobbyAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("dlobbyInstance", dlobbyInstance, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::dserver::DServerInitMsg::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("dlobbyAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, dlobbyAddress)) return false;
		}
		else if (_element.equals("dlobbyInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, dlobbyInstance)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::dserver::DServerInitMsg::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(dlobbyAddress);
	_msg.composeString(dlobbyInstance);
}

void pokerduel::dserver::DServerInitMsg::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringPN(dlobbyAddress, 0, "dlobbyAddress");
	_parser.parseStringPN(dlobbyInstance, 0, "dlobbyInstance");
}

void pokerduel::dserver::DServerInitMsg::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("dlobbyAddress", dlobbyAddress);
	_parser.parse("dlobbyInstance", dlobbyInstance);
}

const char *pokerduel::dserver::DServerInitMsg::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dlobbyAddress", dlobbyAddress);
	_jsonstr.compose("dlobbyInstance", dlobbyInstance);
	return _buf.c_str();
}

void pokerduel::dserver::DServerInitMsg::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dlobbyAddress", dlobbyAddress);
	_jparser.parseByNameThrow("dlobbyInstance", dlobbyInstance);
}

void pokerduel::dserver::DServerInitMsg::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("dlobbyAddress", dlobbyAddress);
	_jparser.validateByNameThrow("dlobbyInstance", dlobbyInstance);
}

/*static*/ void pokerduel::dserver::DServerInitMsg::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.parseStringN(_dummy, 0, "dlobbyAddress");  /*dlobbyAddress*/
	_parser.parseStringN(_dummy, 0, "dlobbyInstance");  /*dlobbyInstance*/
}

//=================================================================
//                Protocol_MSG_DUEL_SERVER_CONNECTED
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::Protocol_MSG_DUEL_SERVER_CONNECTED()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::equals(const Protocol_MSG_DUEL_SERVER_CONNECTED& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_SERVER_CONNECTED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_SERVER_CONNECTED*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_SERVER_CONNECTED).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_SERVER_CONNECTED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::equals(const Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_SERVER_CONNECTED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_SERVER_CONNECTED_REPLY).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_SERVER_CONNECTED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_SERVER_CREATE_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::clear()
{
	duelId = 0;
	tableId = 0;
	dbmAddress.clear();
	dbmInstance.clear();
	entropyAddress.clear();
	entropyInstance.clear();
	encryptorAddress.clear();
	encryptorInstance.clear();
	isPlayMoney = false;
	numHands = 0;
	smallBlind = 0;
	bigBlind = 0;
	startingChips = 0;
	initTimeBankSecs = 0;
	timeBankIncrementSecs = 0;
	timeOutTimeBankIncrementSecs = 0;
	handResultShowSecs = 0;
	duelTypeId = 0;
	buyIn = 0;
	rake = 0;
	challengeId = 0;
	areFriends = false;
	currency.clear();
	siteMask = 0;
	handIds.clear();
	player1.clear();
	player2.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::equals(const Protocol_MSG_DUEL_SERVER_CREATE_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		tableId == _o.tableId &&
		dbmAddress.equals(_o.dbmAddress) &&
		dbmInstance.equals(_o.dbmInstance) &&
		entropyAddress.equals(_o.entropyAddress) &&
		entropyInstance.equals(_o.entropyInstance) &&
		encryptorAddress.equals(_o.encryptorAddress) &&
		encryptorInstance.equals(_o.encryptorInstance) &&
		isPlayMoney == _o.isPlayMoney &&
		numHands == _o.numHands &&
		smallBlind == _o.smallBlind &&
		bigBlind == _o.bigBlind &&
		startingChips == _o.startingChips &&
		initTimeBankSecs == _o.initTimeBankSecs &&
		timeBankIncrementSecs == _o.timeBankIncrementSecs &&
		timeOutTimeBankIncrementSecs == _o.timeOutTimeBankIncrementSecs &&
		handResultShowSecs == _o.handResultShowSecs &&
		duelTypeId == _o.duelTypeId &&
		buyIn == _o.buyIn &&
		rake == _o.rake &&
		challengeId == _o.challengeId &&
		areFriends == _o.areFriends &&
		currency.equals(_o.currency) &&
		siteMask == _o.siteMask &&
		handIds.equals(_o.handIds) &&
		player1.equals(_o.player1) &&
		player2.equals(_o.player2);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_SERVER_CREATE_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_SERVER_CREATE_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_SERVER_CREATE_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("dbmAddress=");
	_buf.append(dbmAddress);
	_buf.append(',');
	_buf.append("dbmInstance=");
	_buf.append(dbmInstance);
	_buf.append(',');
	_buf.append("entropyAddress=");
	_buf.append(entropyAddress);
	_buf.append(',');
	_buf.append("entropyInstance=");
	_buf.append(entropyInstance);
	_buf.append(',');
	_buf.append("encryptorAddress=");
	_buf.append(encryptorAddress);
	_buf.append(',');
	_buf.append("encryptorInstance=");
	_buf.append(encryptorInstance);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("numHands=");
	_buf.appendInt(numHands);
	_buf.append(',');
	_buf.append("smallBlind=");
	_buf.appendInt(smallBlind);
	_buf.append(',');
	_buf.append("bigBlind=");
	_buf.appendInt(bigBlind);
	_buf.append(',');
	_buf.append("startingChips=");
	_buf.appendInt(startingChips);
	_buf.append(',');
	_buf.append("initTimeBankSecs=");
	_buf.appendInt(initTimeBankSecs);
	_buf.append(',');
	_buf.append("timeBankIncrementSecs=");
	_buf.appendInt(timeBankIncrementSecs);
	_buf.append(',');
	_buf.append("timeOutTimeBankIncrementSecs=");
	_buf.appendInt(timeOutTimeBankIncrementSecs);
	_buf.append(',');
	_buf.append("handResultShowSecs=");
	_buf.appendInt(handResultShowSecs);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt64(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendInt64(rake);
	_buf.append(',');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("areFriends=");
	_buf.appendUint(areFriends);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("handIds=");
	handIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("player1=");
	player1.toTraceString(_buf);
	_buf.append(',');
	_buf.append("player2=");
	player2.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_SERVER_CREATE_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmAddress", dbmAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmInstance", dbmInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("entropyAddress", entropyAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("entropyInstance", entropyInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("encryptorAddress", encryptorAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("encryptorInstance", encryptorInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("numHands", numHands, _buf);
	Atf::XmlElement::encodeAsXmlElement("smallBlind", smallBlind, _buf);
	Atf::XmlElement::encodeAsXmlElement("bigBlind", bigBlind, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingChips", startingChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("initTimeBankSecs", initTimeBankSecs, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeBankIncrementSecs", timeBankIncrementSecs, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeOutTimeBankIncrementSecs", timeOutTimeBankIncrementSecs, _buf);
	Atf::XmlElement::encodeAsXmlElement("handResultShowSecs", handResultShowSecs, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("areFriends", areFriends, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
	handIds.toXmlString("handIds", _buf);
	player1.toXmlString("player1", _buf);
	player2.toXmlString("player2", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dbmAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, dbmAddress)) return false;
			}
			else if (_element.equals("dbmInstance"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, dbmInstance)) return false;
			}
			else if (_element.equals("entropyAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, entropyAddress)) return false;
			}
			else if (_element.equals("entropyInstance"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, entropyInstance)) return false;
			}
			else if (_element.equals("encryptorAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encryptorAddress)) return false;
			}
			else if (_element.equals("encryptorInstance"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encryptorInstance)) return false;
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("numHands"))
			{
				numHands = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("smallBlind"))
			{
				smallBlind = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("bigBlind"))
			{
				bigBlind = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startingChips"))
			{
				startingChips = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("initTimeBankSecs"))
			{
				initTimeBankSecs = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeBankIncrementSecs"))
			{
				timeBankIncrementSecs = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeOutTimeBankIncrementSecs"))
			{
				timeOutTimeBankIncrementSecs = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("handResultShowSecs"))
			{
				handResultShowSecs = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("buyIn"))
			{
				buyIn = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rake"))
			{
				rake = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("challengeId"))
			{
				challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("areFriends"))
			{
				areFriends = (*_value.ptr() == '1');
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("siteMask"))
			{
				siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("handIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, handIds)) return false;
			}
			else if (_element.equals("player1"))
			{
				if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player1)) return false;
			}
			else if (_element.equals("player2"))
			{
				if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player2)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeUINT64(tableId);
	_msg.composeString(dbmAddress);
	_msg.composeString(dbmInstance);
	_msg.composeString(entropyAddress);
	_msg.composeString(entropyInstance);
	_msg.composeString(encryptorAddress);
	_msg.composeString(encryptorInstance);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeINT32(numHands);
	_msg.composeINT32(smallBlind);
	_msg.composeINT32(bigBlind);
	_msg.composeINT32(startingChips);
	_msg.composeINT32(initTimeBankSecs);
	_msg.composeINT32(timeBankIncrementSecs);
	_msg.composeINT32(timeOutTimeBankIncrementSecs);
	_msg.composeINT32(handResultShowSecs);
	_msg.composeUINT32(duelTypeId);
	_msg.composeINT64(buyIn);
	_msg.composeINT64(rake);
	_msg.composeUINT64(challengeId);
	_msg.composeBOOL(areFriends);
	_msg.composeString(currency);
	_msg.composeUINT32(siteMask);
	handIds.composeMsg(_msg, _ignoreJSON);
	player1.composeMsg(_msg, _ignoreJSON);
	player2.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseUINT64(tableId);
	_parser.parseStringPN(dbmAddress, 0, "dbmAddress");
	_parser.parseStringPN(dbmInstance, 0, "dbmInstance");
	_parser.parseStringPN(entropyAddress, 0, "entropyAddress");
	_parser.parseStringPN(entropyInstance, 0, "entropyInstance");
	_parser.parseStringPN(encryptorAddress, 0, "encryptorAddress");
	_parser.parseStringPN(encryptorInstance, 0, "encryptorInstance");
	_parser.parseBOOL(isPlayMoney);
	_parser.parseINT32(numHands);
	_parser.parseINT32(smallBlind);
	_parser.parseINT32(bigBlind);
	_parser.parseINT32(startingChips);
	_parser.parseINT32(initTimeBankSecs);
	_parser.parseINT32(timeBankIncrementSecs);
	_parser.parseINT32(timeOutTimeBankIncrementSecs);
	_parser.parseINT32(handResultShowSecs);
	_parser.parseUINT32(duelTypeId);
	_parser.parseINT64(buyIn);
	_parser.parseINT64(rake);
	_parser.parseUINT64(challengeId);
	_parser.parseBOOL(areFriends);
	_parser.parseStringPN(currency, 0, "currency");
	_parser.parseUINT32(siteMask);
	handIds.parseMsg(_parser);
	player1.parseMsg(_parser);
	player2.parseMsg(_parser);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("dbmAddress", dbmAddress);
	_jsonstr.compose("dbmInstance", dbmInstance);
	_jsonstr.compose("entropyAddress", entropyAddress);
	_jsonstr.compose("entropyInstance", entropyInstance);
	_jsonstr.compose("encryptorAddress", encryptorAddress);
	_jsonstr.compose("encryptorInstance", encryptorInstance);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("numHands", numHands);
	_jsonstr.compose("smallBlind", smallBlind);
	_jsonstr.compose("bigBlind", bigBlind);
	_jsonstr.compose("startingChips", startingChips);
	_jsonstr.compose("initTimeBankSecs", initTimeBankSecs);
	_jsonstr.compose("timeBankIncrementSecs", timeBankIncrementSecs);
	_jsonstr.compose("timeOutTimeBankIncrementSecs", timeOutTimeBankIncrementSecs);
	_jsonstr.compose("handResultShowSecs", handResultShowSecs);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("areFriends", areFriends);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("siteMask", siteMask);
	_jsonstr.compose("handIds", handIds);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player2", player2);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("dbmAddress", dbmAddress);
	_jparser.parseByNameThrow("dbmInstance", dbmInstance);
	_jparser.parseByNameThrow("entropyAddress", entropyAddress);
	_jparser.parseByNameThrow("entropyInstance", entropyInstance);
	_jparser.parseByNameThrow("encryptorAddress", encryptorAddress);
	_jparser.parseByNameThrow("encryptorInstance", encryptorInstance);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("numHands", numHands);
	_jparser.parseByNameThrow("smallBlind", smallBlind);
	_jparser.parseByNameThrow("bigBlind", bigBlind);
	_jparser.parseByNameThrow("startingChips", startingChips);
	_jparser.parseByNameThrow("initTimeBankSecs", initTimeBankSecs);
	_jparser.parseByNameThrow("timeBankIncrementSecs", timeBankIncrementSecs);
	_jparser.parseByNameThrow("timeOutTimeBankIncrementSecs", timeOutTimeBankIncrementSecs);
	_jparser.parseByNameThrow("handResultShowSecs", handResultShowSecs);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("challengeId", challengeId);
	_jparser.parseByNameThrow("areFriends", areFriends);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("siteMask", siteMask);
	_jparser.parseByNameThrow("handIds", handIds);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player2", player2);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("tableId", tableId);
	_jparser.validateByNameThrow("dbmAddress", dbmAddress);
	_jparser.validateByNameThrow("dbmInstance", dbmInstance);
	_jparser.validateByNameThrow("entropyAddress", entropyAddress);
	_jparser.validateByNameThrow("entropyInstance", entropyInstance);
	_jparser.validateByNameThrow("encryptorAddress", encryptorAddress);
	_jparser.validateByNameThrow("encryptorInstance", encryptorInstance);
	_jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.validateByNameThrow("numHands", numHands);
	_jparser.validateByNameThrow("smallBlind", smallBlind);
	_jparser.validateByNameThrow("bigBlind", bigBlind);
	_jparser.validateByNameThrow("startingChips", startingChips);
	_jparser.validateByNameThrow("initTimeBankSecs", initTimeBankSecs);
	_jparser.validateByNameThrow("timeBankIncrementSecs", timeBankIncrementSecs);
	_jparser.validateByNameThrow("timeOutTimeBankIncrementSecs", timeOutTimeBankIncrementSecs);
	_jparser.validateByNameThrow("handResultShowSecs", handResultShowSecs);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("buyIn", buyIn);
	_jparser.validateByNameThrow("rake", rake);
	_jparser.validateByNameThrow("challengeId", challengeId);
	_jparser.validateByNameThrow("areFriends", areFriends);
	_jparser.validateByNameThrow("currency", currency);
	_jparser.validateByNameThrow("siteMask", siteMask);
	_jparser.validateByNameThrow("handIds", handIds);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player2", player2);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.skip(8);  /*tableId*/
	_parser.parseStringN(_dummy, 0, "dbmAddress");  /*dbmAddress*/
	_parser.parseStringN(_dummy, 0, "dbmInstance");  /*dbmInstance*/
	_parser.parseStringN(_dummy, 0, "entropyAddress");  /*entropyAddress*/
	_parser.parseStringN(_dummy, 0, "entropyInstance");  /*entropyInstance*/
	_parser.parseStringN(_dummy, 0, "encryptorAddress");  /*encryptorAddress*/
	_parser.parseStringN(_dummy, 0, "encryptorInstance");  /*encryptorInstance*/
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	_parser.skip(4);  /*numHands*/
	_parser.skip(4);  /*smallBlind*/
	_parser.skip(4);  /*bigBlind*/
	_parser.skip(4);  /*startingChips*/
	_parser.skip(4);  /*initTimeBankSecs*/
	_parser.skip(4);  /*timeBankIncrementSecs*/
	_parser.skip(4);  /*timeOutTimeBankIncrementSecs*/
	_parser.skip(4);  /*handResultShowSecs*/
	_parser.skip(4);  /*duelTypeId*/
	_parser.skip(8);  /*buyIn*/
	_parser.skip(8);  /*rake*/
	_parser.skip(8);  /*challengeId*/
	bool areFriends; _parser.parseBOOL(areFriends);
	_parser.parseStringN(_dummy, 0, "currency");  /*currency*/
	_parser.skip(4);  /*siteMask*/
	Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser);  /*handIds*/
	DuelPlayer::validateMsg(_parser);  /*player1*/
	DuelPlayer::validateMsg(_parser);  /*player2*/
}

//=================================================================
//                Protocol_MSG_DUEL_SERVER_CREATE_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::Protocol_MSG_DUEL_SERVER_CREATE_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	duelId = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::equals(const Protocol_MSG_DUEL_SERVER_CREATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelId == _o.duelId;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_SERVER_CREATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_SERVER_CREATE_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_SERVER_CREATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_SERVER_CREATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errString);
	_msg.composeUINT64(duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringPN(errString, 0, "errString");
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	_jparser.validateByNameThrow("errString", errString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(2);  /*errCode*/
	_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::equals(const Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_SERVER_CREATE_REPLY_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_SERVER_CREATE_REPLY_ACK).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_SERVER_CREATE_REPLY_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::clear()
{
	duelId = 0;
	dbmAddress.clear();
	dbmInstance.clear();
	entropyAddress.clear();
	entropyInstance.clear();
	encryptorAddress.clear();
	encryptorInstance.clear();
	handResultShowSecs = 0;
	status = 0;
	player1.clear();
	player2.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::equals(const Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		dbmAddress.equals(_o.dbmAddress) &&
		dbmInstance.equals(_o.dbmInstance) &&
		entropyAddress.equals(_o.entropyAddress) &&
		entropyInstance.equals(_o.entropyInstance) &&
		encryptorAddress.equals(_o.encryptorAddress) &&
		encryptorInstance.equals(_o.encryptorInstance) &&
		handResultShowSecs == _o.handResultShowSecs &&
		status == _o.status &&
		player1.equals(_o.player1) &&
		player2.equals(_o.player2);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_RESTORE_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_RESTORE_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("dbmAddress=");
	_buf.append(dbmAddress);
	_buf.append(',');
	_buf.append("dbmInstance=");
	_buf.append(dbmInstance);
	_buf.append(',');
	_buf.append("entropyAddress=");
	_buf.append(entropyAddress);
	_buf.append(',');
	_buf.append("entropyInstance=");
	_buf.append(entropyInstance);
	_buf.append(',');
	_buf.append("encryptorAddress=");
	_buf.append(encryptorAddress);
	_buf.append(',');
	_buf.append("encryptorInstance=");
	_buf.append(encryptorInstance);
	_buf.append(',');
	_buf.append("handResultShowSecs=");
	_buf.appendInt(handResultShowSecs);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("player1=");
	player1.toTraceString(_buf);
	_buf.append(',');
	_buf.append("player2=");
	player2.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_RESTORE_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmAddress", dbmAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmInstance", dbmInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("entropyAddress", entropyAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("entropyInstance", entropyInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("encryptorAddress", encryptorAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("encryptorInstance", encryptorInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("handResultShowSecs", handResultShowSecs, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	player1.toXmlString("player1", _buf);
	player2.toXmlString("player2", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dbmAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, dbmAddress)) return false;
			}
			else if (_element.equals("dbmInstance"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, dbmInstance)) return false;
			}
			else if (_element.equals("entropyAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, entropyAddress)) return false;
			}
			else if (_element.equals("entropyInstance"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, entropyInstance)) return false;
			}
			else if (_element.equals("encryptorAddress"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encryptorAddress)) return false;
			}
			else if (_element.equals("encryptorInstance"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encryptorInstance)) return false;
			}
			else if (_element.equals("handResultShowSecs"))
			{
				handResultShowSecs = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("status"))
			{
				status = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("player1"))
			{
				if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player1)) return false;
			}
			else if (_element.equals("player2"))
			{
				if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player2)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(dbmAddress);
	_msg.composeString(dbmInstance);
	_msg.composeString(entropyAddress);
	_msg.composeString(entropyInstance);
	_msg.composeString(encryptorAddress);
	_msg.composeString(encryptorInstance);
	_msg.composeINT32(handResultShowSecs);
	_msg.composeINT32(status);
	player1.composeMsg(_msg, _ignoreJSON);
	player2.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(dbmAddress, 0, "dbmAddress");
	_parser.parseStringPN(dbmInstance, 0, "dbmInstance");
	_parser.parseStringPN(entropyAddress, 0, "entropyAddress");
	_parser.parseStringPN(entropyInstance, 0, "entropyInstance");
	_parser.parseStringPN(encryptorAddress, 0, "encryptorAddress");
	_parser.parseStringPN(encryptorInstance, 0, "encryptorInstance");
	_parser.parseINT32(handResultShowSecs);
	_parser.parseINT32(status);
	player1.parseMsg(_parser);
	player2.parseMsg(_parser);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("dbmAddress", dbmAddress);
	_jsonstr.compose("dbmInstance", dbmInstance);
	_jsonstr.compose("entropyAddress", entropyAddress);
	_jsonstr.compose("entropyInstance", entropyInstance);
	_jsonstr.compose("encryptorAddress", encryptorAddress);
	_jsonstr.compose("encryptorInstance", encryptorInstance);
	_jsonstr.compose("handResultShowSecs", handResultShowSecs);
	_jsonstr.compose("status", status);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player2", player2);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("dbmAddress", dbmAddress);
	_jparser.parseByNameThrow("dbmInstance", dbmInstance);
	_jparser.parseByNameThrow("entropyAddress", entropyAddress);
	_jparser.parseByNameThrow("entropyInstance", entropyInstance);
	_jparser.parseByNameThrow("encryptorAddress", encryptorAddress);
	_jparser.parseByNameThrow("encryptorInstance", encryptorInstance);
	_jparser.parseByNameThrow("handResultShowSecs", handResultShowSecs);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player2", player2);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("dbmAddress", dbmAddress);
	_jparser.validateByNameThrow("dbmInstance", dbmInstance);
	_jparser.validateByNameThrow("entropyAddress", entropyAddress);
	_jparser.validateByNameThrow("entropyInstance", entropyInstance);
	_jparser.validateByNameThrow("encryptorAddress", encryptorAddress);
	_jparser.validateByNameThrow("encryptorInstance", encryptorInstance);
	_jparser.validateByNameThrow("handResultShowSecs", handResultShowSecs);
	_jparser.validateByNameThrow("status", status);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player2", player2);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "dbmAddress");  /*dbmAddress*/
	_parser.parseStringN(_dummy, 0, "dbmInstance");  /*dbmInstance*/
	_parser.parseStringN(_dummy, 0, "entropyAddress");  /*entropyAddress*/
	_parser.parseStringN(_dummy, 0, "entropyInstance");  /*entropyInstance*/
	_parser.parseStringN(_dummy, 0, "encryptorAddress");  /*encryptorAddress*/
	_parser.parseStringN(_dummy, 0, "encryptorInstance");  /*encryptorInstance*/
	_parser.skip(4);  /*handResultShowSecs*/
	_parser.skip(4);  /*status*/
	DuelPlayer::validateMsg(_parser);  /*player1*/
	DuelPlayer::validateMsg(_parser);  /*player2*/
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	duelId = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::equals(const Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelId == _o.duelId;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_RESTORE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_RESTORE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_RESTORE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errString);
	_msg.composeUINT64(duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringPN(errString, 0, "errString");
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	_jparser.validateByNameThrow("errString", errString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(2);  /*errCode*/
	_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::equals(const Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_RESTORE_REPLY_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_RESTORE_REPLY_ACK).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_RESTORE_REPLY_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::clear()
{
	duelId = 0;
	player1.clear();
	player1Score = 0;
	player2.clear();
	player2Score = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::equals(const Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		player1.equals(_o.player1) &&
		player1Score == _o.player1Score &&
		player2.equals(_o.player2) &&
		player2Score == _o.player2Score;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("player1=");
	_buf.append(player1);
	_buf.append(',');
	_buf.append("player1Score=");
	_buf.appendInt(player1Score);
	_buf.append(',');
	_buf.append("player2=");
	_buf.append(player2);
	_buf.append(',');
	_buf.append("player2Score=");
	_buf.appendInt(player2Score);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("player1", player1, _buf);
	Atf::XmlElement::encodeAsXmlElement("player1Score", player1Score, _buf);
	Atf::XmlElement::encodeAsXmlElement("player2", player2, _buf);
	Atf::XmlElement::encodeAsXmlElement("player2Score", player2Score, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("player1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, player1)) return false;
			}
			else if (_element.equals("player1Score"))
			{
				player1Score = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("player2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, player2)) return false;
			}
			else if (_element.equals("player2Score"))
			{
				player2Score = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(player1);
	_msg.composeINT32(player1Score);
	_msg.composeString(player2);
	_msg.composeINT32(player2Score);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(player1, 0, "player1");
	_parser.parseINT32(player1Score);
	_parser.parseStringPN(player2, 0, "player2");
	_parser.parseINT32(player2Score);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player1Score", player1Score);
	_jsonstr.compose("player2", player2);
	_jsonstr.compose("player2Score", player2Score);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player1Score", player1Score);
	_jparser.parseByNameThrow("player2", player2);
	_jparser.parseByNameThrow("player2Score", player2Score);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player1Score", player1Score);
	_jparser.validateByNameThrow("player2", player2);
	_jparser.validateByNameThrow("player2Score", player2Score);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "player1");  /*player1*/
	_parser.skip(4);  /*player1Score*/
	_parser.parseStringN(_dummy, 0, "player2");  /*player2*/
	_parser.skip(4);  /*player2Score*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	duelId = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelId == _o.duelId;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errString);
	_msg.composeUINT64(duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringPN(errString, 0, "errString");
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	_jparser.validateByNameThrow("errString", errString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(2);  /*errCode*/
	_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::clear()
{
	duelId = 0;
	secondsAfterDuelResultReported = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::equals(const Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		secondsAfterDuelResultReported == _o.secondsAfterDuelResultReported;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("secondsAfterDuelResultReported=");
	_buf.appendInt(secondsAfterDuelResultReported);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("secondsAfterDuelResultReported", secondsAfterDuelResultReported, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("secondsAfterDuelResultReported"))
			{
				secondsAfterDuelResultReported = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeINT32(secondsAfterDuelResultReported);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseINT32(secondsAfterDuelResultReported);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("secondsAfterDuelResultReported", secondsAfterDuelResultReported);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("secondsAfterDuelResultReported", secondsAfterDuelResultReported);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("secondsAfterDuelResultReported", secondsAfterDuelResultReported);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*secondsAfterDuelResultReported*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	duelId = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelId == _o.duelId;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errString);
	_msg.composeUINT64(duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringPN(errString, 0, "errString");
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	_jparser.validateByNameThrow("errString", errString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(2);  /*errCode*/
	_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::clear()
{
	duelId = 0;
	newStatus = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::equals(const Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		newStatus == _o.newStatus;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("newStatus=");
	_buf.appendInt(newStatus);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("newStatus", newStatus, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("newStatus"))
			{
				newStatus = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeINT32(newStatus);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseINT32(newStatus);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("newStatus", newStatus);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("newStatus", newStatus);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("newStatus", newStatus);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*newStatus*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	duelId = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelId == _o.duelId;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("duelId=");
		_buf.appendUint64(duelId);
	}
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeUINT64(duelId);
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
	else
	{
		_parser.parseUINT64(duelId);
	}
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("duelId", duelId);
	}
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("duelId", duelId);
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
	else
	{
		_jparser.validateByNameThrow("duelId", duelId);
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
	else
	{
		_parser.skip(8);  /*duelId*/
	}
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::equals(const Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::clear()
{
	duelId = 0;
	userId.clear();
	pendingActionType = 0;
	startTime = 0;
	expiryTime = 0;
	timeRemainingMins = 0;
	isRestoredNotif = false;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::equals(const Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId) &&
		pendingActionType == _o.pendingActionType &&
		startTime == _o.startTime &&
		expiryTime == _o.expiryTime &&
		timeRemainingMins == _o.timeRemainingMins &&
		isRestoredNotif == _o.isRestoredNotif;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("pendingActionType=");
	_buf.appendUint(pendingActionType);
	_buf.append(',');
	_buf.append("startTime=");
	_buf.appendUint64(startTime);
	_buf.append(',');
	_buf.append("expiryTime=");
	_buf.appendUint64(expiryTime);
	_buf.append(',');
	_buf.append("timeRemainingMins=");
	_buf.appendInt(timeRemainingMins);
	_buf.append(',');
	_buf.append("isRestoredNotif=");
	_buf.appendUint(isRestoredNotif);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pendingActionType", pendingActionType, _buf);
	Atf::XmlElement::encodeAsXmlElement("startTime", startTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("expiryTime", expiryTime, _buf);
	Atf::XmlElement::encodeAsXmlElement("timeRemainingMins", timeRemainingMins, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRestoredNotif", isRestoredNotif, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("pendingActionType"))
			{
				pendingActionType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startTime"))
			{
				startTime = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("expiryTime"))
			{
				expiryTime = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeRemainingMins"))
			{
				timeRemainingMins = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isRestoredNotif"))
			{
				isRestoredNotif = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
	_msg.composeUINT32(pendingActionType);
	_msg.composeUINT64(startTime);
	_msg.composeUINT64(expiryTime);
	_msg.composeINT32(timeRemainingMins);
	_msg.composeBOOL(isRestoredNotif);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseUINT32(pendingActionType);
	_parser.parseUINT64(startTime);
	_parser.parseUINT64(expiryTime);
	_parser.parseINT32(timeRemainingMins);
	_parser.parseBOOL(isRestoredNotif);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("pendingActionType", pendingActionType);
	_jsonstr.compose("startTime", startTime);
	_jsonstr.compose("expiryTime", expiryTime);
	_jsonstr.compose("timeRemainingMins", timeRemainingMins);
	_jsonstr.compose("isRestoredNotif", isRestoredNotif);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("pendingActionType", pendingActionType);
	_jparser.parseByNameThrow("startTime", startTime);
	_jparser.parseByNameThrow("expiryTime", expiryTime);
	_jparser.parseByNameThrow("timeRemainingMins", timeRemainingMins);
	_jparser.parseByNameThrow("isRestoredNotif", isRestoredNotif);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("pendingActionType", pendingActionType);
	_jparser.validateByNameThrow("startTime", startTime);
	_jparser.validateByNameThrow("expiryTime", expiryTime);
	_jparser.validateByNameThrow("timeRemainingMins", timeRemainingMins);
	_jparser.validateByNameThrow("isRestoredNotif", isRestoredNotif);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*pendingActionType*/
	_parser.skip(8);  /*startTime*/
	_parser.skip(8);  /*expiryTime*/
	_parser.skip(4);  /*timeRemainingMins*/
	bool isRestoredNotif; _parser.parseBOOL(isRestoredNotif);
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	isPlayerOnline = false;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		isPlayerOnline == _o.isPlayerOnline;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	_buf.append(',');
	_buf.append("isPlayerOnline=");
	_buf.appendUint(isPlayerOnline);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayerOnline", isPlayerOnline, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("isPlayerOnline"))
			{
				isPlayerOnline = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errString);
	_msg.composeBOOL(isPlayerOnline);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringPN(errString, 0, "errString");
	_parser.parseBOOL(isPlayerOnline);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	_jsonstr.compose("isPlayerOnline", isPlayerOnline);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
	_jparser.parseByNameThrow("isPlayerOnline", isPlayerOnline);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	_jparser.validateByNameThrow("errString", errString);
	_jparser.validateByNameThrow("isPlayerOnline", isPlayerOnline);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(2);  /*errCode*/
	_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	bool isPlayerOnline; _parser.parseBOOL(isPlayerOnline);
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::clear()
{
	duelId = 0;
	userId.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::equals(const Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::clear()
{
	duelId = 0;
	userId.clear();
	myScore = 0;
	opponentScore = 0;
	myRealScore = 0;
	opponentRealScore = 0;
	numHandsRemaining = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::equals(const Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId) &&
		myScore == _o.myScore &&
		opponentScore == _o.opponentScore &&
		myRealScore == _o.myRealScore &&
		opponentRealScore == _o.opponentRealScore &&
		numHandsRemaining == _o.numHandsRemaining;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("myScore=");
	_buf.appendInt(myScore);
	_buf.append(',');
	_buf.append("opponentScore=");
	_buf.appendInt(opponentScore);
	_buf.append(',');
	_buf.append("myRealScore=");
	_buf.appendInt(myRealScore);
	_buf.append(',');
	_buf.append("opponentRealScore=");
	_buf.appendInt(opponentRealScore);
	_buf.append(',');
	_buf.append("numHandsRemaining=");
	_buf.appendInt(numHandsRemaining);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("myScore", myScore, _buf);
	Atf::XmlElement::encodeAsXmlElement("opponentScore", opponentScore, _buf);
	Atf::XmlElement::encodeAsXmlElement("myRealScore", myRealScore, _buf);
	Atf::XmlElement::encodeAsXmlElement("opponentRealScore", opponentRealScore, _buf);
	Atf::XmlElement::encodeAsXmlElement("numHandsRemaining", numHandsRemaining, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("myScore"))
			{
				myScore = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("opponentScore"))
			{
				opponentScore = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("myRealScore"))
			{
				myRealScore = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("opponentRealScore"))
			{
				opponentRealScore = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numHandsRemaining"))
			{
				numHandsRemaining = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
	_msg.composeINT32(myScore);
	_msg.composeINT32(opponentScore);
	_msg.composeINT32(myRealScore);
	_msg.composeINT32(opponentRealScore);
	_msg.composeINT32(numHandsRemaining);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseINT32(myScore);
	_parser.parseINT32(opponentScore);
	_parser.parseINT32(myRealScore);
	_parser.parseINT32(opponentRealScore);
	_parser.parseINT32(numHandsRemaining);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("myScore", myScore);
	_jsonstr.compose("opponentScore", opponentScore);
	_jsonstr.compose("myRealScore", myRealScore);
	_jsonstr.compose("opponentRealScore", opponentRealScore);
	_jsonstr.compose("numHandsRemaining", numHandsRemaining);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("myScore", myScore);
	_jparser.parseByNameThrow("opponentScore", opponentScore);
	_jparser.parseByNameThrow("myRealScore", myRealScore);
	_jparser.parseByNameThrow("opponentRealScore", opponentRealScore);
	_jparser.parseByNameThrow("numHandsRemaining", numHandsRemaining);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("myScore", myScore);
	_jparser.validateByNameThrow("opponentScore", opponentScore);
	_jparser.validateByNameThrow("myRealScore", myRealScore);
	_jparser.validateByNameThrow("opponentRealScore", opponentRealScore);
	_jparser.validateByNameThrow("numHandsRemaining", numHandsRemaining);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*myScore*/
	_parser.skip(4);  /*opponentScore*/
	_parser.skip(4);  /*myRealScore*/
	_parser.skip(4);  /*opponentRealScore*/
	_parser.skip(4);  /*numHandsRemaining*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::clear()
{
	duelId = 0;
	userId.clear();
	actionTime.setNull();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::equals(const Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId) &&
		actionTime.equals(_o.actionTime);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("actionTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, actionTime);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "actionTime", actionTime);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("actionTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, actionTime);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
	_msg.composeSrvTime(actionTime);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseSrvTime(actionTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("actionTime", actionTime);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("actionTime", actionTime);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("actionTime", actionTime);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(8);  /*actionTime*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::equals(const Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::equals(const Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::equals(const Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::clear()
{
	duelId = 0;
	maxReplayWaitSecs = 0;
	duelHistory.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::equals(const Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		maxReplayWaitSecs == _o.maxReplayWaitSecs &&
		duelHistory.equals(_o.duelHistory);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("maxReplayWaitSecs=");
	_buf.appendInt(maxReplayWaitSecs);
	_buf.append(',');
	_buf.append("duelHistory=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(duelHistory, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxReplayWaitSecs", maxReplayWaitSecs, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelHistory", duelHistory, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxReplayWaitSecs"))
			{
				maxReplayWaitSecs = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("duelHistory"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, duelHistory)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeINT32(maxReplayWaitSecs);
	_msg.composeMsgBody(duelHistory);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseINT32(maxReplayWaitSecs);
	_parser.parseMsgBody(duelHistory);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("maxReplayWaitSecs", maxReplayWaitSecs);
	_jsonstr.compose("duelHistory", duelHistory);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("maxReplayWaitSecs", maxReplayWaitSecs);
	_jparser.parseByNameThrow("duelHistory", duelHistory);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("maxReplayWaitSecs", maxReplayWaitSecs);
	_jparser.validateByNameThrow("duelHistory", duelHistory);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*maxReplayWaitSecs*/
	_parser.skipMsgBody();  /*duelHistory*/
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	duelId = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::equals(const Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		duelId == _o.duelId;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errString);
	_msg.composeUINT64(duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringPN(errString, 0, "errString");
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	_jparser.validateByNameThrow("errString", errString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(2);  /*errCode*/
	_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::equals(const Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::clear()
{
	duelId = 0;
}

bool pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::equals(const Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST& _o) const
{
	return duelId == _o.duelId;
}

bool pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::equals(const Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::clear()
{
	duelId = 0;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::equals(const Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST& _o) const
{
	return duelId == _o.duelId;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::equals(const Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::equals(const Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::clear()
{
	duelId = 0;
	userId.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::equals(const Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::clear()
{
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::equals(const Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY& _o) const
{
	return true;
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY).append(")");
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::clear()
{
	duelId = 0;
	userId.clear();
	gameMsgId = 0;
	gameJSON.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::equals(const Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId) &&
		gameMsgId == _o.gameMsgId &&
		gameJSON.equals(_o.gameJSON);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("gameMsgId=");
	_buf.appendUint(gameMsgId);
	_buf.append(',');
	_buf.append("gameJSON=");
	_buf.append(gameJSON);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMsgId", gameMsgId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameJSON", gameJSON, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("gameMsgId"))
			{
				gameMsgId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameJSON"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, gameJSON)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
	_msg.composeUINT32(gameMsgId);
	_msg.composeString(gameJSON);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseUINT32(gameMsgId);
	_parser.parseStringPN(gameJSON, 0, "gameJSON");
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("gameMsgId", gameMsgId);
	_jsonstr.compose("gameJSON", gameJSON);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("gameMsgId", gameMsgId);
	_jparser.parseByNameThrow("gameJSON", gameJSON);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("gameMsgId", gameMsgId);
	_jparser.validateByNameThrow("gameJSON", gameJSON);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*gameMsgId*/
	_parser.parseStringN(_dummy, 0, "gameJSON");  /*gameJSON*/
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	userId.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::equals(const Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		userId.equals(_o.userId);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errString=");
	_buf.append(errString);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errString);
	_msg.composeString(userId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringPN(errString, 0, "errString");
	_parser.parseStringPN(userId, 0, "userId");
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errString", errString);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errString", errString);
	_jparser.parseByNameThrow("userId", userId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	_jparser.validateByNameThrow("errString", errString);
	_jparser.validateByNameThrow("userId", userId);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(2);  /*errCode*/
	_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
}

//=================================================================
//                Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER
//=================================================================

pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER()
{
	clear();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::clear()
{
	duelId = 0;
	userId.clear();
	gameMsgId = 0;
	gameMsgBody.clear();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::equals(const Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId) &&
		gameMsgId == _o.gameMsgId &&
		gameMsgBody.equals(_o.gameMsgBody);
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER*)_other));
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("gameMsgId=");
	_buf.appendUint(gameMsgId);
	_buf.append(',');
	_buf.append("gameMsgBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(gameMsgBody, _buf); _buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMsgId", gameMsgId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMsgBody", gameMsgBody, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("gameMsgId"))
			{
				gameMsgId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameMsgBody"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, gameMsgBody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
	_msg.composeUINT32(gameMsgId);
	_msg.composeMsgBody(gameMsgBody);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseUINT32(gameMsgId);
	_parser.parseMsgBody(gameMsgBody);
}

const char *pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("gameMsgId", gameMsgId);
	_jsonstr.compose("gameMsgBody", gameMsgBody);
	return _buf.c_str();
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("gameMsgId", gameMsgId);
	_jparser.parseByNameThrow("gameMsgBody", gameMsgBody);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("gameMsgId", gameMsgId);
	_jparser.validateByNameThrow("gameMsgBody", gameMsgBody);
}

void pokerduel::dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*gameMsgId*/
	_parser.skipMsgBody();  /*gameMsgBody*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED
//=================================================================

pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED()
{
	clear();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::clear()
{
	dbmList.clear();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::equals(const Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED& _o) const
{
	return dbmList.equals(_o.dbmList);
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DCHAT_CONNECTED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED*)_other));
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DCHAT_CONNECTED).append(")");
	_buf.append(',');
	_buf.append("dbmList=");
	dbmList.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DCHAT_CONNECTED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	dbmList.toXmlString("dbmList", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("dbmList"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< dbm::DbmInfo , 4 > >::FromXmlString(_value, dbmList)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	dbmList.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::parseMsg(CommMsgParser& _parser)
{
	dbmList.parseMsg(_parser);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("dbmList", dbmList);
	return _buf.c_str();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("dbmList", dbmList);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("dbmList", dbmList);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED::validateMsg(CommMsgParser& _parser)
{
	Atf::LAtfVector< dbm::DbmInfo , 4 >::validateMsg(_parser);  /*dbmList*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY
//=================================================================

pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY()
{
	clear();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::clear()
{
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY& _o) const
{
	return true;
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY*)_other));
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY).append(")");
	return _buf.c_str();
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST
//=================================================================

pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST()
{
	clear();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::clear()
{
	duelId = 0;
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::equals(const Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST& _o) const
{
	return duelId == _o.duelId;
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST*)_other));
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY
//=================================================================

pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY()
{
	clear();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::clear()
{
	duelId = 0;
	tableId = 0;
	dbmId = 0;
	player1.clear();
	player2.clear();
	lastChatOrdinal = 0;
	isPlayMoney = false;
	duelCloseTime.setNull();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY& _o) const
{
	return duelId == _o.duelId &&
		tableId == _o.tableId &&
		dbmId == _o.dbmId &&
		player1.equals(_o.player1) &&
		player2.equals(_o.player2) &&
		lastChatOrdinal == _o.lastChatOrdinal &&
		isPlayMoney == _o.isPlayMoney &&
		duelCloseTime.equals(_o.duelCloseTime);
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY*)_other));
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("dbmId=");
	_buf.appendInt(dbmId);
	_buf.append(',');
	_buf.append("player1=");
	_buf.append(player1);
	_buf.append(',');
	_buf.append("player2=");
	_buf.append(player2);
	_buf.append(',');
	_buf.append("lastChatOrdinal=");
	_buf.appendInt(lastChatOrdinal);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("duelCloseTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, duelCloseTime);
	return _buf.c_str();
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("dbmId", dbmId, _buf);
	Atf::XmlElement::encodeAsXmlElement("player1", player1, _buf);
	Atf::XmlElement::encodeAsXmlElement("player2", player2, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastChatOrdinal", lastChatOrdinal, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "duelCloseTime", duelCloseTime);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dbmId"))
			{
				dbmId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("player1"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, player1)) return false;
			}
			else if (_element.equals("player2"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, player2)) return false;
			}
			else if (_element.equals("lastChatOrdinal"))
			{
				lastChatOrdinal = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else if (_element.equals("duelCloseTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, duelCloseTime);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeUINT64(tableId);
	_msg.composeINT32(dbmId);
	_msg.composeString(player1);
	_msg.composeString(player2);
	_msg.composeINT32(lastChatOrdinal);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeSrvTime(duelCloseTime);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseUINT64(tableId);
	_parser.parseINT32(dbmId);
	_parser.parseStringPN(player1, 0, "player1");
	_parser.parseStringPN(player2, 0, "player2");
	_parser.parseINT32(lastChatOrdinal);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseSrvTime(duelCloseTime);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("dbmId", dbmId);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player2", player2);
	_jsonstr.compose("lastChatOrdinal", lastChatOrdinal);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("duelCloseTime", duelCloseTime);
	return _buf.c_str();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("dbmId", dbmId);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player2", player2);
	_jparser.parseByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("duelCloseTime", duelCloseTime);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("tableId", tableId);
	_jparser.validateByNameThrow("dbmId", dbmId);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player2", player2);
	_jparser.validateByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.validateByNameThrow("duelCloseTime", duelCloseTime);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.skip(8);  /*tableId*/
	_parser.skip(4);  /*dbmId*/
	_parser.parseStringN(_dummy, 0, "player1");  /*player1*/
	_parser.parseStringN(_dummy, 0, "player2");  /*player2*/
	_parser.skip(4);  /*lastChatOrdinal*/
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	_parser.skip(8);  /*duelCloseTime*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK
//=================================================================

pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK()
{
	clear();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::clear()
{
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::equals(const Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK& _o) const
{
	return true;
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK*)_other));
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK).append(")");
	return _buf.c_str();
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME
//=================================================================

pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME()
{
	clear();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::clear()
{
	duelId = 0;
	duelCloseTime.setNull();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::equals(const Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME& _o) const
{
	return duelId == _o.duelId &&
		duelCloseTime.equals(_o.duelCloseTime);
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME*)_other));
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("duelCloseTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, duelCloseTime);
	return _buf.c_str();
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "duelCloseTime", duelCloseTime);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("duelCloseTime"))
			{
				Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, duelCloseTime);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeSrvTime(duelCloseTime);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseSrvTime(duelCloseTime);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("duelCloseTime", duelCloseTime);
	return _buf.c_str();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("duelCloseTime", duelCloseTime);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("duelCloseTime", duelCloseTime);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(8);  /*duelCloseTime*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY
//=================================================================

pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY()
{
	clear();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::clear()
{
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::equals(const Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY& _o) const
{
	return true;
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY*)_other));
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY).append(")");
	return _buf.c_str();
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                    ClientRandomPool
//=================================================================

pokerduel::client::ClientRandomPool::ClientRandomPool()
{
	clear();
}

void pokerduel::client::ClientRandomPool::clear()
{
	duelTypeId = 0;
	whenJoined.setNull();
	ticketUsed = false;
}

bool pokerduel::client::ClientRandomPool::equals(const ClientRandomPool& _o) const
{
	return duelTypeId == _o.duelTypeId &&
		whenJoined.equals(_o.whenJoined) &&
		ticketUsed == _o.ticketUsed;
}

const char *pokerduel::client::ClientRandomPool::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("whenJoined=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenJoined);
	_buf.append(',');
	_buf.append("ticketUsed=");
	_buf.appendUint(ticketUsed);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::ClientRandomPool::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenJoined", whenJoined);
	Atf::XmlElement::encodeAsXmlElement("ticketUsed", ticketUsed, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::ClientRandomPool::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenJoined"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenJoined);
		}
		else if (_element.equals("ticketUsed"))
		{
			ticketUsed = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::ClientRandomPool::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientRandomPool())) // not empty
	{
		_body.composeUINT32(duelTypeId);
		_body.composeSrvTime(whenJoined);
		_body.composeBOOL(ticketUsed);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::client::ClientRandomPool::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(duelTypeId);
	_parser0.parseSrvTime(whenJoined);
	_parser0.parseBOOL(ticketUsed);
}

void pokerduel::client::ClientRandomPool::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("whenJoined", whenJoined);
	_parser0.parse("ticketUsed", ticketUsed);
}

const char *pokerduel::client::ClientRandomPool::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("whenJoined", whenJoined);
	_jsonstr.compose("ticketUsed", ticketUsed);
	return _buf.c_str();
}

void pokerduel::client::ClientRandomPool::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("whenJoined", whenJoined);
	_jparser.parseByNameThrow("ticketUsed", ticketUsed);
}

void pokerduel::client::ClientRandomPool::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("whenJoined", whenJoined);
	_jparser.validateByNameThrow("ticketUsed", ticketUsed);
}

/*static*/ void pokerduel::client::ClientRandomPool::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	_parser0.skip(4);  /*duelTypeId*/
	_parser0.skip(8);  /*whenJoined*/
	bool ticketUsed; _parser0.parseBOOL(ticketUsed);
	AtfValidator::validateEmbeddedMsgbodyParser("client::ClientRandomPool", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    ClientRunningDuel
//=================================================================

pokerduel::client::ClientRunningDuel::ClientRunningDuel()
{
	clear();
}

void pokerduel::client::ClientRunningDuel::clear()
{
	duelId = 0;
	player1.clear();
	player2.clear();
	tableId = 0;
	duelTypeId = 0;
	startTime.setNull();
	duelStatus = 0;
	playerStatus = 0;
	expiryTime.setNull();
	myScore = 0;
	opponentScore = 0;
	lastChatOrdinal = 0;
}

bool pokerduel::client::ClientRunningDuel::equals(const ClientRunningDuel& _o) const
{
	return duelId == _o.duelId &&
		player1.equals(_o.player1) &&
		player2.equals(_o.player2) &&
		tableId == _o.tableId &&
		duelTypeId == _o.duelTypeId &&
		startTime.equals(_o.startTime) &&
		duelStatus == _o.duelStatus &&
		playerStatus == _o.playerStatus &&
		expiryTime.equals(_o.expiryTime) &&
		myScore == _o.myScore &&
		opponentScore == _o.opponentScore &&
		lastChatOrdinal == _o.lastChatOrdinal;
}

const char *pokerduel::client::ClientRunningDuel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("player1=");
	player1.toTraceString(_buf);
	_buf.append(',');
	_buf.append("player2=");
	player2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("startTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("duelStatus=");
	_buf.appendUint(duelStatus);
	_buf.append(',');
	_buf.append("playerStatus=");
	_buf.appendInt(playerStatus);
	_buf.append(',');
	_buf.append("expiryTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, expiryTime);
	_buf.append(',');
	_buf.append("myScore=");
	_buf.appendInt(myScore);
	_buf.append(',');
	_buf.append("opponentScore=");
	_buf.appendInt(opponentScore);
	_buf.append(',');
	_buf.append("lastChatOrdinal=");
	_buf.appendInt(lastChatOrdinal);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::ClientRunningDuel::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	player1.toXmlString("player1", _buf);
	player2.toXmlString("player2", _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "startTime", startTime);
	Atf::XmlElement::encodeAsXmlElement("duelStatus", duelStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerStatus", playerStatus, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "expiryTime", expiryTime);
	Atf::XmlElement::encodeAsXmlElement("myScore", myScore, _buf);
	Atf::XmlElement::encodeAsXmlElement("opponentScore", opponentScore, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastChatOrdinal", lastChatOrdinal, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::ClientRunningDuel::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("duelId"))
		{
			duelId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("player1"))
		{
			if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player1)) return false;
		}
		else if (_element.equals("player2"))
		{
			if(!Atf::AtfTempl< DuelPlayer >::FromXmlString(_value, player2)) return false;
		}
		else if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startTime"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, startTime);
		}
		else if (_element.equals("duelStatus"))
		{
			duelStatus = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerStatus"))
		{
			playerStatus = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("expiryTime"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, expiryTime);
		}
		else if (_element.equals("myScore"))
		{
			myScore = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("opponentScore"))
		{
			opponentScore = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastChatOrdinal"))
		{
			lastChatOrdinal = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::ClientRunningDuel::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientRunningDuel())) // not empty
	{
		_body.composeUINT64(duelId);
		player1.composeMsg(_body, _ignoreJSON);
		player2.composeMsg(_body, _ignoreJSON);
		_body.composeUINT64(tableId);
		_body.composeUINT32(duelTypeId);
		_body.composeSrvTime(startTime);
		_body.composeBYTE(duelStatus);
		_body.composeINT32(playerStatus);
		_body.composeSrvTime(expiryTime);
		_body.composeINT32(myScore);
		_body.composeINT32(opponentScore);
		_body.composeINT32(lastChatOrdinal);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::client::ClientRunningDuel::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(duelId);
	player1.parseMsg(_parser0);
	player2.parseMsg(_parser0);
	_parser0.parseUINT64(tableId);
	_parser0.parseUINT32(duelTypeId);
	_parser0.parseSrvTime(startTime);
	_parser0.parseBYTE(duelStatus);
	_parser0.parseINT32(playerStatus);
	_parser0.parseSrvTime(expiryTime);
	_parser0.parseINT32(myScore);
	_parser0.parseINT32(opponentScore);
	_parser0.parseINT32(lastChatOrdinal);
}

void pokerduel::client::ClientRunningDuel::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("duelId", duelId);
	_parser0.parse("player1", player1);
	_parser0.parse("player2", player2);
	_parser0.parse("tableId", tableId);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("startTime", startTime);
	_parser0.parse("duelStatus", duelStatus);
	_parser0.parse("playerStatus", playerStatus);
	_parser0.parse("expiryTime", expiryTime);
	_parser0.parse("myScore", myScore);
	_parser0.parse("opponentScore", opponentScore);
	_parser0.parse("lastChatOrdinal", lastChatOrdinal);
}

const char *pokerduel::client::ClientRunningDuel::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player2", player2);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("startTime", startTime);
	_jsonstr.compose("duelStatus", duelStatus);
	_jsonstr.compose("playerStatus", playerStatus);
	_jsonstr.compose("expiryTime", expiryTime);
	_jsonstr.compose("myScore", myScore);
	_jsonstr.compose("opponentScore", opponentScore);
	_jsonstr.compose("lastChatOrdinal", lastChatOrdinal);
	return _buf.c_str();
}

void pokerduel::client::ClientRunningDuel::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player2", player2);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("startTime", startTime);
	_jparser.parseByNameThrow("duelStatus", duelStatus);
	_jparser.parseByNameThrow("playerStatus", playerStatus);
	_jparser.parseByNameThrow("expiryTime", expiryTime);
	_jparser.parseByNameThrow("myScore", myScore);
	_jparser.parseByNameThrow("opponentScore", opponentScore);
	_jparser.parseByNameThrow("lastChatOrdinal", lastChatOrdinal);
}

void pokerduel::client::ClientRunningDuel::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player2", player2);
	_jparser.validateByNameThrow("tableId", tableId);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("startTime", startTime);
	_jparser.validateByNameThrow("duelStatus", duelStatus);
	_jparser.validateByNameThrow("playerStatus", playerStatus);
	_jparser.validateByNameThrow("expiryTime", expiryTime);
	_jparser.validateByNameThrow("myScore", myScore);
	_jparser.validateByNameThrow("opponentScore", opponentScore);
	_jparser.validateByNameThrow("lastChatOrdinal", lastChatOrdinal);
}

/*static*/ void pokerduel::client::ClientRunningDuel::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	_parser0.skip(8);  /*duelId*/
	DuelPlayer::validateMsg(_parser0);  /*player1*/
	DuelPlayer::validateMsg(_parser0);  /*player2*/
	_parser0.skip(8);  /*tableId*/
	_parser0.skip(4);  /*duelTypeId*/
	_parser0.skip(8);  /*startTime*/
	_parser0.skip(1);  /*duelStatus*/
	_parser0.skip(4);  /*playerStatus*/
	_parser0.skip(8);  /*expiryTime*/
	_parser0.skip(4);  /*myScore*/
	_parser0.skip(4);  /*opponentScore*/
	_parser0.skip(4);  /*lastChatOrdinal*/
	AtfValidator::validateEmbeddedMsgbodyParser("client::ClientRunningDuel", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    ClientDuelChallengePlayer
//=================================================================

pokerduel::client::ClientDuelChallengePlayer::ClientDuelChallengePlayer()
{
	clear();
}

void pokerduel::client::ClientDuelChallengePlayer::clear()
{
	userId.clear();
	imageId = 0;
	isOnline = false;
}

bool pokerduel::client::ClientDuelChallengePlayer::equals(const ClientDuelChallengePlayer& _o) const
{
	return userId.equals(_o.userId) &&
		imageId == _o.imageId &&
		isOnline == _o.isOnline;
}

const char *pokerduel::client::ClientDuelChallengePlayer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("isOnline=");
	_buf.appendUint(isOnline);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::ClientDuelChallengePlayer::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOnline", isOnline, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::ClientDuelChallengePlayer::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isOnline"))
		{
			isOnline = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::ClientDuelChallengePlayer::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(imageId);
	_msg.composeBOOL(isOnline);
}

void pokerduel::client::ClientDuelChallengePlayer::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseUINT32(imageId);
	_parser.parseBOOL(isOnline);
}

void pokerduel::client::ClientDuelChallengePlayer::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("userId", userId);
	_parser.parse("imageId", imageId);
	_parser.parse("isOnline", isOnline);
}

const char *pokerduel::client::ClientDuelChallengePlayer::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("isOnline", isOnline);
	return _buf.c_str();
}

void pokerduel::client::ClientDuelChallengePlayer::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("isOnline", isOnline);
}

void pokerduel::client::ClientDuelChallengePlayer::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("imageId", imageId);
	_jparser.validateByNameThrow("isOnline", isOnline);
}

/*static*/ void pokerduel::client::ClientDuelChallengePlayer::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*imageId*/
	bool isOnline; _parser.parseBOOL(isOnline);
}

//=================================================================
//                    ClientDuelChallenge
//=================================================================

pokerduel::client::ClientDuelChallenge::ClientDuelChallenge()
{
	clear();
}

void pokerduel::client::ClientDuelChallenge::clear()
{
	challengeId = 0;
	player1.clear();
	player2.clear();
	duelTypeId = 0;
	response = 0;
	whenOffered.setNull();
	whenResponse.setNull();
	whenExpires.setNull();
}

bool pokerduel::client::ClientDuelChallenge::equals(const ClientDuelChallenge& _o) const
{
	return challengeId == _o.challengeId &&
		player1.equals(_o.player1) &&
		player2.equals(_o.player2) &&
		duelTypeId == _o.duelTypeId &&
		response == _o.response &&
		whenOffered.equals(_o.whenOffered) &&
		whenResponse.equals(_o.whenResponse) &&
		whenExpires.equals(_o.whenExpires);
}

const char *pokerduel::client::ClientDuelChallenge::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("player1=");
	player1.toTraceString(_buf);
	_buf.append(',');
	_buf.append("player2=");
	player2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("response=");
	_buf.appendInt(response);
	_buf.append(',');
	_buf.append("whenOffered=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenOffered);
	_buf.append(',');
	_buf.append("whenResponse=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenResponse);
	_buf.append(',');
	_buf.append("whenExpires=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenExpires);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::ClientDuelChallenge::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	player1.toXmlString("player1", _buf);
	player2.toXmlString("player2", _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("response", response, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenOffered", whenOffered);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenResponse", whenResponse);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenExpires", whenExpires);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::ClientDuelChallenge::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("challengeId"))
		{
			challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("player1"))
		{
			if(!Atf::AtfTempl< ClientDuelChallengePlayer >::FromXmlString(_value, player1)) return false;
		}
		else if (_element.equals("player2"))
		{
			if(!Atf::AtfTempl< ClientDuelChallengePlayer >::FromXmlString(_value, player2)) return false;
		}
		else if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("response"))
		{
			response = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenOffered"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenOffered);
		}
		else if (_element.equals("whenResponse"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenResponse);
		}
		else if (_element.equals("whenExpires"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenExpires);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::ClientDuelChallenge::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientDuelChallenge())) // not empty
	{
		_body.composeUINT64(challengeId);
		player1.composeMsg(_body, _ignoreJSON);
		player2.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(duelTypeId);
		_body.composeINT32(response);
		_body.composeSrvTime(whenOffered);
		_body.composeSrvTime(whenResponse);
		_body.composeSrvTime(whenExpires);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::client::ClientDuelChallenge::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(challengeId);
	player1.parseMsg(_parser0);
	player2.parseMsg(_parser0);
	_parser0.parseUINT32(duelTypeId);
	_parser0.parseINT32(response);
	_parser0.parseSrvTime(whenOffered);
	_parser0.parseSrvTime(whenResponse);
	_parser0.parseSrvTime(whenExpires);
}

void pokerduel::client::ClientDuelChallenge::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("challengeId", challengeId);
	_parser0.parse("player1", player1);
	_parser0.parse("player2", player2);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("response", response);
	_parser0.parse("whenOffered", whenOffered);
	_parser0.parse("whenResponse", whenResponse);
	_parser0.parse("whenExpires", whenExpires);
}

const char *pokerduel::client::ClientDuelChallenge::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player2", player2);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("response", response);
	_jsonstr.compose("whenOffered", whenOffered);
	_jsonstr.compose("whenResponse", whenResponse);
	_jsonstr.compose("whenExpires", whenExpires);
	return _buf.c_str();
}

void pokerduel::client::ClientDuelChallenge::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeId", challengeId);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player2", player2);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("response", response);
	_jparser.parseByNameThrow("whenOffered", whenOffered);
	_jparser.parseByNameThrow("whenResponse", whenResponse);
	_jparser.parseByNameThrow("whenExpires", whenExpires);
}

void pokerduel::client::ClientDuelChallenge::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeId", challengeId);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player2", player2);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("response", response);
	_jparser.validateByNameThrow("whenOffered", whenOffered);
	_jparser.validateByNameThrow("whenResponse", whenResponse);
	_jparser.validateByNameThrow("whenExpires", whenExpires);
}

/*static*/ void pokerduel::client::ClientDuelChallenge::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	_parser0.skip(8);  /*challengeId*/
	ClientDuelChallengePlayer::validateMsg(_parser0);  /*player1*/
	ClientDuelChallengePlayer::validateMsg(_parser0);  /*player2*/
	_parser0.skip(4);  /*duelTypeId*/
	_parser0.skip(4);  /*response*/
	_parser0.skip(8);  /*whenOffered*/
	_parser0.skip(8);  /*whenResponse*/
	_parser0.skip(8);  /*whenExpires*/
	AtfValidator::validateEmbeddedMsgbodyParser("client::ClientDuelChallenge", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    ClientDuelChallengePlayer2
//=================================================================

pokerduel::client::ClientDuelChallengePlayer2::ClientDuelChallengePlayer2()
{
	clear();
}

void pokerduel::client::ClientDuelChallengePlayer2::clear()
{
	userId.clear();
	imageId = 0;
	playerFlag = 0;
}

bool pokerduel::client::ClientDuelChallengePlayer2::equals(const ClientDuelChallengePlayer2& _o) const
{
	return userId.equals(_o.userId) &&
		imageId == _o.imageId &&
		playerFlag == _o.playerFlag;
}

const char *pokerduel::client::ClientDuelChallengePlayer2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("playerFlag=");
	_buf.appendUint(playerFlag);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::ClientDuelChallengePlayer2::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerFlag", playerFlag, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::ClientDuelChallengePlayer2::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerFlag"))
		{
			playerFlag = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::ClientDuelChallengePlayer2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientDuelChallengePlayer2())) // not empty
	{
		_body.composeString(userId);
		_body.composeUINT32(imageId);
		_body.composeUINT32(playerFlag);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::client::ClientDuelChallengePlayer2::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringPN(userId, 0, "userId");
	_parser0.parseUINT32(imageId);
	_parser0.parseUINT32(playerFlag);
}

void pokerduel::client::ClientDuelChallengePlayer2::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("userId", userId);
	_parser0.parse("imageId", imageId);
	_parser0.parse("playerFlag", playerFlag);
}

const char *pokerduel::client::ClientDuelChallengePlayer2::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("playerFlag", playerFlag);
	return _buf.c_str();
}

void pokerduel::client::ClientDuelChallengePlayer2::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("playerFlag", playerFlag);
}

void pokerduel::client::ClientDuelChallengePlayer2::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("imageId", imageId);
	_jparser.validateByNameThrow("playerFlag", playerFlag);
}

/*static*/ void pokerduel::client::ClientDuelChallengePlayer2::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy;
	_parser0.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser0.skip(4);  /*imageId*/
	_parser0.skip(4);  /*playerFlag*/
	AtfValidator::validateEmbeddedMsgbodyParser("client::ClientDuelChallengePlayer2", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    ClientDuelChallenge2
//=================================================================

pokerduel::client::ClientDuelChallenge2::ClientDuelChallenge2()
{
	clear();
}

void pokerduel::client::ClientDuelChallenge2::clear()
{
	challengeId = 0;
	player1.clear();
	player2.clear();
	duelTypeId = 0;
	response = 0;
	whenOffered.setNull();
	whenResponse.setNull();
	whenExpires.setNull();
	player1UsedTicket = false;
}

bool pokerduel::client::ClientDuelChallenge2::equals(const ClientDuelChallenge2& _o) const
{
	return challengeId == _o.challengeId &&
		player1.equals(_o.player1) &&
		player2.equals(_o.player2) &&
		duelTypeId == _o.duelTypeId &&
		response == _o.response &&
		whenOffered.equals(_o.whenOffered) &&
		whenResponse.equals(_o.whenResponse) &&
		whenExpires.equals(_o.whenExpires) &&
		player1UsedTicket == _o.player1UsedTicket;
}

const char *pokerduel::client::ClientDuelChallenge2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("player1=");
	player1.toTraceString(_buf);
	_buf.append(',');
	_buf.append("player2=");
	player2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("response=");
	_buf.appendInt(response);
	_buf.append(',');
	_buf.append("whenOffered=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenOffered);
	_buf.append(',');
	_buf.append("whenResponse=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenResponse);
	_buf.append(',');
	_buf.append("whenExpires=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenExpires);
	_buf.append(',');
	_buf.append("player1UsedTicket=");
	_buf.appendUint(player1UsedTicket);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::ClientDuelChallenge2::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	player1.toXmlString("player1", _buf);
	player2.toXmlString("player2", _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("response", response, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenOffered", whenOffered);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenResponse", whenResponse);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenExpires", whenExpires);
	Atf::XmlElement::encodeAsXmlElement("player1UsedTicket", player1UsedTicket, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::ClientDuelChallenge2::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("challengeId"))
		{
			challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("player1"))
		{
			if(!Atf::AtfTempl< ClientDuelChallengePlayer2 >::FromXmlString(_value, player1)) return false;
		}
		else if (_element.equals("player2"))
		{
			if(!Atf::AtfTempl< ClientDuelChallengePlayer2 >::FromXmlString(_value, player2)) return false;
		}
		else if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("response"))
		{
			response = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenOffered"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenOffered);
		}
		else if (_element.equals("whenResponse"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenResponse);
		}
		else if (_element.equals("whenExpires"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenExpires);
		}
		else if (_element.equals("player1UsedTicket"))
		{
			player1UsedTicket = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::ClientDuelChallenge2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClientDuelChallenge2())) // not empty
	{
		_body.composeUINT64(challengeId);
		player1.composeMsg(_body, _ignoreJSON);
		player2.composeMsg(_body, _ignoreJSON);
		_body.composeUINT32(duelTypeId);
		_body.composeINT32(response);
		_body.composeSrvTime(whenOffered);
		_body.composeSrvTime(whenResponse);
		_body.composeSrvTime(whenExpires);
		_body.composeBOOL(player1UsedTicket);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::client::ClientDuelChallenge2::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(challengeId);
	player1.parseMsg(_parser0);
	player2.parseMsg(_parser0);
	_parser0.parseUINT32(duelTypeId);
	_parser0.parseINT32(response);
	_parser0.parseSrvTime(whenOffered);
	_parser0.parseSrvTime(whenResponse);
	_parser0.parseSrvTime(whenExpires);
	_parser0.parseBOOL(player1UsedTicket);
}

void pokerduel::client::ClientDuelChallenge2::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("challengeId", challengeId);
	_parser0.parse("player1", player1);
	_parser0.parse("player2", player2);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("response", response);
	_parser0.parse("whenOffered", whenOffered);
	_parser0.parse("whenResponse", whenResponse);
	_parser0.parse("whenExpires", whenExpires);
	_parser0.parse("player1UsedTicket", player1UsedTicket);
}

const char *pokerduel::client::ClientDuelChallenge2::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("player1", player1);
	_jsonstr.compose("player2", player2);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("response", response);
	_jsonstr.compose("whenOffered", whenOffered);
	_jsonstr.compose("whenResponse", whenResponse);
	_jsonstr.compose("whenExpires", whenExpires);
	_jsonstr.compose("player1UsedTicket", player1UsedTicket);
	return _buf.c_str();
}

void pokerduel::client::ClientDuelChallenge2::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeId", challengeId);
	_jparser.parseByNameThrow("player1", player1);
	_jparser.parseByNameThrow("player2", player2);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("response", response);
	_jparser.parseByNameThrow("whenOffered", whenOffered);
	_jparser.parseByNameThrow("whenResponse", whenResponse);
	_jparser.parseByNameThrow("whenExpires", whenExpires);
	_jparser.parseByNameThrow("player1UsedTicket", player1UsedTicket);
}

void pokerduel::client::ClientDuelChallenge2::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeId", challengeId);
	_jparser.validateByNameThrow("player1", player1);
	_jparser.validateByNameThrow("player2", player2);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("response", response);
	_jparser.validateByNameThrow("whenOffered", whenOffered);
	_jparser.validateByNameThrow("whenResponse", whenResponse);
	_jparser.validateByNameThrow("whenExpires", whenExpires);
	_jparser.validateByNameThrow("player1UsedTicket", player1UsedTicket);
}

/*static*/ void pokerduel::client::ClientDuelChallenge2::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	_parser0.skip(8);  /*challengeId*/
	ClientDuelChallengePlayer2::validateMsg(_parser0);  /*player1*/
	ClientDuelChallengePlayer2::validateMsg(_parser0);  /*player2*/
	_parser0.skip(4);  /*duelTypeId*/
	_parser0.skip(4);  /*response*/
	_parser0.skip(8);  /*whenOffered*/
	_parser0.skip(8);  /*whenResponse*/
	_parser0.skip(8);  /*whenExpires*/
	bool player1UsedTicket; _parser0.parseBOOL(player1UsedTicket);
	AtfValidator::validateEmbeddedMsgbodyParser("client::ClientDuelChallenge2", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER
//=================================================================

pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER()
{
	clear();
}

void pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::clear()
{
	duelId = 0;
	userId.clear();
	gameMsgId = 0;
	gameMsg.clear();
}

bool pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::equals(const Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId) &&
		gameMsgId == _o.gameMsgId &&
		gameMsg.equals(_o.gameMsg);
}

bool pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER*)_other));
}

const char *pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("gameMsgId=");
	_buf.appendUint(gameMsgId);
	_buf.append(',');
	_buf.append("gameMsg=");
	gameMsg.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMsgId", gameMsgId, _buf);
	gameMsg.toXmlString("gameMsg", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("gameMsgId"))
			{
				gameMsgId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameMsg"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, gameMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
	_msg.composeUINT32(gameMsgId);
	gameMsg.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseUINT32(gameMsgId);
	gameMsg.parseMsg(_parser);
}

const char *pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("gameMsgId", gameMsgId);
	_jsonstr.compose("gameMsg", gameMsg);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("gameMsgId", gameMsgId);
	_jparser.parseByNameThrow("gameMsg", gameMsg);
}

void pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("gameMsgId", gameMsgId);
	_jparser.validateByNameThrow("gameMsg", gameMsg);
}

void pokerduel::client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*gameMsgId*/
	Atf::MsgBodyWithJSON::validateMsg(_parser);  /*gameMsg*/
}

//=================================================================
//                Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER
//=================================================================

pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER()
{
	clear();
}

void pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::clear()
{
	duelId = 0;
	userId.clear();
	gameMsgId = 0;
	gameMsg.clear();
}

bool pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::equals(const Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId) &&
		gameMsgId == _o.gameMsgId &&
		gameMsg.equals(_o.gameMsg);
}

bool pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_DLOBBY_POST_TO_PLAYER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER*)_other));
}

const char *pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_DLOBBY_POST_TO_PLAYER).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("gameMsgId=");
	_buf.appendUint(gameMsgId);
	_buf.append(',');
	_buf.append("gameMsg=");
	gameMsg.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_DLOBBY_POST_TO_PLAYER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMsgId", gameMsgId, _buf);
	gameMsg.toXmlString("gameMsg", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("gameMsgId"))
			{
				gameMsgId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameMsg"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, gameMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
	_msg.composeUINT32(gameMsgId);
	gameMsg.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseUINT32(gameMsgId);
	gameMsg.parseMsg(_parser);
}

const char *pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("gameMsgId", gameMsgId);
	_jsonstr.compose("gameMsg", gameMsg);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("gameMsgId", gameMsgId);
	_jparser.parseByNameThrow("gameMsg", gameMsg);
}

void pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("gameMsgId", gameMsgId);
	_jparser.validateByNameThrow("gameMsg", gameMsg);
}

void pokerduel::client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*gameMsgId*/
	Atf::MsgBodyWithJSON::validateMsg(_parser);  /*gameMsg*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::clear()
{
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::equals(const Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS& _o) const
{
	return true;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_RUNNING_DUELS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_RUNNING_DUELS).append(")");
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_RUNNING_DUELS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	runningDuels.clear();
	challenges.clear();
	randomPoolEntries.clear();
	duelTypes.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::equals(const Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		runningDuels.equals(_o.runningDuels) &&
		challenges.equals(_o.challenges) &&
		randomPoolEntries.equals(_o.randomPoolEntries) &&
		duelTypes.equals(_o.duelTypes);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("runningDuels=");
		runningDuels.toTraceString(_buf);
		_buf.append(',');
		_buf.append("challenges=");
		challenges.toTraceString(_buf);
		_buf.append(',');
		_buf.append("randomPoolEntries=");
		randomPoolEntries.toTraceString(_buf);
		_buf.append(',');
		_buf.append("duelTypes=");
		duelTypes.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		runningDuels.toXmlString("runningDuels", _buf);
		challenges.toXmlString("challenges", _buf);
		randomPoolEntries.toXmlString("randomPoolEntries", _buf);
		duelTypes.toXmlString("duelTypes", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("runningDuels"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientRunningDuel , 4 > >::FromXmlString(_value, runningDuels)) return false;
			}
			else if (_element.equals("challenges"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientDuelChallenge , 4 > >::FromXmlString(_value, challenges)) return false;
			}
			else if (_element.equals("randomPoolEntries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientRandomPool , 4 > >::FromXmlString(_value, randomPoolEntries)) return false;
			}
			else if (_element.equals("duelTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DuelType , 4 > >::FromXmlString(_value, duelTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		runningDuels.composeMsg(_msg, _ignoreJSON);
		challenges.composeMsg(_msg, _ignoreJSON);
		randomPoolEntries.composeMsg(_msg, _ignoreJSON);
		duelTypes.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
	}
	else
	{
		runningDuels.parseMsg(_parser);
		challenges.parseMsg(_parser);
		randomPoolEntries.parseMsg(_parser);
		duelTypes.parseMsg(_parser);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("runningDuels", runningDuels);
		_jsonstr.compose("challenges", challenges);
		_jsonstr.compose("randomPoolEntries", randomPoolEntries);
		_jsonstr.compose("duelTypes", duelTypes);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("runningDuels", runningDuels);
		_jparser.parseByNameThrow("challenges", challenges);
		_jparser.parseByNameThrow("randomPoolEntries", randomPoolEntries);
		_jparser.parseByNameThrow("duelTypes", duelTypes);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
	}
	else
	{
		_jparser.validateByNameThrow("runningDuels", runningDuels);
		_jparser.validateByNameThrow("challenges", challenges);
		_jparser.validateByNameThrow("randomPoolEntries", randomPoolEntries);
		_jparser.validateByNameThrow("duelTypes", duelTypes);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
	}
	else
	{
		Atf::LAtfVector< ClientRunningDuel , 4 >::validateMsg(_parser);  /*runningDuels*/
		Atf::LAtfVector< ClientDuelChallenge , 4 >::validateMsg(_parser);  /*challenges*/
		Atf::LAtfVector< ClientRandomPool , 4 >::validateMsg(_parser);  /*randomPoolEntries*/
		Atf::LAtfVector< DuelType , 4 >::validateMsg(_parser);  /*duelTypes*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::clear()
{
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::equals(const Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2& _o) const
{
	return true;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_RUNNING_DUELS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_RUNNING_DUELS2).append(")");
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_RUNNING_DUELS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	runningDuels.clear();
	challenges.clear();
	randomPoolEntries.clear();
	duelTypes.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::equals(const Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		runningDuels.equals(_o.runningDuels) &&
		challenges.equals(_o.challenges) &&
		randomPoolEntries.equals(_o.randomPoolEntries) &&
		duelTypes.equals(_o.duelTypes);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("runningDuels=");
		runningDuels.toTraceString(_buf);
		_buf.append(',');
		_buf.append("challenges=");
		challenges.toTraceString(_buf);
		_buf.append(',');
		_buf.append("randomPoolEntries=");
		randomPoolEntries.toTraceString(_buf);
		_buf.append(',');
		_buf.append("duelTypes=");
		duelTypes.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		runningDuels.toXmlString("runningDuels", _buf);
		challenges.toXmlString("challenges", _buf);
		randomPoolEntries.toXmlString("randomPoolEntries", _buf);
		duelTypes.toXmlString("duelTypes", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("runningDuels"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientRunningDuel , 4 > >::FromXmlString(_value, runningDuels)) return false;
			}
			else if (_element.equals("challenges"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientDuelChallenge2 , 4 > >::FromXmlString(_value, challenges)) return false;
			}
			else if (_element.equals("randomPoolEntries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientRandomPool , 4 > >::FromXmlString(_value, randomPoolEntries)) return false;
			}
			else if (_element.equals("duelTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DuelType , 4 > >::FromXmlString(_value, duelTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		runningDuels.composeMsg(_msg, _ignoreJSON);
		challenges.composeMsg(_msg, _ignoreJSON);
		randomPoolEntries.composeMsg(_msg, _ignoreJSON);
		duelTypes.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		runningDuels.parseMsg(_parser);
		challenges.parseMsg(_parser);
		randomPoolEntries.parseMsg(_parser);
		duelTypes.parseMsg(_parser);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("runningDuels", runningDuels);
		_jsonstr.compose("challenges", challenges);
		_jsonstr.compose("randomPoolEntries", randomPoolEntries);
		_jsonstr.compose("duelTypes", duelTypes);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("runningDuels", runningDuels);
		_jparser.parseByNameThrow("challenges", challenges);
		_jparser.parseByNameThrow("randomPoolEntries", randomPoolEntries);
		_jparser.parseByNameThrow("duelTypes", duelTypes);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("runningDuels", runningDuels);
		_jparser.validateByNameThrow("challenges", challenges);
		_jparser.validateByNameThrow("randomPoolEntries", randomPoolEntries);
		_jparser.validateByNameThrow("duelTypes", duelTypes);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		Atf::LAtfVector< ClientRunningDuel , 4 >::validateMsg(_parser);  /*runningDuels*/
		Atf::LAtfVector< ClientDuelChallenge2 , 4 >::validateMsg(_parser);  /*challenges*/
		Atf::LAtfVector< ClientRandomPool , 4 >::validateMsg(_parser);  /*randomPoolEntries*/
		Atf::LAtfVector< DuelType , 4 >::validateMsg(_parser);  /*duelTypes*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_DUELTYPES
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::Protocol_MSG_POKERDUEL_GET_DUELTYPES()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::clear()
{
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::equals(const Protocol_MSG_POKERDUEL_GET_DUELTYPES& _o) const
{
	return true;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_DUELTYPES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_DUELTYPES*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_DUELTYPES).append(")");
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_DUELTYPES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	duelTypes.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::equals(const Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		duelTypes.equals(_o.duelTypes);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_DUELTYPES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_DUELTYPES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("duelTypes=");
		duelTypes.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_DUELTYPES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		duelTypes.toXmlString("duelTypes", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("duelTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DuelType , 4 > >::FromXmlString(_value, duelTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		duelTypes.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		duelTypes.parseMsg(_parser);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("duelTypes", duelTypes);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("duelTypes", duelTypes);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("duelTypes", duelTypes);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		Atf::LAtfVector< DuelType , 4 >::validateMsg(_parser);  /*duelTypes*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::clear()
{
	opponentUserId.clear();
	duelTypeId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::equals(const Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST& _o) const
{
	return opponentUserId.equals(_o.opponentUserId) &&
		duelTypeId == _o.duelTypeId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_CHALLENGE_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_CHALLENGE_REQUEST).append(")");
	_buf.append(',');
	_buf.append("opponentUserId=");
	_buf.append(opponentUserId);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_CHALLENGE_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("opponentUserId", opponentUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("opponentUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, opponentUserId)) return false;
			}
			else if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(opponentUserId);
	_msg.composeUINT32(duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringPN(opponentUserId, 0, "opponentUserId");
	_parser.parseUINT32(duelTypeId);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("opponentUserId", opponentUserId);
	_jsonstr.compose("duelTypeId", duelTypeId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("opponentUserId", opponentUserId);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("opponentUserId", opponentUserId);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.parseStringN(_dummy, 0, "opponentUserId");  /*opponentUserId*/
	_parser.skip(4);  /*duelTypeId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	challengeId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::equals(const Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		challengeId == _o.challengeId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("challengeId=");
		_buf.appendUint64(challengeId);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("challengeId"))
			{
				challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		_msg.composeUINT64(challengeId);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		_parser.parseUINT64(challengeId);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("challengeId", challengeId);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("challengeId", challengeId);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("challengeId", challengeId);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		_parser.skip(8);  /*challengeId*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_CHALLENGE_OFFER
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::clear()
{
	challengerUserId.clear();
	challengerImageId = 0;
	challengeId = 0;
	duelTypeId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::equals(const Protocol_MSG_POKERDUEL_CHALLENGE_OFFER& _o) const
{
	return challengerUserId.equals(_o.challengerUserId) &&
		challengerImageId == _o.challengerImageId &&
		challengeId == _o.challengeId &&
		duelTypeId == _o.duelTypeId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_CHALLENGE_OFFER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_CHALLENGE_OFFER*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_CHALLENGE_OFFER).append(")");
	_buf.append(',');
	_buf.append("challengerUserId=");
	_buf.append(challengerUserId);
	_buf.append(',');
	_buf.append("challengerImageId=");
	_buf.appendUint(challengerImageId);
	_buf.append(',');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_CHALLENGE_OFFER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("challengerUserId", challengerUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("challengerImageId", challengerImageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("challengerUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, challengerUserId)) return false;
			}
			else if (_element.equals("challengerImageId"))
			{
				challengerImageId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("challengeId"))
			{
				challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(challengerUserId);
	_msg.composeUINT32(challengerImageId);
	_msg.composeUINT64(challengeId);
	_msg.composeUINT32(duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringPN(challengerUserId, 0, "challengerUserId");
	_parser.parseUINT32(challengerImageId);
	_parser.parseUINT64(challengeId);
	_parser.parseUINT32(duelTypeId);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengerUserId", challengerUserId);
	_jsonstr.compose("challengerImageId", challengerImageId);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("duelTypeId", duelTypeId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengerUserId", challengerUserId);
	_jparser.parseByNameThrow("challengerImageId", challengerImageId);
	_jparser.parseByNameThrow("challengeId", challengeId);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengerUserId", challengerUserId);
	_jparser.validateByNameThrow("challengerImageId", challengerImageId);
	_jparser.validateByNameThrow("challengeId", challengeId);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.parseStringN(_dummy, 0, "challengerUserId");  /*challengerUserId*/
	_parser.skip(4);  /*challengerImageId*/
	_parser.skip(8);  /*challengeId*/
	_parser.skip(4);  /*duelTypeId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::clear()
{
	challengeId = 0;
	answer = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::equals(const Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE& _o) const
{
	return challengeId == _o.challengeId &&
		answer == _o.answer;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE).append(")");
	_buf.append(',');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("answer=");
	_buf.appendInt(answer);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer", answer, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("challengeId"))
			{
				challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("answer"))
			{
				answer = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(challengeId);
	_msg.composeINT32(answer);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(challengeId);
	_parser.parseINT32(answer);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("answer", answer);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeId", challengeId);
	_jparser.parseByNameThrow("answer", answer);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeId", challengeId);
	_jparser.validateByNameThrow("answer", answer);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*challengeId*/
	_parser.skip(4);  /*answer*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	duelId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::equals(const Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		duelId == _o.duelId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("duelId=");
		_buf.appendUint64(duelId);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		_msg.composeUINT64(duelId);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		_parser.parseUINT64(duelId);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("duelId", duelId);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("duelId", duelId);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("duelId", duelId);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		_parser.skip(8);  /*duelId*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::clear()
{
	challengeId = 0;
	duelId = 0;
	answer = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::equals(const Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE& _o) const
{
	return challengeId == _o.challengeId &&
		duelId == _o.duelId &&
		answer == _o.answer;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE).append(")");
	_buf.append(',');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("answer=");
	_buf.appendInt(answer);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("answer", answer, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("challengeId"))
			{
				challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("answer"))
			{
				answer = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(challengeId);
	_msg.composeUINT64(duelId);
	_msg.composeINT32(answer);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(challengeId);
	_parser.parseUINT64(duelId);
	_parser.parseINT32(answer);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("answer", answer);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeId", challengeId);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("answer", answer);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeId", challengeId);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("answer", answer);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*challengeId*/
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*answer*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_START_RANDOM_DUEL
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::clear()
{
	duelTypeId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::equals(const Protocol_MSG_POKERDUEL_START_RANDOM_DUEL& _o) const
{
	return duelTypeId == _o.duelTypeId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_START_RANDOM_DUEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_START_RANDOM_DUEL*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_START_RANDOM_DUEL).append(")");
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_START_RANDOM_DUEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(duelTypeId);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(4);  /*duelTypeId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	duelId = 0;
	opponentUserId.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::equals(const Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		duelId == _o.duelId &&
		opponentUserId.equals(_o.opponentUserId);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_START_RANDOM_DUEL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_START_RANDOM_DUEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("duelId=");
		_buf.appendUint64(duelId);
		_buf.append(',');
		_buf.append("opponentUserId=");
		_buf.append(opponentUserId);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_START_RANDOM_DUEL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
		Atf::XmlElement::encodeAsXmlElement("opponentUserId", opponentUserId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("opponentUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, opponentUserId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		_msg.composeUINT64(duelId);
		_msg.composeString(opponentUserId);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		_parser.parseUINT64(duelId);
		_parser.parseStringPN(opponentUserId, 0, "opponentUserId");
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("duelId", duelId);
		_jsonstr.compose("opponentUserId", opponentUserId);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("duelId", duelId);
		_jparser.parseByNameThrow("opponentUserId", opponentUserId);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("duelId", duelId);
		_jparser.validateByNameThrow("opponentUserId", opponentUserId);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		_parser.skip(8);  /*duelId*/
		_parser.parseStringN(_dummy, 0, "opponentUserId");  /*opponentUserId*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::clear()
{
	duelTypeId = 0;
	duelId = 0;
	opponentUserId.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::equals(const Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND& _o) const
{
	return duelTypeId == _o.duelTypeId &&
		duelId == _o.duelId &&
		opponentUserId.equals(_o.opponentUserId);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_RANDOM_OPPONENT_FOUND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_RANDOM_OPPONENT_FOUND).append(")");
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("opponentUserId=");
	_buf.append(opponentUserId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_RANDOM_OPPONENT_FOUND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("opponentUserId", opponentUserId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("opponentUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, opponentUserId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(duelTypeId);
	_msg.composeUINT64(duelId);
	_msg.composeString(opponentUserId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(duelTypeId);
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(opponentUserId, 0, "opponentUserId");
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("opponentUserId", opponentUserId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("opponentUserId", opponentUserId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("opponentUserId", opponentUserId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*duelTypeId*/
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "opponentUserId");  /*opponentUserId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::clear()
{
	challengeId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::equals(const Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE& _o) const
{
	return challengeId == _o.challengeId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_CANCEL_CHALLENGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_CANCEL_CHALLENGE).append(")");
	_buf.append(',');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_CANCEL_CHALLENGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("challengeId"))
			{
				challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(challengeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(challengeId);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeId", challengeId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeId", challengeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeId", challengeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*challengeId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::equals(const Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if(errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::clear()
{
	duelTypeId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::equals(const Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL& _o) const
{
	return duelTypeId == _o.duelTypeId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_LEAVE_RANDOM_POOL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_LEAVE_RANDOM_POOL).append(")");
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_LEAVE_RANDOM_POOL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(duelTypeId);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(4);  /*duelTypeId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::equals(const Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::clear()
{
	duelId = 0;
	newStatus = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::equals(const Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN& _o) const
{
	return duelId == _o.duelId &&
		newStatus == _o.newStatus;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("newStatus=");
	_buf.appendInt(newStatus);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("newStatus", newStatus, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("newStatus"))
			{
				newStatus = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeINT32(newStatus);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseINT32(newStatus);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("newStatus", newStatus);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("newStatus", newStatus);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("newStatus", newStatus);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*newStatus*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_SERVER_RESTARTING
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::Protocol_MSG_POKERDUEL_SERVER_RESTARTING()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::clear()
{
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::equals(const Protocol_MSG_POKERDUEL_SERVER_RESTARTING& _o) const
{
	return true;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_SERVER_RESTARTING != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_SERVER_RESTARTING*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_SERVER_RESTARTING).append(")");
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_SERVER_RESTARTING).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_POKERDUEL_PROFILE_REQUEST
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::Protocol_MSG_POKERDUEL_PROFILE_REQUEST()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::clear()
{
	userId.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::equals(const Protocol_MSG_POKERDUEL_PROFILE_REQUEST& _o) const
{
	return userId.equals(_o.userId);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_PROFILE_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_PROFILE_REQUEST*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_PROFILE_REQUEST).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_PROFILE_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringPN(userId, 0, "userId");
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userId", userId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
}

//=================================================================
//                    ProfileResponse_userInfo
//=================================================================

pokerduel::client::ProfileResponse_userInfo::ProfileResponse_userInfo()
{
	clear();
}

void pokerduel::client::ProfileResponse_userInfo::clear()
{
	imageId = 0;
	country.clear();
	isOnline = false;
	numChallengesFromMeToFriend = 0;
	numChallengesFromFriendToMe = 0;
	playerFlag = 0;
	challengeIdsFromMeToFriend.clear();
	challengeIdsFromFriendToMe.clear();
}

bool pokerduel::client::ProfileResponse_userInfo::equals(const ProfileResponse_userInfo& _o) const
{
	return imageId == _o.imageId &&
		country.equals(_o.country) &&
		isOnline == _o.isOnline &&
		numChallengesFromMeToFriend == _o.numChallengesFromMeToFriend &&
		numChallengesFromFriendToMe == _o.numChallengesFromFriendToMe &&
		playerFlag == _o.playerFlag &&
		challengeIdsFromMeToFriend.equals(_o.challengeIdsFromMeToFriend) &&
		challengeIdsFromFriendToMe.equals(_o.challengeIdsFromFriendToMe);
}

const char *pokerduel::client::ProfileResponse_userInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("country=");
	_buf.append(country);
	_buf.append(',');
	_buf.append("isOnline=");
	_buf.appendUint(isOnline);
	_buf.append(',');
	_buf.append("numChallengesFromMeToFriend=");
	_buf.appendInt(numChallengesFromMeToFriend);
	_buf.append(',');
	_buf.append("numChallengesFromFriendToMe=");
	_buf.appendInt(numChallengesFromFriendToMe);
	_buf.append(',');
	_buf.append("playerFlag=");
	_buf.appendUint(playerFlag);
	_buf.append(',');
	_buf.append("challengeIdsFromMeToFriend=");
	challengeIdsFromMeToFriend.toTraceString(_buf);
	_buf.append(',');
	_buf.append("challengeIdsFromFriendToMe=");
	challengeIdsFromFriendToMe.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::ProfileResponse_userInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOnline", isOnline, _buf);
	Atf::XmlElement::encodeAsXmlElement("numChallengesFromMeToFriend", numChallengesFromMeToFriend, _buf);
	Atf::XmlElement::encodeAsXmlElement("numChallengesFromFriendToMe", numChallengesFromFriendToMe, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerFlag", playerFlag, _buf);
	challengeIdsFromMeToFriend.toXmlString("challengeIdsFromMeToFriend", _buf);
	challengeIdsFromFriendToMe.toXmlString("challengeIdsFromFriendToMe", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::ProfileResponse_userInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("country"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
		}
		else if (_element.equals("isOnline"))
		{
			isOnline = (*_value.ptr() == '1');
		}
		else if (_element.equals("numChallengesFromMeToFriend"))
		{
			numChallengesFromMeToFriend = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numChallengesFromFriendToMe"))
		{
			numChallengesFromFriendToMe = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerFlag"))
		{
			playerFlag = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("challengeIdsFromMeToFriend"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT64 , 4 > >::FromXmlString(_value, challengeIdsFromMeToFriend)) return false;
		}
		else if (_element.equals("challengeIdsFromFriendToMe"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT64 , 4 > >::FromXmlString(_value, challengeIdsFromFriendToMe)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::ProfileResponse_userInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(imageId);
	_msg.composeString(country);
	_msg.composeBOOL(isOnline);
	_msg.composeINT32(numChallengesFromMeToFriend);
	_msg.composeINT32(numChallengesFromFriendToMe);
	_msg.composeUINT32(playerFlag);
	challengeIdsFromMeToFriend.composeMsg(_msg, _ignoreJSON);
	challengeIdsFromFriendToMe.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::client::ProfileResponse_userInfo::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(imageId);
	_parser.parseStringPN(country, 0, "country");
	_parser.parseBOOL(isOnline);
	_parser.parseINT32(numChallengesFromMeToFriend);
	_parser.parseINT32(numChallengesFromFriendToMe);
	_parser.parseUINT32(playerFlag);
	challengeIdsFromMeToFriend.parseMsg(_parser);
	challengeIdsFromFriendToMe.parseMsg(_parser);
}

void pokerduel::client::ProfileResponse_userInfo::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("imageId", imageId);
	_parser.parse("country", country);
	_parser.parse("isOnline", isOnline);
	_parser.parse("numChallengesFromMeToFriend", numChallengesFromMeToFriend);
	_parser.parse("numChallengesFromFriendToMe", numChallengesFromFriendToMe);
	_parser.parse("playerFlag", playerFlag);
	_parser.parse("challengeIdsFromMeToFriend", challengeIdsFromMeToFriend);
	_parser.parse("challengeIdsFromFriendToMe", challengeIdsFromFriendToMe);
}

const char *pokerduel::client::ProfileResponse_userInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("country", country);
	_jsonstr.compose("isOnline", isOnline);
	_jsonstr.compose("numChallengesFromMeToFriend", numChallengesFromMeToFriend);
	_jsonstr.compose("numChallengesFromFriendToMe", numChallengesFromFriendToMe);
	_jsonstr.compose("playerFlag", playerFlag);
	_jsonstr.compose("challengeIdsFromMeToFriend", challengeIdsFromMeToFriend);
	_jsonstr.compose("challengeIdsFromFriendToMe", challengeIdsFromFriendToMe);
	return _buf.c_str();
}

void pokerduel::client::ProfileResponse_userInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("country", country);
	_jparser.parseByNameThrow("isOnline", isOnline);
	_jparser.parseByNameThrow("numChallengesFromMeToFriend", numChallengesFromMeToFriend);
	_jparser.parseByNameThrow("numChallengesFromFriendToMe", numChallengesFromFriendToMe);
	_jparser.parseByNameThrow("playerFlag", playerFlag);
	_jparser.parseByNameThrow("challengeIdsFromMeToFriend", challengeIdsFromMeToFriend);
	_jparser.parseByNameThrow("challengeIdsFromFriendToMe", challengeIdsFromFriendToMe);
}

void pokerduel::client::ProfileResponse_userInfo::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("imageId", imageId);
	_jparser.validateByNameThrow("country", country);
	_jparser.validateByNameThrow("isOnline", isOnline);
	_jparser.validateByNameThrow("numChallengesFromMeToFriend", numChallengesFromMeToFriend);
	_jparser.validateByNameThrow("numChallengesFromFriendToMe", numChallengesFromFriendToMe);
	_jparser.validateByNameThrow("playerFlag", playerFlag);
	_jparser.validateByNameThrow("challengeIdsFromMeToFriend", challengeIdsFromMeToFriend);
	_jparser.validateByNameThrow("challengeIdsFromFriendToMe", challengeIdsFromFriendToMe);
}

/*static*/ void pokerduel::client::ProfileResponse_userInfo::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*imageId*/
	_parser.parseStringN(_dummy, 0, "country");  /*country*/
	bool isOnline; _parser.parseBOOL(isOnline);
	_parser.skip(4);  /*numChallengesFromMeToFriend*/
	_parser.skip(4);  /*numChallengesFromFriendToMe*/
	_parser.skip(4);  /*playerFlag*/
	Atf::LAtfVector< UINT64 , 4 >::validateMsg(_parser);  /*challengeIdsFromMeToFriend*/
	Atf::LAtfVector< UINT64 , 4 >::validateMsg(_parser);  /*challengeIdsFromFriendToMe*/
}

//=================================================================
//                    ProfileResponse_Friend
//=================================================================

pokerduel::client::ProfileResponse_Friend::ProfileResponse_Friend()
{
	clear();
}

void pokerduel::client::ProfileResponse_Friend::clear()
{
	numFriends = 0;
	isOnline = false;
	frdRelation = 0;
	playerFlag = 0;
}

bool pokerduel::client::ProfileResponse_Friend::equals(const ProfileResponse_Friend& _o) const
{
	return numFriends == _o.numFriends &&
		isOnline == _o.isOnline &&
		frdRelation == _o.frdRelation &&
		playerFlag == _o.playerFlag;
}

const char *pokerduel::client::ProfileResponse_Friend::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numFriends=");
	_buf.appendInt(numFriends);
	_buf.append(',');
	_buf.append("isOnline=");
	_buf.appendUint(isOnline);
	_buf.append(',');
	_buf.append("frdRelation=");
	_buf.appendUint(frdRelation);
	_buf.append(',');
	_buf.append("playerFlag=");
	_buf.appendUint(playerFlag);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::ProfileResponse_Friend::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numFriends", numFriends, _buf);
	Atf::XmlElement::encodeAsXmlElement("isOnline", isOnline, _buf);
	Atf::XmlElement::encodeAsXmlElement("frdRelation", frdRelation, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerFlag", playerFlag, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::ProfileResponse_Friend::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("numFriends"))
		{
			numFriends = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isOnline"))
		{
			isOnline = (*_value.ptr() == '1');
		}
		else if (_element.equals("frdRelation"))
		{
			frdRelation = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerFlag"))
		{
			playerFlag = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::ProfileResponse_Friend::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(numFriends);
	_msg.composeBOOL(isOnline);
	_msg.composeUINT32(frdRelation);
	_msg.composeUINT32(playerFlag);
}

void pokerduel::client::ProfileResponse_Friend::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(numFriends);
	_parser.parseBOOL(isOnline);
	_parser.parseUINT32(frdRelation);
	_parser.parseUINT32(playerFlag);
}

void pokerduel::client::ProfileResponse_Friend::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("numFriends", numFriends);
	_parser.parse("isOnline", isOnline);
	_parser.parse("frdRelation", frdRelation);
	_parser.parse("playerFlag", playerFlag);
}

const char *pokerduel::client::ProfileResponse_Friend::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numFriends", numFriends);
	_jsonstr.compose("isOnline", isOnline);
	_jsonstr.compose("frdRelation", frdRelation);
	_jsonstr.compose("playerFlag", playerFlag);
	return _buf.c_str();
}

void pokerduel::client::ProfileResponse_Friend::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numFriends", numFriends);
	_jparser.parseByNameThrow("isOnline", isOnline);
	_jparser.parseByNameThrow("frdRelation", frdRelation);
	_jparser.parseByNameThrow("playerFlag", playerFlag);
}

void pokerduel::client::ProfileResponse_Friend::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("numFriends", numFriends);
	_jparser.validateByNameThrow("isOnline", isOnline);
	_jparser.validateByNameThrow("frdRelation", frdRelation);
	_jparser.validateByNameThrow("playerFlag", playerFlag);
}

/*static*/ void pokerduel::client::ProfileResponse_Friend::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(4);  /*numFriends*/
	bool isOnline; _parser.parseBOOL(isOnline);
	_parser.skip(4);  /*frdRelation*/
	_parser.skip(4);  /*playerFlag*/
}

//=================================================================
//                    IceUserAchievementsVector
//=================================================================

pokerduel::client::IceUserAchievementsVector::IceUserAchievementsVector()
{
	clear();
}

void pokerduel::client::IceUserAchievementsVector::clear()
{
	userAchievements.clear();
}

bool pokerduel::client::IceUserAchievementsVector::equals(const IceUserAchievementsVector& _o) const
{
	return userAchievements.equals(_o.userAchievements);
}

const char *pokerduel::client::IceUserAchievementsVector::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userAchievements=");
	userAchievements.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::IceUserAchievementsVector::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	userAchievements.toXmlString("userAchievements", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::IceUserAchievementsVector::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("userAchievements"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< IceDuelsUserAchievement, 4 > >::FromXmlString(_value, userAchievements)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::IceUserAchievementsVector::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userAchievements.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::client::IceUserAchievementsVector::parseMsg(CommMsgParser& _parser)
{
	userAchievements.parseMsg(_parser);
}

void pokerduel::client::IceUserAchievementsVector::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("userAchievements", userAchievements);
}

const char *pokerduel::client::IceUserAchievementsVector::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userAchievements", userAchievements);
	return _buf.c_str();
}

void pokerduel::client::IceUserAchievementsVector::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userAchievements", userAchievements);
}

void pokerduel::client::IceUserAchievementsVector::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userAchievements", userAchievements);
}

/*static*/ void pokerduel::client::IceUserAchievementsVector::validateMsg(CommMsgParser& _parser)
{
	Atf::LAtfVector< IceDuelsUserAchievement, 4 >::validateMsg(_parser);  /*userAchievements*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_PROFILE_RESPONSE
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::clear()
{
	userId.clear();
	profileDataType = 0;
	data.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::equals(const Protocol_MSG_POKERDUEL_PROFILE_RESPONSE& _o) const
{
	return userId.equals(_o.userId) &&
		profileDataType == _o.profileDataType &&
		data.equals(_o.data);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_PROFILE_RESPONSE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_PROFILE_RESPONSE*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_PROFILE_RESPONSE).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("profileDataType=");
	_buf.appendInt(profileDataType);
	_buf.append(',');
	_buf.append("data=");
	data.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_PROFILE_RESPONSE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("profileDataType", profileDataType, _buf);
	data.toXmlString("data", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("profileDataType"))
			{
				profileDataType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("data"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, data)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT32(profileDataType);
	data.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseINT32(profileDataType);
	data.parseMsg(_parser);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("profileDataType", profileDataType);
	_jsonstr.compose("data", data);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("profileDataType", profileDataType);
	_jparser.parseByNameThrow("data", data);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("profileDataType", profileDataType);
	_jparser.validateByNameThrow("data", data);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(4);  /*profileDataType*/
	Atf::MsgBodyWithJSON::validateMsg(_parser);  /*data*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::clear()
{
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::equals(const Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS& _o) const
{
	return true;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS).append(")");
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                    AllAchievements
//=================================================================

pokerduel::client::AllAchievements::AllAchievements()
{
	clear();
}

void pokerduel::client::AllAchievements::clear()
{
	achievements.clear();
}

bool pokerduel::client::AllAchievements::equals(const AllAchievements& _o) const
{
	return achievements.equals(_o.achievements);
}

const char *pokerduel::client::AllAchievements::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("achievements=");
	achievements.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::AllAchievements::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	achievements.toXmlString("achievements", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::AllAchievements::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("achievements"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< IceDuelsAchievement, 4 > >::FromXmlString(_value, achievements)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::AllAchievements::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	achievements.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::client::AllAchievements::parseMsg(CommMsgParser& _parser)
{
	achievements.parseMsg(_parser);
}

void pokerduel::client::AllAchievements::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("achievements", achievements);
}

const char *pokerduel::client::AllAchievements::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("achievements", achievements);
	return _buf.c_str();
}

void pokerduel::client::AllAchievements::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("achievements", achievements);
}

void pokerduel::client::AllAchievements::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("achievements", achievements);
}

/*static*/ void pokerduel::client::AllAchievements::validateMsg(CommMsgParser& _parser)
{
	Atf::LAtfVector< IceDuelsAchievement, 4 >::validateMsg(_parser);  /*achievements*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	allAchievements.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::equals(const Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		allAchievements.equals(_o.allAchievements);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("allAchievements=");
		allAchievements.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		allAchievements.toXmlString("allAchievements", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("allAchievements"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, allAchievements)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		allAchievements.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		allAchievements.parseMsg(_parser);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("allAchievements", allAchievements);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("allAchievements", allAchievements);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("allAchievements", allAchievements);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		Atf::MsgBodyWithJSON::validateMsg(_parser);  /*allAchievements*/
	}
}

//=================================================================
//                    CompletedDuel
//=================================================================

pokerduel::client::CompletedDuel::CompletedDuel()
{
	clear();
}

void pokerduel::client::CompletedDuel::clear()
{
	duelId = 0;
	duelTypeId = 0;
	whenClosed.setNull();
	opponentUserId.clear();
	result = 0;
	isPlayMoney = false;
	currency.clear();
	amountWonLost = 0;
	siteMask = 0;
	opponentImageId = 0;
	opponentPlayerFlag = 0;
	lastChatOrdinal = 0;
	myLastOrdinalId = 0;
	ticketUsedForBuyin = false;
}

bool pokerduel::client::CompletedDuel::equals(const CompletedDuel& _o) const
{
	return duelId == _o.duelId &&
		duelTypeId == _o.duelTypeId &&
		whenClosed.equals(_o.whenClosed) &&
		opponentUserId.equals(_o.opponentUserId) &&
		result == _o.result &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		amountWonLost == _o.amountWonLost &&
		siteMask == _o.siteMask &&
		opponentImageId == _o.opponentImageId &&
		opponentPlayerFlag == _o.opponentPlayerFlag &&
		lastChatOrdinal == _o.lastChatOrdinal &&
		myLastOrdinalId == _o.myLastOrdinalId &&
		ticketUsedForBuyin == _o.ticketUsedForBuyin;
}

const char *pokerduel::client::CompletedDuel::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("whenClosed=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenClosed);
	_buf.append(',');
	_buf.append("opponentUserId=");
	_buf.append(opponentUserId);
	_buf.append(',');
	_buf.append("result=");
	_buf.appendInt(result);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amountWonLost=");
	_buf.appendInt64(amountWonLost);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("opponentImageId=");
	_buf.appendUint(opponentImageId);
	_buf.append(',');
	_buf.append("opponentPlayerFlag=");
	_buf.appendUint(opponentPlayerFlag);
	_buf.append(',');
	_buf.append("lastChatOrdinal=");
	_buf.appendInt(lastChatOrdinal);
	_buf.append(',');
	_buf.append("myLastOrdinalId=");
	_buf.appendInt(myLastOrdinalId);
	_buf.append(',');
	_buf.append("ticketUsedForBuyin=");
	_buf.appendUint(ticketUsedForBuyin);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::CompletedDuel::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenClosed", whenClosed);
	Atf::XmlElement::encodeAsXmlElement("opponentUserId", opponentUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("result", result, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountWonLost", amountWonLost, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("opponentImageId", opponentImageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("opponentPlayerFlag", opponentPlayerFlag, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastChatOrdinal", lastChatOrdinal, _buf);
	Atf::XmlElement::encodeAsXmlElement("myLastOrdinalId", myLastOrdinalId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketUsedForBuyin", ticketUsedForBuyin, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::CompletedDuel::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("duelId"))
		{
			duelId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenClosed"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenClosed);
		}
		else if (_element.equals("opponentUserId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, opponentUserId)) return false;
		}
		else if (_element.equals("result"))
		{
			result = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("amountWonLost"))
		{
			amountWonLost = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteMask"))
		{
			siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("opponentImageId"))
		{
			opponentImageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("opponentPlayerFlag"))
		{
			opponentPlayerFlag = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastChatOrdinal"))
		{
			lastChatOrdinal = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("myLastOrdinalId"))
		{
			myLastOrdinalId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketUsedForBuyin"))
		{
			ticketUsedForBuyin = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::CompletedDuel::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CompletedDuel())) // not empty
	{
		_body.composeUINT64(duelId);
		_body.composeUINT32(duelTypeId);
		_body.composeSrvTime(whenClosed);
		_body.composeString(opponentUserId);
		_body.composeINT32(result);
		_body.composeBOOL(isPlayMoney);
		_body.composeString(currency);
		_body.composeINT64(amountWonLost);
		_body.composeUINT32(siteMask);
		_body.composeUINT32(opponentImageId);
		_body.composeUINT32(opponentPlayerFlag);
		_body.composeINT32(lastChatOrdinal);
		_body.composeINT32(myLastOrdinalId);
		_body.composeBOOL(ticketUsedForBuyin);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::client::CompletedDuel::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(duelId);
	_parser0.parseUINT32(duelTypeId);
	_parser0.parseSrvTime(whenClosed);
	_parser0.parseStringPN(opponentUserId, 0, "opponentUserId");
	_parser0.parseINT32(result);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseStringPN(currency, 0, "currency");
	_parser0.parseINT64(amountWonLost);
	_parser0.parseUINT32(siteMask);
	_parser0.parseUINT32(opponentImageId);
	_parser0.parseUINT32(opponentPlayerFlag);
	_parser0.parseINT32(lastChatOrdinal);
	_parser0.parseINT32(myLastOrdinalId);
	_parser0.parseBOOL(ticketUsedForBuyin);
}

void pokerduel::client::CompletedDuel::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("duelId", duelId);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("whenClosed", whenClosed);
	_parser0.parse("opponentUserId", opponentUserId);
	_parser0.parse("result", result);
	_parser0.parse("isPlayMoney", isPlayMoney);
	_parser0.parse("currency", currency);
	_parser0.parse("amountWonLost", amountWonLost);
	_parser0.parse("siteMask", siteMask);
	_parser0.parse("opponentImageId", opponentImageId);
	_parser0.parse("opponentPlayerFlag", opponentPlayerFlag);
	_parser0.parse("lastChatOrdinal", lastChatOrdinal);
	_parser0.parse("myLastOrdinalId", myLastOrdinalId);
	_parser0.parse("ticketUsedForBuyin", ticketUsedForBuyin);
}

const char *pokerduel::client::CompletedDuel::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("whenClosed", whenClosed);
	_jsonstr.compose("opponentUserId", opponentUserId);
	_jsonstr.compose("result", result);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("amountWonLost", amountWonLost);
	_jsonstr.compose("siteMask", siteMask);
	_jsonstr.compose("opponentImageId", opponentImageId);
	_jsonstr.compose("opponentPlayerFlag", opponentPlayerFlag);
	_jsonstr.compose("lastChatOrdinal", lastChatOrdinal);
	_jsonstr.compose("myLastOrdinalId", myLastOrdinalId);
	_jsonstr.compose("ticketUsedForBuyin", ticketUsedForBuyin);
	return _buf.c_str();
}

void pokerduel::client::CompletedDuel::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("whenClosed", whenClosed);
	_jparser.parseByNameThrow("opponentUserId", opponentUserId);
	_jparser.parseByNameThrow("result", result);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("amountWonLost", amountWonLost);
	_jparser.parseByNameThrow("siteMask", siteMask);
	_jparser.parseByNameThrow("opponentImageId", opponentImageId);
	_jparser.parseByNameThrow("opponentPlayerFlag", opponentPlayerFlag);
	_jparser.parseByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.parseByNameThrow("myLastOrdinalId", myLastOrdinalId);
	_jparser.parseByNameThrow("ticketUsedForBuyin", ticketUsedForBuyin);
}

void pokerduel::client::CompletedDuel::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("whenClosed", whenClosed);
	_jparser.validateByNameThrow("opponentUserId", opponentUserId);
	_jparser.validateByNameThrow("result", result);
	_jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.validateByNameThrow("currency", currency);
	_jparser.validateByNameThrow("amountWonLost", amountWonLost);
	_jparser.validateByNameThrow("siteMask", siteMask);
	_jparser.validateByNameThrow("opponentImageId", opponentImageId);
	_jparser.validateByNameThrow("opponentPlayerFlag", opponentPlayerFlag);
	_jparser.validateByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.validateByNameThrow("myLastOrdinalId", myLastOrdinalId);
	_jparser.validateByNameThrow("ticketUsedForBuyin", ticketUsedForBuyin);
}

/*static*/ void pokerduel::client::CompletedDuel::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy;
	_parser0.skip(8);  /*duelId*/
	_parser0.skip(4);  /*duelTypeId*/
	_parser0.skip(8);  /*whenClosed*/
	_parser0.parseStringN(_dummy, 0, "opponentUserId");  /*opponentUserId*/
	_parser0.skip(4);  /*result*/
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	_parser0.parseStringN(_dummy, 0, "currency");  /*currency*/
	_parser0.skip(8);  /*amountWonLost*/
	_parser0.skip(4);  /*siteMask*/
	_parser0.skip(4);  /*opponentImageId*/
	_parser0.skip(4);  /*opponentPlayerFlag*/
	_parser0.skip(4);  /*lastChatOrdinal*/
	_parser0.skip(4);  /*myLastOrdinalId*/
	bool ticketUsedForBuyin; _parser0.parseBOOL(ticketUsedForBuyin);
	AtfValidator::validateEmbeddedMsgbodyParser("client::CompletedDuel", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    CancelledChallenge
//=================================================================

pokerduel::client::CancelledChallenge::CancelledChallenge()
{
	clear();
}

void pokerduel::client::CancelledChallenge::clear()
{
	challengeId = 0;
	duelTypeId = 0;
	opponentUserId.clear();
	challengeResponse = 0;
	whenResponse.setNull();
	isPlayMoney = false;
	currency.clear();
	amountRefunded = 0;
	siteMask = 0;
	ticketAmount = 0;
}

bool pokerduel::client::CancelledChallenge::equals(const CancelledChallenge& _o) const
{
	return challengeId == _o.challengeId &&
		duelTypeId == _o.duelTypeId &&
		opponentUserId.equals(_o.opponentUserId) &&
		challengeResponse == _o.challengeResponse &&
		whenResponse.equals(_o.whenResponse) &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		amountRefunded == _o.amountRefunded &&
		siteMask == _o.siteMask &&
		ticketAmount == _o.ticketAmount;
}

const char *pokerduel::client::CancelledChallenge::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("opponentUserId=");
	_buf.append(opponentUserId);
	_buf.append(',');
	_buf.append("challengeResponse=");
	_buf.appendInt(challengeResponse);
	_buf.append(',');
	_buf.append("whenResponse=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenResponse);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amountRefunded=");
	_buf.appendInt64(amountRefunded);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("ticketAmount=");
	_buf.appendInt64(ticketAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::CancelledChallenge::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("opponentUserId", opponentUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("challengeResponse", challengeResponse, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenResponse", whenResponse);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountRefunded", amountRefunded, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketAmount", ticketAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::CancelledChallenge::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("challengeId"))
		{
			challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("opponentUserId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, opponentUserId)) return false;
		}
		else if (_element.equals("challengeResponse"))
		{
			challengeResponse = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenResponse"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenResponse);
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("amountRefunded"))
		{
			amountRefunded = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteMask"))
		{
			siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketAmount"))
		{
			ticketAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::CancelledChallenge::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CancelledChallenge())) // not empty
	{
		_body.composeUINT64(challengeId);
		_body.composeUINT32(duelTypeId);
		_body.composeString(opponentUserId);
		_body.composeINT32(challengeResponse);
		_body.composeSrvTime(whenResponse);
		_body.composeBOOL(isPlayMoney);
		_body.composeString(currency);
		_body.composeINT64(amountRefunded);
		_body.composeUINT32(siteMask);
		_body.composeINT64(ticketAmount);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::client::CancelledChallenge::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(challengeId);
	_parser0.parseUINT32(duelTypeId);
	_parser0.parseStringPN(opponentUserId, 0, "opponentUserId");
	_parser0.parseINT32(challengeResponse);
	_parser0.parseSrvTime(whenResponse);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseStringPN(currency, 0, "currency");
	_parser0.parseINT64(amountRefunded);
	_parser0.parseUINT32(siteMask);
	_parser0.parseINT64(ticketAmount);
}

void pokerduel::client::CancelledChallenge::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("challengeId", challengeId);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("opponentUserId", opponentUserId);
	_parser0.parse("challengeResponse", challengeResponse);
	_parser0.parse("whenResponse", whenResponse);
	_parser0.parse("isPlayMoney", isPlayMoney);
	_parser0.parse("currency", currency);
	_parser0.parse("amountRefunded", amountRefunded);
	_parser0.parse("siteMask", siteMask);
	_parser0.parse("ticketAmount", ticketAmount);
}

const char *pokerduel::client::CancelledChallenge::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("opponentUserId", opponentUserId);
	_jsonstr.compose("challengeResponse", challengeResponse);
	_jsonstr.compose("whenResponse", whenResponse);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("amountRefunded", amountRefunded);
	_jsonstr.compose("siteMask", siteMask);
	_jsonstr.compose("ticketAmount", ticketAmount);
	return _buf.c_str();
}

void pokerduel::client::CancelledChallenge::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeId", challengeId);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("opponentUserId", opponentUserId);
	_jparser.parseByNameThrow("challengeResponse", challengeResponse);
	_jparser.parseByNameThrow("whenResponse", whenResponse);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("amountRefunded", amountRefunded);
	_jparser.parseByNameThrow("siteMask", siteMask);
	_jparser.parseByNameThrow("ticketAmount", ticketAmount);
}

void pokerduel::client::CancelledChallenge::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeId", challengeId);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("opponentUserId", opponentUserId);
	_jparser.validateByNameThrow("challengeResponse", challengeResponse);
	_jparser.validateByNameThrow("whenResponse", whenResponse);
	_jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.validateByNameThrow("currency", currency);
	_jparser.validateByNameThrow("amountRefunded", amountRefunded);
	_jparser.validateByNameThrow("siteMask", siteMask);
	_jparser.validateByNameThrow("ticketAmount", ticketAmount);
}

/*static*/ void pokerduel::client::CancelledChallenge::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy;
	_parser0.skip(8);  /*challengeId*/
	_parser0.skip(4);  /*duelTypeId*/
	_parser0.parseStringN(_dummy, 0, "opponentUserId");  /*opponentUserId*/
	_parser0.skip(4);  /*challengeResponse*/
	_parser0.skip(8);  /*whenResponse*/
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	_parser0.parseStringN(_dummy, 0, "currency");  /*currency*/
	_parser0.skip(8);  /*amountRefunded*/
	_parser0.skip(4);  /*siteMask*/
	_parser0.skip(8);  /*ticketAmount*/
	AtfValidator::validateEmbeddedMsgbodyParser("client::CancelledChallenge", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                    CancelledRandomPoolEntry
//=================================================================

pokerduel::client::CancelledRandomPoolEntry::CancelledRandomPoolEntry()
{
	clear();
}

void pokerduel::client::CancelledRandomPoolEntry::clear()
{
	duelTypeId = 0;
	whenCancelled.setNull();
	reason = 0;
	isPlayMoney = false;
	currency.clear();
	amountRefunded = 0;
	siteMask = 0;
	ticketAmount = 0;
}

bool pokerduel::client::CancelledRandomPoolEntry::equals(const CancelledRandomPoolEntry& _o) const
{
	return duelTypeId == _o.duelTypeId &&
		whenCancelled.equals(_o.whenCancelled) &&
		reason == _o.reason &&
		isPlayMoney == _o.isPlayMoney &&
		currency.equals(_o.currency) &&
		amountRefunded == _o.amountRefunded &&
		siteMask == _o.siteMask &&
		ticketAmount == _o.ticketAmount;
}

const char *pokerduel::client::CancelledRandomPoolEntry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("whenCancelled=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, whenCancelled);
	_buf.append(',');
	_buf.append("reason=");
	_buf.appendInt(reason);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amountRefunded=");
	_buf.appendInt64(amountRefunded);
	_buf.append(',');
	_buf.append("siteMask=");
	_buf.appendUint(siteMask);
	_buf.append(',');
	_buf.append("ticketAmount=");
	_buf.appendInt64(ticketAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::CancelledRandomPoolEntry::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "whenCancelled", whenCancelled);
	Atf::XmlElement::encodeAsXmlElement("reason", reason, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("amountRefunded", amountRefunded, _buf);
	Atf::XmlElement::encodeAsXmlElement("siteMask", siteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketAmount", ticketAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::CancelledRandomPoolEntry::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("duelTypeId"))
		{
			duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenCancelled"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, whenCancelled);
		}
		else if (_element.equals("reason"))
		{
			reason = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("amountRefunded"))
		{
			amountRefunded = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("siteMask"))
		{
			siteMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ticketAmount"))
		{
			ticketAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::CancelledRandomPoolEntry::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CancelledRandomPoolEntry())) // not empty
	{
		_body.composeUINT32(duelTypeId);
		_body.composeSrvTime(whenCancelled);
		_body.composeINT32(reason);
		_body.composeBOOL(isPlayMoney);
		_body.composeString(currency);
		_body.composeINT64(amountRefunded);
		_body.composeUINT32(siteMask);
		_body.composeINT64(ticketAmount);
	}

	_msg.composeMsgBody(_body);
}

void pokerduel::client::CancelledRandomPoolEntry::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(duelTypeId);
	_parser0.parseSrvTime(whenCancelled);
	_parser0.parseINT32(reason);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseStringPN(currency, 0, "currency");
	_parser0.parseINT64(amountRefunded);
	_parser0.parseUINT32(siteMask);
	_parser0.parseINT64(ticketAmount);
}

void pokerduel::client::CancelledRandomPoolEntry::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	Atf::MsgParserWithJSONForMsgBodyStruct _parser0(_parser);
	_parser0.parse("duelTypeId", duelTypeId);
	_parser0.parse("whenCancelled", whenCancelled);
	_parser0.parse("reason", reason);
	_parser0.parse("isPlayMoney", isPlayMoney);
	_parser0.parse("currency", currency);
	_parser0.parse("amountRefunded", amountRefunded);
	_parser0.parse("siteMask", siteMask);
	_parser0.parse("ticketAmount", ticketAmount);
}

const char *pokerduel::client::CancelledRandomPoolEntry::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("whenCancelled", whenCancelled);
	_jsonstr.compose("reason", reason);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("amountRefunded", amountRefunded);
	_jsonstr.compose("siteMask", siteMask);
	_jsonstr.compose("ticketAmount", ticketAmount);
	return _buf.c_str();
}

void pokerduel::client::CancelledRandomPoolEntry::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("whenCancelled", whenCancelled);
	_jparser.parseByNameThrow("reason", reason);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("amountRefunded", amountRefunded);
	_jparser.parseByNameThrow("siteMask", siteMask);
	_jparser.parseByNameThrow("ticketAmount", ticketAmount);
}

void pokerduel::client::CancelledRandomPoolEntry::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("whenCancelled", whenCancelled);
	_jparser.validateByNameThrow("reason", reason);
	_jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.validateByNameThrow("currency", currency);
	_jparser.validateByNameThrow("amountRefunded", amountRefunded);
	_jparser.validateByNameThrow("siteMask", siteMask);
	_jparser.validateByNameThrow("ticketAmount", ticketAmount);
}

/*static*/ void pokerduel::client::CancelledRandomPoolEntry::validateMsg(CommMsgParser& _parser)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy;
	_parser0.skip(4);  /*duelTypeId*/
	_parser0.skip(8);  /*whenCancelled*/
	_parser0.skip(4);  /*reason*/
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	_parser0.parseStringN(_dummy, 0, "currency");  /*currency*/
	_parser0.skip(8);  /*amountRefunded*/
	_parser0.skip(4);  /*siteMask*/
	_parser0.skip(8);  /*ticketAmount*/
	AtfValidator::validateEmbeddedMsgbodyParser("client::CancelledRandomPoolEntry", _parser0.msgBodyViewSize(), _parser0._shift(), _parser._shift());
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GETHISTORY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::Protocol_MSG_POKERDUEL_GETHISTORY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::clear()
{
	numEvents = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::equals(const Protocol_MSG_POKERDUEL_GETHISTORY& _o) const
{
	return numEvents == _o.numEvents;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GETHISTORY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GETHISTORY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GETHISTORY).append(")");
	_buf.append(',');
	_buf.append("numEvents=");
	_buf.appendInt(numEvents);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GETHISTORY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("numEvents", numEvents, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("numEvents"))
			{
				numEvents = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(numEvents);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(numEvents);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numEvents", numEvents);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numEvents", numEvents);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("numEvents", numEvents);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(4);  /*numEvents*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GETHISTORY_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	moreEventsAvailable = false;
	duels.clear();
	cancelledChallenges.clear();
	cancelledRandomPoolEntries.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::equals(const Protocol_MSG_POKERDUEL_GETHISTORY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		moreEventsAvailable == _o.moreEventsAvailable &&
		duels.equals(_o.duels) &&
		cancelledChallenges.equals(_o.cancelledChallenges) &&
		cancelledRandomPoolEntries.equals(_o.cancelledRandomPoolEntries);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GETHISTORY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GETHISTORY_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GETHISTORY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("moreEventsAvailable=");
		_buf.appendUint(moreEventsAvailable);
		_buf.append(',');
		_buf.append("duels=");
		duels.toTraceString(_buf);
		_buf.append(',');
		_buf.append("cancelledChallenges=");
		cancelledChallenges.toTraceString(_buf);
		_buf.append(',');
		_buf.append("cancelledRandomPoolEntries=");
		cancelledRandomPoolEntries.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GETHISTORY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("moreEventsAvailable", moreEventsAvailable, _buf);
		duels.toXmlString("duels", _buf);
		cancelledChallenges.toXmlString("cancelledChallenges", _buf);
		cancelledRandomPoolEntries.toXmlString("cancelledRandomPoolEntries", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("moreEventsAvailable"))
			{
				moreEventsAvailable = (*_value.ptr() == '1');
			}
			else if (_element.equals("duels"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CompletedDuel , 4 > >::FromXmlString(_value, duels)) return false;
			}
			else if (_element.equals("cancelledChallenges"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CancelledChallenge , 4 > >::FromXmlString(_value, cancelledChallenges)) return false;
			}
			else if (_element.equals("cancelledRandomPoolEntries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CancelledRandomPoolEntry , 4 > >::FromXmlString(_value, cancelledRandomPoolEntries)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		_msg.composeBOOL(moreEventsAvailable);
		duels.composeMsg(_msg, _ignoreJSON);
		cancelledChallenges.composeMsg(_msg, _ignoreJSON);
		cancelledRandomPoolEntries.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		_parser.parseBOOL(moreEventsAvailable);
		duels.parseMsg(_parser);
		cancelledChallenges.parseMsg(_parser);
		cancelledRandomPoolEntries.parseMsg(_parser);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("moreEventsAvailable", moreEventsAvailable);
		_jsonstr.compose("duels", duels);
		_jsonstr.compose("cancelledChallenges", cancelledChallenges);
		_jsonstr.compose("cancelledRandomPoolEntries", cancelledRandomPoolEntries);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("moreEventsAvailable", moreEventsAvailable);
		_jparser.parseByNameThrow("duels", duels);
		_jparser.parseByNameThrow("cancelledChallenges", cancelledChallenges);
		_jparser.parseByNameThrow("cancelledRandomPoolEntries", cancelledRandomPoolEntries);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("moreEventsAvailable", moreEventsAvailable);
		_jparser.validateByNameThrow("duels", duels);
		_jparser.validateByNameThrow("cancelledChallenges", cancelledChallenges);
		_jparser.validateByNameThrow("cancelledRandomPoolEntries", cancelledRandomPoolEntries);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		bool moreEventsAvailable; _parser.parseBOOL(moreEventsAvailable);
		Atf::LAtfVector< CompletedDuel , 4 >::validateMsg(_parser);  /*duels*/
		Atf::LAtfVector< CancelledChallenge , 4 >::validateMsg(_parser);  /*cancelledChallenges*/
		Atf::LAtfVector< CancelledRandomPoolEntry , 4 >::validateMsg(_parser);  /*cancelledRandomPoolEntries*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_REPLAY_DUEL
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::Protocol_MSG_POKERDUEL_REPLAY_DUEL()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::clear()
{
	duelId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::equals(const Protocol_MSG_POKERDUEL_REPLAY_DUEL& _o) const
{
	return duelId == _o.duelId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_REPLAY_DUEL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_REPLAY_DUEL*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_REPLAY_DUEL).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_REPLAY_DUEL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	lastChatOrdinal_deprecated = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::equals(const Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		lastChatOrdinal_deprecated == _o.lastChatOrdinal_deprecated;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_REPLAY_DUEL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_REPLAY_DUEL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("lastChatOrdinal_deprecated=");
		_buf.appendInt(lastChatOrdinal_deprecated);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_REPLAY_DUEL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("lastChatOrdinal_deprecated", lastChatOrdinal_deprecated, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("lastChatOrdinal_deprecated"))
			{
				lastChatOrdinal_deprecated = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		_msg.composeINT32(lastChatOrdinal_deprecated);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		_parser.parseINT32(lastChatOrdinal_deprecated);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("lastChatOrdinal_deprecated", lastChatOrdinal_deprecated);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("lastChatOrdinal_deprecated", lastChatOrdinal_deprecated);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("lastChatOrdinal_deprecated", lastChatOrdinal_deprecated);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		_parser.skip(4);  /*lastChatOrdinal_deprecated*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::clear()
{
	duelTypeId = 0;
	matchType_deprecated = 0;
	context = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::equals(const Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK& _o) const
{
	return duelTypeId == _o.duelTypeId &&
		matchType_deprecated == _o.matchType_deprecated &&
		context == _o.context;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_PRECONFIRMATION_CHECK != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_PRECONFIRMATION_CHECK).append(")");
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	_buf.append(',');
	_buf.append("matchType_deprecated=");
	_buf.appendInt(matchType_deprecated);
	_buf.append(',');
	_buf.append("context=");
	_buf.appendInt(context);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_PRECONFIRMATION_CHECK).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("matchType_deprecated", matchType_deprecated, _buf);
	Atf::XmlElement::encodeAsXmlElement("context", context, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("matchType_deprecated"))
			{
				matchType_deprecated = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("context"))
			{
				context = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(duelTypeId);
	_msg.composeINT32(matchType_deprecated);
	_msg.composeINT32(context);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(duelTypeId);
	_parser.parseINT32(matchType_deprecated);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(context);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	_jsonstr.compose("matchType_deprecated", matchType_deprecated);
	_jsonstr.compose("context", context);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
	_jparser.parseByNameThrow("matchType_deprecated", matchType_deprecated);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("context", context);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
	_jparser.validateByNameThrow("matchType_deprecated", matchType_deprecated);
	if(_jparser.parseEnded()) return;
	_jparser.validateByNameThrow("context", context);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(4);  /*duelTypeId*/
	_parser.skip(4);  /*matchType_deprecated*/
	if(_parser.parseEnded()) return;
	_parser.skip(4);  /*context*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	extraErrorInfo.clear();
	errTitle.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::equals(const Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		extraErrorInfo.equals(_o.extraErrorInfo) &&
		errTitle.equals(_o.errTitle);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("extraErrorInfo=");
		extraErrorInfo.toTraceString(_buf);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		extraErrorInfo.toXmlString("extraErrorInfo", _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("extraErrorInfo"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, extraErrorInfo)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		extraErrorInfo.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(errTitle);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		extraErrorInfo.parseMsg(_parser);
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("extraErrorInfo", extraErrorInfo);
		_jsonstr.compose("errTitle", errTitle);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("extraErrorInfo", extraErrorInfo);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("extraErrorInfo", extraErrorInfo);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		Atf::MsgBodyWithJSON::validateMsg(_parser);  /*extraErrorInfo*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::clear()
{
	challengeId = 0;
	reason = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::equals(const Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED& _o) const
{
	return challengeId == _o.challengeId &&
		reason == _o.reason;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED).append(")");
	_buf.append(',');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("reason=");
	_buf.appendInt(reason);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("reason", reason, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("challengeId"))
			{
				challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("reason"))
			{
				reason = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(challengeId);
	_msg.composeINT32(reason);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(challengeId);
	_parser.parseINT32(reason);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("reason", reason);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeId", challengeId);
	_jparser.parseByNameThrow("reason", reason);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeId", challengeId);
	_jparser.validateByNameThrow("reason", reason);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*challengeId*/
	_parser.skip(4);  /*reason*/
}

//=================================================================
//                    DuelClientChatItem
//=================================================================

pokerduel::client::DuelClientChatItem::DuelClientChatItem()
{
	clear();
}

void pokerduel::client::DuelClientChatItem::clear()
{
	ordinal = 0;
	userId.clear();
	time = 0;
	chat.clear();
}

bool pokerduel::client::DuelClientChatItem::equals(const DuelClientChatItem& _o) const
{
	return ordinal == _o.ordinal &&
		userId.equals(_o.userId) &&
		time == _o.time &&
		chat.equals(_o.chat);
}

const char *pokerduel::client::DuelClientChatItem::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ordinal=");
	_buf.appendInt(ordinal);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("time=");
	_buf.appendUint64(time);
	_buf.append(',');
	_buf.append("chat=");
	_buf.append(chat);
	_buf.append('}');
	return _buf.c_str();
}

const char *pokerduel::client::DuelClientChatItem::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ordinal", ordinal, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("time", time, _buf);
	Atf::XmlElement::encodeAsXmlElement("chat", chat, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool pokerduel::client::DuelClientChatItem::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
	{
		if (_element.equals("ordinal"))
		{
			ordinal = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("time"))
		{
			time = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chat"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, chat)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void pokerduel::client::DuelClientChatItem::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(ordinal);
	_msg.composeString(userId);
	_msg.composeUINT64(time);
	_msg.composeString(chat);
}

void pokerduel::client::DuelClientChatItem::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(ordinal);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseUINT64(time);
	_parser.parseStringPN(chat, 0, "chat");
}

void pokerduel::client::DuelClientChatItem::parseMsg(Atf::MsgParserWithJSON& _parser)
{
	_parser.parse("ordinal", ordinal);
	_parser.parse("userId", userId);
	_parser.parse("time", time);
	_parser.parse("chat", chat);
}

const char *pokerduel::client::DuelClientChatItem::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ordinal", ordinal);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("time", time);
	_jsonstr.compose("chat", chat);
	return _buf.c_str();
}

void pokerduel::client::DuelClientChatItem::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ordinal", ordinal);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("time", time);
	_jparser.parseByNameThrow("chat", chat);
}

void pokerduel::client::DuelClientChatItem::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("ordinal", ordinal);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("time", time);
	_jparser.validateByNameThrow("chat", chat);
}

/*static*/ void pokerduel::client::DuelClientChatItem::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(4);  /*ordinal*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.skip(8);  /*time*/
	_parser.parseStringN(_dummy, 0, "chat");  /*chat*/
}

//=================================================================
//                Protocol_MSG_DUEL_CHAT_REQUEST
//=================================================================

pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::Protocol_MSG_DUEL_CHAT_REQUEST()
{
	clear();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::clear()
{
	duelId = 0;
	userId.clear();
	chat.clear();
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::equals(const Protocol_MSG_DUEL_CHAT_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		userId.equals(_o.userId) &&
		chat.equals(_o.chat);
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_CHAT_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_CHAT_REQUEST*)_other));
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_CHAT_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("chat=");
	_buf.append(chat);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_CHAT_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("chat", chat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("chat"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, chat)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeString(userId);
	_msg.composeString(chat);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseStringPN(userId, 0, "userId");
	_parser.parseStringPN(chat, 0, "chat");
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("chat", chat);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("chat", chat);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("userId", userId);
	_jparser.validateByNameThrow("chat", chat);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REQUEST::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.skip(8);  /*duelId*/
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
	_parser.parseStringN(_dummy, 0, "chat");  /*chat*/
}

//=================================================================
//                Protocol_MSG_DUEL_CHAT_BROADCAST
//=================================================================

pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::Protocol_MSG_DUEL_CHAT_BROADCAST()
{
	clear();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::clear()
{
	duelId = 0;
	lastChatOrdinal = 0;
	chat.clear();
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::equals(const Protocol_MSG_DUEL_CHAT_BROADCAST& _o) const
{
	return duelId == _o.duelId &&
		lastChatOrdinal == _o.lastChatOrdinal &&
		chat.equals(_o.chat);
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_CHAT_BROADCAST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_CHAT_BROADCAST*)_other));
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_CHAT_BROADCAST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("lastChatOrdinal=");
	_buf.appendInt(lastChatOrdinal);
	_buf.append(',');
	_buf.append("chat=");
	chat.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_CHAT_BROADCAST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastChatOrdinal", lastChatOrdinal, _buf);
	chat.toXmlString("chat", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("lastChatOrdinal"))
			{
				lastChatOrdinal = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chat"))
			{
				if(!Atf::AtfTempl< DuelClientChatItem >::FromXmlString(_value, chat)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeINT32(lastChatOrdinal);
	chat.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseINT32(lastChatOrdinal);
	chat.parseMsg(_parser);
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("lastChatOrdinal", lastChatOrdinal);
	_jsonstr.compose("chat", chat);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.parseByNameThrow("chat", chat);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.validateByNameThrow("chat", chat);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_BROADCAST::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*lastChatOrdinal*/
	DuelClientChatItem::validateMsg(_parser);  /*chat*/
}

//=================================================================
//                Protocol_MSG_DUEL_CHAT_SYNC_REQUEST
//=================================================================

pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST()
{
	clear();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::clear()
{
	duelId = 0;
	start = 0;
	size = 0;
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::equals(const Protocol_MSG_DUEL_CHAT_SYNC_REQUEST& _o) const
{
	return duelId == _o.duelId &&
		start == _o.start &&
		size == _o.size;
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_CHAT_SYNC_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_CHAT_SYNC_REQUEST*)_other));
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_CHAT_SYNC_REQUEST).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("start=");
	_buf.appendInt(start);
	_buf.append(',');
	_buf.append("size=");
	_buf.appendInt(size);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_CHAT_SYNC_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("start", start, _buf);
	Atf::XmlElement::encodeAsXmlElement("size", size, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("start"))
			{
				start = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("size"))
			{
				size = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeINT32(start);
	_msg.composeINT32(size);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseINT32(start);
	_parser.parseINT32(size);
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("start", start);
	_jsonstr.compose("size", size);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("start", start);
	_jparser.parseByNameThrow("size", size);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("start", start);
	_jparser.validateByNameThrow("size", size);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*start*/
	_parser.skip(4);  /*size*/
}

//=================================================================
//                Protocol_MSG_DUEL_CHAT_SYNC_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::Protocol_MSG_DUEL_CHAT_SYNC_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::clear()
{
	duelId = 0;
	lastChatOrdinal = 0;
	chats.clear();
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::equals(const Protocol_MSG_DUEL_CHAT_SYNC_REPLY& _o) const
{
	return duelId == _o.duelId &&
		lastChatOrdinal == _o.lastChatOrdinal &&
		chats.equals(_o.chats);
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_CHAT_SYNC_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_CHAT_SYNC_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_CHAT_SYNC_REPLY).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("lastChatOrdinal=");
	_buf.appendInt(lastChatOrdinal);
	_buf.append(',');
	_buf.append("chats=");
	chats.toTraceString(_buf);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_CHAT_SYNC_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastChatOrdinal", lastChatOrdinal, _buf);
	chats.toXmlString("chats", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("lastChatOrdinal"))
			{
				lastChatOrdinal = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("chats"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< DuelClientChatItem , 4 > >::FromXmlString(_value, chats)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeINT32(lastChatOrdinal);
	chats.composeMsg(_msg, _ignoreJSON);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseINT32(lastChatOrdinal);
	chats.parseMsg(_parser);
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("lastChatOrdinal", lastChatOrdinal);
	_jsonstr.compose("chats", chats);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.parseByNameThrow("chats", chats);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("lastChatOrdinal", lastChatOrdinal);
	_jparser.validateByNameThrow("chats", chats);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*lastChatOrdinal*/
	Atf::LAtfVector< DuelClientChatItem , 4 >::validateMsg(_parser);  /*chats*/
}

//=================================================================
//                Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID
//=================================================================

pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID()
{
	clear();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::clear()
{
	duelId = 0;
	myLastOrdinalId = 0;
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::equals(const Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID& _o) const
{
	return duelId == _o.duelId &&
		myLastOrdinalId == _o.myLastOrdinalId;
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID*)_other));
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	_buf.append(',');
	_buf.append("myLastOrdinalId=");
	_buf.appendInt(myLastOrdinalId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	Atf::XmlElement::encodeAsXmlElement("myLastOrdinalId", myLastOrdinalId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("myLastOrdinalId"))
			{
				myLastOrdinalId = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
	_msg.composeINT32(myLastOrdinalId);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
	_parser.parseINT32(myLastOrdinalId);
}

const char *pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	_jsonstr.compose("myLastOrdinalId", myLastOrdinalId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
	_jparser.parseByNameThrow("myLastOrdinalId", myLastOrdinalId);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
	_jparser.validateByNameThrow("myLastOrdinalId", myLastOrdinalId);
}

void pokerduel::client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
	_parser.skip(4);  /*myLastOrdinalId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::clear()
{
	userId.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::equals(const Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO& _o) const
{
	return userId.equals(_o.userId);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringPN(userId, 0, "userId");
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("userId", userId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	_parser.parseStringN(_dummy, 0, "userId");  /*userId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	toFriendChallenges.clear();
	fromFriendChallenges.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::equals(const Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		toFriendChallenges.equals(_o.toFriendChallenges) &&
		fromFriendChallenges.equals(_o.fromFriendChallenges);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("toFriendChallenges=");
		toFriendChallenges.toTraceString(_buf);
		_buf.append(',');
		_buf.append("fromFriendChallenges=");
		fromFriendChallenges.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		toFriendChallenges.toXmlString("toFriendChallenges", _buf);
		fromFriendChallenges.toXmlString("fromFriendChallenges", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("toFriendChallenges"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, toFriendChallenges)) return false;
			}
			else if (_element.equals("fromFriendChallenges"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, fromFriendChallenges)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		toFriendChallenges.composeMsg(_msg, _ignoreJSON);
		fromFriendChallenges.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		toFriendChallenges.parseMsg(_parser);
		fromFriendChallenges.parseMsg(_parser);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("toFriendChallenges", toFriendChallenges);
		_jsonstr.compose("fromFriendChallenges", fromFriendChallenges);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("toFriendChallenges", toFriendChallenges);
		_jparser.parseByNameThrow("fromFriendChallenges", fromFriendChallenges);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("toFriendChallenges", toFriendChallenges);
		_jparser.validateByNameThrow("fromFriendChallenges", fromFriendChallenges);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser);  /*toFriendChallenges*/
		Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser);  /*fromFriendChallenges*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::clear()
{
	duelTypeId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::equals(const Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED& _o) const
{
	return duelTypeId == _o.duelTypeId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_RANDOM_ENTRY_REVOKED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_RANDOM_ENTRY_REVOKED).append(")");
	_buf.append(',');
	_buf.append("duelTypeId=");
	_buf.appendUint(duelTypeId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_RANDOM_ENTRY_REVOKED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelTypeId", duelTypeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelTypeId"))
			{
				duelTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(duelTypeId);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelTypeId", duelTypeId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelTypeId", duelTypeId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(4);  /*duelTypeId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::clear()
{
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::equals(const Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES& _o) const
{
	return true;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_ICE_CHALLENGES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_ICE_CHALLENGES).append(")");
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_ICE_CHALLENGES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	numAvailableIceChallenges = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::equals(const Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		numAvailableIceChallenges == _o.numAvailableIceChallenges;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("numAvailableIceChallenges=");
		_buf.appendInt(numAvailableIceChallenges);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("numAvailableIceChallenges", numAvailableIceChallenges, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("numAvailableIceChallenges"))
			{
				numAvailableIceChallenges = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		_msg.composeINT32(numAvailableIceChallenges);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		_parser.parseINT32(numAvailableIceChallenges);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("numAvailableIceChallenges", numAvailableIceChallenges);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("numAvailableIceChallenges", numAvailableIceChallenges);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("numAvailableIceChallenges", numAvailableIceChallenges);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		_parser.skip(4);  /*numAvailableIceChallenges*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_DUEL_INFO
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::Protocol_MSG_POKERDUEL_GET_DUEL_INFO()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::clear()
{
	duelId = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::equals(const Protocol_MSG_POKERDUEL_GET_DUEL_INFO& _o) const
{
	return duelId == _o.duelId;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_DUEL_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_DUEL_INFO*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_DUEL_INFO).append(")");
	_buf.append(',');
	_buf.append("duelId=");
	_buf.appendUint64(duelId);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_DUEL_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("duelId", duelId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("duelId"))
			{
				duelId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(duelId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(duelId);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("duelId", duelId);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("duelId", duelId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("duelId", duelId);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*duelId*/
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	isRunningNotCompleted = false;
	duelInfo.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::equals(const Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		isRunningNotCompleted == _o.isRunningNotCompleted &&
		duelInfo.equals(_o.duelInfo);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_DUEL_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_DUEL_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("isRunningNotCompleted=");
		_buf.appendUint(isRunningNotCompleted);
		_buf.append(',');
		_buf.append("duelInfo=");
		duelInfo.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_DUEL_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("isRunningNotCompleted", isRunningNotCompleted, _buf);
		duelInfo.toXmlString("duelInfo", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("isRunningNotCompleted"))
			{
				isRunningNotCompleted = (*_value.ptr() == '1');
			}
			else if (_element.equals("duelInfo"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, duelInfo)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode != 0 )
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		_msg.composeBOOL(isRunningNotCompleted);
		duelInfo.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode != 0 )
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		_parser.parseBOOL(isRunningNotCompleted);
		duelInfo.parseMsg(_parser);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode != 0 )
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("isRunningNotCompleted", isRunningNotCompleted);
		_jsonstr.compose("duelInfo", duelInfo);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode != 0 )
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("isRunningNotCompleted", isRunningNotCompleted);
		_jparser.parseByNameThrow("duelInfo", duelInfo);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if ( errCode != 0 )
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("isRunningNotCompleted", isRunningNotCompleted);
		_jparser.validateByNameThrow("duelInfo", duelInfo);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if ( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		bool isRunningNotCompleted; _parser.parseBOOL(isRunningNotCompleted);
		Atf::MsgBodyWithJSON::validateMsg(_parser);  /*duelInfo*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::clear()
{
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::equals(const Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO& _o) const
{
	return true;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_RANDOM_POOL_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_RANDOM_POOL_INFO).append(")");
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_RANDOM_POOL_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO::validateMsg(CommMsgParser& _parser)
{
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	randomPoolEntries.clear();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::equals(const Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		randomPoolEntries.equals(_o.randomPoolEntries);
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("randomPoolEntries=");
		randomPoolEntries.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		randomPoolEntries.toXmlString("randomPoolEntries", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("randomPoolEntries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClientRandomPool , 4 > >::FromXmlString(_value, randomPoolEntries)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode != 0 )
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		randomPoolEntries.composeMsg(_msg, _ignoreJSON);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode != 0 )
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		randomPoolEntries.parseMsg(_parser);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode != 0 )
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("randomPoolEntries", randomPoolEntries);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode != 0 )
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("randomPoolEntries", randomPoolEntries);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if ( errCode != 0 )
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("randomPoolEntries", randomPoolEntries);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if ( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		Atf::LAtfVector< ClientRandomPool , 4 >::validateMsg(_parser);  /*randomPoolEntries*/
	}
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::clear()
{
	challengeId = 0;
	supportsConvertedToDuel = false;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::equals(const Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO& _o) const
{
	return challengeId == _o.challengeId &&
		supportsConvertedToDuel == _o.supportsConvertedToDuel;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_CHALLENGE_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_CHALLENGE_INFO).append(")");
	_buf.append(',');
	_buf.append("challengeId=");
	_buf.appendUint64(challengeId);
	_buf.append(',');
	_buf.append("supportsConvertedToDuel=");
	_buf.appendUint(supportsConvertedToDuel);
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_CHALLENGE_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("challengeId", challengeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("supportsConvertedToDuel", supportsConvertedToDuel, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("challengeId"))
			{
				challengeId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("supportsConvertedToDuel"))
			{
				supportsConvertedToDuel = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(challengeId);
	_msg.composeBOOL(supportsConvertedToDuel);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(challengeId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(supportsConvertedToDuel);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("challengeId", challengeId);
	_jsonstr.compose("supportsConvertedToDuel", supportsConvertedToDuel);
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("challengeId", challengeId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("supportsConvertedToDuel", supportsConvertedToDuel);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("challengeId", challengeId);
	if(_jparser.parseEnded()) return;
	_jparser.validateByNameThrow("supportsConvertedToDuel", supportsConvertedToDuel);
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO::validateMsg(CommMsgParser& _parser)
{
	_parser.skip(8);  /*challengeId*/
	if(_parser.parseEnded()) return;
	bool supportsConvertedToDuel; _parser.parseBOOL(supportsConvertedToDuel);
}

//=================================================================
//                Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY
//=================================================================

pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY()
{
	clear();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	errTitle.clear();
	isPendingNotCancelled_deprecated = false;
	challengeInfo.clear();
	challengeType = 0;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::equals(const Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		errTitle.equals(_o.errTitle) &&
		isPendingNotCancelled_deprecated == _o.isPendingNotCancelled_deprecated &&
		challengeInfo.equals(_o.challengeInfo) &&
		challengeType == _o.challengeType;
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY*)_other));
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
		_buf.append(',');
		_buf.append("errTitle=");
		_buf.append(errTitle);
	}
	else
	{
		_buf.append(',');
		_buf.append("isPendingNotCancelled_deprecated=");
		_buf.appendUint(isPendingNotCancelled_deprecated);
		_buf.append(',');
		_buf.append("challengeInfo=");
		challengeInfo.toTraceString(_buf);
		_buf.append(',');
		_buf.append("challengeType=");
		_buf.appendInt(challengeType);
	}
	return _buf.c_str();
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
		Atf::XmlElement::encodeAsXmlElement("errTitle", errTitle, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("isPendingNotCancelled_deprecated", isPendingNotCancelled_deprecated, _buf);
		challengeInfo.toXmlString("challengeInfo", _buf);
		Atf::XmlElement::encodeAsXmlElement("challengeType", challengeType, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("errTitle"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errTitle)) return false;
			}
			else if (_element.equals("isPendingNotCancelled_deprecated"))
			{
				isPendingNotCancelled_deprecated = (*_value.ptr() == '1');
			}
			else if (_element.equals("challengeInfo"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, challengeInfo)) return false;
			}
			else if (_element.equals("challengeType"))
			{
				challengeType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode != 0 )
	{
		_msg.composeString(errString);
		_msg.composeString(errTitle);
	}
	else
	{
		_msg.composeBOOL(isPendingNotCancelled_deprecated);
		challengeInfo.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(challengeType);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode != 0 )
	{
		_parser.parseStringPN(errString, 0, "errString");
		_parser.parseStringPN(errTitle, 0, "errTitle");
	}
	else
	{
		_parser.parseBOOL(isPendingNotCancelled_deprecated);
		challengeInfo.parseMsg(_parser);
		_parser.parseINT32(challengeType);
	}
}

const char *pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode != 0 )
	{
		_jsonstr.compose("errString", errString);
		_jsonstr.compose("errTitle", errTitle);
	}
	else
	{
		_jsonstr.compose("isPendingNotCancelled_deprecated", isPendingNotCancelled_deprecated);
		_jsonstr.compose("challengeInfo", challengeInfo);
		_jsonstr.compose("challengeType", challengeType);
	}
	return _buf.c_str();
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode != 0 )
	{
		_jparser.parseByNameThrow("errString", errString);
		_jparser.parseByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.parseByNameThrow("isPendingNotCancelled_deprecated", isPendingNotCancelled_deprecated);
		_jparser.parseByNameThrow("challengeInfo", challengeInfo);
		_jparser.parseByNameThrow("challengeType", challengeType);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::validateJSONString(const PString& _jsonString)
{
	Atf::JSONStringValidator _jparser(_jsonString);
	_jparser.validateByNameThrow("errCode", errCode);
	if ( errCode != 0 )
	{
		_jparser.validateByNameThrow("errString", errString);
		_jparser.validateByNameThrow("errTitle", errTitle);
	}
	else
	{
		_jparser.validateByNameThrow("isPendingNotCancelled_deprecated", isPendingNotCancelled_deprecated);
		_jparser.validateByNameThrow("challengeInfo", challengeInfo);
		_jparser.validateByNameThrow("challengeType", challengeType);
	}
}

void pokerduel::client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY::validateMsg(CommMsgParser& _parser)
{
	const char *_dummy;
	INT16 errCode; _parser.parseINT16(errCode);
	if ( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errString");  /*errString*/
		_parser.parseStringN(_dummy, 0, "errTitle");  /*errTitle*/
	}
	else
	{
		bool isPendingNotCancelled_deprecated; _parser.parseBOOL(isPendingNotCancelled_deprecated);
		Atf::MsgBodyWithJSON::validateMsg(_parser);  /*challengeInfo*/
		_parser.skip(4);  /*challengeType*/
	}
}

//=================================================================
//                ProtocolFactory
//=================================================================

Atf::MessageProtocol* pokerduel::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;
	
	if (!strcmp(_nameSpace, 
#ifdef client_STRING
		client_STRING
#else
		"client"
#endif
		))
	{
		switch(_msgId)
		{
			case MSG_DUEL_CHAT_BROADCAST: _obj = new client::Protocol_MSG_DUEL_CHAT_BROADCAST(); break;
			case MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID: _obj = new client::Protocol_MSG_DUEL_CHAT_REPORT_CURR_MAXORDINALID(); break;
			case MSG_DUEL_CHAT_REQUEST: _obj = new client::Protocol_MSG_DUEL_CHAT_REQUEST(); break;
			case MSG_DUEL_CHAT_SYNC_REPLY: _obj = new client::Protocol_MSG_DUEL_CHAT_SYNC_REPLY(); break;
			case MSG_DUEL_CHAT_SYNC_REQUEST: _obj = new client::Protocol_MSG_DUEL_CHAT_SYNC_REQUEST(); break;
			case MSG_DUEL_DLOBBY_POST_TO_PLAYER: _obj = new client::Protocol_MSG_DUEL_DLOBBY_POST_TO_PLAYER(); break;
			case MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER: _obj = new client::Protocol_MSG_DUEL_USER_GAME_MESSAGE_TO_SERVER(); break;
			case MSG_POKERDUEL_CANCEL_CHALLENGE: _obj = new client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE(); break;
			case MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_CANCEL_CHALLENGE_REPLY(); break;
			case MSG_POKERDUEL_CHALLENGE_OFFER: _obj = new client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER(); break;
			case MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE: _obj = new client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE(); break;
			case MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_CHALLENGE_OFFER_RESPONSE_REPLY(); break;
			case MSG_POKERDUEL_CHALLENGE_REQUEST: _obj = new client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST(); break;
			case MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_REPLY(); break;
			case MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE: _obj = new client::Protocol_MSG_POKERDUEL_CHALLENGE_REQUEST_RESPONSE(); break;
			case MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN: _obj = new client::Protocol_MSG_POKERDUEL_DUEL_STATUS_CHANGE_BY_ADMIN(); break;
			case MSG_POKERDUEL_GETHISTORY: _obj = new client::Protocol_MSG_POKERDUEL_GETHISTORY(); break;
			case MSG_POKERDUEL_GETHISTORY_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GETHISTORY_REPLY(); break;
			case MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS: _obj = new client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS(); break;
			case MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GET_ALL_ACHIEVEMENTS_REPLY(); break;
			case MSG_POKERDUEL_GET_CHALLENGE_INFO: _obj = new client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO(); break;
			case MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GET_CHALLENGE_INFO_REPLY(); break;
			case MSG_POKERDUEL_GET_DUELTYPES: _obj = new client::Protocol_MSG_POKERDUEL_GET_DUELTYPES(); break;
			case MSG_POKERDUEL_GET_DUELTYPES_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GET_DUELTYPES_REPLY(); break;
			case MSG_POKERDUEL_GET_DUEL_INFO: _obj = new client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO(); break;
			case MSG_POKERDUEL_GET_DUEL_INFO_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GET_DUEL_INFO_REPLY(); break;
			case MSG_POKERDUEL_GET_ICE_CHALLENGES: _obj = new client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES(); break;
			case MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GET_ICE_CHALLENGES_REPLY(); break;
			case MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO: _obj = new client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO(); break;
			case MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GET_PENDING_CHALLENGE_INFO_REPLY(); break;
			case MSG_POKERDUEL_GET_RANDOM_POOL_INFO: _obj = new client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO(); break;
			case MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GET_RANDOM_POOL_INFO_REPLY(); break;
			case MSG_POKERDUEL_GET_RUNNING_DUELS: _obj = new client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS(); break;
			case MSG_POKERDUEL_GET_RUNNING_DUELS2: _obj = new client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2(); break;
			case MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS2_REPLY(); break;
			case MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_GET_RUNNING_DUELS_REPLY(); break;
			case MSG_POKERDUEL_LEAVE_RANDOM_POOL: _obj = new client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL(); break;
			case MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_LEAVE_RANDOM_POOL_REPLY(); break;
			case MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED: _obj = new client::Protocol_MSG_POKERDUEL_NOTIFY_CHALLENGE_REVOKED(); break;
			case MSG_POKERDUEL_PRECONFIRMATION_CHECK: _obj = new client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK(); break;
			case MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_PRECONFIRMATION_CHECK_REPLY(); break;
			case MSG_POKERDUEL_PROFILE_REQUEST: _obj = new client::Protocol_MSG_POKERDUEL_PROFILE_REQUEST(); break;
			case MSG_POKERDUEL_PROFILE_RESPONSE: _obj = new client::Protocol_MSG_POKERDUEL_PROFILE_RESPONSE(); break;
			case MSG_POKERDUEL_RANDOM_ENTRY_REVOKED: _obj = new client::Protocol_MSG_POKERDUEL_RANDOM_ENTRY_REVOKED(); break;
			case MSG_POKERDUEL_RANDOM_OPPONENT_FOUND: _obj = new client::Protocol_MSG_POKERDUEL_RANDOM_OPPONENT_FOUND(); break;
			case MSG_POKERDUEL_REPLAY_DUEL: _obj = new client::Protocol_MSG_POKERDUEL_REPLAY_DUEL(); break;
			case MSG_POKERDUEL_REPLAY_DUEL_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_REPLAY_DUEL_REPLY(); break;
			case MSG_POKERDUEL_SERVER_RESTARTING: _obj = new client::Protocol_MSG_POKERDUEL_SERVER_RESTARTING(); break;
			case MSG_POKERDUEL_START_RANDOM_DUEL: _obj = new client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL(); break;
			case MSG_POKERDUEL_START_RANDOM_DUEL_REPLY: _obj = new client::Protocol_MSG_POKERDUEL_START_RANDOM_DUEL_REPLY(); break;
		}
	}
	else if (!strcmp(_nameSpace, 
#ifdef dbm_STRING
		dbm_STRING
#else
		"dbm"
#endif
		))
	{
		switch(_msgId)
		{
			case DBM_A_ALLOWED_AT_PLAY: _obj = new dbm::Protocol_DBM_A_ALLOWED_AT_PLAY(); break;
			case DBM_A_PDUEL_ACCEPT_CHALLENGE: _obj = new dbm::Protocol_DBM_A_PDUEL_ACCEPT_CHALLENGE(); break;
			case DBM_A_PDUEL_ADD_DUEL_TYPES: _obj = new dbm::Protocol_DBM_A_PDUEL_ADD_DUEL_TYPES(); break;
			case DBM_A_PDUEL_CANCEL_CHALLENGE: _obj = new dbm::Protocol_DBM_A_PDUEL_CANCEL_CHALLENGE(); break;
			case DBM_A_PDUEL_CANCEL_DUEL: _obj = new dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL(); break;
			case DBM_A_PDUEL_CANCEL_DUEL_TYPE: _obj = new dbm::Protocol_DBM_A_PDUEL_CANCEL_DUEL_TYPE(); break;
			case DBM_A_PDUEL_CREATE_CHALLENGE: _obj = new dbm::Protocol_DBM_A_PDUEL_CREATE_CHALLENGE(); break;
			case DBM_A_PDUEL_GET_INIT_DATA: _obj = new dbm::Protocol_DBM_A_PDUEL_GET_INIT_DATA(); break;
			case DBM_A_PDUEL_GET_LASTCHATORDINAL: _obj = new dbm::Protocol_DBM_A_PDUEL_GET_LASTCHATORDINAL(); break;
			case DBM_A_PDUEL_GET_RUNNING_STATE: _obj = new dbm::Protocol_DBM_A_PDUEL_GET_RUNNING_STATE(); break;
			case DBM_A_PDUEL_LOAD_CHAT_ITEMS: _obj = new dbm::Protocol_DBM_A_PDUEL_LOAD_CHAT_ITEMS(); break;
			case DBM_A_PDUEL_SAVE_DUEL_RESULT: _obj = new dbm::Protocol_DBM_A_PDUEL_SAVE_DUEL_RESULT(); break;
			case DBM_A_PDUEL_SAVE_RUNNING_STATE: _obj = new dbm::Protocol_DBM_A_PDUEL_SAVE_RUNNING_STATE(); break;
			case DBM_A_PDUEL_UNPUBLISH_DUEL: _obj = new dbm::Protocol_DBM_A_PDUEL_UNPUBLISH_DUEL(); break;
			case DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL: _obj = new dbm::Protocol_DBM_A_PDUEL_UPDATE_CLIENTCHATORDINAL(); break;
			case DBM_A_PDUEL_UPDATE_DUELTYPE: _obj = new dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE(); break;
			case DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS: _obj = new dbm::Protocol_DBM_A_PDUEL_UPDATE_DUELTYPE_STATUS(); break;
			case DBM_A_PDUEL_UPDATE_DUEL_STATUS: _obj = new dbm::Protocol_DBM_A_PDUEL_UPDATE_DUEL_STATUS(); break;
			case DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK: _obj = new dbm::Protocol_DBM_A_PDUEL_UPDATE_PLAYER_TIMEBANK(); break;
			case DBM_A_PDUEL_UPDATE_RUNNING_STATE: _obj = new dbm::Protocol_DBM_A_PDUEL_UPDATE_RUNNING_STATE(); break;
			case DBM_A_UPDATE_DUEL_LOGLOCATION: _obj = new dbm::Protocol_DBM_A_UPDATE_DUEL_LOGLOCATION(); break;
			case DBM_Q_PDUEL_ACCEPT_CHALLENGE: _obj = new dbm::Protocol_DBM_Q_PDUEL_ACCEPT_CHALLENGE(); break;
			case DBM_Q_PDUEL_ADD_DUEL_TYPES: _obj = new dbm::Protocol_DBM_Q_PDUEL_ADD_DUEL_TYPES(); break;
			case DBM_Q_PDUEL_CANCEL_CHALLENGE: _obj = new dbm::Protocol_DBM_Q_PDUEL_CANCEL_CHALLENGE(); break;
			case DBM_Q_PDUEL_CANCEL_DUEL: _obj = new dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL(); break;
			case DBM_Q_PDUEL_CANCEL_DUEL_TYPE: _obj = new dbm::Protocol_DBM_Q_PDUEL_CANCEL_DUEL_TYPE(); break;
			case DBM_Q_PDUEL_CREATE_CHALLENGE: _obj = new dbm::Protocol_DBM_Q_PDUEL_CREATE_CHALLENGE(); break;
			case DBM_Q_PDUEL_GET_INIT_DATA: _obj = new dbm::Protocol_DBM_Q_PDUEL_GET_INIT_DATA(); break;
			case DBM_Q_PDUEL_GET_LASTCHATORDINAL: _obj = new dbm::Protocol_DBM_Q_PDUEL_GET_LASTCHATORDINAL(); break;
			case DBM_Q_PDUEL_GET_RUNNING_STATE: _obj = new dbm::Protocol_DBM_Q_PDUEL_GET_RUNNING_STATE(); break;
			case DBM_Q_PDUEL_LOAD_CHAT_ITEMS: _obj = new dbm::Protocol_DBM_Q_PDUEL_LOAD_CHAT_ITEMS(); break;
			case DBM_Q_PDUEL_SAVE_DUEL_RESULT: _obj = new dbm::Protocol_DBM_Q_PDUEL_SAVE_DUEL_RESULT(); break;
			case DBM_Q_PDUEL_SAVE_RUNNING_STATE: _obj = new dbm::Protocol_DBM_Q_PDUEL_SAVE_RUNNING_STATE(); break;
			case DBM_Q_PDUEL_UNPUBLISH_DUEL: _obj = new dbm::Protocol_DBM_Q_PDUEL_UNPUBLISH_DUEL(); break;
			case DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL: _obj = new dbm::Protocol_DBM_Q_PDUEL_UPDATE_CLIENTCHATORDINAL(); break;
			case DBM_Q_PDUEL_UPDATE_DUELTYPE: _obj = new dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE(); break;
			case DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS: _obj = new dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUELTYPE_STATUS(); break;
			case DBM_Q_PDUEL_UPDATE_DUEL_STATUS: _obj = new dbm::Protocol_DBM_Q_PDUEL_UPDATE_DUEL_STATUS(); break;
			case DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK: _obj = new dbm::Protocol_DBM_Q_PDUEL_UPDATE_PLAYER_TIMEBANK(); break;
			case DBM_Q_PDUEL_UPDATE_RUNNING_STATE: _obj = new dbm::Protocol_DBM_Q_PDUEL_UPDATE_RUNNING_STATE(); break;
			case DBM_Q_UPDATE_DUEL_LOGLOCATION: _obj = new dbm::Protocol_DBM_Q_UPDATE_DUEL_LOGLOCATION(); break;
		}
	}
	else if (!strcmp(_nameSpace, 
#ifdef dchat_STRING
		dchat_STRING
#else
		"dchat"
#endif
		))
	{
		switch(_msgId)
		{
			case MSG_DUEL_DLOBBY_DCHAT_CONNECTED: _obj = new dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED(); break;
			case MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY: _obj = new dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_CONNECTED_REPLY(); break;
			case MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY: _obj = new dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY(); break;
			case MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK: _obj = new dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REPLY_ACK(); break;
			case MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST: _obj = new dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_GET_DUELINFO_REQUEST(); break;
			case MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME: _obj = new dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME(); break;
			case MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY: _obj = new dchat::Protocol_MSG_DUEL_DLOBBY_DCHAT_UPDATE_DUELCLOSETIME_REPLY(); break;
		}
	}
	else if (!strcmp(_nameSpace, 
#ifdef dserver_STRING
		dserver_STRING
#else
		"dserver"
#endif
		))
	{
		switch(_msgId)
		{
			case MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY: _obj = new dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REPLY(); break;
			case MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST: _obj = new dserver::Protocol_MSG_DLOBBY_FINISHEDDUEL_REPLAY_DONE_REQUEST(); break;
			case MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REPLY(); break;
			case MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_AWARD_WINNERS_REQUEST(); break;
			case MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REPLY(); break;
			case MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_DUEL_COMPLETE_REQUEST(); break;
			case MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED(); break;
			case MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_ADDED_REPLY(); break;
			case MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED(); break;
			case MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_PENDING_GAME_ACTION_REMOVED_REPLY(); break;
			case MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY(); break;
			case MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REPLY_ACK(); break;
			case MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_DUEL_STATUS_REQUEST(); break;
			case MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REPLY(); break;
			case MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_ACTION_TIME_REQUEST(); break;
			case MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REPLY(); break;
			case MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_DLOBBY_UPDATE_PLAYER_SCORES_REQUEST(); break;
			case MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST(); break;
			case MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY(); break;
			case MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_CLOSE_DUEL_REQUEST_REPLY_ACK(); break;
			case MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY(); break;
			case MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REPLY_ACK(); break;
			case MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_CREATE_FINISHEDDUEL_FOR_REPLAY_REQUEST(); break;
			case MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_FROM_PLAYER(); break;
			case MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER(); break;
			case MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_GAME_MESSAGE_TO_PLAYER_REPLY(); break;
			case MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL(); break;
			case MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_PLAYER_LAST_REVEAL_REPLY(); break;
			case MSG_DUEL_DSERVER_RESTORE_REPLY: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY(); break;
			case MSG_DUEL_DSERVER_RESTORE_REPLY_ACK: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REPLY_ACK(); break;
			case MSG_DUEL_DSERVER_RESTORE_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_DSERVER_RESTORE_REQUEST(); break;
			case MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST(); break;
			case MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY: _obj = new dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY(); break;
			case MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK: _obj = new dserver::Protocol_MSG_DUEL_LOBBY_DSERVER_SHUTDOWN_REQUEST_REPLY_ACK(); break;
			case MSG_DUEL_SERVER_CONNECTED: _obj = new dserver::Protocol_MSG_DUEL_SERVER_CONNECTED(); break;
			case MSG_DUEL_SERVER_CONNECTED_REPLY: _obj = new dserver::Protocol_MSG_DUEL_SERVER_CONNECTED_REPLY(); break;
			case MSG_DUEL_SERVER_CREATE_REPLY: _obj = new dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY(); break;
			case MSG_DUEL_SERVER_CREATE_REPLY_ACK: _obj = new dserver::Protocol_MSG_DUEL_SERVER_CREATE_REPLY_ACK(); break;
			case MSG_DUEL_SERVER_CREATE_REQUEST: _obj = new dserver::Protocol_MSG_DUEL_SERVER_CREATE_REQUEST(); break;
		}
	}
	
	return _obj;
}

