/**
 * bduaclientprot.cpp
 *
 * This file was auto-generated from bduaclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: bduaclientprot.txt
 */
 
#include "bduaclientprot.h"

//=================================================================
//                    BDUAData
//=================================================================

BDUAClient::BDUAData::BDUAData()
{
	clear();
}

void BDUAClient::BDUAData::clear()
{
	bduaType = 0;
	bduaValue = 0;
}

bool BDUAClient::BDUAData::equals(const BDUAData& _o) const
{
	return bduaType == _o.bduaType &&
		bduaValue == _o.bduaValue;
}

const char *BDUAClient::BDUAData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("bduaType=");
	_buf.appendUint(bduaType);
	_buf.append(',');
	_buf.append("bduaValue=");
	_buf.appendUint(bduaValue);
	_buf.append('}');
	return _buf.c_str();
}

const char *BDUAClient::BDUAData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("bduaType", bduaType, _buf);
	Atf::XmlElement::encodeAsXmlElement("bduaValue", bduaValue, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool BDUAClient::BDUAData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("bduaType"))
		{
			bduaType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bduaValue"))
		{
			bduaValue = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void BDUAClient::BDUAData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(BDUAData())) // not empty
	{
		_body.composeUINT32(bduaType);
		_body.composeUINT32(bduaValue);
	}

	_msg.composeMsgBody(_body);
}

void BDUAClient::BDUAData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(bduaType);
	_parser0.parseUINT32(bduaValue);
}

const char *BDUAClient::BDUAData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("bduaType", bduaType);
	_jsonstr.compose("bduaValue", bduaValue);
	return _buf.c_str();
}

void BDUAClient::BDUAData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("bduaType", bduaType);
	_jparser.parseByNameThrow("bduaValue", bduaValue);
}

/* static */ void BDUAClient::BDUAData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 bduaType; _jparser.validateByNameThrow("bduaType", bduaType);
	AtfValidator::validateInt(_descr, "bduaType", bduaType, _checker, __FILE__, __LINE__);
	UINT32 bduaValue; _jparser.validateByNameThrow("bduaValue", bduaValue);
	AtfValidator::validateInt(_descr, "bduaValue", bduaValue, _checker, __FILE__, __LINE__);
}

/*static*/ void BDUAClient::BDUAData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 bduaType; _parser0.parseUINT32(bduaType);
	AtfValidator::validateInt(_descr, "bduaType", bduaType, _checker, __FILE__, __LINE__);
	UINT32 bduaValue; _parser0.parseUINT32(bduaValue);
	AtfValidator::validateInt(_descr, "bduaValue", bduaValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER
//=================================================================

BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER()
{
	clear();
}

void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::clear()
{
}

bool BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::equals(const Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER& _o) const
{
	return true;
}

bool BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_BDUAS_FOR_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER*)_other));
}

const char *BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_BDUAS_FOR_USER).append(")");
	return _buf.c_str();
}

const char *BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_BDUAS_FOR_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::parseMsg(CommMsgParser& _parser)
{
}

const char *BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_BDUAS_FOR_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_BDUAS_FOR_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY
//=================================================================

BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY()
{
	clear();
}

void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	userBDUAs.clear();
	userTier = 0;
}

bool BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		userBDUAs.equals(_o.userBDUAs) &&
		userTier == _o.userTier;
}

bool BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY*)_other));
}

const char *BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("userBDUAs=");
		userBDUAs.toTraceString(_buf);
		_buf.append(',');
		_buf.append("userTier=");
		_buf.appendUint(userTier);
	}
	return _buf.c_str();
}

const char *BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		userBDUAs.toXmlString("userBDUAs", _buf);
		Atf::XmlElement::encodeAsXmlElement("userTier", userTier, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("userBDUAs"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< BDUAData, 4 > >::FromXmlString(_value, userBDUAs)) return false;
			}
			else if (_element.equals("userTier"))
			{
				userTier = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		userBDUAs.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(userTier);
	}
}

void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		userBDUAs.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseUINT32(userTier);
	}
}

const char *BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("userBDUAs", userBDUAs);
		_jsonstr.compose("userTier", userTier);
	}
	return _buf.c_str();
}

void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("userBDUAs", userBDUAs);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("userTier", userTier);
	}
}

/*static*/ void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< BDUAData > userBDUAs; _jparser.validateByNameThrow("userBDUAs", userBDUAs);
		AtfValidator::validateInt(_descr, "userBDUAs", userBDUAs.size(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT32 userTier; _jparser.validateByNameThrow("userTier", userTier);
		AtfValidator::validateInt(_descr, "userTier", userTier, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void BDUAClient::Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUserBDUAs = Atf::LAtfVector< BDUAData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userBDUAs"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "userBDUAs", szUserBDUAs, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT32 userTier; _parser.parseUINT32(userTier);
		AtfValidator::validateInt(_descr, "userTier", userTier, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* BDUAClient::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_GET_BDUAS_FOR_USER: _obj = new Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER(); break;
			case MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY: _obj = new Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool BDUAClient::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_GET_BDUAS_FOR_USER: Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY: Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool BDUAClient::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_GET_BDUAS_FOR_USER: Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY: Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

