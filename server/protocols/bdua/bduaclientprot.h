/**
 * bduaclientprot.h
 *
 * This file was auto-generated from bduaclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: bduaclientprot.txt
 */

#ifndef ATF_PROTOCOL_DEFFILE_BDUACLIENTPROT_H
#define ATF_PROTOCOL_DEFFILE_BDUACLIENTPROT_H

//------------------------------------------------------------------------------
//	LobbyEtc <-> Client Protocol
//------------------------------------------------------------------------------
//
//	Copyright (c) 2001-2016 PYR Software Ltd. All rights reserved. This document
//	is for the use of licensed users only and is subject to the terms and
//	conditions of the accompanying and/or applicable license between you and
//	PYR Software Ltd, including without limitation those terms and conditions
//	prohibiting unauthorized translation, reverse engineering, decompilation,
//	disassembly, and other inappropriate use of any software provided. Any
//	unauthorized use, copying, modification, distribution, publication or
//	disclosure of information is a violation of copyright laws. No reproduction
//	in whole or in part of this document may be made without express written
//	consent of PYR Software Ltd.
//
//
//------------------------------------------------------------------------------

#include "LobbyEtc.h"


#include "UserDefStructs.h"

namespace BDUAClient
{
	class ProtocolFactory
	{
	public:
		static Atf::MessageProtocol* createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId);
		static bool validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded);
		static bool validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded);
	};


	//------------------------------------------------------------------------------

	//------------------------------------------------------------------------------
	// Business user attributes (BDUA)
	//------------------------------------------------------------------------------

	// BDUA types used for by client
	enum ClientBDUATypes
	{
		ClientBDUATypes_PlayerScore = 1,
		ClientBDUATypes_CrossSell = 20,
	};

	struct BDUAData
	{
		// M(44) - M(bduaType,bduaValue)
		UINT32 bduaType;
		UINT32 bduaValue;

		BDUAData();
		void clear();
		bool equals(const BDUAData&) const;
		const char *toTraceString(PString& _str) const;
		const char *toXmlString(const char *_element, PString& _str) const;
		bool fromXmlString(const PString& _str);
		void composeMsg(CommMsgBody& _msg, bool _ignoreJSON = COMPOSEMSG_IGNORE_JSON_DEFAULT) const;
		void parseMsg(CommMsgParser& _parser);
		const char *toJSONString(PString& _str) const;
		void fromJSONString(const PString& _str);
		static void validateJSONString(const PString& _str, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	struct Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER : public Atf::MessageProtocol
	{

		Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER();
		void clear() override;
		bool equals(const Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER&) const;
		bool equals(Atf::MessageProtocol* _other) const override;
		const char *asXmlString(PString& _buf, bool _logTimeStamp) const override;
		const char *asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const override;
		bool loadFromXmlString(const PString& _xmlString) override;
		const char *asTraceString(PString& _buf) const override;
		void parseMsg(CommMsgParser& _parser) override;
		void composeMsg(CommMsgBody& _body, bool _ignoreJSON = COMPOSEMSG_IGNORE_JSON_DEFAULT) const override;
		UINT32 getMsgId() const override { return MSG_LOBBYETC_GET_BDUAS_FOR_USER; }
		const char *getMsgIdString() const override { return "MSG_LOBBYETC_GET_BDUAS_FOR_USER"; }
		const char *asJSONString(PString& _buf) const override;
		void loadFromJSONString(const PString& _jsonString) override;
		static void validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
	};

	struct Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY : public Atf::MessageProtocol
	{
		// 2[s|4<M(44)>4] - errCode[errString|numUserBDUAs<M(bduaType,bduaValue)>,userTier]
		INT16 errCode;

		PString errString;

		Atf::LAtfVector< BDUAData, 4 > userBDUAs;
		UINT32 userTier;

		Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY();
		void clear() override;
		bool equals(const Protocol_MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY&) const;
		bool equals(Atf::MessageProtocol* _other) const override;
		const char *asXmlString(PString& _buf, bool _logTimeStamp) const override;
		const char *asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const override;
		bool loadFromXmlString(const PString& _xmlString) override;
		const char *asTraceString(PString& _buf) const override;
		void parseMsg(CommMsgParser& _parser) override;
		void composeMsg(CommMsgBody& _body, bool _ignoreJSON = COMPOSEMSG_IGNORE_JSON_DEFAULT) const override;
		UINT32 getMsgId() const override { return MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY; }
		const char *getMsgIdString() const override { return "MSG_LOBBYETC_GET_BDUAS_FOR_USER_REPLY"; }
		const char *asJSONString(PString& _buf) const override;
		void loadFromJSONString(const PString& _jsonString) override;
		static void validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
	};
};

#endif
