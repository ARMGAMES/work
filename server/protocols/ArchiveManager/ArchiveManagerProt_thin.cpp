/**
 * ArchiveManagerProt_thin.cpp
 *
 * This file was auto-generated from ArchiveManagerProt.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -thin ArchiveManagerProt.txt
 */
 
#include "ArchiveManagerProt_thin.h"

//=================================================================
//                Protocol_ARCHMAN_Q_UNARCHIVE_USER
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER::Protocol_ARCHMAN_Q_UNARCHIVE_USER()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER::clear()
{
	userId.clear();
	unarchiveIsTemporary = false;
	reason = 0;
}

bool ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER::equals(const Protocol_ARCHMAN_Q_UNARCHIVE_USER& _o) const
{
	return userId.equals(_o.userId) &&
		unarchiveIsTemporary == _o.unarchiveIsTemporary &&
		reason == _o.reason;
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_UNARCHIVE_USER).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("unarchiveIsTemporary=");
	_buf.appendUint(unarchiveIsTemporary);
	_buf.append(',');
	_buf.append("reason=");
	_buf.appendInt(reason);
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeBOOL(unarchiveIsTemporary);
	_msg.composeINT32(reason);
}

void ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseBOOL(unarchiveIsTemporary);
	_parser.parseINT32(reason);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_UNARCHIVE_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	bool unarchiveIsTemporary; _parser.parseBOOL(unarchiveIsTemporary);
	AtfValidator::validateInt(_descr, "unarchiveIsTemporary", unarchiveIsTemporary, _checker, __FILE__, __LINE__);
	INT32 reason; _parser.parseINT32(reason);
	AtfValidator::validateInt(_descr, "reason", reason, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_A_UNARCHIVE_USER
//=================================================================

ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER::Protocol_ARCHMAN_A_UNARCHIVE_USER()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER::clear()
{
	errCode = 0;
	errString.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER::equals(const Protocol_ARCHMAN_A_UNARCHIVE_USER& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

const char *ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_A_UNARCHIVE_USER).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_A_UNARCHIVE_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN::Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN::clear()
{
	userId.clear();
	isRAM = false;
	pwdHash.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN::equals(const Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN& _o) const
{
	return userId.equals(_o.userId) &&
		isRAM == _o.isRAM &&
		pwdHash.equals(_o.pwdHash);
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("isRAM=");
	_buf.appendUint(isRAM);
	_buf.append(',');
	_buf.append("pwdHash=");
	_buf.append("...");
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeBOOL(isRAM);
	_msg.composeString(pwdHash);
}

void ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseBOOL(isRAM);
	_parser.parseStringP(pwdHash);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	bool isRAM; _parser.parseBOOL(isRAM);
	AtfValidator::validateInt(_descr, "isRAM", isRAM, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "pwdHash"); size_t szPwdHash = strlen(_dummy);
	AtfValidator::validateInt(_descr, "pwdHash", szPwdHash, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN
//=================================================================

ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN::Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN::clear()
{
	errCode = 0;
	errString.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN::equals(const Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

const char *ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_Q_ARCHIVE_USER
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_ARCHIVE_USER::Protocol_ARCHMAN_Q_ARCHIVE_USER()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_ARCHIVE_USER::clear()
{
	userId.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_Q_ARCHIVE_USER::equals(const Protocol_ARCHMAN_Q_ARCHIVE_USER& _o) const
{
	return userId.equals(_o.userId);
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_ARCHIVE_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_ARCHIVE_USER).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_ARCHIVE_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
}

void ArchiveManager::Protocol_ARCHMAN_Q_ARCHIVE_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_ARCHIVE_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_ARCHIVE_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_A_ARCHIVE_USER
//=================================================================

ArchiveManager::Protocol_ARCHMAN_A_ARCHIVE_USER::Protocol_ARCHMAN_A_ARCHIVE_USER()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_A_ARCHIVE_USER::clear()
{
	errCode = 0;
	errString.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_A_ARCHIVE_USER::equals(const Protocol_ARCHMAN_A_ARCHIVE_USER& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

const char *ArchiveManager::Protocol_ARCHMAN_A_ARCHIVE_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_A_ARCHIVE_USER).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_A_ARCHIVE_USER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void ArchiveManager::Protocol_ARCHMAN_A_ARCHIVE_USER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_A_ARCHIVE_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_A_ARCHIVE_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK::Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK::clear()
{
	adminId.clear();
	adminUserIntId = 0;
	userId.clear();
	mask = 0;
	setNotRemove = false;
	updateType = 0;
	updateField = 0;
}

bool ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK::equals(const Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK& _o) const
{
	return adminId.equals(_o.adminId) &&
		adminUserIntId == _o.adminUserIntId &&
		userId.equals(_o.userId) &&
		mask == _o.mask &&
		setNotRemove == _o.setNotRemove &&
		updateType == _o.updateType &&
		updateField == _o.updateField;
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK).append(")");
	_buf.append(',');
	_buf.append("adminId=");
	_buf.append(adminId);
	_buf.append(',');
	_buf.append("adminUserIntId=");
	_buf.appendUint(adminUserIntId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("mask=");
	_buf.appendUint64(mask);
	_buf.append(',');
	_buf.append("setNotRemove=");
	_buf.appendUint(setNotRemove);
	_buf.append(',');
	_buf.append("updateType=");
	_buf.appendInt(updateType);
	_buf.append(',');
	_buf.append("updateField=");
	_buf.appendInt(updateField);
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(adminId);
	_msg.composeUINT32(adminUserIntId);
	_msg.composeString(userId);
	_msg.composeUINT64(mask);
	_msg.composeBOOL(setNotRemove);
	_msg.composeINT32(updateType);
	_msg.composeINT32(updateField);
}

void ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(adminId);
	_parser.parseUINT32(adminUserIntId);
	_parser.parseStringP(userId);
	_parser.parseUINT64(mask);
	_parser.parseBOOL(setNotRemove);
	_parser.parseINT32(updateType);
	_parser.parseINT32(updateField);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "adminId"); size_t szAdminId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "adminId", szAdminId, _checker, __FILE__, __LINE__);
	UINT32 adminUserIntId; _parser.parseUINT32(adminUserIntId);
	AtfValidator::validateInt(_descr, "adminUserIntId", adminUserIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT64 mask; _parser.parseUINT64(mask);
	AtfValidator::validateUint(_descr, "mask", mask, _checker, __FILE__, __LINE__);
	bool setNotRemove; _parser.parseBOOL(setNotRemove);
	AtfValidator::validateInt(_descr, "setNotRemove", setNotRemove, _checker, __FILE__, __LINE__);
	INT32 updateType; _parser.parseINT32(updateType);
	AtfValidator::validateInt(_descr, "updateType", updateType, _checker, __FILE__, __LINE__);
	INT32 updateField; _parser.parseINT32(updateField);
	AtfValidator::validateInt(_descr, "updateField", updateField, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK
//=================================================================

ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK::Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK::clear()
{
	errCode = 0;
	errString.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK::equals(const Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

const char *ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT::Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT::clear()
{
	adminId.clear();
	adminUserIntId = 0;
	userId.clear();
	comment.clear();
	keepPrivileges = false;
	negativeCategory = 0;
}

bool ArchiveManager::Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT::equals(const Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT& _o) const
{
	return adminId.equals(_o.adminId) &&
		adminUserIntId == _o.adminUserIntId &&
		userId.equals(_o.userId) &&
		comment.equals(_o.comment) &&
		keepPrivileges == _o.keepPrivileges &&
		negativeCategory == _o.negativeCategory;
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_CLOSE_ARCH_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("adminId=");
	_buf.append(adminId);
	_buf.append(',');
	_buf.append("adminUserIntId=");
	_buf.appendUint(adminUserIntId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("keepPrivileges=");
	_buf.appendUint(keepPrivileges);
	_buf.append(',');
	_buf.append("negativeCategory=");
	_buf.appendInt(negativeCategory);
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(adminId);
	_msg.composeUINT32(adminUserIntId);
	_msg.composeString(userId);
	_msg.composeString(comment);
	_msg.composeBOOL(keepPrivileges);
	_msg.composeINT32(negativeCategory);
}

void ArchiveManager::Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(adminId);
	_parser.parseUINT32(adminUserIntId);
	_parser.parseStringP(userId);
	_parser.parseStringP(comment);
	_parser.parseBOOL(keepPrivileges);
	_parser.parseINT32(negativeCategory);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_CLOSE_ARCH_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "adminId"); size_t szAdminId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "adminId", szAdminId, _checker, __FILE__, __LINE__);
	UINT32 adminUserIntId; _parser.parseUINT32(adminUserIntId);
	AtfValidator::validateInt(_descr, "adminUserIntId", adminUserIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateInt(_descr, "comment", szComment, _checker, __FILE__, __LINE__);
	bool keepPrivileges; _parser.parseBOOL(keepPrivileges);
	AtfValidator::validateInt(_descr, "keepPrivileges", keepPrivileges, _checker, __FILE__, __LINE__);
	INT32 negativeCategory; _parser.parseINT32(negativeCategory);
	AtfValidator::validateInt(_descr, "negativeCategory", negativeCategory, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT
//=================================================================

ArchiveManager::Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT::Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT::clear()
{
	errCode = 0;
	errString.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT::equals(const Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

const char *ArchiveManager::Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_A_CLOSE_ARCH_ACCOUNT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void ArchiveManager::Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_A_CLOSE_ARCH_ACCOUNT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS::Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS::clear()
{
	userId.clear();
	pokerCommPrefs = false;
	casinoCommPrefs = false;
	sportsCommPrefs = false;
}

bool ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS::equals(const Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS& _o) const
{
	return userId.equals(_o.userId) &&
		pokerCommPrefs == _o.pokerCommPrefs &&
		casinoCommPrefs == _o.casinoCommPrefs &&
		sportsCommPrefs == _o.sportsCommPrefs;
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("pokerCommPrefs=");
	_buf.appendUint(pokerCommPrefs);
	_buf.append(',');
	_buf.append("casinoCommPrefs=");
	_buf.appendUint(casinoCommPrefs);
	_buf.append(',');
	_buf.append("sportsCommPrefs=");
	_buf.appendUint(sportsCommPrefs);
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeBOOL(pokerCommPrefs);
	_msg.composeBOOL(casinoCommPrefs);
	_msg.composeBOOL(sportsCommPrefs);
}

void ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseBOOL(pokerCommPrefs);
	_parser.parseBOOL(casinoCommPrefs);
	_parser.parseBOOL(sportsCommPrefs);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	bool pokerCommPrefs; _parser.parseBOOL(pokerCommPrefs);
	AtfValidator::validateInt(_descr, "pokerCommPrefs", pokerCommPrefs, _checker, __FILE__, __LINE__);
	bool casinoCommPrefs; _parser.parseBOOL(casinoCommPrefs);
	AtfValidator::validateInt(_descr, "casinoCommPrefs", casinoCommPrefs, _checker, __FILE__, __LINE__);
	bool sportsCommPrefs; _parser.parseBOOL(sportsCommPrefs);
	AtfValidator::validateInt(_descr, "sportsCommPrefs", sportsCommPrefs, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS
//=================================================================

ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS::Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS::clear()
{
	errCode = 0;
	errString.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS::equals(const Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

const char *ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_A_SET_ARCH_USER_COMM_PREFS).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_A_SET_ARCH_USER_COMM_PREFS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL::Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL::clear()
{
	email.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL::equals(const Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL& _o) const
{
	return email.equals(_o.email);
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL).append(")");
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(email);
}

void ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(email);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE::Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE::clear()
{
	userId.clear();
	licenseId = 0;
	email.clear();
	sharedliquidityDuplicateEmailCheck = false;
}

bool ArchiveManager::Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE::equals(const Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE& _o) const
{
	return userId.equals(_o.userId) &&
		licenseId == _o.licenseId &&
		email.equals(_o.email) &&
		sharedliquidityDuplicateEmailCheck == _o.sharedliquidityDuplicateEmailCheck;
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_ARCH_CHECK_USER_UPDATE).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("licenseId=");
	_buf.appendUint(licenseId);
	_buf.append(',');
	_buf.append("email=");
	_buf.append(email);
	_buf.append(',');
	_buf.append("sharedliquidityDuplicateEmailCheck=");
	_buf.appendUint(sharedliquidityDuplicateEmailCheck);
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT32(licenseId);
	_msg.composeString(email);
	_msg.composeBOOL(sharedliquidityDuplicateEmailCheck);
}

void ArchiveManager::Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT32(licenseId);
	_parser.parseStringP(email);
	_parser.parseBOOL(sharedliquidityDuplicateEmailCheck);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_ARCH_CHECK_USER_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT32 licenseId; _parser.parseUINT32(licenseId);
	AtfValidator::validateInt(_descr, "licenseId", licenseId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
	AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	bool sharedliquidityDuplicateEmailCheck; _parser.parseBOOL(sharedliquidityDuplicateEmailCheck);
	AtfValidator::validateInt(_descr, "sharedliquidityDuplicateEmailCheck", sharedliquidityDuplicateEmailCheck, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE
//=================================================================

ArchiveManager::Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE::Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE::clear()
{
	errCode = 0;
	errString.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE::equals(const Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

const char *ArchiveManager::Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_A_ARCH_CHECK_USER_UPDATE).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void ArchiveManager::Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_A_ARCH_CHECK_USER_UPDATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::clear()
{
	userId.clear();
	indiaCurrentTaxYear = 0;
}

bool ArchiveManager::Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::equals(const Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX& _o) const
{
	return userId.equals(_o.userId) &&
		indiaCurrentTaxYear == _o.indiaCurrentTaxYear;
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("indiaCurrentTaxYear=");
	_buf.appendUint(indiaCurrentTaxYear);
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeUINT16(indiaCurrentTaxYear);
}

void ArchiveManager::Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseUINT16(indiaCurrentTaxYear);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT16 indiaCurrentTaxYear; _parser.parseUINT16(indiaCurrentTaxYear);
	AtfValidator::validateInt(_descr, "indiaCurrentTaxYear", indiaCurrentTaxYear, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX
//=================================================================

ArchiveManager::Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::clear()
{
	errCode = 0;
	errString.clear();
}

bool ArchiveManager::Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::equals(const Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX& _o) const
{
	return errCode == _o.errCode &&
		errString.equals(_o.errString);
}

const char *ArchiveManager::Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if(errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void ArchiveManager::Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS
//=================================================================

ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS::Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS()
{
	clear();
}

void ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS::clear()
{
	userId.clear();
	includeProps = false;
}

bool ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS::equals(const Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS& _o) const
{
	return userId.equals(_o.userId) &&
		includeProps == _o.includeProps;
}

const char *ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS).append(")");
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("includeProps=");
	_buf.appendUint(includeProps);
	return _buf.c_str();
}

void ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(userId);
	_msg.composeBOOL(includeProps);
}

void ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseBOOL(includeProps);
}

/*static*/ void ArchiveManager::Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	bool includeProps; _parser.parseBOOL(includeProps);
	AtfValidator::validateInt(_descr, "includeProps", includeProps, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool ArchiveManager::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case ARCHMAN_A_ARCHIVE_USER: Protocol_ARCHMAN_A_ARCHIVE_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_A_ARCH_CHECK_USER_UPDATE: Protocol_ARCHMAN_A_ARCH_CHECK_USER_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_A_CLOSE_ARCH_ACCOUNT: Protocol_ARCHMAN_A_CLOSE_ARCH_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX: Protocol_ARCHMAN_A_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_A_SET_ARCH_USER_COMM_PREFS: Protocol_ARCHMAN_A_SET_ARCH_USER_COMM_PREFS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK: Protocol_ARCHMAN_A_SET_ARCH_USER_FLAGS_PRIVS_MASK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_A_UNARCHIVE_USER: Protocol_ARCHMAN_A_UNARCHIVE_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN: Protocol_ARCHMAN_A_UNARCHIVE_USER_FROM_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_ARCHIVE_USER: Protocol_ARCHMAN_Q_ARCHIVE_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_ARCH_CHECK_USER_UPDATE: Protocol_ARCHMAN_Q_ARCH_CHECK_USER_UPDATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_CLOSE_ARCH_ACCOUNT: Protocol_ARCHMAN_Q_CLOSE_ARCH_ACCOUNT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL: Protocol_ARCHMAN_Q_GET_ARCH_USERS_BY_EMAIL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS: Protocol_ARCHMAN_Q_GET_ARCH_USER_WITH_PROPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX: Protocol_ARCHMAN_Q_PAY_INDIA_ARCH_USER_ZERO_ANNUAL_TAX::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS: Protocol_ARCHMAN_Q_SET_ARCH_USER_COMM_PREFS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK: Protocol_ARCHMAN_Q_SET_ARCH_USER_FLAGS_PRIVS_MASK::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_UNARCHIVE_USER: Protocol_ARCHMAN_Q_UNARCHIVE_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN: Protocol_ARCHMAN_Q_UNARCHIVE_USER_FROM_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

