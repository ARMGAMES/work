/**
 * upservercommonprot_thin.cpp
 *
 * This file was auto-generated from upservercommonprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin upservercommonprot.txt
 */
 
#include "upservercommonprot_thin.h"

//=================================================================
//                    Property
//=================================================================

UPServerCommon::Property::Property()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerCommon::Property::Property(Property&& _o)
	: propertyTypeId(std::move(_o.propertyTypeId))
	, value(std::move(_o.value))
	, validUntil(std::move(_o.validUntil))
	, propertyAttributes(std::move(_o.propertyAttributes))
{
}

UPServerCommon::Property& UPServerCommon::Property::operator=(Property&& _o)
{
	if(this != &_o)
	{
		propertyTypeId = std::move(_o.propertyTypeId);
		value = std::move(_o.value);
		validUntil = std::move(_o.validUntil);
		propertyAttributes = std::move(_o.propertyAttributes);
	}
	return *this;
}

#endif

void UPServerCommon::Property::clear()
{
	propertyTypeId = 0;
	value = 0;
	validUntil.setNull();
	propertyAttributes.clear();
}

bool UPServerCommon::Property::equals(const Property& _o) const
{
	return propertyTypeId == _o.propertyTypeId &&
		value == _o.value &&
		validUntil.equals(_o.validUntil) &&
		propertyAttributes.equals(_o.propertyAttributes);
}

const char *UPServerCommon::Property::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("propertyTypeId=");
	_buf.appendInt(propertyTypeId);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append(',');
	_buf.append("validUntil=");
	ThinAtf::AtfTempl<CommUtcTime>::ToTraceString(_buf, validUntil);
	_buf.append(',');
	_buf.append("propertyAttributes=");
	propertyAttributes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void UPServerCommon::Property::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(Property())) // not empty
	{
		_body.composeINT32(propertyTypeId);
		_body.composeINT32(value);
		validUntil.compose(_body);
		_body.composeMsgBody(propertyAttributes);
	}

	_msg.composeMsgBody(_body);
}

void UPServerCommon::Property::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(propertyTypeId);
	_parser0.parseINT32(value);
	validUntil.parse(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseMsgBody(propertyAttributes);
}

/*static*/ void UPServerCommon::Property::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 propertyTypeId; _parser0.parseINT32(propertyTypeId);
	AtfValidator::validateInt(_descr, "propertyTypeId", propertyTypeId, _checker, __FILE__, __LINE__);
	INT32 value; _parser0.parseINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	_parser0.skip(8);  /*validUntil*/
	if(_parser0.parseEnded()) return;
	size_t szPropertyAttributes; _parser0.skipMsgBody(szPropertyAttributes);  /*propertyAttributes*/
	AtfValidator::validateInt(_descr, "propertyAttributes", szPropertyAttributes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PropertyForClient
//=================================================================

UPServerCommon::PropertyForClient::PropertyForClient()
{
	clear();
}

void UPServerCommon::PropertyForClient::clear()
{
	propertyTypeId = 0;
	value = 0;
}

bool UPServerCommon::PropertyForClient::equals(const PropertyForClient& _o) const
{
	return propertyTypeId == _o.propertyTypeId &&
		value == _o.value;
}

const char *UPServerCommon::PropertyForClient::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("propertyTypeId=");
	_buf.appendInt(propertyTypeId);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append('}');
	return _buf.c_str();
}

void UPServerCommon::PropertyForClient::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PropertyForClient())) // not empty
	{
		_body.composeINT32(propertyTypeId);
		_body.composeINT32(value);
	}

	_msg.composeMsgBody(_body);
}

void UPServerCommon::PropertyForClient::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(propertyTypeId);
	_parser0.parseINT32(value);
}

/*static*/ void UPServerCommon::PropertyForClient::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 propertyTypeId; _parser0.parseINT32(propertyTypeId);
	AtfValidator::validateInt(_descr, "propertyTypeId", propertyTypeId, _checker, __FILE__, __LINE__);
	INT32 value; _parser0.parseINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserPropertyLeaf
//=================================================================

UPServerCommon::UserPropertyLeaf::UserPropertyLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerCommon::UserPropertyLeaf::UserPropertyLeaf(UserPropertyLeaf&& _o)
	: properties(std::move(_o.properties))
{
}

UPServerCommon::UserPropertyLeaf& UPServerCommon::UserPropertyLeaf::operator=(UserPropertyLeaf&& _o)
{
	if(this != &_o)
	{
		properties = std::move(_o.properties);
	}
	return *this;
}

#endif

void UPServerCommon::UserPropertyLeaf::clear()
{
	properties.clear();
}

bool UPServerCommon::UserPropertyLeaf::equals(const UserPropertyLeaf& _o) const
{
	return properties.equals(_o.properties);
}

const char *UPServerCommon::UserPropertyLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("properties=");
	properties.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void UPServerCommon::UserPropertyLeaf::composeMsg(CommMsgBody& _msg) const
{
	properties.composeMsg(_msg);
}

void UPServerCommon::UserPropertyLeaf::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	properties.parseMsg(_parser);
}

/*static*/ void UPServerCommon::UserPropertyLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_parser.parseEnded()) return;
	PString _descbuf;
	int szProperties = ThinAtf::LAtfVector< PropertyForClient, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("properties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "properties", szProperties, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardMatch_Winner_Prop
//=================================================================

UPServerCommon::CardMatch_Winner_Prop::CardMatch_Winner_Prop()
{
	clear();
}

void UPServerCommon::CardMatch_Winner_Prop::clear()
{
	gameType = 0;
	gameId = 0;
	entryId = 0;
}

bool UPServerCommon::CardMatch_Winner_Prop::equals(const CardMatch_Winner_Prop& _o) const
{
	return gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId;
}

const char *UPServerCommon::CardMatch_Winner_Prop::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append('}');
	return _buf.c_str();
}

void UPServerCommon::CardMatch_Winner_Prop::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(gameType);
	_msg.composeUINT64(gameId);
	_msg.composeUINT32(entryId);
}

void UPServerCommon::CardMatch_Winner_Prop::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(gameType);
	_parser.parseUINT64(gameId);
	_parser.parseUINT32(entryId);
}

/*static*/ void UPServerCommon::CardMatch_Winner_Prop::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardMatch_Entry_Prop
//=================================================================

UPServerCommon::CardMatch_Entry_Prop::CardMatch_Entry_Prop()
{
	clear();
}

void UPServerCommon::CardMatch_Entry_Prop::clear()
{
	gameType = 0;
	gameId = 0;
	entryId = 0;
	subGameId = 0;
}

bool UPServerCommon::CardMatch_Entry_Prop::equals(const CardMatch_Entry_Prop& _o) const
{
	return gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		subGameId == _o.subGameId;
}

const char *UPServerCommon::CardMatch_Entry_Prop::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	_buf.append('}');
	return _buf.c_str();
}

void UPServerCommon::CardMatch_Entry_Prop::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBYTE(gameType);
	_msg.composeUINT64(gameId);
	_msg.composeUINT32(entryId);
	_msg.composeUINT64(subGameId);
}

void UPServerCommon::CardMatch_Entry_Prop::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(gameType);
	_parser.parseUINT64(gameId);
	_parser.parseUINT32(entryId);
	_parser.parseUINT64(subGameId);
}

/*static*/ void UPServerCommon::CardMatch_Entry_Prop::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT64 subGameId; _parser.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
}

