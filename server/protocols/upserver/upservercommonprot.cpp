/**
 * upservercommonprot.cpp
 *
 * This file was auto-generated from upservercommonprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor upservercommonprot.txt
 */
 
#include "upservercommonprot.h"

//=================================================================
//                    Property
//=================================================================

UPServerCommon::Property::Property()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerCommon::Property::Property(Property&& _o)
	: propertyTypeId(std::move(_o.propertyTypeId))
	, value(std::move(_o.value))
	, validUntil(std::move(_o.validUntil))
	, propertyAttributes(std::move(_o.propertyAttributes))
{
}

UPServerCommon::Property& UPServerCommon::Property::operator=(Property&& _o)
{
	if(this != &_o)
	{
		propertyTypeId = std::move(_o.propertyTypeId);
		value = std::move(_o.value);
		validUntil = std::move(_o.validUntil);
		propertyAttributes = std::move(_o.propertyAttributes);
	}
	return *this;
}

#endif

void UPServerCommon::Property::clear()
{
	propertyTypeId = 0;
	value = 0;
	validUntil.setNull();
	propertyAttributes.clear();
}

bool UPServerCommon::Property::equals(const Property& _o) const
{
	return propertyTypeId == _o.propertyTypeId &&
		value == _o.value &&
		validUntil.equals(_o.validUntil) &&
		propertyAttributes.equals(_o.propertyAttributes);
}

const char *UPServerCommon::Property::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("propertyTypeId=");
	_buf.appendInt(propertyTypeId);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append(',');
	_buf.append("validUntil=");
	Atf::AtfTempl<CommUtcTime>::ToTraceString(_buf, validUntil);
	_buf.append(',');
	_buf.append("propertyAttributes=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(propertyAttributes, _buf); _buf.append('}');
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServerCommon::Property::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("propertyTypeId", propertyTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::AtfTempl<CommUtcTime>::ToXmlString(_buf, "validUntil", validUntil);
	Atf::XmlElement::encodeAsXmlElement("propertyAttributes", propertyAttributes, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServerCommon::Property::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("propertyTypeId"))
		{
			propertyTypeId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("value"))
		{
			value = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("validUntil"))
		{
			Atf::AtfTempl<CommUtcTime>::FromXmlString(_value, validUntil);
		}
		else if (_element.equals("propertyAttributes"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, propertyAttributes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServerCommon::Property::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(Property())) // not empty
	{
		_body.composeINT32(propertyTypeId);
		_body.composeINT32(value);
		validUntil.compose(_body);
		_body.composeMsgBody(propertyAttributes);
	}

	_msg.composeMsgBody(_body);
}

void UPServerCommon::Property::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(propertyTypeId);
	_parser0.parseINT32(value);
	validUntil.parse(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseMsgBody(propertyAttributes);
}

const char *UPServerCommon::Property::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("propertyTypeId", propertyTypeId);
	_jsonstr.compose("value", value);
	_jsonstr.compose("validUntil", validUntil);
	_jsonstr.compose("propertyAttributes", propertyAttributes);
	return _buf.c_str();
}

void UPServerCommon::Property::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("propertyTypeId", propertyTypeId);
	_jparser.parseByNameThrow("value", value);
	_jparser.parseByNameThrow("validUntil", validUntil);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("propertyAttributes", propertyAttributes);
}

/* static */ void UPServerCommon::Property::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 propertyTypeId; _jparser.validateByNameThrow("propertyTypeId", propertyTypeId);
	AtfValidator::validateInt(_descr, "propertyTypeId", propertyTypeId, _checker, __FILE__, __LINE__);
	INT32 value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	CommUtcTime validUntil; _jparser.validateByNameThrow("validUntil", validUntil);
	if(_jparser.parseEnded()) return;
	Atf::CopyableMsgBody propertyAttributes; _jparser.validateByNameThrow("propertyAttributes", propertyAttributes);
	AtfValidator::validateInt(_descr, "propertyAttributes", propertyAttributes._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServerCommon::Property::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 propertyTypeId; _parser0.parseINT32(propertyTypeId);
	AtfValidator::validateInt(_descr, "propertyTypeId", propertyTypeId, _checker, __FILE__, __LINE__);
	INT32 value; _parser0.parseINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	_parser0.skip(8);  /*validUntil*/
	if(_parser0.parseEnded()) return;
	size_t szPropertyAttributes; _parser0.skipMsgBody(szPropertyAttributes);  /*propertyAttributes*/
	AtfValidator::validateInt(_descr, "propertyAttributes", szPropertyAttributes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PropertyForClient
//=================================================================

UPServerCommon::PropertyForClient::PropertyForClient()
{
	clear();
}

void UPServerCommon::PropertyForClient::clear()
{
	propertyTypeId = 0;
	value = 0;
}

bool UPServerCommon::PropertyForClient::equals(const PropertyForClient& _o) const
{
	return propertyTypeId == _o.propertyTypeId &&
		value == _o.value;
}

const char *UPServerCommon::PropertyForClient::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("propertyTypeId=");
	_buf.appendInt(propertyTypeId);
	_buf.append(',');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServerCommon::PropertyForClient::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("propertyTypeId", propertyTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServerCommon::PropertyForClient::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("propertyTypeId"))
		{
			propertyTypeId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("value"))
		{
			value = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServerCommon::PropertyForClient::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PropertyForClient())) // not empty
	{
		_body.composeINT32(propertyTypeId);
		_body.composeINT32(value);
	}

	_msg.composeMsgBody(_body);
}

void UPServerCommon::PropertyForClient::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(propertyTypeId);
	_parser0.parseINT32(value);
}

const char *UPServerCommon::PropertyForClient::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("propertyTypeId", propertyTypeId);
	_jsonstr.compose("value", value);
	return _buf.c_str();
}

void UPServerCommon::PropertyForClient::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("propertyTypeId", propertyTypeId);
	_jparser.parseByNameThrow("value", value);
}

/* static */ void UPServerCommon::PropertyForClient::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 propertyTypeId; _jparser.validateByNameThrow("propertyTypeId", propertyTypeId);
	AtfValidator::validateInt(_descr, "propertyTypeId", propertyTypeId, _checker, __FILE__, __LINE__);
	INT32 value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServerCommon::PropertyForClient::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 propertyTypeId; _parser0.parseINT32(propertyTypeId);
	AtfValidator::validateInt(_descr, "propertyTypeId", propertyTypeId, _checker, __FILE__, __LINE__);
	INT32 value; _parser0.parseINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserPropertyLeaf
//=================================================================

UPServerCommon::UserPropertyLeaf::UserPropertyLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServerCommon::UserPropertyLeaf::UserPropertyLeaf(UserPropertyLeaf&& _o)
	: properties(std::move(_o.properties))
{
}

UPServerCommon::UserPropertyLeaf& UPServerCommon::UserPropertyLeaf::operator=(UserPropertyLeaf&& _o)
{
	if(this != &_o)
	{
		properties = std::move(_o.properties);
	}
	return *this;
}

#endif

void UPServerCommon::UserPropertyLeaf::clear()
{
	properties.clear();
}

bool UPServerCommon::UserPropertyLeaf::equals(const UserPropertyLeaf& _o) const
{
	return properties.equals(_o.properties);
}

const char *UPServerCommon::UserPropertyLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("properties=");
	properties.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServerCommon::UserPropertyLeaf::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	properties.toXmlString("properties", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServerCommon::UserPropertyLeaf::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("properties"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PropertyForClient, 4 > >::FromXmlString(_value, properties)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServerCommon::UserPropertyLeaf::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	properties.composeMsg(_msg, _ignoreJSON);
}

void UPServerCommon::UserPropertyLeaf::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	properties.parseMsg(_parser);
}

const char *UPServerCommon::UserPropertyLeaf::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("properties", properties);
	return _buf.c_str();
}

void UPServerCommon::UserPropertyLeaf::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("properties", properties);
}

/* static */ void UPServerCommon::UserPropertyLeaf::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< PropertyForClient > properties; _jparser.validateByNameThrow("properties", properties);
	AtfValidator::validateInt(_descr, "properties", properties.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServerCommon::UserPropertyLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_parser.parseEnded()) return;
	PString _descbuf;
	int szProperties = Atf::LAtfVector< PropertyForClient, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("properties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "properties", szProperties, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardMatch_Winner_Prop
//=================================================================

UPServerCommon::CardMatch_Winner_Prop::CardMatch_Winner_Prop()
{
	clear();
}

void UPServerCommon::CardMatch_Winner_Prop::clear()
{
	gameType = 0;
	gameId = 0;
	entryId = 0;
}

bool UPServerCommon::CardMatch_Winner_Prop::equals(const CardMatch_Winner_Prop& _o) const
{
	return gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId;
}

const char *UPServerCommon::CardMatch_Winner_Prop::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServerCommon::CardMatch_Winner_Prop::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServerCommon::CardMatch_Winner_Prop::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameType"))
		{
			gameType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameId"))
		{
			gameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entryId"))
		{
			entryId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServerCommon::CardMatch_Winner_Prop::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(gameType);
	_msg.composeUINT64(gameId);
	_msg.composeUINT32(entryId);
}

void UPServerCommon::CardMatch_Winner_Prop::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(gameType);
	_parser.parseUINT64(gameId);
	_parser.parseUINT32(entryId);
}

const char *UPServerCommon::CardMatch_Winner_Prop::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("entryId", entryId);
	return _buf.c_str();
}

void UPServerCommon::CardMatch_Winner_Prop::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("entryId", entryId);
}

/* static */ void UPServerCommon::CardMatch_Winner_Prop::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServerCommon::CardMatch_Winner_Prop::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    CardMatch_Entry_Prop
//=================================================================

UPServerCommon::CardMatch_Entry_Prop::CardMatch_Entry_Prop()
{
	clear();
}

void UPServerCommon::CardMatch_Entry_Prop::clear()
{
	gameType = 0;
	gameId = 0;
	entryId = 0;
	subGameId = 0;
}

bool UPServerCommon::CardMatch_Entry_Prop::equals(const CardMatch_Entry_Prop& _o) const
{
	return gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		subGameId == _o.subGameId;
}

const char *UPServerCommon::CardMatch_Entry_Prop::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServerCommon::CardMatch_Entry_Prop::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("subGameId", subGameId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServerCommon::CardMatch_Entry_Prop::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameType"))
		{
			gameType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameId"))
		{
			gameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entryId"))
		{
			entryId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("subGameId"))
		{
			subGameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServerCommon::CardMatch_Entry_Prop::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(gameType);
	_msg.composeUINT64(gameId);
	_msg.composeUINT32(entryId);
	_msg.composeUINT64(subGameId);
}

void UPServerCommon::CardMatch_Entry_Prop::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(gameType);
	_parser.parseUINT64(gameId);
	_parser.parseUINT32(entryId);
	_parser.parseUINT64(subGameId);
}

const char *UPServerCommon::CardMatch_Entry_Prop::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("subGameId", subGameId);
	return _buf.c_str();
}

void UPServerCommon::CardMatch_Entry_Prop::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("subGameId", subGameId);
}

/* static */ void UPServerCommon::CardMatch_Entry_Prop::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT64 subGameId; _jparser.validateByNameThrow("subGameId", subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServerCommon::CardMatch_Entry_Prop::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	BYTE gameType; _parser.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT64 subGameId; _parser.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
}

