/**
 * upserverprot_thin.cpp
 *
 * This file was auto-generated from upserverprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin upserverprot.txt
 */
 
#include "upserverprot_thin.h"

//=================================================================
//                    UserPropertyNotification
//=================================================================

UPServer::UserPropertyNotification::UserPropertyNotification()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::UserPropertyNotification::UserPropertyNotification(UserPropertyNotification&& _o)
	: userIntId(std::move(_o.userIntId))
	, userPropBody(std::move(_o.userPropBody))
{
}

UPServer::UserPropertyNotification& UPServer::UserPropertyNotification::operator=(UserPropertyNotification&& _o)
{
	if(this != &_o)
	{
		userIntId = std::move(_o.userIntId);
		userPropBody = std::move(_o.userPropBody);
	}
	return *this;
}

#endif

void UPServer::UserPropertyNotification::clear()
{
	userIntId = 0;
	userPropBody.clear();
}

bool UPServer::UserPropertyNotification::equals(const UserPropertyNotification& _o) const
{
	return userIntId == _o.userIntId &&
		userPropBody.equals(_o.userPropBody);
}

const char *UPServer::UserPropertyNotification::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("userPropBody=");
	userPropBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void UPServer::UserPropertyNotification::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserPropertyNotification())) // not empty
	{
		_body.composeUINT32(userIntId);
		_body.composeMsgBody(userPropBody);
	}

	_msg.composeMsgBody(_body);
}

void UPServer::UserPropertyNotification::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userIntId);
	_parser0.parseMsgBody(userPropBody);
}

/*static*/ void UPServer::UserPropertyNotification::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 userIntId; _parser0.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	size_t szUserPropBody; _parser0.skipMsgBody(szUserPropBody);  /*userPropBody*/
	AtfValidator::validateInt(_descr, "userPropBody", szUserPropBody, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SrvPropertyForCardMatch
//=================================================================

UPServer::SrvPropertyForCardMatch::SrvPropertyForCardMatch()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::SrvPropertyForCardMatch::SrvPropertyForCardMatch(SrvPropertyForCardMatch&& _o)
	: value(std::move(_o.value))
	, mgLobbyAddress(std::move(_o.mgLobbyAddress))
	, mgLobbyInstance(std::move(_o.mgLobbyInstance))
	, isExpired(std::move(_o.isExpired))
	, blitzId(std::move(_o.blitzId))
	, tournId(std::move(_o.tournId))
	, entryId(std::move(_o.entryId))
	, subGameId(std::move(_o.subGameId))
{
}

UPServer::SrvPropertyForCardMatch& UPServer::SrvPropertyForCardMatch::operator=(SrvPropertyForCardMatch&& _o)
{
	if(this != &_o)
	{
		value = std::move(_o.value);
		mgLobbyAddress = std::move(_o.mgLobbyAddress);
		mgLobbyInstance = std::move(_o.mgLobbyInstance);
		isExpired = std::move(_o.isExpired);
		blitzId = std::move(_o.blitzId);
		tournId = std::move(_o.tournId);
		entryId = std::move(_o.entryId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void UPServer::SrvPropertyForCardMatch::clear()
{
	value = 0;
	mgLobbyAddress.clear();
	mgLobbyInstance.clear();
	isExpired = false;
	blitzId = 0;
	tournId = 0;
	entryId = 0;
	subGameId = 0;
}

bool UPServer::SrvPropertyForCardMatch::equals(const SrvPropertyForCardMatch& _o) const
{
	return value == _o.value &&
		mgLobbyAddress.equals(_o.mgLobbyAddress) &&
		mgLobbyInstance.equals(_o.mgLobbyInstance) &&
		isExpired == _o.isExpired &&
		blitzId == _o.blitzId &&
		tournId == _o.tournId &&
		entryId == _o.entryId &&
		subGameId == _o.subGameId;
}

const char *UPServer::SrvPropertyForCardMatch::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append(',');
	_buf.append("mgLobbyAddress=");
	_buf.append(mgLobbyAddress);
	_buf.append(',');
	_buf.append("mgLobbyInstance=");
	_buf.append(mgLobbyInstance);
	_buf.append(',');
	_buf.append("isExpired=");
	_buf.appendUint(isExpired);
	_buf.append(',');
	_buf.append("blitzId=");
	_buf.appendUint(blitzId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	_buf.append('}');
	return _buf.c_str();
}

void UPServer::SrvPropertyForCardMatch::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SrvPropertyForCardMatch())) // not empty
	{
		_body.composeINT32(value);
		_body.composeString(mgLobbyAddress);
		_body.composeString(mgLobbyInstance);
		_body.composeBOOL(isExpired);
		_body.composeUINT32(blitzId);
		_body.composeUINT64(tournId);
		_body.composeUINT32(entryId);
		_body.composeUINT64(subGameId);
	}

	_msg.composeMsgBody(_body);
}

void UPServer::SrvPropertyForCardMatch::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(value);
	_parser0.parseStringP(mgLobbyAddress);
	_parser0.parseStringP(mgLobbyInstance);
	_parser0.parseBOOL(isExpired);
	_parser0.parseUINT32(blitzId);
	_parser0.parseUINT64(tournId);
	_parser0.parseUINT32(entryId);
	_parser0.parseUINT64(subGameId);
}

/*static*/ void UPServer::SrvPropertyForCardMatch::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 value; _parser0.parseINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mgLobbyAddress"); size_t szMgLobbyAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mgLobbyAddress", szMgLobbyAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mgLobbyInstance"); size_t szMgLobbyInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mgLobbyInstance", szMgLobbyInstance, _checker, __FILE__, __LINE__);
	bool isExpired; _parser0.parseBOOL(isExpired);
	AtfValidator::validateInt(_descr, "isExpired", isExpired, _checker, __FILE__, __LINE__);
	UINT32 blitzId; _parser0.parseUINT32(blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
	UINT64 tournId; _parser0.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT64 subGameId; _parser0.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PropertyForServer
//=================================================================

UPServer::PropertyForServer::PropertyForServer()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::PropertyForServer::PropertyForServer(PropertyForServer&& _o)
	: propertyTypeId(std::move(_o.propertyTypeId))
	, propertyBody(std::move(_o.propertyBody))
{
}

UPServer::PropertyForServer& UPServer::PropertyForServer::operator=(PropertyForServer&& _o)
{
	if(this != &_o)
	{
		propertyTypeId = std::move(_o.propertyTypeId);
		propertyBody = std::move(_o.propertyBody);
	}
	return *this;
}

#endif

void UPServer::PropertyForServer::clear()
{
	propertyTypeId = 0;
	propertyBody.clear();
}

bool UPServer::PropertyForServer::equals(const PropertyForServer& _o) const
{
	return propertyTypeId == _o.propertyTypeId &&
		propertyBody.equals(_o.propertyBody);
}

const char *UPServer::PropertyForServer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("propertyTypeId=");
	_buf.appendInt(propertyTypeId);
	_buf.append(',');
	_buf.append("propertyBody=");
	propertyBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void UPServer::PropertyForServer::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PropertyForServer())) // not empty
	{
		_body.composeINT32(propertyTypeId);
		_body.composeMsgBody(propertyBody);
	}

	_msg.composeMsgBody(_body);
}

void UPServer::PropertyForServer::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(propertyTypeId);
	_parser0.parseMsgBody(propertyBody);
}

/*static*/ void UPServer::PropertyForServer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 propertyTypeId; _parser0.parseINT32(propertyTypeId);
	AtfValidator::validateInt(_descr, "propertyTypeId", propertyTypeId, _checker, __FILE__, __LINE__);
	size_t szPropertyBody; _parser0.skipMsgBody(szPropertyBody);  /*propertyBody*/
	AtfValidator::validateInt(_descr, "propertyBody", szPropertyBody, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserPropertyNotificationForServer
//=================================================================

UPServer::UserPropertyNotificationForServer::UserPropertyNotificationForServer()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::UserPropertyNotificationForServer::UserPropertyNotificationForServer(UserPropertyNotificationForServer&& _o)
	: userIntId(std::move(_o.userIntId))
	, isObserver(std::move(_o.isObserver))
	, properties(std::move(_o.properties))
{
}

UPServer::UserPropertyNotificationForServer& UPServer::UserPropertyNotificationForServer::operator=(UserPropertyNotificationForServer&& _o)
{
	if(this != &_o)
	{
		userIntId = std::move(_o.userIntId);
		isObserver = std::move(_o.isObserver);
		properties = std::move(_o.properties);
	}
	return *this;
}

#endif

void UPServer::UserPropertyNotificationForServer::clear()
{
	userIntId = 0;
	isObserver = false;
	properties.clear();
}

bool UPServer::UserPropertyNotificationForServer::equals(const UserPropertyNotificationForServer& _o) const
{
	return userIntId == _o.userIntId &&
		isObserver == _o.isObserver &&
		properties.equals(_o.properties);
}

const char *UPServer::UserPropertyNotificationForServer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("isObserver=");
	_buf.appendUint(isObserver);
	_buf.append(',');
	_buf.append("properties=");
	properties.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void UPServer::UserPropertyNotificationForServer::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(UserPropertyNotificationForServer())) // not empty
	{
		_body.composeUINT32(userIntId);
		_body.composeBOOL(isObserver);
		properties.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void UPServer::UserPropertyNotificationForServer::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userIntId);
	_parser0.parseBOOL(isObserver);
	properties.parseMsg(_parser0);
}

/*static*/ void UPServer::UserPropertyNotificationForServer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 userIntId; _parser0.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	bool isObserver; _parser0.parseBOOL(isObserver);
	AtfValidator::validateInt(_descr, "isObserver", isObserver, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szProperties = ThinAtf::LAtfVector< PropertyForServer, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("properties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "properties", szProperties, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableSelfIdentity
//=================================================================

UPServer::TableSelfIdentity::TableSelfIdentity()
{
	clear();
}

void UPServer::TableSelfIdentity::clear()
{
	tableId = 0;
}

bool UPServer::TableSelfIdentity::equals(const TableSelfIdentity& _o) const
{
	return tableId == _o.tableId;
}

const char *UPServer::TableSelfIdentity::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append('}');
	return _buf.c_str();
}

void UPServer::TableSelfIdentity::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(tableId);
}

void UPServer::TableSelfIdentity::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tableId);
}

/*static*/ void UPServer::TableSelfIdentity::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    BlitzSelfIdentity
//=================================================================

UPServer::BlitzSelfIdentity::BlitzSelfIdentity()
{
	clear();
}

void UPServer::BlitzSelfIdentity::clear()
{
	blitzId = 0;
}

bool UPServer::BlitzSelfIdentity::equals(const BlitzSelfIdentity& _o) const
{
	return blitzId == _o.blitzId;
}

const char *UPServer::BlitzSelfIdentity::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("blitzId=");
	_buf.appendUint(blitzId);
	_buf.append('}');
	return _buf.c_str();
}

void UPServer::BlitzSelfIdentity::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(blitzId);
}

void UPServer::BlitzSelfIdentity::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(blitzId);
}

/*static*/ void UPServer::BlitzSelfIdentity::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 blitzId; _parser.parseUINT32(blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MtlSelfIdentity
//=================================================================

UPServer::MtlSelfIdentity::MtlSelfIdentity()
{
	clear();
}

void UPServer::MtlSelfIdentity::clear()
{
	tournId = 0;
}

bool UPServer::MtlSelfIdentity::equals(const MtlSelfIdentity& _o) const
{
	return tournId == _o.tournId;
}

const char *UPServer::MtlSelfIdentity::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append('}');
	return _buf.c_str();
}

void UPServer::MtlSelfIdentity::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(tournId);
}

void UPServer::MtlSelfIdentity::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tournId);
}

/*static*/ void UPServer::MtlSelfIdentity::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT64 tournId; _parser.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_UPS_Q_USERS_JOIN
//=================================================================

UPServer::Protocol_UPS_Q_USERS_JOIN::Protocol_UPS_Q_USERS_JOIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_USERS_JOIN::Protocol_UPS_Q_USERS_JOIN(Protocol_UPS_Q_USERS_JOIN&& _o)
	: userIntIds(std::move(_o.userIntIds))
{
}

UPServer::Protocol_UPS_Q_USERS_JOIN& UPServer::Protocol_UPS_Q_USERS_JOIN::operator=(Protocol_UPS_Q_USERS_JOIN&& _o)
{
	if(this != &_o)
	{
		userIntIds = std::move(_o.userIntIds);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_USERS_JOIN::clear()
{
	userIntIds.clear();
}

bool UPServer::Protocol_UPS_Q_USERS_JOIN::equals(const Protocol_UPS_Q_USERS_JOIN& _o) const
{
	return userIntIds.equals(_o.userIntIds);
}

const char *UPServer::Protocol_UPS_Q_USERS_JOIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_USERS_JOIN).append(")");
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_USERS_JOIN::composeMsg(CommMsgBody& _msg) const
{
	userIntIds.composeMsg(_msg);
}

void UPServer::Protocol_UPS_Q_USERS_JOIN::parseMsg(CommMsgParser& _parser)
{
	userIntIds.parseMsg(_parser);
}

/*static*/ void UPServer::Protocol_UPS_Q_USERS_JOIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_USERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIntIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_USERS_JOIN
//=================================================================

UPServer::Protocol_UPS_A_USERS_JOIN::Protocol_UPS_A_USERS_JOIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_USERS_JOIN::Protocol_UPS_A_USERS_JOIN(Protocol_UPS_A_USERS_JOIN&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_USERS_JOIN& UPServer::Protocol_UPS_A_USERS_JOIN::operator=(Protocol_UPS_A_USERS_JOIN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_USERS_JOIN::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_USERS_JOIN::equals(const Protocol_UPS_A_USERS_JOIN& _o) const
{
	return errCode == _o.errCode &&
		errStr.equals(_o.errStr);
}

const char *UPServer::Protocol_UPS_A_USERS_JOIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_USERS_JOIN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_USERS_JOIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_USERS_JOIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_USERS_JOIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_USERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_Q_USERS_LEFT
//=================================================================

UPServer::Protocol_UPS_Q_USERS_LEFT::Protocol_UPS_Q_USERS_LEFT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_USERS_LEFT::Protocol_UPS_Q_USERS_LEFT(Protocol_UPS_Q_USERS_LEFT&& _o)
	: userIntIds(std::move(_o.userIntIds))
{
}

UPServer::Protocol_UPS_Q_USERS_LEFT& UPServer::Protocol_UPS_Q_USERS_LEFT::operator=(Protocol_UPS_Q_USERS_LEFT&& _o)
{
	if(this != &_o)
	{
		userIntIds = std::move(_o.userIntIds);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_USERS_LEFT::clear()
{
	userIntIds.clear();
}

bool UPServer::Protocol_UPS_Q_USERS_LEFT::equals(const Protocol_UPS_Q_USERS_LEFT& _o) const
{
	return userIntIds.equals(_o.userIntIds);
}

const char *UPServer::Protocol_UPS_Q_USERS_LEFT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_USERS_LEFT).append(")");
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_USERS_LEFT::composeMsg(CommMsgBody& _msg) const
{
	userIntIds.composeMsg(_msg);
}

void UPServer::Protocol_UPS_Q_USERS_LEFT::parseMsg(CommMsgParser& _parser)
{
	userIntIds.parseMsg(_parser);
}

/*static*/ void UPServer::Protocol_UPS_Q_USERS_LEFT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_USERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIntIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_USERS_LEFT
//=================================================================

UPServer::Protocol_UPS_A_USERS_LEFT::Protocol_UPS_A_USERS_LEFT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_USERS_LEFT::Protocol_UPS_A_USERS_LEFT(Protocol_UPS_A_USERS_LEFT&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_USERS_LEFT& UPServer::Protocol_UPS_A_USERS_LEFT::operator=(Protocol_UPS_A_USERS_LEFT&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_USERS_LEFT::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_USERS_LEFT::equals(const Protocol_UPS_A_USERS_LEFT& _o) const
{
	return errCode == _o.errCode &&
		errStr.equals(_o.errStr);
}

const char *UPServer::Protocol_UPS_A_USERS_LEFT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_USERS_LEFT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_USERS_LEFT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_USERS_LEFT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_USERS_LEFT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_USERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_Q_SET_PROPERTY
//=================================================================

UPServer::Protocol_UPS_Q_SET_PROPERTY::Protocol_UPS_Q_SET_PROPERTY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_SET_PROPERTY::Protocol_UPS_Q_SET_PROPERTY(Protocol_UPS_Q_SET_PROPERTY&& _o)
	: property(std::move(_o.property))
	, userIntIds(std::move(_o.userIntIds))
{
}

UPServer::Protocol_UPS_Q_SET_PROPERTY& UPServer::Protocol_UPS_Q_SET_PROPERTY::operator=(Protocol_UPS_Q_SET_PROPERTY&& _o)
{
	if(this != &_o)
	{
		property = std::move(_o.property);
		userIntIds = std::move(_o.userIntIds);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_SET_PROPERTY::clear()
{
	property.clear();
	userIntIds.clear();
}

bool UPServer::Protocol_UPS_Q_SET_PROPERTY::equals(const Protocol_UPS_Q_SET_PROPERTY& _o) const
{
	return property.equals(_o.property) &&
		userIntIds.equals(_o.userIntIds);
}

const char *UPServer::Protocol_UPS_Q_SET_PROPERTY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_SET_PROPERTY).append(")");
	_buf.append(',');
	_buf.append("property=");
	property.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_SET_PROPERTY::composeMsg(CommMsgBody& _msg) const
{
	property.composeMsg(_msg);
	userIntIds.composeMsg(_msg);
}

void UPServer::Protocol_UPS_Q_SET_PROPERTY::parseMsg(CommMsgParser& _parser)
{
	property.parseMsg(_parser);
	userIntIds.parseMsg(_parser);
}

/*static*/ void UPServer::Protocol_UPS_Q_SET_PROPERTY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_SET_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	UPServerCommon::Property::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("property"), _fieldsWithUnparsedContent);
	int szUserIntIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_SET_PROPERTY
//=================================================================

UPServer::Protocol_UPS_A_SET_PROPERTY::Protocol_UPS_A_SET_PROPERTY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_SET_PROPERTY::Protocol_UPS_A_SET_PROPERTY(Protocol_UPS_A_SET_PROPERTY&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_SET_PROPERTY& UPServer::Protocol_UPS_A_SET_PROPERTY::operator=(Protocol_UPS_A_SET_PROPERTY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_SET_PROPERTY::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_SET_PROPERTY::equals(const Protocol_UPS_A_SET_PROPERTY& _o) const
{
	return errCode == _o.errCode &&
		errStr.equals(_o.errStr);
}

const char *UPServer::Protocol_UPS_A_SET_PROPERTY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_SET_PROPERTY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_SET_PROPERTY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_SET_PROPERTY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_SET_PROPERTY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_SET_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_NOTIFY_PROPERTY_UPDATED
//=================================================================

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::Protocol_UPS_NOTIFY_PROPERTY_UPDATED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::Protocol_UPS_NOTIFY_PROPERTY_UPDATED(Protocol_UPS_NOTIFY_PROPERTY_UPDATED&& _o)
	: userPropertyNotification(std::move(_o.userPropertyNotification))
{
}

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED& UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::operator=(Protocol_UPS_NOTIFY_PROPERTY_UPDATED&& _o)
{
	if(this != &_o)
	{
		userPropertyNotification = std::move(_o.userPropertyNotification);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::clear()
{
	userPropertyNotification.clear();
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::equals(const Protocol_UPS_NOTIFY_PROPERTY_UPDATED& _o) const
{
	return userPropertyNotification.equals(_o.userPropertyNotification);
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_NOTIFY_PROPERTY_UPDATED).append(")");
	_buf.append(',');
	_buf.append("userPropertyNotification=");
	userPropertyNotification.toTraceString(_buf);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::composeMsg(CommMsgBody& _msg) const
{
	userPropertyNotification.composeMsg(_msg);
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::parseMsg(CommMsgParser& _parser)
{
	userPropertyNotification.parseMsg(_parser);
}

/*static*/ void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_NOTIFY_PROPERTY_UPDATED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserPropertyNotification = ThinAtf::LAtfVector< UserPropertyNotification, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userPropertyNotification"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userPropertyNotification", szUserPropertyNotification, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER
//=================================================================

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER(Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER&& _o)
	: userPropertyNotification(std::move(_o.userPropertyNotification))
{
}

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER& UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::operator=(Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER&& _o)
{
	if(this != &_o)
	{
		userPropertyNotification = std::move(_o.userPropertyNotification);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::clear()
{
	userPropertyNotification.clear();
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::equals(const Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER& _o) const
{
	return userPropertyNotification.equals(_o.userPropertyNotification);
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_NOTIFY_PROPERTY_UPDATED_SERVER).append(")");
	_buf.append(',');
	_buf.append("userPropertyNotification=");
	userPropertyNotification.toTraceString(_buf);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::composeMsg(CommMsgBody& _msg) const
{
	userPropertyNotification.composeMsg(_msg);
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::parseMsg(CommMsgParser& _parser)
{
	userPropertyNotification.parseMsg(_parser);
}

/*static*/ void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_NOTIFY_PROPERTY_UPDATED_SERVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserPropertyNotification = ThinAtf::LAtfVector< UserPropertyNotificationForServer, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userPropertyNotification"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userPropertyNotification", szUserPropertyNotification, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER
//=================================================================

UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER(Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER&& _o)
	: blitzId(std::move(_o.blitzId))
	, tableId(std::move(_o.tableId))
	, userIntId(std::move(_o.userIntId))
	, entryId(std::move(_o.entryId))
	, notifTypeId(std::move(_o.notifTypeId))
	, notifSubTypeId(std::move(_o.notifSubTypeId))
	, notifMsg(std::move(_o.notifMsg))
{
}

UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER& UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::operator=(Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER&& _o)
{
	if(this != &_o)
	{
		blitzId = std::move(_o.blitzId);
		tableId = std::move(_o.tableId);
		userIntId = std::move(_o.userIntId);
		entryId = std::move(_o.entryId);
		notifTypeId = std::move(_o.notifTypeId);
		notifSubTypeId = std::move(_o.notifSubTypeId);
		notifMsg = std::move(_o.notifMsg);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::clear()
{
	blitzId = 0;
	tableId = 0;
	userIntId = 0;
	entryId = 0;
	notifTypeId = 0;
	notifSubTypeId = 0;
	notifMsg.clear();
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::equals(const Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER& _o) const
{
	return blitzId == _o.blitzId &&
		tableId == _o.tableId &&
		userIntId == _o.userIntId &&
		entryId == _o.entryId &&
		notifTypeId == _o.notifTypeId &&
		notifSubTypeId == _o.notifSubTypeId &&
		notifMsg.equals(_o.notifMsg);
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER).append(")");
	_buf.append(',');
	_buf.append("blitzId=");
	_buf.appendUint(blitzId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("notifTypeId=");
	_buf.appendUint(notifTypeId);
	_buf.append(',');
	_buf.append("notifSubTypeId=");
	_buf.appendUint(notifSubTypeId);
	_buf.append(',');
	_buf.append("notifMsg=");
	notifMsg.toTraceString(_buf);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(blitzId);
	_msg.composeUINT64(tableId);
	_msg.composeUINT32(userIntId);
	_msg.composeUINT32(entryId);
	_msg.composeUINT32(notifTypeId);
	_msg.composeUINT32(notifSubTypeId);
	notifMsg.composeMsg(_msg);
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(blitzId);
	_parser.parseUINT64(tableId);
	_parser.parseUINT32(userIntId);
	_parser.parseUINT32(entryId);
	_parser.parseUINT32(notifTypeId);
	_parser.parseUINT32(notifSubTypeId);
	notifMsg.parseMsg(_parser);
}

/*static*/ void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 blitzId; _parser.parseUINT32(blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT32 notifTypeId; _parser.parseUINT32(notifTypeId);
	AtfValidator::validateInt(_descr, "notifTypeId", notifTypeId, _checker, __FILE__, __LINE__);
	UINT32 notifSubTypeId; _parser.parseUINT32(notifSubTypeId);
	AtfValidator::validateInt(_descr, "notifSubTypeId", notifSubTypeId, _checker, __FILE__, __LINE__);
	ThinAtf::MoveableMsgBody notifMsg; notifMsg.parseMsg(_parser);
	AtfValidator::validateInt(_descr, "notifMsg", notifMsg._size(), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_Q_OBSERVERS_JOIN
//=================================================================

UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::Protocol_UPS_Q_OBSERVERS_JOIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::Protocol_UPS_Q_OBSERVERS_JOIN(Protocol_UPS_Q_OBSERVERS_JOIN&& _o)
	: userIntIds(std::move(_o.userIntIds))
	, gameId(std::move(_o.gameId))
	, entryType(std::move(_o.entryType))
{
}

UPServer::Protocol_UPS_Q_OBSERVERS_JOIN& UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::operator=(Protocol_UPS_Q_OBSERVERS_JOIN&& _o)
{
	if(this != &_o)
	{
		userIntIds = std::move(_o.userIntIds);
		gameId = std::move(_o.gameId);
		entryType = std::move(_o.entryType);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::clear()
{
	userIntIds.clear();
	gameId = 0;
	entryType = 0;
}

bool UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::equals(const Protocol_UPS_Q_OBSERVERS_JOIN& _o) const
{
	return userIntIds.equals(_o.userIntIds) &&
		gameId == _o.gameId &&
		entryType == _o.entryType;
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_OBSERVERS_JOIN).append(")");
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryType=");
	_buf.appendInt(entryType);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::composeMsg(CommMsgBody& _msg) const
{
	userIntIds.composeMsg(_msg);
	_msg.composeUINT64(gameId);
	_msg.composeINT8(entryType);
}

void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::parseMsg(CommMsgParser& _parser)
{
	userIntIds.parseMsg(_parser);
	_parser.parseUINT64(gameId);
	_parser.parseINT8(entryType);
}

/*static*/ void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_OBSERVERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIntIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	INT8 entryType; _parser.parseINT8(entryType);
	AtfValidator::validateInt(_descr, "entryType", entryType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_OBSERVERS_JOIN
//=================================================================

UPServer::Protocol_UPS_A_OBSERVERS_JOIN::Protocol_UPS_A_OBSERVERS_JOIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_OBSERVERS_JOIN::Protocol_UPS_A_OBSERVERS_JOIN(Protocol_UPS_A_OBSERVERS_JOIN&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_OBSERVERS_JOIN& UPServer::Protocol_UPS_A_OBSERVERS_JOIN::operator=(Protocol_UPS_A_OBSERVERS_JOIN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_OBSERVERS_JOIN::equals(const Protocol_UPS_A_OBSERVERS_JOIN& _o) const
{
	return errCode == _o.errCode &&
		errStr.equals(_o.errStr);
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_JOIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_OBSERVERS_JOIN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_OBSERVERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_Q_OBSERVERS_LEFT
//=================================================================

UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::Protocol_UPS_Q_OBSERVERS_LEFT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::Protocol_UPS_Q_OBSERVERS_LEFT(Protocol_UPS_Q_OBSERVERS_LEFT&& _o)
	: userIntIds(std::move(_o.userIntIds))
	, gameId(std::move(_o.gameId))
	, entryType(std::move(_o.entryType))
{
}

UPServer::Protocol_UPS_Q_OBSERVERS_LEFT& UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::operator=(Protocol_UPS_Q_OBSERVERS_LEFT&& _o)
{
	if(this != &_o)
	{
		userIntIds = std::move(_o.userIntIds);
		gameId = std::move(_o.gameId);
		entryType = std::move(_o.entryType);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::clear()
{
	userIntIds.clear();
	gameId = 0;
	entryType = 0;
}

bool UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::equals(const Protocol_UPS_Q_OBSERVERS_LEFT& _o) const
{
	return userIntIds.equals(_o.userIntIds) &&
		gameId == _o.gameId &&
		entryType == _o.entryType;
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_OBSERVERS_LEFT).append(")");
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryType=");
	_buf.appendInt(entryType);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::composeMsg(CommMsgBody& _msg) const
{
	userIntIds.composeMsg(_msg);
	_msg.composeUINT64(gameId);
	_msg.composeINT8(entryType);
}

void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::parseMsg(CommMsgParser& _parser)
{
	userIntIds.parseMsg(_parser);
	_parser.parseUINT64(gameId);
	_parser.parseINT8(entryType);
}

/*static*/ void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_OBSERVERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIntIds = ThinAtf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	INT8 entryType; _parser.parseINT8(entryType);
	AtfValidator::validateInt(_descr, "entryType", entryType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_OBSERVERS_LEFT
//=================================================================

UPServer::Protocol_UPS_A_OBSERVERS_LEFT::Protocol_UPS_A_OBSERVERS_LEFT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_OBSERVERS_LEFT::Protocol_UPS_A_OBSERVERS_LEFT(Protocol_UPS_A_OBSERVERS_LEFT&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_OBSERVERS_LEFT& UPServer::Protocol_UPS_A_OBSERVERS_LEFT::operator=(Protocol_UPS_A_OBSERVERS_LEFT&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_OBSERVERS_LEFT::equals(const Protocol_UPS_A_OBSERVERS_LEFT& _o) const
{
	return errCode == _o.errCode &&
		errStr.equals(_o.errStr);
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_LEFT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_OBSERVERS_LEFT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_OBSERVERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool UPServer::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case UPS_A_OBSERVERS_JOIN: Protocol_UPS_A_OBSERVERS_JOIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_OBSERVERS_LEFT: Protocol_UPS_A_OBSERVERS_LEFT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_SET_PROPERTY: Protocol_UPS_A_SET_PROPERTY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_USERS_JOIN: Protocol_UPS_A_USERS_JOIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_USERS_LEFT: Protocol_UPS_A_USERS_LEFT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER: Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_NOTIFY_PROPERTY_UPDATED: Protocol_UPS_NOTIFY_PROPERTY_UPDATED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_NOTIFY_PROPERTY_UPDATED_SERVER: Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_OBSERVERS_JOIN: Protocol_UPS_Q_OBSERVERS_JOIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_OBSERVERS_LEFT: Protocol_UPS_Q_OBSERVERS_LEFT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_SET_PROPERTY: Protocol_UPS_Q_SET_PROPERTY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_USERS_JOIN: Protocol_UPS_Q_USERS_JOIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_USERS_LEFT: Protocol_UPS_Q_USERS_LEFT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

