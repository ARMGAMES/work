/**
 * upserverprot.cpp
 *
 * This file was auto-generated from upserverprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor upserverprot.txt
 */
 
#include "upserverprot.h"

//=================================================================
//                    UserPropertyNotification
//=================================================================

UPServer::UserPropertyNotification::UserPropertyNotification()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::UserPropertyNotification::UserPropertyNotification(UserPropertyNotification&& _o)
	: userIntId(std::move(_o.userIntId))
	, userPropBody(std::move(_o.userPropBody))
{
}

UPServer::UserPropertyNotification& UPServer::UserPropertyNotification::operator=(UserPropertyNotification&& _o)
{
	if(this != &_o)
	{
		userIntId = std::move(_o.userIntId);
		userPropBody = std::move(_o.userPropBody);
	}
	return *this;
}

#endif

void UPServer::UserPropertyNotification::clear()
{
	userIntId = 0;
	userPropBody.clear();
}

bool UPServer::UserPropertyNotification::equals(const UserPropertyNotification& _o) const
{
	return userIntId == _o.userIntId &&
		userPropBody.equals(_o.userPropBody);
}

const char *UPServer::UserPropertyNotification::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("userPropBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(userPropBody, _buf); _buf.append('}');
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServer::UserPropertyNotification::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userPropBody", userPropBody, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServer::UserPropertyNotification::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userIntId"))
		{
			userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userPropBody"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, userPropBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServer::UserPropertyNotification::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserPropertyNotification())) // not empty
	{
		_body.composeUINT32(userIntId);
		_body.composeMsgBody(userPropBody);
	}

	_msg.composeMsgBody(_body);
}

void UPServer::UserPropertyNotification::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userIntId);
	_parser0.parseMsgBody(userPropBody);
}

const char *UPServer::UserPropertyNotification::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("userPropBody", userPropBody);
	return _buf.c_str();
}

void UPServer::UserPropertyNotification::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("userPropBody", userPropBody);
}

/* static */ void UPServer::UserPropertyNotification::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody userPropBody; _jparser.validateByNameThrow("userPropBody", userPropBody);
	AtfValidator::validateInt(_descr, "userPropBody", userPropBody._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::UserPropertyNotification::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 userIntId; _parser0.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	size_t szUserPropBody; _parser0.skipMsgBody(szUserPropBody);  /*userPropBody*/
	AtfValidator::validateInt(_descr, "userPropBody", szUserPropBody, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SrvPropertyForCardMatch
//=================================================================

UPServer::SrvPropertyForCardMatch::SrvPropertyForCardMatch()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::SrvPropertyForCardMatch::SrvPropertyForCardMatch(SrvPropertyForCardMatch&& _o)
	: value(std::move(_o.value))
	, mgLobbyAddress(std::move(_o.mgLobbyAddress))
	, mgLobbyInstance(std::move(_o.mgLobbyInstance))
	, isExpired(std::move(_o.isExpired))
	, blitzId(std::move(_o.blitzId))
	, tournId(std::move(_o.tournId))
	, entryId(std::move(_o.entryId))
	, subGameId(std::move(_o.subGameId))
{
}

UPServer::SrvPropertyForCardMatch& UPServer::SrvPropertyForCardMatch::operator=(SrvPropertyForCardMatch&& _o)
{
	if(this != &_o)
	{
		value = std::move(_o.value);
		mgLobbyAddress = std::move(_o.mgLobbyAddress);
		mgLobbyInstance = std::move(_o.mgLobbyInstance);
		isExpired = std::move(_o.isExpired);
		blitzId = std::move(_o.blitzId);
		tournId = std::move(_o.tournId);
		entryId = std::move(_o.entryId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void UPServer::SrvPropertyForCardMatch::clear()
{
	value = 0;
	mgLobbyAddress.clear();
	mgLobbyInstance.clear();
	isExpired = false;
	blitzId = 0;
	tournId = 0;
	entryId = 0;
	subGameId = 0;
}

bool UPServer::SrvPropertyForCardMatch::equals(const SrvPropertyForCardMatch& _o) const
{
	return value == _o.value &&
		Atf::atfPStringEquals(mgLobbyAddress, _o.mgLobbyAddress) &&
		Atf::atfPStringEquals(mgLobbyInstance, _o.mgLobbyInstance) &&
		isExpired == _o.isExpired &&
		blitzId == _o.blitzId &&
		tournId == _o.tournId &&
		entryId == _o.entryId &&
		subGameId == _o.subGameId;
}

const char *UPServer::SrvPropertyForCardMatch::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("value=");
	_buf.appendInt(value);
	_buf.append(',');
	_buf.append("mgLobbyAddress=");
	_buf.append(mgLobbyAddress);
	_buf.append(',');
	_buf.append("mgLobbyInstance=");
	_buf.append(mgLobbyInstance);
	_buf.append(',');
	_buf.append("isExpired=");
	_buf.appendUint(isExpired);
	_buf.append(',');
	_buf.append("blitzId=");
	_buf.appendUint(blitzId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServer::SrvPropertyForCardMatch::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::encodeAsXmlElement("mgLobbyAddress", mgLobbyAddress, _buf);
	Atf::XmlElement::encodeAsXmlElement("mgLobbyInstance", mgLobbyInstance, _buf);
	Atf::XmlElement::encodeAsXmlElement("isExpired", isExpired, _buf);
	Atf::XmlElement::encodeAsXmlElement("blitzId", blitzId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("subGameId", subGameId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServer::SrvPropertyForCardMatch::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("value"))
		{
			value = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("mgLobbyAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mgLobbyAddress)) return false;
		}
		else if (_element.equals("mgLobbyInstance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, mgLobbyInstance)) return false;
		}
		else if (_element.equals("isExpired"))
		{
			isExpired = (*_value.ptr() == '1');
		}
		else if (_element.equals("blitzId"))
		{
			blitzId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entryId"))
		{
			entryId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("subGameId"))
		{
			subGameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServer::SrvPropertyForCardMatch::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SrvPropertyForCardMatch())) // not empty
	{
		_body.composeINT32(value);
		_body.composeString(mgLobbyAddress);
		_body.composeString(mgLobbyInstance);
		_body.composeBOOL(isExpired);
		_body.composeUINT32(blitzId);
		_body.composeUINT64(tournId);
		_body.composeUINT32(entryId);
		_body.composeUINT64(subGameId);
	}

	_msg.composeMsgBody(_body);
}

void UPServer::SrvPropertyForCardMatch::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(value);
	_parser0.parseStringP(mgLobbyAddress);
	_parser0.parseStringP(mgLobbyInstance);
	_parser0.parseBOOL(isExpired);
	_parser0.parseUINT32(blitzId);
	_parser0.parseUINT64(tournId);
	_parser0.parseUINT32(entryId);
	_parser0.parseUINT64(subGameId);
}

const char *UPServer::SrvPropertyForCardMatch::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("value", value);
	_jsonstr.compose("mgLobbyAddress", mgLobbyAddress);
	_jsonstr.compose("mgLobbyInstance", mgLobbyInstance);
	_jsonstr.compose("isExpired", isExpired);
	_jsonstr.compose("blitzId", blitzId);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("subGameId", subGameId);
	return _buf.c_str();
}

void UPServer::SrvPropertyForCardMatch::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("value", value);
	_jparser.parseByNameThrow("mgLobbyAddress", mgLobbyAddress);
	_jparser.parseByNameThrow("mgLobbyInstance", mgLobbyInstance);
	_jparser.parseByNameThrow("isExpired", isExpired);
	_jparser.parseByNameThrow("blitzId", blitzId);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("subGameId", subGameId);
}

/* static */ void UPServer::SrvPropertyForCardMatch::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	PString mgLobbyAddress; _jparser.validateByNameThrow("mgLobbyAddress", mgLobbyAddress);
	AtfValidator::validateInt(_descr, "mgLobbyAddress", mgLobbyAddress.length(), _checker, __FILE__, __LINE__);
	PString mgLobbyInstance; _jparser.validateByNameThrow("mgLobbyInstance", mgLobbyInstance);
	AtfValidator::validateInt(_descr, "mgLobbyInstance", mgLobbyInstance.length(), _checker, __FILE__, __LINE__);
	bool isExpired; _jparser.validateByNameThrow("isExpired", isExpired);
	AtfValidator::validateInt(_descr, "isExpired", isExpired, _checker, __FILE__, __LINE__);
	UINT32 blitzId; _jparser.validateByNameThrow("blitzId", blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
	UINT64 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT64 subGameId; _jparser.validateByNameThrow("subGameId", subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::SrvPropertyForCardMatch::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 value; _parser0.parseINT32(value);
	AtfValidator::validateInt(_descr, "value", value, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mgLobbyAddress"); size_t szMgLobbyAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mgLobbyAddress", szMgLobbyAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "mgLobbyInstance"); size_t szMgLobbyInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "mgLobbyInstance", szMgLobbyInstance, _checker, __FILE__, __LINE__);
	bool isExpired; _parser0.parseBOOL(isExpired);
	AtfValidator::validateInt(_descr, "isExpired", isExpired, _checker, __FILE__, __LINE__);
	UINT32 blitzId; _parser0.parseUINT32(blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
	UINT64 tournId; _parser0.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT64 subGameId; _parser0.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PropertyForServer
//=================================================================

UPServer::PropertyForServer::PropertyForServer()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::PropertyForServer::PropertyForServer(PropertyForServer&& _o)
	: propertyTypeId(std::move(_o.propertyTypeId))
	, propertyBody(std::move(_o.propertyBody))
{
}

UPServer::PropertyForServer& UPServer::PropertyForServer::operator=(PropertyForServer&& _o)
{
	if(this != &_o)
	{
		propertyTypeId = std::move(_o.propertyTypeId);
		propertyBody = std::move(_o.propertyBody);
	}
	return *this;
}

#endif

void UPServer::PropertyForServer::clear()
{
	propertyTypeId = 0;
	propertyBody.clear();
}

bool UPServer::PropertyForServer::equals(const PropertyForServer& _o) const
{
	return propertyTypeId == _o.propertyTypeId &&
		propertyBody.equals(_o.propertyBody);
}

const char *UPServer::PropertyForServer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("propertyTypeId=");
	_buf.appendInt(propertyTypeId);
	_buf.append(',');
	_buf.append("propertyBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(propertyBody, _buf); _buf.append('}');
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServer::PropertyForServer::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("propertyTypeId", propertyTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("propertyBody", propertyBody, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServer::PropertyForServer::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("propertyTypeId"))
		{
			propertyTypeId = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("propertyBody"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, propertyBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServer::PropertyForServer::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PropertyForServer())) // not empty
	{
		_body.composeINT32(propertyTypeId);
		_body.composeMsgBody(propertyBody);
	}

	_msg.composeMsgBody(_body);
}

void UPServer::PropertyForServer::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(propertyTypeId);
	_parser0.parseMsgBody(propertyBody);
}

const char *UPServer::PropertyForServer::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("propertyTypeId", propertyTypeId);
	_jsonstr.compose("propertyBody", propertyBody);
	return _buf.c_str();
}

void UPServer::PropertyForServer::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("propertyTypeId", propertyTypeId);
	_jparser.parseByNameThrow("propertyBody", propertyBody);
}

/* static */ void UPServer::PropertyForServer::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 propertyTypeId; _jparser.validateByNameThrow("propertyTypeId", propertyTypeId);
	AtfValidator::validateInt(_descr, "propertyTypeId", propertyTypeId, _checker, __FILE__, __LINE__);
	Atf::CopyableMsgBody propertyBody; _jparser.validateByNameThrow("propertyBody", propertyBody);
	AtfValidator::validateInt(_descr, "propertyBody", propertyBody._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::PropertyForServer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 propertyTypeId; _parser0.parseINT32(propertyTypeId);
	AtfValidator::validateInt(_descr, "propertyTypeId", propertyTypeId, _checker, __FILE__, __LINE__);
	size_t szPropertyBody; _parser0.skipMsgBody(szPropertyBody);  /*propertyBody*/
	AtfValidator::validateInt(_descr, "propertyBody", szPropertyBody, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserPropertyNotificationForServer
//=================================================================

UPServer::UserPropertyNotificationForServer::UserPropertyNotificationForServer()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::UserPropertyNotificationForServer::UserPropertyNotificationForServer(UserPropertyNotificationForServer&& _o)
	: userIntId(std::move(_o.userIntId))
	, isObserver(std::move(_o.isObserver))
	, properties(std::move(_o.properties))
{
}

UPServer::UserPropertyNotificationForServer& UPServer::UserPropertyNotificationForServer::operator=(UserPropertyNotificationForServer&& _o)
{
	if(this != &_o)
	{
		userIntId = std::move(_o.userIntId);
		isObserver = std::move(_o.isObserver);
		properties = std::move(_o.properties);
	}
	return *this;
}

#endif

void UPServer::UserPropertyNotificationForServer::clear()
{
	userIntId = 0;
	isObserver = false;
	properties.clear();
}

bool UPServer::UserPropertyNotificationForServer::equals(const UserPropertyNotificationForServer& _o) const
{
	return userIntId == _o.userIntId &&
		isObserver == _o.isObserver &&
		properties.equals(_o.properties);
}

const char *UPServer::UserPropertyNotificationForServer::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("isObserver=");
	_buf.appendUint(isObserver);
	_buf.append(',');
	_buf.append("properties=");
	properties.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServer::UserPropertyNotificationForServer::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isObserver", isObserver, _buf);
	properties.toXmlString("properties", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServer::UserPropertyNotificationForServer::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userIntId"))
		{
			userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isObserver"))
		{
			isObserver = (*_value.ptr() == '1');
		}
		else if (_element.equals("properties"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PropertyForServer, 4 > >::FromXmlString(_value, properties)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServer::UserPropertyNotificationForServer::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserPropertyNotificationForServer())) // not empty
	{
		_body.composeUINT32(userIntId);
		_body.composeBOOL(isObserver);
		properties.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void UPServer::UserPropertyNotificationForServer::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(userIntId);
	_parser0.parseBOOL(isObserver);
	properties.parseMsg(_parser0);
}

const char *UPServer::UserPropertyNotificationForServer::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("isObserver", isObserver);
	_jsonstr.compose("properties", properties);
	return _buf.c_str();
}

void UPServer::UserPropertyNotificationForServer::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("isObserver", isObserver);
	_jparser.parseByNameThrow("properties", properties);
}

/* static */ void UPServer::UserPropertyNotificationForServer::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	bool isObserver; _jparser.validateByNameThrow("isObserver", isObserver);
	AtfValidator::validateInt(_descr, "isObserver", isObserver, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PropertyForServer > properties; _jparser.validateByNameThrow("properties", properties);
	AtfValidator::validateInt(_descr, "properties", properties.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::UserPropertyNotificationForServer::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 userIntId; _parser0.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	bool isObserver; _parser0.parseBOOL(isObserver);
	AtfValidator::validateInt(_descr, "isObserver", isObserver, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szProperties = Atf::LAtfVector< PropertyForServer, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("properties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "properties", szProperties, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TableSelfIdentity
//=================================================================

UPServer::TableSelfIdentity::TableSelfIdentity()
{
	clear();
}

void UPServer::TableSelfIdentity::clear()
{
	tableId = 0;
}

bool UPServer::TableSelfIdentity::equals(const TableSelfIdentity& _o) const
{
	return tableId == _o.tableId;
}

const char *UPServer::TableSelfIdentity::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServer::TableSelfIdentity::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServer::TableSelfIdentity::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServer::TableSelfIdentity::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(tableId);
}

void UPServer::TableSelfIdentity::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tableId);
}

const char *UPServer::TableSelfIdentity::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void UPServer::TableSelfIdentity::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId", tableId);
}

/* static */ void UPServer::TableSelfIdentity::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::TableSelfIdentity::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    BlitzSelfIdentity
//=================================================================

UPServer::BlitzSelfIdentity::BlitzSelfIdentity()
{
	clear();
}

void UPServer::BlitzSelfIdentity::clear()
{
	blitzId = 0;
}

bool UPServer::BlitzSelfIdentity::equals(const BlitzSelfIdentity& _o) const
{
	return blitzId == _o.blitzId;
}

const char *UPServer::BlitzSelfIdentity::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("blitzId=");
	_buf.appendUint(blitzId);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServer::BlitzSelfIdentity::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("blitzId", blitzId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServer::BlitzSelfIdentity::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("blitzId"))
		{
			blitzId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServer::BlitzSelfIdentity::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(blitzId);
}

void UPServer::BlitzSelfIdentity::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(blitzId);
}

const char *UPServer::BlitzSelfIdentity::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("blitzId", blitzId);
	return _buf.c_str();
}

void UPServer::BlitzSelfIdentity::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("blitzId", blitzId);
}

/* static */ void UPServer::BlitzSelfIdentity::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 blitzId; _jparser.validateByNameThrow("blitzId", blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::BlitzSelfIdentity::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 blitzId; _parser.parseUINT32(blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    MtlSelfIdentity
//=================================================================

UPServer::MtlSelfIdentity::MtlSelfIdentity()
{
	clear();
}

void UPServer::MtlSelfIdentity::clear()
{
	tournId = 0;
}

bool UPServer::MtlSelfIdentity::equals(const MtlSelfIdentity& _o) const
{
	return tournId == _o.tournId;
}

const char *UPServer::MtlSelfIdentity::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint64(tournId);
	_buf.append('}');
	return _buf.c_str();
}

const char *UPServer::MtlSelfIdentity::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool UPServer::MtlSelfIdentity::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournId"))
		{
			tournId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void UPServer::MtlSelfIdentity::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(tournId);
}

void UPServer::MtlSelfIdentity::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(tournId);
}

const char *UPServer::MtlSelfIdentity::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	return _buf.c_str();
}

void UPServer::MtlSelfIdentity::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
}

/* static */ void UPServer::MtlSelfIdentity::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::MtlSelfIdentity::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT64 tournId; _parser.parseUINT64(tournId);
	AtfValidator::validateUint(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_UPS_Q_USERS_JOIN
//=================================================================

UPServer::Protocol_UPS_Q_USERS_JOIN::Protocol_UPS_Q_USERS_JOIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_USERS_JOIN::Protocol_UPS_Q_USERS_JOIN(Protocol_UPS_Q_USERS_JOIN&& _o)
	: userIntIds(std::move(_o.userIntIds))
{
}

UPServer::Protocol_UPS_Q_USERS_JOIN& UPServer::Protocol_UPS_Q_USERS_JOIN::operator=(Protocol_UPS_Q_USERS_JOIN&& _o)
{
	if(this != &_o)
	{
		userIntIds = std::move(_o.userIntIds);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_USERS_JOIN::clear()
{
	userIntIds.clear();
}

bool UPServer::Protocol_UPS_Q_USERS_JOIN::equals(const Protocol_UPS_Q_USERS_JOIN& _o) const
{
	return userIntIds.equals(_o.userIntIds);
}

bool UPServer::Protocol_UPS_Q_USERS_JOIN::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_Q_USERS_JOIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_Q_USERS_JOIN*)_other));
}

const char *UPServer::Protocol_UPS_Q_USERS_JOIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_USERS_JOIN).append(")");
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_Q_USERS_JOIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_Q_USERS_JOIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_Q_USERS_JOIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	userIntIds.toXmlString("userIntIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_Q_USERS_JOIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, userIntIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_Q_USERS_JOIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userIntIds.composeMsg(_msg, _ignoreJSON);
}

void UPServer::Protocol_UPS_Q_USERS_JOIN::parseMsg(CommMsgParser& _parser)
{
	userIntIds.parseMsg(_parser);
}

const char *UPServer::Protocol_UPS_Q_USERS_JOIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntIds", userIntIds);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_USERS_JOIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntIds", userIntIds);
}

/*static*/ void UPServer::Protocol_UPS_Q_USERS_JOIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_USERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT32 > userIntIds; _jparser.validateByNameThrow("userIntIds", userIntIds);
	AtfValidator::validateInt(_descr, "userIntIds", userIntIds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::Protocol_UPS_Q_USERS_JOIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_USERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIntIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_USERS_JOIN
//=================================================================

UPServer::Protocol_UPS_A_USERS_JOIN::Protocol_UPS_A_USERS_JOIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_USERS_JOIN::Protocol_UPS_A_USERS_JOIN(Protocol_UPS_A_USERS_JOIN&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_USERS_JOIN& UPServer::Protocol_UPS_A_USERS_JOIN::operator=(Protocol_UPS_A_USERS_JOIN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_USERS_JOIN::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_USERS_JOIN::equals(const Protocol_UPS_A_USERS_JOIN& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool UPServer::Protocol_UPS_A_USERS_JOIN::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_A_USERS_JOIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_A_USERS_JOIN*)_other));
}

const char *UPServer::Protocol_UPS_A_USERS_JOIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_USERS_JOIN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_A_USERS_JOIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_A_USERS_JOIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_A_USERS_JOIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_A_USERS_JOIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_A_USERS_JOIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_USERS_JOIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *UPServer::Protocol_UPS_A_USERS_JOIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_USERS_JOIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_USERS_JOIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_USERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_USERS_JOIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_USERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_Q_USERS_LEFT
//=================================================================

UPServer::Protocol_UPS_Q_USERS_LEFT::Protocol_UPS_Q_USERS_LEFT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_USERS_LEFT::Protocol_UPS_Q_USERS_LEFT(Protocol_UPS_Q_USERS_LEFT&& _o)
	: userIntIds(std::move(_o.userIntIds))
{
}

UPServer::Protocol_UPS_Q_USERS_LEFT& UPServer::Protocol_UPS_Q_USERS_LEFT::operator=(Protocol_UPS_Q_USERS_LEFT&& _o)
{
	if(this != &_o)
	{
		userIntIds = std::move(_o.userIntIds);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_USERS_LEFT::clear()
{
	userIntIds.clear();
}

bool UPServer::Protocol_UPS_Q_USERS_LEFT::equals(const Protocol_UPS_Q_USERS_LEFT& _o) const
{
	return userIntIds.equals(_o.userIntIds);
}

bool UPServer::Protocol_UPS_Q_USERS_LEFT::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_Q_USERS_LEFT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_Q_USERS_LEFT*)_other));
}

const char *UPServer::Protocol_UPS_Q_USERS_LEFT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_USERS_LEFT).append(")");
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_Q_USERS_LEFT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_Q_USERS_LEFT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_Q_USERS_LEFT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	userIntIds.toXmlString("userIntIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_Q_USERS_LEFT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, userIntIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_Q_USERS_LEFT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userIntIds.composeMsg(_msg, _ignoreJSON);
}

void UPServer::Protocol_UPS_Q_USERS_LEFT::parseMsg(CommMsgParser& _parser)
{
	userIntIds.parseMsg(_parser);
}

const char *UPServer::Protocol_UPS_Q_USERS_LEFT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntIds", userIntIds);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_USERS_LEFT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntIds", userIntIds);
}

/*static*/ void UPServer::Protocol_UPS_Q_USERS_LEFT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_USERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT32 > userIntIds; _jparser.validateByNameThrow("userIntIds", userIntIds);
	AtfValidator::validateInt(_descr, "userIntIds", userIntIds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::Protocol_UPS_Q_USERS_LEFT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_USERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIntIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_USERS_LEFT
//=================================================================

UPServer::Protocol_UPS_A_USERS_LEFT::Protocol_UPS_A_USERS_LEFT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_USERS_LEFT::Protocol_UPS_A_USERS_LEFT(Protocol_UPS_A_USERS_LEFT&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_USERS_LEFT& UPServer::Protocol_UPS_A_USERS_LEFT::operator=(Protocol_UPS_A_USERS_LEFT&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_USERS_LEFT::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_USERS_LEFT::equals(const Protocol_UPS_A_USERS_LEFT& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool UPServer::Protocol_UPS_A_USERS_LEFT::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_A_USERS_LEFT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_A_USERS_LEFT*)_other));
}

const char *UPServer::Protocol_UPS_A_USERS_LEFT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_USERS_LEFT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_A_USERS_LEFT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_A_USERS_LEFT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_A_USERS_LEFT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_A_USERS_LEFT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_A_USERS_LEFT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_USERS_LEFT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *UPServer::Protocol_UPS_A_USERS_LEFT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_USERS_LEFT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_USERS_LEFT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_USERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_USERS_LEFT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_USERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_Q_SET_PROPERTY
//=================================================================

UPServer::Protocol_UPS_Q_SET_PROPERTY::Protocol_UPS_Q_SET_PROPERTY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_SET_PROPERTY::Protocol_UPS_Q_SET_PROPERTY(Protocol_UPS_Q_SET_PROPERTY&& _o)
	: property(std::move(_o.property))
	, userIntIds(std::move(_o.userIntIds))
{
}

UPServer::Protocol_UPS_Q_SET_PROPERTY& UPServer::Protocol_UPS_Q_SET_PROPERTY::operator=(Protocol_UPS_Q_SET_PROPERTY&& _o)
{
	if(this != &_o)
	{
		property = std::move(_o.property);
		userIntIds = std::move(_o.userIntIds);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_SET_PROPERTY::clear()
{
	property.clear();
	userIntIds.clear();
}

bool UPServer::Protocol_UPS_Q_SET_PROPERTY::equals(const Protocol_UPS_Q_SET_PROPERTY& _o) const
{
	return property.equals(_o.property) &&
		userIntIds.equals(_o.userIntIds);
}

bool UPServer::Protocol_UPS_Q_SET_PROPERTY::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_Q_SET_PROPERTY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_Q_SET_PROPERTY*)_other));
}

const char *UPServer::Protocol_UPS_Q_SET_PROPERTY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_SET_PROPERTY).append(")");
	_buf.append(',');
	_buf.append("property=");
	property.toTraceString(_buf);
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_Q_SET_PROPERTY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_Q_SET_PROPERTY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_Q_SET_PROPERTY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	property.toXmlString("property", _buf);
	userIntIds.toXmlString("userIntIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_Q_SET_PROPERTY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("property"))
			{
				if(!Atf::AtfTempl< UPServerCommon::Property >::FromXmlString(_value, property)) return false;
			}
			else if (_element.equals("userIntIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, userIntIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_Q_SET_PROPERTY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	property.composeMsg(_msg, _ignoreJSON);
	userIntIds.composeMsg(_msg, _ignoreJSON);
}

void UPServer::Protocol_UPS_Q_SET_PROPERTY::parseMsg(CommMsgParser& _parser)
{
	property.parseMsg(_parser);
	userIntIds.parseMsg(_parser);
}

const char *UPServer::Protocol_UPS_Q_SET_PROPERTY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("property", property);
	_jsonstr.compose("userIntIds", userIntIds);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_SET_PROPERTY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("property", property);
	_jparser.parseByNameThrow("userIntIds", userIntIds);
}

/*static*/ void UPServer::Protocol_UPS_Q_SET_PROPERTY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_SET_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UPServerCommon::Property property; _jparser.validateByNameThrow("property", property);
	Atf::AtfVectorBase< UINT32 > userIntIds; _jparser.validateByNameThrow("userIntIds", userIntIds);
	AtfValidator::validateInt(_descr, "userIntIds", userIntIds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::Protocol_UPS_Q_SET_PROPERTY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_SET_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	UPServerCommon::Property::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("property"), _fieldsWithUnparsedContent);
	int szUserIntIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_SET_PROPERTY
//=================================================================

UPServer::Protocol_UPS_A_SET_PROPERTY::Protocol_UPS_A_SET_PROPERTY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_SET_PROPERTY::Protocol_UPS_A_SET_PROPERTY(Protocol_UPS_A_SET_PROPERTY&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_SET_PROPERTY& UPServer::Protocol_UPS_A_SET_PROPERTY::operator=(Protocol_UPS_A_SET_PROPERTY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_SET_PROPERTY::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_SET_PROPERTY::equals(const Protocol_UPS_A_SET_PROPERTY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool UPServer::Protocol_UPS_A_SET_PROPERTY::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_A_SET_PROPERTY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_A_SET_PROPERTY*)_other));
}

const char *UPServer::Protocol_UPS_A_SET_PROPERTY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_SET_PROPERTY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_A_SET_PROPERTY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_A_SET_PROPERTY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_A_SET_PROPERTY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_A_SET_PROPERTY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_A_SET_PROPERTY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_SET_PROPERTY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *UPServer::Protocol_UPS_A_SET_PROPERTY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_SET_PROPERTY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_SET_PROPERTY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_SET_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_SET_PROPERTY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_SET_PROPERTY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_NOTIFY_PROPERTY_UPDATED
//=================================================================

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::Protocol_UPS_NOTIFY_PROPERTY_UPDATED()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::Protocol_UPS_NOTIFY_PROPERTY_UPDATED(Protocol_UPS_NOTIFY_PROPERTY_UPDATED&& _o)
	: userPropertyNotification(std::move(_o.userPropertyNotification))
{
}

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED& UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::operator=(Protocol_UPS_NOTIFY_PROPERTY_UPDATED&& _o)
{
	if(this != &_o)
	{
		userPropertyNotification = std::move(_o.userPropertyNotification);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::clear()
{
	userPropertyNotification.clear();
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::equals(const Protocol_UPS_NOTIFY_PROPERTY_UPDATED& _o) const
{
	return userPropertyNotification.equals(_o.userPropertyNotification);
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_NOTIFY_PROPERTY_UPDATED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_NOTIFY_PROPERTY_UPDATED*)_other));
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_NOTIFY_PROPERTY_UPDATED).append(")");
	_buf.append(',');
	_buf.append("userPropertyNotification=");
	userPropertyNotification.toTraceString(_buf);
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_NOTIFY_PROPERTY_UPDATED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	userPropertyNotification.toXmlString("userPropertyNotification", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userPropertyNotification"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserPropertyNotification, 4 > >::FromXmlString(_value, userPropertyNotification)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userPropertyNotification.composeMsg(_msg, _ignoreJSON);
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::parseMsg(CommMsgParser& _parser)
{
	userPropertyNotification.parseMsg(_parser);
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userPropertyNotification", userPropertyNotification);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userPropertyNotification", userPropertyNotification);
}

/*static*/ void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_NOTIFY_PROPERTY_UPDATED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UserPropertyNotification > userPropertyNotification; _jparser.validateByNameThrow("userPropertyNotification", userPropertyNotification);
	AtfValidator::validateInt(_descr, "userPropertyNotification", userPropertyNotification.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_NOTIFY_PROPERTY_UPDATED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserPropertyNotification = Atf::LAtfVector< UserPropertyNotification, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userPropertyNotification"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userPropertyNotification", szUserPropertyNotification, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER
//=================================================================

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER(Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER&& _o)
	: userPropertyNotification(std::move(_o.userPropertyNotification))
{
}

UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER& UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::operator=(Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER&& _o)
{
	if(this != &_o)
	{
		userPropertyNotification = std::move(_o.userPropertyNotification);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::clear()
{
	userPropertyNotification.clear();
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::equals(const Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER& _o) const
{
	return userPropertyNotification.equals(_o.userPropertyNotification);
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_NOTIFY_PROPERTY_UPDATED_SERVER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER*)_other));
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_NOTIFY_PROPERTY_UPDATED_SERVER).append(")");
	_buf.append(',');
	_buf.append("userPropertyNotification=");
	userPropertyNotification.toTraceString(_buf);
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_NOTIFY_PROPERTY_UPDATED_SERVER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	userPropertyNotification.toXmlString("userPropertyNotification", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userPropertyNotification"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserPropertyNotificationForServer, 4 > >::FromXmlString(_value, userPropertyNotification)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userPropertyNotification.composeMsg(_msg, _ignoreJSON);
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::parseMsg(CommMsgParser& _parser)
{
	userPropertyNotification.parseMsg(_parser);
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userPropertyNotification", userPropertyNotification);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userPropertyNotification", userPropertyNotification);
}

/*static*/ void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_NOTIFY_PROPERTY_UPDATED_SERVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UserPropertyNotificationForServer > userPropertyNotification; _jparser.validateByNameThrow("userPropertyNotification", userPropertyNotification);
	AtfValidator::validateInt(_descr, "userPropertyNotification", userPropertyNotification.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_NOTIFY_PROPERTY_UPDATED_SERVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserPropertyNotification = Atf::LAtfVector< UserPropertyNotificationForServer, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userPropertyNotification"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userPropertyNotification", szUserPropertyNotification, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER
//=================================================================

UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER(Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER&& _o)
	: blitzId(std::move(_o.blitzId))
	, tableId(std::move(_o.tableId))
	, userIntId(std::move(_o.userIntId))
	, entryId(std::move(_o.entryId))
	, notifTypeId(std::move(_o.notifTypeId))
	, notifSubTypeId(std::move(_o.notifSubTypeId))
	, notifMsg(std::move(_o.notifMsg))
{
}

UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER& UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::operator=(Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER&& _o)
{
	if(this != &_o)
	{
		blitzId = std::move(_o.blitzId);
		tableId = std::move(_o.tableId);
		userIntId = std::move(_o.userIntId);
		entryId = std::move(_o.entryId);
		notifTypeId = std::move(_o.notifTypeId);
		notifSubTypeId = std::move(_o.notifSubTypeId);
		notifMsg = std::move(_o.notifMsg);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::clear()
{
	blitzId = 0;
	tableId = 0;
	userIntId = 0;
	entryId = 0;
	notifTypeId = 0;
	notifSubTypeId = 0;
	notifMsg.clear();
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::equals(const Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER& _o) const
{
	return blitzId == _o.blitzId &&
		tableId == _o.tableId &&
		userIntId == _o.userIntId &&
		entryId == _o.entryId &&
		notifTypeId == _o.notifTypeId &&
		notifSubTypeId == _o.notifSubTypeId &&
		notifMsg.equals(_o.notifMsg);
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER*)_other));
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER).append(")");
	_buf.append(',');
	_buf.append("blitzId=");
	_buf.appendUint(blitzId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("notifTypeId=");
	_buf.appendUint(notifTypeId);
	_buf.append(',');
	_buf.append("notifSubTypeId=");
	_buf.appendUint(notifSubTypeId);
	_buf.append(',');
	_buf.append("notifMsg=");
	notifMsg.toTraceString(_buf);
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("blitzId", blitzId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("notifTypeId", notifTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("notifSubTypeId", notifSubTypeId, _buf);
	notifMsg.toXmlString("notifMsg", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("blitzId"))
			{
				blitzId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notifTypeId"))
			{
				notifTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notifSubTypeId"))
			{
				notifSubTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notifMsg"))
			{
				if(!Atf::AtfTempl< Atf::MoveableMsgBody >::FromXmlString(_value, notifMsg)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(blitzId);
	_msg.composeUINT64(tableId);
	_msg.composeUINT32(userIntId);
	_msg.composeUINT32(entryId);
	_msg.composeUINT32(notifTypeId);
	_msg.composeUINT32(notifSubTypeId);
	notifMsg.composeMsg(_msg, _ignoreJSON);
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(blitzId);
	_parser.parseUINT64(tableId);
	_parser.parseUINT32(userIntId);
	_parser.parseUINT32(entryId);
	_parser.parseUINT32(notifTypeId);
	_parser.parseUINT32(notifSubTypeId);
	notifMsg.parseMsg(_parser);
}

const char *UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("blitzId", blitzId);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("notifTypeId", notifTypeId);
	_jsonstr.compose("notifSubTypeId", notifSubTypeId);
	_jsonstr.compose("notifMsg", notifMsg);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("blitzId", blitzId);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("notifTypeId", notifTypeId);
	_jparser.parseByNameThrow("notifSubTypeId", notifSubTypeId);
	_jparser.parseByNameThrow("notifMsg", notifMsg);
}

/*static*/ void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 blitzId; _jparser.validateByNameThrow("blitzId", blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT32 notifTypeId; _jparser.validateByNameThrow("notifTypeId", notifTypeId);
	AtfValidator::validateInt(_descr, "notifTypeId", notifTypeId, _checker, __FILE__, __LINE__);
	UINT32 notifSubTypeId; _jparser.validateByNameThrow("notifSubTypeId", notifSubTypeId);
	AtfValidator::validateInt(_descr, "notifSubTypeId", notifSubTypeId, _checker, __FILE__, __LINE__);
	Atf::MoveableMsgBody notifMsg; _jparser.validateByNameThrow("notifMsg", notifMsg);
	AtfValidator::validateInt(_descr, "notifMsg", notifMsg._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 blitzId; _parser.parseUINT32(blitzId);
	AtfValidator::validateInt(_descr, "blitzId", blitzId, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT32 notifTypeId; _parser.parseUINT32(notifTypeId);
	AtfValidator::validateInt(_descr, "notifTypeId", notifTypeId, _checker, __FILE__, __LINE__);
	UINT32 notifSubTypeId; _parser.parseUINT32(notifSubTypeId);
	AtfValidator::validateInt(_descr, "notifSubTypeId", notifSubTypeId, _checker, __FILE__, __LINE__);
	Atf::MoveableMsgBody notifMsg; notifMsg.parseMsg(_parser);
	AtfValidator::validateInt(_descr, "notifMsg", notifMsg._size(), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_Q_OBSERVERS_JOIN
//=================================================================

UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::Protocol_UPS_Q_OBSERVERS_JOIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::Protocol_UPS_Q_OBSERVERS_JOIN(Protocol_UPS_Q_OBSERVERS_JOIN&& _o)
	: userIntIds(std::move(_o.userIntIds))
	, gameId(std::move(_o.gameId))
	, entryType(std::move(_o.entryType))
{
}

UPServer::Protocol_UPS_Q_OBSERVERS_JOIN& UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::operator=(Protocol_UPS_Q_OBSERVERS_JOIN&& _o)
{
	if(this != &_o)
	{
		userIntIds = std::move(_o.userIntIds);
		gameId = std::move(_o.gameId);
		entryType = std::move(_o.entryType);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::clear()
{
	userIntIds.clear();
	gameId = 0;
	entryType = 0;
}

bool UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::equals(const Protocol_UPS_Q_OBSERVERS_JOIN& _o) const
{
	return userIntIds.equals(_o.userIntIds) &&
		gameId == _o.gameId &&
		entryType == _o.entryType;
}

bool UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_Q_OBSERVERS_JOIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_Q_OBSERVERS_JOIN*)_other));
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_OBSERVERS_JOIN).append(")");
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryType=");
	_buf.appendInt(entryType);
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_Q_OBSERVERS_JOIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	userIntIds.toXmlString("userIntIds", _buf);
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryType", entryType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, userIntIds)) return false;
			}
			else if (_element.equals("gameId"))
			{
				gameId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("entryType"))
			{
				entryType = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userIntIds.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT64(gameId);
	_msg.composeINT8(entryType);
}

void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::parseMsg(CommMsgParser& _parser)
{
	userIntIds.parseMsg(_parser);
	_parser.parseUINT64(gameId);
	_parser.parseINT8(entryType);
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntIds", userIntIds);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("entryType", entryType);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntIds", userIntIds);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("entryType", entryType);
}

/*static*/ void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_OBSERVERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT32 > userIntIds; _jparser.validateByNameThrow("userIntIds", userIntIds);
	AtfValidator::validateInt(_descr, "userIntIds", userIntIds.size(), _checker, __FILE__, __LINE__);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	INT8 entryType; _jparser.validateByNameThrow("entryType", entryType);
	AtfValidator::validateInt(_descr, "entryType", entryType, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::Protocol_UPS_Q_OBSERVERS_JOIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_OBSERVERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIntIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	INT8 entryType; _parser.parseINT8(entryType);
	AtfValidator::validateInt(_descr, "entryType", entryType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_OBSERVERS_JOIN
//=================================================================

UPServer::Protocol_UPS_A_OBSERVERS_JOIN::Protocol_UPS_A_OBSERVERS_JOIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_OBSERVERS_JOIN::Protocol_UPS_A_OBSERVERS_JOIN(Protocol_UPS_A_OBSERVERS_JOIN&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_OBSERVERS_JOIN& UPServer::Protocol_UPS_A_OBSERVERS_JOIN::operator=(Protocol_UPS_A_OBSERVERS_JOIN&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_OBSERVERS_JOIN::equals(const Protocol_UPS_A_OBSERVERS_JOIN& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool UPServer::Protocol_UPS_A_OBSERVERS_JOIN::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_A_OBSERVERS_JOIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_A_OBSERVERS_JOIN*)_other));
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_JOIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_OBSERVERS_JOIN).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_JOIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_JOIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_A_OBSERVERS_JOIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_A_OBSERVERS_JOIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_JOIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_OBSERVERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_OBSERVERS_JOIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_OBSERVERS_JOIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_Q_OBSERVERS_LEFT
//=================================================================

UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::Protocol_UPS_Q_OBSERVERS_LEFT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::Protocol_UPS_Q_OBSERVERS_LEFT(Protocol_UPS_Q_OBSERVERS_LEFT&& _o)
	: userIntIds(std::move(_o.userIntIds))
	, gameId(std::move(_o.gameId))
	, entryType(std::move(_o.entryType))
{
}

UPServer::Protocol_UPS_Q_OBSERVERS_LEFT& UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::operator=(Protocol_UPS_Q_OBSERVERS_LEFT&& _o)
{
	if(this != &_o)
	{
		userIntIds = std::move(_o.userIntIds);
		gameId = std::move(_o.gameId);
		entryType = std::move(_o.entryType);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::clear()
{
	userIntIds.clear();
	gameId = 0;
	entryType = 0;
}

bool UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::equals(const Protocol_UPS_Q_OBSERVERS_LEFT& _o) const
{
	return userIntIds.equals(_o.userIntIds) &&
		gameId == _o.gameId &&
		entryType == _o.entryType;
}

bool UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_Q_OBSERVERS_LEFT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_Q_OBSERVERS_LEFT*)_other));
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_Q_OBSERVERS_LEFT).append(")");
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryType=");
	_buf.appendInt(entryType);
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_Q_OBSERVERS_LEFT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	userIntIds.toXmlString("userIntIds", _buf);
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryType", entryType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, userIntIds)) return false;
			}
			else if (_element.equals("gameId"))
			{
				gameId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("entryType"))
			{
				entryType = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userIntIds.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT64(gameId);
	_msg.composeINT8(entryType);
}

void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::parseMsg(CommMsgParser& _parser)
{
	userIntIds.parseMsg(_parser);
	_parser.parseUINT64(gameId);
	_parser.parseINT8(entryType);
}

const char *UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntIds", userIntIds);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("entryType", entryType);
	return _buf.c_str();
}

void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntIds", userIntIds);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("entryType", entryType);
}

/*static*/ void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_OBSERVERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT32 > userIntIds; _jparser.validateByNameThrow("userIntIds", userIntIds);
	AtfValidator::validateInt(_descr, "userIntIds", userIntIds.size(), _checker, __FILE__, __LINE__);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	INT8 entryType; _jparser.validateByNameThrow("entryType", entryType);
	AtfValidator::validateInt(_descr, "entryType", entryType, _checker, __FILE__, __LINE__);
}

/*static*/ void UPServer::Protocol_UPS_Q_OBSERVERS_LEFT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_Q_OBSERVERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIntIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "userIntIds", szUserIntIds, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	INT8 entryType; _parser.parseINT8(entryType);
	AtfValidator::validateInt(_descr, "entryType", entryType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_UPS_A_OBSERVERS_LEFT
//=================================================================

UPServer::Protocol_UPS_A_OBSERVERS_LEFT::Protocol_UPS_A_OBSERVERS_LEFT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

UPServer::Protocol_UPS_A_OBSERVERS_LEFT::Protocol_UPS_A_OBSERVERS_LEFT(Protocol_UPS_A_OBSERVERS_LEFT&& _o)
	: errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

UPServer::Protocol_UPS_A_OBSERVERS_LEFT& UPServer::Protocol_UPS_A_OBSERVERS_LEFT::operator=(Protocol_UPS_A_OBSERVERS_LEFT&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::clear()
{
	errCode = 0;
	errStr.clear();
}

bool UPServer::Protocol_UPS_A_OBSERVERS_LEFT::equals(const Protocol_UPS_A_OBSERVERS_LEFT& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool UPServer::Protocol_UPS_A_OBSERVERS_LEFT::equals(Atf::MessageProtocol* _other) const
{
	if (UPS_A_OBSERVERS_LEFT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_UPS_A_OBSERVERS_LEFT*)_other));
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_LEFT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(UPS_A_OBSERVERS_LEFT).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_LEFT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_LEFT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(UPS_A_OBSERVERS_LEFT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool UPServer::Protocol_UPS_A_OBSERVERS_LEFT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *UPServer::Protocol_UPS_A_OBSERVERS_LEFT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_OBSERVERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void UPServer::Protocol_UPS_A_OBSERVERS_LEFT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "UPS_A_OBSERVERS_LEFT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* UPServer::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case UPS_A_OBSERVERS_JOIN: _obj = new Protocol_UPS_A_OBSERVERS_JOIN(); break;
			case UPS_A_OBSERVERS_LEFT: _obj = new Protocol_UPS_A_OBSERVERS_LEFT(); break;
			case UPS_A_SET_PROPERTY: _obj = new Protocol_UPS_A_SET_PROPERTY(); break;
			case UPS_A_USERS_JOIN: _obj = new Protocol_UPS_A_USERS_JOIN(); break;
			case UPS_A_USERS_LEFT: _obj = new Protocol_UPS_A_USERS_LEFT(); break;
			case UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER: _obj = new Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER(); break;
			case UPS_NOTIFY_PROPERTY_UPDATED: _obj = new Protocol_UPS_NOTIFY_PROPERTY_UPDATED(); break;
			case UPS_NOTIFY_PROPERTY_UPDATED_SERVER: _obj = new Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER(); break;
			case UPS_Q_OBSERVERS_JOIN: _obj = new Protocol_UPS_Q_OBSERVERS_JOIN(); break;
			case UPS_Q_OBSERVERS_LEFT: _obj = new Protocol_UPS_Q_OBSERVERS_LEFT(); break;
			case UPS_Q_SET_PROPERTY: _obj = new Protocol_UPS_Q_SET_PROPERTY(); break;
			case UPS_Q_USERS_JOIN: _obj = new Protocol_UPS_Q_USERS_JOIN(); break;
			case UPS_Q_USERS_LEFT: _obj = new Protocol_UPS_Q_USERS_LEFT(); break;
		}
	}
	
	return _obj;
}

/* static */ bool UPServer::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case UPS_A_OBSERVERS_JOIN: Protocol_UPS_A_OBSERVERS_JOIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_OBSERVERS_LEFT: Protocol_UPS_A_OBSERVERS_LEFT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_SET_PROPERTY: Protocol_UPS_A_SET_PROPERTY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_USERS_JOIN: Protocol_UPS_A_USERS_JOIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_USERS_LEFT: Protocol_UPS_A_USERS_LEFT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER: Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_NOTIFY_PROPERTY_UPDATED: Protocol_UPS_NOTIFY_PROPERTY_UPDATED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_NOTIFY_PROPERTY_UPDATED_SERVER: Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_OBSERVERS_JOIN: Protocol_UPS_Q_OBSERVERS_JOIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_OBSERVERS_LEFT: Protocol_UPS_Q_OBSERVERS_LEFT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_SET_PROPERTY: Protocol_UPS_Q_SET_PROPERTY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_USERS_JOIN: Protocol_UPS_Q_USERS_JOIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_USERS_LEFT: Protocol_UPS_Q_USERS_LEFT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool UPServer::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case UPS_A_OBSERVERS_JOIN: Protocol_UPS_A_OBSERVERS_JOIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_OBSERVERS_LEFT: Protocol_UPS_A_OBSERVERS_LEFT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_SET_PROPERTY: Protocol_UPS_A_SET_PROPERTY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_USERS_JOIN: Protocol_UPS_A_USERS_JOIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_A_USERS_LEFT: Protocol_UPS_A_USERS_LEFT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER: Protocol_UPS_NOTIFY_PROPERTY_ONE_TIME_NOTIFICATION_SERVER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_NOTIFY_PROPERTY_UPDATED: Protocol_UPS_NOTIFY_PROPERTY_UPDATED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_NOTIFY_PROPERTY_UPDATED_SERVER: Protocol_UPS_NOTIFY_PROPERTY_UPDATED_SERVER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_OBSERVERS_JOIN: Protocol_UPS_Q_OBSERVERS_JOIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_OBSERVERS_LEFT: Protocol_UPS_Q_OBSERVERS_LEFT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_SET_PROPERTY: Protocol_UPS_Q_SET_PROPERTY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_USERS_JOIN: Protocol_UPS_Q_USERS_JOIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case UPS_Q_USERS_LEFT: Protocol_UPS_Q_USERS_LEFT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

