/**
 * minigamesclientprot_thin.h
 *
 * This file was auto-generated from minigamesclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin minigamesclientprot.txt
 */

#ifndef ATF_PROTOCOL_DEFFILE_MINIGAMESCLIENTPROT_THIN_H
#define ATF_PROTOCOL_DEFFILE_MINIGAMESCLIENTPROT_THIN_H

//------------------------------------------------------------------------------
//	Mini Game Lobby <-> Client Protocol
//------------------------------------------------------------------------------
//
//	Copyright (c) 2001-2016 PYR Software Ltd. All rights reserved. This document
//	is for the use of licensed users only and is subject to the terms and
//	conditions of the accompanying and/or applicable license between you and
//	PYR Software Ltd, including without limitation those terms and conditions
//	prohibiting unauthorized translation, reverse engineering, decompilation,
//	disassembly, and other inappropriate use of any software provided. Any
//	unauthorized use, copying, modification, distribution, publication or
//	disclosure of information is a violation of copyright laws. No reproduction
//	in whole or in part of this document may be made without express written
//	consent of PYR Software Ltd.
//
//
//------------------------------------------------------------------------------

#include "ThinAtfUserDefStructs.h"
#include "ppcontainer.h"
#include "minigames/minigamescommonprot.h"
#include "pyrtime.h"
#include "sitemasks.h"
#include "licensemask.h"

#include "atfgenerated/brandimgs_thin.h"
#include "cvl/cvlclientprotocol_thin.h"


//------------------------------------------------------------------------------

//------------------------------------------------------------------------------

// !!! WARNING !!! If you modify this message, please let testautomation team know.
#define MINIGAME_MSG_ACTIVE_GAMES				1001 	// client -> Mini Game lobby
#define MINIGAME_MSG_ACTIVE_GAMES_REPLY			1002 	// Mini Game lobby -> client
// !!! WARNING !!! If you modify this message, please let testautomation team know.
#define MINIGAME_MSG_START_GAME					1003 	// client -> server
#define MINIGAME_MSG_START_GAME_REPLY			1004 	// server -> client
// !!! WARNING !!! If you modify this message, please let testautomation team know.
#define MINIGAME_MSG_PLAY_NEXT_ROUND			1005 	// client -> Mini Game lobby
// !!! WARNING !!! If you modify this message, please let testautomation team know.
#define MINIGAME_MSG_GAME_STATE					1006 	// client -> Mini Game lobby
#define MINIGAME_MSG_GAME_STATE_REPLY			1007 	// Mini Game lobby -> client
#define MINIGAME_MSG_SERVER_RESTARTING			1008 	// Mini Game lobby -> client
#define SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER	1009 	// client -> MGLobby
#define SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER	1010 	// MGLobby -> client
#define SIDEGAME_MSG_START_GAME						1011 	// client -> MGLobby		// TO BE DEPRECATED
#define SIDEGAME_MSG_START_GAME_REPLY				1012 	// MGLobby -> client
// request state for all current sidegame plays
#define SIDEGAME_MSG_ACTIVE_GAMES					1013 	// client -> MGLobby
#define SIDEGAME_MSG_ACTIVE_GAMES_REPLY				1014 	// MGLobby -> client
// request state for a specific play
// also used for push notifications of updates to a specific play
#define SIDEGAME_MSG_GAME_STATE						1015 	// client -> MGLobby
#define SIDEGAME_MSG_GAME_STATE_REPLY				1016 	// MGLobby -> client
// request details of max games reached limits
// also used for push notifications when a player hits this limit
#define SIDEGAME_MSG_MAX_GAMES_REACHED				1017 	// client -> MGLobby
#define SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY		1018 	// MGLobby -> client
// claim a prize when a sidegame is in the prize claimable state
#define SIDEGAME_MSG_CLAIM_PRIZE					1019 	// client -> MGLobby
#define SIDEGAME_MSG_CLAIM_PRIZE_REPLY				1020 	// MGLobby -> client
// request a snapshot of the game definition publication node
#define SIDEGAME_MSG_GAME_DEF						1021 	// client -> MGLobby
#define SIDEGAME_MSG_GAME_DEF_REPLY					1022 	// MGLobby -> client
// request state for historic sidegame plays
#define SIDEGAME_MSG_HISTORIC_GAMES                 1023 	// client -> MGLobby
#define SIDEGAME_MSG_HISTORIC_GAMES_REPLY           1024 	// MGLobby -> client
// forfeit a current sidegame play
#define SIDEGAME_MSG_FORFEIT						1025 	// client -> MGLobby
#define SIDEGAME_MSG_FORFEIT_REPLY					1026 	// MGLobby -> client
#define SIDEGAME_MSG_TRIGGER_ANIMATION				1027 	// MGLobby -> client
#define MINIGAME_MSG_TICKET_LOOKUP					1028 	// client -> MGLobby
#define MINIGAME_MSG_TICKET_LOOKUP_REPLY			1029 	// MGLobby -> client
#define SIDEGAME_MSG_GET_TICKET_BALANCE				1030 	// client -> MGLobby
#define SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY		1031 	// MGLobby -> client
#define MINIGAME_MSG_GET_TICKETS					1032 	// client -> MGLobby
#define MINIGAME_MSG_GET_TICKETS_REPLY				1033 	// MGLobby -> client
#define SIDEGAME_MSG_GAME_DEF_LOCALIZED				1034 	// client -> MGLobby
#define SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY		1035 	// MGLobby -> client
#define SIDEGAME_MSG_START_GAME_NEW					1036 	// client -> MGLobby		// TO BE RENAMED SIDEGAME_MSG_START_GAME
#define SIDEGAME_MSG_GET_STARSREWARDS_BAR			1037 	// client -> MGLobby
#define SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY		1038 	// MGLobby -> client
#define SIDEGAME_MSG_SKIP_DELAY						1039 	// client -> MGLobby		// no reply necessary
#define MINIGAME_MSG_GET_STACKED_TICKETS			1040 	// client -> MGLobby
#define MINIGAME_MSG_GET_STACKED_TICKETS_REPLY		1041 	// MGLobby -> client
#define SIDEGAME_MSG_GET_RING_SESSIONID				1042 	// client -> MGLobby
#define SIDEGAME_MSG_GET_RING_SESSIONID_REPLY		1043 	// MGLobby -> client
#define SIDEGAME_MSG_CANCEL_PLAY					1044 	// client -> MGLobby
#define SIDEGAME_MSG_CANCEL_PLAY_REPLY				1045 	// MGLobby -> client
#define SIDEGAME_MSG_START_AUTOPLAY					1046 	// client -> MGLobby
#define SIDEGAME_MSG_START_AUTOPLAY_REPLY			1047 	// MGLobby -> client
#define SIDEGAME_MSG_STOP_AUTOPLAY					1048 	// client -> MGLobby
#define SIDEGAME_MSG_STOP_AUTOPLAY_REPLY			1049 	// MGLobby -> client
#define SIDEGAME_MSG_AUTOPLAY_STATE					1050 	// client -> MGLobby
#define SIDEGAME_MSG_AUTOPLAY_STATE_REPLY			1051 	// MGLobby -> client
#define SIDEGAME_MSG_REPLAY_AUTOPLAY				1052 	// client -> MGLobby
#define SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY			1053 	// MGLobby -> client
#define SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY			1054 	// client -> MGLobby
#define SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY	1055 	// MGLobby -> client

// PYR-120600
#define MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW		1058 	// LobbyEtc -> MGLobby
#define MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY	1059 	// MGLobby -> LobbyEtc

namespace MiniGameClient
{
	class ProtocolFactory
	{
	public:
		static bool validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded);
	};


	//------------------------------------------------------------------------------

	enum TheDealStates
	{
		TheDealState_Done       = 0, 	// game instance is finished, prizes have been paid (if applicable)
		TheDealState_InProgress = 1, 	// game instance result has been determined, prizes not yet paid
	};

	//------------------------------------------------------------------------------

	enum RandomDrawGameStates
	{
		RandomDrawGameState_Done       = 0, 	// game instance is finished
		RandomDrawGameState_InProgress = 1, 	// game instance is in progress
		RandomDrawGameState_Pending    = 2, 	// game instance is waiting for players
	};

	enum TheDealJackpotStates
	{
		TheDealJackpotState_Done       = RandomDrawGameState_Done,       	// game instance is finished, prizes have been paid
		TheDealJackpotState_InProgress = RandomDrawGameState_InProgress, 	// result determined, prizes not yet paid
		TheDealJackpotState_Pending    = RandomDrawGameState_Pending,    	// waiting for players (client show countdown timer), result not yet determined
	};

	enum FixedPrizeDrawStates
	{
		FixedPrizeDrawState_Done       = RandomDrawGameState_Done,       	// game instance is finished, prizes have been paid
		FixedPrizeDrawState_InProgress = RandomDrawGameState_InProgress, 	// draw was done, result determined, prizes are assigned but not yet paid
		FixedPrizeDrawState_Pending    = RandomDrawGameState_Pending,    	// waiting for the draw time, accepting new players
	};

	//------------------------------------------------------------------------------

	enum CardMatchHandStates
	{
		CardMatchHand_Eligible     = 0, 	// card match hand eligible
		CardMatchHand_InEligible   = 1,		// card match hand ineligble
		CardMatchHand_NonQualified = 2,		// card match hand non-qualified
	};

	//------------------------------------------------------------------------------

	enum ChestGameStates
	{
		ChestGameState_Done       = 0, 	// game instance is finished, prizes have been paid (if applicable)
		ChestGameState_InProgress = 1, 	// game instance result has been determined, prizes not yet paid
	};

	//------------------------------------------------------------------------------

	enum PokerSideGameHandStates
	{
		PokerSideGameHand_Eligible     = 0, 	// card match hand eligible
		PokerSideGameHand_InEligible   = 1,		// card match hand ineligble
		PokerSideGameHand_NonQualified = 2,		// card match hand non-qualified
	};

	//------------------------------------------------------------------------------

	//------------------------------------------------------------------------------

	struct NameValuePair
	{
		// M(ss) - M(name,value)
		PString name;
		PString value;

		NameValuePair();
		void clear();
		bool equals(const NameValuePair&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		NameValuePair(NameValuePair&&);
		NameValuePair& operator=(NameValuePair&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		NameValuePair(const NameValuePair&) = default;
		NameValuePair& operator=(const NameValuePair&) = default;
#endif
#endif
	};

	struct MiniGamePrize
	{
		// M(4Is8bIss4<M(ss)>sI) - M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)
		INT32 prizeType;	// see enum PrizeType
		I18nPString prizeName;	// human readable
		PString currency;
		INT64 amount;
		bool isTopPrize;	// potential special client behaviour for "top prize" prize(s)
		I18nPString prizeDescription;
		PString imageURLPrefix;	// URL prefix for client resources associated with this prize
		PString assetName;	// key for client to lookup image/animation asset in local library
		ThinAtf::LAtfVector< NameValuePair, 4 > prizeProperties;	//vector of prize properties from MG_CATALOG_PRIZE_PROPERTIES, only applicable to catalog prizes
		PString clickToLaunchURL;	// destination URL for action button
		I18nPString clickToLaunchButtonText;	// description of the C2L button behaviour

		MiniGamePrize();
		void clear();
		bool equals(const MiniGamePrize&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGamePrize(MiniGamePrize&&);
		MiniGamePrize& operator=(MiniGamePrize&&);
	private:
		MiniGamePrize(const MiniGamePrize&);  // prohibit
		MiniGamePrize& operator=(const MiniGamePrize&);  // prohibit
#endif
	};

	struct MiniGamePrizeLocalized
	{
		// M(4ss8bsss4<M(ss)>ss) - M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)
		INT32 prizeType;	// see enum PrizeType
		PString prizeName;	// human readable
		PString currency;
		INT64 amount;
		bool isTopPrize;	// potential special client behaviour for "top prize" prize(s)
		PString prizeDescription;
		PString imageURLPrefix;	// URL prefix for client resources associated with this prize
		PString assetName;	// key for client to lookup image/animation asset in local library
		ThinAtf::LAtfVector< NameValuePair, 4 > prizeProperties;	//vector of prize properties from MG_CATALOG_PRIZE_PROPERTIES, only applicable to catalog prizes
		PString clickToLaunchURL;	// destination URL for action button
		PString clickToLaunchButtonText;	// description of the C2L button behaviour

		MiniGamePrizeLocalized();
		void clear();
		bool equals(const MiniGamePrizeLocalized&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGamePrizeLocalized(MiniGamePrizeLocalized&&);
		MiniGamePrizeLocalized& operator=(MiniGamePrizeLocalized&&);
	private:
		MiniGamePrizeLocalized(const MiniGamePrizeLocalized&);  // prohibit
		MiniGamePrizeLocalized& operator=(const MiniGamePrizeLocalized&);  // prohibit
#endif
	};

	//------------------------------------------------------------------------------

	struct MiniGamePrizeBucket
	{
		// M(IM(4<M(4Is8bIss4<M(ss)>sI)>)4) - M(prizeBucketName,M(numPrizes<M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)>),bucketOdds)
		I18nPString prizeBucketName;	// human readable
		ThinAtf::LAtfVector< MiniGamePrize , 4 > prizes;

		INT32 bucketOdds;	// in hundredths of a percent, i.e. 10000 is 100%. populated if game definition specifies that this should be published, else all zeroes.

		MiniGamePrizeBucket();
		void clear();
		bool equals(const MiniGamePrizeBucket&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGamePrizeBucket(MiniGamePrizeBucket&&);
		MiniGamePrizeBucket& operator=(MiniGamePrizeBucket&&);
	private:
		MiniGamePrizeBucket(const MiniGamePrizeBucket&);  // prohibit
		MiniGamePrizeBucket& operator=(const MiniGamePrizeBucket&);  // prohibit
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	struct MiniGamePrizeBucketLocalized
	{
		// M(sM(4<M(4ss8bsss4<M(ss)>ss)>)4) - M(prizeBucketName,M(numPrizes<M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)>),bucketOdds)
		PString prizeBucketName;	// human readable
		ThinAtf::LAtfVector< MiniGamePrizeLocalized , 4 > prizes;

		INT32 bucketOdds;	// in hundredths of a percent, i.e. 10000 is 100%. populated if game definition specifies that this should be published, else all zeroes.

		MiniGamePrizeBucketLocalized();
		void clear();
		bool equals(const MiniGamePrizeBucketLocalized&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGamePrizeBucketLocalized(MiniGamePrizeBucketLocalized&&);
		MiniGamePrizeBucketLocalized& operator=(MiniGamePrizeBucketLocalized&&);
	private:
		MiniGamePrizeBucketLocalized(const MiniGamePrizeBucketLocalized&);  // prohibit
		MiniGamePrizeBucketLocalized& operator=(const MiniGamePrizeBucketLocalized&);  // prohibit
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	//------------------------------------------------------------------------------

	struct MiniGameBuyIn
	{
		// M(4s8) - M(buyInType,currency,amount)
		INT32 buyInType;	// see enum BuyInType
		PString currency;
		INT64 amount;

		MiniGameBuyIn();
		void clear();
		bool equals(const MiniGameBuyIn&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGameBuyIn(MiniGameBuyIn&&);
		MiniGameBuyIn& operator=(MiniGameBuyIn&&);
	private:
		MiniGameBuyIn(const MiniGameBuyIn&);  // prohibit
		MiniGameBuyIn& operator=(const MiniGameBuyIn&);  // prohibit
#endif
	};

	//------------------------------------------------------------------------------

	struct MiniGameDefinition
	{
		// M(444M(4s8)M(4<M(IM(4<M(4Is8bIss4<M(ss)>sI)>)4)>)) - M(gameType,delayToPayout,delayToPayoutAutoplay,M(buyInType,currency,amount),M(numPrizeTable<M(prizeBucketName,M(numPrizes<M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)>),bucketOdds)>))
		INT32 gameType;	// see enum GameType
		INT32 delayToPayout;
		INT32 delayToPayoutAutoplay;
		MiniGameBuyIn buyIn;
		ThinAtf::LAtfVector< MiniGamePrizeBucket , 4 > prizeTable;

		MiniGameDefinition();
		void clear();
		bool equals(const MiniGameDefinition&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGameDefinition(MiniGameDefinition&&);
		MiniGameDefinition& operator=(MiniGameDefinition&&);
	private:
		MiniGameDefinition(const MiniGameDefinition&);  // prohibit
		MiniGameDefinition& operator=(const MiniGameDefinition&);  // prohibit
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	struct MiniGameDefinitionLocalized
	{
		// M(444M(4s8)M(4<M(sM(4<M(4ss8bsss4<M(ss)>ss)>)4)>)M()) - M(gameType,delayToPayout,delayToPayoutAutoplay,M(buyInType,currency,amount),M(numPrizeTable<M(prizeBucketName,M(numPrizes<M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)>),bucketOdds)>),M())
		INT32 gameType;	// see enum GameType
		INT32 delayToPayout;
		INT32 delayToPayoutAutoplay;
		MiniGameBuyIn buyIn;
		ThinAtf::LAtfVector< MiniGamePrizeBucketLocalized , 4 > prizeTable;

		ThinAtf::MoveableMsgBody gameDefMsgBody;	// contains additional game-specific definition

		MiniGameDefinitionLocalized();
		void clear();
		bool equals(const MiniGameDefinitionLocalized&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGameDefinitionLocalized(MiniGameDefinitionLocalized&&);
		MiniGameDefinitionLocalized& operator=(MiniGameDefinitionLocalized&&);
	private:
		MiniGameDefinitionLocalized(const MiniGameDefinitionLocalized&);  // prohibit
		MiniGameDefinitionLocalized& operator=(const MiniGameDefinitionLocalized&);  // prohibit
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	//------------------------------------------------------------------------------

	struct MiniGameVisibility
	{
		// M(44M(b4<s>)ssm) - M(brand,site,M(excludeCountries,numCountries<countries>),criteria,tableCriteria,siteMaskEx)
		UINT32 brand;	// visibility mask
		UINT32 site;	// visibility mask - deprecated. Replaced with siteMaskEx

		bool excludeCountries;
		ThinAtf::LAtfVector< PString , 4 > countries;	// country inlcusion/exclusion list

		PString criteria;	// criteria name to look up in Help Support Portal
		PString tableCriteria;	// table criteria name to look up in Help Support Portal
		PSiteMask siteMaskEx;	// visibility mask

		MiniGameVisibility();
		void clear();
		bool equals(const MiniGameVisibility&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

		// @Override
		void parseAnonymousMsgBody0( CommMsgParser& _parser );

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGameVisibility(MiniGameVisibility&&);
		MiniGameVisibility& operator=(MiniGameVisibility&&);
	private:
		MiniGameVisibility(const MiniGameVisibility&);  // prohibit
		MiniGameVisibility& operator=(const MiniGameVisibility&);  // prohibit
#endif

	private: // helper functions
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	//------------------------------------------------------------------------------

	struct MiniGameMetaData
	{
		// M(4<4>) - M(numMetaData<metaData>)
		ThinAtf::LAtfVector< INT32 , 4 > metaData;

		MiniGameMetaData();
		void clear();
		bool equals(const MiniGameMetaData&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGameMetaData(MiniGameMetaData&&);
		MiniGameMetaData& operator=(MiniGameMetaData&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		MiniGameMetaData(const MiniGameMetaData&) = default;
		MiniGameMetaData& operator=(const MiniGameMetaData&) = default;
#endif
#endif
	};

	//------------------------------------------------------------------------------

	struct MiniGameRound
	{
		// M(44<4>4<4>4M(44<M(4<4>)>)) - M(timestamp,numDecisions<decisions>,numResults<results>,prizeBucket,M(state,numMetaData<M(numMetaData<metaData>)>))
		INT32 timestamp;	// what timestamp is this (candidates: Start, End, Last Transition) - int representation of time_t since ATF does not support time_t
		ThinAtf::LAtfVector< INT32 , 4 > decisions;	// decisions made in the round
		ThinAtf::LAtfVector< INT32 , 4 > results;	// results of the decisions made in the round
		INT32 prizeBucket;	// index of the prize bucket won, or -1 if game is in progress

		INT32 state;	// current state (interpretation is game specific)
		ThinAtf::LAtfVector< MiniGameMetaData , 4 > metaData;	// A way to pass game specific round information to the client (eg: prizes left on a card by card basis in the deal)

		MiniGameRound();
		void clear();
		bool equals(const MiniGameRound&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGameRound(MiniGameRound&&);
		MiniGameRound& operator=(MiniGameRound&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		MiniGameRound(const MiniGameRound&) = default;
		MiniGameRound& operator=(const MiniGameRound&) = default;
#endif
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	//------------------------------------------------------------------------------

	struct MiniGameState
	{
		// M(84M(4<M(44<4>4<4>4M(44<M(4<4>)>))>)) - M(minigamePlayId,minigameId,M(numRounds<M(timestamp,numDecisions<decisions>,numResults<results>,prizeBucket,M(state,numMetaData<M(numMetaData<metaData>)>))>))
		UINT64 minigamePlayId;
		UINT32 minigameId;
		ThinAtf::LAtfVector< MiniGameRound , 4 > rounds;

		MiniGameState();
		void clear();
		bool equals(const MiniGameState&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGameState(MiniGameState&&);
		MiniGameState& operator=(MiniGameState&&);
	private:
		MiniGameState(const MiniGameState&);  // prohibit
		MiniGameState& operator=(const MiniGameState&);  // prohibit
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	//------------------------------------------------------------------------------

	struct MGConnInfo
	{
		// M(ss) - M(address,instance)
		PString address;	// address of MGLobby instance to connect to
		PString instance;	// name of MGLobby instance to connect to

		MGConnInfo();
		void clear();
		bool equals(const MGConnInfo&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MGConnInfo(MGConnInfo&&);
		MGConnInfo& operator=(MGConnInfo&&);
	private:
		MGConnInfo(const MGConnInfo&);  // prohibit
		MGConnInfo& operator=(const MGConnInfo&);  // prohibit
#endif
	};

	//------------------------------------------------------------------------------
	// 'MiniGame' publication
	//------------------------------------------------------------------------------
	//
	// Node { 0 } - list of mini game types
	//

	//------------------------------------------------------------------------------
	// Mini game publication leaf
	//------------------------------------------------------------------------------

	struct MiniGameTypeLeaf	// Leaf { 0, n }
	{
		// 44M(444M(4s8)M(4<M(IM(4<M(4Is8bIss4<M(ss)>sI)>)4)>))M(44M(b4<s>)ssm)sM(ss)IIIsI - gameStatus,minigameId,M(gameType,delayToPayout,delayToPayoutAutoplay,M(buyInType,currency,amount),M(numPrizeTable<M(prizeBucketName,M(numPrizes<M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)>),bucketOdds)>)),M(brand,site,M(excludeCountries,numCountries<countries>),criteria,tableCriteria,siteMaskEx),url,M(address,instance),clientDisplayName,clientDisplayInfo,clientDisplayInProgressTag,contentURLPrefix,clientDisplayGameDescription
		INT32 gameStatus;	// see enum GameStatus
		UINT32 minigameId;	// unique ID, referenced in messages below
		MiniGameDefinition minigameDef;
		MiniGameVisibility visibility;
		PString url;	// URL to navigate to, set if game is intended to be played via an HTML5 client
		MGConnInfo mgConnInfo;	// connection info for MGLobby instance where game is hosted
		I18nPString clientDisplayName;
		I18nPString clientDisplayInfo;
		I18nPString clientDisplayInProgressTag;
		PString contentURLPrefix;
		I18nPString clientDisplayGameDescription;

		MiniGameTypeLeaf();
		void clear();
		bool equals(const MiniGameTypeLeaf&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGameTypeLeaf(MiniGameTypeLeaf&&);
		MiniGameTypeLeaf& operator=(MiniGameTypeLeaf&&);
	private:
		MiniGameTypeLeaf(const MiniGameTypeLeaf&);  // prohibit
		MiniGameTypeLeaf& operator=(const MiniGameTypeLeaf&);  // prohibit
#endif
	};

	struct MiniGameDefLocalized
	{
		// 44M(444M(4s8)M(4<M(sM(4<M(4ss8bsss4<M(ss)>ss)>)4)>)M())sssss - gameStatus,minigameId,M(gameType,delayToPayout,delayToPayoutAutoplay,M(buyInType,currency,amount),M(numPrizeTable<M(prizeBucketName,M(numPrizes<M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)>),bucketOdds)>),M()),clientDisplayName,clientDisplayInfo,clientDisplayInProgressTag,contentURLPrefix,clientDisplayGameDescription
		INT32 gameStatus;	// see enum GameStatus
		UINT32 minigameId;	// unique ID, referenced in messages below
		MiniGameDefinitionLocalized minigameDef;
		PString clientDisplayName;
		PString clientDisplayInfo;
		PString clientDisplayInProgressTag;
		PString contentURLPrefix;
		PString clientDisplayGameDescription;

		MiniGameDefLocalized();
		void clear();
		bool equals(const MiniGameDefLocalized&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		MiniGameDefLocalized(MiniGameDefLocalized&&);
		MiniGameDefLocalized& operator=(MiniGameDefLocalized&&);
	private:
		MiniGameDefLocalized(const MiniGameDefLocalized&);  // prohibit
		MiniGameDefLocalized& operator=(const MiniGameDefLocalized&);  // prohibit
#endif
	};

	//------------------------------------------------------------------------------
	//
	// Node { 1 } - list of running jackpots
	//

	struct TheDealJackpotLeaf	// Leaf { 1, n, 0 }
	{
		// M(s844)M(44M(b4<s>)ssm) - M(jackpotCurrency,jackpotAmount,jackpotWinnerPercentage,jackpotShareEligibilityMins),M(brand,site,M(excludeCountries,numCountries<countries>),criteria,tableCriteria,siteMaskEx)

		PString jackpotCurrency;
		INT64 jackpotAmount;
		INT32 jackpotWinnerPercentage;	//percentage of the jackpot share that goes to the winner
		INT32 jackpotShareEligibilityMins;	// length of jackpot share eligibility

		MiniGameVisibility visibility;

		TheDealJackpotLeaf();
		void clear();
		bool equals(const TheDealJackpotLeaf&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		TheDealJackpotLeaf(TheDealJackpotLeaf&&);
		TheDealJackpotLeaf& operator=(TheDealJackpotLeaf&&);
	private:
		TheDealJackpotLeaf(const TheDealJackpotLeaf&);  // prohibit
		TheDealJackpotLeaf& operator=(const TheDealJackpotLeaf&);  // prohibit
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	struct TheDealJackpotSpinLeaf	// Leaf { 1, n, 1 } - active or last Jackpot spin
	{
		//! b4s <FIXME>BrandProtThin::BrandImageList</FIXME> 844M(84M(4<M(44<4>4<4>4M(44<M(4<4>)>))>)) - active,timestamp,playerId, <FIXME>playerBrandImages</FIXME> ,jackpotAmountInCents,winnerShareAmount,playerShareAmount,M(minigamePlayId,minigameId,M(numRounds<M(timestamp,numDecisions<decisions>,numResults<results>,prizeBucket,M(state,numMetaData<M(numMetaData<metaData>)>))>))
		bool active;	// true if Jackpot spin is now in progress
		INT32 timestamp;	//When the Jackpot started, or will start - int representation of time_t since ATF does not support time_t
		PString playerId;
		BrandProtThin::BrandImageList playerBrandImages;
		INT64 jackpotAmountInCents;
		INT32 winnerShareAmount;
		INT32 playerShareAmount;
		MiniGameState jackpotState;

		TheDealJackpotSpinLeaf();
		void clear();
		bool equals(const TheDealJackpotSpinLeaf&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		TheDealJackpotSpinLeaf(TheDealJackpotSpinLeaf&&);
		TheDealJackpotSpinLeaf& operator=(TheDealJackpotSpinLeaf&&);
	private:
		TheDealJackpotSpinLeaf(const TheDealJackpotSpinLeaf&);  // prohibit
		TheDealJackpotSpinLeaf& operator=(const TheDealJackpotSpinLeaf&);  // prohibit
#endif
	};

	//------------------------------------------------------------------------------

	struct GameTicketWithMiniGame
	{
		// M(84tt44444ss4444m) - M(gameTicketId,gameTicketTypeId,whenStarted,expiration,playsInitial,playsSpent,gameTicketBrandMask,minigameId,minigameType,minigameClientDisplayName,minigameClientDisplayInfo,minigameBrandMask,minigameSiteMask,status,costFpp1,minigameSiteMaskEx)
		UINT64 gameTicketId;
		UINT32 gameTicketTypeId;
		SrvTime whenStarted;
		SrvTime expiration;
		INT32 playsInitial;
		INT32 playsSpent;
		UINT32 gameTicketBrandMask;
		UINT32 minigameId;
		UINT32 minigameType;
		PString minigameClientDisplayName;
		PString minigameClientDisplayInfo;
		UINT32 minigameBrandMask;
		UINT32 minigameSiteMask;	// deprecated. Replaced by minigameSiteMaskEx
		INT32 status;
		INT32 costFpp1;
		PSiteMask minigameSiteMaskEx;

		GameTicketWithMiniGame();
		void clear();
		bool equals(const GameTicketWithMiniGame&) const;
		const char *toTraceString(PString& _str) const;
		void composeMsg(CommMsgBody& _msg) const;
		void parseMsg(CommMsgParser& _parser);
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		GameTicketWithMiniGame(GameTicketWithMiniGame&&);
		GameTicketWithMiniGame& operator=(GameTicketWithMiniGame&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		GameTicketWithMiniGame(const GameTicketWithMiniGame&) = default;
		GameTicketWithMiniGame& operator=(const GameTicketWithMiniGame&) = default;
#endif
#endif
	};

	//------------------------------------------------------------------------------

	//------------------------------------------------------------------------------
	// Enumerate active mini games
	//------------------------------------------------------------------------------

	// !!! WARNING !!! If you modify this message, please let testautomation team know.
	struct Protocol_MINIGAME_MSG_ACTIVE_GAMES
	{
		// 8 - requestId
		INT64 requestId;

		Protocol_MINIGAME_MSG_ACTIVE_GAMES();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_ACTIVE_GAMES&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_ACTIVE_GAMES; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_ACTIVE_GAMES"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
	};

	struct Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY
	{
		// 82[s|M(4<M(84M(4<M(44<4>4<4>4M(44<M(4<4>)>))>))>)] - requestId,errCode[errStr|M(numStates<M(minigamePlayId,minigameId,M(numRounds<M(timestamp,numDecisions<decisions>,numResults<results>,prizeBucket,M(state,numMetaData<M(numMetaData<metaData>)>))>))>)]
		INT64 requestId;	// return value received in MINIGAME_MSG_ACTIVE_GAMES
		INT16 errCode;

		PString errStr;

		ThinAtf::LAtfVector< MiniGameState , 4 > states;

		Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_ACTIVE_GAMES_REPLY; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_ACTIVE_GAMES_REPLY"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY(Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY&&);
		Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY& operator=(Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY(const Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY&) = default;
		Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY& operator=(const Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY&) = default;
#endif
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	//------------------------------------------------------------------------------
	// MiniGame: start new game
	//------------------------------------------------------------------------------

	// !!! WARNING !!! If you modify this message, please let testautomation team know.
	struct Protocol_MINIGAME_MSG_START_GAME
	{
		// 84M(4<4>)bb18 - requestId,minigameId,M(numInitialDecisions<initialDecisions>),autoPlay,useGameTicket,minigameEntryMode,minigameEntryRefId
		INT64 requestId;
		UINT32 minigameId;	// see MiniGameTypeLeaf
		ThinAtf::LAtfVector< INT32 , 4 > initialDecisions;	// apply these decisions to round 0

		bool autoPlay;
		bool useGameTicket;	// useGameTicket is not used anymore and is ignored by MGLobby
		INT8 minigameEntryMode;	// see SideGameEntryMode enum
		UINT64 minigameEntryRefId;	// depends on minigameEntryMode

		Protocol_MINIGAME_MSG_START_GAME();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_START_GAME&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_START_GAME; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_START_GAME"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_START_GAME(Protocol_MINIGAME_MSG_START_GAME&&);
		Protocol_MINIGAME_MSG_START_GAME& operator=(Protocol_MINIGAME_MSG_START_GAME&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		Protocol_MINIGAME_MSG_START_GAME(const Protocol_MINIGAME_MSG_START_GAME&) = default;
		Protocol_MINIGAME_MSG_START_GAME& operator=(const Protocol_MINIGAME_MSG_START_GAME&) = default;
#endif
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	struct Protocol_MINIGAME_MSG_START_GAME_REPLY
	{
		// 82[s|M(84M(4<M(44<4>4<4>4M(44<M(4<4>)>))>))]4<M(84tt44444ss4444m)>4 - requestId,errCode[errStr|M(minigamePlayId,minigameId,M(numRounds<M(timestamp,numDecisions<decisions>,numResults<results>,prizeBucket,M(state,numMetaData<M(numMetaData<metaData>)>))>))],numTicketsWithMinigames<M(gameTicketId,gameTicketTypeId,whenStarted,expiration,playsInitial,playsSpent,gameTicketBrandMask,minigameId,minigameType,minigameClientDisplayName,minigameClientDisplayInfo,minigameBrandMask,minigameSiteMask,status,costFpp1,minigameSiteMaskEx)>,playsRemaining
		INT64 requestId;	// return value received in MINIGAME_MSG_START_GAME
		INT16 errCode;

		PString errStr;

		MiniGameState state;

		ThinAtf::LAtfVector< GameTicketWithMiniGame , 4 > ticketsWithMinigames;
		INT32 playsRemaining;

		Protocol_MINIGAME_MSG_START_GAME_REPLY();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_START_GAME_REPLY&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_START_GAME_REPLY; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_START_GAME_REPLY"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_START_GAME_REPLY(Protocol_MINIGAME_MSG_START_GAME_REPLY&&);
		Protocol_MINIGAME_MSG_START_GAME_REPLY& operator=(Protocol_MINIGAME_MSG_START_GAME_REPLY&&);
	private:
		Protocol_MINIGAME_MSG_START_GAME_REPLY(const Protocol_MINIGAME_MSG_START_GAME_REPLY&);  // prohibit
		Protocol_MINIGAME_MSG_START_GAME_REPLY& operator=(const Protocol_MINIGAME_MSG_START_GAME_REPLY&);  // prohibit
#endif
	};

	//------------------------------------------------------------------------------
	// Play next game round, game progress update
	//------------------------------------------------------------------------------

	// !!! WARNING !!! If you modify this message, please let testautomation team know.
	struct Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND
	{
		// 884M(4<4>) - requestId,minigamePlayId,round,M(numDecisions<decisions>)
		INT64 requestId;
		UINT64 minigamePlayId;
		INT32 round;	// this message isn't used at the moment so max size is 0
		ThinAtf::LAtfVector< INT32 , 4 > decisions;	// this message isn't used at the moment so max size is 0

		Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_PLAY_NEXT_ROUND; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_PLAY_NEXT_ROUND"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND(Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND&&);
		Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND& operator=(Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND(const Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND&) = default;
		Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND& operator=(const Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND&) = default;
#endif
#endif

	private: // helper functions
		void parseAnonymousMsgBody0(CommMsgParser& _parser);
		static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
	};

	// !!! WARNING !!! If you modify this message, please let testautomation team know.
	struct Protocol_MINIGAME_MSG_GAME_STATE
	{
		// 88 - requestId,minigamePlayId
		INT64 requestId;
		UINT64 minigamePlayId;

		Protocol_MINIGAME_MSG_GAME_STATE();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_GAME_STATE&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_GAME_STATE; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_GAME_STATE"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
	};

	struct Protocol_MINIGAME_MSG_GAME_STATE_REPLY
	{
		// 82[s|M(84M(4<M(44<4>4<4>4M(44<M(4<4>)>))>))] - requestId,errCode[errStr|M(minigamePlayId,minigameId,M(numRounds<M(timestamp,numDecisions<decisions>,numResults<results>,prizeBucket,M(state,numMetaData<M(numMetaData<metaData>)>))>))]
		INT64 requestId;	// return value received in MINIGAME_MSG_PLAY_NEXT_ROUND or MINIGAME_MSG_GAME_STATE, or 0 for push notifications
		INT16 errCode;

		PString errStr;

		MiniGameState state;

		Protocol_MINIGAME_MSG_GAME_STATE_REPLY();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_GAME_STATE_REPLY&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_GAME_STATE_REPLY; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_GAME_STATE_REPLY"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_GAME_STATE_REPLY(Protocol_MINIGAME_MSG_GAME_STATE_REPLY&&);
		Protocol_MINIGAME_MSG_GAME_STATE_REPLY& operator=(Protocol_MINIGAME_MSG_GAME_STATE_REPLY&&);
	private:
		Protocol_MINIGAME_MSG_GAME_STATE_REPLY(const Protocol_MINIGAME_MSG_GAME_STATE_REPLY&);  // prohibit
		Protocol_MINIGAME_MSG_GAME_STATE_REPLY& operator=(const Protocol_MINIGAME_MSG_GAME_STATE_REPLY&);  // prohibit
#endif
	};

	//------------------------------------------------------------------------------
	// Control messages
	//------------------------------------------------------------------------------

	struct Protocol_MINIGAME_MSG_SERVER_RESTARTING
	{
		//empty

		Protocol_MINIGAME_MSG_SERVER_RESTARTING();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_SERVER_RESTARTING&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_SERVER_RESTARTING; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_SERVER_RESTARTING"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
	};

	//------------------------------------------------------------------------------
	// Lookup minigame by ticket and ticket type
	//------------------------------------------------------------------------------

	struct Protocol_MINIGAME_MSG_TICKET_LOOKUP
	{
		// 884 - requestId,ticketId,ticketTypeId
		INT64 requestId;
		UINT64 ticketId;
		UINT32 ticketTypeId;

		Protocol_MINIGAME_MSG_TICKET_LOOKUP();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_TICKET_LOOKUP&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_TICKET_LOOKUP; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_TICKET_LOOKUP"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
	};

	struct Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY
	{
		// 82[s|444m] - requestId,errCode[errStr|minigameId,minigameType,minigameBrandMask,minigameSiteMaskEx]
		INT64 requestId;	// return value received in MINIGAME_MSG_TICKET_LOOKUP
		INT16 errCode;

		PString errStr;

		UINT32 minigameId;
		UINT32 minigameType;	// enum GameType
		// PYR-112602
		UINT32 minigameBrandMask;
		PSiteMask minigameSiteMaskEx;

		Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_TICKET_LOOKUP_REPLY; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_TICKET_LOOKUP_REPLY"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY(Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY&&);
		Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY& operator=(Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY(const Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY&) = default;
		Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY& operator=(const Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY&) = default;
#endif
#endif
	};

	//------------------------------------------------------------------------------
	// Get the player's available game tickets and associated minigame
	//------------------------------------------------------------------------------

	struct Protocol_MINIGAME_MSG_GET_TICKETS
	{
		// 8 - requestId
		INT64 requestId;

		Protocol_MINIGAME_MSG_GET_TICKETS();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_GET_TICKETS&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_GET_TICKETS; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_GET_TICKETS"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
	};

	struct Protocol_MINIGAME_MSG_GET_TICKETS_REPLY
	{
		// 82[s|4<M(84tt44444ss4444m)>] - requestId,errCode[errStr|numTicketsWithMinigames<M(gameTicketId,gameTicketTypeId,whenStarted,expiration,playsInitial,playsSpent,gameTicketBrandMask,minigameId,minigameType,minigameClientDisplayName,minigameClientDisplayInfo,minigameBrandMask,minigameSiteMask,status,costFpp1,minigameSiteMaskEx)>]
		INT64 requestId;
		INT16 errCode;

		PString errStr;

		ThinAtf::LAtfVector< GameTicketWithMiniGame , 4 > ticketsWithMinigames;

		Protocol_MINIGAME_MSG_GET_TICKETS_REPLY();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_GET_TICKETS_REPLY&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_GET_TICKETS_REPLY; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_GET_TICKETS_REPLY"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_GET_TICKETS_REPLY(Protocol_MINIGAME_MSG_GET_TICKETS_REPLY&&);
		Protocol_MINIGAME_MSG_GET_TICKETS_REPLY& operator=(Protocol_MINIGAME_MSG_GET_TICKETS_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		Protocol_MINIGAME_MSG_GET_TICKETS_REPLY(const Protocol_MINIGAME_MSG_GET_TICKETS_REPLY&) = default;
		Protocol_MINIGAME_MSG_GET_TICKETS_REPLY& operator=(const Protocol_MINIGAME_MSG_GET_TICKETS_REPLY&) = default;
#endif
#endif
	};

	//-------------------------------------------------------------------------------
	// Get the number of plays for tickets filtered by minigameId or gameTicketTypeId
	//-------------------------------------------------------------------------------

	struct Protocol_MINIGAME_MSG_GET_STACKED_TICKETS
	{
		// 844 - requestId,minigameId,gameTicketTypeId
		INT64 requestId;
		UINT32 minigameId;	// minigameId for which to stack game ticket plays
		UINT32 gameTicketTypeId;	// gameTicketTypeId for which to stack game ticket plays

		Protocol_MINIGAME_MSG_GET_STACKED_TICKETS();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_GET_STACKED_TICKETS&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_GET_STACKED_TICKETS; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_GET_STACKED_TICKETS"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
	};

	struct Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY
	{
		// 82[s|4] - requestId,errCode[errStr|playsRemaining]
		INT64 requestId;
		INT16 errCode;

		PString errStr;

		INT32 playsRemaining;

		Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_GET_STACKED_TICKETS_REPLY; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_GET_STACKED_TICKETS_REPLY"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY(Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY&&);
		Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY& operator=(Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY(const Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY&) = default;
		Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY& operator=(const Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY&) = default;
#endif
#endif
	};

	//------------------------------------------------------------------------------
	// Sidegame messages
	//------------------------------------------------------------------------------

	namespace client	// between native client and MGLobby through msgbody format. MGLobby is the client access point.
	{
		enum SideGameStatus
		{
			eSGS_None         = -1,
			eSGS_ProgressMin  = 0,
			eSGS_ProgressMax  = 100,
			eSGS_Completed    = 300,
			eSGS_Failed       = 400,
		};

		enum SuitRacePosition
		{
			eSuitRace_Unknown  = -1,
			eSuitRace_Starting = 0,
			eSuitRace_First    = 1,
			eSuitRace_Second   = 2,
			eSuitRace_Third    = 3,
			eSuitRace_Fourth   = 4,
			eSuitRace_Winner   = 5,
			eSuitRace_Loss     = 6,
			eSuitRace_DailyMax = 7,
		};

		enum SuitRaceSuit
		{
			eSuitRaceSuit_None     = 0,
			eSuitRaceSuit_Spades   = 115, 	//'s'
			eSuitRaceSuit_Hearts   = 104, 	//'h'
			eSuitRaceSuit_Diamonds = 100, 	//'d'
			eSuitRaceSuit_Clubs    = 99,  	//'c'
		};

		enum SideBetStatus
		{
			eSBS_NoBet        = 0, 	// no bet has been created
			eSBS_BetPending   = 1, 	// a bet has been made and is waiting resolution
			eSBS_BetResolved  = 2, 	// a bet has been resolved
			eSBS_BetError     = 3, 	// an error occurred creating or resolving a bet, or an auto-bet has been stopped prematurely
		};

		struct Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER	// C->S
		{
			// 84M() - clientCtx,gameMsgId,M()
			UINT64 clientCtx;	// value submitted by client and used for routing reply to appropriate html5 client instance (could be TableId for CardMatch at a ring game table, but exact details are up to client).
			UINT32 gameMsgId;
			ThinAtf::MoveableMsgBody gameMsgBody;	// the concrete game message is transparent to the MGLobby (maxsize=1Mb)

			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER&&);
			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER& operator=(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER&&);
		private:
			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER&);  // prohibit
			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER& operator=(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER&);  // prohibit
#endif
		};

		struct Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER	// S->C
		{
			// 84M()M() - clientCtx,gameMsgId,M(),M()
			UINT64 clientCtx;	// echo of clientCtx on inbound message for synchronous replies, or stored clientCtx from start request for async updates
			UINT32 gameMsgId;
			ThinAtf::MoveableMsgBody gameMsgBody;	// the concrete game message, MGLobby wraps the JSON string into msgbody (maxsize=1Mb)
			ThinAtf::MoveableMsgBody gameStateMetaDataMsgBody;	// GameStateMetaData (maxsize=1Mb)

			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER&&);
			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER& operator=(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER&&);
		private:
			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER&);  // prohibit
			Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER& operator=(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER&);  // prohibit
#endif
		};

		struct PokerSideBetGameStateMetaData
		{
			// M(4881) - M(gameStatus,betAmount,winAmount,numAutoPlaysRemainingToDisplay)
			INT32 gameStatus;	// see enum SideBetStatus
			INT64 betAmount;	// total amount bet for the hand
			INT64 winAmount;	// amount won for the latest bet to resolve
			INT8 numAutoPlaysRemainingToDisplay;	// number of autoPlays remaining to display on the client (-1 means this was a single bet)

			PokerSideBetGameStateMetaData();
			void clear();
			bool equals(const PokerSideBetGameStateMetaData&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct GameStateMetaData
		{
			// 414M() - gameState,chosenSuit,position,M()
			INT32 gameState;	// eSGS_*
			BYTE chosenSuit;	//one of 'schd' or 0 For non-suit race
			INT32 position;	//see eSuitRacePosition
			ThinAtf::CopyableMsgBody stateMsgBody;	// game specific information

			GameStateMetaData();
			void clear();
			bool equals(const GameStateMetaData&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			GameStateMetaData(GameStateMetaData&&);
			GameStateMetaData& operator=(GameStateMetaData&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			GameStateMetaData(const GameStateMetaData&) = default;
			GameStateMetaData& operator=(const GameStateMetaData&) = default;
#endif
#endif
		};

		enum SideGameAnimType
		{
			eSGAnimType_None          = 0,
			eSGAnimType_PossibleMatch = 1,
			eSGAnimType_Match         = 2,
			eSGAnimType_SideBetWin_HoleCards = 3,
			eSGAnimType_SideBetWin_FlopCards = 4,
		};

		enum SideGameAnimLocation
		{
			eSGAnimLoc_None                            = -1,
			eSGAnimLoc_HoleCard_First                  = 0,   	// second hole card is HoleCard_First + 1, etc
			eSGAnimLoc_CommunityCard_FirstBoard_First  = 100, 	// first community card on first board (board 0). second card is eSGAnimLoc_CommunityCard_FirstBoard_First + 1, etc.
			eSGAnimLoc_CommunityCard_SecondBoard_First = 200, 	// for run it twice - first community card on second board (board 1)
		};

		struct SideGameAnim
		{
			// M(44M()) - M(animType,location,M())
			INT32 animType;	// eSGAnimType_*
			INT32 location;	// eSGAnimLoc_*
			ThinAtf::CopyableMsgBody animMsgBody;	// structure depends on SideGameAnimType

			SideGameAnim();
			void clear();
			bool equals(const SideGameAnim&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			SideGameAnim(SideGameAnim&&);
			SideGameAnim& operator=(SideGameAnim&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			SideGameAnim(const SideGameAnim&) = default;
			SideGameAnim& operator=(const SideGameAnim&) = default;
#endif
#endif
		};

		// animMsgBody for eSGAnimType_SideBetWin_HoleCards and eSGAnimType_SideBetWin_FlopCards
		struct SideBetWinAnimMsgBody
		{
			// 4sbs8 - amount,currency,isPlayMoney,betType,amount64
			INT32 amount;	// deprecated. use amount64 instead
			PString currency;
			bool isPlayMoney;
			PString betType;
			INT64 amount64;

			SideBetWinAnimMsgBody();
			void clear();
			bool equals(const SideBetWinAnimMsgBody&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			SideBetWinAnimMsgBody(SideBetWinAnimMsgBody&&);
			SideBetWinAnimMsgBody& operator=(SideBetWinAnimMsgBody&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			SideBetWinAnimMsgBody(const SideBetWinAnimMsgBody&) = default;
			SideBetWinAnimMsgBody& operator=(const SideBetWinAnimMsgBody&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION	// S->C
		{
			// 84<M(44M())> - handId,numAnims<M(animType,location,M())>
			UINT64 handId;
			ThinAtf::LAtfVector< SideGameAnim , 4 > anims;

			Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_TRIGGER_ANIMATION; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_TRIGGER_ANIMATION"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION(Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION&&);
			Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION& operator=(Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION&&);
		private:
			Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION(const Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION&);  // prohibit
			Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION& operator=(const Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION&);  // prohibit
#endif
		};
	};

	namespace sidegame	// between html5 client and MGLobby server through JSON format
	{
		// for poker side bets
		struct SGCard
		{
			// M(11) - M(rank,suit)
			BYTE rank;	// 2 - 14
			BYTE suit;	// 'c', 'd', 'h', 's'

			SGCard();
			void clear();
			bool equals(const SGCard&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		// for CardMatch
		struct MCard
		{
			// M(11bb) - M(rank,suit,matched,possibleMatch)
			BYTE rank;	// 2 - 14
			BYTE suit;	// 'c', 'd', 'h', 's'
			bool matched;	// true if this card has been matched
			bool possibleMatch;	// true if this card is not yet matched but matches a currently dealt card and is pending other match condition(s)

			MCard();
			void clear();
			bool equals(const MCard&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct PokerSideGameState
		{
			// M(444444M(4Is8bIss4<M(ss)>sI)) - M(timestamp,handsTotal,handsRemaining,handsRequiredToForfeit,lifeCycleState,currentHandState,M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText))
			INT32 timestamp;	// game start time - int representation of time_t since ATF does not support time_t
			INT32 handsTotal;	// total number of hands which player has to match [mds] maybe redundant with game definition?
			INT32 handsRemaining;	// hands remaining [mds] is this inclusive of current hand? or exclusive?
			INT32 handsRequiredToForfeit;	// forfeit after this many hands have elapsed (compare to handsTotal - handsRemaining)
			INT32 lifeCycleState;	// pending, active, prize claimable, end
			INT32 currentHandState;	// eligible, ineligible, non-qualified
			MiniGamePrize prize;	// prize. only valid in "prize claimable" and "end" states.

			PokerSideGameState();
			void clear();
			bool equals(const PokerSideGameState&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PokerSideGameState(PokerSideGameState&&);
			PokerSideGameState& operator=(PokerSideGameState&&);
		private:
			PokerSideGameState(const PokerSideGameState&);  // prohibit
			PokerSideGameState& operator=(const PokerSideGameState&);  // prohibit
#endif
		};

		// [mds] first pass at this structure, representation may need to change slightly to reflect all possible client states
		struct CardMatchGameState
		{
			// M(4<M(11bb)>444444M(4Is8bIss4<M(ss)>sI)) - M(numCards<M(rank,suit,matched,possibleMatch)>,timestamp,handsTotal,handsRemaining,handsRequiredToForfeit,lifeCycleState,currentHandState,M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText))
			ThinAtf::LAtfVector< MCard , 4 > cards;
			INT32 timestamp;	// game start time - int representation of time_t since ATF does not support time_t
			INT32 handsTotal;	// total number of hands which player has to match [mds] maybe redundant with game definition?
			INT32 handsRemaining;	// hands remaining [mds] is this inclusive of current hand? or exclusive?
			INT32 handsRequiredToForfeit;	// forfeit after this many hands have elapsed (compare to handsTotal - handsRemaining)
			INT32 lifeCycleState;	// pending, active, prize claimable, end
			INT32 currentHandState;	// eligible, ineligible, non-qualified
			MiniGamePrize prize;	// prize. only valid in "prize claimable" and "end" states.

			CardMatchGameState();
			void clear();
			bool equals(const CardMatchGameState&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			CardMatchGameState(CardMatchGameState&&);
			CardMatchGameState& operator=(CardMatchGameState&&);
		private:
			CardMatchGameState(const CardMatchGameState&);  // prohibit
			CardMatchGameState& operator=(const CardMatchGameState&);  // prohibit
#endif
		};

		struct RandomDrawGameState
		{
			// M(4444) - M(timestamp,lifeCycleState,prizeIndex,animationSeed)
			INT32 timestamp;	// game start time - int representation of time_t since ATF does not support time_t
			INT32 lifeCycleState;	// in progress or done
			INT32 prizeIndex;	// index into the prizetable for this game that was selected
			INT32 animationSeed;	// random number generated to seed variation in animation display

			RandomDrawGameState();
			void clear();
			bool equals(const RandomDrawGameState&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct PickAnObjectGameState
		{
			// M(4444<4>1) - M(timestamp,lifeCycleState,animationSeed,numPrizeObjectIndices<prizeObjectIndices>,prizeObjectPicked)
			INT32 timestamp;	// game start time - int representation of time_t since ATF does not support time_t
			INT32 lifeCycleState;	// in progress or done
			INT32 animationSeed;	// random number generated to seed variation in animation display
			ThinAtf::LAtfVector< INT32, 4 > prizeObjectIndices;	// vector of prizeBucketIndices indicating the position of each prize object that the client will display
			INT8 prizeObjectPicked;	// position of prize object selected by player - prize awarded is this position in the prizeObjectIndices vector

			PickAnObjectGameState();
			void clear();
			bool equals(const PickAnObjectGameState&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PickAnObjectGameState(PickAnObjectGameState&&);
			PickAnObjectGameState& operator=(PickAnObjectGameState&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			PickAnObjectGameState(const PickAnObjectGameState&) = default;
			PickAnObjectGameState& operator=(const PickAnObjectGameState&) = default;
#endif
#endif
		};

		struct ChestGameState
		{
			//! M(44<M(4ss8bsss4<M(ss)>ss)>44< <FIXME>CvlClientUserBarNotification</FIXME> >4< <FIXME>CvlConfigParams</FIXME> >) - M(lifeCycleState,numPrizes<M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)>,animationLevel,numCvlBarUpdates< <FIXME>CvlClientUserBarNotification</FIXME> >,numCvlConfigParams< <FIXME>CvlConfigParams</FIXME> >)
			INT32 lifeCycleState;	// in progress or done
			ThinAtf::LAtfVector< MiniGamePrizeLocalized, 4 > prizes;
			INT32 animationLevel;
			ThinAtf::LAtfVector< CvlClientUserBarNotification, 4 > cvlBarUpdates;
			ThinAtf::LAtfVector< CvlConfigParams, 4 > cvlConfigParams;

			ChestGameState();
			void clear();
			bool equals(const ChestGameState&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			ChestGameState(ChestGameState&&);
			ChestGameState& operator=(ChestGameState&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			ChestGameState(const ChestGameState&) = default;
			ChestGameState& operator=(const ChestGameState&) = default;
#endif
#endif
		};

		struct SuitRacePlayerProgress
		{
			// M(141) - M(suit,progress,lastProgressType)
			BYTE suit;
			INT32 progress;
			INT8 lastProgressType;

			SuitRacePlayerProgress();
			void clear();
			bool equals(const SuitRacePlayerProgress&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct SuitRaceGameState
		{
			// M(4<M(141)>14M(444444M(4Is8bIss4<M(ss)>sI))) - M(numPlayerProgress<M(suit,progress,lastProgressType)>,chosenSuit,totalProgressRequired,M(timestamp,handsTotal,handsRemaining,handsRequiredToForfeit,lifeCycleState,currentHandState,M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)))
			ThinAtf::LAtfVector< SuitRacePlayerProgress , 4 > playerProgress;
			BYTE chosenSuit;
			INT32 totalProgressRequired;
			PokerSideGameState sideGameState;

			SuitRaceGameState();
			void clear();
			bool equals(const SuitRaceGameState&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			SuitRaceGameState(SuitRaceGameState&&);
			SuitRaceGameState& operator=(SuitRaceGameState&&);
		private:
			SuitRaceGameState(const SuitRaceGameState&);  // prohibit
			SuitRaceGameState& operator=(const SuitRaceGameState&);  // prohibit
#endif
		};

		struct SideGameState
		{
			// M(84184M()88) - M(minigamePlayId,minigameId,gameType,gameId,entryId,M(),ringSessionId,subGameId)
			UINT64 minigamePlayId;
			UINT32 minigameId;
			INT8 gameType;	// 0: Table, 1: Zoom
			UINT64 gameId;	// TableId or BlitzId
			UINT32 entryId;	// for Zoom
			ThinAtf::CopyableMsgBody stateMsgBody;	// game-specific structure, interpreted based on minigameId. For CardMatch, this is a CardMatchGameState.
			UINT64 ringSessionId;	// for ring games
			UINT64 subGameId;	// id of a child object of gameId, e.g., tableId of table in a tournament

			SideGameState();
			void clear();
			bool equals(const SideGameState&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			SideGameState(SideGameState&&);
			SideGameState& operator=(SideGameState&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			SideGameState(const SideGameState&) = default;
			SideGameState& operator=(const SideGameState&) = default;
#endif
#endif
		};

		struct MaxGamesReachedEntry
		{
			// M(44) - M(minigameId,expirationTime)
			UINT32 minigameId;	// minigameId for which max games are reached
			INT32 expirationTime;	// time_t at which max games reached state resets

			MaxGamesReachedEntry();
			void clear();
			bool equals(const MaxGamesReachedEntry&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct GameTicketState
		{
			// M(84) - M(gameTicketId,playsRemaining)
			UINT64 gameTicketId;	// ticket instance id used for play, if applicable (else 0)
			INT32 playsRemaining;	// remaining plays on ticket if instanceid != 0

			GameTicketState();
			void clear();
			bool equals(const GameTicketState&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		enum ePokerSideBetType
		{
			ePokerSideBetType_Undefined = 0,
			ePokerSideBetType_HoleCards = 1,  	// bet where payouts are determined by hole cards dealt to player
			ePokerSideBetType_FlopCards = 2,  	// bet where payouts are determined by flop cards
			ePokerSideBetType_Max = ePokerSideBetType_FlopCards 	// must be kept up-to-date
		};

		enum PokerSideBetAvailabilityFlags
		{
			ePokerSideBetAvailabilityFlags_Seated    = 0x01,     	// if set, this bet is available for seated players
			ePokerSideBetAvailabilityFlags_Observer  = 0x02,     	// if set, this bet is available for observer players
		};

		struct PokerSideBetResultPayout
		{
			// M(24) - M(betResult,payoutMultiplier)
			INT16 betResult;	// value in ePokerSideBetResult_ for the bet type that this payout table corresponds to (i.e. ePokerSideBetResult_HoleCards for a hole cards bet)
			INT32 payoutMultiplier;

			PokerSideBetResultPayout();
			void clear();
			bool equals(const PokerSideBetResultPayout&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct PokerSideBetAvailableBet
		{
			// M(2ss4<M(24)>1) - M(betType,betName,betDescription,numOddsTable<M(betResult,payoutMultiplier)>,availabilityflags)
			INT16 betType;	// enum ePokerSideBetType
			PString betName;	// localized
			PString betDescription;	// localized - includes payout table?
			ThinAtf::LAtfVector< PokerSideBetResultPayout, 4 > oddsTable;
			BYTE availabilityflags;	// see PokerSideBetAvailabilityFlags

			PokerSideBetAvailableBet();
			void clear();
			bool equals(const PokerSideBetAvailableBet&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PokerSideBetAvailableBet(PokerSideBetAvailableBet&&);
			PokerSideBetAvailableBet& operator=(PokerSideBetAvailableBet&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			PokerSideBetAvailableBet(const PokerSideBetAvailableBet&) = default;
			PokerSideBetAvailableBet& operator=(const PokerSideBetAvailableBet&) = default;
#endif
#endif
		};

		struct PokerSideBetGameDefBody
		{
			// M(4<M(2ss4<M(24)>1)>4<8>4<2>4<8>8) - M(numAvailableBets<M(betType,betName,betDescription,numOddsTable<M(betResult,payoutMultiplier)>,availabilityflags)>,numAllowedBetAmounts<allowedBetAmounts>,numAllowedNumberOfAutoBets<allowedNumberOfAutoBets>,numAllowedBetIncrements<allowedBetIncrements>,maxBuyIn)
			ThinAtf::LAtfVector< PokerSideBetAvailableBet, 4 > availableBets;
			ThinAtf::LAtfVector< INT64, 4 > allowedBetAmounts;
			ThinAtf::LAtfVector< INT16, 4 > allowedNumberOfAutoBets;	// either allowedNumberOfAutoBets or allowedBetIncrements will be populated
			ThinAtf::LAtfVector< INT64, 4 > allowedBetIncrements;	// either allowedNumberOfAutoBets or allowedBetIncrements will be populated
			INT64 maxBuyIn;

			PokerSideBetGameDefBody();
			void clear();
			bool equals(const PokerSideBetGameDefBody&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PokerSideBetGameDefBody(PokerSideBetGameDefBody&&);
			PokerSideBetGameDefBody& operator=(PokerSideBetGameDefBody&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			PokerSideBetGameDefBody(const PokerSideBetGameDefBody&) = default;
			PokerSideBetGameDefBody& operator=(const PokerSideBetGameDefBody&) = default;
#endif
#endif
		};

		struct PokerSideBetGameState
		{
			// M(284424<M(11)>M(4Is8bIss4<M(ss)>sI)) - M(betType,betAmount,timestamp,lifeCycleState,betResult,numCards<M(rank,suit)>,M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText))
			INT16 betType;	// ePokerSideBetType_
			INT64 betAmount;
			INT32 timestamp;	// game start time - int representation of time_t since ATF does not support time_t
			INT32 lifeCycleState;	// pending, active, end
			INT16 betResult;
			ThinAtf::LAtfVector< SGCard, 4 > cards;
			MiniGamePrize prize;	// prize. only valid in "end" states.

			PokerSideBetGameState();
			void clear();
			bool equals(const PokerSideBetGameState&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			PokerSideBetGameState(PokerSideBetGameState&&);
			PokerSideBetGameState& operator=(PokerSideBetGameState&&);
		private:
			PokerSideBetGameState(const PokerSideBetGameState&);  // prohibit
			PokerSideBetGameState& operator=(const PokerSideBetGameState&);  // prohibit
#endif
		};

		// we will deprecate this message soon. please use the message and format SIDEGAME_MSG_START_GAME_NEW
		struct Protocol_SIDEGAME_MSG_START_GAME	// GC->GS
		{
			// 84184b8b - requestId,minigameId,gameType,gameId,entryId,useGameTicket,gameTicketId,autoPlay
			INT64 requestId;
			UINT32 minigameId;	// instance of sidegame definition to request
			INT8 gameType;	// 0: Table, 1: Zoom
			UINT64 gameId;	// TableId or BlitzId
			UINT32 entryId;	// for Zoom
			bool useGameTicket;
			UINT64 gameTicketId;	// only if useTicket is set
			bool autoPlay;

			Protocol_SIDEGAME_MSG_START_GAME();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_START_GAME&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_START_GAME; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_START_GAME"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_START_GAME_REPLY	// GS->GC
		{
			// 82[s|M(84184M()88)M(84)]4 - requestId,errCode[errString|M(minigamePlayId,minigameId,gameType,gameId,entryId,M(),ringSessionId,subGameId),M(gameTicketId,playsRemaining)],playsRemaining
			INT64 requestId;	// return value received in MINIGAME_MSG_START_GAME
			INT16 errCode;	// 1: not a player, 2: not applicable to this table, 3: already started

			PString errString;	// hopefully localized error string

			SideGameState state;
			GameTicketState gameTicketState;

			INT32 playsRemaining;

			Protocol_SIDEGAME_MSG_START_GAME_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_START_GAME_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_START_GAME_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_START_GAME_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_START_GAME_REPLY(Protocol_SIDEGAME_MSG_START_GAME_REPLY&&);
			Protocol_SIDEGAME_MSG_START_GAME_REPLY& operator=(Protocol_SIDEGAME_MSG_START_GAME_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_START_GAME_REPLY(const Protocol_SIDEGAME_MSG_START_GAME_REPLY&) = default;
			Protocol_SIDEGAME_MSG_START_GAME_REPLY& operator=(const Protocol_SIDEGAME_MSG_START_GAME_REPLY&) = default;
#endif
#endif
		};

		enum SideGameEntryMode
		{
			eSideGameEntryMode_Normal                  = 0,
			eSideGameEntryMode_GameTicket              = 1,		// player is using a gameticket to play this game. minigameEntryRefId is gameTicketId
			eSideGameEntryMode_CVLBar                  = 2,		// player is using a cross-vertical-loyalty bar to open a chest. minigameEntryRefId is barId
			eSideGameEntryMode_GameTicketStackedByGame = 3,		// player is using a gameticket chosen by MGLobby to play this game. minigameEntryRefId is 0 since minigameId is in start game message
			eSideGameEntryMode_GameTicketStackedByType = 4,		// player is using a gameticket chosen by MGLobby to play this game. minigameEntryRefId is gameTicketTypeId

			eSideGameEntryMode_Max                     = eSideGameEntryMode_GameTicketStackedByType 	// must be kept up-to-date
		};

		struct SuitRaceEntryMetaData
		{
			// M(1) - M(chosenSuit)
			BYTE chosenSuit;

			SuitRaceEntryMetaData();
			void clear();
			bool equals(const SuitRaceEntryMetaData&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct PickAnObjectEntryMetaData
		{
			// M(1) - M(prizeIndexPicked)
			INT8 prizeIndexPicked;

			PickAnObjectEntryMetaData();
			void clear();
			bool equals(const PickAnObjectEntryMetaData&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct PokerSideBetEntryMetaData
		{
			// M(28) - M(betType,betAmount)
			INT16 betType;	// ePokerSideBetType_
			INT64 betAmount;

			PokerSideBetEntryMetaData();
			void clear();
			bool equals(const PokerSideBetEntryMetaData&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_START_GAME_NEW	// GC->GS
		{
			// 8418418bM()88 - requestId,minigameId,gameType,gameId,entryId,minigameEntryMode,minigameEntryRefId,autoPlay,M(),ringSessionId,subGameId
			INT64 requestId;
			UINT32 minigameId;	// instance of sidegame definition to request
			INT8 gameType;	// 0: Table, 1: Zoom
			UINT64 gameId;	// TableId or BlitzId
			UINT32 entryId;	// for Zoom
			INT8 minigameEntryMode;	// see SideGameEntryMode enum
			UINT64 minigameEntryRefId;	// depends on minigameEntryMode
			bool autoPlay;
			ThinAtf::CopyableMsgBody sideGameEntryMetaData;	// (maxsize=1Mb)
			UINT64 ringSessionId;
			UINT64 subGameId;	// id of a child object of gameId, e.g., tableId of table in a tournament

			Protocol_SIDEGAME_MSG_START_GAME_NEW();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_START_GAME_NEW&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_START_GAME_NEW; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_START_GAME_NEW"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_START_GAME_NEW(Protocol_SIDEGAME_MSG_START_GAME_NEW&&);
			Protocol_SIDEGAME_MSG_START_GAME_NEW& operator=(Protocol_SIDEGAME_MSG_START_GAME_NEW&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_START_GAME_NEW(const Protocol_SIDEGAME_MSG_START_GAME_NEW&) = default;
			Protocol_SIDEGAME_MSG_START_GAME_NEW& operator=(const Protocol_SIDEGAME_MSG_START_GAME_NEW&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_ACTIVE_GAMES
		{
			// 81[18488] - requestId,useEntryFilter[gameType,gameId,entryId,ringSessionId,subGameId]
			INT64 requestId;
			BYTE useEntryFilter;	// if set, server will filter to games for a specific table or blitz entry

			INT8 gameType;	// 0: Table, 1: Zoom
			UINT64 gameId;	// TableId or BlitzId
			UINT32 entryId;	// for Zoom
			UINT64 ringSessionId;
			UINT64 subGameId;	// id of a child object of gameId, e.g., tableId of table in a tournament

			Protocol_SIDEGAME_MSG_ACTIVE_GAMES();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_ACTIVE_GAMES; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_ACTIVE_GAMES"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_ACTIVE_GAMES(Protocol_SIDEGAME_MSG_ACTIVE_GAMES&&);
			Protocol_SIDEGAME_MSG_ACTIVE_GAMES& operator=(Protocol_SIDEGAME_MSG_ACTIVE_GAMES&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_ACTIVE_GAMES(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES&) = default;
			Protocol_SIDEGAME_MSG_ACTIVE_GAMES& operator=(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY
		{
			// 82[s|M(4<M(84184M()88)>)M(4<M(44)>)b] - requestId,errCode[errStr|M(numStates<M(minigamePlayId,minigameId,gameType,gameId,entryId,M(),ringSessionId,subGameId)>),M(numMaxGamesReached<M(minigameId,expirationTime)>),hasHistoricGames]
			INT64 requestId;	// return value received in MINIGAME_MSG_ACTIVE_GAMES
			INT16 errCode;

			PString errStr;

			ThinAtf::LAtfVector< SideGameState , 4 > states;

			ThinAtf::LAtfVector< MaxGamesReachedEntry , 4 > maxGamesReached;

			bool hasHistoricGames;	// only populated if useEntryFilter was set in request

			Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_ACTIVE_GAMES_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_ACTIVE_GAMES_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY(Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY&&);
			Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY& operator=(Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY&) = default;
			Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY& operator=(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY&) = default;
#endif
#endif

		private: // helper functions
			void parseAnonymousMsgBody0(CommMsgParser& _parser);
			static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
			void parseAnonymousMsgBody1(CommMsgParser& _parser);
			static void validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_GAME_STATE
		{
			// 88 - requestId,minigamePlayId
			INT64 requestId;
			UINT64 minigamePlayId;

			Protocol_SIDEGAME_MSG_GAME_STATE();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GAME_STATE&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GAME_STATE; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GAME_STATE"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_GAME_STATE_REPLY
		{
			// 82[s|M(84184M()88)b] - requestId,errCode[errStr|M(minigamePlayId,minigameId,gameType,gameId,entryId,M(),ringSessionId,subGameId),hasHistoricGames]
			INT64 requestId;	// return value received in MINIGAME_MSG_PLAY_NEXT_ROUND or MINIGAME_MSG_GAME_STATE, or 0 for push notifications
			INT16 errCode;

			PString errStr;

			SideGameState state;
			bool hasHistoricGames;

			Protocol_SIDEGAME_MSG_GAME_STATE_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GAME_STATE_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GAME_STATE_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GAME_STATE_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_GAME_STATE_REPLY(Protocol_SIDEGAME_MSG_GAME_STATE_REPLY&&);
			Protocol_SIDEGAME_MSG_GAME_STATE_REPLY& operator=(Protocol_SIDEGAME_MSG_GAME_STATE_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_GAME_STATE_REPLY(const Protocol_SIDEGAME_MSG_GAME_STATE_REPLY&) = default;
			Protocol_SIDEGAME_MSG_GAME_STATE_REPLY& operator=(const Protocol_SIDEGAME_MSG_GAME_STATE_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED
		{
			// 8 - requestId
			INT64 requestId;

			Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_MAX_GAMES_REACHED; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_MAX_GAMES_REACHED"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY
		{
			// 82[s|4<M(44)>] - requestId,errCode[errStr|numMaxGamesReached<M(minigameId,expirationTime)>]
			INT64 requestId;	// return value received in SIDEGAME_MSG_MAX_GAMES_REACHED, or 0 for push notifications
			INT16 errCode;

			PString errStr;

			ThinAtf::LAtfVector< MaxGamesReachedEntry , 4 > maxGamesReached;

			Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY(Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY&&);
			Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY& operator=(Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY(const Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY&) = default;
			Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY& operator=(const Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_CLAIM_PRIZE	// GC->GS
		{
			// 884 - requestId,minigamePlayId,prizeIndex
			INT64 requestId;
			UINT64 minigamePlayId;
			INT32 prizeIndex;	// future flexibility for prize choice within a prize bucket (use 0 for games without prize choice ie: CardMatch)

			Protocol_SIDEGAME_MSG_CLAIM_PRIZE();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_CLAIM_PRIZE&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_CLAIM_PRIZE; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_CLAIM_PRIZE"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY	// GS->GC
		{
			// 82[s|M(84184M()88)b] - requestId,errCode[errStr|M(minigamePlayId,minigameId,gameType,gameId,entryId,M(),ringSessionId,subGameId),hasHistoricGames]
			INT64 requestId;	// return value received in SIDEGAME_MSG_CLAIM_PRIZE
			INT16 errCode;

			PString errStr;

			SideGameState state;	// prize is a part of the SideGameState structure
			bool hasHistoricGames;

			Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_CLAIM_PRIZE_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_CLAIM_PRIZE_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY(Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY&&);
			Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY& operator=(Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY(const Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY&) = default;
			Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY& operator=(const Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_GAME_DEF	// GC->GS
		{
			// 844 - requestId,minigameId,gameTicketTypeId
			INT64 requestId;
			UINT32 minigameId;	// either minigameId or gameTicketTypeId should be specified, other should be set to 0
			UINT32 gameTicketTypeId;

			Protocol_SIDEGAME_MSG_GAME_DEF();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GAME_DEF&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GAME_DEF; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GAME_DEF"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_GAME_DEF_REPLY	// GS->GC
		{
			// 82[s|44M(444M(4s8)M(4<M(IM(4<M(4Is8bIss4<M(ss)>sI)>)4)>))M(44M(b4<s>)ssm)sM(ss)IIIsI] - requestId,errCode[errStr|gameStatus,minigameId,M(gameType,delayToPayout,delayToPayoutAutoplay,M(buyInType,currency,amount),M(numPrizeTable<M(prizeBucketName,M(numPrizes<M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)>),bucketOdds)>)),M(brand,site,M(excludeCountries,numCountries<countries>),criteria,tableCriteria,siteMaskEx),url,M(address,instance),clientDisplayName,clientDisplayInfo,clientDisplayInProgressTag,contentURLPrefix,clientDisplayGameDescription]
			INT64 requestId;	// return value received in SIDEGAME_MSG_CLAIM_PRIZE
			INT16 errCode;

			PString errStr;

			MiniGameTypeLeaf def;	// definition leaf for this minigameId

			Protocol_SIDEGAME_MSG_GAME_DEF_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GAME_DEF_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GAME_DEF_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GAME_DEF_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_GAME_DEF_REPLY(Protocol_SIDEGAME_MSG_GAME_DEF_REPLY&&);
			Protocol_SIDEGAME_MSG_GAME_DEF_REPLY& operator=(Protocol_SIDEGAME_MSG_GAME_DEF_REPLY&&);
		private:
			Protocol_SIDEGAME_MSG_GAME_DEF_REPLY(const Protocol_SIDEGAME_MSG_GAME_DEF_REPLY&);  // prohibit
			Protocol_SIDEGAME_MSG_GAME_DEF_REPLY& operator=(const Protocol_SIDEGAME_MSG_GAME_DEF_REPLY&);  // prohibit
#endif
		};

		struct Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED	// GC->GS
		{
			// 8444 - requestId,minigameId,gameTicketTypeId,gameType
			INT64 requestId;
			UINT32 minigameId;	// either minigameId or gameTicketTypeId or gameType should be specified, others should be set to 0
			UINT32 gameTicketTypeId;
			INT32 gameType;

			Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GAME_DEF_LOCALIZED; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GAME_DEF_LOCALIZED"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY	// GS->GC
		{
			// 82[s|44M(444M(4s8)M(4<M(sM(4<M(4ss8bsss4<M(ss)>ss)>)4)>)M())sssss] - requestId,errCode[errStr|gameStatus,minigameId,M(gameType,delayToPayout,delayToPayoutAutoplay,M(buyInType,currency,amount),M(numPrizeTable<M(prizeBucketName,M(numPrizes<M(prizeType,prizeName,currency,amount,isTopPrize,prizeDescription,imageURLPrefix,assetName,numPrizeProperties<M(name,value)>,clickToLaunchURL,clickToLaunchButtonText)>),bucketOdds)>),M()),clientDisplayName,clientDisplayInfo,clientDisplayInProgressTag,contentURLPrefix,clientDisplayGameDescription]
			INT64 requestId;	// return value received in SIDEGAME_MSG_GAME_DEF_LOCALIZED
			INT16 errCode;

			PString errStr;

			MiniGameDefLocalized def;	// definition leaf for this minigameId

			Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY(Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY&&);
			Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY& operator=(Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY&&);
		private:
			Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY(const Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY&);  // prohibit
			Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY& operator=(const Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY&);  // prohibit
#endif
		};

		struct Protocol_SIDEGAME_MSG_HISTORIC_GAMES
		{
			// 811[184]888 - requestId,maxHistoricPlays,useEntryFilter[gameType,gameId,entryId],gameTicketTypeId,ringSessionId,subGameId
			INT64 requestId;
			BYTE maxHistoricPlays;	// max number of plays to request
			BYTE useEntryFilter;	// if set, server will filter to games for a specific table or blitz entry

			INT8 gameType;	// 0: Table, 1: Zoom
			UINT64 gameId;	// TableId or BlitzId
			UINT32 entryId;	// for Zoom

			UINT64 gameTicketTypeId;	// if set, filters for games entered using this gameTicketTypeId
			UINT64 ringSessionId;	// only valid if useEntryFilter != 0
			UINT64 subGameId;	// only valid if useEntryFilter != 0: id of a child object of gameId, e.g., tableId of table in a tournament

			Protocol_SIDEGAME_MSG_HISTORIC_GAMES();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_HISTORIC_GAMES; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_HISTORIC_GAMES"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_HISTORIC_GAMES(Protocol_SIDEGAME_MSG_HISTORIC_GAMES&&);
			Protocol_SIDEGAME_MSG_HISTORIC_GAMES& operator=(Protocol_SIDEGAME_MSG_HISTORIC_GAMES&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_HISTORIC_GAMES(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES&) = default;
			Protocol_SIDEGAME_MSG_HISTORIC_GAMES& operator=(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY
		{
			// 82[s|M(4<M(84184M()88)>)] - requestId,errCode[errStr|M(numHistoricGames<M(minigamePlayId,minigameId,gameType,gameId,entryId,M(),ringSessionId,subGameId)>)]
			INT64 requestId;	// return value received in SIDEGAME_MSG_HISTORIC_GAMES
			INT16 errCode;

			PString errStr;

			ThinAtf::LAtfVector< SideGameState , 4 > historicGames;

			Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_HISTORIC_GAMES_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_HISTORIC_GAMES_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY(Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY&&);
			Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY& operator=(Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY&) = default;
			Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY& operator=(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY&) = default;
#endif
#endif

		private: // helper functions
			void parseAnonymousMsgBody0(CommMsgParser& _parser);
			static void validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_FORFEIT	// GC->GS
		{
			// 88 - requestId,minigamePlayId
			INT64 requestId;
			UINT64 minigamePlayId;

			Protocol_SIDEGAME_MSG_FORFEIT();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_FORFEIT&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_FORFEIT; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_FORFEIT"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_FORFEIT_REPLY	// GS->GC
		{
			// 82[s|M(84184M()88)b] - requestId,errCode[errStr|M(minigamePlayId,minigameId,gameType,gameId,entryId,M(),ringSessionId,subGameId),hasHistoricGames]
			INT64 requestId;	// return value received in SIDEGAME_MSG_FORFEIT
			INT16 errCode;

			PString errStr;

			SideGameState state;	// this will be the end state of the forfeited card
			bool hasHistoricGames;

			Protocol_SIDEGAME_MSG_FORFEIT_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_FORFEIT_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_FORFEIT_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_FORFEIT_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_FORFEIT_REPLY(Protocol_SIDEGAME_MSG_FORFEIT_REPLY&&);
			Protocol_SIDEGAME_MSG_FORFEIT_REPLY& operator=(Protocol_SIDEGAME_MSG_FORFEIT_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_FORFEIT_REPLY(const Protocol_SIDEGAME_MSG_FORFEIT_REPLY&) = default;
			Protocol_SIDEGAME_MSG_FORFEIT_REPLY& operator=(const Protocol_SIDEGAME_MSG_FORFEIT_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE	// GC->GS
		{
			// 88 - requestId,gameTicketId
			INT64 requestId;
			UINT64 gameTicketId;

			Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GET_TICKET_BALANCE; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GET_TICKET_BALANCE"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY	// GS->GC
		{
			// 82[s|4] - requestId,errCode[errStr|playsRemaining]
			INT64 requestId;
			INT16 errCode;

			PString errStr;

			INT32 playsRemaining;

			Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY(Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY&&);
			Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY& operator=(Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY(const Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY&) = default;
			Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY& operator=(const Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY&) = default;
#endif
#endif
		};

		struct MultiPurposeChestMetaData
		{
			// M(s1s) - M(logoName,chestSkin,customSkin)
			PString logoName;
			BYTE chestSkin;
			PString customSkin;

			MultiPurposeChestMetaData();
			void clear();
			bool equals(const MultiPurposeChestMetaData&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			MultiPurposeChestMetaData(MultiPurposeChestMetaData&&);
			MultiPurposeChestMetaData& operator=(MultiPurposeChestMetaData&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			MultiPurposeChestMetaData(const MultiPurposeChestMetaData&) = default;
			MultiPurposeChestMetaData& operator=(const MultiPurposeChestMetaData&) = default;
#endif
#endif
		};

		struct StarsRewardsChestMetaData
		{
			// M(4) - M(version)
			INT32 version;

			StarsRewardsChestMetaData();
			void clear();
			bool equals(const StarsRewardsChestMetaData&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR
		{
			// 88 - requestId,barId
			INT64 requestId;
			UINT64 barId;

			Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GET_STARSREWARDS_BAR; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GET_STARSREWARDS_BAR"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY
		{
			//! 82[s|841M()4< <FIXME>ChestAsset</FIXME> >] - requestId,errCode[errStr|barId,barTier,barType,M(),numAssets< <FIXME>ChestAsset</FIXME> >]
			INT64 requestId;
			INT16 errCode;

			PString errStr;

			UINT64 barId;
			INT32 barTier;
			INT8 barType;	//from BarTypes enum in minigamescommonprot.h
			ThinAtf::CopyableMsgBody metaData;

			ThinAtf::LAtfVector< ChestAsset, 4 > assets;	// PYR-123328

			Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY(Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY&&);
			Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY& operator=(Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY(const Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY&) = default;
			Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY& operator=(const Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_SKIP_DELAY
		{
			// 88 - requestId,minigamePlayId
			INT64 requestId;
			INT64 minigamePlayId;

			Protocol_SIDEGAME_MSG_SKIP_DELAY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_SKIP_DELAY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_SKIP_DELAY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_SKIP_DELAY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_GET_RING_SESSIONID
		{
			// 88 - requestId,tableId
			INT64 requestId;
			UINT64 tableId;

			Protocol_SIDEGAME_MSG_GET_RING_SESSIONID();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GET_RING_SESSIONID&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GET_RING_SESSIONID; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GET_RING_SESSIONID"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY
		{
			// 82[s|8] - requestId,errCode[errStr|ringSessionId]
			INT64 requestId;
			INT16 errCode;

			PString errStr;

			UINT64 ringSessionId;

			Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_GET_RING_SESSIONID_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_GET_RING_SESSIONID_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY(Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY&&);
			Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY& operator=(Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY(const Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY&) = default;
			Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY& operator=(const Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_CANCEL_PLAY	// GC->GS
		{
			// 88 - requestId,minigamePlayId
			INT64 requestId;
			UINT64 minigamePlayId;

			Protocol_SIDEGAME_MSG_CANCEL_PLAY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_CANCEL_PLAY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_CANCEL_PLAY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_CANCEL_PLAY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY	// GS->GC
		{
			// 82[s|M(84184M()88)b] - requestId,errCode[errStr|M(minigamePlayId,minigameId,gameType,gameId,entryId,M(),ringSessionId,subGameId),hasHistoricGames]
			INT64 requestId;
			INT16 errCode;

			PString errStr;

			SideGameState state;	// this will be the end state of the play
			bool hasHistoricGames;

			Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_CANCEL_PLAY_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_CANCEL_PLAY_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY(Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY&&);
			Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY& operator=(Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY(const Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY&) = default;
			Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY& operator=(const Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY&) = default;
#endif
#endif
		};

		struct SideGameContext
		{
			// M(418488) - M(minigameId,gameType,gameId,entryId,ringSessionId,subGameId)
			UINT32 minigameId;	// instance of sidegame definition we're interested in
			INT8 gameType;	// see enum MiniGameCommon::EntryType
			UINT64 gameId;	// TableId or BlitzId or TournamentId
			UINT32 entryId;	// for Zoom
			UINT64 ringSessionId;	// for table merge
			UINT64 subGameId;	// id of a child object of gameId, e.g., tableId of table in a tournament

			SideGameContext();
			void clear();
			bool equals(const SideGameContext&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);
		};

		enum SideGameAutoPlayFlags
		{
			eSideGameAutoPlay_SinglePlay      	= 0x0001, 	// if set, the autoPlay context should be interpreted as a single play
			eSideGameAutoPlay_Resolved        	= 0x0002, 	// if set, the plays for this autoplay have started and cannot be canceled
			eSideGameAutoPlay_Error           	= 0x0004, 	// if set, autoPlay context was stopped prematurely by the system due to an error
			eSideGameAutoPlay_Complete        	= 0x0008, 	// if set, this autoPlay context and all its minigame plays have completed
			eSideGameAutoPlay_Canceled        	= 0x0010, 	// if set, autoPlay context was stopped because of a non-error reason, e.g., player request, minigame play timeout, player not dealt in, etc.
			eSideGameAutoPlay_IsReplay        	= 0x0020, 	// if set, autoPlay context has made a replay request
			eSideGameAutoPlay_WinLimitExceeded	= 0x0040, 	// if set, autoPlay context was stopped because win limit was exceeded
			eSideGameAutoPlay_LossLimitExceeded	= 0x0080, 	// if set, autoPlay context was stopped because loss limit was exceeded
			eSideGameAutoPlay_PlayerLeft		= 0x0100, 	// if set, autoPlay context was stopped because player left the table/tournament
		};

		struct AutoPlayContextData
		{
			// M(118844<M()>4<8>4<8>4<8>) - M(numAutoPlaysRemainingToDisplay,numAutoPlays,singleWinThreshold,totalLossesThreshold,flags,numSideGameEntryMetaData<M()>,numPendingMGPlays<pendingMGPlays>,numStartedMGPlays<startedMGPlays>,numResolvedMGPlays<resolvedMGPlays>)
			INT8 numAutoPlaysRemainingToDisplay;	// number of autoPlays remaining to display on the client for this autoPlay context
			INT8 numAutoPlays;	// original numAutoPlays set by SIDEGAME_MSG_START_AUTOPLAY
			INT64 singleWinThreshold;	// original singleWinThreshold set by SIDEGAME_MSG_START_AUTOPLAY
			INT64 totalLossesThreshold;	// original totalLossesThreshold set by SIDEGAME_MSG_START_AUTOPLAY
			UINT32 flags;	// see enum SideGameAutoPlayFlags
			ThinAtf::LAtfVector< ThinAtf::CopyableMsgBody, 4 > sideGameEntryMetaData;	// original sideGameEntryMetaData set by SIDEGAME_MSG_START_AUTOPLAY
			ThinAtf::LAtfVector< UINT64, 4 > pendingMGPlays;	// vector of plays for future hands that haven't started yet
			ThinAtf::LAtfVector< UINT64, 4 > startedMGPlays;	// vector of plays that have started but have not yet been resolved
			ThinAtf::LAtfVector< UINT64, 4 > resolvedMGPlays;	// vector of plays that have been resolved (this is cleared after the end ends)

			AutoPlayContextData();
			void clear();
			bool equals(const AutoPlayContextData&) const;
			const char *toTraceString(PString& _str) const;
			void composeMsg(CommMsgBody& _msg) const;
			void parseMsg(CommMsgParser& _parser);
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			AutoPlayContextData(AutoPlayContextData&&);
			AutoPlayContextData& operator=(AutoPlayContextData&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			AutoPlayContextData(const AutoPlayContextData&) = default;
			AutoPlayContextData& operator=(const AutoPlayContextData&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_START_AUTOPLAY	// GC->GS
		{
			// 8M(418488)1818844<M()> - requestId,M(minigameId,gameType,gameId,entryId,ringSessionId,subGameId),minigameEntryMode,minigameEntryRefId,numAutoPlays,singleWinThreshold,totalLossesThreshold,flags,numSideGameEntryMetaData<M()>
			INT64 requestId;
			SideGameContext sideGameContext;
			INT8 minigameEntryMode;	// see SideGameEntryMode enum
			UINT64 minigameEntryRefId;	// depends on minigameEntryMode
			INT8 numAutoPlays;
			INT64 singleWinThreshold;
			INT64 totalLossesThreshold;
			UINT32 flags;	// see enum SideGameAutoPlayFlags
			ThinAtf::LAtfVector< ThinAtf::CopyableMsgBody, 4 > sideGameEntryMetaData;

			Protocol_SIDEGAME_MSG_START_AUTOPLAY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_START_AUTOPLAY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_START_AUTOPLAY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_START_AUTOPLAY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_START_AUTOPLAY(Protocol_SIDEGAME_MSG_START_AUTOPLAY&&);
			Protocol_SIDEGAME_MSG_START_AUTOPLAY& operator=(Protocol_SIDEGAME_MSG_START_AUTOPLAY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_START_AUTOPLAY(const Protocol_SIDEGAME_MSG_START_AUTOPLAY&) = default;
			Protocol_SIDEGAME_MSG_START_AUTOPLAY& operator=(const Protocol_SIDEGAME_MSG_START_AUTOPLAY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY	// GS->GC
		{
			// 82[s|M(118844<M()>4<8>4<8>4<8>)M(118844<M()>4<8>4<8>4<8>)] - requestId,errCode[errStr|M(numAutoPlaysRemainingToDisplay,numAutoPlays,singleWinThreshold,totalLossesThreshold,flags,numSideGameEntryMetaData<M()>,numPendingMGPlays<pendingMGPlays>,numStartedMGPlays<startedMGPlays>,numResolvedMGPlays<resolvedMGPlays>),M(numAutoPlaysRemainingToDisplay,numAutoPlays,singleWinThreshold,totalLossesThreshold,flags,numSideGameEntryMetaData<M()>,numPendingMGPlays<pendingMGPlays>,numStartedMGPlays<startedMGPlays>,numResolvedMGPlays<resolvedMGPlays>)]
			INT64 requestId;
			INT16 errCode;

			PString errStr;

			AutoPlayContextData autoPlayContextData;
			AutoPlayContextData orphanedAutoPlayContextData;	// previously created autoPlayContextData that is active on the current hand but has been deleted by the new autoPlayContextData which is effective from the next hand

			Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_START_AUTOPLAY_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_START_AUTOPLAY_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY&&);
			Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY& operator=(Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY(const Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY&) = default;
			Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY& operator=(const Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_STOP_AUTOPLAY	// GC->GS
		{
			// 8M(418488) - requestId,M(minigameId,gameType,gameId,entryId,ringSessionId,subGameId)
			INT64 requestId;
			SideGameContext sideGameContext;

			Protocol_SIDEGAME_MSG_STOP_AUTOPLAY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_STOP_AUTOPLAY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_STOP_AUTOPLAY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_STOP_AUTOPLAY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY	// GS->GC
		{
			// 82[s|1] - requestId,errCode[errStr|numPendingGamesCanceled]
			INT64 requestId;
			INT16 errCode;

			PString errStr;

			INT8 numPendingGamesCanceled;	// number of pending minigames canceled by this request

			Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_STOP_AUTOPLAY_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_STOP_AUTOPLAY_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY&&);
			Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY& operator=(Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY(const Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY&) = default;
			Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY& operator=(const Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_AUTOPLAY_STATE	// GC->GS
		{
			// 8M(418488) - requestId,M(minigameId,gameType,gameId,entryId,ringSessionId,subGameId)
			INT64 requestId;
			SideGameContext sideGameContext;

			Protocol_SIDEGAME_MSG_AUTOPLAY_STATE();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_AUTOPLAY_STATE&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_AUTOPLAY_STATE; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_AUTOPLAY_STATE"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY	// GS->GC
		{
			// 82[s|M(118844<M()>4<8>4<8>4<8>)M(118844<M()>4<8>4<8>4<8>)] - requestId,errCode[errStr|M(numAutoPlaysRemainingToDisplay,numAutoPlays,singleWinThreshold,totalLossesThreshold,flags,numSideGameEntryMetaData<M()>,numPendingMGPlays<pendingMGPlays>,numStartedMGPlays<startedMGPlays>,numResolvedMGPlays<resolvedMGPlays>),M(numAutoPlaysRemainingToDisplay,numAutoPlays,singleWinThreshold,totalLossesThreshold,flags,numSideGameEntryMetaData<M()>,numPendingMGPlays<pendingMGPlays>,numStartedMGPlays<startedMGPlays>,numResolvedMGPlays<resolvedMGPlays>)]
			INT64 requestId;	// return value received in SIDEGAME_MSG_START_AUTOPLAY or SIDEGAME_MSG_AUTOPLAY_STATE, or 0 for push notifications
			INT16 errCode;

			PString errStr;

			AutoPlayContextData autoPlayContextData;
			AutoPlayContextData orphanedAutoPlayContextData;	// previously created autoPlayContextData that is active on the current hand but has been deleted by the new autoPlayContextData which is effective from the next hand

			Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_AUTOPLAY_STATE_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_AUTOPLAY_STATE_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY(Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY&&);
			Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY& operator=(Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY(const Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY&) = default;
			Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY& operator=(const Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY	// GC->GS
		{
			// 8M(418488) - requestId,M(minigameId,gameType,gameId,entryId,ringSessionId,subGameId)
			INT64 requestId;
			SideGameContext sideGameContext;

			Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_REPLAY_AUTOPLAY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_REPLAY_AUTOPLAY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY	// GS->GC
		{
			// 82[s] - requestId,errCode[errStr]
			INT64 requestId;
			INT16 errCode;

			PString errStr;

			Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY&&);
			Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY& operator=(Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY(const Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY&) = default;
			Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY& operator=(const Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY&) = default;
#endif
#endif
		};

		struct Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY	// GC->GS
		{
			// 8M(418488) - requestId,M(minigameId,gameType,gameId,entryId,ringSessionId,subGameId)
			INT64 requestId;
			SideGameContext sideGameContext;

			Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);
		};

		struct Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY	// GS->GC
		{
			// 82[s] - requestId,errCode[errStr]
			INT64 requestId;
			INT16 errCode;

			PString errStr;

			Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY();
			void clear();
			bool equals(const Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY&) const;
			const char *asTraceString(PString& _buf) const;
			void parseMsg(CommMsgParser& _parser);
			void composeMsg(CommMsgBody& _body) const;

			static UINT32 getMsgId() { return SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY; }
			static const char *getMsgIdString() { return "SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY"; }
			static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
			Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY&&);
			Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY& operator=(Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
			Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY(const Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY&) = default;
			Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY& operator=(const Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY&) = default;
#endif
#endif
		};
	};

	// PYR-120600
	struct Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW
	{
		// 844448ss4 - requestId,userIntId,brandId,clientSiteId,minigameId,ticketId,headerImageURL,ticketTypeName,playsAvailable
		INT64 requestId;	// for compatibility
		UINT32 userIntId;	// user to register
		UINT32 brandId;	// brand id
		UINT32 clientSiteId;	// clientSiteId id
		UINT32 minigameId;	// game id to register into
		UINT64 ticketId;	// ticket id to register with
		PString headerImageURL;	// ticket's headerImageURL
		PString ticketTypeName;	// ticket's ticketTypeName
		INT32 playsAvailable;	// how many time to register

		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW&&);
		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW& operator=(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW&) = default;
		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW& operator=(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW&) = default;
#endif
#endif
	};

	// PYR-120600
	struct Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY
	{
		// 82[s|4ts444] - requestId,errCode[errStr|minigameId,drawTime,userId,userTimeZone,userLocale,playsAvailable]
		INT64 requestId;
		INT16 errCode;

		PString errStr;

		UINT32 minigameId;	// game id
		SrvTime drawTime;	// fixed prize draw time
		PString userId;	// userId for registered user
		UINT32 userTimeZone;	// registered user preferred time zone
		UINT32 userLocale;	// registered user locale
		INT32 playsAvailable;	// how many time the user was registered

		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY();
		void clear();
		bool equals(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY&) const;
		const char *asTraceString(PString& _buf) const;
		void parseMsg(CommMsgParser& _parser);
		void composeMsg(CommMsgBody& _body) const;

		static UINT32 getMsgId() { return MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY; }
		static const char *getMsgIdString() { return "MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY"; }
		static void validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent);

#ifdef MOVE_CONSTRUCTOR_SUPPORTED
		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY&&);
		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY& operator=(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY&&);
#ifdef ATF_GENERATE_DEFAULT_COPYCONSTRUCTOR
		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY&) = default;
		Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY& operator=(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY&) = default;
#endif
#endif
	};
};

#endif
