/**
 * minigamesclientprot_thin.cpp
 *
 * This file was auto-generated from minigamesclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin minigamesclientprot.txt
 */
 
#include "minigamesclientprot_thin.h"

//=================================================================
//                    NameValuePair
//=================================================================

MiniGameClient::NameValuePair::NameValuePair()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::NameValuePair::NameValuePair(NameValuePair&& _o)
	: name(std::move(_o.name))
	, value(std::move(_o.value))
{
}

MiniGameClient::NameValuePair& MiniGameClient::NameValuePair::operator=(NameValuePair&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		value = std::move(_o.value);
	}
	return *this;
}

#endif

void MiniGameClient::NameValuePair::clear()
{
	name.clear();
	value.clear();
}

bool MiniGameClient::NameValuePair::equals(const NameValuePair& _o) const
{
	return name.equals(_o.name) &&
		value.equals(_o.value);
}

const char *MiniGameClient::NameValuePair::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::NameValuePair::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(NameValuePair())) // not empty
	{
		_body.composeString(name);
		_body.composeString(value);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::NameValuePair::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	_parser0.parseStringP(value);
}

/*static*/ void MiniGameClient::NameValuePair::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "value"); size_t szValue = strlen(_dummy);
	AtfValidator::validateInt(_descr, "value", szValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGamePrize
//=================================================================

MiniGameClient::MiniGamePrize::MiniGamePrize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGamePrize::MiniGamePrize(MiniGamePrize&& _o)
	: prizeType(std::move(_o.prizeType))
	, prizeName(std::move(_o.prizeName))
	, currency(std::move(_o.currency))
	, amount(std::move(_o.amount))
	, isTopPrize(std::move(_o.isTopPrize))
	, prizeDescription(std::move(_o.prizeDescription))
	, imageURLPrefix(std::move(_o.imageURLPrefix))
	, assetName(std::move(_o.assetName))
	, prizeProperties(std::move(_o.prizeProperties))
	, clickToLaunchURL(std::move(_o.clickToLaunchURL))
	, clickToLaunchButtonText(std::move(_o.clickToLaunchButtonText))
{
}

MiniGameClient::MiniGamePrize& MiniGameClient::MiniGamePrize::operator=(MiniGamePrize&& _o)
{
	if(this != &_o)
	{
		prizeType = std::move(_o.prizeType);
		prizeName = std::move(_o.prizeName);
		currency = std::move(_o.currency);
		amount = std::move(_o.amount);
		isTopPrize = std::move(_o.isTopPrize);
		prizeDescription = std::move(_o.prizeDescription);
		imageURLPrefix = std::move(_o.imageURLPrefix);
		assetName = std::move(_o.assetName);
		prizeProperties = std::move(_o.prizeProperties);
		clickToLaunchURL = std::move(_o.clickToLaunchURL);
		clickToLaunchButtonText = std::move(_o.clickToLaunchButtonText);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGamePrize::clear()
{
	prizeType = 0;
	prizeName.clear();
	currency.clear();
	amount = 0;
	isTopPrize = false;
	prizeDescription.clear();
	imageURLPrefix.clear();
	assetName.clear();
	prizeProperties.clear();
	clickToLaunchURL.clear();
	clickToLaunchButtonText.clear();
}

bool MiniGameClient::MiniGamePrize::equals(const MiniGamePrize& _o) const
{
	return prizeType == _o.prizeType &&
		prizeName.equals(_o.prizeName) &&
		currency.equals(_o.currency) &&
		amount == _o.amount &&
		isTopPrize == _o.isTopPrize &&
		prizeDescription.equals(_o.prizeDescription) &&
		imageURLPrefix.equals(_o.imageURLPrefix) &&
		assetName.equals(_o.assetName) &&
		prizeProperties.equals(_o.prizeProperties) &&
		clickToLaunchURL.equals(_o.clickToLaunchURL) &&
		clickToLaunchButtonText.equals(_o.clickToLaunchButtonText);
}

const char *MiniGameClient::MiniGamePrize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeType=");
	_buf.appendInt(prizeType);
	_buf.append(',');
	_buf.append("prizeName=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, prizeName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append(',');
	_buf.append("isTopPrize=");
	_buf.appendUint(isTopPrize);
	_buf.append(',');
	_buf.append("prizeDescription=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, prizeDescription);
	_buf.append(',');
	_buf.append("imageURLPrefix=");
	_buf.append(imageURLPrefix);
	_buf.append(',');
	_buf.append("assetName=");
	_buf.append(assetName);
	_buf.append(',');
	_buf.append("prizeProperties=");
	prizeProperties.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clickToLaunchURL=");
	_buf.append(clickToLaunchURL);
	_buf.append(',');
	_buf.append("clickToLaunchButtonText=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, clickToLaunchButtonText);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGamePrize::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGamePrize())) // not empty
	{
		_body.composeINT32(prizeType);
		prizeName.compose(_body);
		_body.composeString(currency);
		_body.composeINT64(amount);
		_body.composeBOOL(isTopPrize);
		prizeDescription.compose(_body);
		_body.composeString(imageURLPrefix);
		_body.composeString(assetName);
		prizeProperties.composeMsg(_body);
		_body.composeString(clickToLaunchURL);
		clickToLaunchButtonText.compose(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGamePrize::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(prizeType);
	prizeName.parse(_parser0);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(amount);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(isTopPrize);
	if(_parser0.parseEnded()) return;
	prizeDescription.parse(_parser0);
	_parser0.parseStringP(imageURLPrefix);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(assetName);
	if(_parser0.parseEnded()) return;
	prizeProperties.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clickToLaunchURL);
	clickToLaunchButtonText.parse(_parser0);
}

/*static*/ void MiniGameClient::MiniGamePrize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 prizeType; _parser0.parseINT32(prizeType);
	AtfValidator::validateInt(_descr, "prizeType", prizeType, _checker, __FILE__, __LINE__);
	I18nPString prizeName; prizeName.parse(_parser0);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool isTopPrize; _parser0.parseBOOL(isTopPrize);
	AtfValidator::validateInt(_descr, "isTopPrize", isTopPrize, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	I18nPString prizeDescription; prizeDescription.parse(_parser0);
	_parser0.parseStringN(_dummy, 0, "imageURLPrefix"); size_t szImageURLPrefix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "imageURLPrefix", szImageURLPrefix, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "assetName"); size_t szAssetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "assetName", szAssetName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szPrizeProperties = ThinAtf::LAtfVector< NameValuePair, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeProperties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeProperties", szPrizeProperties, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clickToLaunchURL"); size_t szClickToLaunchURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clickToLaunchURL", szClickToLaunchURL, _checker, __FILE__, __LINE__);
	I18nPString clickToLaunchButtonText; clickToLaunchButtonText.parse(_parser0);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGamePrizeLocalized
//=================================================================

MiniGameClient::MiniGamePrizeLocalized::MiniGamePrizeLocalized()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGamePrizeLocalized::MiniGamePrizeLocalized(MiniGamePrizeLocalized&& _o)
	: prizeType(std::move(_o.prizeType))
	, prizeName(std::move(_o.prizeName))
	, currency(std::move(_o.currency))
	, amount(std::move(_o.amount))
	, isTopPrize(std::move(_o.isTopPrize))
	, prizeDescription(std::move(_o.prizeDescription))
	, imageURLPrefix(std::move(_o.imageURLPrefix))
	, assetName(std::move(_o.assetName))
	, prizeProperties(std::move(_o.prizeProperties))
	, clickToLaunchURL(std::move(_o.clickToLaunchURL))
	, clickToLaunchButtonText(std::move(_o.clickToLaunchButtonText))
{
}

MiniGameClient::MiniGamePrizeLocalized& MiniGameClient::MiniGamePrizeLocalized::operator=(MiniGamePrizeLocalized&& _o)
{
	if(this != &_o)
	{
		prizeType = std::move(_o.prizeType);
		prizeName = std::move(_o.prizeName);
		currency = std::move(_o.currency);
		amount = std::move(_o.amount);
		isTopPrize = std::move(_o.isTopPrize);
		prizeDescription = std::move(_o.prizeDescription);
		imageURLPrefix = std::move(_o.imageURLPrefix);
		assetName = std::move(_o.assetName);
		prizeProperties = std::move(_o.prizeProperties);
		clickToLaunchURL = std::move(_o.clickToLaunchURL);
		clickToLaunchButtonText = std::move(_o.clickToLaunchButtonText);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGamePrizeLocalized::clear()
{
	prizeType = 0;
	prizeName.clear();
	currency.clear();
	amount = 0;
	isTopPrize = false;
	prizeDescription.clear();
	imageURLPrefix.clear();
	assetName.clear();
	prizeProperties.clear();
	clickToLaunchURL.clear();
	clickToLaunchButtonText.clear();
}

bool MiniGameClient::MiniGamePrizeLocalized::equals(const MiniGamePrizeLocalized& _o) const
{
	return prizeType == _o.prizeType &&
		prizeName.equals(_o.prizeName) &&
		currency.equals(_o.currency) &&
		amount == _o.amount &&
		isTopPrize == _o.isTopPrize &&
		prizeDescription.equals(_o.prizeDescription) &&
		imageURLPrefix.equals(_o.imageURLPrefix) &&
		assetName.equals(_o.assetName) &&
		prizeProperties.equals(_o.prizeProperties) &&
		clickToLaunchURL.equals(_o.clickToLaunchURL) &&
		clickToLaunchButtonText.equals(_o.clickToLaunchButtonText);
}

const char *MiniGameClient::MiniGamePrizeLocalized::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeType=");
	_buf.appendInt(prizeType);
	_buf.append(',');
	_buf.append("prizeName=");
	_buf.append(prizeName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append(',');
	_buf.append("isTopPrize=");
	_buf.appendUint(isTopPrize);
	_buf.append(',');
	_buf.append("prizeDescription=");
	_buf.append(prizeDescription);
	_buf.append(',');
	_buf.append("imageURLPrefix=");
	_buf.append(imageURLPrefix);
	_buf.append(',');
	_buf.append("assetName=");
	_buf.append(assetName);
	_buf.append(',');
	_buf.append("prizeProperties=");
	prizeProperties.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clickToLaunchURL=");
	_buf.append(clickToLaunchURL);
	_buf.append(',');
	_buf.append("clickToLaunchButtonText=");
	_buf.append(clickToLaunchButtonText);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGamePrizeLocalized::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGamePrizeLocalized())) // not empty
	{
		_body.composeINT32(prizeType);
		_body.composeString(prizeName);
		_body.composeString(currency);
		_body.composeINT64(amount);
		_body.composeBOOL(isTopPrize);
		_body.composeString(prizeDescription);
		_body.composeString(imageURLPrefix);
		_body.composeString(assetName);
		prizeProperties.composeMsg(_body);
		_body.composeString(clickToLaunchURL);
		_body.composeString(clickToLaunchButtonText);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGamePrizeLocalized::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(prizeType);
	_parser0.parseStringP(prizeName);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(amount);
	_parser0.parseBOOL(isTopPrize);
	_parser0.parseStringP(prizeDescription);
	_parser0.parseStringP(imageURLPrefix);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(assetName);
	if(_parser0.parseEnded()) return;
	prizeProperties.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clickToLaunchURL);
	_parser0.parseStringP(clickToLaunchButtonText);
}

/*static*/ void MiniGameClient::MiniGamePrizeLocalized::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 prizeType; _parser0.parseINT32(prizeType);
	AtfValidator::validateInt(_descr, "prizeType", prizeType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "prizeName"); size_t szPrizeName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "prizeName", szPrizeName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	bool isTopPrize; _parser0.parseBOOL(isTopPrize);
	AtfValidator::validateInt(_descr, "isTopPrize", isTopPrize, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "prizeDescription"); size_t szPrizeDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "prizeDescription", szPrizeDescription, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "imageURLPrefix"); size_t szImageURLPrefix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "imageURLPrefix", szImageURLPrefix, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "assetName"); size_t szAssetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "assetName", szAssetName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szPrizeProperties = ThinAtf::LAtfVector< NameValuePair, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeProperties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeProperties", szPrizeProperties, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clickToLaunchURL"); size_t szClickToLaunchURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clickToLaunchURL", szClickToLaunchURL, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clickToLaunchButtonText"); size_t szClickToLaunchButtonText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clickToLaunchButtonText", szClickToLaunchButtonText, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGamePrizeBucket
//=================================================================

MiniGameClient::MiniGamePrizeBucket::MiniGamePrizeBucket()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGamePrizeBucket::MiniGamePrizeBucket(MiniGamePrizeBucket&& _o)
	: prizeBucketName(std::move(_o.prizeBucketName))
	, prizes(std::move(_o.prizes))
	, bucketOdds(std::move(_o.bucketOdds))
{
}

MiniGameClient::MiniGamePrizeBucket& MiniGameClient::MiniGamePrizeBucket::operator=(MiniGamePrizeBucket&& _o)
{
	if(this != &_o)
	{
		prizeBucketName = std::move(_o.prizeBucketName);
		prizes = std::move(_o.prizes);
		bucketOdds = std::move(_o.bucketOdds);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGamePrizeBucket::clear()
{
	prizeBucketName.clear();
	prizes.clear();
	bucketOdds = 0;
}

bool MiniGameClient::MiniGamePrizeBucket::equals(const MiniGamePrizeBucket& _o) const
{
	return prizeBucketName.equals(_o.prizeBucketName) &&
		prizes.equals(_o.prizes) &&
		bucketOdds == _o.bucketOdds;
}

const char *MiniGameClient::MiniGamePrizeBucket::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeBucketName=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, prizeBucketName);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bucketOdds=");
	_buf.appendInt(bucketOdds);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGamePrizeBucket::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGamePrizeBucket())) // not empty
	{
		prizeBucketName.compose(_body);
		CommMsgBody _body0;
		prizes.composeMsg(_body0);
		_body.composeMsgBody(_body0);
		_body.composeINT32(bucketOdds);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGamePrizeBucket::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	prizeBucketName.parse(_parser0);
	parseAnonymousMsgBody0(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(bucketOdds);
}

/*static*/ void MiniGameClient::MiniGamePrizeBucket::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	I18nPString prizeBucketName; prizeBucketName.parse(_parser0);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	INT32 bucketOdds; _parser0.parseINT32(bucketOdds);
	AtfValidator::validateInt(_descr, "bucketOdds", bucketOdds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGamePrizeBucket::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	prizes.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGamePrizeBucket::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPrizes = ThinAtf::LAtfVector< MiniGamePrize , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGamePrizeBucketLocalized
//=================================================================

MiniGameClient::MiniGamePrizeBucketLocalized::MiniGamePrizeBucketLocalized()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGamePrizeBucketLocalized::MiniGamePrizeBucketLocalized(MiniGamePrizeBucketLocalized&& _o)
	: prizeBucketName(std::move(_o.prizeBucketName))
	, prizes(std::move(_o.prizes))
	, bucketOdds(std::move(_o.bucketOdds))
{
}

MiniGameClient::MiniGamePrizeBucketLocalized& MiniGameClient::MiniGamePrizeBucketLocalized::operator=(MiniGamePrizeBucketLocalized&& _o)
{
	if(this != &_o)
	{
		prizeBucketName = std::move(_o.prizeBucketName);
		prizes = std::move(_o.prizes);
		bucketOdds = std::move(_o.bucketOdds);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGamePrizeBucketLocalized::clear()
{
	prizeBucketName.clear();
	prizes.clear();
	bucketOdds = 0;
}

bool MiniGameClient::MiniGamePrizeBucketLocalized::equals(const MiniGamePrizeBucketLocalized& _o) const
{
	return prizeBucketName.equals(_o.prizeBucketName) &&
		prizes.equals(_o.prizes) &&
		bucketOdds == _o.bucketOdds;
}

const char *MiniGameClient::MiniGamePrizeBucketLocalized::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeBucketName=");
	_buf.append(prizeBucketName);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bucketOdds=");
	_buf.appendInt(bucketOdds);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGamePrizeBucketLocalized::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGamePrizeBucketLocalized())) // not empty
	{
		_body.composeString(prizeBucketName);
		CommMsgBody _body0;
		prizes.composeMsg(_body0);
		_body.composeMsgBody(_body0);
		_body.composeINT32(bucketOdds);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGamePrizeBucketLocalized::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(prizeBucketName);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseINT32(bucketOdds);
}

/*static*/ void MiniGameClient::MiniGamePrizeBucketLocalized::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "prizeBucketName"); size_t szPrizeBucketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "prizeBucketName", szPrizeBucketName, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 bucketOdds; _parser0.parseINT32(bucketOdds);
	AtfValidator::validateInt(_descr, "bucketOdds", bucketOdds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGamePrizeBucketLocalized::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	prizes.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGamePrizeBucketLocalized::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPrizes = ThinAtf::LAtfVector< MiniGamePrizeLocalized , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameBuyIn
//=================================================================

MiniGameClient::MiniGameBuyIn::MiniGameBuyIn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameBuyIn::MiniGameBuyIn(MiniGameBuyIn&& _o)
	: buyInType(std::move(_o.buyInType))
	, currency(std::move(_o.currency))
	, amount(std::move(_o.amount))
{
}

MiniGameClient::MiniGameBuyIn& MiniGameClient::MiniGameBuyIn::operator=(MiniGameBuyIn&& _o)
{
	if(this != &_o)
	{
		buyInType = std::move(_o.buyInType);
		currency = std::move(_o.currency);
		amount = std::move(_o.amount);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameBuyIn::clear()
{
	buyInType = 0;
	currency.clear();
	amount = 0;
}

bool MiniGameClient::MiniGameBuyIn::equals(const MiniGameBuyIn& _o) const
{
	return buyInType == _o.buyInType &&
		currency.equals(_o.currency) &&
		amount == _o.amount;
}

const char *MiniGameClient::MiniGameBuyIn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("buyInType=");
	_buf.appendInt(buyInType);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGameBuyIn::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameBuyIn())) // not empty
	{
		_body.composeINT32(buyInType);
		_body.composeString(currency);
		_body.composeINT64(amount);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameBuyIn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(buyInType);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(amount);
}

/*static*/ void MiniGameClient::MiniGameBuyIn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 buyInType; _parser0.parseINT32(buyInType);
	AtfValidator::validateInt(_descr, "buyInType", buyInType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameDefinition
//=================================================================

MiniGameClient::MiniGameDefinition::MiniGameDefinition()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameDefinition::MiniGameDefinition(MiniGameDefinition&& _o)
	: gameType(std::move(_o.gameType))
	, delayToPayout(std::move(_o.delayToPayout))
	, delayToPayoutAutoplay(std::move(_o.delayToPayoutAutoplay))
	, buyIn(std::move(_o.buyIn))
	, prizeTable(std::move(_o.prizeTable))
{
}

MiniGameClient::MiniGameDefinition& MiniGameClient::MiniGameDefinition::operator=(MiniGameDefinition&& _o)
{
	if(this != &_o)
	{
		gameType = std::move(_o.gameType);
		delayToPayout = std::move(_o.delayToPayout);
		delayToPayoutAutoplay = std::move(_o.delayToPayoutAutoplay);
		buyIn = std::move(_o.buyIn);
		prizeTable = std::move(_o.prizeTable);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameDefinition::clear()
{
	gameType = 0;
	delayToPayout = 0;
	delayToPayoutAutoplay = 0;
	buyIn.clear();
	prizeTable.clear();
}

bool MiniGameClient::MiniGameDefinition::equals(const MiniGameDefinition& _o) const
{
	return gameType == _o.gameType &&
		delayToPayout == _o.delayToPayout &&
		delayToPayoutAutoplay == _o.delayToPayoutAutoplay &&
		buyIn.equals(_o.buyIn) &&
		prizeTable.equals(_o.prizeTable);
}

const char *MiniGameClient::MiniGameDefinition::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("delayToPayout=");
	_buf.appendInt(delayToPayout);
	_buf.append(',');
	_buf.append("delayToPayoutAutoplay=");
	_buf.appendInt(delayToPayoutAutoplay);
	_buf.append(',');
	_buf.append("buyIn=");
	buyIn.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prizeTable=");
	prizeTable.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGameDefinition::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameDefinition())) // not empty
	{
		_body.composeINT32(gameType);
		_body.composeINT32(delayToPayout);
		_body.composeINT32(delayToPayoutAutoplay);
		buyIn.composeMsg(_body);
		CommMsgBody _body0;
		prizeTable.composeMsg(_body0);
		_body.composeMsgBody(_body0);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameDefinition::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(gameType);
	_parser0.parseINT32(delayToPayout);
	_parser0.parseINT32(delayToPayoutAutoplay);
	buyIn.parseMsg(_parser0);
	parseAnonymousMsgBody0(_parser0);
}

/*static*/ void MiniGameClient::MiniGameDefinition::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 gameType; _parser0.parseINT32(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	INT32 delayToPayout; _parser0.parseINT32(delayToPayout);
	AtfValidator::validateInt(_descr, "delayToPayout", delayToPayout, _checker, __FILE__, __LINE__);
	INT32 delayToPayoutAutoplay; _parser0.parseINT32(delayToPayoutAutoplay);
	AtfValidator::validateInt(_descr, "delayToPayoutAutoplay", delayToPayoutAutoplay, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGameBuyIn::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("buyIn"), _fieldsWithUnparsedContent);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGameDefinition::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	prizeTable.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameDefinition::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPrizeTable = ThinAtf::LAtfVector< MiniGamePrizeBucket , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeTable"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeTable", szPrizeTable, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameDefinitionLocalized
//=================================================================

MiniGameClient::MiniGameDefinitionLocalized::MiniGameDefinitionLocalized()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameDefinitionLocalized::MiniGameDefinitionLocalized(MiniGameDefinitionLocalized&& _o)
	: gameType(std::move(_o.gameType))
	, delayToPayout(std::move(_o.delayToPayout))
	, delayToPayoutAutoplay(std::move(_o.delayToPayoutAutoplay))
	, buyIn(std::move(_o.buyIn))
	, prizeTable(std::move(_o.prizeTable))
	, gameDefMsgBody(std::move(_o.gameDefMsgBody))
{
}

MiniGameClient::MiniGameDefinitionLocalized& MiniGameClient::MiniGameDefinitionLocalized::operator=(MiniGameDefinitionLocalized&& _o)
{
	if(this != &_o)
	{
		gameType = std::move(_o.gameType);
		delayToPayout = std::move(_o.delayToPayout);
		delayToPayoutAutoplay = std::move(_o.delayToPayoutAutoplay);
		buyIn = std::move(_o.buyIn);
		prizeTable = std::move(_o.prizeTable);
		gameDefMsgBody = std::move(_o.gameDefMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameDefinitionLocalized::clear()
{
	gameType = 0;
	delayToPayout = 0;
	delayToPayoutAutoplay = 0;
	buyIn.clear();
	prizeTable.clear();
	gameDefMsgBody.clear();
}

bool MiniGameClient::MiniGameDefinitionLocalized::equals(const MiniGameDefinitionLocalized& _o) const
{
	return gameType == _o.gameType &&
		delayToPayout == _o.delayToPayout &&
		delayToPayoutAutoplay == _o.delayToPayoutAutoplay &&
		buyIn.equals(_o.buyIn) &&
		prizeTable.equals(_o.prizeTable) &&
		gameDefMsgBody.equals(_o.gameDefMsgBody);
}

const char *MiniGameClient::MiniGameDefinitionLocalized::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("delayToPayout=");
	_buf.appendInt(delayToPayout);
	_buf.append(',');
	_buf.append("delayToPayoutAutoplay=");
	_buf.appendInt(delayToPayoutAutoplay);
	_buf.append(',');
	_buf.append("buyIn=");
	buyIn.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prizeTable=");
	prizeTable.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameDefMsgBody=");
	gameDefMsgBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGameDefinitionLocalized::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameDefinitionLocalized())) // not empty
	{
		_body.composeINT32(gameType);
		_body.composeINT32(delayToPayout);
		_body.composeINT32(delayToPayoutAutoplay);
		buyIn.composeMsg(_body);
		CommMsgBody _body0;
		prizeTable.composeMsg(_body0);
		_body.composeMsgBody(_body0);
		gameDefMsgBody.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameDefinitionLocalized::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(gameType);
	_parser0.parseINT32(delayToPayout);
	_parser0.parseINT32(delayToPayoutAutoplay);
	buyIn.parseMsg(_parser0);
	parseAnonymousMsgBody0(_parser0);
	if(_parser0.parseEnded()) return;
	gameDefMsgBody.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameDefinitionLocalized::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 gameType; _parser0.parseINT32(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	INT32 delayToPayout; _parser0.parseINT32(delayToPayout);
	AtfValidator::validateInt(_descr, "delayToPayout", delayToPayout, _checker, __FILE__, __LINE__);
	INT32 delayToPayoutAutoplay; _parser0.parseINT32(delayToPayoutAutoplay);
	AtfValidator::validateInt(_descr, "delayToPayoutAutoplay", delayToPayoutAutoplay, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGameBuyIn::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("buyIn"), _fieldsWithUnparsedContent);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	ThinAtf::MoveableMsgBody gameDefMsgBody; gameDefMsgBody.parseMsg(_parser0);
	AtfValidator::validateInt(_descr, "gameDefMsgBody", gameDefMsgBody._size(), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGameDefinitionLocalized::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	prizeTable.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameDefinitionLocalized::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPrizeTable = ThinAtf::LAtfVector< MiniGamePrizeBucketLocalized , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeTable"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeTable", szPrizeTable, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameVisibility
//=================================================================

// @Override
void MiniGameClient::MiniGameVisibility::parseAnonymousMsgBody0( CommMsgParser& _parser )
{
	CommMsgBody msgBody;
	_parser.parseMsgBody( msgBody );

	CommMsgParser parser( msgBody );
	parser.parseBOOL( excludeCountries );

	UINT32 size;
	parser.parseUINT32( size );
	if( size )
	{
		countries.resize( size );
		for( UINT32 i = 0; i < size; ++i )
		{
			parser.parseStringP( countries[ i ] );
			countries[ i ].toUpper();
		}

		std::sort( countries.begin(), countries.end(), PStringCmp() );
	}
	else
	{
		countries.clear();
	}
}

MiniGameClient::MiniGameVisibility::MiniGameVisibility()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameVisibility::MiniGameVisibility(MiniGameVisibility&& _o)
	: brand(std::move(_o.brand))
	, site(std::move(_o.site))
	, excludeCountries(std::move(_o.excludeCountries))
	, countries(std::move(_o.countries))
	, criteria(std::move(_o.criteria))
	, tableCriteria(std::move(_o.tableCriteria))
	, siteMaskEx(std::move(_o.siteMaskEx))
{
}

MiniGameClient::MiniGameVisibility& MiniGameClient::MiniGameVisibility::operator=(MiniGameVisibility&& _o)
{
	if(this != &_o)
	{
		brand = std::move(_o.brand);
		site = std::move(_o.site);
		excludeCountries = std::move(_o.excludeCountries);
		countries = std::move(_o.countries);
		criteria = std::move(_o.criteria);
		tableCriteria = std::move(_o.tableCriteria);
		siteMaskEx = std::move(_o.siteMaskEx);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameVisibility::clear()
{
	brand = 0;
	site = 0;
	excludeCountries = false;
	countries.clear();
	criteria.clear();
	tableCriteria.clear();
	siteMaskEx.clear();
}

bool MiniGameClient::MiniGameVisibility::equals(const MiniGameVisibility& _o) const
{
	return brand == _o.brand &&
		site == _o.site &&
		excludeCountries == _o.excludeCountries &&
		countries.equals(_o.countries) &&
		criteria.equals(_o.criteria) &&
		tableCriteria.equals(_o.tableCriteria) &&
		siteMaskEx.equals(_o.siteMaskEx);
}

const char *MiniGameClient::MiniGameVisibility::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("brand=");
	_buf.appendUint(brand);
	_buf.append(',');
	_buf.append("site=");
	_buf.appendUint(site);
	_buf.append(',');
	_buf.append("excludeCountries=");
	_buf.appendUint(excludeCountries);
	_buf.append(',');
	_buf.append("countries=");
	countries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("tableCriteria=");
	_buf.append(tableCriteria);
	_buf.append(',');
	_buf.append("siteMaskEx=");
	siteMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGameVisibility::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameVisibility())) // not empty
	{
		_body.composeUINT32(brand);
		_body.composeUINT32(site);
		CommMsgBody _body0;
		_body0.composeBOOL(excludeCountries);
		countries.composeMsg(_body0);
		_body.composeMsgBody(_body0);
		_body.composeString(criteria);
		_body.composeString(tableCriteria);
		siteMaskEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameVisibility::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(brand);
	_parser0.parseUINT32(site);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseStringP(criteria);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(tableCriteria);
	if(_parser0.parseEnded()) return;
	siteMaskEx.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameVisibility::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 brand; _parser0.parseUINT32(brand);
	AtfValidator::validateInt(_descr, "brand", brand, _checker, __FILE__, __LINE__);
	UINT32 site; _parser0.parseUINT32(site);
	AtfValidator::validateInt(_descr, "site", site, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "tableCriteria"); size_t szTableCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableCriteria", szTableCriteria, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("siteMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

/*static*/ void MiniGameClient::MiniGameVisibility::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool excludeCountries; _parser0.parseBOOL(excludeCountries);
	AtfValidator::validateInt(_descr, "excludeCountries", excludeCountries, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCountries = ThinAtf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameMetaData
//=================================================================

MiniGameClient::MiniGameMetaData::MiniGameMetaData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameMetaData::MiniGameMetaData(MiniGameMetaData&& _o)
	: metaData(std::move(_o.metaData))
{
}

MiniGameClient::MiniGameMetaData& MiniGameClient::MiniGameMetaData::operator=(MiniGameMetaData&& _o)
{
	if(this != &_o)
	{
		metaData = std::move(_o.metaData);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameMetaData::clear()
{
	metaData.clear();
}

bool MiniGameClient::MiniGameMetaData::equals(const MiniGameMetaData& _o) const
{
	return metaData.equals(_o.metaData);
}

const char *MiniGameClient::MiniGameMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("metaData=");
	metaData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGameMetaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameMetaData())) // not empty
	{
		metaData.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	metaData.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szMetaData = ThinAtf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("metaData"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "metaData", szMetaData, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameRound
//=================================================================

MiniGameClient::MiniGameRound::MiniGameRound()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameRound::MiniGameRound(MiniGameRound&& _o)
	: timestamp(std::move(_o.timestamp))
	, decisions(std::move(_o.decisions))
	, results(std::move(_o.results))
	, prizeBucket(std::move(_o.prizeBucket))
	, state(std::move(_o.state))
	, metaData(std::move(_o.metaData))
{
}

MiniGameClient::MiniGameRound& MiniGameClient::MiniGameRound::operator=(MiniGameRound&& _o)
{
	if(this != &_o)
	{
		timestamp = std::move(_o.timestamp);
		decisions = std::move(_o.decisions);
		results = std::move(_o.results);
		prizeBucket = std::move(_o.prizeBucket);
		state = std::move(_o.state);
		metaData = std::move(_o.metaData);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameRound::clear()
{
	timestamp = 0;
	decisions.clear();
	results.clear();
	prizeBucket = 0;
	state = 0;
	metaData.clear();
}

bool MiniGameClient::MiniGameRound::equals(const MiniGameRound& _o) const
{
	return timestamp == _o.timestamp &&
		decisions.equals(_o.decisions) &&
		results.equals(_o.results) &&
		prizeBucket == _o.prizeBucket &&
		state == _o.state &&
		metaData.equals(_o.metaData);
}

const char *MiniGameClient::MiniGameRound::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("decisions=");
	decisions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("results=");
	results.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prizeBucket=");
	_buf.appendInt(prizeBucket);
	_buf.append(',');
	_buf.append("state=");
	_buf.appendInt(state);
	_buf.append(',');
	_buf.append("metaData=");
	metaData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGameRound::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameRound())) // not empty
	{
		_body.composeINT32(timestamp);
		decisions.composeMsg(_body);
		results.composeMsg(_body);
		_body.composeINT32(prizeBucket);
		CommMsgBody _body0;
		_body0.composeINT32(state);
		metaData.composeMsg(_body0);
		_body.composeMsgBody(_body0);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameRound::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(timestamp);
	decisions.parseMsg(_parser0);
	results.parseMsg(_parser0);
	_parser0.parseINT32(prizeBucket);
	parseAnonymousMsgBody0(_parser0);
}

/*static*/ void MiniGameClient::MiniGameRound::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szDecisions = ThinAtf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("decisions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "decisions", szDecisions, _checker, __FILE__, __LINE__);
	int szResults = ThinAtf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("results"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "results", szResults, _checker, __FILE__, __LINE__);
	INT32 prizeBucket; _parser0.parseINT32(prizeBucket);
	AtfValidator::validateInt(_descr, "prizeBucket", prizeBucket, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGameRound::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(state);
	metaData.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameRound::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 state; _parser0.parseINT32(state);
	AtfValidator::validateInt(_descr, "state", state, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szMetaData = ThinAtf::LAtfVector< MiniGameMetaData , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("metaData"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "metaData", szMetaData, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameState
//=================================================================

MiniGameClient::MiniGameState::MiniGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameState::MiniGameState(MiniGameState&& _o)
	: minigamePlayId(std::move(_o.minigamePlayId))
	, minigameId(std::move(_o.minigameId))
	, rounds(std::move(_o.rounds))
{
}

MiniGameClient::MiniGameState& MiniGameClient::MiniGameState::operator=(MiniGameState&& _o)
{
	if(this != &_o)
	{
		minigamePlayId = std::move(_o.minigamePlayId);
		minigameId = std::move(_o.minigameId);
		rounds = std::move(_o.rounds);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameState::clear()
{
	minigamePlayId = 0;
	minigameId = 0;
	rounds.clear();
}

bool MiniGameClient::MiniGameState::equals(const MiniGameState& _o) const
{
	return minigamePlayId == _o.minigamePlayId &&
		minigameId == _o.minigameId &&
		rounds.equals(_o.rounds);
}

const char *MiniGameClient::MiniGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("rounds=");
	rounds.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGameState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameState())) // not empty
	{
		_body.composeUINT64(minigamePlayId);
		_body.composeUINT32(minigameId);
		CommMsgBody _body0;
		rounds.composeMsg(_body0);
		_body.composeMsgBody(_body0);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(minigamePlayId);
	_parser0.parseUINT32(minigameId);
	parseAnonymousMsgBody0(_parser0);
}

/*static*/ void MiniGameClient::MiniGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 minigamePlayId; _parser0.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGameState::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	rounds.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameState::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szRounds = ThinAtf::LAtfVector< MiniGameRound , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("rounds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "rounds", szRounds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MGConnInfo
//=================================================================

MiniGameClient::MGConnInfo::MGConnInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MGConnInfo::MGConnInfo(MGConnInfo&& _o)
	: address(std::move(_o.address))
	, instance(std::move(_o.instance))
{
}

MiniGameClient::MGConnInfo& MiniGameClient::MGConnInfo::operator=(MGConnInfo&& _o)
{
	if(this != &_o)
	{
		address = std::move(_o.address);
		instance = std::move(_o.instance);
	}
	return *this;
}

#endif

void MiniGameClient::MGConnInfo::clear()
{
	address.clear();
	instance.clear();
}

bool MiniGameClient::MGConnInfo::equals(const MGConnInfo& _o) const
{
	return address.equals(_o.address) &&
		instance.equals(_o.instance);
}

const char *MiniGameClient::MGConnInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("instance=");
	_buf.append(instance);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MGConnInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MGConnInfo())) // not empty
	{
		_body.composeString(address);
		_body.composeString(instance);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MGConnInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(address);
	_parser0.parseStringP(instance);
}

/*static*/ void MiniGameClient::MGConnInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "address", szAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "instance"); size_t szInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "instance", szInstance, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameTypeLeaf
//=================================================================

MiniGameClient::MiniGameTypeLeaf::MiniGameTypeLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameTypeLeaf::MiniGameTypeLeaf(MiniGameTypeLeaf&& _o)
	: gameStatus(std::move(_o.gameStatus))
	, minigameId(std::move(_o.minigameId))
	, minigameDef(std::move(_o.minigameDef))
	, visibility(std::move(_o.visibility))
	, url(std::move(_o.url))
	, mgConnInfo(std::move(_o.mgConnInfo))
	, clientDisplayName(std::move(_o.clientDisplayName))
	, clientDisplayInfo(std::move(_o.clientDisplayInfo))
	, clientDisplayInProgressTag(std::move(_o.clientDisplayInProgressTag))
	, contentURLPrefix(std::move(_o.contentURLPrefix))
	, clientDisplayGameDescription(std::move(_o.clientDisplayGameDescription))
{
}

MiniGameClient::MiniGameTypeLeaf& MiniGameClient::MiniGameTypeLeaf::operator=(MiniGameTypeLeaf&& _o)
{
	if(this != &_o)
	{
		gameStatus = std::move(_o.gameStatus);
		minigameId = std::move(_o.minigameId);
		minigameDef = std::move(_o.minigameDef);
		visibility = std::move(_o.visibility);
		url = std::move(_o.url);
		mgConnInfo = std::move(_o.mgConnInfo);
		clientDisplayName = std::move(_o.clientDisplayName);
		clientDisplayInfo = std::move(_o.clientDisplayInfo);
		clientDisplayInProgressTag = std::move(_o.clientDisplayInProgressTag);
		contentURLPrefix = std::move(_o.contentURLPrefix);
		clientDisplayGameDescription = std::move(_o.clientDisplayGameDescription);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameTypeLeaf::clear()
{
	gameStatus = 0;
	minigameId = 0;
	minigameDef.clear();
	visibility.clear();
	url.clear();
	mgConnInfo.clear();
	clientDisplayName.clear();
	clientDisplayInfo.clear();
	clientDisplayInProgressTag.clear();
	contentURLPrefix.clear();
	clientDisplayGameDescription.clear();
}

bool MiniGameClient::MiniGameTypeLeaf::equals(const MiniGameTypeLeaf& _o) const
{
	return gameStatus == _o.gameStatus &&
		minigameId == _o.minigameId &&
		minigameDef.equals(_o.minigameDef) &&
		visibility.equals(_o.visibility) &&
		url.equals(_o.url) &&
		mgConnInfo.equals(_o.mgConnInfo) &&
		clientDisplayName.equals(_o.clientDisplayName) &&
		clientDisplayInfo.equals(_o.clientDisplayInfo) &&
		clientDisplayInProgressTag.equals(_o.clientDisplayInProgressTag) &&
		contentURLPrefix.equals(_o.contentURLPrefix) &&
		clientDisplayGameDescription.equals(_o.clientDisplayGameDescription);
}

const char *MiniGameClient::MiniGameTypeLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameStatus=");
	_buf.appendInt(gameStatus);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("minigameDef=");
	minigameDef.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibility=");
	visibility.toTraceString(_buf);
	_buf.append(',');
	_buf.append("url=");
	_buf.append(url);
	_buf.append(',');
	_buf.append("mgConnInfo=");
	mgConnInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientDisplayName=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, clientDisplayName);
	_buf.append(',');
	_buf.append("clientDisplayInfo=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, clientDisplayInfo);
	_buf.append(',');
	_buf.append("clientDisplayInProgressTag=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, clientDisplayInProgressTag);
	_buf.append(',');
	_buf.append("contentURLPrefix=");
	_buf.append(contentURLPrefix);
	_buf.append(',');
	_buf.append("clientDisplayGameDescription=");
	ThinAtf::AtfTempl<I18nPString>::ToTraceString(_buf, clientDisplayGameDescription);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGameTypeLeaf::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(gameStatus);
	_msg.composeUINT32(minigameId);
	minigameDef.composeMsg(_msg);
	visibility.composeMsg(_msg);
	_msg.composeString(url);
	mgConnInfo.composeMsg(_msg);
	clientDisplayName.compose(_msg);
	clientDisplayInfo.compose(_msg);
	clientDisplayInProgressTag.compose(_msg);
	_msg.composeString(contentURLPrefix);
	clientDisplayGameDescription.compose(_msg);
}

void MiniGameClient::MiniGameTypeLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(gameStatus);
	_parser.parseUINT32(minigameId);
	minigameDef.parseMsg(_parser);
	visibility.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(url);
	mgConnInfo.parseMsg(_parser);
	clientDisplayName.parse(_parser);
	clientDisplayInfo.parse(_parser);
	if(_parser.parseEnded()) return;
	clientDisplayInProgressTag.parse(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(contentURLPrefix);
	if(_parser.parseEnded()) return;
	clientDisplayGameDescription.parse(_parser);
}

/*static*/ void MiniGameClient::MiniGameTypeLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 gameStatus; _parser.parseINT32(gameStatus);
	AtfValidator::validateInt(_descr, "gameStatus", gameStatus, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGameDefinition::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("minigameDef"), _fieldsWithUnparsedContent);
	MiniGameVisibility::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibility"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
	AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	MGConnInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("mgConnInfo"), _fieldsWithUnparsedContent);
	I18nPString clientDisplayName; clientDisplayName.parse(_parser);
	I18nPString clientDisplayInfo; clientDisplayInfo.parse(_parser);
	if(_parser.parseEnded()) return;
	I18nPString clientDisplayInProgressTag; clientDisplayInProgressTag.parse(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "contentURLPrefix"); size_t szContentURLPrefix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contentURLPrefix", szContentURLPrefix, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	I18nPString clientDisplayGameDescription; clientDisplayGameDescription.parse(_parser);
}

//=================================================================
//                    MiniGameDefLocalized
//=================================================================

MiniGameClient::MiniGameDefLocalized::MiniGameDefLocalized()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameDefLocalized::MiniGameDefLocalized(MiniGameDefLocalized&& _o)
	: gameStatus(std::move(_o.gameStatus))
	, minigameId(std::move(_o.minigameId))
	, minigameDef(std::move(_o.minigameDef))
	, clientDisplayName(std::move(_o.clientDisplayName))
	, clientDisplayInfo(std::move(_o.clientDisplayInfo))
	, clientDisplayInProgressTag(std::move(_o.clientDisplayInProgressTag))
	, contentURLPrefix(std::move(_o.contentURLPrefix))
	, clientDisplayGameDescription(std::move(_o.clientDisplayGameDescription))
{
}

MiniGameClient::MiniGameDefLocalized& MiniGameClient::MiniGameDefLocalized::operator=(MiniGameDefLocalized&& _o)
{
	if(this != &_o)
	{
		gameStatus = std::move(_o.gameStatus);
		minigameId = std::move(_o.minigameId);
		minigameDef = std::move(_o.minigameDef);
		clientDisplayName = std::move(_o.clientDisplayName);
		clientDisplayInfo = std::move(_o.clientDisplayInfo);
		clientDisplayInProgressTag = std::move(_o.clientDisplayInProgressTag);
		contentURLPrefix = std::move(_o.contentURLPrefix);
		clientDisplayGameDescription = std::move(_o.clientDisplayGameDescription);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameDefLocalized::clear()
{
	gameStatus = 0;
	minigameId = 0;
	minigameDef.clear();
	clientDisplayName.clear();
	clientDisplayInfo.clear();
	clientDisplayInProgressTag.clear();
	contentURLPrefix.clear();
	clientDisplayGameDescription.clear();
}

bool MiniGameClient::MiniGameDefLocalized::equals(const MiniGameDefLocalized& _o) const
{
	return gameStatus == _o.gameStatus &&
		minigameId == _o.minigameId &&
		minigameDef.equals(_o.minigameDef) &&
		clientDisplayName.equals(_o.clientDisplayName) &&
		clientDisplayInfo.equals(_o.clientDisplayInfo) &&
		clientDisplayInProgressTag.equals(_o.clientDisplayInProgressTag) &&
		contentURLPrefix.equals(_o.contentURLPrefix) &&
		clientDisplayGameDescription.equals(_o.clientDisplayGameDescription);
}

const char *MiniGameClient::MiniGameDefLocalized::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameStatus=");
	_buf.appendInt(gameStatus);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("minigameDef=");
	minigameDef.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientDisplayName=");
	_buf.append(clientDisplayName);
	_buf.append(',');
	_buf.append("clientDisplayInfo=");
	_buf.append(clientDisplayInfo);
	_buf.append(',');
	_buf.append("clientDisplayInProgressTag=");
	_buf.append(clientDisplayInProgressTag);
	_buf.append(',');
	_buf.append("contentURLPrefix=");
	_buf.append(contentURLPrefix);
	_buf.append(',');
	_buf.append("clientDisplayGameDescription=");
	_buf.append(clientDisplayGameDescription);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::MiniGameDefLocalized::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(gameStatus);
	_msg.composeUINT32(minigameId);
	minigameDef.composeMsg(_msg);
	_msg.composeString(clientDisplayName);
	_msg.composeString(clientDisplayInfo);
	_msg.composeString(clientDisplayInProgressTag);
	_msg.composeString(contentURLPrefix);
	_msg.composeString(clientDisplayGameDescription);
}

void MiniGameClient::MiniGameDefLocalized::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(gameStatus);
	_parser.parseUINT32(minigameId);
	minigameDef.parseMsg(_parser);
	_parser.parseStringP(clientDisplayName);
	_parser.parseStringP(clientDisplayInfo);
	_parser.parseStringP(clientDisplayInProgressTag);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(contentURLPrefix);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(clientDisplayGameDescription);
}

/*static*/ void MiniGameClient::MiniGameDefLocalized::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 gameStatus; _parser.parseINT32(gameStatus);
	AtfValidator::validateInt(_descr, "gameStatus", gameStatus, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGameDefinitionLocalized::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("minigameDef"), _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "clientDisplayName"); size_t szClientDisplayName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientDisplayName", szClientDisplayName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clientDisplayInfo"); size_t szClientDisplayInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientDisplayInfo", szClientDisplayInfo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clientDisplayInProgressTag"); size_t szClientDisplayInProgressTag = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientDisplayInProgressTag", szClientDisplayInProgressTag, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "contentURLPrefix"); size_t szContentURLPrefix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contentURLPrefix", szContentURLPrefix, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "clientDisplayGameDescription"); size_t szClientDisplayGameDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientDisplayGameDescription", szClientDisplayGameDescription, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TheDealJackpotLeaf
//=================================================================

MiniGameClient::TheDealJackpotLeaf::TheDealJackpotLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::TheDealJackpotLeaf::TheDealJackpotLeaf(TheDealJackpotLeaf&& _o)
	: jackpotCurrency(std::move(_o.jackpotCurrency))
	, jackpotAmount(std::move(_o.jackpotAmount))
	, jackpotWinnerPercentage(std::move(_o.jackpotWinnerPercentage))
	, jackpotShareEligibilityMins(std::move(_o.jackpotShareEligibilityMins))
	, visibility(std::move(_o.visibility))
{
}

MiniGameClient::TheDealJackpotLeaf& MiniGameClient::TheDealJackpotLeaf::operator=(TheDealJackpotLeaf&& _o)
{
	if(this != &_o)
	{
		jackpotCurrency = std::move(_o.jackpotCurrency);
		jackpotAmount = std::move(_o.jackpotAmount);
		jackpotWinnerPercentage = std::move(_o.jackpotWinnerPercentage);
		jackpotShareEligibilityMins = std::move(_o.jackpotShareEligibilityMins);
		visibility = std::move(_o.visibility);
	}
	return *this;
}

#endif

void MiniGameClient::TheDealJackpotLeaf::clear()
{
	jackpotCurrency.clear();
	jackpotAmount = 0;
	jackpotWinnerPercentage = 0;
	jackpotShareEligibilityMins = 0;
	visibility.clear();
}

bool MiniGameClient::TheDealJackpotLeaf::equals(const TheDealJackpotLeaf& _o) const
{
	return jackpotCurrency.equals(_o.jackpotCurrency) &&
		jackpotAmount == _o.jackpotAmount &&
		jackpotWinnerPercentage == _o.jackpotWinnerPercentage &&
		jackpotShareEligibilityMins == _o.jackpotShareEligibilityMins &&
		visibility.equals(_o.visibility);
}

const char *MiniGameClient::TheDealJackpotLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("jackpotCurrency=");
	_buf.append(jackpotCurrency);
	_buf.append(',');
	_buf.append("jackpotAmount=");
	_buf.appendInt64(jackpotAmount);
	_buf.append(',');
	_buf.append("jackpotWinnerPercentage=");
	_buf.appendInt(jackpotWinnerPercentage);
	_buf.append(',');
	_buf.append("jackpotShareEligibilityMins=");
	_buf.appendInt(jackpotShareEligibilityMins);
	_buf.append(',');
	_buf.append("visibility=");
	visibility.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::TheDealJackpotLeaf::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _msg0;
	_msg0.composeString(jackpotCurrency);
	_msg0.composeINT64(jackpotAmount);
	_msg0.composeINT32(jackpotWinnerPercentage);
	_msg0.composeINT32(jackpotShareEligibilityMins);
	_msg.composeMsgBody(_msg0);
	visibility.composeMsg(_msg);
}

void MiniGameClient::TheDealJackpotLeaf::parseMsg(CommMsgParser& _parser)
{
	parseAnonymousMsgBody0(_parser);
	visibility.parseMsg(_parser);
}

/*static*/ void MiniGameClient::TheDealJackpotLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	PString _descbuf;
	MiniGameVisibility::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibility"), _fieldsWithUnparsedContent);
}

void MiniGameClient::TheDealJackpotLeaf::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(jackpotCurrency);
	_parser0.parseINT64(jackpotAmount);
	_parser0.parseINT32(jackpotWinnerPercentage);
	_parser0.parseINT32(jackpotShareEligibilityMins);
}

/*static*/ void MiniGameClient::TheDealJackpotLeaf::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "jackpotCurrency"); size_t szJackpotCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "jackpotCurrency", szJackpotCurrency, _checker, __FILE__, __LINE__);
	INT64 jackpotAmount; _parser0.parseINT64(jackpotAmount);
	AtfValidator::validateInt(_descr, "jackpotAmount", jackpotAmount, _checker, __FILE__, __LINE__);
	INT32 jackpotWinnerPercentage; _parser0.parseINT32(jackpotWinnerPercentage);
	AtfValidator::validateInt(_descr, "jackpotWinnerPercentage", jackpotWinnerPercentage, _checker, __FILE__, __LINE__);
	INT32 jackpotShareEligibilityMins; _parser0.parseINT32(jackpotShareEligibilityMins);
	AtfValidator::validateInt(_descr, "jackpotShareEligibilityMins", jackpotShareEligibilityMins, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TheDealJackpotSpinLeaf
//=================================================================

MiniGameClient::TheDealJackpotSpinLeaf::TheDealJackpotSpinLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::TheDealJackpotSpinLeaf::TheDealJackpotSpinLeaf(TheDealJackpotSpinLeaf&& _o)
	: active(std::move(_o.active))
	, timestamp(std::move(_o.timestamp))
	, playerId(std::move(_o.playerId))
	, playerBrandImages(std::move(_o.playerBrandImages))
	, jackpotAmountInCents(std::move(_o.jackpotAmountInCents))
	, winnerShareAmount(std::move(_o.winnerShareAmount))
	, playerShareAmount(std::move(_o.playerShareAmount))
	, jackpotState(std::move(_o.jackpotState))
{
}

MiniGameClient::TheDealJackpotSpinLeaf& MiniGameClient::TheDealJackpotSpinLeaf::operator=(TheDealJackpotSpinLeaf&& _o)
{
	if(this != &_o)
	{
		active = std::move(_o.active);
		timestamp = std::move(_o.timestamp);
		playerId = std::move(_o.playerId);
		playerBrandImages = std::move(_o.playerBrandImages);
		jackpotAmountInCents = std::move(_o.jackpotAmountInCents);
		winnerShareAmount = std::move(_o.winnerShareAmount);
		playerShareAmount = std::move(_o.playerShareAmount);
		jackpotState = std::move(_o.jackpotState);
	}
	return *this;
}

#endif

void MiniGameClient::TheDealJackpotSpinLeaf::clear()
{
	active = false;
	timestamp = 0;
	playerId.clear();
	playerBrandImages.clear();
	jackpotAmountInCents = 0;
	winnerShareAmount = 0;
	playerShareAmount = 0;
	jackpotState.clear();
}

bool MiniGameClient::TheDealJackpotSpinLeaf::equals(const TheDealJackpotSpinLeaf& _o) const
{
	return active == _o.active &&
		timestamp == _o.timestamp &&
		playerId.equals(_o.playerId) &&
		playerBrandImages.equals(_o.playerBrandImages) &&
		jackpotAmountInCents == _o.jackpotAmountInCents &&
		winnerShareAmount == _o.winnerShareAmount &&
		playerShareAmount == _o.playerShareAmount &&
		jackpotState.equals(_o.jackpotState);
}

const char *MiniGameClient::TheDealJackpotSpinLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("active=");
	_buf.appendUint(active);
	_buf.append(',');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("playerId=");
	_buf.append(playerId);
	_buf.append(',');
	_buf.append("playerBrandImages=");
	playerBrandImages.toTraceString(_buf);
	_buf.append(',');
	_buf.append("jackpotAmountInCents=");
	_buf.appendInt64(jackpotAmountInCents);
	_buf.append(',');
	_buf.append("winnerShareAmount=");
	_buf.appendInt(winnerShareAmount);
	_buf.append(',');
	_buf.append("playerShareAmount=");
	_buf.appendInt(playerShareAmount);
	_buf.append(',');
	_buf.append("jackpotState=");
	jackpotState.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::TheDealJackpotSpinLeaf::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeBOOL(active);
	_msg.composeINT32(timestamp);
	_msg.composeString(playerId);
	playerBrandImages.composeMsg(_msg);
	_msg.composeINT64(jackpotAmountInCents);
	_msg.composeINT32(winnerShareAmount);
	_msg.composeINT32(playerShareAmount);
	jackpotState.composeMsg(_msg);
}

void MiniGameClient::TheDealJackpotSpinLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(active);
	_parser.parseINT32(timestamp);
	_parser.parseStringP(playerId);
	playerBrandImages.parseMsg(_parser);
	_parser.parseINT64(jackpotAmountInCents);
	_parser.parseINT32(winnerShareAmount);
	_parser.parseINT32(playerShareAmount);
	jackpotState.parseMsg(_parser);
}

/*static*/ void MiniGameClient::TheDealJackpotSpinLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool active; _parser.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	INT32 timestamp; _parser.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "playerId"); size_t szPlayerId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "playerId", szPlayerId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BrandProtThin::BrandImageList::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBrandImages"), _fieldsWithUnparsedContent);
	INT64 jackpotAmountInCents; _parser.parseINT64(jackpotAmountInCents);
	AtfValidator::validateInt(_descr, "jackpotAmountInCents", jackpotAmountInCents, _checker, __FILE__, __LINE__);
	INT32 winnerShareAmount; _parser.parseINT32(winnerShareAmount);
	AtfValidator::validateInt(_descr, "winnerShareAmount", winnerShareAmount, _checker, __FILE__, __LINE__);
	INT32 playerShareAmount; _parser.parseINT32(playerShareAmount);
	AtfValidator::validateInt(_descr, "playerShareAmount", playerShareAmount, _checker, __FILE__, __LINE__);
	MiniGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("jackpotState"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    GameTicketWithMiniGame
//=================================================================

MiniGameClient::GameTicketWithMiniGame::GameTicketWithMiniGame()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::GameTicketWithMiniGame::GameTicketWithMiniGame(GameTicketWithMiniGame&& _o)
	: gameTicketId(std::move(_o.gameTicketId))
	, gameTicketTypeId(std::move(_o.gameTicketTypeId))
	, whenStarted(std::move(_o.whenStarted))
	, expiration(std::move(_o.expiration))
	, playsInitial(std::move(_o.playsInitial))
	, playsSpent(std::move(_o.playsSpent))
	, gameTicketBrandMask(std::move(_o.gameTicketBrandMask))
	, minigameId(std::move(_o.minigameId))
	, minigameType(std::move(_o.minigameType))
	, minigameClientDisplayName(std::move(_o.minigameClientDisplayName))
	, minigameClientDisplayInfo(std::move(_o.minigameClientDisplayInfo))
	, minigameBrandMask(std::move(_o.minigameBrandMask))
	, minigameSiteMask(std::move(_o.minigameSiteMask))
	, status(std::move(_o.status))
	, costFpp1(std::move(_o.costFpp1))
	, minigameSiteMaskEx(std::move(_o.minigameSiteMaskEx))
{
}

MiniGameClient::GameTicketWithMiniGame& MiniGameClient::GameTicketWithMiniGame::operator=(GameTicketWithMiniGame&& _o)
{
	if(this != &_o)
	{
		gameTicketId = std::move(_o.gameTicketId);
		gameTicketTypeId = std::move(_o.gameTicketTypeId);
		whenStarted = std::move(_o.whenStarted);
		expiration = std::move(_o.expiration);
		playsInitial = std::move(_o.playsInitial);
		playsSpent = std::move(_o.playsSpent);
		gameTicketBrandMask = std::move(_o.gameTicketBrandMask);
		minigameId = std::move(_o.minigameId);
		minigameType = std::move(_o.minigameType);
		minigameClientDisplayName = std::move(_o.minigameClientDisplayName);
		minigameClientDisplayInfo = std::move(_o.minigameClientDisplayInfo);
		minigameBrandMask = std::move(_o.minigameBrandMask);
		minigameSiteMask = std::move(_o.minigameSiteMask);
		status = std::move(_o.status);
		costFpp1 = std::move(_o.costFpp1);
		minigameSiteMaskEx = std::move(_o.minigameSiteMaskEx);
	}
	return *this;
}

#endif

void MiniGameClient::GameTicketWithMiniGame::clear()
{
	gameTicketId = 0;
	gameTicketTypeId = 0;
	whenStarted.setNull();
	expiration.setNull();
	playsInitial = 0;
	playsSpent = 0;
	gameTicketBrandMask = 0;
	minigameId = 0;
	minigameType = 0;
	minigameClientDisplayName.clear();
	minigameClientDisplayInfo.clear();
	minigameBrandMask = 0;
	minigameSiteMask = 0;
	status = 0;
	costFpp1 = 0;
	minigameSiteMaskEx.clear();
}

bool MiniGameClient::GameTicketWithMiniGame::equals(const GameTicketWithMiniGame& _o) const
{
	return gameTicketId == _o.gameTicketId &&
		gameTicketTypeId == _o.gameTicketTypeId &&
		whenStarted.equals(_o.whenStarted) &&
		expiration.equals(_o.expiration) &&
		playsInitial == _o.playsInitial &&
		playsSpent == _o.playsSpent &&
		gameTicketBrandMask == _o.gameTicketBrandMask &&
		minigameId == _o.minigameId &&
		minigameType == _o.minigameType &&
		minigameClientDisplayName.equals(_o.minigameClientDisplayName) &&
		minigameClientDisplayInfo.equals(_o.minigameClientDisplayInfo) &&
		minigameBrandMask == _o.minigameBrandMask &&
		minigameSiteMask == _o.minigameSiteMask &&
		status == _o.status &&
		costFpp1 == _o.costFpp1 &&
		minigameSiteMaskEx.equals(_o.minigameSiteMaskEx);
}

const char *MiniGameClient::GameTicketWithMiniGame::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint(gameTicketTypeId);
	_buf.append(',');
	_buf.append("whenStarted=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStarted);
	_buf.append(',');
	_buf.append("expiration=");
	ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, expiration);
	_buf.append(',');
	_buf.append("playsInitial=");
	_buf.appendInt(playsInitial);
	_buf.append(',');
	_buf.append("playsSpent=");
	_buf.appendInt(playsSpent);
	_buf.append(',');
	_buf.append("gameTicketBrandMask=");
	_buf.appendUint(gameTicketBrandMask);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("minigameType=");
	_buf.appendUint(minigameType);
	_buf.append(',');
	_buf.append("minigameClientDisplayName=");
	_buf.append(minigameClientDisplayName);
	_buf.append(',');
	_buf.append("minigameClientDisplayInfo=");
	_buf.append(minigameClientDisplayInfo);
	_buf.append(',');
	_buf.append("minigameBrandMask=");
	_buf.appendUint(minigameBrandMask);
	_buf.append(',');
	_buf.append("minigameSiteMask=");
	_buf.appendUint(minigameSiteMask);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("costFpp1=");
	_buf.appendInt(costFpp1);
	_buf.append(',');
	_buf.append("minigameSiteMaskEx=");
	minigameSiteMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::GameTicketWithMiniGame::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(GameTicketWithMiniGame())) // not empty
	{
		_body.composeUINT64(gameTicketId);
		_body.composeUINT32(gameTicketTypeId);
		_body.composeSrvTime(whenStarted);
		_body.composeSrvTime(expiration);
		_body.composeINT32(playsInitial);
		_body.composeINT32(playsSpent);
		_body.composeUINT32(gameTicketBrandMask);
		_body.composeUINT32(minigameId);
		_body.composeUINT32(minigameType);
		_body.composeString(minigameClientDisplayName);
		_body.composeString(minigameClientDisplayInfo);
		_body.composeUINT32(minigameBrandMask);
		_body.composeUINT32(minigameSiteMask);
		_body.composeINT32(status);
		_body.composeINT32(costFpp1);
		minigameSiteMaskEx.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::GameTicketWithMiniGame::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameTicketId);
	_parser0.parseUINT32(gameTicketTypeId);
	_parser0.parseSrvTime(whenStarted);
	_parser0.parseSrvTime(expiration);
	_parser0.parseINT32(playsInitial);
	_parser0.parseINT32(playsSpent);
	_parser0.parseUINT32(gameTicketBrandMask);
	_parser0.parseUINT32(minigameId);
	_parser0.parseUINT32(minigameType);
	_parser0.parseStringP(minigameClientDisplayName);
	_parser0.parseStringP(minigameClientDisplayInfo);
	_parser0.parseUINT32(minigameBrandMask);
	_parser0.parseUINT32(minigameSiteMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(status);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(costFpp1);
	if(_parser0.parseEnded()) return;
	minigameSiteMaskEx.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::GameTicketWithMiniGame::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 gameTicketId; _parser0.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	UINT32 gameTicketTypeId; _parser0.parseUINT32(gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	SrvTime whenStarted; _parser0.parseSrvTime(whenStarted);
	AtfValidator::validateSrvDateTime(_descr, "whenStarted", whenStarted, _checker, __FILE__, __LINE__);
	SrvTime expiration; _parser0.parseSrvTime(expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	INT32 playsInitial; _parser0.parseINT32(playsInitial);
	AtfValidator::validateInt(_descr, "playsInitial", playsInitial, _checker, __FILE__, __LINE__);
	INT32 playsSpent; _parser0.parseINT32(playsSpent);
	AtfValidator::validateInt(_descr, "playsSpent", playsSpent, _checker, __FILE__, __LINE__);
	UINT32 gameTicketBrandMask; _parser0.parseUINT32(gameTicketBrandMask);
	AtfValidator::validateInt(_descr, "gameTicketBrandMask", gameTicketBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT32 minigameType; _parser0.parseUINT32(minigameType);
	AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "minigameClientDisplayName"); size_t szMinigameClientDisplayName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "minigameClientDisplayName", szMinigameClientDisplayName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "minigameClientDisplayInfo"); size_t szMinigameClientDisplayInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "minigameClientDisplayInfo", szMinigameClientDisplayInfo, _checker, __FILE__, __LINE__);
	UINT32 minigameBrandMask; _parser0.parseUINT32(minigameBrandMask);
	AtfValidator::validateInt(_descr, "minigameBrandMask", minigameBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameSiteMask; _parser0.parseUINT32(minigameSiteMask);
	AtfValidator::validateInt(_descr, "minigameSiteMask", minigameSiteMask, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 status; _parser0.parseINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 costFpp1; _parser0.parseINT32(costFpp1);
	AtfValidator::validateInt(_descr, "costFpp1", costFpp1, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("minigameSiteMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MINIGAME_MSG_ACTIVE_GAMES
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::Protocol_MINIGAME_MSG_ACTIVE_GAMES()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::clear()
{
	requestId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::equals(const Protocol_MINIGAME_MSG_ACTIVE_GAMES& _o) const
{
	return requestId == _o.requestId;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_ACTIVE_GAMES).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_ACTIVE_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY(Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, states(std::move(_o.states))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::operator=(Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		states = std::move(_o.states);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	states.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::equals(const Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		states.equals(_o.states);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_ACTIVE_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("states=");
		states.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		CommMsgBody _msg0;
		states.composeMsg(_msg0);
		_msg.composeMsgBody(_msg0);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_ACTIVE_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	states.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szStates = ThinAtf::LAtfVector< MiniGameState , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("states"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "states", szStates, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MINIGAME_MSG_START_GAME
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::Protocol_MINIGAME_MSG_START_GAME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::Protocol_MINIGAME_MSG_START_GAME(Protocol_MINIGAME_MSG_START_GAME&& _o)
	: requestId(std::move(_o.requestId))
	, minigameId(std::move(_o.minigameId))
	, initialDecisions(std::move(_o.initialDecisions))
	, autoPlay(std::move(_o.autoPlay))
	, useGameTicket(std::move(_o.useGameTicket))
	, minigameEntryMode(std::move(_o.minigameEntryMode))
	, minigameEntryRefId(std::move(_o.minigameEntryRefId))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME& MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::operator=(Protocol_MINIGAME_MSG_START_GAME&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		minigameId = std::move(_o.minigameId);
		initialDecisions = std::move(_o.initialDecisions);
		autoPlay = std::move(_o.autoPlay);
		useGameTicket = std::move(_o.useGameTicket);
		minigameEntryMode = std::move(_o.minigameEntryMode);
		minigameEntryRefId = std::move(_o.minigameEntryRefId);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::clear()
{
	requestId = 0;
	minigameId = 0;
	initialDecisions.clear();
	autoPlay = false;
	useGameTicket = false;
	minigameEntryMode = sidegame::eSideGameEntryMode_Normal;
	minigameEntryRefId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::equals(const Protocol_MINIGAME_MSG_START_GAME& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		initialDecisions.equals(_o.initialDecisions) &&
		autoPlay == _o.autoPlay &&
		useGameTicket == _o.useGameTicket &&
		minigameEntryMode == _o.minigameEntryMode &&
		minigameEntryRefId == _o.minigameEntryRefId;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_START_GAME).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("initialDecisions=");
	initialDecisions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("autoPlay=");
	_buf.appendUint(autoPlay);
	_buf.append(',');
	_buf.append("useGameTicket=");
	_buf.appendUint(useGameTicket);
	_buf.append(',');
	_buf.append("minigameEntryMode=");
	_buf.appendInt(minigameEntryMode);
	_buf.append(',');
	_buf.append("minigameEntryRefId=");
	_buf.appendUint64(minigameEntryRefId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	CommMsgBody _msg0;
	initialDecisions.composeMsg(_msg0);
	_msg.composeMsgBody(_msg0);
	_msg.composeBOOL(autoPlay);
	_msg.composeBOOL(useGameTicket);
	_msg.composeINT8(minigameEntryMode);
	_msg.composeUINT64(minigameEntryRefId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	parseAnonymousMsgBody0(_parser);
	_parser.parseBOOL(autoPlay);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useGameTicket);
	if(_parser.parseEnded()) return;
	_parser.parseINT8(minigameEntryMode);
	_parser.parseUINT64(minigameEntryRefId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_START_GAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	bool autoPlay; _parser.parseBOOL(autoPlay);
	AtfValidator::validateInt(_descr, "autoPlay", autoPlay, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useGameTicket; _parser.parseBOOL(useGameTicket);
	AtfValidator::validateInt(_descr, "useGameTicket", useGameTicket, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT8 minigameEntryMode; _parser.parseINT8(minigameEntryMode);
	AtfValidator::validateIntRange(_descr, "minigameEntryMode", minigameEntryMode, sidegame::eSideGameEntryMode_Normal, sidegame::eSideGameEntryMode_Max, _checker, __FILE__, __LINE__);
	UINT64 minigameEntryRefId; _parser.parseUINT64(minigameEntryRefId);
	AtfValidator::validateUint(_descr, "minigameEntryRefId", minigameEntryRefId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	initialDecisions.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szInitialDecisions = ThinAtf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("initialDecisions"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "initialDecisions", szInitialDecisions, 2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MINIGAME_MSG_START_GAME_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::Protocol_MINIGAME_MSG_START_GAME_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::Protocol_MINIGAME_MSG_START_GAME_REPLY(Protocol_MINIGAME_MSG_START_GAME_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, ticketsWithMinigames(std::move(_o.ticketsWithMinigames))
	, playsRemaining(std::move(_o.playsRemaining))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::operator=(Protocol_MINIGAME_MSG_START_GAME_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		ticketsWithMinigames = std::move(_o.ticketsWithMinigames);
		playsRemaining = std::move(_o.playsRemaining);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	ticketsWithMinigames.clear();
	playsRemaining = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::equals(const Protocol_MINIGAME_MSG_START_GAME_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		state.equals(_o.state) &&
		ticketsWithMinigames.equals(_o.ticketsWithMinigames) &&
		playsRemaining == _o.playsRemaining;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_START_GAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
	}
	_buf.append(',');
	_buf.append("ticketsWithMinigames=");
	ticketsWithMinigames.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playsRemaining=");
	_buf.appendInt(playsRemaining);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg);
	}
	ticketsWithMinigames.composeMsg(_msg);
	_msg.composeINT32(playsRemaining);
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
	}
	if(_parser.parseEnded()) return;
	ticketsWithMinigames.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(playsRemaining);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_START_GAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		MiniGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
	}
	if(_parser.parseEnded()) return;
	PString _descbuf;
	int szTicketsWithMinigames = ThinAtf::LAtfVector< GameTicketWithMiniGame , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketsWithMinigames"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketsWithMinigames", szTicketsWithMinigames, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 playsRemaining; _parser.parseINT32(playsRemaining);
	AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND(Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND&& _o)
	: requestId(std::move(_o.requestId))
	, minigamePlayId(std::move(_o.minigamePlayId))
	, round(std::move(_o.round))
	, decisions(std::move(_o.decisions))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND& MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::operator=(Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		minigamePlayId = std::move(_o.minigamePlayId);
		round = std::move(_o.round);
		decisions = std::move(_o.decisions);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::clear()
{
	requestId = 0;
	minigamePlayId = 0;
	round = 0;
	decisions.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::equals(const Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId &&
		round == _o.round &&
		decisions.equals(_o.decisions);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_PLAY_NEXT_ROUND).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	_buf.append(',');
	_buf.append("round=");
	_buf.appendInt(round);
	_buf.append(',');
	_buf.append("decisions=");
	decisions.toTraceString(_buf);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
	_msg.composeINT32(round);
	CommMsgBody _msg0;
	decisions.composeMsg(_msg0);
	_msg.composeMsgBody(_msg0);
}

void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
	_parser.parseINT32(round);
	parseAnonymousMsgBody0(_parser);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_PLAY_NEXT_ROUND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	INT32 round; _parser.parseINT32(round);
	AtfValidator::validateIntRange(_descr, "round", round, 0, 0, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	decisions.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szDecisions = ThinAtf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("decisions"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "decisions", szDecisions, 0, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GAME_STATE
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::Protocol_MINIGAME_MSG_GAME_STATE()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::equals(const Protocol_MINIGAME_MSG_GAME_STATE& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GAME_STATE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GAME_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GAME_STATE_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::Protocol_MINIGAME_MSG_GAME_STATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::Protocol_MINIGAME_MSG_GAME_STATE_REPLY(Protocol_MINIGAME_MSG_GAME_STATE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::operator=(Protocol_MINIGAME_MSG_GAME_STATE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::equals(const Protocol_MINIGAME_MSG_GAME_STATE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		state.equals(_o.state);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GAME_STATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GAME_STATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		MiniGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_SERVER_RESTARTING
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::Protocol_MINIGAME_MSG_SERVER_RESTARTING()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::clear()
{
}

bool MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::equals(const Protocol_MINIGAME_MSG_SERVER_RESTARTING& _o) const
{
	return true;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_SERVER_RESTARTING).append(")");
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::composeMsg(CommMsgBody& _msg) const
{
}

void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_SERVER_RESTARTING";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_TICKET_LOOKUP
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::Protocol_MINIGAME_MSG_TICKET_LOOKUP()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::clear()
{
	requestId = 0;
	ticketId = 0;
	ticketTypeId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::equals(const Protocol_MINIGAME_MSG_TICKET_LOOKUP& _o) const
{
	return requestId == _o.requestId &&
		ticketId == _o.ticketId &&
		ticketTypeId == _o.ticketTypeId;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_TICKET_LOOKUP).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("ticketId=");
	_buf.appendUint64(ticketId);
	_buf.append(',');
	_buf.append("ticketTypeId=");
	_buf.appendUint(ticketTypeId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(ticketId);
	_msg.composeUINT32(ticketTypeId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(ticketId);
	_parser.parseUINT32(ticketTypeId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_TICKET_LOOKUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 ticketId; _parser.parseUINT64(ticketId);
	AtfValidator::validateUint(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeId; _parser.parseUINT32(ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY(Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, minigameId(std::move(_o.minigameId))
	, minigameType(std::move(_o.minigameType))
	, minigameBrandMask(std::move(_o.minigameBrandMask))
	, minigameSiteMaskEx(std::move(_o.minigameSiteMaskEx))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::operator=(Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		minigameId = std::move(_o.minigameId);
		minigameType = std::move(_o.minigameType);
		minigameBrandMask = std::move(_o.minigameBrandMask);
		minigameSiteMaskEx = std::move(_o.minigameSiteMaskEx);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	minigameId = 0;
	minigameType = 0;
	minigameBrandMask = 0;
	minigameSiteMaskEx.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::equals(const Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		minigameId == _o.minigameId &&
		minigameType == _o.minigameType &&
		minigameBrandMask == _o.minigameBrandMask &&
		minigameSiteMaskEx.equals(_o.minigameSiteMaskEx);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_TICKET_LOOKUP_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("minigameId=");
		_buf.appendUint(minigameId);
		_buf.append(',');
		_buf.append("minigameType=");
		_buf.appendUint(minigameType);
		_buf.append(',');
		_buf.append("minigameBrandMask=");
		_buf.appendUint(minigameBrandMask);
		_buf.append(',');
		_buf.append("minigameSiteMaskEx=");
		minigameSiteMaskEx.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT32(minigameId);
		_msg.composeUINT32(minigameType);
		_msg.composeUINT32(minigameBrandMask);
		minigameSiteMaskEx.composeMsg(_msg);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT32(minigameId);
		if(_parser.parseEnded()) return;
		_parser.parseUINT32(minigameType);
		if(_parser.parseEnded()) return;
		_parser.parseUINT32(minigameBrandMask);
		if(_parser.parseEnded()) return;
		minigameSiteMaskEx.parseMsg(_parser);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_TICKET_LOOKUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 minigameId; _parser.parseUINT32(minigameId);
		AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT32 minigameType; _parser.parseUINT32(minigameType);
		AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT32 minigameBrandMask; _parser.parseUINT32(minigameBrandMask);
		AtfValidator::validateInt(_descr, "minigameBrandMask", minigameBrandMask, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("minigameSiteMaskEx"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GET_TICKETS
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::Protocol_MINIGAME_MSG_GET_TICKETS()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::clear()
{
	requestId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::equals(const Protocol_MINIGAME_MSG_GET_TICKETS& _o) const
{
	return requestId == _o.requestId;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GET_TICKETS).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GET_TICKETS_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY(Protocol_MINIGAME_MSG_GET_TICKETS_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, ticketsWithMinigames(std::move(_o.ticketsWithMinigames))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::operator=(Protocol_MINIGAME_MSG_GET_TICKETS_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		ticketsWithMinigames = std::move(_o.ticketsWithMinigames);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	ticketsWithMinigames.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::equals(const Protocol_MINIGAME_MSG_GET_TICKETS_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		ticketsWithMinigames.equals(_o.ticketsWithMinigames);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GET_TICKETS_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("ticketsWithMinigames=");
		ticketsWithMinigames.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		ticketsWithMinigames.composeMsg(_msg);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		ticketsWithMinigames.parseMsg(_parser);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_TICKETS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTicketsWithMinigames = ThinAtf::LAtfVector< GameTicketWithMiniGame , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketsWithMinigames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ticketsWithMinigames", szTicketsWithMinigames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GET_STACKED_TICKETS
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::clear()
{
	requestId = 0;
	minigameId = 0;
	gameTicketTypeId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::equals(const Protocol_MINIGAME_MSG_GET_STACKED_TICKETS& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameTicketTypeId == _o.gameTicketTypeId;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GET_STACKED_TICKETS).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint(gameTicketTypeId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeUINT32(gameTicketTypeId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	_parser.parseUINT32(gameTicketTypeId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_STACKED_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT32 gameTicketTypeId; _parser.parseUINT32(gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY(Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, playsRemaining(std::move(_o.playsRemaining))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::operator=(Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		playsRemaining = std::move(_o.playsRemaining);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	playsRemaining = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::equals(const Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		playsRemaining == _o.playsRemaining;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GET_STACKED_TICKETS_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playsRemaining=");
		_buf.appendInt(playsRemaining);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeINT32(playsRemaining);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseINT32(playsRemaining);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_STACKED_TICKETS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 playsRemaining; _parser.parseINT32(playsRemaining);
		AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER
//=================================================================

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER&& _o)
	: clientCtx(std::move(_o.clientCtx))
	, gameMsgId(std::move(_o.gameMsgId))
	, gameMsgBody(std::move(_o.gameMsgBody))
{
}

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER& MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::operator=(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER&& _o)
{
	if(this != &_o)
	{
		clientCtx = std::move(_o.clientCtx);
		gameMsgId = std::move(_o.gameMsgId);
		gameMsgBody = std::move(_o.gameMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::clear()
{
	clientCtx = 0;
	gameMsgId = 0;
	gameMsgBody.clear();
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::equals(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER& _o) const
{
	return clientCtx == _o.clientCtx &&
		gameMsgId == _o.gameMsgId &&
		gameMsgBody.equals(_o.gameMsgBody);
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER).append(")");
	_buf.append(',');
	_buf.append("clientCtx=");
	_buf.appendUint64(clientCtx);
	_buf.append(',');
	_buf.append("gameMsgId=");
	_buf.appendUint(gameMsgId);
	_buf.append(',');
	_buf.append("gameMsgBody=");
	gameMsgBody.toTraceString(_buf);
	return _buf.c_str();
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(clientCtx);
	_msg.composeUINT32(gameMsgId);
	gameMsgBody.composeMsg(_msg);
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(clientCtx);
	_parser.parseUINT32(gameMsgId);
	gameMsgBody.parseMsg(_parser);
}

/*static*/ void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 clientCtx; _parser.parseUINT64(clientCtx);
	AtfValidator::validateUint(_descr, "clientCtx", clientCtx, _checker, __FILE__, __LINE__);
	UINT32 gameMsgId; _parser.parseUINT32(gameMsgId);
	AtfValidator::validateInt(_descr, "gameMsgId", gameMsgId, _checker, __FILE__, __LINE__);
	ThinAtf::MoveableMsgBody gameMsgBody; gameMsgBody.parseMsg(_parser);
	AtfValidator::validateIntMax(_descr, "gameMsgBody", gameMsgBody._size(), 1048576, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER
//=================================================================

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER&& _o)
	: clientCtx(std::move(_o.clientCtx))
	, gameMsgId(std::move(_o.gameMsgId))
	, gameMsgBody(std::move(_o.gameMsgBody))
	, gameStateMetaDataMsgBody(std::move(_o.gameStateMetaDataMsgBody))
{
}

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER& MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::operator=(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER&& _o)
{
	if(this != &_o)
	{
		clientCtx = std::move(_o.clientCtx);
		gameMsgId = std::move(_o.gameMsgId);
		gameMsgBody = std::move(_o.gameMsgBody);
		gameStateMetaDataMsgBody = std::move(_o.gameStateMetaDataMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::clear()
{
	clientCtx = 0;
	gameMsgId = 0;
	gameMsgBody.clear();
	gameStateMetaDataMsgBody.clear();
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::equals(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER& _o) const
{
	return clientCtx == _o.clientCtx &&
		gameMsgId == _o.gameMsgId &&
		gameMsgBody.equals(_o.gameMsgBody) &&
		gameStateMetaDataMsgBody.equals(_o.gameStateMetaDataMsgBody);
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER).append(")");
	_buf.append(',');
	_buf.append("clientCtx=");
	_buf.appendUint64(clientCtx);
	_buf.append(',');
	_buf.append("gameMsgId=");
	_buf.appendUint(gameMsgId);
	_buf.append(',');
	_buf.append("gameMsgBody=");
	gameMsgBody.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameStateMetaDataMsgBody=");
	gameStateMetaDataMsgBody.toTraceString(_buf);
	return _buf.c_str();
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(clientCtx);
	_msg.composeUINT32(gameMsgId);
	gameMsgBody.composeMsg(_msg);
	gameStateMetaDataMsgBody.composeMsg(_msg);
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(clientCtx);
	_parser.parseUINT32(gameMsgId);
	gameMsgBody.parseMsg(_parser);
	gameStateMetaDataMsgBody.parseMsg(_parser);
}

/*static*/ void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 clientCtx; _parser.parseUINT64(clientCtx);
	AtfValidator::validateUint(_descr, "clientCtx", clientCtx, _checker, __FILE__, __LINE__);
	UINT32 gameMsgId; _parser.parseUINT32(gameMsgId);
	AtfValidator::validateInt(_descr, "gameMsgId", gameMsgId, _checker, __FILE__, __LINE__);
	ThinAtf::MoveableMsgBody gameMsgBody; gameMsgBody.parseMsg(_parser);
	AtfValidator::validateIntMax(_descr, "gameMsgBody", gameMsgBody._size(), 1048576, _checker, __FILE__, __LINE__);
	ThinAtf::MoveableMsgBody gameStateMetaDataMsgBody; gameStateMetaDataMsgBody.parseMsg(_parser);
	AtfValidator::validateIntMax(_descr, "gameStateMetaDataMsgBody", gameStateMetaDataMsgBody._size(), 1048576, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PokerSideBetGameStateMetaData
//=================================================================

MiniGameClient::client::PokerSideBetGameStateMetaData::PokerSideBetGameStateMetaData()
{
	clear();
}

void MiniGameClient::client::PokerSideBetGameStateMetaData::clear()
{
	gameStatus = eSBS_NoBet;
	betAmount = 0;
	winAmount = 0;
	numAutoPlaysRemainingToDisplay = 0;
}

bool MiniGameClient::client::PokerSideBetGameStateMetaData::equals(const PokerSideBetGameStateMetaData& _o) const
{
	return gameStatus == _o.gameStatus &&
		betAmount == _o.betAmount &&
		winAmount == _o.winAmount &&
		numAutoPlaysRemainingToDisplay == _o.numAutoPlaysRemainingToDisplay;
}

const char *MiniGameClient::client::PokerSideBetGameStateMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameStatus=");
	_buf.appendInt(gameStatus);
	_buf.append(',');
	_buf.append("betAmount=");
	_buf.appendInt64(betAmount);
	_buf.append(',');
	_buf.append("winAmount=");
	_buf.appendInt64(winAmount);
	_buf.append(',');
	_buf.append("numAutoPlaysRemainingToDisplay=");
	_buf.appendInt(numAutoPlaysRemainingToDisplay);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::client::PokerSideBetGameStateMetaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetGameStateMetaData())) // not empty
	{
		_body.composeINT32(gameStatus);
		_body.composeINT64(betAmount);
		_body.composeINT64(winAmount);
		_body.composeINT8(numAutoPlaysRemainingToDisplay);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::client::PokerSideBetGameStateMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(gameStatus);
	_parser0.parseINT64(betAmount);
	_parser0.parseINT64(winAmount);
	_parser0.parseINT8(numAutoPlaysRemainingToDisplay);
}

/*static*/ void MiniGameClient::client::PokerSideBetGameStateMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 gameStatus; _parser0.parseINT32(gameStatus);
	AtfValidator::validateInt(_descr, "gameStatus", gameStatus, _checker, __FILE__, __LINE__);
	INT64 betAmount; _parser0.parseINT64(betAmount);
	AtfValidator::validateInt(_descr, "betAmount", betAmount, _checker, __FILE__, __LINE__);
	INT64 winAmount; _parser0.parseINT64(winAmount);
	AtfValidator::validateInt(_descr, "winAmount", winAmount, _checker, __FILE__, __LINE__);
	INT8 numAutoPlaysRemainingToDisplay; _parser0.parseINT8(numAutoPlaysRemainingToDisplay);
	AtfValidator::validateInt(_descr, "numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameStateMetaData
//=================================================================

MiniGameClient::client::GameStateMetaData::GameStateMetaData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::GameStateMetaData::GameStateMetaData(GameStateMetaData&& _o)
	: gameState(std::move(_o.gameState))
	, chosenSuit(std::move(_o.chosenSuit))
	, position(std::move(_o.position))
	, stateMsgBody(std::move(_o.stateMsgBody))
{
}

MiniGameClient::client::GameStateMetaData& MiniGameClient::client::GameStateMetaData::operator=(GameStateMetaData&& _o)
{
	if(this != &_o)
	{
		gameState = std::move(_o.gameState);
		chosenSuit = std::move(_o.chosenSuit);
		position = std::move(_o.position);
		stateMsgBody = std::move(_o.stateMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::client::GameStateMetaData::clear()
{
	gameState = eSGS_None;
	chosenSuit = eSuitRaceSuit_None;
	position = eSuitRace_Unknown;
	stateMsgBody.clear();
}

bool MiniGameClient::client::GameStateMetaData::equals(const GameStateMetaData& _o) const
{
	return gameState == _o.gameState &&
		chosenSuit == _o.chosenSuit &&
		position == _o.position &&
		stateMsgBody.equals(_o.stateMsgBody);
}

const char *MiniGameClient::client::GameStateMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameState=");
	_buf.appendInt(gameState);
	_buf.append(',');
	_buf.append("chosenSuit=");
	_buf.appendUint(chosenSuit);
	_buf.append(',');
	_buf.append("position=");
	_buf.appendInt(position);
	_buf.append(',');
	_buf.append("stateMsgBody=");
	stateMsgBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::client::GameStateMetaData::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(gameState);
	_msg.composeBYTE(chosenSuit);
	_msg.composeINT32(position);
	_msg.composeMsgBody(stateMsgBody);
}

void MiniGameClient::client::GameStateMetaData::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseINT32(gameState);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(chosenSuit);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(position);
	if(_parser.parseEnded()) return;
	_parser.parseMsgBody(stateMsgBody);
}

/*static*/ void MiniGameClient::client::GameStateMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_parser.parseEnded()) return;
	INT32 gameState; _parser.parseINT32(gameState);
	AtfValidator::validateInt(_descr, "gameState", gameState, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE chosenSuit; _parser.parseBYTE(chosenSuit);
	AtfValidator::validateInt(_descr, "chosenSuit", chosenSuit, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 position; _parser.parseINT32(position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	size_t szStateMsgBody; _parser.skipMsgBody(szStateMsgBody);  /*stateMsgBody*/
	AtfValidator::validateInt(_descr, "stateMsgBody", szStateMsgBody, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SideGameAnim
//=================================================================

MiniGameClient::client::SideGameAnim::SideGameAnim()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::SideGameAnim::SideGameAnim(SideGameAnim&& _o)
	: animType(std::move(_o.animType))
	, location(std::move(_o.location))
	, animMsgBody(std::move(_o.animMsgBody))
{
}

MiniGameClient::client::SideGameAnim& MiniGameClient::client::SideGameAnim::operator=(SideGameAnim&& _o)
{
	if(this != &_o)
	{
		animType = std::move(_o.animType);
		location = std::move(_o.location);
		animMsgBody = std::move(_o.animMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::client::SideGameAnim::clear()
{
	animType = 0;
	location = 0;
	animMsgBody.clear();
}

bool MiniGameClient::client::SideGameAnim::equals(const SideGameAnim& _o) const
{
	return animType == _o.animType &&
		location == _o.location &&
		animMsgBody.equals(_o.animMsgBody);
}

const char *MiniGameClient::client::SideGameAnim::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("animType=");
	_buf.appendInt(animType);
	_buf.append(',');
	_buf.append("location=");
	_buf.appendInt(location);
	_buf.append(',');
	_buf.append("animMsgBody=");
	animMsgBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::client::SideGameAnim::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SideGameAnim())) // not empty
	{
		_body.composeINT32(animType);
		_body.composeINT32(location);
		_body.composeMsgBody(animMsgBody);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::client::SideGameAnim::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(animType);
	_parser0.parseINT32(location);
	if(_parser0.parseEnded()) return;
	_parser0.parseMsgBody(animMsgBody);
}

/*static*/ void MiniGameClient::client::SideGameAnim::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 animType; _parser0.parseINT32(animType);
	AtfValidator::validateInt(_descr, "animType", animType, _checker, __FILE__, __LINE__);
	INT32 location; _parser0.parseINT32(location);
	AtfValidator::validateInt(_descr, "location", location, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	size_t szAnimMsgBody; _parser0.skipMsgBody(szAnimMsgBody);  /*animMsgBody*/
	AtfValidator::validateInt(_descr, "animMsgBody", szAnimMsgBody, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SideBetWinAnimMsgBody
//=================================================================

MiniGameClient::client::SideBetWinAnimMsgBody::SideBetWinAnimMsgBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::SideBetWinAnimMsgBody::SideBetWinAnimMsgBody(SideBetWinAnimMsgBody&& _o)
	: amount(std::move(_o.amount))
	, currency(std::move(_o.currency))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, betType(std::move(_o.betType))
	, amount64(std::move(_o.amount64))
{
}

MiniGameClient::client::SideBetWinAnimMsgBody& MiniGameClient::client::SideBetWinAnimMsgBody::operator=(SideBetWinAnimMsgBody&& _o)
{
	if(this != &_o)
	{
		amount = std::move(_o.amount);
		currency = std::move(_o.currency);
		isPlayMoney = std::move(_o.isPlayMoney);
		betType = std::move(_o.betType);
		amount64 = std::move(_o.amount64);
	}
	return *this;
}

#endif

void MiniGameClient::client::SideBetWinAnimMsgBody::clear()
{
	amount = 0;
	currency.clear();
	isPlayMoney = false;
	betType.clear();
	amount64 = 0;
}

bool MiniGameClient::client::SideBetWinAnimMsgBody::equals(const SideBetWinAnimMsgBody& _o) const
{
	return amount == _o.amount &&
		currency.equals(_o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		betType.equals(_o.betType) &&
		amount64 == _o.amount64;
}

const char *MiniGameClient::client::SideBetWinAnimMsgBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("betType=");
	_buf.append(betType);
	_buf.append(',');
	_buf.append("amount64=");
	_buf.appendInt64(amount64);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::client::SideBetWinAnimMsgBody::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(amount);
	_msg.composeString(currency);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(betType);
	_msg.composeINT64(amount64);
}

void MiniGameClient::client::SideBetWinAnimMsgBody::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(amount);
	_parser.parseStringP(currency);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(betType);
	if(_parser.parseEnded()) return;
	_parser.parseINT64(amount64);
}

/*static*/ void MiniGameClient::client::SideBetWinAnimMsgBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "betType"); size_t szBetType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "betType", szBetType, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT64 amount64; _parser.parseINT64(amount64);
	AtfValidator::validateInt(_descr, "amount64", amount64, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION
//=================================================================

MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION(Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION&& _o)
	: handId(std::move(_o.handId))
	, anims(std::move(_o.anims))
{
}

MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION& MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::operator=(Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION&& _o)
{
	if(this != &_o)
	{
		handId = std::move(_o.handId);
		anims = std::move(_o.anims);
	}
	return *this;
}

#endif

void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::clear()
{
	handId = 0;
	anims.clear();
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::equals(const Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION& _o) const
{
	return handId == _o.handId &&
		anims.equals(_o.anims);
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_TRIGGER_ANIMATION).append(")");
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("anims=");
	anims.toTraceString(_buf);
	return _buf.c_str();
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT64(handId);
	anims.composeMsg(_msg);
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	anims.parseMsg(_parser);
}

/*static*/ void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_TRIGGER_ANIMATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAnims = ThinAtf::LAtfVector< SideGameAnim , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("anims"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "anims", szAnims, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SGCard
//=================================================================

MiniGameClient::sidegame::SGCard::SGCard()
{
	clear();
}

void MiniGameClient::sidegame::SGCard::clear()
{
	rank = 0;
	suit = 0;
}

bool MiniGameClient::sidegame::SGCard::equals(const SGCard& _o) const
{
	return rank == _o.rank &&
		suit == _o.suit;
}

const char *MiniGameClient::sidegame::SGCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append(',');
	_buf.append("suit=");
	_buf.appendUint(suit);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::SGCard::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SGCard())) // not empty
	{
		_body.composeBYTE(rank);
		_body.composeBYTE(suit);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SGCard::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(rank);
	_parser0.parseBYTE(suit);
}

/*static*/ void MiniGameClient::sidegame::SGCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE rank; _parser0.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MCard
//=================================================================

MiniGameClient::sidegame::MCard::MCard()
{
	clear();
}

void MiniGameClient::sidegame::MCard::clear()
{
	rank = 0;
	suit = 0;
	matched = false;
	possibleMatch = false;
}

bool MiniGameClient::sidegame::MCard::equals(const MCard& _o) const
{
	return rank == _o.rank &&
		suit == _o.suit &&
		matched == _o.matched &&
		possibleMatch == _o.possibleMatch;
}

const char *MiniGameClient::sidegame::MCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append(',');
	_buf.append("suit=");
	_buf.appendUint(suit);
	_buf.append(',');
	_buf.append("matched=");
	_buf.appendUint(matched);
	_buf.append(',');
	_buf.append("possibleMatch=");
	_buf.appendUint(possibleMatch);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::MCard::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MCard())) // not empty
	{
		_body.composeBYTE(rank);
		_body.composeBYTE(suit);
		_body.composeBOOL(matched);
		_body.composeBOOL(possibleMatch);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::MCard::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(rank);
	_parser0.parseBYTE(suit);
	_parser0.parseBOOL(matched);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(possibleMatch);
}

/*static*/ void MiniGameClient::sidegame::MCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE rank; _parser0.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	bool matched; _parser0.parseBOOL(matched);
	AtfValidator::validateInt(_descr, "matched", matched, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool possibleMatch; _parser0.parseBOOL(possibleMatch);
	AtfValidator::validateInt(_descr, "possibleMatch", possibleMatch, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideGameState
//=================================================================

MiniGameClient::sidegame::PokerSideGameState::PokerSideGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PokerSideGameState::PokerSideGameState(PokerSideGameState&& _o)
	: timestamp(std::move(_o.timestamp))
	, handsTotal(std::move(_o.handsTotal))
	, handsRemaining(std::move(_o.handsRemaining))
	, handsRequiredToForfeit(std::move(_o.handsRequiredToForfeit))
	, lifeCycleState(std::move(_o.lifeCycleState))
	, currentHandState(std::move(_o.currentHandState))
	, prize(std::move(_o.prize))
{
}

MiniGameClient::sidegame::PokerSideGameState& MiniGameClient::sidegame::PokerSideGameState::operator=(PokerSideGameState&& _o)
{
	if(this != &_o)
	{
		timestamp = std::move(_o.timestamp);
		handsTotal = std::move(_o.handsTotal);
		handsRemaining = std::move(_o.handsRemaining);
		handsRequiredToForfeit = std::move(_o.handsRequiredToForfeit);
		lifeCycleState = std::move(_o.lifeCycleState);
		currentHandState = std::move(_o.currentHandState);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PokerSideGameState::clear()
{
	timestamp = 0;
	handsTotal = 0;
	handsRemaining = 0;
	handsRequiredToForfeit = 0;
	lifeCycleState = 0;
	currentHandState = 0;
	prize.clear();
}

bool MiniGameClient::sidegame::PokerSideGameState::equals(const PokerSideGameState& _o) const
{
	return timestamp == _o.timestamp &&
		handsTotal == _o.handsTotal &&
		handsRemaining == _o.handsRemaining &&
		handsRequiredToForfeit == _o.handsRequiredToForfeit &&
		lifeCycleState == _o.lifeCycleState &&
		currentHandState == _o.currentHandState &&
		prize.equals(_o.prize);
}

const char *MiniGameClient::sidegame::PokerSideGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("handsTotal=");
	_buf.appendInt(handsTotal);
	_buf.append(',');
	_buf.append("handsRemaining=");
	_buf.appendInt(handsRemaining);
	_buf.append(',');
	_buf.append("handsRequiredToForfeit=");
	_buf.appendInt(handsRequiredToForfeit);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("currentHandState=");
	_buf.appendInt(currentHandState);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideGameState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideGameState())) // not empty
	{
		_body.composeINT32(timestamp);
		_body.composeINT32(handsTotal);
		_body.composeINT32(handsRemaining);
		_body.composeINT32(handsRequiredToForfeit);
		_body.composeINT32(lifeCycleState);
		_body.composeINT32(currentHandState);
		prize.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(handsTotal);
	_parser0.parseINT32(handsRemaining);
	_parser0.parseINT32(handsRequiredToForfeit);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT32(currentHandState);
	prize.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::PokerSideGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 handsTotal; _parser0.parseINT32(handsTotal);
	AtfValidator::validateInt(_descr, "handsTotal", handsTotal, _checker, __FILE__, __LINE__);
	INT32 handsRemaining; _parser0.parseINT32(handsRemaining);
	AtfValidator::validateInt(_descr, "handsRemaining", handsRemaining, _checker, __FILE__, __LINE__);
	INT32 handsRequiredToForfeit; _parser0.parseINT32(handsRequiredToForfeit);
	AtfValidator::validateInt(_descr, "handsRequiredToForfeit", handsRequiredToForfeit, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 currentHandState; _parser0.parseINT32(currentHandState);
	AtfValidator::validateInt(_descr, "currentHandState", currentHandState, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGamePrize::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CardMatchGameState
//=================================================================

MiniGameClient::sidegame::CardMatchGameState::CardMatchGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::CardMatchGameState::CardMatchGameState(CardMatchGameState&& _o)
	: cards(std::move(_o.cards))
	, timestamp(std::move(_o.timestamp))
	, handsTotal(std::move(_o.handsTotal))
	, handsRemaining(std::move(_o.handsRemaining))
	, handsRequiredToForfeit(std::move(_o.handsRequiredToForfeit))
	, lifeCycleState(std::move(_o.lifeCycleState))
	, currentHandState(std::move(_o.currentHandState))
	, prize(std::move(_o.prize))
{
}

MiniGameClient::sidegame::CardMatchGameState& MiniGameClient::sidegame::CardMatchGameState::operator=(CardMatchGameState&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
		timestamp = std::move(_o.timestamp);
		handsTotal = std::move(_o.handsTotal);
		handsRemaining = std::move(_o.handsRemaining);
		handsRequiredToForfeit = std::move(_o.handsRequiredToForfeit);
		lifeCycleState = std::move(_o.lifeCycleState);
		currentHandState = std::move(_o.currentHandState);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::CardMatchGameState::clear()
{
	cards.clear();
	timestamp = 0;
	handsTotal = 0;
	handsRemaining = 0;
	handsRequiredToForfeit = 0;
	lifeCycleState = 0;
	currentHandState = 0;
	prize.clear();
}

bool MiniGameClient::sidegame::CardMatchGameState::equals(const CardMatchGameState& _o) const
{
	return cards.equals(_o.cards) &&
		timestamp == _o.timestamp &&
		handsTotal == _o.handsTotal &&
		handsRemaining == _o.handsRemaining &&
		handsRequiredToForfeit == _o.handsRequiredToForfeit &&
		lifeCycleState == _o.lifeCycleState &&
		currentHandState == _o.currentHandState &&
		prize.equals(_o.prize);
}

const char *MiniGameClient::sidegame::CardMatchGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("handsTotal=");
	_buf.appendInt(handsTotal);
	_buf.append(',');
	_buf.append("handsRemaining=");
	_buf.appendInt(handsRemaining);
	_buf.append(',');
	_buf.append("handsRequiredToForfeit=");
	_buf.appendInt(handsRequiredToForfeit);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("currentHandState=");
	_buf.appendInt(currentHandState);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::CardMatchGameState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(CardMatchGameState())) // not empty
	{
		cards.composeMsg(_body);
		_body.composeINT32(timestamp);
		_body.composeINT32(handsTotal);
		_body.composeINT32(handsRemaining);
		_body.composeINT32(handsRequiredToForfeit);
		_body.composeINT32(lifeCycleState);
		_body.composeINT32(currentHandState);
		prize.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::CardMatchGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	cards.parseMsg(_parser0);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(handsTotal);
	_parser0.parseINT32(handsRemaining);
	_parser0.parseINT32(handsRequiredToForfeit);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT32(currentHandState);
	prize.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::CardMatchGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szCards = ThinAtf::LAtfVector< MCard , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 handsTotal; _parser0.parseINT32(handsTotal);
	AtfValidator::validateInt(_descr, "handsTotal", handsTotal, _checker, __FILE__, __LINE__);
	INT32 handsRemaining; _parser0.parseINT32(handsRemaining);
	AtfValidator::validateInt(_descr, "handsRemaining", handsRemaining, _checker, __FILE__, __LINE__);
	INT32 handsRequiredToForfeit; _parser0.parseINT32(handsRequiredToForfeit);
	AtfValidator::validateInt(_descr, "handsRequiredToForfeit", handsRequiredToForfeit, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 currentHandState; _parser0.parseINT32(currentHandState);
	AtfValidator::validateInt(_descr, "currentHandState", currentHandState, _checker, __FILE__, __LINE__);
	MiniGamePrize::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RandomDrawGameState
//=================================================================

MiniGameClient::sidegame::RandomDrawGameState::RandomDrawGameState()
{
	clear();
}

void MiniGameClient::sidegame::RandomDrawGameState::clear()
{
	timestamp = 0;
	lifeCycleState = 0;
	prizeIndex = 0;
	animationSeed = 0;
}

bool MiniGameClient::sidegame::RandomDrawGameState::equals(const RandomDrawGameState& _o) const
{
	return timestamp == _o.timestamp &&
		lifeCycleState == _o.lifeCycleState &&
		prizeIndex == _o.prizeIndex &&
		animationSeed == _o.animationSeed;
}

const char *MiniGameClient::sidegame::RandomDrawGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("prizeIndex=");
	_buf.appendInt(prizeIndex);
	_buf.append(',');
	_buf.append("animationSeed=");
	_buf.appendInt(animationSeed);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::RandomDrawGameState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(RandomDrawGameState())) // not empty
	{
		_body.composeINT32(timestamp);
		_body.composeINT32(lifeCycleState);
		_body.composeINT32(prizeIndex);
		_body.composeINT32(animationSeed);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::RandomDrawGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT32(prizeIndex);
	_parser0.parseINT32(animationSeed);
}

/*static*/ void MiniGameClient::sidegame::RandomDrawGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 prizeIndex; _parser0.parseINT32(prizeIndex);
	AtfValidator::validateInt(_descr, "prizeIndex", prizeIndex, _checker, __FILE__, __LINE__);
	INT32 animationSeed; _parser0.parseINT32(animationSeed);
	AtfValidator::validateInt(_descr, "animationSeed", animationSeed, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PickAnObjectGameState
//=================================================================

MiniGameClient::sidegame::PickAnObjectGameState::PickAnObjectGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PickAnObjectGameState::PickAnObjectGameState(PickAnObjectGameState&& _o)
	: timestamp(std::move(_o.timestamp))
	, lifeCycleState(std::move(_o.lifeCycleState))
	, animationSeed(std::move(_o.animationSeed))
	, prizeObjectIndices(std::move(_o.prizeObjectIndices))
	, prizeObjectPicked(std::move(_o.prizeObjectPicked))
{
}

MiniGameClient::sidegame::PickAnObjectGameState& MiniGameClient::sidegame::PickAnObjectGameState::operator=(PickAnObjectGameState&& _o)
{
	if(this != &_o)
	{
		timestamp = std::move(_o.timestamp);
		lifeCycleState = std::move(_o.lifeCycleState);
		animationSeed = std::move(_o.animationSeed);
		prizeObjectIndices = std::move(_o.prizeObjectIndices);
		prizeObjectPicked = std::move(_o.prizeObjectPicked);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PickAnObjectGameState::clear()
{
	timestamp = 0;
	lifeCycleState = 0;
	animationSeed = 0;
	prizeObjectIndices.clear();
	prizeObjectPicked = 0;
}

bool MiniGameClient::sidegame::PickAnObjectGameState::equals(const PickAnObjectGameState& _o) const
{
	return timestamp == _o.timestamp &&
		lifeCycleState == _o.lifeCycleState &&
		animationSeed == _o.animationSeed &&
		prizeObjectIndices.equals(_o.prizeObjectIndices) &&
		prizeObjectPicked == _o.prizeObjectPicked;
}

const char *MiniGameClient::sidegame::PickAnObjectGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("animationSeed=");
	_buf.appendInt(animationSeed);
	_buf.append(',');
	_buf.append("prizeObjectIndices=");
	prizeObjectIndices.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prizeObjectPicked=");
	_buf.appendInt(prizeObjectPicked);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::PickAnObjectGameState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PickAnObjectGameState())) // not empty
	{
		_body.composeINT32(timestamp);
		_body.composeINT32(lifeCycleState);
		_body.composeINT32(animationSeed);
		prizeObjectIndices.composeMsg(_body);
		_body.composeINT8(prizeObjectPicked);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PickAnObjectGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT32(animationSeed);
	prizeObjectIndices.parseMsg(_parser0);
	_parser0.parseINT8(prizeObjectPicked);
}

/*static*/ void MiniGameClient::sidegame::PickAnObjectGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 animationSeed; _parser0.parseINT32(animationSeed);
	AtfValidator::validateInt(_descr, "animationSeed", animationSeed, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizeObjectIndices = ThinAtf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeObjectIndices"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeObjectIndices", szPrizeObjectIndices, _checker, __FILE__, __LINE__);
	INT8 prizeObjectPicked; _parser0.parseINT8(prizeObjectPicked);
	AtfValidator::validateInt(_descr, "prizeObjectPicked", prizeObjectPicked, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ChestGameState
//=================================================================

MiniGameClient::sidegame::ChestGameState::ChestGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::ChestGameState::ChestGameState(ChestGameState&& _o)
	: lifeCycleState(std::move(_o.lifeCycleState))
	, prizes(std::move(_o.prizes))
	, animationLevel(std::move(_o.animationLevel))
	, cvlBarUpdates(std::move(_o.cvlBarUpdates))
	, cvlConfigParams(std::move(_o.cvlConfigParams))
{
}

MiniGameClient::sidegame::ChestGameState& MiniGameClient::sidegame::ChestGameState::operator=(ChestGameState&& _o)
{
	if(this != &_o)
	{
		lifeCycleState = std::move(_o.lifeCycleState);
		prizes = std::move(_o.prizes);
		animationLevel = std::move(_o.animationLevel);
		cvlBarUpdates = std::move(_o.cvlBarUpdates);
		cvlConfigParams = std::move(_o.cvlConfigParams);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::ChestGameState::clear()
{
	lifeCycleState = 0;
	prizes.clear();
	animationLevel = 0;
	cvlBarUpdates.clear();
	cvlConfigParams.clear();
}

bool MiniGameClient::sidegame::ChestGameState::equals(const ChestGameState& _o) const
{
	return lifeCycleState == _o.lifeCycleState &&
		prizes.equals(_o.prizes) &&
		animationLevel == _o.animationLevel &&
		cvlBarUpdates.equals(_o.cvlBarUpdates) &&
		cvlConfigParams.equals(_o.cvlConfigParams);
}

const char *MiniGameClient::sidegame::ChestGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("animationLevel=");
	_buf.appendInt(animationLevel);
	_buf.append(',');
	_buf.append("cvlBarUpdates=");
	cvlBarUpdates.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cvlConfigParams=");
	cvlConfigParams.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::ChestGameState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(ChestGameState())) // not empty
	{
		_body.composeINT32(lifeCycleState);
		prizes.composeMsg(_body);
		_body.composeINT32(animationLevel);
		cvlBarUpdates.composeMsg(_body);
		cvlConfigParams.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::ChestGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(lifeCycleState);
	prizes.parseMsg(_parser0);
	_parser0.parseINT32(animationLevel);
	cvlBarUpdates.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	cvlConfigParams.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::ChestGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = ThinAtf::LAtfVector< MiniGamePrizeLocalized, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	INT32 animationLevel; _parser0.parseINT32(animationLevel);
	AtfValidator::validateInt(_descr, "animationLevel", animationLevel, _checker, __FILE__, __LINE__);
	int szCvlBarUpdates = ThinAtf::LAtfVector< CvlClientUserBarNotification, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cvlBarUpdates"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cvlBarUpdates", szCvlBarUpdates, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	int szCvlConfigParams = ThinAtf::LAtfVector< CvlConfigParams, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cvlConfigParams"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cvlConfigParams", szCvlConfigParams, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SuitRacePlayerProgress
//=================================================================

MiniGameClient::sidegame::SuitRacePlayerProgress::SuitRacePlayerProgress()
{
	clear();
}

void MiniGameClient::sidegame::SuitRacePlayerProgress::clear()
{
	suit = 0;
	progress = 0;
	lastProgressType = 0;
}

bool MiniGameClient::sidegame::SuitRacePlayerProgress::equals(const SuitRacePlayerProgress& _o) const
{
	return suit == _o.suit &&
		progress == _o.progress &&
		lastProgressType == _o.lastProgressType;
}

const char *MiniGameClient::sidegame::SuitRacePlayerProgress::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("suit=");
	_buf.appendUint(suit);
	_buf.append(',');
	_buf.append("progress=");
	_buf.appendInt(progress);
	_buf.append(',');
	_buf.append("lastProgressType=");
	_buf.appendInt(lastProgressType);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::SuitRacePlayerProgress::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SuitRacePlayerProgress())) // not empty
	{
		_body.composeBYTE(suit);
		_body.composeINT32(progress);
		_body.composeINT8(lastProgressType);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SuitRacePlayerProgress::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(suit);
	_parser0.parseINT32(progress);
	_parser0.parseINT8(lastProgressType);
}

/*static*/ void MiniGameClient::sidegame::SuitRacePlayerProgress::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	INT32 progress; _parser0.parseINT32(progress);
	AtfValidator::validateInt(_descr, "progress", progress, _checker, __FILE__, __LINE__);
	INT8 lastProgressType; _parser0.parseINT8(lastProgressType);
	AtfValidator::validateInt(_descr, "lastProgressType", lastProgressType, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SuitRaceGameState
//=================================================================

MiniGameClient::sidegame::SuitRaceGameState::SuitRaceGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::SuitRaceGameState::SuitRaceGameState(SuitRaceGameState&& _o)
	: playerProgress(std::move(_o.playerProgress))
	, chosenSuit(std::move(_o.chosenSuit))
	, totalProgressRequired(std::move(_o.totalProgressRequired))
	, sideGameState(std::move(_o.sideGameState))
{
}

MiniGameClient::sidegame::SuitRaceGameState& MiniGameClient::sidegame::SuitRaceGameState::operator=(SuitRaceGameState&& _o)
{
	if(this != &_o)
	{
		playerProgress = std::move(_o.playerProgress);
		chosenSuit = std::move(_o.chosenSuit);
		totalProgressRequired = std::move(_o.totalProgressRequired);
		sideGameState = std::move(_o.sideGameState);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::SuitRaceGameState::clear()
{
	playerProgress.clear();
	chosenSuit = 0;
	totalProgressRequired = 0;
	sideGameState.clear();
}

bool MiniGameClient::sidegame::SuitRaceGameState::equals(const SuitRaceGameState& _o) const
{
	return playerProgress.equals(_o.playerProgress) &&
		chosenSuit == _o.chosenSuit &&
		totalProgressRequired == _o.totalProgressRequired &&
		sideGameState.equals(_o.sideGameState);
}

const char *MiniGameClient::sidegame::SuitRaceGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("playerProgress=");
	playerProgress.toTraceString(_buf);
	_buf.append(',');
	_buf.append("chosenSuit=");
	_buf.appendUint(chosenSuit);
	_buf.append(',');
	_buf.append("totalProgressRequired=");
	_buf.appendInt(totalProgressRequired);
	_buf.append(',');
	_buf.append("sideGameState=");
	sideGameState.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::SuitRaceGameState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SuitRaceGameState())) // not empty
	{
		playerProgress.composeMsg(_body);
		_body.composeBYTE(chosenSuit);
		_body.composeINT32(totalProgressRequired);
		sideGameState.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SuitRaceGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	playerProgress.parseMsg(_parser0);
	_parser0.parseBYTE(chosenSuit);
	_parser0.parseINT32(totalProgressRequired);
	sideGameState.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::SuitRaceGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPlayerProgress = ThinAtf::LAtfVector< SuitRacePlayerProgress , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("playerProgress"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerProgress", szPlayerProgress, _checker, __FILE__, __LINE__);
	BYTE chosenSuit; _parser0.parseBYTE(chosenSuit);
	AtfValidator::validateInt(_descr, "chosenSuit", chosenSuit, _checker, __FILE__, __LINE__);
	INT32 totalProgressRequired; _parser0.parseINT32(totalProgressRequired);
	AtfValidator::validateInt(_descr, "totalProgressRequired", totalProgressRequired, _checker, __FILE__, __LINE__);
	PokerSideGameState::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sideGameState"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SideGameState
//=================================================================

MiniGameClient::sidegame::SideGameState::SideGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::SideGameState::SideGameState(SideGameState&& _o)
	: minigamePlayId(std::move(_o.minigamePlayId))
	, minigameId(std::move(_o.minigameId))
	, gameType(std::move(_o.gameType))
	, gameId(std::move(_o.gameId))
	, entryId(std::move(_o.entryId))
	, stateMsgBody(std::move(_o.stateMsgBody))
	, ringSessionId(std::move(_o.ringSessionId))
	, subGameId(std::move(_o.subGameId))
{
}

MiniGameClient::sidegame::SideGameState& MiniGameClient::sidegame::SideGameState::operator=(SideGameState&& _o)
{
	if(this != &_o)
	{
		minigamePlayId = std::move(_o.minigamePlayId);
		minigameId = std::move(_o.minigameId);
		gameType = std::move(_o.gameType);
		gameId = std::move(_o.gameId);
		entryId = std::move(_o.entryId);
		stateMsgBody = std::move(_o.stateMsgBody);
		ringSessionId = std::move(_o.ringSessionId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::SideGameState::clear()
{
	minigamePlayId = 0;
	minigameId = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	stateMsgBody.clear();
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::SideGameState::equals(const SideGameState& _o) const
{
	return minigamePlayId == _o.minigamePlayId &&
		minigameId == _o.minigameId &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		stateMsgBody.equals(_o.stateMsgBody) &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

const char *MiniGameClient::sidegame::SideGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("stateMsgBody=");
	stateMsgBody.toTraceString(_buf);
	_buf.append(',');
	_buf.append("ringSessionId=");
	_buf.appendUint64(ringSessionId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::SideGameState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SideGameState())) // not empty
	{
		_body.composeUINT64(minigamePlayId);
		_body.composeUINT32(minigameId);
		_body.composeINT8(gameType);
		_body.composeUINT64(gameId);
		_body.composeUINT32(entryId);
		_body.composeMsgBody(stateMsgBody);
		_body.composeUINT64(ringSessionId);
		_body.composeUINT64(subGameId);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SideGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(minigamePlayId);
	_parser0.parseUINT32(minigameId);
	_parser0.parseINT8(gameType);
	_parser0.parseUINT64(gameId);
	_parser0.parseUINT32(entryId);
	_parser0.parseMsgBody(stateMsgBody);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(ringSessionId);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(subGameId);
}

/*static*/ void MiniGameClient::sidegame::SideGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 minigamePlayId; _parser0.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _parser0.parseINT8(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	size_t szStateMsgBody; _parser0.skipMsgBody(szStateMsgBody);  /*stateMsgBody*/
	AtfValidator::validateInt(_descr, "stateMsgBody", szStateMsgBody, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT64 ringSessionId; _parser0.parseUINT64(ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT64 subGameId; _parser0.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MaxGamesReachedEntry
//=================================================================

MiniGameClient::sidegame::MaxGamesReachedEntry::MaxGamesReachedEntry()
{
	clear();
}

void MiniGameClient::sidegame::MaxGamesReachedEntry::clear()
{
	minigameId = 0;
	expirationTime = 0;
}

bool MiniGameClient::sidegame::MaxGamesReachedEntry::equals(const MaxGamesReachedEntry& _o) const
{
	return minigameId == _o.minigameId &&
		expirationTime == _o.expirationTime;
}

const char *MiniGameClient::sidegame::MaxGamesReachedEntry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("expirationTime=");
	_buf.appendInt(expirationTime);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::MaxGamesReachedEntry::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MaxGamesReachedEntry())) // not empty
	{
		_body.composeUINT32(minigameId);
		_body.composeINT32(expirationTime);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::MaxGamesReachedEntry::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(minigameId);
	_parser0.parseINT32(expirationTime);
}

/*static*/ void MiniGameClient::sidegame::MaxGamesReachedEntry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT32 expirationTime; _parser0.parseINT32(expirationTime);
	AtfValidator::validateInt(_descr, "expirationTime", expirationTime, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameTicketState
//=================================================================

MiniGameClient::sidegame::GameTicketState::GameTicketState()
{
	clear();
}

void MiniGameClient::sidegame::GameTicketState::clear()
{
	gameTicketId = 0;
	playsRemaining = 0;
}

bool MiniGameClient::sidegame::GameTicketState::equals(const GameTicketState& _o) const
{
	return gameTicketId == _o.gameTicketId &&
		playsRemaining == _o.playsRemaining;
}

const char *MiniGameClient::sidegame::GameTicketState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	_buf.append(',');
	_buf.append("playsRemaining=");
	_buf.appendInt(playsRemaining);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::GameTicketState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(GameTicketState())) // not empty
	{
		_body.composeUINT64(gameTicketId);
		_body.composeINT32(playsRemaining);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::GameTicketState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameTicketId);
	_parser0.parseINT32(playsRemaining);
}

/*static*/ void MiniGameClient::sidegame::GameTicketState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 gameTicketId; _parser0.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	INT32 playsRemaining; _parser0.parseINT32(playsRemaining);
	AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetResultPayout
//=================================================================

MiniGameClient::sidegame::PokerSideBetResultPayout::PokerSideBetResultPayout()
{
	clear();
}

void MiniGameClient::sidegame::PokerSideBetResultPayout::clear()
{
	betResult = 0;
	payoutMultiplier = 0;
}

bool MiniGameClient::sidegame::PokerSideBetResultPayout::equals(const PokerSideBetResultPayout& _o) const
{
	return betResult == _o.betResult &&
		payoutMultiplier == _o.payoutMultiplier;
}

const char *MiniGameClient::sidegame::PokerSideBetResultPayout::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("betResult=");
	_buf.appendInt(betResult);
	_buf.append(',');
	_buf.append("payoutMultiplier=");
	_buf.appendInt(payoutMultiplier);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetResultPayout::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetResultPayout())) // not empty
	{
		_body.composeINT16(betResult);
		_body.composeINT32(payoutMultiplier);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetResultPayout::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(betResult);
	_parser0.parseINT32(payoutMultiplier);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetResultPayout::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT16 betResult; _parser0.parseINT16(betResult);
	AtfValidator::validateInt(_descr, "betResult", betResult, _checker, __FILE__, __LINE__);
	INT32 payoutMultiplier; _parser0.parseINT32(payoutMultiplier);
	AtfValidator::validateInt(_descr, "payoutMultiplier", payoutMultiplier, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetAvailableBet
//=================================================================

MiniGameClient::sidegame::PokerSideBetAvailableBet::PokerSideBetAvailableBet()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PokerSideBetAvailableBet::PokerSideBetAvailableBet(PokerSideBetAvailableBet&& _o)
	: betType(std::move(_o.betType))
	, betName(std::move(_o.betName))
	, betDescription(std::move(_o.betDescription))
	, oddsTable(std::move(_o.oddsTable))
	, availabilityflags(std::move(_o.availabilityflags))
{
}

MiniGameClient::sidegame::PokerSideBetAvailableBet& MiniGameClient::sidegame::PokerSideBetAvailableBet::operator=(PokerSideBetAvailableBet&& _o)
{
	if(this != &_o)
	{
		betType = std::move(_o.betType);
		betName = std::move(_o.betName);
		betDescription = std::move(_o.betDescription);
		oddsTable = std::move(_o.oddsTable);
		availabilityflags = std::move(_o.availabilityflags);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PokerSideBetAvailableBet::clear()
{
	betType = 0;
	betName.clear();
	betDescription.clear();
	oddsTable.clear();
	availabilityflags = 0;
}

bool MiniGameClient::sidegame::PokerSideBetAvailableBet::equals(const PokerSideBetAvailableBet& _o) const
{
	return betType == _o.betType &&
		betName.equals(_o.betName) &&
		betDescription.equals(_o.betDescription) &&
		oddsTable.equals(_o.oddsTable) &&
		availabilityflags == _o.availabilityflags;
}

const char *MiniGameClient::sidegame::PokerSideBetAvailableBet::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("betType=");
	_buf.appendInt(betType);
	_buf.append(',');
	_buf.append("betName=");
	_buf.append(betName);
	_buf.append(',');
	_buf.append("betDescription=");
	_buf.append(betDescription);
	_buf.append(',');
	_buf.append("oddsTable=");
	oddsTable.toTraceString(_buf);
	_buf.append(',');
	_buf.append("availabilityflags=");
	_buf.appendUint(availabilityflags);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetAvailableBet::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetAvailableBet())) // not empty
	{
		_body.composeINT16(betType);
		_body.composeString(betName);
		_body.composeString(betDescription);
		oddsTable.composeMsg(_body);
		_body.composeBYTE(availabilityflags);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetAvailableBet::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(betType);
	_parser0.parseStringP(betName);
	_parser0.parseStringP(betDescription);
	oddsTable.parseMsg(_parser0);
	_parser0.parseBYTE(availabilityflags);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetAvailableBet::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 betType; _parser0.parseINT16(betType);
	AtfValidator::validateInt(_descr, "betType", betType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "betName"); size_t szBetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "betName", szBetName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "betDescription"); size_t szBetDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "betDescription", szBetDescription, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szOddsTable = ThinAtf::LAtfVector< PokerSideBetResultPayout, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("oddsTable"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "oddsTable", szOddsTable, _checker, __FILE__, __LINE__);
	BYTE availabilityflags; _parser0.parseBYTE(availabilityflags);
	AtfValidator::validateInt(_descr, "availabilityflags", availabilityflags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetGameDefBody
//=================================================================

MiniGameClient::sidegame::PokerSideBetGameDefBody::PokerSideBetGameDefBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PokerSideBetGameDefBody::PokerSideBetGameDefBody(PokerSideBetGameDefBody&& _o)
	: availableBets(std::move(_o.availableBets))
	, allowedBetAmounts(std::move(_o.allowedBetAmounts))
	, allowedNumberOfAutoBets(std::move(_o.allowedNumberOfAutoBets))
	, allowedBetIncrements(std::move(_o.allowedBetIncrements))
	, maxBuyIn(std::move(_o.maxBuyIn))
{
}

MiniGameClient::sidegame::PokerSideBetGameDefBody& MiniGameClient::sidegame::PokerSideBetGameDefBody::operator=(PokerSideBetGameDefBody&& _o)
{
	if(this != &_o)
	{
		availableBets = std::move(_o.availableBets);
		allowedBetAmounts = std::move(_o.allowedBetAmounts);
		allowedNumberOfAutoBets = std::move(_o.allowedNumberOfAutoBets);
		allowedBetIncrements = std::move(_o.allowedBetIncrements);
		maxBuyIn = std::move(_o.maxBuyIn);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PokerSideBetGameDefBody::clear()
{
	availableBets.clear();
	allowedBetAmounts.clear();
	allowedNumberOfAutoBets.clear();
	allowedBetIncrements.clear();
	maxBuyIn = 0;
}

bool MiniGameClient::sidegame::PokerSideBetGameDefBody::equals(const PokerSideBetGameDefBody& _o) const
{
	return availableBets.equals(_o.availableBets) &&
		allowedBetAmounts.equals(_o.allowedBetAmounts) &&
		allowedNumberOfAutoBets.equals(_o.allowedNumberOfAutoBets) &&
		allowedBetIncrements.equals(_o.allowedBetIncrements) &&
		maxBuyIn == _o.maxBuyIn;
}

const char *MiniGameClient::sidegame::PokerSideBetGameDefBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("availableBets=");
	availableBets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("allowedBetAmounts=");
	allowedBetAmounts.toTraceString(_buf);
	_buf.append(',');
	_buf.append("allowedNumberOfAutoBets=");
	allowedNumberOfAutoBets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("allowedBetIncrements=");
	allowedBetIncrements.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetGameDefBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetGameDefBody())) // not empty
	{
		availableBets.composeMsg(_body);
		allowedBetAmounts.composeMsg(_body);
		allowedNumberOfAutoBets.composeMsg(_body);
		allowedBetIncrements.composeMsg(_body);
		_body.composeINT64(maxBuyIn);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetGameDefBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	availableBets.parseMsg(_parser0);
	allowedBetAmounts.parseMsg(_parser0);
	allowedNumberOfAutoBets.parseMsg(_parser0);
	allowedBetIncrements.parseMsg(_parser0);
	_parser0.parseINT64(maxBuyIn);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetGameDefBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szAvailableBets = ThinAtf::LAtfVector< PokerSideBetAvailableBet, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("availableBets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "availableBets", szAvailableBets, _checker, __FILE__, __LINE__);
	int szAllowedBetAmounts = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("allowedBetAmounts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "allowedBetAmounts", szAllowedBetAmounts, _checker, __FILE__, __LINE__);
	int szAllowedNumberOfAutoBets = ThinAtf::LAtfVector< INT16, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("allowedNumberOfAutoBets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "allowedNumberOfAutoBets", szAllowedNumberOfAutoBets, _checker, __FILE__, __LINE__);
	int szAllowedBetIncrements = ThinAtf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("allowedBetIncrements"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "allowedBetIncrements", szAllowedBetIncrements, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser0.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetGameState
//=================================================================

MiniGameClient::sidegame::PokerSideBetGameState::PokerSideBetGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PokerSideBetGameState::PokerSideBetGameState(PokerSideBetGameState&& _o)
	: betType(std::move(_o.betType))
	, betAmount(std::move(_o.betAmount))
	, timestamp(std::move(_o.timestamp))
	, lifeCycleState(std::move(_o.lifeCycleState))
	, betResult(std::move(_o.betResult))
	, cards(std::move(_o.cards))
	, prize(std::move(_o.prize))
{
}

MiniGameClient::sidegame::PokerSideBetGameState& MiniGameClient::sidegame::PokerSideBetGameState::operator=(PokerSideBetGameState&& _o)
{
	if(this != &_o)
	{
		betType = std::move(_o.betType);
		betAmount = std::move(_o.betAmount);
		timestamp = std::move(_o.timestamp);
		lifeCycleState = std::move(_o.lifeCycleState);
		betResult = std::move(_o.betResult);
		cards = std::move(_o.cards);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PokerSideBetGameState::clear()
{
	betType = 0;
	betAmount = 0;
	timestamp = 0;
	lifeCycleState = 0;
	betResult = 0;
	cards.clear();
	prize.clear();
}

bool MiniGameClient::sidegame::PokerSideBetGameState::equals(const PokerSideBetGameState& _o) const
{
	return betType == _o.betType &&
		betAmount == _o.betAmount &&
		timestamp == _o.timestamp &&
		lifeCycleState == _o.lifeCycleState &&
		betResult == _o.betResult &&
		cards.equals(_o.cards) &&
		prize.equals(_o.prize);
}

const char *MiniGameClient::sidegame::PokerSideBetGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("betType=");
	_buf.appendInt(betType);
	_buf.append(',');
	_buf.append("betAmount=");
	_buf.appendInt64(betAmount);
	_buf.append(',');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("betResult=");
	_buf.appendInt(betResult);
	_buf.append(',');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetGameState::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetGameState())) // not empty
	{
		_body.composeINT16(betType);
		_body.composeINT64(betAmount);
		_body.composeINT32(timestamp);
		_body.composeINT32(lifeCycleState);
		_body.composeINT16(betResult);
		cards.composeMsg(_body);
		prize.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(betType);
	_parser0.parseINT64(betAmount);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT16(betResult);
	cards.parseMsg(_parser0);
	prize.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT16 betType; _parser0.parseINT16(betType);
	AtfValidator::validateInt(_descr, "betType", betType, _checker, __FILE__, __LINE__);
	INT64 betAmount; _parser0.parseINT64(betAmount);
	AtfValidator::validateInt(_descr, "betAmount", betAmount, _checker, __FILE__, __LINE__);
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT16 betResult; _parser0.parseINT16(betResult);
	AtfValidator::validateInt(_descr, "betResult", betResult, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCards = ThinAtf::LAtfVector< SGCard, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	MiniGamePrize::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_GAME
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::Protocol_SIDEGAME_MSG_START_GAME()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::clear()
{
	requestId = 0;
	minigameId = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	useGameTicket = false;
	gameTicketId = 0;
	autoPlay = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::equals(const Protocol_SIDEGAME_MSG_START_GAME& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		useGameTicket == _o.useGameTicket &&
		gameTicketId == _o.gameTicketId &&
		autoPlay == _o.autoPlay;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_GAME).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("useGameTicket=");
	_buf.appendUint(useGameTicket);
	_buf.append(',');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	_buf.append(',');
	_buf.append("autoPlay=");
	_buf.appendUint(autoPlay);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeINT8(gameType);
	_msg.composeUINT64(gameId);
	_msg.composeUINT32(entryId);
	_msg.composeBOOL(useGameTicket);
	_msg.composeUINT64(gameTicketId);
	_msg.composeBOOL(autoPlay);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	_parser.parseINT8(gameType);
	_parser.parseUINT64(gameId);
	_parser.parseUINT32(entryId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useGameTicket);
	_parser.parseUINT64(gameTicketId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(autoPlay);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_GAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _parser.parseINT8(gameType);
	AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useGameTicket; _parser.parseBOOL(useGameTicket);
	AtfValidator::validateInt(_descr, "useGameTicket", useGameTicket, _checker, __FILE__, __LINE__);
	UINT64 gameTicketId; _parser.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool autoPlay; _parser.parseBOOL(autoPlay);
	AtfValidator::validateInt(_descr, "autoPlay", autoPlay, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_GAME_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::Protocol_SIDEGAME_MSG_START_GAME_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::Protocol_SIDEGAME_MSG_START_GAME_REPLY(Protocol_SIDEGAME_MSG_START_GAME_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, state(std::move(_o.state))
	, gameTicketState(std::move(_o.gameTicketState))
	, playsRemaining(std::move(_o.playsRemaining))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::operator=(Protocol_SIDEGAME_MSG_START_GAME_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		state = std::move(_o.state);
		gameTicketState = std::move(_o.gameTicketState);
		playsRemaining = std::move(_o.playsRemaining);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errString.clear();
	state.clear();
	gameTicketState.clear();
	playsRemaining = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::equals(const Protocol_SIDEGAME_MSG_START_GAME_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errString.equals(_o.errString) &&
		state.equals(_o.state) &&
		gameTicketState.equals(_o.gameTicketState) &&
		playsRemaining == _o.playsRemaining;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_GAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("gameTicketState=");
		gameTicketState.toTraceString(_buf);
	}
	_buf.append(',');
	_buf.append("playsRemaining=");
	_buf.appendInt(playsRemaining);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		state.composeMsg(_msg);
		gameTicketState.composeMsg(_msg);
	}
	_msg.composeINT32(playsRemaining);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		state.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		gameTicketState.parseMsg(_parser);
	}
	if(_parser.parseEnded()) return;
	_parser.parseINT32(playsRemaining);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_GAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		GameTicketState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameTicketState"), _fieldsWithUnparsedContent);
	}
	if(_parser.parseEnded()) return;
	INT32 playsRemaining; _parser.parseINT32(playsRemaining);
	AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SuitRaceEntryMetaData
//=================================================================

MiniGameClient::sidegame::SuitRaceEntryMetaData::SuitRaceEntryMetaData()
{
	clear();
}

void MiniGameClient::sidegame::SuitRaceEntryMetaData::clear()
{
	chosenSuit = 0;
}

bool MiniGameClient::sidegame::SuitRaceEntryMetaData::equals(const SuitRaceEntryMetaData& _o) const
{
	return chosenSuit == _o.chosenSuit;
}

const char *MiniGameClient::sidegame::SuitRaceEntryMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("chosenSuit=");
	_buf.appendUint(chosenSuit);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::SuitRaceEntryMetaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SuitRaceEntryMetaData())) // not empty
	{
		_body.composeBYTE(chosenSuit);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SuitRaceEntryMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(chosenSuit);
}

/*static*/ void MiniGameClient::sidegame::SuitRaceEntryMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE chosenSuit; _parser0.parseBYTE(chosenSuit);
	AtfValidator::validateInt(_descr, "chosenSuit", chosenSuit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PickAnObjectEntryMetaData
//=================================================================

MiniGameClient::sidegame::PickAnObjectEntryMetaData::PickAnObjectEntryMetaData()
{
	clear();
}

void MiniGameClient::sidegame::PickAnObjectEntryMetaData::clear()
{
	prizeIndexPicked = 0;
}

bool MiniGameClient::sidegame::PickAnObjectEntryMetaData::equals(const PickAnObjectEntryMetaData& _o) const
{
	return prizeIndexPicked == _o.prizeIndexPicked;
}

const char *MiniGameClient::sidegame::PickAnObjectEntryMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeIndexPicked=");
	_buf.appendInt(prizeIndexPicked);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::PickAnObjectEntryMetaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PickAnObjectEntryMetaData())) // not empty
	{
		_body.composeINT8(prizeIndexPicked);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PickAnObjectEntryMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT8(prizeIndexPicked);
}

/*static*/ void MiniGameClient::sidegame::PickAnObjectEntryMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT8 prizeIndexPicked; _parser0.parseINT8(prizeIndexPicked);
	AtfValidator::validateInt(_descr, "prizeIndexPicked", prizeIndexPicked, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetEntryMetaData
//=================================================================

MiniGameClient::sidegame::PokerSideBetEntryMetaData::PokerSideBetEntryMetaData()
{
	clear();
}

void MiniGameClient::sidegame::PokerSideBetEntryMetaData::clear()
{
	betType = 0;
	betAmount = 0;
}

bool MiniGameClient::sidegame::PokerSideBetEntryMetaData::equals(const PokerSideBetEntryMetaData& _o) const
{
	return betType == _o.betType &&
		betAmount == _o.betAmount;
}

const char *MiniGameClient::sidegame::PokerSideBetEntryMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("betType=");
	_buf.appendInt(betType);
	_buf.append(',');
	_buf.append("betAmount=");
	_buf.appendInt64(betAmount);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetEntryMetaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetEntryMetaData())) // not empty
	{
		_body.composeINT16(betType);
		_body.composeINT64(betAmount);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetEntryMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(betType);
	_parser0.parseINT64(betAmount);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetEntryMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT16 betType; _parser0.parseINT16(betType);
	AtfValidator::validateInt(_descr, "betType", betType, _checker, __FILE__, __LINE__);
	INT64 betAmount; _parser0.parseINT64(betAmount);
	AtfValidator::validateInt(_descr, "betAmount", betAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_GAME_NEW
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::Protocol_SIDEGAME_MSG_START_GAME_NEW()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::Protocol_SIDEGAME_MSG_START_GAME_NEW(Protocol_SIDEGAME_MSG_START_GAME_NEW&& _o)
	: requestId(std::move(_o.requestId))
	, minigameId(std::move(_o.minigameId))
	, gameType(std::move(_o.gameType))
	, gameId(std::move(_o.gameId))
	, entryId(std::move(_o.entryId))
	, minigameEntryMode(std::move(_o.minigameEntryMode))
	, minigameEntryRefId(std::move(_o.minigameEntryRefId))
	, autoPlay(std::move(_o.autoPlay))
	, sideGameEntryMetaData(std::move(_o.sideGameEntryMetaData))
	, ringSessionId(std::move(_o.ringSessionId))
	, subGameId(std::move(_o.subGameId))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::operator=(Protocol_SIDEGAME_MSG_START_GAME_NEW&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		minigameId = std::move(_o.minigameId);
		gameType = std::move(_o.gameType);
		gameId = std::move(_o.gameId);
		entryId = std::move(_o.entryId);
		minigameEntryMode = std::move(_o.minigameEntryMode);
		minigameEntryRefId = std::move(_o.minigameEntryRefId);
		autoPlay = std::move(_o.autoPlay);
		sideGameEntryMetaData = std::move(_o.sideGameEntryMetaData);
		ringSessionId = std::move(_o.ringSessionId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::clear()
{
	requestId = 0;
	minigameId = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	minigameEntryMode = 0;
	minigameEntryRefId = 0;
	autoPlay = false;
	sideGameEntryMetaData.clear();
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::equals(const Protocol_SIDEGAME_MSG_START_GAME_NEW& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		minigameEntryMode == _o.minigameEntryMode &&
		minigameEntryRefId == _o.minigameEntryRefId &&
		autoPlay == _o.autoPlay &&
		sideGameEntryMetaData.equals(_o.sideGameEntryMetaData) &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_GAME_NEW).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("minigameEntryMode=");
	_buf.appendInt(minigameEntryMode);
	_buf.append(',');
	_buf.append("minigameEntryRefId=");
	_buf.appendUint64(minigameEntryRefId);
	_buf.append(',');
	_buf.append("autoPlay=");
	_buf.appendUint(autoPlay);
	_buf.append(',');
	_buf.append("sideGameEntryMetaData=");
	sideGameEntryMetaData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("ringSessionId=");
	_buf.appendUint64(ringSessionId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeINT8(gameType);
	_msg.composeUINT64(gameId);
	_msg.composeUINT32(entryId);
	_msg.composeINT8(minigameEntryMode);
	_msg.composeUINT64(minigameEntryRefId);
	_msg.composeBOOL(autoPlay);
	_msg.composeMsgBody(sideGameEntryMetaData);
	_msg.composeUINT64(ringSessionId);
	_msg.composeUINT64(subGameId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	_parser.parseINT8(gameType);
	_parser.parseUINT64(gameId);
	_parser.parseUINT32(entryId);
	_parser.parseINT8(minigameEntryMode);
	_parser.parseUINT64(minigameEntryRefId);
	_parser.parseBOOL(autoPlay);
	if(_parser.parseEnded()) return;
	_parser.parseMsgBody(sideGameEntryMetaData);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(ringSessionId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(subGameId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_GAME_NEW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _parser.parseINT8(gameType);
	AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	INT8 minigameEntryMode; _parser.parseINT8(minigameEntryMode);
	AtfValidator::validateIntRange(_descr, "minigameEntryMode", minigameEntryMode, sidegame::eSideGameEntryMode_Normal, sidegame::eSideGameEntryMode_Max, _checker, __FILE__, __LINE__);
	UINT64 minigameEntryRefId; _parser.parseUINT64(minigameEntryRefId);
	AtfValidator::validateUint(_descr, "minigameEntryRefId", minigameEntryRefId, _checker, __FILE__, __LINE__);
	bool autoPlay; _parser.parseBOOL(autoPlay);
	AtfValidator::validateInt(_descr, "autoPlay", autoPlay, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	size_t szSideGameEntryMetaData; _parser.skipMsgBody(szSideGameEntryMetaData);  /*sideGameEntryMetaData*/
	AtfValidator::validateIntMax(_descr, "sideGameEntryMetaData", szSideGameEntryMetaData, 1048576, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 ringSessionId; _parser.parseUINT64(ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 subGameId; _parser.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_ACTIVE_GAMES
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::Protocol_SIDEGAME_MSG_ACTIVE_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::Protocol_SIDEGAME_MSG_ACTIVE_GAMES(Protocol_SIDEGAME_MSG_ACTIVE_GAMES&& _o)
	: requestId(std::move(_o.requestId))
	, useEntryFilter(std::move(_o.useEntryFilter))
	, gameType(std::move(_o.gameType))
	, gameId(std::move(_o.gameId))
	, entryId(std::move(_o.entryId))
	, ringSessionId(std::move(_o.ringSessionId))
	, subGameId(std::move(_o.subGameId))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::operator=(Protocol_SIDEGAME_MSG_ACTIVE_GAMES&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		useEntryFilter = std::move(_o.useEntryFilter);
		gameType = std::move(_o.gameType);
		gameId = std::move(_o.gameId);
		entryId = std::move(_o.entryId);
		ringSessionId = std::move(_o.ringSessionId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::clear()
{
	requestId = 0;
	useEntryFilter = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::equals(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES& _o) const
{
	return requestId == _o.requestId &&
		useEntryFilter == _o.useEntryFilter &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_ACTIVE_GAMES).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("useEntryFilter=");
	_buf.appendUint(useEntryFilter);
	if( useEntryFilter)
	{
		_buf.append(',');
		_buf.append("gameType=");
		_buf.appendInt(gameType);
		_buf.append(',');
		_buf.append("gameId=");
		_buf.appendUint64(gameId);
		_buf.append(',');
		_buf.append("entryId=");
		_buf.appendUint(entryId);
		_buf.append(',');
		_buf.append("ringSessionId=");
		_buf.appendUint64(ringSessionId);
		_buf.append(',');
		_buf.append("subGameId=");
		_buf.appendUint64(subGameId);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeBYTE(useEntryFilter);
	if( useEntryFilter)
	{
		_msg.composeINT8(gameType);
		_msg.composeUINT64(gameId);
		_msg.composeUINT32(entryId);
		_msg.composeUINT64(ringSessionId);
		_msg.composeUINT64(subGameId);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseBYTE(useEntryFilter);
	if( useEntryFilter)
	{
		_parser.parseINT8(gameType);
		_parser.parseUINT64(gameId);
		_parser.parseUINT32(entryId);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(ringSessionId);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(subGameId);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_ACTIVE_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE useEntryFilter = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(useEntryFilter);
	AtfValidator::validateIntRange(_descr, "useEntryFilter", useEntryFilter, 0, 1, _checker, __FILE__, __LINE__);
	if( useEntryFilter)
	{
		INT8 gameType; _parser.parseINT8(gameType);
		AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
		UINT64 gameId; _parser.parseUINT64(gameId);
		AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
		UINT32 entryId; _parser.parseUINT32(entryId);
		AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 ringSessionId; _parser.parseUINT64(ringSessionId);
		AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 subGameId; _parser.parseUINT64(subGameId);
		AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY(Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, states(std::move(_o.states))
	, maxGamesReached(std::move(_o.maxGamesReached))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::operator=(Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		states = std::move(_o.states);
		maxGamesReached = std::move(_o.maxGamesReached);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	states.clear();
	maxGamesReached.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::equals(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		states.equals(_o.states) &&
		maxGamesReached.equals(_o.maxGamesReached) &&
		hasHistoricGames == _o.hasHistoricGames;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_ACTIVE_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("states=");
		states.toTraceString(_buf);
		_buf.append(',');
		_buf.append("maxGamesReached=");
		maxGamesReached.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		CommMsgBody _msg0;
		states.composeMsg(_msg0);
		_msg.composeMsgBody(_msg0);
		CommMsgBody _msg1;
		maxGamesReached.composeMsg(_msg1);
		_msg.composeMsgBody(_msg1);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
		parseAnonymousMsgBody1(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseBOOL(hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_ACTIVE_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	states.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szStates = ThinAtf::LAtfVector< SideGameState , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("states"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "states", szStates, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	maxGamesReached.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szMaxGamesReached = ThinAtf::LAtfVector< MaxGamesReachedEntry , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("maxGamesReached"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "maxGamesReached", szMaxGamesReached, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_STATE
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::Protocol_SIDEGAME_MSG_GAME_STATE()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::equals(const Protocol_SIDEGAME_MSG_GAME_STATE& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_STATE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_STATE_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY(Protocol_SIDEGAME_MSG_GAME_STATE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::operator=(Protocol_SIDEGAME_MSG_GAME_STATE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::equals(const Protocol_SIDEGAME_MSG_GAME_STATE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		state.equals(_o.state) &&
		hasHistoricGames == _o.hasHistoricGames;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_STATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseBOOL(hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_STATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::clear()
{
	requestId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::equals(const Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED& _o) const
{
	return requestId == _o.requestId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_MAX_GAMES_REACHED).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_MAX_GAMES_REACHED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY(Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, maxGamesReached(std::move(_o.maxGamesReached))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::operator=(Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		maxGamesReached = std::move(_o.maxGamesReached);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	maxGamesReached.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::equals(const Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		maxGamesReached.equals(_o.maxGamesReached);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("maxGamesReached=");
		maxGamesReached.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		maxGamesReached.composeMsg(_msg);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		maxGamesReached.parseMsg(_parser);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szMaxGamesReached = ThinAtf::LAtfVector< MaxGamesReachedEntry , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("maxGamesReached"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "maxGamesReached", szMaxGamesReached, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CLAIM_PRIZE
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::Protocol_SIDEGAME_MSG_CLAIM_PRIZE()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::clear()
{
	requestId = 0;
	minigamePlayId = 0;
	prizeIndex = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::equals(const Protocol_SIDEGAME_MSG_CLAIM_PRIZE& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId &&
		prizeIndex == _o.prizeIndex;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CLAIM_PRIZE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	_buf.append(',');
	_buf.append("prizeIndex=");
	_buf.appendInt(prizeIndex);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
	_msg.composeINT32(prizeIndex);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
	_parser.parseINT32(prizeIndex);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CLAIM_PRIZE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	INT32 prizeIndex; _parser.parseINT32(prizeIndex);
	AtfValidator::validateIntRange(_descr, "prizeIndex", prizeIndex, 0, 0, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY(Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::operator=(Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::equals(const Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		state.equals(_o.state) &&
		hasHistoricGames == _o.hasHistoricGames;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CLAIM_PRIZE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseBOOL(hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CLAIM_PRIZE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_DEF
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::Protocol_SIDEGAME_MSG_GAME_DEF()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::clear()
{
	requestId = 0;
	minigameId = 0;
	gameTicketTypeId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::equals(const Protocol_SIDEGAME_MSG_GAME_DEF& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameTicketTypeId == _o.gameTicketTypeId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_DEF).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint(gameTicketTypeId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeUINT32(gameTicketTypeId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(gameTicketTypeId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 gameTicketTypeId; _parser.parseUINT32(gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_DEF_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY(Protocol_SIDEGAME_MSG_GAME_DEF_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, def(std::move(_o.def))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::operator=(Protocol_SIDEGAME_MSG_GAME_DEF_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		def = std::move(_o.def);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	def.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::equals(const Protocol_SIDEGAME_MSG_GAME_DEF_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		def.equals(_o.def);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_DEF_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("def=");
		def.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		def.composeMsg(_msg);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		def.parseMsg(_parser);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		MiniGameTypeLeaf::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("def"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::clear()
{
	requestId = 0;
	minigameId = 0;
	gameTicketTypeId = 0;
	gameType = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::equals(const Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameTicketTypeId == _o.gameTicketTypeId &&
		gameType == _o.gameType;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_DEF_LOCALIZED).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint(gameTicketTypeId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeUINT32(gameTicketTypeId);
	_msg.composeINT32(gameType);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(gameTicketTypeId);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(gameType);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF_LOCALIZED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 gameTicketTypeId; _parser.parseUINT32(gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 gameType; _parser.parseINT32(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY(Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, def(std::move(_o.def))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::operator=(Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		def = std::move(_o.def);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	def.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::equals(const Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		def.equals(_o.def);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("def=");
		def.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		def.composeMsg(_msg);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		def.parseMsg(_parser);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		MiniGameDefLocalized::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("def"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_HISTORIC_GAMES
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::Protocol_SIDEGAME_MSG_HISTORIC_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::Protocol_SIDEGAME_MSG_HISTORIC_GAMES(Protocol_SIDEGAME_MSG_HISTORIC_GAMES&& _o)
	: requestId(std::move(_o.requestId))
	, maxHistoricPlays(std::move(_o.maxHistoricPlays))
	, useEntryFilter(std::move(_o.useEntryFilter))
	, gameType(std::move(_o.gameType))
	, gameId(std::move(_o.gameId))
	, entryId(std::move(_o.entryId))
	, gameTicketTypeId(std::move(_o.gameTicketTypeId))
	, ringSessionId(std::move(_o.ringSessionId))
	, subGameId(std::move(_o.subGameId))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::operator=(Protocol_SIDEGAME_MSG_HISTORIC_GAMES&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		maxHistoricPlays = std::move(_o.maxHistoricPlays);
		useEntryFilter = std::move(_o.useEntryFilter);
		gameType = std::move(_o.gameType);
		gameId = std::move(_o.gameId);
		entryId = std::move(_o.entryId);
		gameTicketTypeId = std::move(_o.gameTicketTypeId);
		ringSessionId = std::move(_o.ringSessionId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::clear()
{
	requestId = 0;
	maxHistoricPlays = 0;
	useEntryFilter = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	gameTicketTypeId = 0;
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::equals(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES& _o) const
{
	return requestId == _o.requestId &&
		maxHistoricPlays == _o.maxHistoricPlays &&
		useEntryFilter == _o.useEntryFilter &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		gameTicketTypeId == _o.gameTicketTypeId &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_HISTORIC_GAMES).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("maxHistoricPlays=");
	_buf.appendUint(maxHistoricPlays);
	_buf.append(',');
	_buf.append("useEntryFilter=");
	_buf.appendUint(useEntryFilter);
	if( useEntryFilter )
	{
		_buf.append(',');
		_buf.append("gameType=");
		_buf.appendInt(gameType);
		_buf.append(',');
		_buf.append("gameId=");
		_buf.appendUint64(gameId);
		_buf.append(',');
		_buf.append("entryId=");
		_buf.appendUint(entryId);
	}
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint64(gameTicketTypeId);
	_buf.append(',');
	_buf.append("ringSessionId=");
	_buf.appendUint64(ringSessionId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeBYTE(maxHistoricPlays);
	_msg.composeBYTE(useEntryFilter);
	if( useEntryFilter )
	{
		_msg.composeINT8(gameType);
		_msg.composeUINT64(gameId);
		_msg.composeUINT32(entryId);
	}
	_msg.composeUINT64(gameTicketTypeId);
	_msg.composeUINT64(ringSessionId);
	_msg.composeUINT64(subGameId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseBYTE(maxHistoricPlays);
	_parser.parseBYTE(useEntryFilter);
	if( useEntryFilter )
	{
		_parser.parseINT8(gameType);
		_parser.parseUINT64(gameId);
		_parser.parseUINT32(entryId);
	}
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(gameTicketTypeId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(ringSessionId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(subGameId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_HISTORIC_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE useEntryFilter = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	BYTE maxHistoricPlays; _parser.parseBYTE(maxHistoricPlays);
	AtfValidator::validateIntRange(_descr, "maxHistoricPlays", maxHistoricPlays, 0, 10, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(useEntryFilter);
	AtfValidator::validateIntRange(_descr, "useEntryFilter", useEntryFilter, 0, 1, _checker, __FILE__, __LINE__);
	if( useEntryFilter )
	{
		INT8 gameType; _parser.parseINT8(gameType);
		AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
		UINT64 gameId; _parser.parseUINT64(gameId);
		AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
		UINT32 entryId; _parser.parseUINT32(entryId);
		AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	}
	if(_parser.parseEnded()) return;
	UINT64 gameTicketTypeId; _parser.parseUINT64(gameTicketTypeId);
	AtfValidator::validateUint(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 ringSessionId; _parser.parseUINT64(ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 subGameId; _parser.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY(Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, historicGames(std::move(_o.historicGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::operator=(Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		historicGames = std::move(_o.historicGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	historicGames.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::equals(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		historicGames.equals(_o.historicGames);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_HISTORIC_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("historicGames=");
		historicGames.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		CommMsgBody _msg0;
		historicGames.composeMsg(_msg0);
		_msg.composeMsgBody(_msg0);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_HISTORIC_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	historicGames.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szHistoricGames = ThinAtf::LAtfVector< SideGameState , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("historicGames"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "historicGames", szHistoricGames, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_FORFEIT
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::Protocol_SIDEGAME_MSG_FORFEIT()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::equals(const Protocol_SIDEGAME_MSG_FORFEIT& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_FORFEIT).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_FORFEIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_FORFEIT_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::Protocol_SIDEGAME_MSG_FORFEIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::Protocol_SIDEGAME_MSG_FORFEIT_REPLY(Protocol_SIDEGAME_MSG_FORFEIT_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::operator=(Protocol_SIDEGAME_MSG_FORFEIT_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::equals(const Protocol_SIDEGAME_MSG_FORFEIT_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		state.equals(_o.state) &&
		hasHistoricGames == _o.hasHistoricGames;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_FORFEIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseBOOL(hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_FORFEIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::clear()
{
	requestId = 0;
	gameTicketId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::equals(const Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE& _o) const
{
	return requestId == _o.requestId &&
		gameTicketId == _o.gameTicketId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_TICKET_BALANCE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(gameTicketId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(gameTicketId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_TICKET_BALANCE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 gameTicketId; _parser.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY(Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, playsRemaining(std::move(_o.playsRemaining))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::operator=(Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		playsRemaining = std::move(_o.playsRemaining);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	playsRemaining = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::equals(const Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		playsRemaining == _o.playsRemaining;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playsRemaining=");
		_buf.appendInt(playsRemaining);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeINT32(playsRemaining);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseINT32(playsRemaining);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 playsRemaining; _parser.parseINT32(playsRemaining);
		AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    MultiPurposeChestMetaData
//=================================================================

MiniGameClient::sidegame::MultiPurposeChestMetaData::MultiPurposeChestMetaData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::MultiPurposeChestMetaData::MultiPurposeChestMetaData(MultiPurposeChestMetaData&& _o)
	: logoName(std::move(_o.logoName))
	, chestSkin(std::move(_o.chestSkin))
	, customSkin(std::move(_o.customSkin))
{
}

MiniGameClient::sidegame::MultiPurposeChestMetaData& MiniGameClient::sidegame::MultiPurposeChestMetaData::operator=(MultiPurposeChestMetaData&& _o)
{
	if(this != &_o)
	{
		logoName = std::move(_o.logoName);
		chestSkin = std::move(_o.chestSkin);
		customSkin = std::move(_o.customSkin);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::MultiPurposeChestMetaData::clear()
{
	logoName.clear();
	chestSkin = 0;
	customSkin.clear();
}

bool MiniGameClient::sidegame::MultiPurposeChestMetaData::equals(const MultiPurposeChestMetaData& _o) const
{
	return logoName.equals(_o.logoName) &&
		chestSkin == _o.chestSkin &&
		customSkin.equals(_o.customSkin);
}

const char *MiniGameClient::sidegame::MultiPurposeChestMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("logoName=");
	_buf.append(logoName);
	_buf.append(',');
	_buf.append("chestSkin=");
	_buf.appendUint(chestSkin);
	_buf.append(',');
	_buf.append("customSkin=");
	_buf.append(customSkin);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::MultiPurposeChestMetaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MultiPurposeChestMetaData())) // not empty
	{
		_body.composeString(logoName);
		_body.composeBYTE(chestSkin);
		_body.composeString(customSkin);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::MultiPurposeChestMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(logoName);
	_parser0.parseBYTE(chestSkin);
	_parser0.parseStringP(customSkin);
}

/*static*/ void MiniGameClient::sidegame::MultiPurposeChestMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "logoName"); size_t szLogoName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "logoName", szLogoName, _checker, __FILE__, __LINE__);
	BYTE chestSkin; _parser0.parseBYTE(chestSkin);
	AtfValidator::validateInt(_descr, "chestSkin", chestSkin, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "customSkin"); size_t szCustomSkin = strlen(_dummy);
	AtfValidator::validateInt(_descr, "customSkin", szCustomSkin, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    StarsRewardsChestMetaData
//=================================================================

MiniGameClient::sidegame::StarsRewardsChestMetaData::StarsRewardsChestMetaData()
{
	clear();
}

void MiniGameClient::sidegame::StarsRewardsChestMetaData::clear()
{
	version = 0;
}

bool MiniGameClient::sidegame::StarsRewardsChestMetaData::equals(const StarsRewardsChestMetaData& _o) const
{
	return version == _o.version;
}

const char *MiniGameClient::sidegame::StarsRewardsChestMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendInt(version);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::StarsRewardsChestMetaData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(StarsRewardsChestMetaData())) // not empty
	{
		_body.composeINT32(version);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::StarsRewardsChestMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(version);
}

/*static*/ void MiniGameClient::sidegame::StarsRewardsChestMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 version; _parser0.parseINT32(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::clear()
{
	requestId = 0;
	barId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::equals(const Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR& _o) const
{
	return requestId == _o.requestId &&
		barId == _o.barId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_STARSREWARDS_BAR).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("barId=");
	_buf.appendUint64(barId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(barId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(barId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_STARSREWARDS_BAR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 barId; _parser.parseUINT64(barId);
	AtfValidator::validateUint(_descr, "barId", barId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY(Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, barId(std::move(_o.barId))
	, barTier(std::move(_o.barTier))
	, barType(std::move(_o.barType))
	, metaData(std::move(_o.metaData))
	, assets(std::move(_o.assets))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::operator=(Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		barId = std::move(_o.barId);
		barTier = std::move(_o.barTier);
		barType = std::move(_o.barType);
		metaData = std::move(_o.metaData);
		assets = std::move(_o.assets);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	barId = 0;
	barTier = 0;
	barType = 0;
	metaData.clear();
	assets.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::equals(const Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		barId == _o.barId &&
		barTier == _o.barTier &&
		barType == _o.barType &&
		metaData.equals(_o.metaData) &&
		assets.equals(_o.assets);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("barId=");
		_buf.appendUint64(barId);
		_buf.append(',');
		_buf.append("barTier=");
		_buf.appendInt(barTier);
		_buf.append(',');
		_buf.append("barType=");
		_buf.appendInt(barType);
		_buf.append(',');
		_buf.append("metaData=");
		metaData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("assets=");
		assets.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT64(barId);
		_msg.composeINT32(barTier);
		_msg.composeINT8(barType);
		_msg.composeMsgBody(metaData);
		assets.composeMsg(_msg);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT64(barId);
		_parser.parseINT32(barTier);
		if(_parser.parseEnded()) return;
		_parser.parseINT8(barType);
		if(_parser.parseEnded()) return;
		_parser.parseMsgBody(metaData);
		if(_parser.parseEnded()) return;
		assets.parseMsg(_parser);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 barId; _parser.parseUINT64(barId);
		AtfValidator::validateUint(_descr, "barId", barId, _checker, __FILE__, __LINE__);
		INT32 barTier; _parser.parseINT32(barTier);
		AtfValidator::validateInt(_descr, "barTier", barTier, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT8 barType; _parser.parseINT8(barType);
		AtfValidator::validateInt(_descr, "barType", barType, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		size_t szMetaData; _parser.skipMsgBody(szMetaData);  /*metaData*/
		AtfValidator::validateInt(_descr, "metaData", szMetaData, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		int szAssets = ThinAtf::LAtfVector< ChestAsset, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("assets"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "assets", szAssets, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_SKIP_DELAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::Protocol_SIDEGAME_MSG_SKIP_DELAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::equals(const Protocol_SIDEGAME_MSG_SKIP_DELAY& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_SKIP_DELAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendInt64(minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT64(minigamePlayId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT64(minigamePlayId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_SKIP_DELAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	INT64 minigamePlayId; _parser.parseINT64(minigamePlayId);
	AtfValidator::validateInt(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_RING_SESSIONID
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::clear()
{
	requestId = 0;
	tableId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::equals(const Protocol_SIDEGAME_MSG_GET_RING_SESSIONID& _o) const
{
	return requestId == _o.requestId &&
		tableId == _o.tableId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_RING_SESSIONID).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(tableId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(tableId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_RING_SESSIONID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY(Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, ringSessionId(std::move(_o.ringSessionId))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::operator=(Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		ringSessionId = std::move(_o.ringSessionId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	ringSessionId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::equals(const Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		ringSessionId == _o.ringSessionId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_RING_SESSIONID_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("ringSessionId=");
		_buf.appendUint64(ringSessionId);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT64(ringSessionId);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT64(ringSessionId);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_RING_SESSIONID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 ringSessionId; _parser.parseUINT64(ringSessionId);
		AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CANCEL_PLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::Protocol_SIDEGAME_MSG_CANCEL_PLAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::equals(const Protocol_SIDEGAME_MSG_CANCEL_PLAY& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CANCEL_PLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_PLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY(Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		state.equals(_o.state) &&
		hasHistoricGames == _o.hasHistoricGames;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CANCEL_PLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
		_parser.parseBOOL(hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_PLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SideGameContext
//=================================================================

MiniGameClient::sidegame::SideGameContext::SideGameContext()
{
	clear();
}

void MiniGameClient::sidegame::SideGameContext::clear()
{
	minigameId = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::SideGameContext::equals(const SideGameContext& _o) const
{
	return minigameId == _o.minigameId &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

const char *MiniGameClient::sidegame::SideGameContext::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("ringSessionId=");
	_buf.appendUint64(ringSessionId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::SideGameContext::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(SideGameContext())) // not empty
	{
		_body.composeUINT32(minigameId);
		_body.composeINT8(gameType);
		_body.composeUINT64(gameId);
		_body.composeUINT32(entryId);
		_body.composeUINT64(ringSessionId);
		_body.composeUINT64(subGameId);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SideGameContext::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(minigameId);
	_parser0.parseINT8(gameType);
	_parser0.parseUINT64(gameId);
	_parser0.parseUINT32(entryId);
	_parser0.parseUINT64(ringSessionId);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(subGameId);
}

/*static*/ void MiniGameClient::sidegame::SideGameContext::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _parser0.parseINT8(gameType);
	AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT64 ringSessionId; _parser0.parseUINT64(ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT64 subGameId; _parser0.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    AutoPlayContextData
//=================================================================

MiniGameClient::sidegame::AutoPlayContextData::AutoPlayContextData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::AutoPlayContextData::AutoPlayContextData(AutoPlayContextData&& _o)
	: numAutoPlaysRemainingToDisplay(std::move(_o.numAutoPlaysRemainingToDisplay))
	, numAutoPlays(std::move(_o.numAutoPlays))
	, singleWinThreshold(std::move(_o.singleWinThreshold))
	, totalLossesThreshold(std::move(_o.totalLossesThreshold))
	, flags(std::move(_o.flags))
	, sideGameEntryMetaData(std::move(_o.sideGameEntryMetaData))
	, pendingMGPlays(std::move(_o.pendingMGPlays))
	, startedMGPlays(std::move(_o.startedMGPlays))
	, resolvedMGPlays(std::move(_o.resolvedMGPlays))
{
}

MiniGameClient::sidegame::AutoPlayContextData& MiniGameClient::sidegame::AutoPlayContextData::operator=(AutoPlayContextData&& _o)
{
	if(this != &_o)
	{
		numAutoPlaysRemainingToDisplay = std::move(_o.numAutoPlaysRemainingToDisplay);
		numAutoPlays = std::move(_o.numAutoPlays);
		singleWinThreshold = std::move(_o.singleWinThreshold);
		totalLossesThreshold = std::move(_o.totalLossesThreshold);
		flags = std::move(_o.flags);
		sideGameEntryMetaData = std::move(_o.sideGameEntryMetaData);
		pendingMGPlays = std::move(_o.pendingMGPlays);
		startedMGPlays = std::move(_o.startedMGPlays);
		resolvedMGPlays = std::move(_o.resolvedMGPlays);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::AutoPlayContextData::clear()
{
	numAutoPlaysRemainingToDisplay = 0;
	numAutoPlays = 0;
	singleWinThreshold = 0;
	totalLossesThreshold = 0;
	flags = 0;
	sideGameEntryMetaData.clear();
	pendingMGPlays.clear();
	startedMGPlays.clear();
	resolvedMGPlays.clear();
}

bool MiniGameClient::sidegame::AutoPlayContextData::equals(const AutoPlayContextData& _o) const
{
	return numAutoPlaysRemainingToDisplay == _o.numAutoPlaysRemainingToDisplay &&
		numAutoPlays == _o.numAutoPlays &&
		singleWinThreshold == _o.singleWinThreshold &&
		totalLossesThreshold == _o.totalLossesThreshold &&
		flags == _o.flags &&
		sideGameEntryMetaData.equals(_o.sideGameEntryMetaData) &&
		pendingMGPlays.equals(_o.pendingMGPlays) &&
		startedMGPlays.equals(_o.startedMGPlays) &&
		resolvedMGPlays.equals(_o.resolvedMGPlays);
}

const char *MiniGameClient::sidegame::AutoPlayContextData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numAutoPlaysRemainingToDisplay=");
	_buf.appendInt(numAutoPlaysRemainingToDisplay);
	_buf.append(',');
	_buf.append("numAutoPlays=");
	_buf.appendInt(numAutoPlays);
	_buf.append(',');
	_buf.append("singleWinThreshold=");
	_buf.appendInt64(singleWinThreshold);
	_buf.append(',');
	_buf.append("totalLossesThreshold=");
	_buf.appendInt64(totalLossesThreshold);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("sideGameEntryMetaData=");
	sideGameEntryMetaData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pendingMGPlays=");
	pendingMGPlays.toTraceString(_buf);
	_buf.append(',');
	_buf.append("startedMGPlays=");
	startedMGPlays.toTraceString(_buf);
	_buf.append(',');
	_buf.append("resolvedMGPlays=");
	resolvedMGPlays.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

void MiniGameClient::sidegame::AutoPlayContextData::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(AutoPlayContextData())) // not empty
	{
		_body.composeINT8(numAutoPlaysRemainingToDisplay);
		_body.composeINT8(numAutoPlays);
		_body.composeINT64(singleWinThreshold);
		_body.composeINT64(totalLossesThreshold);
		_body.composeUINT32(flags);
		sideGameEntryMetaData.composeMsg(_body);
		pendingMGPlays.composeMsg(_body);
		startedMGPlays.composeMsg(_body);
		resolvedMGPlays.composeMsg(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::AutoPlayContextData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT8(numAutoPlaysRemainingToDisplay);
	_parser0.parseINT8(numAutoPlays);
	_parser0.parseINT64(singleWinThreshold);
	_parser0.parseINT64(totalLossesThreshold);
	_parser0.parseUINT32(flags);
	sideGameEntryMetaData.parseMsg(_parser0);
	pendingMGPlays.parseMsg(_parser0);
	startedMGPlays.parseMsg(_parser0);
	resolvedMGPlays.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::AutoPlayContextData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT8 numAutoPlaysRemainingToDisplay; _parser0.parseINT8(numAutoPlaysRemainingToDisplay);
	AtfValidator::validateInt(_descr, "numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay, _checker, __FILE__, __LINE__);
	INT8 numAutoPlays; _parser0.parseINT8(numAutoPlays);
	AtfValidator::validateInt(_descr, "numAutoPlays", numAutoPlays, _checker, __FILE__, __LINE__);
	INT64 singleWinThreshold; _parser0.parseINT64(singleWinThreshold);
	AtfValidator::validateInt(_descr, "singleWinThreshold", singleWinThreshold, _checker, __FILE__, __LINE__);
	INT64 totalLossesThreshold; _parser0.parseINT64(totalLossesThreshold);
	AtfValidator::validateInt(_descr, "totalLossesThreshold", totalLossesThreshold, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSideGameEntryMetaData = ThinAtf::LAtfVector< ThinAtf::CopyableMsgBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sideGameEntryMetaData"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sideGameEntryMetaData", szSideGameEntryMetaData, _checker, __FILE__, __LINE__);
	int szPendingMGPlays = ThinAtf::LAtfVector< UINT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("pendingMGPlays"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "pendingMGPlays", szPendingMGPlays, _checker, __FILE__, __LINE__);
	int szStartedMGPlays = ThinAtf::LAtfVector< UINT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("startedMGPlays"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "startedMGPlays", szStartedMGPlays, _checker, __FILE__, __LINE__);
	int szResolvedMGPlays = ThinAtf::LAtfVector< UINT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("resolvedMGPlays"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "resolvedMGPlays", szResolvedMGPlays, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_AUTOPLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::Protocol_SIDEGAME_MSG_START_AUTOPLAY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::Protocol_SIDEGAME_MSG_START_AUTOPLAY(Protocol_SIDEGAME_MSG_START_AUTOPLAY&& _o)
	: requestId(std::move(_o.requestId))
	, sideGameContext(std::move(_o.sideGameContext))
	, minigameEntryMode(std::move(_o.minigameEntryMode))
	, minigameEntryRefId(std::move(_o.minigameEntryRefId))
	, numAutoPlays(std::move(_o.numAutoPlays))
	, singleWinThreshold(std::move(_o.singleWinThreshold))
	, totalLossesThreshold(std::move(_o.totalLossesThreshold))
	, flags(std::move(_o.flags))
	, sideGameEntryMetaData(std::move(_o.sideGameEntryMetaData))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::operator=(Protocol_SIDEGAME_MSG_START_AUTOPLAY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		sideGameContext = std::move(_o.sideGameContext);
		minigameEntryMode = std::move(_o.minigameEntryMode);
		minigameEntryRefId = std::move(_o.minigameEntryRefId);
		numAutoPlays = std::move(_o.numAutoPlays);
		singleWinThreshold = std::move(_o.singleWinThreshold);
		totalLossesThreshold = std::move(_o.totalLossesThreshold);
		flags = std::move(_o.flags);
		sideGameEntryMetaData = std::move(_o.sideGameEntryMetaData);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::clear()
{
	requestId = 0;
	sideGameContext.clear();
	minigameEntryMode = 0;
	minigameEntryRefId = 0;
	numAutoPlays = 0;
	singleWinThreshold = 0;
	totalLossesThreshold = 0;
	flags = 0;
	sideGameEntryMetaData.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::equals(const Protocol_SIDEGAME_MSG_START_AUTOPLAY& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext) &&
		minigameEntryMode == _o.minigameEntryMode &&
		minigameEntryRefId == _o.minigameEntryRefId &&
		numAutoPlays == _o.numAutoPlays &&
		singleWinThreshold == _o.singleWinThreshold &&
		totalLossesThreshold == _o.totalLossesThreshold &&
		flags == _o.flags &&
		sideGameEntryMetaData.equals(_o.sideGameEntryMetaData);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_AUTOPLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	_buf.append(',');
	_buf.append("minigameEntryMode=");
	_buf.appendInt(minigameEntryMode);
	_buf.append(',');
	_buf.append("minigameEntryRefId=");
	_buf.appendUint64(minigameEntryRefId);
	_buf.append(',');
	_buf.append("numAutoPlays=");
	_buf.appendInt(numAutoPlays);
	_buf.append(',');
	_buf.append("singleWinThreshold=");
	_buf.appendInt64(singleWinThreshold);
	_buf.append(',');
	_buf.append("totalLossesThreshold=");
	_buf.appendInt64(totalLossesThreshold);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("sideGameEntryMetaData=");
	sideGameEntryMetaData.toTraceString(_buf);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg);
	_msg.composeINT8(minigameEntryMode);
	_msg.composeUINT64(minigameEntryRefId);
	_msg.composeINT8(numAutoPlays);
	_msg.composeINT64(singleWinThreshold);
	_msg.composeINT64(totalLossesThreshold);
	_msg.composeUINT32(flags);
	sideGameEntryMetaData.composeMsg(_msg);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
	_parser.parseINT8(minigameEntryMode);
	_parser.parseUINT64(minigameEntryRefId);
	_parser.parseINT8(numAutoPlays);
	_parser.parseINT64(singleWinThreshold);
	_parser.parseINT64(totalLossesThreshold);
	_parser.parseUINT32(flags);
	sideGameEntryMetaData.parseMsg(_parser);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	INT8 minigameEntryMode; _parser.parseINT8(minigameEntryMode);
	AtfValidator::validateIntRange(_descr, "minigameEntryMode", minigameEntryMode, sidegame::eSideGameEntryMode_Normal, sidegame::eSideGameEntryMode_Max, _checker, __FILE__, __LINE__);
	UINT64 minigameEntryRefId; _parser.parseUINT64(minigameEntryRefId);
	AtfValidator::validateUint(_descr, "minigameEntryRefId", minigameEntryRefId, _checker, __FILE__, __LINE__);
	INT8 numAutoPlays; _parser.parseINT8(numAutoPlays);
	AtfValidator::validateInt(_descr, "numAutoPlays", numAutoPlays, _checker, __FILE__, __LINE__);
	INT64 singleWinThreshold; _parser.parseINT64(singleWinThreshold);
	AtfValidator::validateInt(_descr, "singleWinThreshold", singleWinThreshold, _checker, __FILE__, __LINE__);
	INT64 totalLossesThreshold; _parser.parseINT64(totalLossesThreshold);
	AtfValidator::validateInt(_descr, "totalLossesThreshold", totalLossesThreshold, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	int szSideGameEntryMetaData = ThinAtf::LAtfVector< ThinAtf::CopyableMsgBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameEntryMetaData"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sideGameEntryMetaData", szSideGameEntryMetaData, 1024, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, autoPlayContextData(std::move(_o.autoPlayContextData))
	, orphanedAutoPlayContextData(std::move(_o.orphanedAutoPlayContextData))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		autoPlayContextData = std::move(_o.autoPlayContextData);
		orphanedAutoPlayContextData = std::move(_o.orphanedAutoPlayContextData);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	autoPlayContextData.clear();
	orphanedAutoPlayContextData.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		autoPlayContextData.equals(_o.autoPlayContextData) &&
		orphanedAutoPlayContextData.equals(_o.orphanedAutoPlayContextData);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_AUTOPLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("autoPlayContextData=");
		autoPlayContextData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("orphanedAutoPlayContextData=");
		orphanedAutoPlayContextData.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		autoPlayContextData.composeMsg(_msg);
		orphanedAutoPlayContextData.composeMsg(_msg);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		autoPlayContextData.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		orphanedAutoPlayContextData.parseMsg(_parser);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		AutoPlayContextData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("autoPlayContextData"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		AutoPlayContextData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("orphanedAutoPlayContextData"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_STOP_AUTOPLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::clear()
{
	requestId = 0;
	sideGameContext.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::equals(const Protocol_SIDEGAME_MSG_STOP_AUTOPLAY& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_STOP_AUTOPLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_STOP_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, numPendingGamesCanceled(std::move(_o.numPendingGamesCanceled))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		numPendingGamesCanceled = std::move(_o.numPendingGamesCanceled);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	numPendingGamesCanceled = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		numPendingGamesCanceled == _o.numPendingGamesCanceled;
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_STOP_AUTOPLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("numPendingGamesCanceled=");
		_buf.appendInt(numPendingGamesCanceled);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeINT8(numPendingGamesCanceled);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseINT8(numPendingGamesCanceled);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_STOP_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT8 numPendingGamesCanceled; _parser.parseINT8(numPendingGamesCanceled);
		AtfValidator::validateInt(_descr, "numPendingGamesCanceled", numPendingGamesCanceled, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_AUTOPLAY_STATE
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::clear()
{
	requestId = 0;
	sideGameContext.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::equals(const Protocol_SIDEGAME_MSG_AUTOPLAY_STATE& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_AUTOPLAY_STATE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_AUTOPLAY_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY(Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, autoPlayContextData(std::move(_o.autoPlayContextData))
	, orphanedAutoPlayContextData(std::move(_o.orphanedAutoPlayContextData))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::operator=(Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		autoPlayContextData = std::move(_o.autoPlayContextData);
		orphanedAutoPlayContextData = std::move(_o.orphanedAutoPlayContextData);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	autoPlayContextData.clear();
	orphanedAutoPlayContextData.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::equals(const Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		autoPlayContextData.equals(_o.autoPlayContextData) &&
		orphanedAutoPlayContextData.equals(_o.orphanedAutoPlayContextData);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_AUTOPLAY_STATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("autoPlayContextData=");
		autoPlayContextData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("orphanedAutoPlayContextData=");
		orphanedAutoPlayContextData.toTraceString(_buf);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		autoPlayContextData.composeMsg(_msg);
		orphanedAutoPlayContextData.composeMsg(_msg);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		autoPlayContextData.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		orphanedAutoPlayContextData.parseMsg(_parser);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_AUTOPLAY_STATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		AutoPlayContextData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("autoPlayContextData"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		AutoPlayContextData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("orphanedAutoPlayContextData"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::clear()
{
	requestId = 0;
	sideGameContext.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::equals(const Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_REPLAY_AUTOPLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_REPLAY_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::clear()
{
	requestId = 0;
	sideGameContext.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::equals(const Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW&& _o)
	: requestId(std::move(_o.requestId))
	, userIntId(std::move(_o.userIntId))
	, brandId(std::move(_o.brandId))
	, clientSiteId(std::move(_o.clientSiteId))
	, minigameId(std::move(_o.minigameId))
	, ticketId(std::move(_o.ticketId))
	, headerImageURL(std::move(_o.headerImageURL))
	, ticketTypeName(std::move(_o.ticketTypeName))
	, playsAvailable(std::move(_o.playsAvailable))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW& MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::operator=(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		userIntId = std::move(_o.userIntId);
		brandId = std::move(_o.brandId);
		clientSiteId = std::move(_o.clientSiteId);
		minigameId = std::move(_o.minigameId);
		ticketId = std::move(_o.ticketId);
		headerImageURL = std::move(_o.headerImageURL);
		ticketTypeName = std::move(_o.ticketTypeName);
		playsAvailable = std::move(_o.playsAvailable);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::clear()
{
	requestId = 0;
	userIntId = 0;
	brandId = 0;
	clientSiteId = 0;
	minigameId = 0;
	ticketId = 0;
	headerImageURL.clear();
	ticketTypeName.clear();
	playsAvailable = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::equals(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW& _o) const
{
	return requestId == _o.requestId &&
		userIntId == _o.userIntId &&
		brandId == _o.brandId &&
		clientSiteId == _o.clientSiteId &&
		minigameId == _o.minigameId &&
		ticketId == _o.ticketId &&
		headerImageURL.equals(_o.headerImageURL) &&
		ticketTypeName.equals(_o.ticketTypeName) &&
		playsAvailable == _o.playsAvailable;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("ticketId=");
	_buf.appendUint64(ticketId);
	_buf.append(',');
	_buf.append("headerImageURL=");
	_buf.append(headerImageURL);
	_buf.append(',');
	_buf.append("ticketTypeName=");
	_buf.append(ticketTypeName);
	_buf.append(',');
	_buf.append("playsAvailable=");
	_buf.appendInt(playsAvailable);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(userIntId);
	_msg.composeUINT32(brandId);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(minigameId);
	_msg.composeUINT64(ticketId);
	_msg.composeString(headerImageURL);
	_msg.composeString(ticketTypeName);
	_msg.composeINT32(playsAvailable);
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(userIntId);
	_parser.parseUINT32(brandId);
	_parser.parseUINT32(clientSiteId);
	_parser.parseUINT32(minigameId);
	_parser.parseUINT64(ticketId);
	_parser.parseStringP(headerImageURL);
	_parser.parseStringP(ticketTypeName);
	_parser.parseINT32(playsAvailable);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser.parseUINT32(brandId);
	AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateInt(_descr, "clientSiteId", clientSiteId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT64 ticketId; _parser.parseUINT64(ticketId);
	AtfValidator::validateUint(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "headerImageURL"); size_t szHeaderImageURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "headerImageURL", szHeaderImageURL, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ticketTypeName"); size_t szTicketTypeName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketTypeName", szTicketTypeName, _checker, __FILE__, __LINE__);
	INT32 playsAvailable; _parser.parseINT32(playsAvailable);
	AtfValidator::validateInt(_descr, "playsAvailable", playsAvailable, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, minigameId(std::move(_o.minigameId))
	, drawTime(std::move(_o.drawTime))
	, userId(std::move(_o.userId))
	, userTimeZone(std::move(_o.userTimeZone))
	, userLocale(std::move(_o.userLocale))
	, playsAvailable(std::move(_o.playsAvailable))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::operator=(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		minigameId = std::move(_o.minigameId);
		drawTime = std::move(_o.drawTime);
		userId = std::move(_o.userId);
		userTimeZone = std::move(_o.userTimeZone);
		userLocale = std::move(_o.userLocale);
		playsAvailable = std::move(_o.playsAvailable);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	minigameId = 0;
	drawTime.setNull();
	userId.clear();
	userTimeZone = 0;
	userLocale = 0;
	playsAvailable = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::equals(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		errStr.equals(_o.errStr) &&
		minigameId == _o.minigameId &&
		drawTime.equals(_o.drawTime) &&
		userId.equals(_o.userId) &&
		userTimeZone == _o.userTimeZone &&
		userLocale == _o.userLocale &&
		playsAvailable == _o.playsAvailable;
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("minigameId=");
		_buf.appendUint(minigameId);
		_buf.append(',');
		_buf.append("drawTime=");
		ThinAtf::AtfTempl<SrvTime>::ToTraceString(_buf, drawTime);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("userTimeZone=");
		_buf.appendUint(userTimeZone);
		_buf.append(',');
		_buf.append("userLocale=");
		_buf.appendUint(userLocale);
		_buf.append(',');
		_buf.append("playsAvailable=");
		_buf.appendInt(playsAvailable);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT32(minigameId);
		_msg.composeSrvTime(drawTime);
		_msg.composeString(userId);
		_msg.composeUINT32(userTimeZone);
		_msg.composeUINT32(userLocale);
		_msg.composeINT32(playsAvailable);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT32(minigameId);
		_parser.parseSrvTime(drawTime);
		_parser.parseStringP(userId);
		_parser.parseUINT32(userTimeZone);
		_parser.parseUINT32(userLocale);
		_parser.parseINT32(playsAvailable);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 minigameId; _parser.parseUINT32(minigameId);
		AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
		SrvTime drawTime; _parser.parseSrvTime(drawTime);
		AtfValidator::validateSrvDateTime(_descr, "drawTime", drawTime, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		UINT32 userTimeZone; _parser.parseUINT32(userTimeZone);
		AtfValidator::validateInt(_descr, "userTimeZone", userTimeZone, _checker, __FILE__, __LINE__);
		UINT32 userLocale; _parser.parseUINT32(userLocale);
		AtfValidator::validateInt(_descr, "userLocale", userLocale, _checker, __FILE__, __LINE__);
		INT32 playsAvailable; _parser.parseINT32(playsAvailable);
		AtfValidator::validateInt(_descr, "playsAvailable", playsAvailable, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool MiniGameClient::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MINIGAME_MSG_ACTIVE_GAMES: Protocol_MINIGAME_MSG_ACTIVE_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_ACTIVE_GAMES_REPLY: Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GAME_STATE: Protocol_MINIGAME_MSG_GAME_STATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GAME_STATE_REPLY: Protocol_MINIGAME_MSG_GAME_STATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_STACKED_TICKETS: Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_STACKED_TICKETS_REPLY: Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_TICKETS: Protocol_MINIGAME_MSG_GET_TICKETS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_TICKETS_REPLY: Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_PLAY_NEXT_ROUND: Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW: Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY: Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_SERVER_RESTARTING: Protocol_MINIGAME_MSG_SERVER_RESTARTING::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_START_GAME: Protocol_MINIGAME_MSG_START_GAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_START_GAME_REPLY: Protocol_MINIGAME_MSG_START_GAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_TICKET_LOOKUP: Protocol_MINIGAME_MSG_TICKET_LOOKUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_TICKET_LOOKUP_REPLY: Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "client"))
	{
		switch(_msgId)
		{
			case SIDEGAME_MSG_TRIGGER_ANIMATION: client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER: client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER: client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "sidegame"))
	{
		switch(_msgId)
		{
			case SIDEGAME_MSG_ACTIVE_GAMES: sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_ACTIVE_GAMES_REPLY: sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_AUTOPLAY_STATE: sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_AUTOPLAY_STATE_REPLY: sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_PLAY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_PLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CLAIM_PRIZE: sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CLAIM_PRIZE_REPLY: sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_FORFEIT: sidegame::Protocol_SIDEGAME_MSG_FORFEIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_FORFEIT_REPLY: sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF_LOCALIZED: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF_REPLY: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_STATE: sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_STATE_REPLY: sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_RING_SESSIONID: sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_RING_SESSIONID_REPLY: sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_STARSREWARDS_BAR: sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY: sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_TICKET_BALANCE: sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY: sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_HISTORIC_GAMES: sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_HISTORIC_GAMES_REPLY: sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_MAX_GAMES_REACHED: sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY: sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_REPLAY_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_SKIP_DELAY: sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_GAME: sidegame::Protocol_SIDEGAME_MSG_START_GAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_GAME_NEW: sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_GAME_REPLY: sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_STOP_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_STOP_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

