/**
 * minigamesclientprot.cpp
 *
 * This file was auto-generated from minigamesclientprot.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor minigamesclientprot.txt
 */
 
#include "minigamesclientprot.h"

//=================================================================
//                    NameValuePair
//=================================================================

MiniGameClient::NameValuePair::NameValuePair()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::NameValuePair::NameValuePair(NameValuePair&& _o)
	: name(std::move(_o.name))
	, value(std::move(_o.value))
{
}

MiniGameClient::NameValuePair& MiniGameClient::NameValuePair::operator=(NameValuePair&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		value = std::move(_o.value);
	}
	return *this;
}

#endif

void MiniGameClient::NameValuePair::clear()
{
	name.clear();
	value.clear();
}

bool MiniGameClient::NameValuePair::equals(const NameValuePair& _o) const
{
	return Atf::atfPStringEquals(name, _o.name) &&
		Atf::atfPStringEquals(value, _o.value);
}

const char *MiniGameClient::NameValuePair::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("value=");
	_buf.append(value);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::NameValuePair::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::encodeAsXmlElement("value", value, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::NameValuePair::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else if (_element.equals("value"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, value)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::NameValuePair::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(NameValuePair())) // not empty
	{
		_body.composeString(name);
		_body.composeString(value);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::NameValuePair::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(name);
	_parser0.parseStringP(value);
}

const char *MiniGameClient::NameValuePair::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	_jsonstr.compose("value", value);
	return _buf.c_str();
}

void MiniGameClient::NameValuePair::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
	_jparser.parseByNameThrow("value", value);
}

/* static */ void MiniGameClient::NameValuePair::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateInt(_descr, "name", name.length(), _checker, __FILE__, __LINE__);
	PString value; _jparser.validateByNameThrow("value", value);
	AtfValidator::validateInt(_descr, "value", value.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::NameValuePair::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "value"); size_t szValue = strlen(_dummy);
	AtfValidator::validateInt(_descr, "value", szValue, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGamePrize
//=================================================================

MiniGameClient::MiniGamePrize::MiniGamePrize()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGamePrize::MiniGamePrize(MiniGamePrize&& _o)
	: prizeType(std::move(_o.prizeType))
	, prizeName(std::move(_o.prizeName))
	, currency(std::move(_o.currency))
	, amount(std::move(_o.amount))
	, isTopPrize(std::move(_o.isTopPrize))
	, prizeDescription(std::move(_o.prizeDescription))
	, imageURLPrefix(std::move(_o.imageURLPrefix))
	, assetName(std::move(_o.assetName))
	, prizeProperties(std::move(_o.prizeProperties))
	, clickToLaunchURL(std::move(_o.clickToLaunchURL))
	, clickToLaunchButtonText(std::move(_o.clickToLaunchButtonText))
{
}

MiniGameClient::MiniGamePrize& MiniGameClient::MiniGamePrize::operator=(MiniGamePrize&& _o)
{
	if(this != &_o)
	{
		prizeType = std::move(_o.prizeType);
		prizeName = std::move(_o.prizeName);
		currency = std::move(_o.currency);
		amount = std::move(_o.amount);
		isTopPrize = std::move(_o.isTopPrize);
		prizeDescription = std::move(_o.prizeDescription);
		imageURLPrefix = std::move(_o.imageURLPrefix);
		assetName = std::move(_o.assetName);
		prizeProperties = std::move(_o.prizeProperties);
		clickToLaunchURL = std::move(_o.clickToLaunchURL);
		clickToLaunchButtonText = std::move(_o.clickToLaunchButtonText);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGamePrize::clear()
{
	prizeType = 0;
	prizeName.clear();
	currency.clear();
	amount = 0;
	isTopPrize = false;
	prizeDescription.clear();
	imageURLPrefix.clear();
	assetName.clear();
	prizeProperties.clear();
	clickToLaunchURL.clear();
	clickToLaunchButtonText.clear();
}

bool MiniGameClient::MiniGamePrize::equals(const MiniGamePrize& _o) const
{
	return prizeType == _o.prizeType &&
		prizeName.equals(_o.prizeName) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		amount == _o.amount &&
		isTopPrize == _o.isTopPrize &&
		prizeDescription.equals(_o.prizeDescription) &&
		Atf::atfPStringEquals(imageURLPrefix, _o.imageURLPrefix) &&
		Atf::atfPStringEquals(assetName, _o.assetName) &&
		prizeProperties.equals(_o.prizeProperties) &&
		Atf::atfPStringEquals(clickToLaunchURL, _o.clickToLaunchURL) &&
		clickToLaunchButtonText.equals(_o.clickToLaunchButtonText);
}

const char *MiniGameClient::MiniGamePrize::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeType=");
	_buf.appendInt(prizeType);
	_buf.append(',');
	_buf.append("prizeName=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, prizeName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append(',');
	_buf.append("isTopPrize=");
	_buf.appendUint(isTopPrize);
	_buf.append(',');
	_buf.append("prizeDescription=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, prizeDescription);
	_buf.append(',');
	_buf.append("imageURLPrefix=");
	_buf.append(imageURLPrefix);
	_buf.append(',');
	_buf.append("assetName=");
	_buf.append(assetName);
	_buf.append(',');
	_buf.append("prizeProperties=");
	prizeProperties.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clickToLaunchURL=");
	_buf.append(clickToLaunchURL);
	_buf.append(',');
	_buf.append("clickToLaunchButtonText=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, clickToLaunchButtonText);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGamePrize::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("prizeType", prizeType, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "prizeName", prizeName);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("isTopPrize", isTopPrize, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "prizeDescription", prizeDescription);
	Atf::XmlElement::encodeAsXmlElement("imageURLPrefix", imageURLPrefix, _buf);
	Atf::XmlElement::encodeAsXmlElement("assetName", assetName, _buf);
	prizeProperties.toXmlString("prizeProperties", _buf);
	Atf::XmlElement::encodeAsXmlElement("clickToLaunchURL", clickToLaunchURL, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "clickToLaunchButtonText", clickToLaunchButtonText);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGamePrize::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prizeType"))
		{
			prizeType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizeName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, prizeName);
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isTopPrize"))
		{
			isTopPrize = (*_value.ptr() == '1');
		}
		else if (_element.equals("prizeDescription"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, prizeDescription);
		}
		else if (_element.equals("imageURLPrefix"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, imageURLPrefix)) return false;
		}
		else if (_element.equals("assetName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, assetName)) return false;
		}
		else if (_element.equals("prizeProperties"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< NameValuePair, 4 > >::FromXmlString(_value, prizeProperties)) return false;
		}
		else if (_element.equals("clickToLaunchURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clickToLaunchURL)) return false;
		}
		else if (_element.equals("clickToLaunchButtonText"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, clickToLaunchButtonText);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGamePrize::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGamePrize())) // not empty
	{
		_body.composeINT32(prizeType);
		prizeName.compose(_body);
		_body.composeString(currency);
		_body.composeINT64(amount);
		_body.composeBOOL(isTopPrize);
		prizeDescription.compose(_body);
		_body.composeString(imageURLPrefix);
		_body.composeString(assetName);
		prizeProperties.composeMsg(_body, _ignoreJSON);
		_body.composeString(clickToLaunchURL);
		clickToLaunchButtonText.compose(_body);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGamePrize::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(prizeType);
	prizeName.parse(_parser0);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(amount);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(isTopPrize);
	if(_parser0.parseEnded()) return;
	prizeDescription.parse(_parser0);
	_parser0.parseStringP(imageURLPrefix);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(assetName);
	if(_parser0.parseEnded()) return;
	prizeProperties.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clickToLaunchURL);
	clickToLaunchButtonText.parse(_parser0);
}

const char *MiniGameClient::MiniGamePrize::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prizeType", prizeType);
	_jsonstr.compose("prizeName", prizeName);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("isTopPrize", isTopPrize);
	_jsonstr.compose("prizeDescription", prizeDescription);
	_jsonstr.compose("imageURLPrefix", imageURLPrefix);
	_jsonstr.compose("assetName", assetName);
	_jsonstr.compose("prizeProperties", prizeProperties);
	_jsonstr.compose("clickToLaunchURL", clickToLaunchURL);
	_jsonstr.compose("clickToLaunchButtonText", clickToLaunchButtonText);
	return _buf.c_str();
}

void MiniGameClient::MiniGamePrize::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prizeType", prizeType);
	_jparser.parseByNameThrow("prizeName", prizeName);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("amount", amount);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isTopPrize", isTopPrize);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("prizeDescription", prizeDescription);
	_jparser.parseByNameThrow("imageURLPrefix", imageURLPrefix);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("assetName", assetName);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("prizeProperties", prizeProperties);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clickToLaunchURL", clickToLaunchURL);
	_jparser.parseByNameThrow("clickToLaunchButtonText", clickToLaunchButtonText);
}

/* static */ void MiniGameClient::MiniGamePrize::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 prizeType; _jparser.validateByNameThrow("prizeType", prizeType);
	AtfValidator::validateInt(_descr, "prizeType", prizeType, _checker, __FILE__, __LINE__);
	I18nPString prizeName; _jparser.validateByNameThrow("prizeName", prizeName);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isTopPrize; _jparser.validateByNameThrow("isTopPrize", isTopPrize);
	AtfValidator::validateInt(_descr, "isTopPrize", isTopPrize, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	I18nPString prizeDescription; _jparser.validateByNameThrow("prizeDescription", prizeDescription);
	PString imageURLPrefix; _jparser.validateByNameThrow("imageURLPrefix", imageURLPrefix);
	AtfValidator::validateInt(_descr, "imageURLPrefix", imageURLPrefix.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString assetName; _jparser.validateByNameThrow("assetName", assetName);
	AtfValidator::validateInt(_descr, "assetName", assetName.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< NameValuePair > prizeProperties; _jparser.validateByNameThrow("prizeProperties", prizeProperties);
	AtfValidator::validateInt(_descr, "prizeProperties", prizeProperties.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString clickToLaunchURL; _jparser.validateByNameThrow("clickToLaunchURL", clickToLaunchURL);
	AtfValidator::validateInt(_descr, "clickToLaunchURL", clickToLaunchURL.length(), _checker, __FILE__, __LINE__);
	I18nPString clickToLaunchButtonText; _jparser.validateByNameThrow("clickToLaunchButtonText", clickToLaunchButtonText);
}

/*static*/ void MiniGameClient::MiniGamePrize::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 prizeType; _parser0.parseINT32(prizeType);
	AtfValidator::validateInt(_descr, "prizeType", prizeType, _checker, __FILE__, __LINE__);
	I18nPString prizeName; prizeName.parse(_parser0);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool isTopPrize; _parser0.parseBOOL(isTopPrize);
	AtfValidator::validateInt(_descr, "isTopPrize", isTopPrize, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	I18nPString prizeDescription; prizeDescription.parse(_parser0);
	_parser0.parseStringN(_dummy, 0, "imageURLPrefix"); size_t szImageURLPrefix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "imageURLPrefix", szImageURLPrefix, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "assetName"); size_t szAssetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "assetName", szAssetName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szPrizeProperties = Atf::LAtfVector< NameValuePair, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeProperties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeProperties", szPrizeProperties, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clickToLaunchURL"); size_t szClickToLaunchURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clickToLaunchURL", szClickToLaunchURL, _checker, __FILE__, __LINE__);
	I18nPString clickToLaunchButtonText; clickToLaunchButtonText.parse(_parser0);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGamePrizeLocalized
//=================================================================

MiniGameClient::MiniGamePrizeLocalized::MiniGamePrizeLocalized()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGamePrizeLocalized::MiniGamePrizeLocalized(MiniGamePrizeLocalized&& _o)
	: prizeType(std::move(_o.prizeType))
	, prizeName(std::move(_o.prizeName))
	, currency(std::move(_o.currency))
	, amount(std::move(_o.amount))
	, isTopPrize(std::move(_o.isTopPrize))
	, prizeDescription(std::move(_o.prizeDescription))
	, imageURLPrefix(std::move(_o.imageURLPrefix))
	, assetName(std::move(_o.assetName))
	, prizeProperties(std::move(_o.prizeProperties))
	, clickToLaunchURL(std::move(_o.clickToLaunchURL))
	, clickToLaunchButtonText(std::move(_o.clickToLaunchButtonText))
{
}

MiniGameClient::MiniGamePrizeLocalized& MiniGameClient::MiniGamePrizeLocalized::operator=(MiniGamePrizeLocalized&& _o)
{
	if(this != &_o)
	{
		prizeType = std::move(_o.prizeType);
		prizeName = std::move(_o.prizeName);
		currency = std::move(_o.currency);
		amount = std::move(_o.amount);
		isTopPrize = std::move(_o.isTopPrize);
		prizeDescription = std::move(_o.prizeDescription);
		imageURLPrefix = std::move(_o.imageURLPrefix);
		assetName = std::move(_o.assetName);
		prizeProperties = std::move(_o.prizeProperties);
		clickToLaunchURL = std::move(_o.clickToLaunchURL);
		clickToLaunchButtonText = std::move(_o.clickToLaunchButtonText);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGamePrizeLocalized::clear()
{
	prizeType = 0;
	prizeName.clear();
	currency.clear();
	amount = 0;
	isTopPrize = false;
	prizeDescription.clear();
	imageURLPrefix.clear();
	assetName.clear();
	prizeProperties.clear();
	clickToLaunchURL.clear();
	clickToLaunchButtonText.clear();
}

bool MiniGameClient::MiniGamePrizeLocalized::equals(const MiniGamePrizeLocalized& _o) const
{
	return prizeType == _o.prizeType &&
		Atf::atfPStringEquals(prizeName, _o.prizeName) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		amount == _o.amount &&
		isTopPrize == _o.isTopPrize &&
		Atf::atfPStringEquals(prizeDescription, _o.prizeDescription) &&
		Atf::atfPStringEquals(imageURLPrefix, _o.imageURLPrefix) &&
		Atf::atfPStringEquals(assetName, _o.assetName) &&
		prizeProperties.equals(_o.prizeProperties) &&
		Atf::atfPStringEquals(clickToLaunchURL, _o.clickToLaunchURL) &&
		Atf::atfPStringEquals(clickToLaunchButtonText, _o.clickToLaunchButtonText);
}

const char *MiniGameClient::MiniGamePrizeLocalized::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeType=");
	_buf.appendInt(prizeType);
	_buf.append(',');
	_buf.append("prizeName=");
	_buf.append(prizeName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append(',');
	_buf.append("isTopPrize=");
	_buf.appendUint(isTopPrize);
	_buf.append(',');
	_buf.append("prizeDescription=");
	_buf.append(prizeDescription);
	_buf.append(',');
	_buf.append("imageURLPrefix=");
	_buf.append(imageURLPrefix);
	_buf.append(',');
	_buf.append("assetName=");
	_buf.append(assetName);
	_buf.append(',');
	_buf.append("prizeProperties=");
	prizeProperties.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clickToLaunchURL=");
	_buf.append(clickToLaunchURL);
	_buf.append(',');
	_buf.append("clickToLaunchButtonText=");
	_buf.append(clickToLaunchButtonText);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGamePrizeLocalized::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("prizeType", prizeType, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizeName", prizeName, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("isTopPrize", isTopPrize, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizeDescription", prizeDescription, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageURLPrefix", imageURLPrefix, _buf);
	Atf::XmlElement::encodeAsXmlElement("assetName", assetName, _buf);
	prizeProperties.toXmlString("prizeProperties", _buf);
	Atf::XmlElement::encodeAsXmlElement("clickToLaunchURL", clickToLaunchURL, _buf);
	Atf::XmlElement::encodeAsXmlElement("clickToLaunchButtonText", clickToLaunchButtonText, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGamePrizeLocalized::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prizeType"))
		{
			prizeType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizeName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, prizeName)) return false;
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isTopPrize"))
		{
			isTopPrize = (*_value.ptr() == '1');
		}
		else if (_element.equals("prizeDescription"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, prizeDescription)) return false;
		}
		else if (_element.equals("imageURLPrefix"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, imageURLPrefix)) return false;
		}
		else if (_element.equals("assetName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, assetName)) return false;
		}
		else if (_element.equals("prizeProperties"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< NameValuePair, 4 > >::FromXmlString(_value, prizeProperties)) return false;
		}
		else if (_element.equals("clickToLaunchURL"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clickToLaunchURL)) return false;
		}
		else if (_element.equals("clickToLaunchButtonText"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clickToLaunchButtonText)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGamePrizeLocalized::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGamePrizeLocalized())) // not empty
	{
		_body.composeINT32(prizeType);
		_body.composeString(prizeName);
		_body.composeString(currency);
		_body.composeINT64(amount);
		_body.composeBOOL(isTopPrize);
		_body.composeString(prizeDescription);
		_body.composeString(imageURLPrefix);
		_body.composeString(assetName);
		prizeProperties.composeMsg(_body, _ignoreJSON);
		_body.composeString(clickToLaunchURL);
		_body.composeString(clickToLaunchButtonText);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGamePrizeLocalized::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(prizeType);
	_parser0.parseStringP(prizeName);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(amount);
	_parser0.parseBOOL(isTopPrize);
	_parser0.parseStringP(prizeDescription);
	_parser0.parseStringP(imageURLPrefix);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(assetName);
	if(_parser0.parseEnded()) return;
	prizeProperties.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(clickToLaunchURL);
	_parser0.parseStringP(clickToLaunchButtonText);
}

const char *MiniGameClient::MiniGamePrizeLocalized::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prizeType", prizeType);
	_jsonstr.compose("prizeName", prizeName);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("isTopPrize", isTopPrize);
	_jsonstr.compose("prizeDescription", prizeDescription);
	_jsonstr.compose("imageURLPrefix", imageURLPrefix);
	_jsonstr.compose("assetName", assetName);
	_jsonstr.compose("prizeProperties", prizeProperties);
	_jsonstr.compose("clickToLaunchURL", clickToLaunchURL);
	_jsonstr.compose("clickToLaunchButtonText", clickToLaunchButtonText);
	return _buf.c_str();
}

void MiniGameClient::MiniGamePrizeLocalized::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prizeType", prizeType);
	_jparser.parseByNameThrow("prizeName", prizeName);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("isTopPrize", isTopPrize);
	_jparser.parseByNameThrow("prizeDescription", prizeDescription);
	_jparser.parseByNameThrow("imageURLPrefix", imageURLPrefix);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("assetName", assetName);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("prizeProperties", prizeProperties);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clickToLaunchURL", clickToLaunchURL);
	_jparser.parseByNameThrow("clickToLaunchButtonText", clickToLaunchButtonText);
}

/* static */ void MiniGameClient::MiniGamePrizeLocalized::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 prizeType; _jparser.validateByNameThrow("prizeType", prizeType);
	AtfValidator::validateInt(_descr, "prizeType", prizeType, _checker, __FILE__, __LINE__);
	PString prizeName; _jparser.validateByNameThrow("prizeName", prizeName);
	AtfValidator::validateInt(_descr, "prizeName", prizeName.length(), _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	bool isTopPrize; _jparser.validateByNameThrow("isTopPrize", isTopPrize);
	AtfValidator::validateInt(_descr, "isTopPrize", isTopPrize, _checker, __FILE__, __LINE__);
	PString prizeDescription; _jparser.validateByNameThrow("prizeDescription", prizeDescription);
	AtfValidator::validateInt(_descr, "prizeDescription", prizeDescription.length(), _checker, __FILE__, __LINE__);
	PString imageURLPrefix; _jparser.validateByNameThrow("imageURLPrefix", imageURLPrefix);
	AtfValidator::validateInt(_descr, "imageURLPrefix", imageURLPrefix.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString assetName; _jparser.validateByNameThrow("assetName", assetName);
	AtfValidator::validateInt(_descr, "assetName", assetName.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< NameValuePair > prizeProperties; _jparser.validateByNameThrow("prizeProperties", prizeProperties);
	AtfValidator::validateInt(_descr, "prizeProperties", prizeProperties.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString clickToLaunchURL; _jparser.validateByNameThrow("clickToLaunchURL", clickToLaunchURL);
	AtfValidator::validateInt(_descr, "clickToLaunchURL", clickToLaunchURL.length(), _checker, __FILE__, __LINE__);
	PString clickToLaunchButtonText; _jparser.validateByNameThrow("clickToLaunchButtonText", clickToLaunchButtonText);
	AtfValidator::validateInt(_descr, "clickToLaunchButtonText", clickToLaunchButtonText.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGamePrizeLocalized::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 prizeType; _parser0.parseINT32(prizeType);
	AtfValidator::validateInt(_descr, "prizeType", prizeType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "prizeName"); size_t szPrizeName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "prizeName", szPrizeName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	bool isTopPrize; _parser0.parseBOOL(isTopPrize);
	AtfValidator::validateInt(_descr, "isTopPrize", isTopPrize, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "prizeDescription"); size_t szPrizeDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "prizeDescription", szPrizeDescription, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "imageURLPrefix"); size_t szImageURLPrefix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "imageURLPrefix", szImageURLPrefix, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "assetName"); size_t szAssetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "assetName", szAssetName, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	int szPrizeProperties = Atf::LAtfVector< NameValuePair, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeProperties"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeProperties", szPrizeProperties, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "clickToLaunchURL"); size_t szClickToLaunchURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clickToLaunchURL", szClickToLaunchURL, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clickToLaunchButtonText"); size_t szClickToLaunchButtonText = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clickToLaunchButtonText", szClickToLaunchButtonText, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGamePrizeBucket
//=================================================================

MiniGameClient::MiniGamePrizeBucket::MiniGamePrizeBucket()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGamePrizeBucket::MiniGamePrizeBucket(MiniGamePrizeBucket&& _o)
	: prizeBucketName(std::move(_o.prizeBucketName))
	, prizes(std::move(_o.prizes))
	, bucketOdds(std::move(_o.bucketOdds))
{
}

MiniGameClient::MiniGamePrizeBucket& MiniGameClient::MiniGamePrizeBucket::operator=(MiniGamePrizeBucket&& _o)
{
	if(this != &_o)
	{
		prizeBucketName = std::move(_o.prizeBucketName);
		prizes = std::move(_o.prizes);
		bucketOdds = std::move(_o.bucketOdds);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGamePrizeBucket::clear()
{
	prizeBucketName.clear();
	prizes.clear();
	bucketOdds = 0;
}

bool MiniGameClient::MiniGamePrizeBucket::equals(const MiniGamePrizeBucket& _o) const
{
	return prizeBucketName.equals(_o.prizeBucketName) &&
		prizes.equals(_o.prizes) &&
		bucketOdds == _o.bucketOdds;
}

const char *MiniGameClient::MiniGamePrizeBucket::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeBucketName=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, prizeBucketName);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bucketOdds=");
	_buf.appendInt(bucketOdds);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGamePrizeBucket::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "prizeBucketName", prizeBucketName);
	prizes.toXmlString("prizes", _buf);
	Atf::XmlElement::encodeAsXmlElement("bucketOdds", bucketOdds, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGamePrizeBucket::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prizeBucketName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, prizeBucketName);
		}
		else if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< MiniGamePrize , 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else if (_element.equals("bucketOdds"))
		{
			bucketOdds = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGamePrizeBucket::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGamePrizeBucket())) // not empty
	{
		prizeBucketName.compose(_body);
		CommMsgBody _body0;
		prizes.composeMsg(_body0, _ignoreJSON);
		_body.composeMsgBody(_body0);
		_body.composeINT32(bucketOdds);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGamePrizeBucket::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	prizeBucketName.parse(_parser0);
	parseAnonymousMsgBody0(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(bucketOdds);
}

const char *MiniGameClient::MiniGamePrizeBucket::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prizeBucketName", prizeBucketName);
	_jsonstr.compose("prizes", prizes);
	_jsonstr.compose("bucketOdds", bucketOdds);
	return _buf.c_str();
}

void MiniGameClient::MiniGamePrizeBucket::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prizeBucketName", prizeBucketName);
	_jparser.parseByNameThrow("prizes", prizes);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("bucketOdds", bucketOdds);
}

/* static */ void MiniGameClient::MiniGamePrizeBucket::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	I18nPString prizeBucketName; _jparser.validateByNameThrow("prizeBucketName", prizeBucketName);
	Atf::AtfVectorBase< MiniGamePrize > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 bucketOdds; _jparser.validateByNameThrow("bucketOdds", bucketOdds);
	AtfValidator::validateInt(_descr, "bucketOdds", bucketOdds, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGamePrizeBucket::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	I18nPString prizeBucketName; prizeBucketName.parse(_parser0);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	INT32 bucketOdds; _parser0.parseINT32(bucketOdds);
	AtfValidator::validateInt(_descr, "bucketOdds", bucketOdds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGamePrizeBucket::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	prizes.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGamePrizeBucket::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< MiniGamePrize , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGamePrizeBucketLocalized
//=================================================================

MiniGameClient::MiniGamePrizeBucketLocalized::MiniGamePrizeBucketLocalized()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGamePrizeBucketLocalized::MiniGamePrizeBucketLocalized(MiniGamePrizeBucketLocalized&& _o)
	: prizeBucketName(std::move(_o.prizeBucketName))
	, prizes(std::move(_o.prizes))
	, bucketOdds(std::move(_o.bucketOdds))
{
}

MiniGameClient::MiniGamePrizeBucketLocalized& MiniGameClient::MiniGamePrizeBucketLocalized::operator=(MiniGamePrizeBucketLocalized&& _o)
{
	if(this != &_o)
	{
		prizeBucketName = std::move(_o.prizeBucketName);
		prizes = std::move(_o.prizes);
		bucketOdds = std::move(_o.bucketOdds);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGamePrizeBucketLocalized::clear()
{
	prizeBucketName.clear();
	prizes.clear();
	bucketOdds = 0;
}

bool MiniGameClient::MiniGamePrizeBucketLocalized::equals(const MiniGamePrizeBucketLocalized& _o) const
{
	return Atf::atfPStringEquals(prizeBucketName, _o.prizeBucketName) &&
		prizes.equals(_o.prizes) &&
		bucketOdds == _o.bucketOdds;
}

const char *MiniGameClient::MiniGamePrizeBucketLocalized::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeBucketName=");
	_buf.append(prizeBucketName);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("bucketOdds=");
	_buf.appendInt(bucketOdds);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGamePrizeBucketLocalized::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("prizeBucketName", prizeBucketName, _buf);
	prizes.toXmlString("prizes", _buf);
	Atf::XmlElement::encodeAsXmlElement("bucketOdds", bucketOdds, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGamePrizeBucketLocalized::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prizeBucketName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, prizeBucketName)) return false;
		}
		else if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< MiniGamePrizeLocalized , 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else if (_element.equals("bucketOdds"))
		{
			bucketOdds = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGamePrizeBucketLocalized::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGamePrizeBucketLocalized())) // not empty
	{
		_body.composeString(prizeBucketName);
		CommMsgBody _body0;
		prizes.composeMsg(_body0, _ignoreJSON);
		_body.composeMsgBody(_body0);
		_body.composeINT32(bucketOdds);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGamePrizeBucketLocalized::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(prizeBucketName);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseINT32(bucketOdds);
}

const char *MiniGameClient::MiniGamePrizeBucketLocalized::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prizeBucketName", prizeBucketName);
	_jsonstr.compose("prizes", prizes);
	_jsonstr.compose("bucketOdds", bucketOdds);
	return _buf.c_str();
}

void MiniGameClient::MiniGamePrizeBucketLocalized::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prizeBucketName", prizeBucketName);
	_jparser.parseByNameThrow("prizes", prizes);
	_jparser.parseByNameThrow("bucketOdds", bucketOdds);
}

/* static */ void MiniGameClient::MiniGamePrizeBucketLocalized::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString prizeBucketName; _jparser.validateByNameThrow("prizeBucketName", prizeBucketName);
	AtfValidator::validateInt(_descr, "prizeBucketName", prizeBucketName.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MiniGamePrizeLocalized > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
	INT32 bucketOdds; _jparser.validateByNameThrow("bucketOdds", bucketOdds);
	AtfValidator::validateInt(_descr, "bucketOdds", bucketOdds, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGamePrizeBucketLocalized::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "prizeBucketName"); size_t szPrizeBucketName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "prizeBucketName", szPrizeBucketName, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 bucketOdds; _parser0.parseINT32(bucketOdds);
	AtfValidator::validateInt(_descr, "bucketOdds", bucketOdds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGamePrizeBucketLocalized::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	prizes.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGamePrizeBucketLocalized::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< MiniGamePrizeLocalized , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameBuyIn
//=================================================================

MiniGameClient::MiniGameBuyIn::MiniGameBuyIn()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameBuyIn::MiniGameBuyIn(MiniGameBuyIn&& _o)
	: buyInType(std::move(_o.buyInType))
	, currency(std::move(_o.currency))
	, amount(std::move(_o.amount))
{
}

MiniGameClient::MiniGameBuyIn& MiniGameClient::MiniGameBuyIn::operator=(MiniGameBuyIn&& _o)
{
	if(this != &_o)
	{
		buyInType = std::move(_o.buyInType);
		currency = std::move(_o.currency);
		amount = std::move(_o.amount);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameBuyIn::clear()
{
	buyInType = 0;
	currency.clear();
	amount = 0;
}

bool MiniGameClient::MiniGameBuyIn::equals(const MiniGameBuyIn& _o) const
{
	return buyInType == _o.buyInType &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		amount == _o.amount;
}

const char *MiniGameClient::MiniGameBuyIn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("buyInType=");
	_buf.appendInt(buyInType);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGameBuyIn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("buyInType", buyInType, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGameBuyIn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("buyInType"))
		{
			buyInType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGameBuyIn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameBuyIn())) // not empty
	{
		_body.composeINT32(buyInType);
		_body.composeString(currency);
		_body.composeINT64(amount);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameBuyIn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(buyInType);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(amount);
}

const char *MiniGameClient::MiniGameBuyIn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("buyInType", buyInType);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("amount", amount);
	return _buf.c_str();
}

void MiniGameClient::MiniGameBuyIn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("buyInType", buyInType);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("amount", amount);
}

/* static */ void MiniGameClient::MiniGameBuyIn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 buyInType; _jparser.validateByNameThrow("buyInType", buyInType);
	AtfValidator::validateInt(_descr, "buyInType", buyInType, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGameBuyIn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 buyInType; _parser0.parseINT32(buyInType);
	AtfValidator::validateInt(_descr, "buyInType", buyInType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameDefinition
//=================================================================

MiniGameClient::MiniGameDefinition::MiniGameDefinition()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameDefinition::MiniGameDefinition(MiniGameDefinition&& _o)
	: gameType(std::move(_o.gameType))
	, delayToPayout(std::move(_o.delayToPayout))
	, delayToPayoutAutoplay(std::move(_o.delayToPayoutAutoplay))
	, buyIn(std::move(_o.buyIn))
	, prizeTable(std::move(_o.prizeTable))
{
}

MiniGameClient::MiniGameDefinition& MiniGameClient::MiniGameDefinition::operator=(MiniGameDefinition&& _o)
{
	if(this != &_o)
	{
		gameType = std::move(_o.gameType);
		delayToPayout = std::move(_o.delayToPayout);
		delayToPayoutAutoplay = std::move(_o.delayToPayoutAutoplay);
		buyIn = std::move(_o.buyIn);
		prizeTable = std::move(_o.prizeTable);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameDefinition::clear()
{
	gameType = 0;
	delayToPayout = 0;
	delayToPayoutAutoplay = 0;
	buyIn.clear();
	prizeTable.clear();
}

bool MiniGameClient::MiniGameDefinition::equals(const MiniGameDefinition& _o) const
{
	return gameType == _o.gameType &&
		delayToPayout == _o.delayToPayout &&
		delayToPayoutAutoplay == _o.delayToPayoutAutoplay &&
		buyIn.equals(_o.buyIn) &&
		prizeTable.equals(_o.prizeTable);
}

const char *MiniGameClient::MiniGameDefinition::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("delayToPayout=");
	_buf.appendInt(delayToPayout);
	_buf.append(',');
	_buf.append("delayToPayoutAutoplay=");
	_buf.appendInt(delayToPayoutAutoplay);
	_buf.append(',');
	_buf.append("buyIn=");
	buyIn.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prizeTable=");
	prizeTable.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGameDefinition::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("delayToPayout", delayToPayout, _buf);
	Atf::XmlElement::encodeAsXmlElement("delayToPayoutAutoplay", delayToPayoutAutoplay, _buf);
	buyIn.toXmlString("buyIn", _buf);
	prizeTable.toXmlString("prizeTable", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGameDefinition::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameType"))
		{
			gameType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("delayToPayout"))
		{
			delayToPayout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("delayToPayoutAutoplay"))
		{
			delayToPayoutAutoplay = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			if(!Atf::AtfTempl< MiniGameBuyIn >::FromXmlString(_value, buyIn)) return false;
		}
		else if (_element.equals("prizeTable"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< MiniGamePrizeBucket , 4 > >::FromXmlString(_value, prizeTable)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGameDefinition::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameDefinition())) // not empty
	{
		_body.composeINT32(gameType);
		_body.composeINT32(delayToPayout);
		_body.composeINT32(delayToPayoutAutoplay);
		buyIn.composeMsg(_body, _ignoreJSON);
		CommMsgBody _body0;
		prizeTable.composeMsg(_body0, _ignoreJSON);
		_body.composeMsgBody(_body0);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameDefinition::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(gameType);
	_parser0.parseINT32(delayToPayout);
	_parser0.parseINT32(delayToPayoutAutoplay);
	buyIn.parseMsg(_parser0);
	parseAnonymousMsgBody0(_parser0);
}

const char *MiniGameClient::MiniGameDefinition::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("delayToPayout", delayToPayout);
	_jsonstr.compose("delayToPayoutAutoplay", delayToPayoutAutoplay);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("prizeTable", prizeTable);
	return _buf.c_str();
}

void MiniGameClient::MiniGameDefinition::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("delayToPayout", delayToPayout);
	_jparser.parseByNameThrow("delayToPayoutAutoplay", delayToPayoutAutoplay);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("prizeTable", prizeTable);
}

/* static */ void MiniGameClient::MiniGameDefinition::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	INT32 delayToPayout; _jparser.validateByNameThrow("delayToPayout", delayToPayout);
	AtfValidator::validateInt(_descr, "delayToPayout", delayToPayout, _checker, __FILE__, __LINE__);
	INT32 delayToPayoutAutoplay; _jparser.validateByNameThrow("delayToPayoutAutoplay", delayToPayoutAutoplay);
	AtfValidator::validateInt(_descr, "delayToPayoutAutoplay", delayToPayoutAutoplay, _checker, __FILE__, __LINE__);
	MiniGameBuyIn buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	Atf::AtfVectorBase< MiniGamePrizeBucket > prizeTable; _jparser.validateByNameThrow("prizeTable", prizeTable);
	AtfValidator::validateInt(_descr, "prizeTable", prizeTable.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGameDefinition::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 gameType; _parser0.parseINT32(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	INT32 delayToPayout; _parser0.parseINT32(delayToPayout);
	AtfValidator::validateInt(_descr, "delayToPayout", delayToPayout, _checker, __FILE__, __LINE__);
	INT32 delayToPayoutAutoplay; _parser0.parseINT32(delayToPayoutAutoplay);
	AtfValidator::validateInt(_descr, "delayToPayoutAutoplay", delayToPayoutAutoplay, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGameBuyIn::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("buyIn"), _fieldsWithUnparsedContent);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGameDefinition::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	prizeTable.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameDefinition::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPrizeTable = Atf::LAtfVector< MiniGamePrizeBucket , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeTable"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeTable", szPrizeTable, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameDefinitionLocalized
//=================================================================

MiniGameClient::MiniGameDefinitionLocalized::MiniGameDefinitionLocalized()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameDefinitionLocalized::MiniGameDefinitionLocalized(MiniGameDefinitionLocalized&& _o)
	: gameType(std::move(_o.gameType))
	, delayToPayout(std::move(_o.delayToPayout))
	, delayToPayoutAutoplay(std::move(_o.delayToPayoutAutoplay))
	, buyIn(std::move(_o.buyIn))
	, prizeTable(std::move(_o.prizeTable))
	, gameDefMsgBody(std::move(_o.gameDefMsgBody))
{
}

MiniGameClient::MiniGameDefinitionLocalized& MiniGameClient::MiniGameDefinitionLocalized::operator=(MiniGameDefinitionLocalized&& _o)
{
	if(this != &_o)
	{
		gameType = std::move(_o.gameType);
		delayToPayout = std::move(_o.delayToPayout);
		delayToPayoutAutoplay = std::move(_o.delayToPayoutAutoplay);
		buyIn = std::move(_o.buyIn);
		prizeTable = std::move(_o.prizeTable);
		gameDefMsgBody = std::move(_o.gameDefMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameDefinitionLocalized::clear()
{
	gameType = 0;
	delayToPayout = 0;
	delayToPayoutAutoplay = 0;
	buyIn.clear();
	prizeTable.clear();
	gameDefMsgBody.clear();
}

bool MiniGameClient::MiniGameDefinitionLocalized::equals(const MiniGameDefinitionLocalized& _o) const
{
	return gameType == _o.gameType &&
		delayToPayout == _o.delayToPayout &&
		delayToPayoutAutoplay == _o.delayToPayoutAutoplay &&
		buyIn.equals(_o.buyIn) &&
		prizeTable.equals(_o.prizeTable) &&
		gameDefMsgBody.equals(_o.gameDefMsgBody);
}

const char *MiniGameClient::MiniGameDefinitionLocalized::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("delayToPayout=");
	_buf.appendInt(delayToPayout);
	_buf.append(',');
	_buf.append("delayToPayoutAutoplay=");
	_buf.appendInt(delayToPayoutAutoplay);
	_buf.append(',');
	_buf.append("buyIn=");
	buyIn.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prizeTable=");
	prizeTable.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameDefMsgBody=");
	gameDefMsgBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGameDefinitionLocalized::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("delayToPayout", delayToPayout, _buf);
	Atf::XmlElement::encodeAsXmlElement("delayToPayoutAutoplay", delayToPayoutAutoplay, _buf);
	buyIn.toXmlString("buyIn", _buf);
	prizeTable.toXmlString("prizeTable", _buf);
	gameDefMsgBody.toXmlString("gameDefMsgBody", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGameDefinitionLocalized::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameType"))
		{
			gameType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("delayToPayout"))
		{
			delayToPayout = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("delayToPayoutAutoplay"))
		{
			delayToPayoutAutoplay = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			if(!Atf::AtfTempl< MiniGameBuyIn >::FromXmlString(_value, buyIn)) return false;
		}
		else if (_element.equals("prizeTable"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< MiniGamePrizeBucketLocalized , 4 > >::FromXmlString(_value, prizeTable)) return false;
		}
		else if (_element.equals("gameDefMsgBody"))
		{
			if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, gameDefMsgBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGameDefinitionLocalized::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameDefinitionLocalized())) // not empty
	{
		_body.composeINT32(gameType);
		_body.composeINT32(delayToPayout);
		_body.composeINT32(delayToPayoutAutoplay);
		buyIn.composeMsg(_body, _ignoreJSON);
		CommMsgBody _body0;
		prizeTable.composeMsg(_body0, _ignoreJSON);
		_body.composeMsgBody(_body0);
		gameDefMsgBody.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameDefinitionLocalized::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(gameType);
	_parser0.parseINT32(delayToPayout);
	_parser0.parseINT32(delayToPayoutAutoplay);
	buyIn.parseMsg(_parser0);
	parseAnonymousMsgBody0(_parser0);
	if(_parser0.parseEnded()) return;
	gameDefMsgBody.parseMsg(_parser0);
}

const char *MiniGameClient::MiniGameDefinitionLocalized::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("delayToPayout", delayToPayout);
	_jsonstr.compose("delayToPayoutAutoplay", delayToPayoutAutoplay);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("prizeTable", prizeTable);
	_jsonstr.compose("gameDefMsgBody", gameDefMsgBody);
	return _buf.c_str();
}

void MiniGameClient::MiniGameDefinitionLocalized::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("delayToPayout", delayToPayout);
	_jparser.parseByNameThrow("delayToPayoutAutoplay", delayToPayoutAutoplay);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("prizeTable", prizeTable);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("gameDefMsgBody", gameDefMsgBody);
}

/* static */ void MiniGameClient::MiniGameDefinitionLocalized::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	INT32 delayToPayout; _jparser.validateByNameThrow("delayToPayout", delayToPayout);
	AtfValidator::validateInt(_descr, "delayToPayout", delayToPayout, _checker, __FILE__, __LINE__);
	INT32 delayToPayoutAutoplay; _jparser.validateByNameThrow("delayToPayoutAutoplay", delayToPayoutAutoplay);
	AtfValidator::validateInt(_descr, "delayToPayoutAutoplay", delayToPayoutAutoplay, _checker, __FILE__, __LINE__);
	MiniGameBuyIn buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	Atf::AtfVectorBase< MiniGamePrizeBucketLocalized > prizeTable; _jparser.validateByNameThrow("prizeTable", prizeTable);
	AtfValidator::validateInt(_descr, "prizeTable", prizeTable.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::MsgBodyWithJSON gameDefMsgBody; _jparser.validateByNameThrow("gameDefMsgBody", gameDefMsgBody);
	AtfValidator::validateInt(_descr, "gameDefMsgBody", gameDefMsgBody.jsonLengthOrMsgBodySize(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGameDefinitionLocalized::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 gameType; _parser0.parseINT32(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	INT32 delayToPayout; _parser0.parseINT32(delayToPayout);
	AtfValidator::validateInt(_descr, "delayToPayout", delayToPayout, _checker, __FILE__, __LINE__);
	INT32 delayToPayoutAutoplay; _parser0.parseINT32(delayToPayoutAutoplay);
	AtfValidator::validateInt(_descr, "delayToPayoutAutoplay", delayToPayoutAutoplay, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGameBuyIn::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("buyIn"), _fieldsWithUnparsedContent);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	if(_parser0.parseEnded()) return;
	Atf::MsgBodyWithJSON gameDefMsgBody; gameDefMsgBody.parseMsg(_parser0);
	AtfValidator::validateInt(_descr, "gameDefMsgBody", gameDefMsgBody.jsonLengthOrMsgBodySize(), _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGameDefinitionLocalized::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	prizeTable.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameDefinitionLocalized::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPrizeTable = Atf::LAtfVector< MiniGamePrizeBucketLocalized , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeTable"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeTable", szPrizeTable, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameVisibility
//=================================================================

// @Override
void MiniGameClient::MiniGameVisibility::parseAnonymousMsgBody0( CommMsgParser& _parser )
{
	CommMsgBody msgBody;
	_parser.parseMsgBody( msgBody );

	CommMsgParser parser( msgBody );
	parser.parseBOOL( excludeCountries );

	UINT32 size;
	parser.parseUINT32( size );
	if( size )
	{
		countries.resize( size );
		for( UINT32 i = 0; i < size; ++i )
		{
			parser.parseStringP( countries[ i ] );
			countries[ i ].toUpper();
		}

		std::sort( countries.begin(), countries.end(), PStringCmp() );
	}
	else
	{
		countries.clear();
	}
}

MiniGameClient::MiniGameVisibility::MiniGameVisibility()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameVisibility::MiniGameVisibility(MiniGameVisibility&& _o)
	: brand(std::move(_o.brand))
	, site(std::move(_o.site))
	, excludeCountries(std::move(_o.excludeCountries))
	, countries(std::move(_o.countries))
	, criteria(std::move(_o.criteria))
	, tableCriteria(std::move(_o.tableCriteria))
	, siteMaskEx(std::move(_o.siteMaskEx))
{
}

MiniGameClient::MiniGameVisibility& MiniGameClient::MiniGameVisibility::operator=(MiniGameVisibility&& _o)
{
	if(this != &_o)
	{
		brand = std::move(_o.brand);
		site = std::move(_o.site);
		excludeCountries = std::move(_o.excludeCountries);
		countries = std::move(_o.countries);
		criteria = std::move(_o.criteria);
		tableCriteria = std::move(_o.tableCriteria);
		siteMaskEx = std::move(_o.siteMaskEx);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameVisibility::clear()
{
	brand = 0;
	site = 0;
	excludeCountries = false;
	countries.clear();
	criteria.clear();
	tableCriteria.clear();
	siteMaskEx.clear();
}

bool MiniGameClient::MiniGameVisibility::equals(const MiniGameVisibility& _o) const
{
	return brand == _o.brand &&
		site == _o.site &&
		excludeCountries == _o.excludeCountries &&
		countries.equals(_o.countries) &&
		Atf::atfPStringEquals(criteria, _o.criteria) &&
		Atf::atfPStringEquals(tableCriteria, _o.tableCriteria) &&
		siteMaskEx.equals(_o.siteMaskEx);
}

const char *MiniGameClient::MiniGameVisibility::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("brand=");
	_buf.appendUint(brand);
	_buf.append(',');
	_buf.append("site=");
	_buf.appendUint(site);
	_buf.append(',');
	_buf.append("excludeCountries=");
	_buf.appendUint(excludeCountries);
	_buf.append(',');
	_buf.append("countries=");
	countries.toTraceString(_buf);
	_buf.append(',');
	_buf.append("criteria=");
	_buf.append(criteria);
	_buf.append(',');
	_buf.append("tableCriteria=");
	_buf.append(tableCriteria);
	_buf.append(',');
	_buf.append("siteMaskEx=");
	siteMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGameVisibility::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("brand", brand, _buf);
	Atf::XmlElement::encodeAsXmlElement("site", site, _buf);
	Atf::XmlElement::encodeAsXmlElement("excludeCountries", excludeCountries, _buf);
	countries.toXmlString("countries", _buf);
	Atf::XmlElement::encodeAsXmlElement("criteria", criteria, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableCriteria", tableCriteria, _buf);
	siteMaskEx.toXmlString("siteMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGameVisibility::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("brand"))
		{
			brand = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("site"))
		{
			site = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("excludeCountries"))
		{
			excludeCountries = (*_value.ptr() == '1');
		}
		else if (_element.equals("countries"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PString , 4 > >::FromXmlString(_value, countries)) return false;
		}
		else if (_element.equals("criteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, criteria)) return false;
		}
		else if (_element.equals("tableCriteria"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableCriteria)) return false;
		}
		else if (_element.equals("siteMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, siteMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGameVisibility::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameVisibility())) // not empty
	{
		_body.composeUINT32(brand);
		_body.composeUINT32(site);
		CommMsgBody _body0;
		_body0.composeBOOL(excludeCountries);
		countries.composeMsg(_body0, _ignoreJSON);
		_body.composeMsgBody(_body0);
		_body.composeString(criteria);
		_body.composeString(tableCriteria);
		siteMaskEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameVisibility::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(brand);
	_parser0.parseUINT32(site);
	parseAnonymousMsgBody0(_parser0);
	_parser0.parseStringP(criteria);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringP(tableCriteria);
	if(_parser0.parseEnded()) return;
	siteMaskEx.parseMsg(_parser0);
}

const char *MiniGameClient::MiniGameVisibility::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("brand", brand);
	_jsonstr.compose("site", site);
	_jsonstr.compose("excludeCountries", excludeCountries);
	_jsonstr.compose("countries", countries);
	_jsonstr.compose("criteria", criteria);
	_jsonstr.compose("tableCriteria", tableCriteria);
	_jsonstr.compose("siteMaskEx", siteMaskEx);
	return _buf.c_str();
}

void MiniGameClient::MiniGameVisibility::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("brand", brand);
	_jparser.parseByNameThrow("site", site);
	_jparser.parseByNameThrow("excludeCountries", excludeCountries);
	_jparser.parseByNameThrow("countries", countries);
	_jparser.parseByNameThrow("criteria", criteria);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableCriteria", tableCriteria);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("siteMaskEx", siteMaskEx);
}

/* static */ void MiniGameClient::MiniGameVisibility::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 brand; _jparser.validateByNameThrow("brand", brand);
	AtfValidator::validateInt(_descr, "brand", brand, _checker, __FILE__, __LINE__);
	UINT32 site; _jparser.validateByNameThrow("site", site);
	AtfValidator::validateInt(_descr, "site", site, _checker, __FILE__, __LINE__);
	bool excludeCountries; _jparser.validateByNameThrow("excludeCountries", excludeCountries);
	AtfValidator::validateInt(_descr, "excludeCountries", excludeCountries, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PString > countries; _jparser.validateByNameThrow("countries", countries);
	AtfValidator::validateInt(_descr, "countries", countries.size(), _checker, __FILE__, __LINE__);
	PString criteria; _jparser.validateByNameThrow("criteria", criteria);
	AtfValidator::validateInt(_descr, "criteria", criteria.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString tableCriteria; _jparser.validateByNameThrow("tableCriteria", tableCriteria);
	AtfValidator::validateInt(_descr, "tableCriteria", tableCriteria.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask siteMaskEx; _jparser.validateByNameThrow("siteMaskEx", siteMaskEx);
}

/*static*/ void MiniGameClient::MiniGameVisibility::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 brand; _parser0.parseUINT32(brand);
	AtfValidator::validateInt(_descr, "brand", brand, _checker, __FILE__, __LINE__);
	UINT32 site; _parser0.parseUINT32(site);
	AtfValidator::validateInt(_descr, "site", site, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	_parser0.parseStringN(_dummy, 0, "criteria"); size_t szCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "criteria", szCriteria, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	_parser0.parseStringN(_dummy, 0, "tableCriteria"); size_t szTableCriteria = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableCriteria", szTableCriteria, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("siteMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

/*static*/ void MiniGameClient::MiniGameVisibility::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	bool excludeCountries; _parser0.parseBOOL(excludeCountries);
	AtfValidator::validateInt(_descr, "excludeCountries", excludeCountries, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCountries = Atf::LAtfVector< PString , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("countries"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "countries", szCountries, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameMetaData
//=================================================================

MiniGameClient::MiniGameMetaData::MiniGameMetaData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameMetaData::MiniGameMetaData(MiniGameMetaData&& _o)
	: metaData(std::move(_o.metaData))
{
}

MiniGameClient::MiniGameMetaData& MiniGameClient::MiniGameMetaData::operator=(MiniGameMetaData&& _o)
{
	if(this != &_o)
	{
		metaData = std::move(_o.metaData);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameMetaData::clear()
{
	metaData.clear();
}

bool MiniGameClient::MiniGameMetaData::equals(const MiniGameMetaData& _o) const
{
	return metaData.equals(_o.metaData);
}

const char *MiniGameClient::MiniGameMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("metaData=");
	metaData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGameMetaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	metaData.toXmlString("metaData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGameMetaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("metaData"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32 , 4 > >::FromXmlString(_value, metaData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGameMetaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameMetaData())) // not empty
	{
		metaData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	metaData.parseMsg(_parser0);
}

const char *MiniGameClient::MiniGameMetaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("metaData", metaData);
	return _buf.c_str();
}

void MiniGameClient::MiniGameMetaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("metaData", metaData);
}

/* static */ void MiniGameClient::MiniGameMetaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< INT32 > metaData; _jparser.validateByNameThrow("metaData", metaData);
	AtfValidator::validateInt(_descr, "metaData", metaData.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGameMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szMetaData = Atf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("metaData"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "metaData", szMetaData, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameRound
//=================================================================

MiniGameClient::MiniGameRound::MiniGameRound()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameRound::MiniGameRound(MiniGameRound&& _o)
	: timestamp(std::move(_o.timestamp))
	, decisions(std::move(_o.decisions))
	, results(std::move(_o.results))
	, prizeBucket(std::move(_o.prizeBucket))
	, state(std::move(_o.state))
	, metaData(std::move(_o.metaData))
{
}

MiniGameClient::MiniGameRound& MiniGameClient::MiniGameRound::operator=(MiniGameRound&& _o)
{
	if(this != &_o)
	{
		timestamp = std::move(_o.timestamp);
		decisions = std::move(_o.decisions);
		results = std::move(_o.results);
		prizeBucket = std::move(_o.prizeBucket);
		state = std::move(_o.state);
		metaData = std::move(_o.metaData);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameRound::clear()
{
	timestamp = 0;
	decisions.clear();
	results.clear();
	prizeBucket = 0;
	state = 0;
	metaData.clear();
}

bool MiniGameClient::MiniGameRound::equals(const MiniGameRound& _o) const
{
	return timestamp == _o.timestamp &&
		decisions.equals(_o.decisions) &&
		results.equals(_o.results) &&
		prizeBucket == _o.prizeBucket &&
		state == _o.state &&
		metaData.equals(_o.metaData);
}

const char *MiniGameClient::MiniGameRound::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("decisions=");
	decisions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("results=");
	results.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prizeBucket=");
	_buf.appendInt(prizeBucket);
	_buf.append(',');
	_buf.append("state=");
	_buf.appendInt(state);
	_buf.append(',');
	_buf.append("metaData=");
	metaData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGameRound::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("timestamp", timestamp, _buf);
	decisions.toXmlString("decisions", _buf);
	results.toXmlString("results", _buf);
	Atf::XmlElement::encodeAsXmlElement("prizeBucket", prizeBucket, _buf);
	Atf::XmlElement::encodeAsXmlElement("state", state, _buf);
	metaData.toXmlString("metaData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGameRound::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("timestamp"))
		{
			timestamp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("decisions"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32 , 4 > >::FromXmlString(_value, decisions)) return false;
		}
		else if (_element.equals("results"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32 , 4 > >::FromXmlString(_value, results)) return false;
		}
		else if (_element.equals("prizeBucket"))
		{
			prizeBucket = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("state"))
		{
			state = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("metaData"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< MiniGameMetaData , 4 > >::FromXmlString(_value, metaData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGameRound::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameRound())) // not empty
	{
		_body.composeINT32(timestamp);
		decisions.composeMsg(_body, _ignoreJSON);
		results.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(prizeBucket);
		CommMsgBody _body0;
		_body0.composeINT32(state);
		metaData.composeMsg(_body0, _ignoreJSON);
		_body.composeMsgBody(_body0);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameRound::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(timestamp);
	decisions.parseMsg(_parser0);
	results.parseMsg(_parser0);
	_parser0.parseINT32(prizeBucket);
	parseAnonymousMsgBody0(_parser0);
}

const char *MiniGameClient::MiniGameRound::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("timestamp", timestamp);
	_jsonstr.compose("decisions", decisions);
	_jsonstr.compose("results", results);
	_jsonstr.compose("prizeBucket", prizeBucket);
	_jsonstr.compose("state", state);
	_jsonstr.compose("metaData", metaData);
	return _buf.c_str();
}

void MiniGameClient::MiniGameRound::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("timestamp", timestamp);
	_jparser.parseByNameThrow("decisions", decisions);
	_jparser.parseByNameThrow("results", results);
	_jparser.parseByNameThrow("prizeBucket", prizeBucket);
	_jparser.parseByNameThrow("state", state);
	_jparser.parseByNameThrow("metaData", metaData);
}

/* static */ void MiniGameClient::MiniGameRound::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 timestamp; _jparser.validateByNameThrow("timestamp", timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > decisions; _jparser.validateByNameThrow("decisions", decisions);
	AtfValidator::validateInt(_descr, "decisions", decisions.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > results; _jparser.validateByNameThrow("results", results);
	AtfValidator::validateInt(_descr, "results", results.size(), _checker, __FILE__, __LINE__);
	INT32 prizeBucket; _jparser.validateByNameThrow("prizeBucket", prizeBucket);
	AtfValidator::validateInt(_descr, "prizeBucket", prizeBucket, _checker, __FILE__, __LINE__);
	INT32 state; _jparser.validateByNameThrow("state", state);
	AtfValidator::validateInt(_descr, "state", state, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MiniGameMetaData > metaData; _jparser.validateByNameThrow("metaData", metaData);
	AtfValidator::validateInt(_descr, "metaData", metaData.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGameRound::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szDecisions = Atf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("decisions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "decisions", szDecisions, _checker, __FILE__, __LINE__);
	int szResults = Atf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("results"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "results", szResults, _checker, __FILE__, __LINE__);
	INT32 prizeBucket; _parser0.parseINT32(prizeBucket);
	AtfValidator::validateInt(_descr, "prizeBucket", prizeBucket, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGameRound::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseINT32(state);
	metaData.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameRound::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 state; _parser0.parseINT32(state);
	AtfValidator::validateInt(_descr, "state", state, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szMetaData = Atf::LAtfVector< MiniGameMetaData , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("metaData"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "metaData", szMetaData, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameState
//=================================================================

MiniGameClient::MiniGameState::MiniGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameState::MiniGameState(MiniGameState&& _o)
	: minigamePlayId(std::move(_o.minigamePlayId))
	, minigameId(std::move(_o.minigameId))
	, rounds(std::move(_o.rounds))
{
}

MiniGameClient::MiniGameState& MiniGameClient::MiniGameState::operator=(MiniGameState&& _o)
{
	if(this != &_o)
	{
		minigamePlayId = std::move(_o.minigamePlayId);
		minigameId = std::move(_o.minigameId);
		rounds = std::move(_o.rounds);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameState::clear()
{
	minigamePlayId = 0;
	minigameId = 0;
	rounds.clear();
}

bool MiniGameClient::MiniGameState::equals(const MiniGameState& _o) const
{
	return minigamePlayId == _o.minigamePlayId &&
		minigameId == _o.minigameId &&
		rounds.equals(_o.rounds);
}

const char *MiniGameClient::MiniGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("rounds=");
	rounds.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGameState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minigamePlayId", minigamePlayId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	rounds.toXmlString("rounds", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGameState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minigamePlayId"))
		{
			minigamePlayId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameId"))
		{
			minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rounds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< MiniGameRound , 4 > >::FromXmlString(_value, rounds)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGameState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MiniGameState())) // not empty
	{
		_body.composeUINT64(minigamePlayId);
		_body.composeUINT32(minigameId);
		CommMsgBody _body0;
		rounds.composeMsg(_body0, _ignoreJSON);
		_body.composeMsgBody(_body0);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MiniGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(minigamePlayId);
	_parser0.parseUINT32(minigameId);
	parseAnonymousMsgBody0(_parser0);
}

const char *MiniGameClient::MiniGameState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minigamePlayId", minigamePlayId);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("rounds", rounds);
	return _buf.c_str();
}

void MiniGameClient::MiniGameState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minigamePlayId", minigamePlayId);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("rounds", rounds);
}

/* static */ void MiniGameClient::MiniGameState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 minigamePlayId; _jparser.validateByNameThrow("minigamePlayId", minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MiniGameRound > rounds; _jparser.validateByNameThrow("rounds", rounds);
	AtfValidator::validateInt(_descr, "rounds", rounds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 minigamePlayId; _parser0.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::MiniGameState::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	rounds.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::MiniGameState::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szRounds = Atf::LAtfVector< MiniGameRound , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("rounds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "rounds", szRounds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MGConnInfo
//=================================================================

MiniGameClient::MGConnInfo::MGConnInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MGConnInfo::MGConnInfo(MGConnInfo&& _o)
	: address(std::move(_o.address))
	, instance(std::move(_o.instance))
{
}

MiniGameClient::MGConnInfo& MiniGameClient::MGConnInfo::operator=(MGConnInfo&& _o)
{
	if(this != &_o)
	{
		address = std::move(_o.address);
		instance = std::move(_o.instance);
	}
	return *this;
}

#endif

void MiniGameClient::MGConnInfo::clear()
{
	address.clear();
	instance.clear();
}

bool MiniGameClient::MGConnInfo::equals(const MGConnInfo& _o) const
{
	return Atf::atfPStringEquals(address, _o.address) &&
		Atf::atfPStringEquals(instance, _o.instance);
}

const char *MiniGameClient::MGConnInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("address=");
	_buf.append(address);
	_buf.append(',');
	_buf.append("instance=");
	_buf.append(instance);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MGConnInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("address", address, _buf);
	Atf::XmlElement::encodeAsXmlElement("instance", instance, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MGConnInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("address"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, address)) return false;
		}
		else if (_element.equals("instance"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, instance)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MGConnInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MGConnInfo())) // not empty
	{
		_body.composeString(address);
		_body.composeString(instance);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::MGConnInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(address);
	_parser0.parseStringP(instance);
}

const char *MiniGameClient::MGConnInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("address", address);
	_jsonstr.compose("instance", instance);
	return _buf.c_str();
}

void MiniGameClient::MGConnInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("address", address);
	_jparser.parseByNameThrow("instance", instance);
}

/* static */ void MiniGameClient::MGConnInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString address; _jparser.validateByNameThrow("address", address);
	AtfValidator::validateInt(_descr, "address", address.length(), _checker, __FILE__, __LINE__);
	PString instance; _jparser.validateByNameThrow("instance", instance);
	AtfValidator::validateInt(_descr, "instance", instance.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MGConnInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "address"); size_t szAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "address", szAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "instance"); size_t szInstance = strlen(_dummy);
	AtfValidator::validateInt(_descr, "instance", szInstance, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MiniGameTypeLeaf
//=================================================================

MiniGameClient::MiniGameTypeLeaf::MiniGameTypeLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameTypeLeaf::MiniGameTypeLeaf(MiniGameTypeLeaf&& _o)
	: gameStatus(std::move(_o.gameStatus))
	, minigameId(std::move(_o.minigameId))
	, minigameDef(std::move(_o.minigameDef))
	, visibility(std::move(_o.visibility))
	, url(std::move(_o.url))
	, mgConnInfo(std::move(_o.mgConnInfo))
	, clientDisplayName(std::move(_o.clientDisplayName))
	, clientDisplayInfo(std::move(_o.clientDisplayInfo))
	, clientDisplayInProgressTag(std::move(_o.clientDisplayInProgressTag))
	, contentURLPrefix(std::move(_o.contentURLPrefix))
	, clientDisplayGameDescription(std::move(_o.clientDisplayGameDescription))
{
}

MiniGameClient::MiniGameTypeLeaf& MiniGameClient::MiniGameTypeLeaf::operator=(MiniGameTypeLeaf&& _o)
{
	if(this != &_o)
	{
		gameStatus = std::move(_o.gameStatus);
		minigameId = std::move(_o.minigameId);
		minigameDef = std::move(_o.minigameDef);
		visibility = std::move(_o.visibility);
		url = std::move(_o.url);
		mgConnInfo = std::move(_o.mgConnInfo);
		clientDisplayName = std::move(_o.clientDisplayName);
		clientDisplayInfo = std::move(_o.clientDisplayInfo);
		clientDisplayInProgressTag = std::move(_o.clientDisplayInProgressTag);
		contentURLPrefix = std::move(_o.contentURLPrefix);
		clientDisplayGameDescription = std::move(_o.clientDisplayGameDescription);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameTypeLeaf::clear()
{
	gameStatus = 0;
	minigameId = 0;
	minigameDef.clear();
	visibility.clear();
	url.clear();
	mgConnInfo.clear();
	clientDisplayName.clear();
	clientDisplayInfo.clear();
	clientDisplayInProgressTag.clear();
	contentURLPrefix.clear();
	clientDisplayGameDescription.clear();
}

bool MiniGameClient::MiniGameTypeLeaf::equals(const MiniGameTypeLeaf& _o) const
{
	return gameStatus == _o.gameStatus &&
		minigameId == _o.minigameId &&
		minigameDef.equals(_o.minigameDef) &&
		visibility.equals(_o.visibility) &&
		Atf::atfPStringEquals(url, _o.url) &&
		mgConnInfo.equals(_o.mgConnInfo) &&
		clientDisplayName.equals(_o.clientDisplayName) &&
		clientDisplayInfo.equals(_o.clientDisplayInfo) &&
		clientDisplayInProgressTag.equals(_o.clientDisplayInProgressTag) &&
		Atf::atfPStringEquals(contentURLPrefix, _o.contentURLPrefix) &&
		clientDisplayGameDescription.equals(_o.clientDisplayGameDescription);
}

const char *MiniGameClient::MiniGameTypeLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameStatus=");
	_buf.appendInt(gameStatus);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("minigameDef=");
	minigameDef.toTraceString(_buf);
	_buf.append(',');
	_buf.append("visibility=");
	visibility.toTraceString(_buf);
	_buf.append(',');
	_buf.append("url=");
	_buf.append(url);
	_buf.append(',');
	_buf.append("mgConnInfo=");
	mgConnInfo.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientDisplayName=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, clientDisplayName);
	_buf.append(',');
	_buf.append("clientDisplayInfo=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, clientDisplayInfo);
	_buf.append(',');
	_buf.append("clientDisplayInProgressTag=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, clientDisplayInProgressTag);
	_buf.append(',');
	_buf.append("contentURLPrefix=");
	_buf.append(contentURLPrefix);
	_buf.append(',');
	_buf.append("clientDisplayGameDescription=");
	Atf::AtfTempl<I18nPString>::ToTraceString(_buf, clientDisplayGameDescription);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGameTypeLeaf::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameStatus", gameStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	minigameDef.toXmlString("minigameDef", _buf);
	visibility.toXmlString("visibility", _buf);
	Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	mgConnInfo.toXmlString("mgConnInfo", _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "clientDisplayName", clientDisplayName);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "clientDisplayInfo", clientDisplayInfo);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "clientDisplayInProgressTag", clientDisplayInProgressTag);
	Atf::XmlElement::encodeAsXmlElement("contentURLPrefix", contentURLPrefix, _buf);
	Atf::AtfTempl<I18nPString>::ToXmlString(_buf, "clientDisplayGameDescription", clientDisplayGameDescription);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGameTypeLeaf::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameStatus"))
		{
			gameStatus = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameId"))
		{
			minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameDef"))
		{
			if(!Atf::AtfTempl< MiniGameDefinition >::FromXmlString(_value, minigameDef)) return false;
		}
		else if (_element.equals("visibility"))
		{
			if(!Atf::AtfTempl< MiniGameVisibility >::FromXmlString(_value, visibility)) return false;
		}
		else if (_element.equals("url"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
		}
		else if (_element.equals("mgConnInfo"))
		{
			if(!Atf::AtfTempl< MGConnInfo >::FromXmlString(_value, mgConnInfo)) return false;
		}
		else if (_element.equals("clientDisplayName"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, clientDisplayName);
		}
		else if (_element.equals("clientDisplayInfo"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, clientDisplayInfo);
		}
		else if (_element.equals("clientDisplayInProgressTag"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, clientDisplayInProgressTag);
		}
		else if (_element.equals("contentURLPrefix"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, contentURLPrefix)) return false;
		}
		else if (_element.equals("clientDisplayGameDescription"))
		{
			Atf::AtfTempl<I18nPString>::FromXmlString(_value, clientDisplayGameDescription);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGameTypeLeaf::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(gameStatus);
	_msg.composeUINT32(minigameId);
	minigameDef.composeMsg(_msg, _ignoreJSON);
	visibility.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(url);
	mgConnInfo.composeMsg(_msg, _ignoreJSON);
	clientDisplayName.compose(_msg);
	clientDisplayInfo.compose(_msg);
	clientDisplayInProgressTag.compose(_msg);
	_msg.composeString(contentURLPrefix);
	clientDisplayGameDescription.compose(_msg);
}

void MiniGameClient::MiniGameTypeLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(gameStatus);
	_parser.parseUINT32(minigameId);
	minigameDef.parseMsg(_parser);
	visibility.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(url);
	mgConnInfo.parseMsg(_parser);
	clientDisplayName.parse(_parser);
	clientDisplayInfo.parse(_parser);
	if(_parser.parseEnded()) return;
	clientDisplayInProgressTag.parse(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(contentURLPrefix);
	if(_parser.parseEnded()) return;
	clientDisplayGameDescription.parse(_parser);
}

const char *MiniGameClient::MiniGameTypeLeaf::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameStatus", gameStatus);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("minigameDef", minigameDef);
	_jsonstr.compose("visibility", visibility);
	_jsonstr.compose("url", url);
	_jsonstr.compose("mgConnInfo", mgConnInfo);
	_jsonstr.compose("clientDisplayName", clientDisplayName);
	_jsonstr.compose("clientDisplayInfo", clientDisplayInfo);
	_jsonstr.compose("clientDisplayInProgressTag", clientDisplayInProgressTag);
	_jsonstr.compose("contentURLPrefix", contentURLPrefix);
	_jsonstr.compose("clientDisplayGameDescription", clientDisplayGameDescription);
	return _buf.c_str();
}

void MiniGameClient::MiniGameTypeLeaf::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameStatus", gameStatus);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("minigameDef", minigameDef);
	_jparser.parseByNameThrow("visibility", visibility);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("url", url);
	_jparser.parseByNameThrow("mgConnInfo", mgConnInfo);
	_jparser.parseByNameThrow("clientDisplayName", clientDisplayName);
	_jparser.parseByNameThrow("clientDisplayInfo", clientDisplayInfo);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientDisplayInProgressTag", clientDisplayInProgressTag);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("contentURLPrefix", contentURLPrefix);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientDisplayGameDescription", clientDisplayGameDescription);
}

/* static */ void MiniGameClient::MiniGameTypeLeaf::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 gameStatus; _jparser.validateByNameThrow("gameStatus", gameStatus);
	AtfValidator::validateInt(_descr, "gameStatus", gameStatus, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	MiniGameDefinition minigameDef; _jparser.validateByNameThrow("minigameDef", minigameDef);
	MiniGameVisibility visibility; _jparser.validateByNameThrow("visibility", visibility);
	if(_jparser.parseEnded()) return;
	PString url; _jparser.validateByNameThrow("url", url);
	AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	MGConnInfo mgConnInfo; _jparser.validateByNameThrow("mgConnInfo", mgConnInfo);
	I18nPString clientDisplayName; _jparser.validateByNameThrow("clientDisplayName", clientDisplayName);
	I18nPString clientDisplayInfo; _jparser.validateByNameThrow("clientDisplayInfo", clientDisplayInfo);
	if(_jparser.parseEnded()) return;
	I18nPString clientDisplayInProgressTag; _jparser.validateByNameThrow("clientDisplayInProgressTag", clientDisplayInProgressTag);
	if(_jparser.parseEnded()) return;
	PString contentURLPrefix; _jparser.validateByNameThrow("contentURLPrefix", contentURLPrefix);
	AtfValidator::validateInt(_descr, "contentURLPrefix", contentURLPrefix.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	I18nPString clientDisplayGameDescription; _jparser.validateByNameThrow("clientDisplayGameDescription", clientDisplayGameDescription);
}

/*static*/ void MiniGameClient::MiniGameTypeLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 gameStatus; _parser.parseINT32(gameStatus);
	AtfValidator::validateInt(_descr, "gameStatus", gameStatus, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGameDefinition::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("minigameDef"), _fieldsWithUnparsedContent);
	MiniGameVisibility::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibility"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
	AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	MGConnInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("mgConnInfo"), _fieldsWithUnparsedContent);
	I18nPString clientDisplayName; clientDisplayName.parse(_parser);
	I18nPString clientDisplayInfo; clientDisplayInfo.parse(_parser);
	if(_parser.parseEnded()) return;
	I18nPString clientDisplayInProgressTag; clientDisplayInProgressTag.parse(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "contentURLPrefix"); size_t szContentURLPrefix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contentURLPrefix", szContentURLPrefix, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	I18nPString clientDisplayGameDescription; clientDisplayGameDescription.parse(_parser);
}

//=================================================================
//                    MiniGameDefLocalized
//=================================================================

MiniGameClient::MiniGameDefLocalized::MiniGameDefLocalized()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::MiniGameDefLocalized::MiniGameDefLocalized(MiniGameDefLocalized&& _o)
	: gameStatus(std::move(_o.gameStatus))
	, minigameId(std::move(_o.minigameId))
	, minigameDef(std::move(_o.minigameDef))
	, clientDisplayName(std::move(_o.clientDisplayName))
	, clientDisplayInfo(std::move(_o.clientDisplayInfo))
	, clientDisplayInProgressTag(std::move(_o.clientDisplayInProgressTag))
	, contentURLPrefix(std::move(_o.contentURLPrefix))
	, clientDisplayGameDescription(std::move(_o.clientDisplayGameDescription))
{
}

MiniGameClient::MiniGameDefLocalized& MiniGameClient::MiniGameDefLocalized::operator=(MiniGameDefLocalized&& _o)
{
	if(this != &_o)
	{
		gameStatus = std::move(_o.gameStatus);
		minigameId = std::move(_o.minigameId);
		minigameDef = std::move(_o.minigameDef);
		clientDisplayName = std::move(_o.clientDisplayName);
		clientDisplayInfo = std::move(_o.clientDisplayInfo);
		clientDisplayInProgressTag = std::move(_o.clientDisplayInProgressTag);
		contentURLPrefix = std::move(_o.contentURLPrefix);
		clientDisplayGameDescription = std::move(_o.clientDisplayGameDescription);
	}
	return *this;
}

#endif

void MiniGameClient::MiniGameDefLocalized::clear()
{
	gameStatus = 0;
	minigameId = 0;
	minigameDef.clear();
	clientDisplayName.clear();
	clientDisplayInfo.clear();
	clientDisplayInProgressTag.clear();
	contentURLPrefix.clear();
	clientDisplayGameDescription.clear();
}

bool MiniGameClient::MiniGameDefLocalized::equals(const MiniGameDefLocalized& _o) const
{
	return gameStatus == _o.gameStatus &&
		minigameId == _o.minigameId &&
		minigameDef.equals(_o.minigameDef) &&
		Atf::atfPStringEquals(clientDisplayName, _o.clientDisplayName) &&
		Atf::atfPStringEquals(clientDisplayInfo, _o.clientDisplayInfo) &&
		Atf::atfPStringEquals(clientDisplayInProgressTag, _o.clientDisplayInProgressTag) &&
		Atf::atfPStringEquals(contentURLPrefix, _o.contentURLPrefix) &&
		Atf::atfPStringEquals(clientDisplayGameDescription, _o.clientDisplayGameDescription);
}

const char *MiniGameClient::MiniGameDefLocalized::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameStatus=");
	_buf.appendInt(gameStatus);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("minigameDef=");
	minigameDef.toTraceString(_buf);
	_buf.append(',');
	_buf.append("clientDisplayName=");
	_buf.append(clientDisplayName);
	_buf.append(',');
	_buf.append("clientDisplayInfo=");
	_buf.append(clientDisplayInfo);
	_buf.append(',');
	_buf.append("clientDisplayInProgressTag=");
	_buf.append(clientDisplayInProgressTag);
	_buf.append(',');
	_buf.append("contentURLPrefix=");
	_buf.append(contentURLPrefix);
	_buf.append(',');
	_buf.append("clientDisplayGameDescription=");
	_buf.append(clientDisplayGameDescription);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::MiniGameDefLocalized::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameStatus", gameStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	minigameDef.toXmlString("minigameDef", _buf);
	Atf::XmlElement::encodeAsXmlElement("clientDisplayName", clientDisplayName, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientDisplayInfo", clientDisplayInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientDisplayInProgressTag", clientDisplayInProgressTag, _buf);
	Atf::XmlElement::encodeAsXmlElement("contentURLPrefix", contentURLPrefix, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientDisplayGameDescription", clientDisplayGameDescription, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::MiniGameDefLocalized::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameStatus"))
		{
			gameStatus = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameId"))
		{
			minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameDef"))
		{
			if(!Atf::AtfTempl< MiniGameDefinitionLocalized >::FromXmlString(_value, minigameDef)) return false;
		}
		else if (_element.equals("clientDisplayName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientDisplayName)) return false;
		}
		else if (_element.equals("clientDisplayInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientDisplayInfo)) return false;
		}
		else if (_element.equals("clientDisplayInProgressTag"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientDisplayInProgressTag)) return false;
		}
		else if (_element.equals("contentURLPrefix"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, contentURLPrefix)) return false;
		}
		else if (_element.equals("clientDisplayGameDescription"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clientDisplayGameDescription)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::MiniGameDefLocalized::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(gameStatus);
	_msg.composeUINT32(minigameId);
	minigameDef.composeMsg(_msg, _ignoreJSON);
	_msg.composeString(clientDisplayName);
	_msg.composeString(clientDisplayInfo);
	_msg.composeString(clientDisplayInProgressTag);
	_msg.composeString(contentURLPrefix);
	_msg.composeString(clientDisplayGameDescription);
}

void MiniGameClient::MiniGameDefLocalized::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(gameStatus);
	_parser.parseUINT32(minigameId);
	minigameDef.parseMsg(_parser);
	_parser.parseStringP(clientDisplayName);
	_parser.parseStringP(clientDisplayInfo);
	_parser.parseStringP(clientDisplayInProgressTag);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(contentURLPrefix);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(clientDisplayGameDescription);
}

const char *MiniGameClient::MiniGameDefLocalized::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameStatus", gameStatus);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("minigameDef", minigameDef);
	_jsonstr.compose("clientDisplayName", clientDisplayName);
	_jsonstr.compose("clientDisplayInfo", clientDisplayInfo);
	_jsonstr.compose("clientDisplayInProgressTag", clientDisplayInProgressTag);
	_jsonstr.compose("contentURLPrefix", contentURLPrefix);
	_jsonstr.compose("clientDisplayGameDescription", clientDisplayGameDescription);
	return _buf.c_str();
}

void MiniGameClient::MiniGameDefLocalized::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameStatus", gameStatus);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("minigameDef", minigameDef);
	_jparser.parseByNameThrow("clientDisplayName", clientDisplayName);
	_jparser.parseByNameThrow("clientDisplayInfo", clientDisplayInfo);
	_jparser.parseByNameThrow("clientDisplayInProgressTag", clientDisplayInProgressTag);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("contentURLPrefix", contentURLPrefix);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("clientDisplayGameDescription", clientDisplayGameDescription);
}

/* static */ void MiniGameClient::MiniGameDefLocalized::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 gameStatus; _jparser.validateByNameThrow("gameStatus", gameStatus);
	AtfValidator::validateInt(_descr, "gameStatus", gameStatus, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	MiniGameDefinitionLocalized minigameDef; _jparser.validateByNameThrow("minigameDef", minigameDef);
	PString clientDisplayName; _jparser.validateByNameThrow("clientDisplayName", clientDisplayName);
	AtfValidator::validateInt(_descr, "clientDisplayName", clientDisplayName.length(), _checker, __FILE__, __LINE__);
	PString clientDisplayInfo; _jparser.validateByNameThrow("clientDisplayInfo", clientDisplayInfo);
	AtfValidator::validateInt(_descr, "clientDisplayInfo", clientDisplayInfo.length(), _checker, __FILE__, __LINE__);
	PString clientDisplayInProgressTag; _jparser.validateByNameThrow("clientDisplayInProgressTag", clientDisplayInProgressTag);
	AtfValidator::validateInt(_descr, "clientDisplayInProgressTag", clientDisplayInProgressTag.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString contentURLPrefix; _jparser.validateByNameThrow("contentURLPrefix", contentURLPrefix);
	AtfValidator::validateInt(_descr, "contentURLPrefix", contentURLPrefix.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString clientDisplayGameDescription; _jparser.validateByNameThrow("clientDisplayGameDescription", clientDisplayGameDescription);
	AtfValidator::validateInt(_descr, "clientDisplayGameDescription", clientDisplayGameDescription.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::MiniGameDefLocalized::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 gameStatus; _parser.parseINT32(gameStatus);
	AtfValidator::validateInt(_descr, "gameStatus", gameStatus, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGameDefinitionLocalized::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("minigameDef"), _fieldsWithUnparsedContent);
	_parser.parseStringN(_dummy, 0, "clientDisplayName"); size_t szClientDisplayName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientDisplayName", szClientDisplayName, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clientDisplayInfo"); size_t szClientDisplayInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientDisplayInfo", szClientDisplayInfo, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clientDisplayInProgressTag"); size_t szClientDisplayInProgressTag = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientDisplayInProgressTag", szClientDisplayInProgressTag, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "contentURLPrefix"); size_t szContentURLPrefix = strlen(_dummy);
	AtfValidator::validateInt(_descr, "contentURLPrefix", szContentURLPrefix, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "clientDisplayGameDescription"); size_t szClientDisplayGameDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clientDisplayGameDescription", szClientDisplayGameDescription, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TheDealJackpotLeaf
//=================================================================

MiniGameClient::TheDealJackpotLeaf::TheDealJackpotLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::TheDealJackpotLeaf::TheDealJackpotLeaf(TheDealJackpotLeaf&& _o)
	: jackpotCurrency(std::move(_o.jackpotCurrency))
	, jackpotAmount(std::move(_o.jackpotAmount))
	, jackpotWinnerPercentage(std::move(_o.jackpotWinnerPercentage))
	, jackpotShareEligibilityMins(std::move(_o.jackpotShareEligibilityMins))
	, visibility(std::move(_o.visibility))
{
}

MiniGameClient::TheDealJackpotLeaf& MiniGameClient::TheDealJackpotLeaf::operator=(TheDealJackpotLeaf&& _o)
{
	if(this != &_o)
	{
		jackpotCurrency = std::move(_o.jackpotCurrency);
		jackpotAmount = std::move(_o.jackpotAmount);
		jackpotWinnerPercentage = std::move(_o.jackpotWinnerPercentage);
		jackpotShareEligibilityMins = std::move(_o.jackpotShareEligibilityMins);
		visibility = std::move(_o.visibility);
	}
	return *this;
}

#endif

void MiniGameClient::TheDealJackpotLeaf::clear()
{
	jackpotCurrency.clear();
	jackpotAmount = 0;
	jackpotWinnerPercentage = 0;
	jackpotShareEligibilityMins = 0;
	visibility.clear();
}

bool MiniGameClient::TheDealJackpotLeaf::equals(const TheDealJackpotLeaf& _o) const
{
	return Atf::atfPStringEquals(jackpotCurrency, _o.jackpotCurrency) &&
		jackpotAmount == _o.jackpotAmount &&
		jackpotWinnerPercentage == _o.jackpotWinnerPercentage &&
		jackpotShareEligibilityMins == _o.jackpotShareEligibilityMins &&
		visibility.equals(_o.visibility);
}

const char *MiniGameClient::TheDealJackpotLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("jackpotCurrency=");
	_buf.append(jackpotCurrency);
	_buf.append(',');
	_buf.append("jackpotAmount=");
	_buf.appendInt64(jackpotAmount);
	_buf.append(',');
	_buf.append("jackpotWinnerPercentage=");
	_buf.appendInt(jackpotWinnerPercentage);
	_buf.append(',');
	_buf.append("jackpotShareEligibilityMins=");
	_buf.appendInt(jackpotShareEligibilityMins);
	_buf.append(',');
	_buf.append("visibility=");
	visibility.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::TheDealJackpotLeaf::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("jackpotCurrency", jackpotCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("jackpotAmount", jackpotAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("jackpotWinnerPercentage", jackpotWinnerPercentage, _buf);
	Atf::XmlElement::encodeAsXmlElement("jackpotShareEligibilityMins", jackpotShareEligibilityMins, _buf);
	visibility.toXmlString("visibility", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::TheDealJackpotLeaf::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("jackpotCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, jackpotCurrency)) return false;
		}
		else if (_element.equals("jackpotAmount"))
		{
			jackpotAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("jackpotWinnerPercentage"))
		{
			jackpotWinnerPercentage = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("jackpotShareEligibilityMins"))
		{
			jackpotShareEligibilityMins = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("visibility"))
		{
			if(!Atf::AtfTempl< MiniGameVisibility >::FromXmlString(_value, visibility)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::TheDealJackpotLeaf::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _msg0;
	_msg0.composeString(jackpotCurrency);
	_msg0.composeINT64(jackpotAmount);
	_msg0.composeINT32(jackpotWinnerPercentage);
	_msg0.composeINT32(jackpotShareEligibilityMins);
	_msg.composeMsgBody(_msg0);
	visibility.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::TheDealJackpotLeaf::parseMsg(CommMsgParser& _parser)
{
	parseAnonymousMsgBody0(_parser);
	visibility.parseMsg(_parser);
}

const char *MiniGameClient::TheDealJackpotLeaf::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("jackpotCurrency", jackpotCurrency);
	_jsonstr.compose("jackpotAmount", jackpotAmount);
	_jsonstr.compose("jackpotWinnerPercentage", jackpotWinnerPercentage);
	_jsonstr.compose("jackpotShareEligibilityMins", jackpotShareEligibilityMins);
	_jsonstr.compose("visibility", visibility);
	return _buf.c_str();
}

void MiniGameClient::TheDealJackpotLeaf::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("jackpotCurrency", jackpotCurrency);
	_jparser.parseByNameThrow("jackpotAmount", jackpotAmount);
	_jparser.parseByNameThrow("jackpotWinnerPercentage", jackpotWinnerPercentage);
	_jparser.parseByNameThrow("jackpotShareEligibilityMins", jackpotShareEligibilityMins);
	_jparser.parseByNameThrow("visibility", visibility);
}

/* static */ void MiniGameClient::TheDealJackpotLeaf::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString jackpotCurrency; _jparser.validateByNameThrow("jackpotCurrency", jackpotCurrency);
	AtfValidator::validateInt(_descr, "jackpotCurrency", jackpotCurrency.length(), _checker, __FILE__, __LINE__);
	INT64 jackpotAmount; _jparser.validateByNameThrow("jackpotAmount", jackpotAmount);
	AtfValidator::validateInt(_descr, "jackpotAmount", jackpotAmount, _checker, __FILE__, __LINE__);
	INT32 jackpotWinnerPercentage; _jparser.validateByNameThrow("jackpotWinnerPercentage", jackpotWinnerPercentage);
	AtfValidator::validateInt(_descr, "jackpotWinnerPercentage", jackpotWinnerPercentage, _checker, __FILE__, __LINE__);
	INT32 jackpotShareEligibilityMins; _jparser.validateByNameThrow("jackpotShareEligibilityMins", jackpotShareEligibilityMins);
	AtfValidator::validateInt(_descr, "jackpotShareEligibilityMins", jackpotShareEligibilityMins, _checker, __FILE__, __LINE__);
	MiniGameVisibility visibility; _jparser.validateByNameThrow("visibility", visibility);
}

/*static*/ void MiniGameClient::TheDealJackpotLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	PString _descbuf;
	MiniGameVisibility::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("visibility"), _fieldsWithUnparsedContent);
}

void MiniGameClient::TheDealJackpotLeaf::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseStringP(jackpotCurrency);
	_parser0.parseINT64(jackpotAmount);
	_parser0.parseINT32(jackpotWinnerPercentage);
	_parser0.parseINT32(jackpotShareEligibilityMins);
}

/*static*/ void MiniGameClient::TheDealJackpotLeaf::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "jackpotCurrency"); size_t szJackpotCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "jackpotCurrency", szJackpotCurrency, _checker, __FILE__, __LINE__);
	INT64 jackpotAmount; _parser0.parseINT64(jackpotAmount);
	AtfValidator::validateInt(_descr, "jackpotAmount", jackpotAmount, _checker, __FILE__, __LINE__);
	INT32 jackpotWinnerPercentage; _parser0.parseINT32(jackpotWinnerPercentage);
	AtfValidator::validateInt(_descr, "jackpotWinnerPercentage", jackpotWinnerPercentage, _checker, __FILE__, __LINE__);
	INT32 jackpotShareEligibilityMins; _parser0.parseINT32(jackpotShareEligibilityMins);
	AtfValidator::validateInt(_descr, "jackpotShareEligibilityMins", jackpotShareEligibilityMins, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TheDealJackpotSpinLeaf
//=================================================================

MiniGameClient::TheDealJackpotSpinLeaf::TheDealJackpotSpinLeaf()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::TheDealJackpotSpinLeaf::TheDealJackpotSpinLeaf(TheDealJackpotSpinLeaf&& _o)
	: active(std::move(_o.active))
	, timestamp(std::move(_o.timestamp))
	, playerId(std::move(_o.playerId))
	, playerBrandImages(std::move(_o.playerBrandImages))
	, jackpotAmountInCents(std::move(_o.jackpotAmountInCents))
	, winnerShareAmount(std::move(_o.winnerShareAmount))
	, playerShareAmount(std::move(_o.playerShareAmount))
	, jackpotState(std::move(_o.jackpotState))
{
}

MiniGameClient::TheDealJackpotSpinLeaf& MiniGameClient::TheDealJackpotSpinLeaf::operator=(TheDealJackpotSpinLeaf&& _o)
{
	if(this != &_o)
	{
		active = std::move(_o.active);
		timestamp = std::move(_o.timestamp);
		playerId = std::move(_o.playerId);
		playerBrandImages = std::move(_o.playerBrandImages);
		jackpotAmountInCents = std::move(_o.jackpotAmountInCents);
		winnerShareAmount = std::move(_o.winnerShareAmount);
		playerShareAmount = std::move(_o.playerShareAmount);
		jackpotState = std::move(_o.jackpotState);
	}
	return *this;
}

#endif

void MiniGameClient::TheDealJackpotSpinLeaf::clear()
{
	active = false;
	timestamp = 0;
	playerId.clear();
	playerBrandImages.clear();
	jackpotAmountInCents = 0;
	winnerShareAmount = 0;
	playerShareAmount = 0;
	jackpotState.clear();
}

bool MiniGameClient::TheDealJackpotSpinLeaf::equals(const TheDealJackpotSpinLeaf& _o) const
{
	return active == _o.active &&
		timestamp == _o.timestamp &&
		Atf::atfPStringEquals(playerId, _o.playerId) &&
		playerBrandImages.equals(_o.playerBrandImages) &&
		jackpotAmountInCents == _o.jackpotAmountInCents &&
		winnerShareAmount == _o.winnerShareAmount &&
		playerShareAmount == _o.playerShareAmount &&
		jackpotState.equals(_o.jackpotState);
}

const char *MiniGameClient::TheDealJackpotSpinLeaf::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("active=");
	_buf.appendUint(active);
	_buf.append(',');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("playerId=");
	_buf.append(playerId);
	_buf.append(',');
	_buf.append("playerBrandImages=");
	playerBrandImages.toTraceString(_buf);
	_buf.append(',');
	_buf.append("jackpotAmountInCents=");
	_buf.appendInt64(jackpotAmountInCents);
	_buf.append(',');
	_buf.append("winnerShareAmount=");
	_buf.appendInt(winnerShareAmount);
	_buf.append(',');
	_buf.append("playerShareAmount=");
	_buf.appendInt(playerShareAmount);
	_buf.append(',');
	_buf.append("jackpotState=");
	jackpotState.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::TheDealJackpotSpinLeaf::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("active", active, _buf);
	Atf::XmlElement::encodeAsXmlElement("timestamp", timestamp, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerId", playerId, _buf);
	playerBrandImages.toXmlString("playerBrandImages", _buf);
	Atf::XmlElement::encodeAsXmlElement("jackpotAmountInCents", jackpotAmountInCents, _buf);
	Atf::XmlElement::encodeAsXmlElement("winnerShareAmount", winnerShareAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerShareAmount", playerShareAmount, _buf);
	jackpotState.toXmlString("jackpotState", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::TheDealJackpotSpinLeaf::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("active"))
		{
			active = (*_value.ptr() == '1');
		}
		else if (_element.equals("timestamp"))
		{
			timestamp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, playerId)) return false;
		}
		else if (_element.equals("playerBrandImages"))
		{
			if(!Atf::AtfTempl< BrandProt::BrandImageList >::FromXmlString(_value, playerBrandImages)) return false;
		}
		else if (_element.equals("jackpotAmountInCents"))
		{
			jackpotAmountInCents = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winnerShareAmount"))
		{
			winnerShareAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playerShareAmount"))
		{
			playerShareAmount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("jackpotState"))
		{
			if(!Atf::AtfTempl< MiniGameState >::FromXmlString(_value, jackpotState)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::TheDealJackpotSpinLeaf::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(active);
	_msg.composeINT32(timestamp);
	_msg.composeString(playerId);
	playerBrandImages.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT64(jackpotAmountInCents);
	_msg.composeINT32(winnerShareAmount);
	_msg.composeINT32(playerShareAmount);
	jackpotState.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::TheDealJackpotSpinLeaf::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(active);
	_parser.parseINT32(timestamp);
	_parser.parseStringP(playerId);
	playerBrandImages.parseMsg(_parser);
	_parser.parseINT64(jackpotAmountInCents);
	_parser.parseINT32(winnerShareAmount);
	_parser.parseINT32(playerShareAmount);
	jackpotState.parseMsg(_parser);
}

const char *MiniGameClient::TheDealJackpotSpinLeaf::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("active", active);
	_jsonstr.compose("timestamp", timestamp);
	_jsonstr.compose("playerId", playerId);
	_jsonstr.compose("playerBrandImages", playerBrandImages);
	_jsonstr.compose("jackpotAmountInCents", jackpotAmountInCents);
	_jsonstr.compose("winnerShareAmount", winnerShareAmount);
	_jsonstr.compose("playerShareAmount", playerShareAmount);
	_jsonstr.compose("jackpotState", jackpotState);
	return _buf.c_str();
}

void MiniGameClient::TheDealJackpotSpinLeaf::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("active", active);
	_jparser.parseByNameThrow("timestamp", timestamp);
	_jparser.parseByNameThrow("playerId", playerId);
	_jparser.parseByNameThrow("playerBrandImages", playerBrandImages);
	_jparser.parseByNameThrow("jackpotAmountInCents", jackpotAmountInCents);
	_jparser.parseByNameThrow("winnerShareAmount", winnerShareAmount);
	_jparser.parseByNameThrow("playerShareAmount", playerShareAmount);
	_jparser.parseByNameThrow("jackpotState", jackpotState);
}

/* static */ void MiniGameClient::TheDealJackpotSpinLeaf::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool active; _jparser.validateByNameThrow("active", active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	INT32 timestamp; _jparser.validateByNameThrow("timestamp", timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	PString playerId; _jparser.validateByNameThrow("playerId", playerId);
	AtfValidator::validateInt(_descr, "playerId", playerId.length(), _checker, __FILE__, __LINE__);
	BrandProt::BrandImageList playerBrandImages; _jparser.validateByNameThrow("playerBrandImages", playerBrandImages);
	INT64 jackpotAmountInCents; _jparser.validateByNameThrow("jackpotAmountInCents", jackpotAmountInCents);
	AtfValidator::validateInt(_descr, "jackpotAmountInCents", jackpotAmountInCents, _checker, __FILE__, __LINE__);
	INT32 winnerShareAmount; _jparser.validateByNameThrow("winnerShareAmount", winnerShareAmount);
	AtfValidator::validateInt(_descr, "winnerShareAmount", winnerShareAmount, _checker, __FILE__, __LINE__);
	INT32 playerShareAmount; _jparser.validateByNameThrow("playerShareAmount", playerShareAmount);
	AtfValidator::validateInt(_descr, "playerShareAmount", playerShareAmount, _checker, __FILE__, __LINE__);
	MiniGameState jackpotState; _jparser.validateByNameThrow("jackpotState", jackpotState);
}

/*static*/ void MiniGameClient::TheDealJackpotSpinLeaf::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool active; _parser.parseBOOL(active);
	AtfValidator::validateInt(_descr, "active", active, _checker, __FILE__, __LINE__);
	INT32 timestamp; _parser.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "playerId"); size_t szPlayerId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "playerId", szPlayerId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	BrandProt::BrandImageList::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerBrandImages"), _fieldsWithUnparsedContent);
	INT64 jackpotAmountInCents; _parser.parseINT64(jackpotAmountInCents);
	AtfValidator::validateInt(_descr, "jackpotAmountInCents", jackpotAmountInCents, _checker, __FILE__, __LINE__);
	INT32 winnerShareAmount; _parser.parseINT32(winnerShareAmount);
	AtfValidator::validateInt(_descr, "winnerShareAmount", winnerShareAmount, _checker, __FILE__, __LINE__);
	INT32 playerShareAmount; _parser.parseINT32(playerShareAmount);
	AtfValidator::validateInt(_descr, "playerShareAmount", playerShareAmount, _checker, __FILE__, __LINE__);
	MiniGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("jackpotState"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    GameTicketWithMiniGame
//=================================================================

MiniGameClient::GameTicketWithMiniGame::GameTicketWithMiniGame()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::GameTicketWithMiniGame::GameTicketWithMiniGame(GameTicketWithMiniGame&& _o)
	: gameTicketId(std::move(_o.gameTicketId))
	, gameTicketTypeId(std::move(_o.gameTicketTypeId))
	, whenStarted(std::move(_o.whenStarted))
	, expiration(std::move(_o.expiration))
	, playsInitial(std::move(_o.playsInitial))
	, playsSpent(std::move(_o.playsSpent))
	, gameTicketBrandMask(std::move(_o.gameTicketBrandMask))
	, minigameId(std::move(_o.minigameId))
	, minigameType(std::move(_o.minigameType))
	, minigameClientDisplayName(std::move(_o.minigameClientDisplayName))
	, minigameClientDisplayInfo(std::move(_o.minigameClientDisplayInfo))
	, minigameBrandMask(std::move(_o.minigameBrandMask))
	, minigameSiteMask(std::move(_o.minigameSiteMask))
	, status(std::move(_o.status))
	, costFpp1(std::move(_o.costFpp1))
	, minigameSiteMaskEx(std::move(_o.minigameSiteMaskEx))
{
}

MiniGameClient::GameTicketWithMiniGame& MiniGameClient::GameTicketWithMiniGame::operator=(GameTicketWithMiniGame&& _o)
{
	if(this != &_o)
	{
		gameTicketId = std::move(_o.gameTicketId);
		gameTicketTypeId = std::move(_o.gameTicketTypeId);
		whenStarted = std::move(_o.whenStarted);
		expiration = std::move(_o.expiration);
		playsInitial = std::move(_o.playsInitial);
		playsSpent = std::move(_o.playsSpent);
		gameTicketBrandMask = std::move(_o.gameTicketBrandMask);
		minigameId = std::move(_o.minigameId);
		minigameType = std::move(_o.minigameType);
		minigameClientDisplayName = std::move(_o.minigameClientDisplayName);
		minigameClientDisplayInfo = std::move(_o.minigameClientDisplayInfo);
		minigameBrandMask = std::move(_o.minigameBrandMask);
		minigameSiteMask = std::move(_o.minigameSiteMask);
		status = std::move(_o.status);
		costFpp1 = std::move(_o.costFpp1);
		minigameSiteMaskEx = std::move(_o.minigameSiteMaskEx);
	}
	return *this;
}

#endif

void MiniGameClient::GameTicketWithMiniGame::clear()
{
	gameTicketId = 0;
	gameTicketTypeId = 0;
	whenStarted.setNull();
	expiration.setNull();
	playsInitial = 0;
	playsSpent = 0;
	gameTicketBrandMask = 0;
	minigameId = 0;
	minigameType = 0;
	minigameClientDisplayName.clear();
	minigameClientDisplayInfo.clear();
	minigameBrandMask = 0;
	minigameSiteMask = 0;
	status = 0;
	costFpp1 = 0;
	minigameSiteMaskEx.clear();
}

bool MiniGameClient::GameTicketWithMiniGame::equals(const GameTicketWithMiniGame& _o) const
{
	return gameTicketId == _o.gameTicketId &&
		gameTicketTypeId == _o.gameTicketTypeId &&
		whenStarted.equals(_o.whenStarted) &&
		expiration.equals(_o.expiration) &&
		playsInitial == _o.playsInitial &&
		playsSpent == _o.playsSpent &&
		gameTicketBrandMask == _o.gameTicketBrandMask &&
		minigameId == _o.minigameId &&
		minigameType == _o.minigameType &&
		Atf::atfPStringEquals(minigameClientDisplayName, _o.minigameClientDisplayName) &&
		Atf::atfPStringEquals(minigameClientDisplayInfo, _o.minigameClientDisplayInfo) &&
		minigameBrandMask == _o.minigameBrandMask &&
		minigameSiteMask == _o.minigameSiteMask &&
		status == _o.status &&
		costFpp1 == _o.costFpp1 &&
		minigameSiteMaskEx.equals(_o.minigameSiteMaskEx);
}

const char *MiniGameClient::GameTicketWithMiniGame::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint(gameTicketTypeId);
	_buf.append(',');
	_buf.append("whenStarted=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenStarted);
	_buf.append(',');
	_buf.append("expiration=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, expiration);
	_buf.append(',');
	_buf.append("playsInitial=");
	_buf.appendInt(playsInitial);
	_buf.append(',');
	_buf.append("playsSpent=");
	_buf.appendInt(playsSpent);
	_buf.append(',');
	_buf.append("gameTicketBrandMask=");
	_buf.appendUint(gameTicketBrandMask);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("minigameType=");
	_buf.appendUint(minigameType);
	_buf.append(',');
	_buf.append("minigameClientDisplayName=");
	_buf.append(minigameClientDisplayName);
	_buf.append(',');
	_buf.append("minigameClientDisplayInfo=");
	_buf.append(minigameClientDisplayInfo);
	_buf.append(',');
	_buf.append("minigameBrandMask=");
	_buf.appendUint(minigameBrandMask);
	_buf.append(',');
	_buf.append("minigameSiteMask=");
	_buf.appendUint(minigameSiteMask);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	_buf.append(',');
	_buf.append("costFpp1=");
	_buf.appendInt(costFpp1);
	_buf.append(',');
	_buf.append("minigameSiteMaskEx=");
	minigameSiteMaskEx.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::GameTicketWithMiniGame::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameTicketId", gameTicketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTicketTypeId", gameTicketTypeId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenStarted", whenStarted);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "expiration", expiration);
	Atf::XmlElement::encodeAsXmlElement("playsInitial", playsInitial, _buf);
	Atf::XmlElement::encodeAsXmlElement("playsSpent", playsSpent, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTicketBrandMask", gameTicketBrandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameType", minigameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameClientDisplayName", minigameClientDisplayName, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameClientDisplayInfo", minigameClientDisplayInfo, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameBrandMask", minigameBrandMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameSiteMask", minigameSiteMask, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("costFpp1", costFpp1, _buf);
	minigameSiteMaskEx.toXmlString("minigameSiteMaskEx", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::GameTicketWithMiniGame::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameTicketId"))
		{
			gameTicketId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameTicketTypeId"))
		{
			gameTicketTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenStarted"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenStarted);
		}
		else if (_element.equals("expiration"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, expiration);
		}
		else if (_element.equals("playsInitial"))
		{
			playsInitial = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playsSpent"))
		{
			playsSpent = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameTicketBrandMask"))
		{
			gameTicketBrandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameId"))
		{
			minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameType"))
		{
			minigameType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameClientDisplayName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, minigameClientDisplayName)) return false;
		}
		else if (_element.equals("minigameClientDisplayInfo"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, minigameClientDisplayInfo)) return false;
		}
		else if (_element.equals("minigameBrandMask"))
		{
			minigameBrandMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameSiteMask"))
		{
			minigameSiteMask = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("status"))
		{
			status = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("costFpp1"))
		{
			costFpp1 = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameSiteMaskEx"))
		{
			if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, minigameSiteMaskEx)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::GameTicketWithMiniGame::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(GameTicketWithMiniGame())) // not empty
	{
		_body.composeUINT64(gameTicketId);
		_body.composeUINT32(gameTicketTypeId);
		_body.composeSrvTime(whenStarted);
		_body.composeSrvTime(expiration);
		_body.composeINT32(playsInitial);
		_body.composeINT32(playsSpent);
		_body.composeUINT32(gameTicketBrandMask);
		_body.composeUINT32(minigameId);
		_body.composeUINT32(minigameType);
		_body.composeString(minigameClientDisplayName);
		_body.composeString(minigameClientDisplayInfo);
		_body.composeUINT32(minigameBrandMask);
		_body.composeUINT32(minigameSiteMask);
		_body.composeINT32(status);
		_body.composeINT32(costFpp1);
		minigameSiteMaskEx.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::GameTicketWithMiniGame::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameTicketId);
	_parser0.parseUINT32(gameTicketTypeId);
	_parser0.parseSrvTime(whenStarted);
	_parser0.parseSrvTime(expiration);
	_parser0.parseINT32(playsInitial);
	_parser0.parseINT32(playsSpent);
	_parser0.parseUINT32(gameTicketBrandMask);
	_parser0.parseUINT32(minigameId);
	_parser0.parseUINT32(minigameType);
	_parser0.parseStringP(minigameClientDisplayName);
	_parser0.parseStringP(minigameClientDisplayInfo);
	_parser0.parseUINT32(minigameBrandMask);
	_parser0.parseUINT32(minigameSiteMask);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(status);
	if(_parser0.parseEnded()) return;
	_parser0.parseINT32(costFpp1);
	if(_parser0.parseEnded()) return;
	minigameSiteMaskEx.parseMsg(_parser0);
}

const char *MiniGameClient::GameTicketWithMiniGame::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameTicketId", gameTicketId);
	_jsonstr.compose("gameTicketTypeId", gameTicketTypeId);
	_jsonstr.compose("whenStarted", whenStarted);
	_jsonstr.compose("expiration", expiration);
	_jsonstr.compose("playsInitial", playsInitial);
	_jsonstr.compose("playsSpent", playsSpent);
	_jsonstr.compose("gameTicketBrandMask", gameTicketBrandMask);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("minigameType", minigameType);
	_jsonstr.compose("minigameClientDisplayName", minigameClientDisplayName);
	_jsonstr.compose("minigameClientDisplayInfo", minigameClientDisplayInfo);
	_jsonstr.compose("minigameBrandMask", minigameBrandMask);
	_jsonstr.compose("minigameSiteMask", minigameSiteMask);
	_jsonstr.compose("status", status);
	_jsonstr.compose("costFpp1", costFpp1);
	_jsonstr.compose("minigameSiteMaskEx", minigameSiteMaskEx);
	return _buf.c_str();
}

void MiniGameClient::GameTicketWithMiniGame::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameTicketId", gameTicketId);
	_jparser.parseByNameThrow("gameTicketTypeId", gameTicketTypeId);
	_jparser.parseByNameThrow("whenStarted", whenStarted);
	_jparser.parseByNameThrow("expiration", expiration);
	_jparser.parseByNameThrow("playsInitial", playsInitial);
	_jparser.parseByNameThrow("playsSpent", playsSpent);
	_jparser.parseByNameThrow("gameTicketBrandMask", gameTicketBrandMask);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("minigameType", minigameType);
	_jparser.parseByNameThrow("minigameClientDisplayName", minigameClientDisplayName);
	_jparser.parseByNameThrow("minigameClientDisplayInfo", minigameClientDisplayInfo);
	_jparser.parseByNameThrow("minigameBrandMask", minigameBrandMask);
	_jparser.parseByNameThrow("minigameSiteMask", minigameSiteMask);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("status", status);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("costFpp1", costFpp1);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("minigameSiteMaskEx", minigameSiteMaskEx);
}

/* static */ void MiniGameClient::GameTicketWithMiniGame::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 gameTicketId; _jparser.validateByNameThrow("gameTicketId", gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	UINT32 gameTicketTypeId; _jparser.validateByNameThrow("gameTicketTypeId", gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	SrvTime whenStarted; _jparser.validateByNameThrow("whenStarted", whenStarted);
	AtfValidator::validateSrvDateTime(_descr, "whenStarted", whenStarted, _checker, __FILE__, __LINE__);
	SrvTime expiration; _jparser.validateByNameThrow("expiration", expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	INT32 playsInitial; _jparser.validateByNameThrow("playsInitial", playsInitial);
	AtfValidator::validateInt(_descr, "playsInitial", playsInitial, _checker, __FILE__, __LINE__);
	INT32 playsSpent; _jparser.validateByNameThrow("playsSpent", playsSpent);
	AtfValidator::validateInt(_descr, "playsSpent", playsSpent, _checker, __FILE__, __LINE__);
	UINT32 gameTicketBrandMask; _jparser.validateByNameThrow("gameTicketBrandMask", gameTicketBrandMask);
	AtfValidator::validateInt(_descr, "gameTicketBrandMask", gameTicketBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT32 minigameType; _jparser.validateByNameThrow("minigameType", minigameType);
	AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
	PString minigameClientDisplayName; _jparser.validateByNameThrow("minigameClientDisplayName", minigameClientDisplayName);
	AtfValidator::validateInt(_descr, "minigameClientDisplayName", minigameClientDisplayName.length(), _checker, __FILE__, __LINE__);
	PString minigameClientDisplayInfo; _jparser.validateByNameThrow("minigameClientDisplayInfo", minigameClientDisplayInfo);
	AtfValidator::validateInt(_descr, "minigameClientDisplayInfo", minigameClientDisplayInfo.length(), _checker, __FILE__, __LINE__);
	UINT32 minigameBrandMask; _jparser.validateByNameThrow("minigameBrandMask", minigameBrandMask);
	AtfValidator::validateInt(_descr, "minigameBrandMask", minigameBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameSiteMask; _jparser.validateByNameThrow("minigameSiteMask", minigameSiteMask);
	AtfValidator::validateInt(_descr, "minigameSiteMask", minigameSiteMask, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 costFpp1; _jparser.validateByNameThrow("costFpp1", costFpp1);
	AtfValidator::validateInt(_descr, "costFpp1", costFpp1, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PSiteMask minigameSiteMaskEx; _jparser.validateByNameThrow("minigameSiteMaskEx", minigameSiteMaskEx);
}

/*static*/ void MiniGameClient::GameTicketWithMiniGame::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT64 gameTicketId; _parser0.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	UINT32 gameTicketTypeId; _parser0.parseUINT32(gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	SrvTime whenStarted; _parser0.parseSrvTime(whenStarted);
	AtfValidator::validateSrvDateTime(_descr, "whenStarted", whenStarted, _checker, __FILE__, __LINE__);
	SrvTime expiration; _parser0.parseSrvTime(expiration);
	AtfValidator::validateSrvDateTime(_descr, "expiration", expiration, _checker, __FILE__, __LINE__);
	INT32 playsInitial; _parser0.parseINT32(playsInitial);
	AtfValidator::validateInt(_descr, "playsInitial", playsInitial, _checker, __FILE__, __LINE__);
	INT32 playsSpent; _parser0.parseINT32(playsSpent);
	AtfValidator::validateInt(_descr, "playsSpent", playsSpent, _checker, __FILE__, __LINE__);
	UINT32 gameTicketBrandMask; _parser0.parseUINT32(gameTicketBrandMask);
	AtfValidator::validateInt(_descr, "gameTicketBrandMask", gameTicketBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT32 minigameType; _parser0.parseUINT32(minigameType);
	AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "minigameClientDisplayName"); size_t szMinigameClientDisplayName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "minigameClientDisplayName", szMinigameClientDisplayName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "minigameClientDisplayInfo"); size_t szMinigameClientDisplayInfo = strlen(_dummy);
	AtfValidator::validateInt(_descr, "minigameClientDisplayInfo", szMinigameClientDisplayInfo, _checker, __FILE__, __LINE__);
	UINT32 minigameBrandMask; _parser0.parseUINT32(minigameBrandMask);
	AtfValidator::validateInt(_descr, "minigameBrandMask", minigameBrandMask, _checker, __FILE__, __LINE__);
	UINT32 minigameSiteMask; _parser0.parseUINT32(minigameSiteMask);
	AtfValidator::validateInt(_descr, "minigameSiteMask", minigameSiteMask, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 status; _parser0.parseINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	INT32 costFpp1; _parser0.parseINT32(costFpp1);
	AtfValidator::validateInt(_descr, "costFpp1", costFpp1, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	PSiteMask::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("minigameSiteMaskEx"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MINIGAME_MSG_ACTIVE_GAMES
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::Protocol_MINIGAME_MSG_ACTIVE_GAMES()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::clear()
{
	requestId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::equals(const Protocol_MINIGAME_MSG_ACTIVE_GAMES& _o) const
{
	return requestId == _o.requestId;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_ACTIVE_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_ACTIVE_GAMES*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_ACTIVE_GAMES).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_ACTIVE_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_ACTIVE_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_ACTIVE_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY(Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, states(std::move(_o.states))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::operator=(Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		states = std::move(_o.states);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	states.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::equals(const Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		states.equals(_o.states);
}

bool MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_ACTIVE_GAMES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_ACTIVE_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("states=");
		states.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_ACTIVE_GAMES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		states.toXmlString("states", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("states"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MiniGameState , 4 > >::FromXmlString(_value, states)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		CommMsgBody _msg0;
		states.composeMsg(_msg0, _ignoreJSON);
		_msg.composeMsgBody(_msg0);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
	}
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("states", states);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("states", states);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_ACTIVE_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< MiniGameState > states; _jparser.validateByNameThrow("states", states);
		AtfValidator::validateInt(_descr, "states", states.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_ACTIVE_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	states.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szStates = Atf::LAtfVector< MiniGameState , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("states"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "states", szStates, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MINIGAME_MSG_START_GAME
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::Protocol_MINIGAME_MSG_START_GAME()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::Protocol_MINIGAME_MSG_START_GAME(Protocol_MINIGAME_MSG_START_GAME&& _o)
	: requestId(std::move(_o.requestId))
	, minigameId(std::move(_o.minigameId))
	, initialDecisions(std::move(_o.initialDecisions))
	, autoPlay(std::move(_o.autoPlay))
	, useGameTicket(std::move(_o.useGameTicket))
	, minigameEntryMode(std::move(_o.minigameEntryMode))
	, minigameEntryRefId(std::move(_o.minigameEntryRefId))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME& MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::operator=(Protocol_MINIGAME_MSG_START_GAME&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		minigameId = std::move(_o.minigameId);
		initialDecisions = std::move(_o.initialDecisions);
		autoPlay = std::move(_o.autoPlay);
		useGameTicket = std::move(_o.useGameTicket);
		minigameEntryMode = std::move(_o.minigameEntryMode);
		minigameEntryRefId = std::move(_o.minigameEntryRefId);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::clear()
{
	requestId = 0;
	minigameId = 0;
	initialDecisions.clear();
	autoPlay = false;
	useGameTicket = false;
	minigameEntryMode = sidegame::eSideGameEntryMode_Normal;
	minigameEntryRefId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::equals(const Protocol_MINIGAME_MSG_START_GAME& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		initialDecisions.equals(_o.initialDecisions) &&
		autoPlay == _o.autoPlay &&
		useGameTicket == _o.useGameTicket &&
		minigameEntryMode == _o.minigameEntryMode &&
		minigameEntryRefId == _o.minigameEntryRefId;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_START_GAME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_START_GAME*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_START_GAME).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("initialDecisions=");
	initialDecisions.toTraceString(_buf);
	_buf.append(',');
	_buf.append("autoPlay=");
	_buf.appendUint(autoPlay);
	_buf.append(',');
	_buf.append("useGameTicket=");
	_buf.appendUint(useGameTicket);
	_buf.append(',');
	_buf.append("minigameEntryMode=");
	_buf.appendInt(minigameEntryMode);
	_buf.append(',');
	_buf.append("minigameEntryRefId=");
	_buf.appendUint64(minigameEntryRefId);
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_START_GAME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	initialDecisions.toXmlString("initialDecisions", _buf);
	Atf::XmlElement::encodeAsXmlElement("autoPlay", autoPlay, _buf);
	Atf::XmlElement::encodeAsXmlElement("useGameTicket", useGameTicket, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameEntryMode", minigameEntryMode, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameEntryRefId", minigameEntryRefId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameId"))
			{
				minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("initialDecisions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT32 , 4 > >::FromXmlString(_value, initialDecisions)) return false;
			}
			else if (_element.equals("autoPlay"))
			{
				autoPlay = (*_value.ptr() == '1');
			}
			else if (_element.equals("useGameTicket"))
			{
				useGameTicket = (*_value.ptr() == '1');
			}
			else if (_element.equals("minigameEntryMode"))
			{
				minigameEntryMode = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameEntryRefId"))
			{
				minigameEntryRefId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	CommMsgBody _msg0;
	initialDecisions.composeMsg(_msg0, _ignoreJSON);
	_msg.composeMsgBody(_msg0);
	_msg.composeBOOL(autoPlay);
	_msg.composeBOOL(useGameTicket);
	_msg.composeINT8(minigameEntryMode);
	_msg.composeUINT64(minigameEntryRefId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	parseAnonymousMsgBody0(_parser);
	_parser.parseBOOL(autoPlay);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useGameTicket);
	if(_parser.parseEnded()) return;
	_parser.parseINT8(minigameEntryMode);
	_parser.parseUINT64(minigameEntryRefId);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("initialDecisions", initialDecisions);
	_jsonstr.compose("autoPlay", autoPlay);
	_jsonstr.compose("useGameTicket", useGameTicket);
	_jsonstr.compose("minigameEntryMode", minigameEntryMode);
	_jsonstr.compose("minigameEntryRefId", minigameEntryRefId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("initialDecisions", initialDecisions);
	_jparser.parseByNameThrow("autoPlay", autoPlay);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("useGameTicket", useGameTicket);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("minigameEntryMode", minigameEntryMode);
	_jparser.parseByNameThrow("minigameEntryRefId", minigameEntryRefId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_START_GAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > initialDecisions; _jparser.validateByNameThrow("initialDecisions", initialDecisions);
	AtfValidator::validateIntMax(_descr, "initialDecisions", initialDecisions.size(), 2, _checker, __FILE__, __LINE__);
	bool autoPlay; _jparser.validateByNameThrow("autoPlay", autoPlay);
	AtfValidator::validateInt(_descr, "autoPlay", autoPlay, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool useGameTicket; _jparser.validateByNameThrow("useGameTicket", useGameTicket);
	AtfValidator::validateInt(_descr, "useGameTicket", useGameTicket, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT8 minigameEntryMode; _jparser.validateByNameThrow("minigameEntryMode", minigameEntryMode);
	AtfValidator::validateIntRange(_descr, "minigameEntryMode", minigameEntryMode, sidegame::eSideGameEntryMode_Normal, sidegame::eSideGameEntryMode_Max, _checker, __FILE__, __LINE__);
	UINT64 minigameEntryRefId; _jparser.validateByNameThrow("minigameEntryRefId", minigameEntryRefId);
	AtfValidator::validateUint(_descr, "minigameEntryRefId", minigameEntryRefId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_START_GAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	bool autoPlay; _parser.parseBOOL(autoPlay);
	AtfValidator::validateInt(_descr, "autoPlay", autoPlay, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useGameTicket; _parser.parseBOOL(useGameTicket);
	AtfValidator::validateInt(_descr, "useGameTicket", useGameTicket, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT8 minigameEntryMode; _parser.parseINT8(minigameEntryMode);
	AtfValidator::validateIntRange(_descr, "minigameEntryMode", minigameEntryMode, sidegame::eSideGameEntryMode_Normal, sidegame::eSideGameEntryMode_Max, _checker, __FILE__, __LINE__);
	UINT64 minigameEntryRefId; _parser.parseUINT64(minigameEntryRefId);
	AtfValidator::validateUint(_descr, "minigameEntryRefId", minigameEntryRefId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	initialDecisions.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szInitialDecisions = Atf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("initialDecisions"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "initialDecisions", szInitialDecisions, 2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MINIGAME_MSG_START_GAME_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::Protocol_MINIGAME_MSG_START_GAME_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::Protocol_MINIGAME_MSG_START_GAME_REPLY(Protocol_MINIGAME_MSG_START_GAME_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, ticketsWithMinigames(std::move(_o.ticketsWithMinigames))
	, playsRemaining(std::move(_o.playsRemaining))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::operator=(Protocol_MINIGAME_MSG_START_GAME_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		ticketsWithMinigames = std::move(_o.ticketsWithMinigames);
		playsRemaining = std::move(_o.playsRemaining);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	ticketsWithMinigames.clear();
	playsRemaining = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::equals(const Protocol_MINIGAME_MSG_START_GAME_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		state.equals(_o.state) &&
		ticketsWithMinigames.equals(_o.ticketsWithMinigames) &&
		playsRemaining == _o.playsRemaining;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_START_GAME_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_START_GAME_REPLY*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_START_GAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
	}
	_buf.append(',');
	_buf.append("ticketsWithMinigames=");
	ticketsWithMinigames.toTraceString(_buf);
	_buf.append(',');
	_buf.append("playsRemaining=");
	_buf.appendInt(playsRemaining);
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_START_GAME_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		state.toXmlString("state", _buf);
	}
	ticketsWithMinigames.toXmlString("ticketsWithMinigames", _buf);
	Atf::XmlElement::encodeAsXmlElement("playsRemaining", playsRemaining, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::AtfTempl< MiniGameState >::FromXmlString(_value, state)) return false;
			}
			else if (_element.equals("ticketsWithMinigames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameTicketWithMiniGame , 4 > >::FromXmlString(_value, ticketsWithMinigames)) return false;
			}
			else if (_element.equals("playsRemaining"))
			{
				playsRemaining = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg, _ignoreJSON);
	}
	ticketsWithMinigames.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT32(playsRemaining);
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
	}
	if(_parser.parseEnded()) return;
	ticketsWithMinigames.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(playsRemaining);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("state", state);
	}
	_jsonstr.compose("ticketsWithMinigames", ticketsWithMinigames);
	_jsonstr.compose("playsRemaining", playsRemaining);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("state", state);
	}
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("ticketsWithMinigames", ticketsWithMinigames);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("playsRemaining", playsRemaining);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_START_GAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		MiniGameState state; _jparser.validateByNameThrow("state", state);
	}
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< GameTicketWithMiniGame > ticketsWithMinigames; _jparser.validateByNameThrow("ticketsWithMinigames", ticketsWithMinigames);
	AtfValidator::validateInt(_descr, "ticketsWithMinigames", ticketsWithMinigames.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 playsRemaining; _jparser.validateByNameThrow("playsRemaining", playsRemaining);
	AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_START_GAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_START_GAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		MiniGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
	}
	if(_parser.parseEnded()) return;
	PString _descbuf;
	int szTicketsWithMinigames = Atf::LAtfVector< GameTicketWithMiniGame , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketsWithMinigames"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "ticketsWithMinigames", szTicketsWithMinigames, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 playsRemaining; _parser.parseINT32(playsRemaining);
	AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND(Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND&& _o)
	: requestId(std::move(_o.requestId))
	, minigamePlayId(std::move(_o.minigamePlayId))
	, round(std::move(_o.round))
	, decisions(std::move(_o.decisions))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND& MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::operator=(Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		minigamePlayId = std::move(_o.minigamePlayId);
		round = std::move(_o.round);
		decisions = std::move(_o.decisions);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::clear()
{
	requestId = 0;
	minigamePlayId = 0;
	round = 0;
	decisions.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::equals(const Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId &&
		round == _o.round &&
		decisions.equals(_o.decisions);
}

bool MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_PLAY_NEXT_ROUND != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_PLAY_NEXT_ROUND).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	_buf.append(',');
	_buf.append("round=");
	_buf.appendInt(round);
	_buf.append(',');
	_buf.append("decisions=");
	decisions.toTraceString(_buf);
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_PLAY_NEXT_ROUND).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigamePlayId", minigamePlayId, _buf);
	Atf::XmlElement::encodeAsXmlElement("round", round, _buf);
	decisions.toXmlString("decisions", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigamePlayId"))
			{
				minigamePlayId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("round"))
			{
				round = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("decisions"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< INT32 , 4 > >::FromXmlString(_value, decisions)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
	_msg.composeINT32(round);
	CommMsgBody _msg0;
	decisions.composeMsg(_msg0, _ignoreJSON);
	_msg.composeMsgBody(_msg0);
}

void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
	_parser.parseINT32(round);
	parseAnonymousMsgBody0(_parser);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigamePlayId", minigamePlayId);
	_jsonstr.compose("round", round);
	_jsonstr.compose("decisions", decisions);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigamePlayId", minigamePlayId);
	_jparser.parseByNameThrow("round", round);
	_jparser.parseByNameThrow("decisions", decisions);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_PLAY_NEXT_ROUND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _jparser.validateByNameThrow("minigamePlayId", minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	INT32 round; _jparser.validateByNameThrow("round", round);
	AtfValidator::validateIntRange(_descr, "round", round, 0, 0, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > decisions; _jparser.validateByNameThrow("decisions", decisions);
	AtfValidator::validateIntMax(_descr, "decisions", decisions.size(), 0, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_PLAY_NEXT_ROUND";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	INT32 round; _parser.parseINT32(round);
	AtfValidator::validateIntRange(_descr, "round", round, 0, 0, _checker, __FILE__, __LINE__);
	validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	decisions.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szDecisions = Atf::LAtfVector< INT32 , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("decisions"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "decisions", szDecisions, 0, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GAME_STATE
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::Protocol_MINIGAME_MSG_GAME_STATE()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::equals(const Protocol_MINIGAME_MSG_GAME_STATE& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_GAME_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_GAME_STATE*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GAME_STATE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_GAME_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigamePlayId", minigamePlayId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigamePlayId"))
			{
				minigamePlayId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigamePlayId", minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigamePlayId", minigamePlayId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GAME_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _jparser.validateByNameThrow("minigamePlayId", minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GAME_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GAME_STATE_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::Protocol_MINIGAME_MSG_GAME_STATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::Protocol_MINIGAME_MSG_GAME_STATE_REPLY(Protocol_MINIGAME_MSG_GAME_STATE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::operator=(Protocol_MINIGAME_MSG_GAME_STATE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::equals(const Protocol_MINIGAME_MSG_GAME_STATE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		state.equals(_o.state);
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_GAME_STATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_GAME_STATE_REPLY*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GAME_STATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_GAME_STATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		state.toXmlString("state", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::AtfTempl< MiniGameState >::FromXmlString(_value, state)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg, _ignoreJSON);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
	}
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("state", state);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("state", state);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GAME_STATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		MiniGameState state; _jparser.validateByNameThrow("state", state);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GAME_STATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GAME_STATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		MiniGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_SERVER_RESTARTING
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::Protocol_MINIGAME_MSG_SERVER_RESTARTING()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::clear()
{
}

bool MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::equals(const Protocol_MINIGAME_MSG_SERVER_RESTARTING& _o) const
{
	return true;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_SERVER_RESTARTING != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_SERVER_RESTARTING*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_SERVER_RESTARTING).append(")");
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_SERVER_RESTARTING).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::parseMsg(CommMsgParser& _parser)
{
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_SERVER_RESTARTING";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_SERVER_RESTARTING::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_SERVER_RESTARTING";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_TICKET_LOOKUP
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::Protocol_MINIGAME_MSG_TICKET_LOOKUP()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::clear()
{
	requestId = 0;
	ticketId = 0;
	ticketTypeId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::equals(const Protocol_MINIGAME_MSG_TICKET_LOOKUP& _o) const
{
	return requestId == _o.requestId &&
		ticketId == _o.ticketId &&
		ticketTypeId == _o.ticketTypeId;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_TICKET_LOOKUP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_TICKET_LOOKUP*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_TICKET_LOOKUP).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("ticketId=");
	_buf.appendUint64(ticketId);
	_buf.append(',');
	_buf.append("ticketTypeId=");
	_buf.appendUint(ticketTypeId);
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_TICKET_LOOKUP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketTypeId", ticketTypeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ticketId"))
			{
				ticketId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ticketTypeId"))
			{
				ticketTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(ticketId);
	_msg.composeUINT32(ticketTypeId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(ticketId);
	_parser.parseUINT32(ticketTypeId);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("ticketTypeId", ticketTypeId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("ticketTypeId", ticketTypeId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_TICKET_LOOKUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateUint(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeId; _jparser.validateByNameThrow("ticketTypeId", ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_TICKET_LOOKUP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 ticketId; _parser.parseUINT64(ticketId);
	AtfValidator::validateUint(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeId; _parser.parseUINT32(ticketTypeId);
	AtfValidator::validateInt(_descr, "ticketTypeId", ticketTypeId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY(Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, minigameId(std::move(_o.minigameId))
	, minigameType(std::move(_o.minigameType))
	, minigameBrandMask(std::move(_o.minigameBrandMask))
	, minigameSiteMaskEx(std::move(_o.minigameSiteMaskEx))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::operator=(Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		minigameId = std::move(_o.minigameId);
		minigameType = std::move(_o.minigameType);
		minigameBrandMask = std::move(_o.minigameBrandMask);
		minigameSiteMaskEx = std::move(_o.minigameSiteMaskEx);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	minigameId = 0;
	minigameType = 0;
	minigameBrandMask = 0;
	minigameSiteMaskEx.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::equals(const Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		minigameId == _o.minigameId &&
		minigameType == _o.minigameType &&
		minigameBrandMask == _o.minigameBrandMask &&
		minigameSiteMaskEx.equals(_o.minigameSiteMaskEx);
}

bool MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_TICKET_LOOKUP_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_TICKET_LOOKUP_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("minigameId=");
		_buf.appendUint(minigameId);
		_buf.append(',');
		_buf.append("minigameType=");
		_buf.appendUint(minigameType);
		_buf.append(',');
		_buf.append("minigameBrandMask=");
		_buf.appendUint(minigameBrandMask);
		_buf.append(',');
		_buf.append("minigameSiteMaskEx=");
		minigameSiteMaskEx.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_TICKET_LOOKUP_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
		Atf::XmlElement::encodeAsXmlElement("minigameType", minigameType, _buf);
		Atf::XmlElement::encodeAsXmlElement("minigameBrandMask", minigameBrandMask, _buf);
		minigameSiteMaskEx.toXmlString("minigameSiteMaskEx", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("minigameId"))
			{
				minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameType"))
			{
				minigameType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameBrandMask"))
			{
				minigameBrandMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameSiteMaskEx"))
			{
				if(!Atf::AtfTempl< PSiteMask >::FromXmlString(_value, minigameSiteMaskEx)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT32(minigameId);
		_msg.composeUINT32(minigameType);
		_msg.composeUINT32(minigameBrandMask);
		minigameSiteMaskEx.composeMsg(_msg, _ignoreJSON);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT32(minigameId);
		if(_parser.parseEnded()) return;
		_parser.parseUINT32(minigameType);
		if(_parser.parseEnded()) return;
		_parser.parseUINT32(minigameBrandMask);
		if(_parser.parseEnded()) return;
		minigameSiteMaskEx.parseMsg(_parser);
	}
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("minigameId", minigameId);
		_jsonstr.compose("minigameType", minigameType);
		_jsonstr.compose("minigameBrandMask", minigameBrandMask);
		_jsonstr.compose("minigameSiteMaskEx", minigameSiteMaskEx);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("minigameId", minigameId);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("minigameType", minigameType);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("minigameBrandMask", minigameBrandMask);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("minigameSiteMaskEx", minigameSiteMaskEx);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_TICKET_LOOKUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
		AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT32 minigameType; _jparser.validateByNameThrow("minigameType", minigameType);
		AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT32 minigameBrandMask; _jparser.validateByNameThrow("minigameBrandMask", minigameBrandMask);
		AtfValidator::validateInt(_descr, "minigameBrandMask", minigameBrandMask, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		PSiteMask minigameSiteMaskEx; _jparser.validateByNameThrow("minigameSiteMaskEx", minigameSiteMaskEx);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_TICKET_LOOKUP_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 minigameId; _parser.parseUINT32(minigameId);
		AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT32 minigameType; _parser.parseUINT32(minigameType);
		AtfValidator::validateInt(_descr, "minigameType", minigameType, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT32 minigameBrandMask; _parser.parseUINT32(minigameBrandMask);
		AtfValidator::validateInt(_descr, "minigameBrandMask", minigameBrandMask, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		PSiteMask::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("minigameSiteMaskEx"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GET_TICKETS
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::Protocol_MINIGAME_MSG_GET_TICKETS()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::clear()
{
	requestId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::equals(const Protocol_MINIGAME_MSG_GET_TICKETS& _o) const
{
	return requestId == _o.requestId;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_GET_TICKETS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_GET_TICKETS*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GET_TICKETS).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_GET_TICKETS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GET_TICKETS_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY(Protocol_MINIGAME_MSG_GET_TICKETS_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, ticketsWithMinigames(std::move(_o.ticketsWithMinigames))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::operator=(Protocol_MINIGAME_MSG_GET_TICKETS_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		ticketsWithMinigames = std::move(_o.ticketsWithMinigames);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	ticketsWithMinigames.clear();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::equals(const Protocol_MINIGAME_MSG_GET_TICKETS_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		ticketsWithMinigames.equals(_o.ticketsWithMinigames);
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_GET_TICKETS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_GET_TICKETS_REPLY*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GET_TICKETS_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("ticketsWithMinigames=");
		ticketsWithMinigames.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_GET_TICKETS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		ticketsWithMinigames.toXmlString("ticketsWithMinigames", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("ticketsWithMinigames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameTicketWithMiniGame , 4 > >::FromXmlString(_value, ticketsWithMinigames)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		ticketsWithMinigames.composeMsg(_msg, _ignoreJSON);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		ticketsWithMinigames.parseMsg(_parser);
	}
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("ticketsWithMinigames", ticketsWithMinigames);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("ticketsWithMinigames", ticketsWithMinigames);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_TICKETS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< GameTicketWithMiniGame > ticketsWithMinigames; _jparser.validateByNameThrow("ticketsWithMinigames", ticketsWithMinigames);
		AtfValidator::validateInt(_descr, "ticketsWithMinigames", ticketsWithMinigames.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_TICKETS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTicketsWithMinigames = Atf::LAtfVector< GameTicketWithMiniGame , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ticketsWithMinigames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ticketsWithMinigames", szTicketsWithMinigames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GET_STACKED_TICKETS
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS()
{
	clear();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::clear()
{
	requestId = 0;
	minigameId = 0;
	gameTicketTypeId = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::equals(const Protocol_MINIGAME_MSG_GET_STACKED_TICKETS& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameTicketTypeId == _o.gameTicketTypeId;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_GET_STACKED_TICKETS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_GET_STACKED_TICKETS*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GET_STACKED_TICKETS).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint(gameTicketTypeId);
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_GET_STACKED_TICKETS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTicketTypeId", gameTicketTypeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameId"))
			{
				minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameTicketTypeId"))
			{
				gameTicketTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeUINT32(gameTicketTypeId);
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	_parser.parseUINT32(gameTicketTypeId);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("gameTicketTypeId", gameTicketTypeId);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("gameTicketTypeId", gameTicketTypeId);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_STACKED_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT32 gameTicketTypeId; _jparser.validateByNameThrow("gameTicketTypeId", gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_STACKED_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT32 gameTicketTypeId; _parser.parseUINT32(gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY(Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, playsRemaining(std::move(_o.playsRemaining))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::operator=(Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		playsRemaining = std::move(_o.playsRemaining);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	playsRemaining = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::equals(const Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		playsRemaining == _o.playsRemaining;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_GET_STACKED_TICKETS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_GET_STACKED_TICKETS_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playsRemaining=");
		_buf.appendInt(playsRemaining);
	}
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_GET_STACKED_TICKETS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("playsRemaining", playsRemaining, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("playsRemaining"))
			{
				playsRemaining = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeINT32(playsRemaining);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseINT32(playsRemaining);
	}
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("playsRemaining", playsRemaining);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("playsRemaining", playsRemaining);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_STACKED_TICKETS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 playsRemaining; _jparser.validateByNameThrow("playsRemaining", playsRemaining);
		AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_GET_STACKED_TICKETS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 playsRemaining; _parser.parseINT32(playsRemaining);
		AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER
//=================================================================

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER&& _o)
	: clientCtx(std::move(_o.clientCtx))
	, gameMsgId(std::move(_o.gameMsgId))
	, gameMsgBody(std::move(_o.gameMsgBody))
{
}

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER& MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::operator=(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER&& _o)
{
	if(this != &_o)
	{
		clientCtx = std::move(_o.clientCtx);
		gameMsgId = std::move(_o.gameMsgId);
		gameMsgBody = std::move(_o.gameMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::clear()
{
	clientCtx = 0;
	gameMsgId = 0;
	gameMsgBody.clear();
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::equals(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER& _o) const
{
	return clientCtx == _o.clientCtx &&
		gameMsgId == _o.gameMsgId &&
		gameMsgBody.equals(_o.gameMsgBody);
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER*)_other));
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER).append(")");
	_buf.append(',');
	_buf.append("clientCtx=");
	_buf.appendUint64(clientCtx);
	_buf.append(',');
	_buf.append("gameMsgId=");
	_buf.appendUint(gameMsgId);
	_buf.append(',');
	_buf.append("gameMsgBody=");
	gameMsgBody.toTraceString(_buf);
	return _buf.c_str();
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientCtx", clientCtx, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMsgId", gameMsgId, _buf);
	gameMsgBody.toXmlString("gameMsgBody", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientCtx"))
			{
				clientCtx = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameMsgId"))
			{
				gameMsgId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameMsgBody"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, gameMsgBody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(clientCtx);
	_msg.composeUINT32(gameMsgId);
	gameMsgBody.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(clientCtx);
	_parser.parseUINT32(gameMsgId);
	gameMsgBody.parseMsg(_parser);
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientCtx", clientCtx);
	_jsonstr.compose("gameMsgId", gameMsgId);
	_jsonstr.compose("gameMsgBody", gameMsgBody);
	return _buf.c_str();
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientCtx", clientCtx);
	_jparser.parseByNameThrow("gameMsgId", gameMsgId);
	_jparser.parseByNameThrow("gameMsgBody", gameMsgBody);
}

/*static*/ void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 clientCtx; _jparser.validateByNameThrow("clientCtx", clientCtx);
	AtfValidator::validateUint(_descr, "clientCtx", clientCtx, _checker, __FILE__, __LINE__);
	UINT32 gameMsgId; _jparser.validateByNameThrow("gameMsgId", gameMsgId);
	AtfValidator::validateInt(_descr, "gameMsgId", gameMsgId, _checker, __FILE__, __LINE__);
	Atf::MsgBodyWithJSON gameMsgBody; _jparser.validateByNameThrow("gameMsgBody", gameMsgBody);
	AtfValidator::validateIntMax(_descr, "gameMsgBody", gameMsgBody.jsonLengthOrMsgBodySize(), 1048576, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 clientCtx; _parser.parseUINT64(clientCtx);
	AtfValidator::validateUint(_descr, "clientCtx", clientCtx, _checker, __FILE__, __LINE__);
	UINT32 gameMsgId; _parser.parseUINT32(gameMsgId);
	AtfValidator::validateInt(_descr, "gameMsgId", gameMsgId, _checker, __FILE__, __LINE__);
	Atf::MsgBodyWithJSON gameMsgBody; gameMsgBody.parseMsg(_parser);
	AtfValidator::validateIntMax(_descr, "gameMsgBody", gameMsgBody.jsonLengthOrMsgBodySize(), 1048576, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER
//=================================================================

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER&& _o)
	: clientCtx(std::move(_o.clientCtx))
	, gameMsgId(std::move(_o.gameMsgId))
	, gameMsgBody(std::move(_o.gameMsgBody))
	, gameStateMetaDataMsgBody(std::move(_o.gameStateMetaDataMsgBody))
{
}

MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER& MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::operator=(Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER&& _o)
{
	if(this != &_o)
	{
		clientCtx = std::move(_o.clientCtx);
		gameMsgId = std::move(_o.gameMsgId);
		gameMsgBody = std::move(_o.gameMsgBody);
		gameStateMetaDataMsgBody = std::move(_o.gameStateMetaDataMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::clear()
{
	clientCtx = 0;
	gameMsgId = 0;
	gameMsgBody.clear();
	gameStateMetaDataMsgBody.clear();
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::equals(const Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER& _o) const
{
	return clientCtx == _o.clientCtx &&
		gameMsgId == _o.gameMsgId &&
		gameMsgBody.equals(_o.gameMsgBody) &&
		gameStateMetaDataMsgBody.equals(_o.gameStateMetaDataMsgBody);
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER*)_other));
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER).append(")");
	_buf.append(',');
	_buf.append("clientCtx=");
	_buf.appendUint64(clientCtx);
	_buf.append(',');
	_buf.append("gameMsgId=");
	_buf.appendUint(gameMsgId);
	_buf.append(',');
	_buf.append("gameMsgBody=");
	gameMsgBody.toTraceString(_buf);
	_buf.append(',');
	_buf.append("gameStateMetaDataMsgBody=");
	gameStateMetaDataMsgBody.toTraceString(_buf);
	return _buf.c_str();
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientCtx", clientCtx, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameMsgId", gameMsgId, _buf);
	gameMsgBody.toXmlString("gameMsgBody", _buf);
	gameStateMetaDataMsgBody.toXmlString("gameStateMetaDataMsgBody", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientCtx"))
			{
				clientCtx = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameMsgId"))
			{
				gameMsgId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameMsgBody"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, gameMsgBody)) return false;
			}
			else if (_element.equals("gameStateMetaDataMsgBody"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, gameStateMetaDataMsgBody)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(clientCtx);
	_msg.composeUINT32(gameMsgId);
	gameMsgBody.composeMsg(_msg, _ignoreJSON);
	gameStateMetaDataMsgBody.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(clientCtx);
	_parser.parseUINT32(gameMsgId);
	gameMsgBody.parseMsg(_parser);
	gameStateMetaDataMsgBody.parseMsg(_parser);
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientCtx", clientCtx);
	_jsonstr.compose("gameMsgId", gameMsgId);
	_jsonstr.compose("gameMsgBody", gameMsgBody);
	_jsonstr.compose("gameStateMetaDataMsgBody", gameStateMetaDataMsgBody);
	return _buf.c_str();
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientCtx", clientCtx);
	_jparser.parseByNameThrow("gameMsgId", gameMsgId);
	_jparser.parseByNameThrow("gameMsgBody", gameMsgBody);
	_jparser.parseByNameThrow("gameStateMetaDataMsgBody", gameStateMetaDataMsgBody);
}

/*static*/ void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 clientCtx; _jparser.validateByNameThrow("clientCtx", clientCtx);
	AtfValidator::validateUint(_descr, "clientCtx", clientCtx, _checker, __FILE__, __LINE__);
	UINT32 gameMsgId; _jparser.validateByNameThrow("gameMsgId", gameMsgId);
	AtfValidator::validateInt(_descr, "gameMsgId", gameMsgId, _checker, __FILE__, __LINE__);
	Atf::MsgBodyWithJSON gameMsgBody; _jparser.validateByNameThrow("gameMsgBody", gameMsgBody);
	AtfValidator::validateIntMax(_descr, "gameMsgBody", gameMsgBody.jsonLengthOrMsgBodySize(), 1048576, _checker, __FILE__, __LINE__);
	Atf::MsgBodyWithJSON gameStateMetaDataMsgBody; _jparser.validateByNameThrow("gameStateMetaDataMsgBody", gameStateMetaDataMsgBody);
	AtfValidator::validateIntMax(_descr, "gameStateMetaDataMsgBody", gameStateMetaDataMsgBody.jsonLengthOrMsgBodySize(), 1048576, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 clientCtx; _parser.parseUINT64(clientCtx);
	AtfValidator::validateUint(_descr, "clientCtx", clientCtx, _checker, __FILE__, __LINE__);
	UINT32 gameMsgId; _parser.parseUINT32(gameMsgId);
	AtfValidator::validateInt(_descr, "gameMsgId", gameMsgId, _checker, __FILE__, __LINE__);
	Atf::MsgBodyWithJSON gameMsgBody; gameMsgBody.parseMsg(_parser);
	AtfValidator::validateIntMax(_descr, "gameMsgBody", gameMsgBody.jsonLengthOrMsgBodySize(), 1048576, _checker, __FILE__, __LINE__);
	Atf::MsgBodyWithJSON gameStateMetaDataMsgBody; gameStateMetaDataMsgBody.parseMsg(_parser);
	AtfValidator::validateIntMax(_descr, "gameStateMetaDataMsgBody", gameStateMetaDataMsgBody.jsonLengthOrMsgBodySize(), 1048576, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PokerSideBetGameStateMetaData
//=================================================================

MiniGameClient::client::PokerSideBetGameStateMetaData::PokerSideBetGameStateMetaData()
{
	clear();
}

void MiniGameClient::client::PokerSideBetGameStateMetaData::clear()
{
	gameStatus = eSBS_NoBet;
	betAmount = 0;
	winAmount = 0;
	numAutoPlaysRemainingToDisplay = 0;
}

bool MiniGameClient::client::PokerSideBetGameStateMetaData::equals(const PokerSideBetGameStateMetaData& _o) const
{
	return gameStatus == _o.gameStatus &&
		betAmount == _o.betAmount &&
		winAmount == _o.winAmount &&
		numAutoPlaysRemainingToDisplay == _o.numAutoPlaysRemainingToDisplay;
}

const char *MiniGameClient::client::PokerSideBetGameStateMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameStatus=");
	_buf.appendInt(gameStatus);
	_buf.append(',');
	_buf.append("betAmount=");
	_buf.appendInt64(betAmount);
	_buf.append(',');
	_buf.append("winAmount=");
	_buf.appendInt64(winAmount);
	_buf.append(',');
	_buf.append("numAutoPlaysRemainingToDisplay=");
	_buf.appendInt(numAutoPlaysRemainingToDisplay);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::client::PokerSideBetGameStateMetaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameStatus", gameStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("betAmount", betAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("winAmount", winAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::client::PokerSideBetGameStateMetaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameStatus"))
		{
			gameStatus = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("betAmount"))
		{
			betAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("winAmount"))
		{
			winAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numAutoPlaysRemainingToDisplay"))
		{
			numAutoPlaysRemainingToDisplay = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::client::PokerSideBetGameStateMetaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetGameStateMetaData())) // not empty
	{
		_body.composeINT32(gameStatus);
		_body.composeINT64(betAmount);
		_body.composeINT64(winAmount);
		_body.composeINT8(numAutoPlaysRemainingToDisplay);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::client::PokerSideBetGameStateMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(gameStatus);
	_parser0.parseINT64(betAmount);
	_parser0.parseINT64(winAmount);
	_parser0.parseINT8(numAutoPlaysRemainingToDisplay);
}

const char *MiniGameClient::client::PokerSideBetGameStateMetaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameStatus", gameStatus);
	_jsonstr.compose("betAmount", betAmount);
	_jsonstr.compose("winAmount", winAmount);
	_jsonstr.compose("numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay);
	return _buf.c_str();
}

void MiniGameClient::client::PokerSideBetGameStateMetaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameStatus", gameStatus);
	_jparser.parseByNameThrow("betAmount", betAmount);
	_jparser.parseByNameThrow("winAmount", winAmount);
	_jparser.parseByNameThrow("numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay);
}

/* static */ void MiniGameClient::client::PokerSideBetGameStateMetaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 gameStatus; _jparser.validateByNameThrow("gameStatus", gameStatus);
	AtfValidator::validateInt(_descr, "gameStatus", gameStatus, _checker, __FILE__, __LINE__);
	INT64 betAmount; _jparser.validateByNameThrow("betAmount", betAmount);
	AtfValidator::validateInt(_descr, "betAmount", betAmount, _checker, __FILE__, __LINE__);
	INT64 winAmount; _jparser.validateByNameThrow("winAmount", winAmount);
	AtfValidator::validateInt(_descr, "winAmount", winAmount, _checker, __FILE__, __LINE__);
	INT8 numAutoPlaysRemainingToDisplay; _jparser.validateByNameThrow("numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay);
	AtfValidator::validateInt(_descr, "numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::client::PokerSideBetGameStateMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 gameStatus; _parser0.parseINT32(gameStatus);
	AtfValidator::validateInt(_descr, "gameStatus", gameStatus, _checker, __FILE__, __LINE__);
	INT64 betAmount; _parser0.parseINT64(betAmount);
	AtfValidator::validateInt(_descr, "betAmount", betAmount, _checker, __FILE__, __LINE__);
	INT64 winAmount; _parser0.parseINT64(winAmount);
	AtfValidator::validateInt(_descr, "winAmount", winAmount, _checker, __FILE__, __LINE__);
	INT8 numAutoPlaysRemainingToDisplay; _parser0.parseINT8(numAutoPlaysRemainingToDisplay);
	AtfValidator::validateInt(_descr, "numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameStateMetaData
//=================================================================

MiniGameClient::client::GameStateMetaData::GameStateMetaData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::GameStateMetaData::GameStateMetaData(GameStateMetaData&& _o)
	: gameState(std::move(_o.gameState))
	, chosenSuit(std::move(_o.chosenSuit))
	, position(std::move(_o.position))
	, stateMsgBody(std::move(_o.stateMsgBody))
{
}

MiniGameClient::client::GameStateMetaData& MiniGameClient::client::GameStateMetaData::operator=(GameStateMetaData&& _o)
{
	if(this != &_o)
	{
		gameState = std::move(_o.gameState);
		chosenSuit = std::move(_o.chosenSuit);
		position = std::move(_o.position);
		stateMsgBody = std::move(_o.stateMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::client::GameStateMetaData::clear()
{
	gameState = eSGS_None;
	chosenSuit = eSuitRaceSuit_None;
	position = eSuitRace_Unknown;
	stateMsgBody.clear();
}

bool MiniGameClient::client::GameStateMetaData::equals(const GameStateMetaData& _o) const
{
	return gameState == _o.gameState &&
		chosenSuit == _o.chosenSuit &&
		position == _o.position &&
		stateMsgBody.equals(_o.stateMsgBody);
}

const char *MiniGameClient::client::GameStateMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameState=");
	_buf.appendInt(gameState);
	_buf.append(',');
	_buf.append("chosenSuit=");
	_buf.appendUint(chosenSuit);
	_buf.append(',');
	_buf.append("position=");
	_buf.appendInt(position);
	_buf.append(',');
	_buf.append("stateMsgBody=");
	stateMsgBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::client::GameStateMetaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameState", gameState, _buf);
	Atf::XmlElement::encodeAsXmlElement("chosenSuit", chosenSuit, _buf);
	Atf::XmlElement::encodeAsXmlElement("position", position, _buf);
	stateMsgBody.toXmlString("stateMsgBody", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::client::GameStateMetaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameState"))
		{
			gameState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("chosenSuit"))
		{
			chosenSuit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("position"))
		{
			position = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stateMsgBody"))
		{
			if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, stateMsgBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::client::GameStateMetaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(gameState);
	_msg.composeBYTE(chosenSuit);
	_msg.composeINT32(position);
	stateMsgBody.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::client::GameStateMetaData::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseINT32(gameState);
	if(_parser.parseEnded()) return;
	_parser.parseBYTE(chosenSuit);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(position);
	if(_parser.parseEnded()) return;
	stateMsgBody.parseMsg(_parser);
}

const char *MiniGameClient::client::GameStateMetaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameState", gameState);
	_jsonstr.compose("chosenSuit", chosenSuit);
	_jsonstr.compose("position", position);
	_jsonstr.compose("stateMsgBody", stateMsgBody);
	return _buf.c_str();
}

void MiniGameClient::client::GameStateMetaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("gameState", gameState);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("chosenSuit", chosenSuit);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("position", position);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("stateMsgBody", stateMsgBody);
}

/* static */ void MiniGameClient::client::GameStateMetaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	INT32 gameState; _jparser.validateByNameThrow("gameState", gameState);
	AtfValidator::validateInt(_descr, "gameState", gameState, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	BYTE chosenSuit; _jparser.validateByNameThrow("chosenSuit", chosenSuit);
	AtfValidator::validateInt(_descr, "chosenSuit", chosenSuit, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 position; _jparser.validateByNameThrow("position", position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::MsgBodyWithJSON stateMsgBody; _jparser.validateByNameThrow("stateMsgBody", stateMsgBody);
	AtfValidator::validateInt(_descr, "stateMsgBody", stateMsgBody.jsonLengthOrMsgBodySize(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::client::GameStateMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	if(_parser.parseEnded()) return;
	INT32 gameState; _parser.parseINT32(gameState);
	AtfValidator::validateInt(_descr, "gameState", gameState, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	BYTE chosenSuit; _parser.parseBYTE(chosenSuit);
	AtfValidator::validateInt(_descr, "chosenSuit", chosenSuit, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 position; _parser.parseINT32(position);
	AtfValidator::validateInt(_descr, "position", position, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	Atf::MsgBodyWithJSON stateMsgBody; stateMsgBody.parseMsg(_parser);
	AtfValidator::validateInt(_descr, "stateMsgBody", stateMsgBody.jsonLengthOrMsgBodySize(), _checker, __FILE__, __LINE__);
}

//=================================================================
//                    SideGameAnim
//=================================================================

MiniGameClient::client::SideGameAnim::SideGameAnim()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::SideGameAnim::SideGameAnim(SideGameAnim&& _o)
	: animType(std::move(_o.animType))
	, location(std::move(_o.location))
	, animMsgBody(std::move(_o.animMsgBody))
{
}

MiniGameClient::client::SideGameAnim& MiniGameClient::client::SideGameAnim::operator=(SideGameAnim&& _o)
{
	if(this != &_o)
	{
		animType = std::move(_o.animType);
		location = std::move(_o.location);
		animMsgBody = std::move(_o.animMsgBody);
	}
	return *this;
}

#endif

void MiniGameClient::client::SideGameAnim::clear()
{
	animType = 0;
	location = 0;
	animMsgBody.clear();
}

bool MiniGameClient::client::SideGameAnim::equals(const SideGameAnim& _o) const
{
	return animType == _o.animType &&
		location == _o.location &&
		animMsgBody.equals(_o.animMsgBody);
}

const char *MiniGameClient::client::SideGameAnim::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("animType=");
	_buf.appendInt(animType);
	_buf.append(',');
	_buf.append("location=");
	_buf.appendInt(location);
	_buf.append(',');
	_buf.append("animMsgBody=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(animMsgBody, _buf); _buf.append('}');
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::client::SideGameAnim::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("animType", animType, _buf);
	Atf::XmlElement::encodeAsXmlElement("location", location, _buf);
	Atf::XmlElement::encodeAsXmlElement("animMsgBody", animMsgBody, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::client::SideGameAnim::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("animType"))
		{
			animType = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("location"))
		{
			location = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("animMsgBody"))
		{
			if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, animMsgBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::client::SideGameAnim::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SideGameAnim())) // not empty
	{
		_body.composeINT32(animType);
		_body.composeINT32(location);
		_body.composeMsgBody(animMsgBody);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::client::SideGameAnim::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(animType);
	_parser0.parseINT32(location);
	if(_parser0.parseEnded()) return;
	_parser0.parseMsgBody(animMsgBody);
}

const char *MiniGameClient::client::SideGameAnim::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("animType", animType);
	_jsonstr.compose("location", location);
	_jsonstr.compose("animMsgBody", animMsgBody);
	return _buf.c_str();
}

void MiniGameClient::client::SideGameAnim::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("animType", animType);
	_jparser.parseByNameThrow("location", location);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("animMsgBody", animMsgBody);
}

/* static */ void MiniGameClient::client::SideGameAnim::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 animType; _jparser.validateByNameThrow("animType", animType);
	AtfValidator::validateInt(_descr, "animType", animType, _checker, __FILE__, __LINE__);
	INT32 location; _jparser.validateByNameThrow("location", location);
	AtfValidator::validateInt(_descr, "location", location, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::CopyableMsgBody animMsgBody; _jparser.validateByNameThrow("animMsgBody", animMsgBody);
	AtfValidator::validateInt(_descr, "animMsgBody", animMsgBody._size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::client::SideGameAnim::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 animType; _parser0.parseINT32(animType);
	AtfValidator::validateInt(_descr, "animType", animType, _checker, __FILE__, __LINE__);
	INT32 location; _parser0.parseINT32(location);
	AtfValidator::validateInt(_descr, "location", location, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	size_t szAnimMsgBody; _parser0.skipMsgBody(szAnimMsgBody);  /*animMsgBody*/
	AtfValidator::validateInt(_descr, "animMsgBody", szAnimMsgBody, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SideBetWinAnimMsgBody
//=================================================================

MiniGameClient::client::SideBetWinAnimMsgBody::SideBetWinAnimMsgBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::SideBetWinAnimMsgBody::SideBetWinAnimMsgBody(SideBetWinAnimMsgBody&& _o)
	: amount(std::move(_o.amount))
	, currency(std::move(_o.currency))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, betType(std::move(_o.betType))
	, amount64(std::move(_o.amount64))
{
}

MiniGameClient::client::SideBetWinAnimMsgBody& MiniGameClient::client::SideBetWinAnimMsgBody::operator=(SideBetWinAnimMsgBody&& _o)
{
	if(this != &_o)
	{
		amount = std::move(_o.amount);
		currency = std::move(_o.currency);
		isPlayMoney = std::move(_o.isPlayMoney);
		betType = std::move(_o.betType);
		amount64 = std::move(_o.amount64);
	}
	return *this;
}

#endif

void MiniGameClient::client::SideBetWinAnimMsgBody::clear()
{
	amount = 0;
	currency.clear();
	isPlayMoney = false;
	betType.clear();
	amount64 = 0;
}

bool MiniGameClient::client::SideBetWinAnimMsgBody::equals(const SideBetWinAnimMsgBody& _o) const
{
	return amount == _o.amount &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(betType, _o.betType) &&
		amount64 == _o.amount64;
}

const char *MiniGameClient::client::SideBetWinAnimMsgBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("betType=");
	_buf.append(betType);
	_buf.append(',');
	_buf.append("amount64=");
	_buf.appendInt64(amount64);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::client::SideBetWinAnimMsgBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("betType", betType, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount64", amount64, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::client::SideBetWinAnimMsgBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amount"))
		{
			amount = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("betType"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, betType)) return false;
		}
		else if (_element.equals("amount64"))
		{
			amount64 = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::client::SideBetWinAnimMsgBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(amount);
	_msg.composeString(currency);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(betType);
	_msg.composeINT64(amount64);
}

void MiniGameClient::client::SideBetWinAnimMsgBody::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(amount);
	_parser.parseStringP(currency);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(betType);
	if(_parser.parseEnded()) return;
	_parser.parseINT64(amount64);
}

const char *MiniGameClient::client::SideBetWinAnimMsgBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("betType", betType);
	_jsonstr.compose("amount64", amount64);
	return _buf.c_str();
}

void MiniGameClient::client::SideBetWinAnimMsgBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("betType", betType);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("amount64", amount64);
}

/* static */ void MiniGameClient::client::SideBetWinAnimMsgBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString betType; _jparser.validateByNameThrow("betType", betType);
	AtfValidator::validateInt(_descr, "betType", betType.length(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT64 amount64; _jparser.validateByNameThrow("amount64", amount64);
	AtfValidator::validateInt(_descr, "amount64", amount64, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::client::SideBetWinAnimMsgBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT32 amount; _parser.parseINT32(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "betType"); size_t szBetType = strlen(_dummy);
	AtfValidator::validateInt(_descr, "betType", szBetType, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT64 amount64; _parser.parseINT64(amount64);
	AtfValidator::validateInt(_descr, "amount64", amount64, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION
//=================================================================

MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION(Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION&& _o)
	: handId(std::move(_o.handId))
	, anims(std::move(_o.anims))
{
}

MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION& MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::operator=(Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION&& _o)
{
	if(this != &_o)
	{
		handId = std::move(_o.handId);
		anims = std::move(_o.anims);
	}
	return *this;
}

#endif

void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::clear()
{
	handId = 0;
	anims.clear();
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::equals(const Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION& _o) const
{
	return handId == _o.handId &&
		anims.equals(_o.anims);
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_TRIGGER_ANIMATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION*)_other));
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_TRIGGER_ANIMATION).append(")");
	_buf.append(',');
	_buf.append("handId=");
	_buf.appendUint64(handId);
	_buf.append(',');
	_buf.append("anims=");
	anims.toTraceString(_buf);
	return _buf.c_str();
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_TRIGGER_ANIMATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("handId", handId, _buf);
	anims.toXmlString("anims", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("handId"))
			{
				handId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("anims"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SideGameAnim , 4 > >::FromXmlString(_value, anims)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT64(handId);
	anims.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT64(handId);
	anims.parseMsg(_parser);
}

const char *MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handId", handId);
	_jsonstr.compose("anims", anims);
	return _buf.c_str();
}

void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handId", handId);
	_jparser.parseByNameThrow("anims", anims);
}

/*static*/ void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_TRIGGER_ANIMATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 handId; _jparser.validateByNameThrow("handId", handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SideGameAnim > anims; _jparser.validateByNameThrow("anims", anims);
	AtfValidator::validateInt(_descr, "anims", anims.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_TRIGGER_ANIMATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT64 handId; _parser.parseUINT64(handId);
	AtfValidator::validateUint(_descr, "handId", handId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAnims = Atf::LAtfVector< SideGameAnim , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("anims"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "anims", szAnims, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SGCard
//=================================================================

MiniGameClient::sidegame::SGCard::SGCard()
{
	clear();
}

void MiniGameClient::sidegame::SGCard::clear()
{
	rank = 0;
	suit = 0;
}

bool MiniGameClient::sidegame::SGCard::equals(const SGCard& _o) const
{
	return rank == _o.rank &&
		suit == _o.suit;
}

const char *MiniGameClient::sidegame::SGCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append(',');
	_buf.append("suit=");
	_buf.appendUint(suit);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::SGCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("rank", rank, _buf);
	Atf::XmlElement::encodeAsXmlElement("suit", suit, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::SGCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("rank"))
		{
			rank = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("suit"))
		{
			suit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::SGCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SGCard())) // not empty
	{
		_body.composeBYTE(rank);
		_body.composeBYTE(suit);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SGCard::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(rank);
	_parser0.parseBYTE(suit);
}

const char *MiniGameClient::sidegame::SGCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("rank", rank);
	_jsonstr.compose("suit", suit);
	return _buf.c_str();
}

void MiniGameClient::sidegame::SGCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("rank", rank);
	_jparser.parseByNameThrow("suit", suit);
}

/* static */ void MiniGameClient::sidegame::SGCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE rank; _jparser.validateByNameThrow("rank", rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	BYTE suit; _jparser.validateByNameThrow("suit", suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::SGCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE rank; _parser0.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MCard
//=================================================================

MiniGameClient::sidegame::MCard::MCard()
{
	clear();
}

void MiniGameClient::sidegame::MCard::clear()
{
	rank = 0;
	suit = 0;
	matched = false;
	possibleMatch = false;
}

bool MiniGameClient::sidegame::MCard::equals(const MCard& _o) const
{
	return rank == _o.rank &&
		suit == _o.suit &&
		matched == _o.matched &&
		possibleMatch == _o.possibleMatch;
}

const char *MiniGameClient::sidegame::MCard::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append(',');
	_buf.append("suit=");
	_buf.appendUint(suit);
	_buf.append(',');
	_buf.append("matched=");
	_buf.appendUint(matched);
	_buf.append(',');
	_buf.append("possibleMatch=");
	_buf.appendUint(possibleMatch);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::MCard::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("rank", rank, _buf);
	Atf::XmlElement::encodeAsXmlElement("suit", suit, _buf);
	Atf::XmlElement::encodeAsXmlElement("matched", matched, _buf);
	Atf::XmlElement::encodeAsXmlElement("possibleMatch", possibleMatch, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::MCard::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("rank"))
		{
			rank = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("suit"))
		{
			suit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("matched"))
		{
			matched = (*_value.ptr() == '1');
		}
		else if (_element.equals("possibleMatch"))
		{
			possibleMatch = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::MCard::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MCard())) // not empty
	{
		_body.composeBYTE(rank);
		_body.composeBYTE(suit);
		_body.composeBOOL(matched);
		_body.composeBOOL(possibleMatch);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::MCard::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(rank);
	_parser0.parseBYTE(suit);
	_parser0.parseBOOL(matched);
	if(_parser0.parseEnded()) return;
	_parser0.parseBOOL(possibleMatch);
}

const char *MiniGameClient::sidegame::MCard::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("rank", rank);
	_jsonstr.compose("suit", suit);
	_jsonstr.compose("matched", matched);
	_jsonstr.compose("possibleMatch", possibleMatch);
	return _buf.c_str();
}

void MiniGameClient::sidegame::MCard::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("rank", rank);
	_jparser.parseByNameThrow("suit", suit);
	_jparser.parseByNameThrow("matched", matched);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("possibleMatch", possibleMatch);
}

/* static */ void MiniGameClient::sidegame::MCard::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE rank; _jparser.validateByNameThrow("rank", rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	BYTE suit; _jparser.validateByNameThrow("suit", suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	bool matched; _jparser.validateByNameThrow("matched", matched);
	AtfValidator::validateInt(_descr, "matched", matched, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool possibleMatch; _jparser.validateByNameThrow("possibleMatch", possibleMatch);
	AtfValidator::validateInt(_descr, "possibleMatch", possibleMatch, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::MCard::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE rank; _parser0.parseBYTE(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	bool matched; _parser0.parseBOOL(matched);
	AtfValidator::validateInt(_descr, "matched", matched, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	bool possibleMatch; _parser0.parseBOOL(possibleMatch);
	AtfValidator::validateInt(_descr, "possibleMatch", possibleMatch, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideGameState
//=================================================================

MiniGameClient::sidegame::PokerSideGameState::PokerSideGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PokerSideGameState::PokerSideGameState(PokerSideGameState&& _o)
	: timestamp(std::move(_o.timestamp))
	, handsTotal(std::move(_o.handsTotal))
	, handsRemaining(std::move(_o.handsRemaining))
	, handsRequiredToForfeit(std::move(_o.handsRequiredToForfeit))
	, lifeCycleState(std::move(_o.lifeCycleState))
	, currentHandState(std::move(_o.currentHandState))
	, prize(std::move(_o.prize))
{
}

MiniGameClient::sidegame::PokerSideGameState& MiniGameClient::sidegame::PokerSideGameState::operator=(PokerSideGameState&& _o)
{
	if(this != &_o)
	{
		timestamp = std::move(_o.timestamp);
		handsTotal = std::move(_o.handsTotal);
		handsRemaining = std::move(_o.handsRemaining);
		handsRequiredToForfeit = std::move(_o.handsRequiredToForfeit);
		lifeCycleState = std::move(_o.lifeCycleState);
		currentHandState = std::move(_o.currentHandState);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PokerSideGameState::clear()
{
	timestamp = 0;
	handsTotal = 0;
	handsRemaining = 0;
	handsRequiredToForfeit = 0;
	lifeCycleState = 0;
	currentHandState = 0;
	prize.clear();
}

bool MiniGameClient::sidegame::PokerSideGameState::equals(const PokerSideGameState& _o) const
{
	return timestamp == _o.timestamp &&
		handsTotal == _o.handsTotal &&
		handsRemaining == _o.handsRemaining &&
		handsRequiredToForfeit == _o.handsRequiredToForfeit &&
		lifeCycleState == _o.lifeCycleState &&
		currentHandState == _o.currentHandState &&
		prize.equals(_o.prize);
}

const char *MiniGameClient::sidegame::PokerSideGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("handsTotal=");
	_buf.appendInt(handsTotal);
	_buf.append(',');
	_buf.append("handsRemaining=");
	_buf.appendInt(handsRemaining);
	_buf.append(',');
	_buf.append("handsRequiredToForfeit=");
	_buf.appendInt(handsRequiredToForfeit);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("currentHandState=");
	_buf.appendInt(currentHandState);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::PokerSideGameState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("timestamp", timestamp, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsTotal", handsTotal, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsRemaining", handsRemaining, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsRequiredToForfeit", handsRequiredToForfeit, _buf);
	Atf::XmlElement::encodeAsXmlElement("lifeCycleState", lifeCycleState, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentHandState", currentHandState, _buf);
	prize.toXmlString("prize", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::PokerSideGameState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("timestamp"))
		{
			timestamp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsTotal"))
		{
			handsTotal = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsRemaining"))
		{
			handsRemaining = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsRequiredToForfeit"))
		{
			handsRequiredToForfeit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lifeCycleState"))
		{
			lifeCycleState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currentHandState"))
		{
			currentHandState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prize"))
		{
			if(!Atf::AtfTempl< MiniGamePrize >::FromXmlString(_value, prize)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::PokerSideGameState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideGameState())) // not empty
	{
		_body.composeINT32(timestamp);
		_body.composeINT32(handsTotal);
		_body.composeINT32(handsRemaining);
		_body.composeINT32(handsRequiredToForfeit);
		_body.composeINT32(lifeCycleState);
		_body.composeINT32(currentHandState);
		prize.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(handsTotal);
	_parser0.parseINT32(handsRemaining);
	_parser0.parseINT32(handsRequiredToForfeit);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT32(currentHandState);
	prize.parseMsg(_parser0);
}

const char *MiniGameClient::sidegame::PokerSideGameState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("timestamp", timestamp);
	_jsonstr.compose("handsTotal", handsTotal);
	_jsonstr.compose("handsRemaining", handsRemaining);
	_jsonstr.compose("handsRequiredToForfeit", handsRequiredToForfeit);
	_jsonstr.compose("lifeCycleState", lifeCycleState);
	_jsonstr.compose("currentHandState", currentHandState);
	_jsonstr.compose("prize", prize);
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideGameState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("timestamp", timestamp);
	_jparser.parseByNameThrow("handsTotal", handsTotal);
	_jparser.parseByNameThrow("handsRemaining", handsRemaining);
	_jparser.parseByNameThrow("handsRequiredToForfeit", handsRequiredToForfeit);
	_jparser.parseByNameThrow("lifeCycleState", lifeCycleState);
	_jparser.parseByNameThrow("currentHandState", currentHandState);
	_jparser.parseByNameThrow("prize", prize);
}

/* static */ void MiniGameClient::sidegame::PokerSideGameState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 timestamp; _jparser.validateByNameThrow("timestamp", timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 handsTotal; _jparser.validateByNameThrow("handsTotal", handsTotal);
	AtfValidator::validateInt(_descr, "handsTotal", handsTotal, _checker, __FILE__, __LINE__);
	INT32 handsRemaining; _jparser.validateByNameThrow("handsRemaining", handsRemaining);
	AtfValidator::validateInt(_descr, "handsRemaining", handsRemaining, _checker, __FILE__, __LINE__);
	INT32 handsRequiredToForfeit; _jparser.validateByNameThrow("handsRequiredToForfeit", handsRequiredToForfeit);
	AtfValidator::validateInt(_descr, "handsRequiredToForfeit", handsRequiredToForfeit, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _jparser.validateByNameThrow("lifeCycleState", lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 currentHandState; _jparser.validateByNameThrow("currentHandState", currentHandState);
	AtfValidator::validateInt(_descr, "currentHandState", currentHandState, _checker, __FILE__, __LINE__);
	MiniGamePrize prize; _jparser.validateByNameThrow("prize", prize);
}

/*static*/ void MiniGameClient::sidegame::PokerSideGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 handsTotal; _parser0.parseINT32(handsTotal);
	AtfValidator::validateInt(_descr, "handsTotal", handsTotal, _checker, __FILE__, __LINE__);
	INT32 handsRemaining; _parser0.parseINT32(handsRemaining);
	AtfValidator::validateInt(_descr, "handsRemaining", handsRemaining, _checker, __FILE__, __LINE__);
	INT32 handsRequiredToForfeit; _parser0.parseINT32(handsRequiredToForfeit);
	AtfValidator::validateInt(_descr, "handsRequiredToForfeit", handsRequiredToForfeit, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 currentHandState; _parser0.parseINT32(currentHandState);
	AtfValidator::validateInt(_descr, "currentHandState", currentHandState, _checker, __FILE__, __LINE__);
	PString _descbuf;
	MiniGamePrize::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CardMatchGameState
//=================================================================

MiniGameClient::sidegame::CardMatchGameState::CardMatchGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::CardMatchGameState::CardMatchGameState(CardMatchGameState&& _o)
	: cards(std::move(_o.cards))
	, timestamp(std::move(_o.timestamp))
	, handsTotal(std::move(_o.handsTotal))
	, handsRemaining(std::move(_o.handsRemaining))
	, handsRequiredToForfeit(std::move(_o.handsRequiredToForfeit))
	, lifeCycleState(std::move(_o.lifeCycleState))
	, currentHandState(std::move(_o.currentHandState))
	, prize(std::move(_o.prize))
{
}

MiniGameClient::sidegame::CardMatchGameState& MiniGameClient::sidegame::CardMatchGameState::operator=(CardMatchGameState&& _o)
{
	if(this != &_o)
	{
		cards = std::move(_o.cards);
		timestamp = std::move(_o.timestamp);
		handsTotal = std::move(_o.handsTotal);
		handsRemaining = std::move(_o.handsRemaining);
		handsRequiredToForfeit = std::move(_o.handsRequiredToForfeit);
		lifeCycleState = std::move(_o.lifeCycleState);
		currentHandState = std::move(_o.currentHandState);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::CardMatchGameState::clear()
{
	cards.clear();
	timestamp = 0;
	handsTotal = 0;
	handsRemaining = 0;
	handsRequiredToForfeit = 0;
	lifeCycleState = 0;
	currentHandState = 0;
	prize.clear();
}

bool MiniGameClient::sidegame::CardMatchGameState::equals(const CardMatchGameState& _o) const
{
	return cards.equals(_o.cards) &&
		timestamp == _o.timestamp &&
		handsTotal == _o.handsTotal &&
		handsRemaining == _o.handsRemaining &&
		handsRequiredToForfeit == _o.handsRequiredToForfeit &&
		lifeCycleState == _o.lifeCycleState &&
		currentHandState == _o.currentHandState &&
		prize.equals(_o.prize);
}

const char *MiniGameClient::sidegame::CardMatchGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("handsTotal=");
	_buf.appendInt(handsTotal);
	_buf.append(',');
	_buf.append("handsRemaining=");
	_buf.appendInt(handsRemaining);
	_buf.append(',');
	_buf.append("handsRequiredToForfeit=");
	_buf.appendInt(handsRequiredToForfeit);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("currentHandState=");
	_buf.appendInt(currentHandState);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::CardMatchGameState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	cards.toXmlString("cards", _buf);
	Atf::XmlElement::encodeAsXmlElement("timestamp", timestamp, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsTotal", handsTotal, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsRemaining", handsRemaining, _buf);
	Atf::XmlElement::encodeAsXmlElement("handsRequiredToForfeit", handsRequiredToForfeit, _buf);
	Atf::XmlElement::encodeAsXmlElement("lifeCycleState", lifeCycleState, _buf);
	Atf::XmlElement::encodeAsXmlElement("currentHandState", currentHandState, _buf);
	prize.toXmlString("prize", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::CardMatchGameState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("cards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< MCard , 4 > >::FromXmlString(_value, cards)) return false;
		}
		else if (_element.equals("timestamp"))
		{
			timestamp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsTotal"))
		{
			handsTotal = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsRemaining"))
		{
			handsRemaining = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handsRequiredToForfeit"))
		{
			handsRequiredToForfeit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lifeCycleState"))
		{
			lifeCycleState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currentHandState"))
		{
			currentHandState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prize"))
		{
			if(!Atf::AtfTempl< MiniGamePrize >::FromXmlString(_value, prize)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::CardMatchGameState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CardMatchGameState())) // not empty
	{
		cards.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(timestamp);
		_body.composeINT32(handsTotal);
		_body.composeINT32(handsRemaining);
		_body.composeINT32(handsRequiredToForfeit);
		_body.composeINT32(lifeCycleState);
		_body.composeINT32(currentHandState);
		prize.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::CardMatchGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	cards.parseMsg(_parser0);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(handsTotal);
	_parser0.parseINT32(handsRemaining);
	_parser0.parseINT32(handsRequiredToForfeit);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT32(currentHandState);
	prize.parseMsg(_parser0);
}

const char *MiniGameClient::sidegame::CardMatchGameState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cards", cards);
	_jsonstr.compose("timestamp", timestamp);
	_jsonstr.compose("handsTotal", handsTotal);
	_jsonstr.compose("handsRemaining", handsRemaining);
	_jsonstr.compose("handsRequiredToForfeit", handsRequiredToForfeit);
	_jsonstr.compose("lifeCycleState", lifeCycleState);
	_jsonstr.compose("currentHandState", currentHandState);
	_jsonstr.compose("prize", prize);
	return _buf.c_str();
}

void MiniGameClient::sidegame::CardMatchGameState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cards", cards);
	_jparser.parseByNameThrow("timestamp", timestamp);
	_jparser.parseByNameThrow("handsTotal", handsTotal);
	_jparser.parseByNameThrow("handsRemaining", handsRemaining);
	_jparser.parseByNameThrow("handsRequiredToForfeit", handsRequiredToForfeit);
	_jparser.parseByNameThrow("lifeCycleState", lifeCycleState);
	_jparser.parseByNameThrow("currentHandState", currentHandState);
	_jparser.parseByNameThrow("prize", prize);
}

/* static */ void MiniGameClient::sidegame::CardMatchGameState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< MCard > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
	INT32 timestamp; _jparser.validateByNameThrow("timestamp", timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 handsTotal; _jparser.validateByNameThrow("handsTotal", handsTotal);
	AtfValidator::validateInt(_descr, "handsTotal", handsTotal, _checker, __FILE__, __LINE__);
	INT32 handsRemaining; _jparser.validateByNameThrow("handsRemaining", handsRemaining);
	AtfValidator::validateInt(_descr, "handsRemaining", handsRemaining, _checker, __FILE__, __LINE__);
	INT32 handsRequiredToForfeit; _jparser.validateByNameThrow("handsRequiredToForfeit", handsRequiredToForfeit);
	AtfValidator::validateInt(_descr, "handsRequiredToForfeit", handsRequiredToForfeit, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _jparser.validateByNameThrow("lifeCycleState", lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 currentHandState; _jparser.validateByNameThrow("currentHandState", currentHandState);
	AtfValidator::validateInt(_descr, "currentHandState", currentHandState, _checker, __FILE__, __LINE__);
	MiniGamePrize prize; _jparser.validateByNameThrow("prize", prize);
}

/*static*/ void MiniGameClient::sidegame::CardMatchGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szCards = Atf::LAtfVector< MCard , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 handsTotal; _parser0.parseINT32(handsTotal);
	AtfValidator::validateInt(_descr, "handsTotal", handsTotal, _checker, __FILE__, __LINE__);
	INT32 handsRemaining; _parser0.parseINT32(handsRemaining);
	AtfValidator::validateInt(_descr, "handsRemaining", handsRemaining, _checker, __FILE__, __LINE__);
	INT32 handsRequiredToForfeit; _parser0.parseINT32(handsRequiredToForfeit);
	AtfValidator::validateInt(_descr, "handsRequiredToForfeit", handsRequiredToForfeit, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 currentHandState; _parser0.parseINT32(currentHandState);
	AtfValidator::validateInt(_descr, "currentHandState", currentHandState, _checker, __FILE__, __LINE__);
	MiniGamePrize::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    RandomDrawGameState
//=================================================================

MiniGameClient::sidegame::RandomDrawGameState::RandomDrawGameState()
{
	clear();
}

void MiniGameClient::sidegame::RandomDrawGameState::clear()
{
	timestamp = 0;
	lifeCycleState = 0;
	prizeIndex = 0;
	animationSeed = 0;
}

bool MiniGameClient::sidegame::RandomDrawGameState::equals(const RandomDrawGameState& _o) const
{
	return timestamp == _o.timestamp &&
		lifeCycleState == _o.lifeCycleState &&
		prizeIndex == _o.prizeIndex &&
		animationSeed == _o.animationSeed;
}

const char *MiniGameClient::sidegame::RandomDrawGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("prizeIndex=");
	_buf.appendInt(prizeIndex);
	_buf.append(',');
	_buf.append("animationSeed=");
	_buf.appendInt(animationSeed);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::RandomDrawGameState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("timestamp", timestamp, _buf);
	Atf::XmlElement::encodeAsXmlElement("lifeCycleState", lifeCycleState, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizeIndex", prizeIndex, _buf);
	Atf::XmlElement::encodeAsXmlElement("animationSeed", animationSeed, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::RandomDrawGameState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("timestamp"))
		{
			timestamp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lifeCycleState"))
		{
			lifeCycleState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizeIndex"))
		{
			prizeIndex = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("animationSeed"))
		{
			animationSeed = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::RandomDrawGameState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(RandomDrawGameState())) // not empty
	{
		_body.composeINT32(timestamp);
		_body.composeINT32(lifeCycleState);
		_body.composeINT32(prizeIndex);
		_body.composeINT32(animationSeed);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::RandomDrawGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT32(prizeIndex);
	_parser0.parseINT32(animationSeed);
}

const char *MiniGameClient::sidegame::RandomDrawGameState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("timestamp", timestamp);
	_jsonstr.compose("lifeCycleState", lifeCycleState);
	_jsonstr.compose("prizeIndex", prizeIndex);
	_jsonstr.compose("animationSeed", animationSeed);
	return _buf.c_str();
}

void MiniGameClient::sidegame::RandomDrawGameState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("timestamp", timestamp);
	_jparser.parseByNameThrow("lifeCycleState", lifeCycleState);
	_jparser.parseByNameThrow("prizeIndex", prizeIndex);
	_jparser.parseByNameThrow("animationSeed", animationSeed);
}

/* static */ void MiniGameClient::sidegame::RandomDrawGameState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 timestamp; _jparser.validateByNameThrow("timestamp", timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _jparser.validateByNameThrow("lifeCycleState", lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 prizeIndex; _jparser.validateByNameThrow("prizeIndex", prizeIndex);
	AtfValidator::validateInt(_descr, "prizeIndex", prizeIndex, _checker, __FILE__, __LINE__);
	INT32 animationSeed; _jparser.validateByNameThrow("animationSeed", animationSeed);
	AtfValidator::validateInt(_descr, "animationSeed", animationSeed, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::RandomDrawGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 prizeIndex; _parser0.parseINT32(prizeIndex);
	AtfValidator::validateInt(_descr, "prizeIndex", prizeIndex, _checker, __FILE__, __LINE__);
	INT32 animationSeed; _parser0.parseINT32(animationSeed);
	AtfValidator::validateInt(_descr, "animationSeed", animationSeed, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PickAnObjectGameState
//=================================================================

MiniGameClient::sidegame::PickAnObjectGameState::PickAnObjectGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PickAnObjectGameState::PickAnObjectGameState(PickAnObjectGameState&& _o)
	: timestamp(std::move(_o.timestamp))
	, lifeCycleState(std::move(_o.lifeCycleState))
	, animationSeed(std::move(_o.animationSeed))
	, prizeObjectIndices(std::move(_o.prizeObjectIndices))
	, prizeObjectPicked(std::move(_o.prizeObjectPicked))
{
}

MiniGameClient::sidegame::PickAnObjectGameState& MiniGameClient::sidegame::PickAnObjectGameState::operator=(PickAnObjectGameState&& _o)
{
	if(this != &_o)
	{
		timestamp = std::move(_o.timestamp);
		lifeCycleState = std::move(_o.lifeCycleState);
		animationSeed = std::move(_o.animationSeed);
		prizeObjectIndices = std::move(_o.prizeObjectIndices);
		prizeObjectPicked = std::move(_o.prizeObjectPicked);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PickAnObjectGameState::clear()
{
	timestamp = 0;
	lifeCycleState = 0;
	animationSeed = 0;
	prizeObjectIndices.clear();
	prizeObjectPicked = 0;
}

bool MiniGameClient::sidegame::PickAnObjectGameState::equals(const PickAnObjectGameState& _o) const
{
	return timestamp == _o.timestamp &&
		lifeCycleState == _o.lifeCycleState &&
		animationSeed == _o.animationSeed &&
		prizeObjectIndices.equals(_o.prizeObjectIndices) &&
		prizeObjectPicked == _o.prizeObjectPicked;
}

const char *MiniGameClient::sidegame::PickAnObjectGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("animationSeed=");
	_buf.appendInt(animationSeed);
	_buf.append(',');
	_buf.append("prizeObjectIndices=");
	prizeObjectIndices.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prizeObjectPicked=");
	_buf.appendInt(prizeObjectPicked);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::PickAnObjectGameState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("timestamp", timestamp, _buf);
	Atf::XmlElement::encodeAsXmlElement("lifeCycleState", lifeCycleState, _buf);
	Atf::XmlElement::encodeAsXmlElement("animationSeed", animationSeed, _buf);
	prizeObjectIndices.toXmlString("prizeObjectIndices", _buf);
	Atf::XmlElement::encodeAsXmlElement("prizeObjectPicked", prizeObjectPicked, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::PickAnObjectGameState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("timestamp"))
		{
			timestamp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lifeCycleState"))
		{
			lifeCycleState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("animationSeed"))
		{
			animationSeed = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizeObjectIndices"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT32, 4 > >::FromXmlString(_value, prizeObjectIndices)) return false;
		}
		else if (_element.equals("prizeObjectPicked"))
		{
			prizeObjectPicked = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::PickAnObjectGameState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PickAnObjectGameState())) // not empty
	{
		_body.composeINT32(timestamp);
		_body.composeINT32(lifeCycleState);
		_body.composeINT32(animationSeed);
		prizeObjectIndices.composeMsg(_body, _ignoreJSON);
		_body.composeINT8(prizeObjectPicked);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PickAnObjectGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT32(animationSeed);
	prizeObjectIndices.parseMsg(_parser0);
	_parser0.parseINT8(prizeObjectPicked);
}

const char *MiniGameClient::sidegame::PickAnObjectGameState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("timestamp", timestamp);
	_jsonstr.compose("lifeCycleState", lifeCycleState);
	_jsonstr.compose("animationSeed", animationSeed);
	_jsonstr.compose("prizeObjectIndices", prizeObjectIndices);
	_jsonstr.compose("prizeObjectPicked", prizeObjectPicked);
	return _buf.c_str();
}

void MiniGameClient::sidegame::PickAnObjectGameState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("timestamp", timestamp);
	_jparser.parseByNameThrow("lifeCycleState", lifeCycleState);
	_jparser.parseByNameThrow("animationSeed", animationSeed);
	_jparser.parseByNameThrow("prizeObjectIndices", prizeObjectIndices);
	_jparser.parseByNameThrow("prizeObjectPicked", prizeObjectPicked);
}

/* static */ void MiniGameClient::sidegame::PickAnObjectGameState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 timestamp; _jparser.validateByNameThrow("timestamp", timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _jparser.validateByNameThrow("lifeCycleState", lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 animationSeed; _jparser.validateByNameThrow("animationSeed", animationSeed);
	AtfValidator::validateInt(_descr, "animationSeed", animationSeed, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT32 > prizeObjectIndices; _jparser.validateByNameThrow("prizeObjectIndices", prizeObjectIndices);
	AtfValidator::validateInt(_descr, "prizeObjectIndices", prizeObjectIndices.size(), _checker, __FILE__, __LINE__);
	INT8 prizeObjectPicked; _jparser.validateByNameThrow("prizeObjectPicked", prizeObjectPicked);
	AtfValidator::validateInt(_descr, "prizeObjectPicked", prizeObjectPicked, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::PickAnObjectGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT32 animationSeed; _parser0.parseINT32(animationSeed);
	AtfValidator::validateInt(_descr, "animationSeed", animationSeed, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizeObjectIndices = Atf::LAtfVector< INT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizeObjectIndices"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizeObjectIndices", szPrizeObjectIndices, _checker, __FILE__, __LINE__);
	INT8 prizeObjectPicked; _parser0.parseINT8(prizeObjectPicked);
	AtfValidator::validateInt(_descr, "prizeObjectPicked", prizeObjectPicked, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ChestGameState
//=================================================================

MiniGameClient::sidegame::ChestGameState::ChestGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::ChestGameState::ChestGameState(ChestGameState&& _o)
	: lifeCycleState(std::move(_o.lifeCycleState))
	, prizes(std::move(_o.prizes))
	, animationLevel(std::move(_o.animationLevel))
	, cvlBarUpdates(std::move(_o.cvlBarUpdates))
	, cvlConfigParams(std::move(_o.cvlConfigParams))
{
}

MiniGameClient::sidegame::ChestGameState& MiniGameClient::sidegame::ChestGameState::operator=(ChestGameState&& _o)
{
	if(this != &_o)
	{
		lifeCycleState = std::move(_o.lifeCycleState);
		prizes = std::move(_o.prizes);
		animationLevel = std::move(_o.animationLevel);
		cvlBarUpdates = std::move(_o.cvlBarUpdates);
		cvlConfigParams = std::move(_o.cvlConfigParams);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::ChestGameState::clear()
{
	lifeCycleState = 0;
	prizes.clear();
	animationLevel = 0;
	cvlBarUpdates.clear();
	cvlConfigParams.clear();
}

bool MiniGameClient::sidegame::ChestGameState::equals(const ChestGameState& _o) const
{
	return lifeCycleState == _o.lifeCycleState &&
		prizes.equals(_o.prizes) &&
		animationLevel == _o.animationLevel &&
		cvlBarUpdates.equals(_o.cvlBarUpdates) &&
		cvlConfigParams.equals(_o.cvlConfigParams);
}

const char *MiniGameClient::sidegame::ChestGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("prizes=");
	prizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("animationLevel=");
	_buf.appendInt(animationLevel);
	_buf.append(',');
	_buf.append("cvlBarUpdates=");
	cvlBarUpdates.toTraceString(_buf);
	_buf.append(',');
	_buf.append("cvlConfigParams=");
	cvlConfigParams.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::ChestGameState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("lifeCycleState", lifeCycleState, _buf);
	prizes.toXmlString("prizes", _buf);
	Atf::XmlElement::encodeAsXmlElement("animationLevel", animationLevel, _buf);
	cvlBarUpdates.toXmlString("cvlBarUpdates", _buf);
	cvlConfigParams.toXmlString("cvlConfigParams", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::ChestGameState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("lifeCycleState"))
		{
			lifeCycleState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< MiniGamePrizeLocalized, 4 > >::FromXmlString(_value, prizes)) return false;
		}
		else if (_element.equals("animationLevel"))
		{
			animationLevel = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cvlBarUpdates"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CvlClientUserBarNotification, 4 > >::FromXmlString(_value, cvlBarUpdates)) return false;
		}
		else if (_element.equals("cvlConfigParams"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< CvlConfigParams, 4 > >::FromXmlString(_value, cvlConfigParams)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::ChestGameState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ChestGameState())) // not empty
	{
		_body.composeINT32(lifeCycleState);
		prizes.composeMsg(_body, _ignoreJSON);
		_body.composeINT32(animationLevel);
		cvlBarUpdates.composeMsg(_body, _ignoreJSON);
		cvlConfigParams.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::ChestGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(lifeCycleState);
	prizes.parseMsg(_parser0);
	_parser0.parseINT32(animationLevel);
	cvlBarUpdates.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	cvlConfigParams.parseMsg(_parser0);
}

const char *MiniGameClient::sidegame::ChestGameState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("lifeCycleState", lifeCycleState);
	_jsonstr.compose("prizes", prizes);
	_jsonstr.compose("animationLevel", animationLevel);
	_jsonstr.compose("cvlBarUpdates", cvlBarUpdates);
	_jsonstr.compose("cvlConfigParams", cvlConfigParams);
	return _buf.c_str();
}

void MiniGameClient::sidegame::ChestGameState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("lifeCycleState", lifeCycleState);
	_jparser.parseByNameThrow("prizes", prizes);
	_jparser.parseByNameThrow("animationLevel", animationLevel);
	_jparser.parseByNameThrow("cvlBarUpdates", cvlBarUpdates);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cvlConfigParams", cvlConfigParams);
}

/* static */ void MiniGameClient::sidegame::ChestGameState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 lifeCycleState; _jparser.validateByNameThrow("lifeCycleState", lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< MiniGamePrizeLocalized > prizes; _jparser.validateByNameThrow("prizes", prizes);
	AtfValidator::validateInt(_descr, "prizes", prizes.size(), _checker, __FILE__, __LINE__);
	INT32 animationLevel; _jparser.validateByNameThrow("animationLevel", animationLevel);
	AtfValidator::validateInt(_descr, "animationLevel", animationLevel, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< CvlClientUserBarNotification > cvlBarUpdates; _jparser.validateByNameThrow("cvlBarUpdates", cvlBarUpdates);
	AtfValidator::validateInt(_descr, "cvlBarUpdates", cvlBarUpdates.size(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< CvlConfigParams > cvlConfigParams; _jparser.validateByNameThrow("cvlConfigParams", cvlConfigParams);
	AtfValidator::validateInt(_descr, "cvlConfigParams", cvlConfigParams.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::ChestGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPrizes = Atf::LAtfVector< MiniGamePrizeLocalized, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "prizes", szPrizes, _checker, __FILE__, __LINE__);
	INT32 animationLevel; _parser0.parseINT32(animationLevel);
	AtfValidator::validateInt(_descr, "animationLevel", animationLevel, _checker, __FILE__, __LINE__);
	int szCvlBarUpdates = Atf::LAtfVector< CvlClientUserBarNotification, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cvlBarUpdates"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cvlBarUpdates", szCvlBarUpdates, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	int szCvlConfigParams = Atf::LAtfVector< CvlConfigParams, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cvlConfigParams"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cvlConfigParams", szCvlConfigParams, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SuitRacePlayerProgress
//=================================================================

MiniGameClient::sidegame::SuitRacePlayerProgress::SuitRacePlayerProgress()
{
	clear();
}

void MiniGameClient::sidegame::SuitRacePlayerProgress::clear()
{
	suit = 0;
	progress = 0;
	lastProgressType = 0;
}

bool MiniGameClient::sidegame::SuitRacePlayerProgress::equals(const SuitRacePlayerProgress& _o) const
{
	return suit == _o.suit &&
		progress == _o.progress &&
		lastProgressType == _o.lastProgressType;
}

const char *MiniGameClient::sidegame::SuitRacePlayerProgress::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("suit=");
	_buf.appendUint(suit);
	_buf.append(',');
	_buf.append("progress=");
	_buf.appendInt(progress);
	_buf.append(',');
	_buf.append("lastProgressType=");
	_buf.appendInt(lastProgressType);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::SuitRacePlayerProgress::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("suit", suit, _buf);
	Atf::XmlElement::encodeAsXmlElement("progress", progress, _buf);
	Atf::XmlElement::encodeAsXmlElement("lastProgressType", lastProgressType, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::SuitRacePlayerProgress::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("suit"))
		{
			suit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("progress"))
		{
			progress = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lastProgressType"))
		{
			lastProgressType = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::SuitRacePlayerProgress::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SuitRacePlayerProgress())) // not empty
	{
		_body.composeBYTE(suit);
		_body.composeINT32(progress);
		_body.composeINT8(lastProgressType);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SuitRacePlayerProgress::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(suit);
	_parser0.parseINT32(progress);
	_parser0.parseINT8(lastProgressType);
}

const char *MiniGameClient::sidegame::SuitRacePlayerProgress::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("suit", suit);
	_jsonstr.compose("progress", progress);
	_jsonstr.compose("lastProgressType", lastProgressType);
	return _buf.c_str();
}

void MiniGameClient::sidegame::SuitRacePlayerProgress::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("suit", suit);
	_jparser.parseByNameThrow("progress", progress);
	_jparser.parseByNameThrow("lastProgressType", lastProgressType);
}

/* static */ void MiniGameClient::sidegame::SuitRacePlayerProgress::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE suit; _jparser.validateByNameThrow("suit", suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	INT32 progress; _jparser.validateByNameThrow("progress", progress);
	AtfValidator::validateInt(_descr, "progress", progress, _checker, __FILE__, __LINE__);
	INT8 lastProgressType; _jparser.validateByNameThrow("lastProgressType", lastProgressType);
	AtfValidator::validateInt(_descr, "lastProgressType", lastProgressType, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::SuitRacePlayerProgress::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE suit; _parser0.parseBYTE(suit);
	AtfValidator::validateInt(_descr, "suit", suit, _checker, __FILE__, __LINE__);
	INT32 progress; _parser0.parseINT32(progress);
	AtfValidator::validateInt(_descr, "progress", progress, _checker, __FILE__, __LINE__);
	INT8 lastProgressType; _parser0.parseINT8(lastProgressType);
	AtfValidator::validateInt(_descr, "lastProgressType", lastProgressType, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SuitRaceGameState
//=================================================================

MiniGameClient::sidegame::SuitRaceGameState::SuitRaceGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::SuitRaceGameState::SuitRaceGameState(SuitRaceGameState&& _o)
	: playerProgress(std::move(_o.playerProgress))
	, chosenSuit(std::move(_o.chosenSuit))
	, totalProgressRequired(std::move(_o.totalProgressRequired))
	, sideGameState(std::move(_o.sideGameState))
{
}

MiniGameClient::sidegame::SuitRaceGameState& MiniGameClient::sidegame::SuitRaceGameState::operator=(SuitRaceGameState&& _o)
{
	if(this != &_o)
	{
		playerProgress = std::move(_o.playerProgress);
		chosenSuit = std::move(_o.chosenSuit);
		totalProgressRequired = std::move(_o.totalProgressRequired);
		sideGameState = std::move(_o.sideGameState);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::SuitRaceGameState::clear()
{
	playerProgress.clear();
	chosenSuit = 0;
	totalProgressRequired = 0;
	sideGameState.clear();
}

bool MiniGameClient::sidegame::SuitRaceGameState::equals(const SuitRaceGameState& _o) const
{
	return playerProgress.equals(_o.playerProgress) &&
		chosenSuit == _o.chosenSuit &&
		totalProgressRequired == _o.totalProgressRequired &&
		sideGameState.equals(_o.sideGameState);
}

const char *MiniGameClient::sidegame::SuitRaceGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("playerProgress=");
	playerProgress.toTraceString(_buf);
	_buf.append(',');
	_buf.append("chosenSuit=");
	_buf.appendUint(chosenSuit);
	_buf.append(',');
	_buf.append("totalProgressRequired=");
	_buf.appendInt(totalProgressRequired);
	_buf.append(',');
	_buf.append("sideGameState=");
	sideGameState.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::SuitRaceGameState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	playerProgress.toXmlString("playerProgress", _buf);
	Atf::XmlElement::encodeAsXmlElement("chosenSuit", chosenSuit, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalProgressRequired", totalProgressRequired, _buf);
	sideGameState.toXmlString("sideGameState", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::SuitRaceGameState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("playerProgress"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SuitRacePlayerProgress , 4 > >::FromXmlString(_value, playerProgress)) return false;
		}
		else if (_element.equals("chosenSuit"))
		{
			chosenSuit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalProgressRequired"))
		{
			totalProgressRequired = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sideGameState"))
		{
			if(!Atf::AtfTempl< PokerSideGameState >::FromXmlString(_value, sideGameState)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::SuitRaceGameState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SuitRaceGameState())) // not empty
	{
		playerProgress.composeMsg(_body, _ignoreJSON);
		_body.composeBYTE(chosenSuit);
		_body.composeINT32(totalProgressRequired);
		sideGameState.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SuitRaceGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	playerProgress.parseMsg(_parser0);
	_parser0.parseBYTE(chosenSuit);
	_parser0.parseINT32(totalProgressRequired);
	sideGameState.parseMsg(_parser0);
}

const char *MiniGameClient::sidegame::SuitRaceGameState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("playerProgress", playerProgress);
	_jsonstr.compose("chosenSuit", chosenSuit);
	_jsonstr.compose("totalProgressRequired", totalProgressRequired);
	_jsonstr.compose("sideGameState", sideGameState);
	return _buf.c_str();
}

void MiniGameClient::sidegame::SuitRaceGameState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("playerProgress", playerProgress);
	_jparser.parseByNameThrow("chosenSuit", chosenSuit);
	_jparser.parseByNameThrow("totalProgressRequired", totalProgressRequired);
	_jparser.parseByNameThrow("sideGameState", sideGameState);
}

/* static */ void MiniGameClient::sidegame::SuitRaceGameState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< SuitRacePlayerProgress > playerProgress; _jparser.validateByNameThrow("playerProgress", playerProgress);
	AtfValidator::validateInt(_descr, "playerProgress", playerProgress.size(), _checker, __FILE__, __LINE__);
	BYTE chosenSuit; _jparser.validateByNameThrow("chosenSuit", chosenSuit);
	AtfValidator::validateInt(_descr, "chosenSuit", chosenSuit, _checker, __FILE__, __LINE__);
	INT32 totalProgressRequired; _jparser.validateByNameThrow("totalProgressRequired", totalProgressRequired);
	AtfValidator::validateInt(_descr, "totalProgressRequired", totalProgressRequired, _checker, __FILE__, __LINE__);
	PokerSideGameState sideGameState; _jparser.validateByNameThrow("sideGameState", sideGameState);
}

/*static*/ void MiniGameClient::sidegame::SuitRaceGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szPlayerProgress = Atf::LAtfVector< SuitRacePlayerProgress , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("playerProgress"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "playerProgress", szPlayerProgress, _checker, __FILE__, __LINE__);
	BYTE chosenSuit; _parser0.parseBYTE(chosenSuit);
	AtfValidator::validateInt(_descr, "chosenSuit", chosenSuit, _checker, __FILE__, __LINE__);
	INT32 totalProgressRequired; _parser0.parseINT32(totalProgressRequired);
	AtfValidator::validateInt(_descr, "totalProgressRequired", totalProgressRequired, _checker, __FILE__, __LINE__);
	PokerSideGameState::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sideGameState"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SideGameState
//=================================================================

MiniGameClient::sidegame::SideGameState::SideGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::SideGameState::SideGameState(SideGameState&& _o)
	: minigamePlayId(std::move(_o.minigamePlayId))
	, minigameId(std::move(_o.minigameId))
	, gameType(std::move(_o.gameType))
	, gameId(std::move(_o.gameId))
	, entryId(std::move(_o.entryId))
	, stateMsgBody(std::move(_o.stateMsgBody))
	, ringSessionId(std::move(_o.ringSessionId))
	, subGameId(std::move(_o.subGameId))
{
}

MiniGameClient::sidegame::SideGameState& MiniGameClient::sidegame::SideGameState::operator=(SideGameState&& _o)
{
	if(this != &_o)
	{
		minigamePlayId = std::move(_o.minigamePlayId);
		minigameId = std::move(_o.minigameId);
		gameType = std::move(_o.gameType);
		gameId = std::move(_o.gameId);
		entryId = std::move(_o.entryId);
		stateMsgBody = std::move(_o.stateMsgBody);
		ringSessionId = std::move(_o.ringSessionId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::SideGameState::clear()
{
	minigamePlayId = 0;
	minigameId = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	stateMsgBody.clear();
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::SideGameState::equals(const SideGameState& _o) const
{
	return minigamePlayId == _o.minigamePlayId &&
		minigameId == _o.minigameId &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		stateMsgBody.equals(_o.stateMsgBody) &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

const char *MiniGameClient::sidegame::SideGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("stateMsgBody=");
	stateMsgBody.toTraceString(_buf);
	_buf.append(',');
	_buf.append("ringSessionId=");
	_buf.appendUint64(ringSessionId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::SideGameState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minigamePlayId", minigamePlayId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	stateMsgBody.toXmlString("stateMsgBody", _buf);
	Atf::XmlElement::encodeAsXmlElement("ringSessionId", ringSessionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("subGameId", subGameId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::SideGameState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minigamePlayId"))
		{
			minigamePlayId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minigameId"))
		{
			minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameType"))
		{
			gameType = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameId"))
		{
			gameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entryId"))
		{
			entryId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stateMsgBody"))
		{
			if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, stateMsgBody)) return false;
		}
		else if (_element.equals("ringSessionId"))
		{
			ringSessionId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("subGameId"))
		{
			subGameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::SideGameState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SideGameState())) // not empty
	{
		_body.composeUINT64(minigamePlayId);
		_body.composeUINT32(minigameId);
		_body.composeINT8(gameType);
		_body.composeUINT64(gameId);
		_body.composeUINT32(entryId);
		stateMsgBody.composeMsg(_body, _ignoreJSON);
		_body.composeUINT64(ringSessionId);
		_body.composeUINT64(subGameId);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SideGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(minigamePlayId);
	_parser0.parseUINT32(minigameId);
	_parser0.parseINT8(gameType);
	_parser0.parseUINT64(gameId);
	_parser0.parseUINT32(entryId);
	stateMsgBody.parseMsg(_parser0);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(ringSessionId);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(subGameId);
}

const char *MiniGameClient::sidegame::SideGameState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minigamePlayId", minigamePlayId);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("stateMsgBody", stateMsgBody);
	_jsonstr.compose("ringSessionId", ringSessionId);
	_jsonstr.compose("subGameId", subGameId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::SideGameState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minigamePlayId", minigamePlayId);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("stateMsgBody", stateMsgBody);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("ringSessionId", ringSessionId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("subGameId", subGameId);
}

/* static */ void MiniGameClient::sidegame::SideGameState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 minigamePlayId; _jparser.validateByNameThrow("minigamePlayId", minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	Atf::MsgBodyWithJSON stateMsgBody; _jparser.validateByNameThrow("stateMsgBody", stateMsgBody);
	AtfValidator::validateInt(_descr, "stateMsgBody", stateMsgBody.jsonLengthOrMsgBodySize(), _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 ringSessionId; _jparser.validateByNameThrow("ringSessionId", ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 subGameId; _jparser.validateByNameThrow("subGameId", subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::SideGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 minigamePlayId; _parser0.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _parser0.parseINT8(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	Atf::MsgBodyWithJSON stateMsgBody; stateMsgBody.parseMsg(_parser0);
	AtfValidator::validateInt(_descr, "stateMsgBody", stateMsgBody.jsonLengthOrMsgBodySize(), _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT64 ringSessionId; _parser0.parseUINT64(ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT64 subGameId; _parser0.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MaxGamesReachedEntry
//=================================================================

MiniGameClient::sidegame::MaxGamesReachedEntry::MaxGamesReachedEntry()
{
	clear();
}

void MiniGameClient::sidegame::MaxGamesReachedEntry::clear()
{
	minigameId = 0;
	expirationTime = 0;
}

bool MiniGameClient::sidegame::MaxGamesReachedEntry::equals(const MaxGamesReachedEntry& _o) const
{
	return minigameId == _o.minigameId &&
		expirationTime == _o.expirationTime;
}

const char *MiniGameClient::sidegame::MaxGamesReachedEntry::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("expirationTime=");
	_buf.appendInt(expirationTime);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::MaxGamesReachedEntry::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("expirationTime", expirationTime, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::MaxGamesReachedEntry::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minigameId"))
		{
			minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("expirationTime"))
		{
			expirationTime = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::MaxGamesReachedEntry::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MaxGamesReachedEntry())) // not empty
	{
		_body.composeUINT32(minigameId);
		_body.composeINT32(expirationTime);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::MaxGamesReachedEntry::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(minigameId);
	_parser0.parseINT32(expirationTime);
}

const char *MiniGameClient::sidegame::MaxGamesReachedEntry::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("expirationTime", expirationTime);
	return _buf.c_str();
}

void MiniGameClient::sidegame::MaxGamesReachedEntry::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("expirationTime", expirationTime);
}

/* static */ void MiniGameClient::sidegame::MaxGamesReachedEntry::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT32 expirationTime; _jparser.validateByNameThrow("expirationTime", expirationTime);
	AtfValidator::validateInt(_descr, "expirationTime", expirationTime, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::MaxGamesReachedEntry::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT32 expirationTime; _parser0.parseINT32(expirationTime);
	AtfValidator::validateInt(_descr, "expirationTime", expirationTime, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    GameTicketState
//=================================================================

MiniGameClient::sidegame::GameTicketState::GameTicketState()
{
	clear();
}

void MiniGameClient::sidegame::GameTicketState::clear()
{
	gameTicketId = 0;
	playsRemaining = 0;
}

bool MiniGameClient::sidegame::GameTicketState::equals(const GameTicketState& _o) const
{
	return gameTicketId == _o.gameTicketId &&
		playsRemaining == _o.playsRemaining;
}

const char *MiniGameClient::sidegame::GameTicketState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	_buf.append(',');
	_buf.append("playsRemaining=");
	_buf.appendInt(playsRemaining);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::GameTicketState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("gameTicketId", gameTicketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("playsRemaining", playsRemaining, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::GameTicketState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("gameTicketId"))
		{
			gameTicketId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playsRemaining"))
		{
			playsRemaining = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::GameTicketState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(GameTicketState())) // not empty
	{
		_body.composeUINT64(gameTicketId);
		_body.composeINT32(playsRemaining);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::GameTicketState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(gameTicketId);
	_parser0.parseINT32(playsRemaining);
}

const char *MiniGameClient::sidegame::GameTicketState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameTicketId", gameTicketId);
	_jsonstr.compose("playsRemaining", playsRemaining);
	return _buf.c_str();
}

void MiniGameClient::sidegame::GameTicketState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameTicketId", gameTicketId);
	_jparser.parseByNameThrow("playsRemaining", playsRemaining);
}

/* static */ void MiniGameClient::sidegame::GameTicketState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT64 gameTicketId; _jparser.validateByNameThrow("gameTicketId", gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	INT32 playsRemaining; _jparser.validateByNameThrow("playsRemaining", playsRemaining);
	AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::GameTicketState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 gameTicketId; _parser0.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	INT32 playsRemaining; _parser0.parseINT32(playsRemaining);
	AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetResultPayout
//=================================================================

MiniGameClient::sidegame::PokerSideBetResultPayout::PokerSideBetResultPayout()
{
	clear();
}

void MiniGameClient::sidegame::PokerSideBetResultPayout::clear()
{
	betResult = 0;
	payoutMultiplier = 0;
}

bool MiniGameClient::sidegame::PokerSideBetResultPayout::equals(const PokerSideBetResultPayout& _o) const
{
	return betResult == _o.betResult &&
		payoutMultiplier == _o.payoutMultiplier;
}

const char *MiniGameClient::sidegame::PokerSideBetResultPayout::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("betResult=");
	_buf.appendInt(betResult);
	_buf.append(',');
	_buf.append("payoutMultiplier=");
	_buf.appendInt(payoutMultiplier);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::PokerSideBetResultPayout::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("betResult", betResult, _buf);
	Atf::XmlElement::encodeAsXmlElement("payoutMultiplier", payoutMultiplier, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::PokerSideBetResultPayout::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("betResult"))
		{
			betResult = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("payoutMultiplier"))
		{
			payoutMultiplier = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::PokerSideBetResultPayout::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetResultPayout())) // not empty
	{
		_body.composeINT16(betResult);
		_body.composeINT32(payoutMultiplier);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetResultPayout::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(betResult);
	_parser0.parseINT32(payoutMultiplier);
}

const char *MiniGameClient::sidegame::PokerSideBetResultPayout::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("betResult", betResult);
	_jsonstr.compose("payoutMultiplier", payoutMultiplier);
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetResultPayout::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("betResult", betResult);
	_jparser.parseByNameThrow("payoutMultiplier", payoutMultiplier);
}

/* static */ void MiniGameClient::sidegame::PokerSideBetResultPayout::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 betResult; _jparser.validateByNameThrow("betResult", betResult);
	AtfValidator::validateInt(_descr, "betResult", betResult, _checker, __FILE__, __LINE__);
	INT32 payoutMultiplier; _jparser.validateByNameThrow("payoutMultiplier", payoutMultiplier);
	AtfValidator::validateInt(_descr, "payoutMultiplier", payoutMultiplier, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetResultPayout::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT16 betResult; _parser0.parseINT16(betResult);
	AtfValidator::validateInt(_descr, "betResult", betResult, _checker, __FILE__, __LINE__);
	INT32 payoutMultiplier; _parser0.parseINT32(payoutMultiplier);
	AtfValidator::validateInt(_descr, "payoutMultiplier", payoutMultiplier, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetAvailableBet
//=================================================================

MiniGameClient::sidegame::PokerSideBetAvailableBet::PokerSideBetAvailableBet()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PokerSideBetAvailableBet::PokerSideBetAvailableBet(PokerSideBetAvailableBet&& _o)
	: betType(std::move(_o.betType))
	, betName(std::move(_o.betName))
	, betDescription(std::move(_o.betDescription))
	, oddsTable(std::move(_o.oddsTable))
	, availabilityflags(std::move(_o.availabilityflags))
{
}

MiniGameClient::sidegame::PokerSideBetAvailableBet& MiniGameClient::sidegame::PokerSideBetAvailableBet::operator=(PokerSideBetAvailableBet&& _o)
{
	if(this != &_o)
	{
		betType = std::move(_o.betType);
		betName = std::move(_o.betName);
		betDescription = std::move(_o.betDescription);
		oddsTable = std::move(_o.oddsTable);
		availabilityflags = std::move(_o.availabilityflags);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PokerSideBetAvailableBet::clear()
{
	betType = 0;
	betName.clear();
	betDescription.clear();
	oddsTable.clear();
	availabilityflags = 0;
}

bool MiniGameClient::sidegame::PokerSideBetAvailableBet::equals(const PokerSideBetAvailableBet& _o) const
{
	return betType == _o.betType &&
		Atf::atfPStringEquals(betName, _o.betName) &&
		Atf::atfPStringEquals(betDescription, _o.betDescription) &&
		oddsTable.equals(_o.oddsTable) &&
		availabilityflags == _o.availabilityflags;
}

const char *MiniGameClient::sidegame::PokerSideBetAvailableBet::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("betType=");
	_buf.appendInt(betType);
	_buf.append(',');
	_buf.append("betName=");
	_buf.append(betName);
	_buf.append(',');
	_buf.append("betDescription=");
	_buf.append(betDescription);
	_buf.append(',');
	_buf.append("oddsTable=");
	oddsTable.toTraceString(_buf);
	_buf.append(',');
	_buf.append("availabilityflags=");
	_buf.appendUint(availabilityflags);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::PokerSideBetAvailableBet::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("betType", betType, _buf);
	Atf::XmlElement::encodeAsXmlElement("betName", betName, _buf);
	Atf::XmlElement::encodeAsXmlElement("betDescription", betDescription, _buf);
	oddsTable.toXmlString("oddsTable", _buf);
	Atf::XmlElement::encodeAsXmlElement("availabilityflags", availabilityflags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::PokerSideBetAvailableBet::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("betType"))
		{
			betType = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("betName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, betName)) return false;
		}
		else if (_element.equals("betDescription"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, betDescription)) return false;
		}
		else if (_element.equals("oddsTable"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PokerSideBetResultPayout, 4 > >::FromXmlString(_value, oddsTable)) return false;
		}
		else if (_element.equals("availabilityflags"))
		{
			availabilityflags = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::PokerSideBetAvailableBet::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetAvailableBet())) // not empty
	{
		_body.composeINT16(betType);
		_body.composeString(betName);
		_body.composeString(betDescription);
		oddsTable.composeMsg(_body, _ignoreJSON);
		_body.composeBYTE(availabilityflags);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetAvailableBet::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(betType);
	_parser0.parseStringP(betName);
	_parser0.parseStringP(betDescription);
	oddsTable.parseMsg(_parser0);
	_parser0.parseBYTE(availabilityflags);
}

const char *MiniGameClient::sidegame::PokerSideBetAvailableBet::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("betType", betType);
	_jsonstr.compose("betName", betName);
	_jsonstr.compose("betDescription", betDescription);
	_jsonstr.compose("oddsTable", oddsTable);
	_jsonstr.compose("availabilityflags", availabilityflags);
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetAvailableBet::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("betType", betType);
	_jparser.parseByNameThrow("betName", betName);
	_jparser.parseByNameThrow("betDescription", betDescription);
	_jparser.parseByNameThrow("oddsTable", oddsTable);
	_jparser.parseByNameThrow("availabilityflags", availabilityflags);
}

/* static */ void MiniGameClient::sidegame::PokerSideBetAvailableBet::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 betType; _jparser.validateByNameThrow("betType", betType);
	AtfValidator::validateInt(_descr, "betType", betType, _checker, __FILE__, __LINE__);
	PString betName; _jparser.validateByNameThrow("betName", betName);
	AtfValidator::validateInt(_descr, "betName", betName.length(), _checker, __FILE__, __LINE__);
	PString betDescription; _jparser.validateByNameThrow("betDescription", betDescription);
	AtfValidator::validateInt(_descr, "betDescription", betDescription.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< PokerSideBetResultPayout > oddsTable; _jparser.validateByNameThrow("oddsTable", oddsTable);
	AtfValidator::validateInt(_descr, "oddsTable", oddsTable.size(), _checker, __FILE__, __LINE__);
	BYTE availabilityflags; _jparser.validateByNameThrow("availabilityflags", availabilityflags);
	AtfValidator::validateInt(_descr, "availabilityflags", availabilityflags, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetAvailableBet::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT16 betType; _parser0.parseINT16(betType);
	AtfValidator::validateInt(_descr, "betType", betType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "betName"); size_t szBetName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "betName", szBetName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "betDescription"); size_t szBetDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "betDescription", szBetDescription, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szOddsTable = Atf::LAtfVector< PokerSideBetResultPayout, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("oddsTable"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "oddsTable", szOddsTable, _checker, __FILE__, __LINE__);
	BYTE availabilityflags; _parser0.parseBYTE(availabilityflags);
	AtfValidator::validateInt(_descr, "availabilityflags", availabilityflags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetGameDefBody
//=================================================================

MiniGameClient::sidegame::PokerSideBetGameDefBody::PokerSideBetGameDefBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PokerSideBetGameDefBody::PokerSideBetGameDefBody(PokerSideBetGameDefBody&& _o)
	: availableBets(std::move(_o.availableBets))
	, allowedBetAmounts(std::move(_o.allowedBetAmounts))
	, allowedNumberOfAutoBets(std::move(_o.allowedNumberOfAutoBets))
	, allowedBetIncrements(std::move(_o.allowedBetIncrements))
	, maxBuyIn(std::move(_o.maxBuyIn))
{
}

MiniGameClient::sidegame::PokerSideBetGameDefBody& MiniGameClient::sidegame::PokerSideBetGameDefBody::operator=(PokerSideBetGameDefBody&& _o)
{
	if(this != &_o)
	{
		availableBets = std::move(_o.availableBets);
		allowedBetAmounts = std::move(_o.allowedBetAmounts);
		allowedNumberOfAutoBets = std::move(_o.allowedNumberOfAutoBets);
		allowedBetIncrements = std::move(_o.allowedBetIncrements);
		maxBuyIn = std::move(_o.maxBuyIn);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PokerSideBetGameDefBody::clear()
{
	availableBets.clear();
	allowedBetAmounts.clear();
	allowedNumberOfAutoBets.clear();
	allowedBetIncrements.clear();
	maxBuyIn = 0;
}

bool MiniGameClient::sidegame::PokerSideBetGameDefBody::equals(const PokerSideBetGameDefBody& _o) const
{
	return availableBets.equals(_o.availableBets) &&
		allowedBetAmounts.equals(_o.allowedBetAmounts) &&
		allowedNumberOfAutoBets.equals(_o.allowedNumberOfAutoBets) &&
		allowedBetIncrements.equals(_o.allowedBetIncrements) &&
		maxBuyIn == _o.maxBuyIn;
}

const char *MiniGameClient::sidegame::PokerSideBetGameDefBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("availableBets=");
	availableBets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("allowedBetAmounts=");
	allowedBetAmounts.toTraceString(_buf);
	_buf.append(',');
	_buf.append("allowedNumberOfAutoBets=");
	allowedNumberOfAutoBets.toTraceString(_buf);
	_buf.append(',');
	_buf.append("allowedBetIncrements=");
	allowedBetIncrements.toTraceString(_buf);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendInt64(maxBuyIn);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::PokerSideBetGameDefBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	availableBets.toXmlString("availableBets", _buf);
	allowedBetAmounts.toXmlString("allowedBetAmounts", _buf);
	allowedNumberOfAutoBets.toXmlString("allowedNumberOfAutoBets", _buf);
	allowedBetIncrements.toXmlString("allowedBetIncrements", _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::PokerSideBetGameDefBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("availableBets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< PokerSideBetAvailableBet, 4 > >::FromXmlString(_value, availableBets)) return false;
		}
		else if (_element.equals("allowedBetAmounts"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, allowedBetAmounts)) return false;
		}
		else if (_element.equals("allowedNumberOfAutoBets"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT16, 4 > >::FromXmlString(_value, allowedNumberOfAutoBets)) return false;
		}
		else if (_element.equals("allowedBetIncrements"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< INT64, 4 > >::FromXmlString(_value, allowedBetIncrements)) return false;
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::PokerSideBetGameDefBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetGameDefBody())) // not empty
	{
		availableBets.composeMsg(_body, _ignoreJSON);
		allowedBetAmounts.composeMsg(_body, _ignoreJSON);
		allowedNumberOfAutoBets.composeMsg(_body, _ignoreJSON);
		allowedBetIncrements.composeMsg(_body, _ignoreJSON);
		_body.composeINT64(maxBuyIn);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetGameDefBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	availableBets.parseMsg(_parser0);
	allowedBetAmounts.parseMsg(_parser0);
	allowedNumberOfAutoBets.parseMsg(_parser0);
	allowedBetIncrements.parseMsg(_parser0);
	_parser0.parseINT64(maxBuyIn);
}

const char *MiniGameClient::sidegame::PokerSideBetGameDefBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("availableBets", availableBets);
	_jsonstr.compose("allowedBetAmounts", allowedBetAmounts);
	_jsonstr.compose("allowedNumberOfAutoBets", allowedNumberOfAutoBets);
	_jsonstr.compose("allowedBetIncrements", allowedBetIncrements);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetGameDefBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("availableBets", availableBets);
	_jparser.parseByNameThrow("allowedBetAmounts", allowedBetAmounts);
	_jparser.parseByNameThrow("allowedNumberOfAutoBets", allowedNumberOfAutoBets);
	_jparser.parseByNameThrow("allowedBetIncrements", allowedBetIncrements);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
}

/* static */ void MiniGameClient::sidegame::PokerSideBetGameDefBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PokerSideBetAvailableBet > availableBets; _jparser.validateByNameThrow("availableBets", availableBets);
	AtfValidator::validateInt(_descr, "availableBets", availableBets.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT64 > allowedBetAmounts; _jparser.validateByNameThrow("allowedBetAmounts", allowedBetAmounts);
	AtfValidator::validateInt(_descr, "allowedBetAmounts", allowedBetAmounts.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT16 > allowedNumberOfAutoBets; _jparser.validateByNameThrow("allowedNumberOfAutoBets", allowedNumberOfAutoBets);
	AtfValidator::validateInt(_descr, "allowedNumberOfAutoBets", allowedNumberOfAutoBets.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< INT64 > allowedBetIncrements; _jparser.validateByNameThrow("allowedBetIncrements", allowedBetIncrements);
	AtfValidator::validateInt(_descr, "allowedBetIncrements", allowedBetIncrements.size(), _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetGameDefBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szAvailableBets = Atf::LAtfVector< PokerSideBetAvailableBet, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("availableBets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "availableBets", szAvailableBets, _checker, __FILE__, __LINE__);
	int szAllowedBetAmounts = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("allowedBetAmounts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "allowedBetAmounts", szAllowedBetAmounts, _checker, __FILE__, __LINE__);
	int szAllowedNumberOfAutoBets = Atf::LAtfVector< INT16, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("allowedNumberOfAutoBets"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "allowedNumberOfAutoBets", szAllowedNumberOfAutoBets, _checker, __FILE__, __LINE__);
	int szAllowedBetIncrements = Atf::LAtfVector< INT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("allowedBetIncrements"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "allowedBetIncrements", szAllowedBetIncrements, _checker, __FILE__, __LINE__);
	INT64 maxBuyIn; _parser0.parseINT64(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetGameState
//=================================================================

MiniGameClient::sidegame::PokerSideBetGameState::PokerSideBetGameState()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::PokerSideBetGameState::PokerSideBetGameState(PokerSideBetGameState&& _o)
	: betType(std::move(_o.betType))
	, betAmount(std::move(_o.betAmount))
	, timestamp(std::move(_o.timestamp))
	, lifeCycleState(std::move(_o.lifeCycleState))
	, betResult(std::move(_o.betResult))
	, cards(std::move(_o.cards))
	, prize(std::move(_o.prize))
{
}

MiniGameClient::sidegame::PokerSideBetGameState& MiniGameClient::sidegame::PokerSideBetGameState::operator=(PokerSideBetGameState&& _o)
{
	if(this != &_o)
	{
		betType = std::move(_o.betType);
		betAmount = std::move(_o.betAmount);
		timestamp = std::move(_o.timestamp);
		lifeCycleState = std::move(_o.lifeCycleState);
		betResult = std::move(_o.betResult);
		cards = std::move(_o.cards);
		prize = std::move(_o.prize);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::PokerSideBetGameState::clear()
{
	betType = 0;
	betAmount = 0;
	timestamp = 0;
	lifeCycleState = 0;
	betResult = 0;
	cards.clear();
	prize.clear();
}

bool MiniGameClient::sidegame::PokerSideBetGameState::equals(const PokerSideBetGameState& _o) const
{
	return betType == _o.betType &&
		betAmount == _o.betAmount &&
		timestamp == _o.timestamp &&
		lifeCycleState == _o.lifeCycleState &&
		betResult == _o.betResult &&
		cards.equals(_o.cards) &&
		prize.equals(_o.prize);
}

const char *MiniGameClient::sidegame::PokerSideBetGameState::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("betType=");
	_buf.appendInt(betType);
	_buf.append(',');
	_buf.append("betAmount=");
	_buf.appendInt64(betAmount);
	_buf.append(',');
	_buf.append("timestamp=");
	_buf.appendInt(timestamp);
	_buf.append(',');
	_buf.append("lifeCycleState=");
	_buf.appendInt(lifeCycleState);
	_buf.append(',');
	_buf.append("betResult=");
	_buf.appendInt(betResult);
	_buf.append(',');
	_buf.append("cards=");
	cards.toTraceString(_buf);
	_buf.append(',');
	_buf.append("prize=");
	prize.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::PokerSideBetGameState::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("betType", betType, _buf);
	Atf::XmlElement::encodeAsXmlElement("betAmount", betAmount, _buf);
	Atf::XmlElement::encodeAsXmlElement("timestamp", timestamp, _buf);
	Atf::XmlElement::encodeAsXmlElement("lifeCycleState", lifeCycleState, _buf);
	Atf::XmlElement::encodeAsXmlElement("betResult", betResult, _buf);
	cards.toXmlString("cards", _buf);
	prize.toXmlString("prize", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::PokerSideBetGameState::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("betType"))
		{
			betType = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("betAmount"))
		{
			betAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timestamp"))
		{
			timestamp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("lifeCycleState"))
		{
			lifeCycleState = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("betResult"))
		{
			betResult = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cards"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SGCard, 4 > >::FromXmlString(_value, cards)) return false;
		}
		else if (_element.equals("prize"))
		{
			if(!Atf::AtfTempl< MiniGamePrize >::FromXmlString(_value, prize)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::PokerSideBetGameState::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetGameState())) // not empty
	{
		_body.composeINT16(betType);
		_body.composeINT64(betAmount);
		_body.composeINT32(timestamp);
		_body.composeINT32(lifeCycleState);
		_body.composeINT16(betResult);
		cards.composeMsg(_body, _ignoreJSON);
		prize.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetGameState::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(betType);
	_parser0.parseINT64(betAmount);
	_parser0.parseINT32(timestamp);
	_parser0.parseINT32(lifeCycleState);
	_parser0.parseINT16(betResult);
	cards.parseMsg(_parser0);
	prize.parseMsg(_parser0);
}

const char *MiniGameClient::sidegame::PokerSideBetGameState::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("betType", betType);
	_jsonstr.compose("betAmount", betAmount);
	_jsonstr.compose("timestamp", timestamp);
	_jsonstr.compose("lifeCycleState", lifeCycleState);
	_jsonstr.compose("betResult", betResult);
	_jsonstr.compose("cards", cards);
	_jsonstr.compose("prize", prize);
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetGameState::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("betType", betType);
	_jparser.parseByNameThrow("betAmount", betAmount);
	_jparser.parseByNameThrow("timestamp", timestamp);
	_jparser.parseByNameThrow("lifeCycleState", lifeCycleState);
	_jparser.parseByNameThrow("betResult", betResult);
	_jparser.parseByNameThrow("cards", cards);
	_jparser.parseByNameThrow("prize", prize);
}

/* static */ void MiniGameClient::sidegame::PokerSideBetGameState::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 betType; _jparser.validateByNameThrow("betType", betType);
	AtfValidator::validateInt(_descr, "betType", betType, _checker, __FILE__, __LINE__);
	INT64 betAmount; _jparser.validateByNameThrow("betAmount", betAmount);
	AtfValidator::validateInt(_descr, "betAmount", betAmount, _checker, __FILE__, __LINE__);
	INT32 timestamp; _jparser.validateByNameThrow("timestamp", timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _jparser.validateByNameThrow("lifeCycleState", lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT16 betResult; _jparser.validateByNameThrow("betResult", betResult);
	AtfValidator::validateInt(_descr, "betResult", betResult, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SGCard > cards; _jparser.validateByNameThrow("cards", cards);
	AtfValidator::validateInt(_descr, "cards", cards.size(), _checker, __FILE__, __LINE__);
	MiniGamePrize prize; _jparser.validateByNameThrow("prize", prize);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetGameState::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT16 betType; _parser0.parseINT16(betType);
	AtfValidator::validateInt(_descr, "betType", betType, _checker, __FILE__, __LINE__);
	INT64 betAmount; _parser0.parseINT64(betAmount);
	AtfValidator::validateInt(_descr, "betAmount", betAmount, _checker, __FILE__, __LINE__);
	INT32 timestamp; _parser0.parseINT32(timestamp);
	AtfValidator::validateInt(_descr, "timestamp", timestamp, _checker, __FILE__, __LINE__);
	INT32 lifeCycleState; _parser0.parseINT32(lifeCycleState);
	AtfValidator::validateInt(_descr, "lifeCycleState", lifeCycleState, _checker, __FILE__, __LINE__);
	INT16 betResult; _parser0.parseINT16(betResult);
	AtfValidator::validateInt(_descr, "betResult", betResult, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szCards = Atf::LAtfVector< SGCard, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("cards"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "cards", szCards, _checker, __FILE__, __LINE__);
	MiniGamePrize::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("prize"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_GAME
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::Protocol_SIDEGAME_MSG_START_GAME()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::clear()
{
	requestId = 0;
	minigameId = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	useGameTicket = false;
	gameTicketId = 0;
	autoPlay = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::equals(const Protocol_SIDEGAME_MSG_START_GAME& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		useGameTicket == _o.useGameTicket &&
		gameTicketId == _o.gameTicketId &&
		autoPlay == _o.autoPlay;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_START_GAME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_START_GAME*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_GAME).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("useGameTicket=");
	_buf.appendUint(useGameTicket);
	_buf.append(',');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	_buf.append(',');
	_buf.append("autoPlay=");
	_buf.appendUint(autoPlay);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_START_GAME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("useGameTicket", useGameTicket, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTicketId", gameTicketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoPlay", autoPlay, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameId"))
			{
				minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameType"))
			{
				gameType = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameId"))
			{
				gameId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("useGameTicket"))
			{
				useGameTicket = (*_value.ptr() == '1');
			}
			else if (_element.equals("gameTicketId"))
			{
				gameTicketId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoPlay"))
			{
				autoPlay = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeINT8(gameType);
	_msg.composeUINT64(gameId);
	_msg.composeUINT32(entryId);
	_msg.composeBOOL(useGameTicket);
	_msg.composeUINT64(gameTicketId);
	_msg.composeBOOL(autoPlay);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	_parser.parseINT8(gameType);
	_parser.parseUINT64(gameId);
	_parser.parseUINT32(entryId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(useGameTicket);
	_parser.parseUINT64(gameTicketId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(autoPlay);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("useGameTicket", useGameTicket);
	_jsonstr.compose("gameTicketId", gameTicketId);
	_jsonstr.compose("autoPlay", autoPlay);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("entryId", entryId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("useGameTicket", useGameTicket);
	_jparser.parseByNameThrow("gameTicketId", gameTicketId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("autoPlay", autoPlay);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_GAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool useGameTicket; _jparser.validateByNameThrow("useGameTicket", useGameTicket);
	AtfValidator::validateInt(_descr, "useGameTicket", useGameTicket, _checker, __FILE__, __LINE__);
	UINT64 gameTicketId; _jparser.validateByNameThrow("gameTicketId", gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool autoPlay; _jparser.validateByNameThrow("autoPlay", autoPlay);
	AtfValidator::validateInt(_descr, "autoPlay", autoPlay, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_GAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _parser.parseINT8(gameType);
	AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool useGameTicket; _parser.parseBOOL(useGameTicket);
	AtfValidator::validateInt(_descr, "useGameTicket", useGameTicket, _checker, __FILE__, __LINE__);
	UINT64 gameTicketId; _parser.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool autoPlay; _parser.parseBOOL(autoPlay);
	AtfValidator::validateInt(_descr, "autoPlay", autoPlay, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_GAME_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::Protocol_SIDEGAME_MSG_START_GAME_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::Protocol_SIDEGAME_MSG_START_GAME_REPLY(Protocol_SIDEGAME_MSG_START_GAME_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, state(std::move(_o.state))
	, gameTicketState(std::move(_o.gameTicketState))
	, playsRemaining(std::move(_o.playsRemaining))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::operator=(Protocol_SIDEGAME_MSG_START_GAME_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		state = std::move(_o.state);
		gameTicketState = std::move(_o.gameTicketState);
		playsRemaining = std::move(_o.playsRemaining);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errString.clear();
	state.clear();
	gameTicketState.clear();
	playsRemaining = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::equals(const Protocol_SIDEGAME_MSG_START_GAME_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		state.equals(_o.state) &&
		gameTicketState.equals(_o.gameTicketState) &&
		playsRemaining == _o.playsRemaining;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_START_GAME_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_START_GAME_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_GAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("gameTicketState=");
		gameTicketState.toTraceString(_buf);
	}
	_buf.append(',');
	_buf.append("playsRemaining=");
	_buf.appendInt(playsRemaining);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_START_GAME_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		state.toXmlString("state", _buf);
		gameTicketState.toXmlString("gameTicketState", _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("playsRemaining", playsRemaining, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::AtfTempl< SideGameState >::FromXmlString(_value, state)) return false;
			}
			else if (_element.equals("gameTicketState"))
			{
				if(!Atf::AtfTempl< GameTicketState >::FromXmlString(_value, gameTicketState)) return false;
			}
			else if (_element.equals("playsRemaining"))
			{
				playsRemaining = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		state.composeMsg(_msg, _ignoreJSON);
		gameTicketState.composeMsg(_msg, _ignoreJSON);
	}
	_msg.composeINT32(playsRemaining);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		state.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		gameTicketState.parseMsg(_parser);
	}
	if(_parser.parseEnded()) return;
	_parser.parseINT32(playsRemaining);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("state", state);
		_jsonstr.compose("gameTicketState", gameTicketState);
	}
	_jsonstr.compose("playsRemaining", playsRemaining);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("state", state);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("gameTicketState", gameTicketState);
	}
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("playsRemaining", playsRemaining);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_GAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		SideGameState state; _jparser.validateByNameThrow("state", state);
		if(_jparser.parseEnded()) return;
		GameTicketState gameTicketState; _jparser.validateByNameThrow("gameTicketState", gameTicketState);
	}
	if(_jparser.parseEnded()) return;
	INT32 playsRemaining; _jparser.validateByNameThrow("playsRemaining", playsRemaining);
	AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_GAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		GameTicketState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameTicketState"), _fieldsWithUnparsedContent);
	}
	if(_parser.parseEnded()) return;
	INT32 playsRemaining; _parser.parseINT32(playsRemaining);
	AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SuitRaceEntryMetaData
//=================================================================

MiniGameClient::sidegame::SuitRaceEntryMetaData::SuitRaceEntryMetaData()
{
	clear();
}

void MiniGameClient::sidegame::SuitRaceEntryMetaData::clear()
{
	chosenSuit = 0;
}

bool MiniGameClient::sidegame::SuitRaceEntryMetaData::equals(const SuitRaceEntryMetaData& _o) const
{
	return chosenSuit == _o.chosenSuit;
}

const char *MiniGameClient::sidegame::SuitRaceEntryMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("chosenSuit=");
	_buf.appendUint(chosenSuit);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::SuitRaceEntryMetaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("chosenSuit", chosenSuit, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::SuitRaceEntryMetaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("chosenSuit"))
		{
			chosenSuit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::SuitRaceEntryMetaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SuitRaceEntryMetaData())) // not empty
	{
		_body.composeBYTE(chosenSuit);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SuitRaceEntryMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(chosenSuit);
}

const char *MiniGameClient::sidegame::SuitRaceEntryMetaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("chosenSuit", chosenSuit);
	return _buf.c_str();
}

void MiniGameClient::sidegame::SuitRaceEntryMetaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("chosenSuit", chosenSuit);
}

/* static */ void MiniGameClient::sidegame::SuitRaceEntryMetaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE chosenSuit; _jparser.validateByNameThrow("chosenSuit", chosenSuit);
	AtfValidator::validateInt(_descr, "chosenSuit", chosenSuit, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::SuitRaceEntryMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE chosenSuit; _parser0.parseBYTE(chosenSuit);
	AtfValidator::validateInt(_descr, "chosenSuit", chosenSuit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PickAnObjectEntryMetaData
//=================================================================

MiniGameClient::sidegame::PickAnObjectEntryMetaData::PickAnObjectEntryMetaData()
{
	clear();
}

void MiniGameClient::sidegame::PickAnObjectEntryMetaData::clear()
{
	prizeIndexPicked = 0;
}

bool MiniGameClient::sidegame::PickAnObjectEntryMetaData::equals(const PickAnObjectEntryMetaData& _o) const
{
	return prizeIndexPicked == _o.prizeIndexPicked;
}

const char *MiniGameClient::sidegame::PickAnObjectEntryMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("prizeIndexPicked=");
	_buf.appendInt(prizeIndexPicked);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::PickAnObjectEntryMetaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("prizeIndexPicked", prizeIndexPicked, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::PickAnObjectEntryMetaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("prizeIndexPicked"))
		{
			prizeIndexPicked = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::PickAnObjectEntryMetaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PickAnObjectEntryMetaData())) // not empty
	{
		_body.composeINT8(prizeIndexPicked);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PickAnObjectEntryMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT8(prizeIndexPicked);
}

const char *MiniGameClient::sidegame::PickAnObjectEntryMetaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("prizeIndexPicked", prizeIndexPicked);
	return _buf.c_str();
}

void MiniGameClient::sidegame::PickAnObjectEntryMetaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("prizeIndexPicked", prizeIndexPicked);
}

/* static */ void MiniGameClient::sidegame::PickAnObjectEntryMetaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 prizeIndexPicked; _jparser.validateByNameThrow("prizeIndexPicked", prizeIndexPicked);
	AtfValidator::validateInt(_descr, "prizeIndexPicked", prizeIndexPicked, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::PickAnObjectEntryMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT8 prizeIndexPicked; _parser0.parseINT8(prizeIndexPicked);
	AtfValidator::validateInt(_descr, "prizeIndexPicked", prizeIndexPicked, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    PokerSideBetEntryMetaData
//=================================================================

MiniGameClient::sidegame::PokerSideBetEntryMetaData::PokerSideBetEntryMetaData()
{
	clear();
}

void MiniGameClient::sidegame::PokerSideBetEntryMetaData::clear()
{
	betType = 0;
	betAmount = 0;
}

bool MiniGameClient::sidegame::PokerSideBetEntryMetaData::equals(const PokerSideBetEntryMetaData& _o) const
{
	return betType == _o.betType &&
		betAmount == _o.betAmount;
}

const char *MiniGameClient::sidegame::PokerSideBetEntryMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("betType=");
	_buf.appendInt(betType);
	_buf.append(',');
	_buf.append("betAmount=");
	_buf.appendInt64(betAmount);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::PokerSideBetEntryMetaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("betType", betType, _buf);
	Atf::XmlElement::encodeAsXmlElement("betAmount", betAmount, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::PokerSideBetEntryMetaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("betType"))
		{
			betType = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("betAmount"))
		{
			betAmount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::PokerSideBetEntryMetaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PokerSideBetEntryMetaData())) // not empty
	{
		_body.composeINT16(betType);
		_body.composeINT64(betAmount);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::PokerSideBetEntryMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT16(betType);
	_parser0.parseINT64(betAmount);
}

const char *MiniGameClient::sidegame::PokerSideBetEntryMetaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("betType", betType);
	_jsonstr.compose("betAmount", betAmount);
	return _buf.c_str();
}

void MiniGameClient::sidegame::PokerSideBetEntryMetaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("betType", betType);
	_jparser.parseByNameThrow("betAmount", betAmount);
}

/* static */ void MiniGameClient::sidegame::PokerSideBetEntryMetaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 betType; _jparser.validateByNameThrow("betType", betType);
	AtfValidator::validateInt(_descr, "betType", betType, _checker, __FILE__, __LINE__);
	INT64 betAmount; _jparser.validateByNameThrow("betAmount", betAmount);
	AtfValidator::validateInt(_descr, "betAmount", betAmount, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::PokerSideBetEntryMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT16 betType; _parser0.parseINT16(betType);
	AtfValidator::validateInt(_descr, "betType", betType, _checker, __FILE__, __LINE__);
	INT64 betAmount; _parser0.parseINT64(betAmount);
	AtfValidator::validateInt(_descr, "betAmount", betAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_GAME_NEW
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::Protocol_SIDEGAME_MSG_START_GAME_NEW()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::Protocol_SIDEGAME_MSG_START_GAME_NEW(Protocol_SIDEGAME_MSG_START_GAME_NEW&& _o)
	: requestId(std::move(_o.requestId))
	, minigameId(std::move(_o.minigameId))
	, gameType(std::move(_o.gameType))
	, gameId(std::move(_o.gameId))
	, entryId(std::move(_o.entryId))
	, minigameEntryMode(std::move(_o.minigameEntryMode))
	, minigameEntryRefId(std::move(_o.minigameEntryRefId))
	, autoPlay(std::move(_o.autoPlay))
	, sideGameEntryMetaData(std::move(_o.sideGameEntryMetaData))
	, ringSessionId(std::move(_o.ringSessionId))
	, subGameId(std::move(_o.subGameId))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::operator=(Protocol_SIDEGAME_MSG_START_GAME_NEW&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		minigameId = std::move(_o.minigameId);
		gameType = std::move(_o.gameType);
		gameId = std::move(_o.gameId);
		entryId = std::move(_o.entryId);
		minigameEntryMode = std::move(_o.minigameEntryMode);
		minigameEntryRefId = std::move(_o.minigameEntryRefId);
		autoPlay = std::move(_o.autoPlay);
		sideGameEntryMetaData = std::move(_o.sideGameEntryMetaData);
		ringSessionId = std::move(_o.ringSessionId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::clear()
{
	requestId = 0;
	minigameId = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	minigameEntryMode = 0;
	minigameEntryRefId = 0;
	autoPlay = false;
	sideGameEntryMetaData.clear();
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::equals(const Protocol_SIDEGAME_MSG_START_GAME_NEW& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		minigameEntryMode == _o.minigameEntryMode &&
		minigameEntryRefId == _o.minigameEntryRefId &&
		autoPlay == _o.autoPlay &&
		sideGameEntryMetaData.equals(_o.sideGameEntryMetaData) &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_START_GAME_NEW != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_START_GAME_NEW*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_GAME_NEW).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("minigameEntryMode=");
	_buf.appendInt(minigameEntryMode);
	_buf.append(',');
	_buf.append("minigameEntryRefId=");
	_buf.appendUint64(minigameEntryRefId);
	_buf.append(',');
	_buf.append("autoPlay=");
	_buf.appendUint(autoPlay);
	_buf.append(',');
	_buf.append("sideGameEntryMetaData=");
	sideGameEntryMetaData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("ringSessionId=");
	_buf.appendUint64(ringSessionId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_START_GAME_NEW).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameEntryMode", minigameEntryMode, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameEntryRefId", minigameEntryRefId, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoPlay", autoPlay, _buf);
	sideGameEntryMetaData.toXmlString("sideGameEntryMetaData", _buf);
	Atf::XmlElement::encodeAsXmlElement("ringSessionId", ringSessionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("subGameId", subGameId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameId"))
			{
				minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameType"))
			{
				gameType = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameId"))
			{
				gameId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameEntryMode"))
			{
				minigameEntryMode = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameEntryRefId"))
			{
				minigameEntryRefId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("autoPlay"))
			{
				autoPlay = (*_value.ptr() == '1');
			}
			else if (_element.equals("sideGameEntryMetaData"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, sideGameEntryMetaData)) return false;
			}
			else if (_element.equals("ringSessionId"))
			{
				ringSessionId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("subGameId"))
			{
				subGameId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeINT8(gameType);
	_msg.composeUINT64(gameId);
	_msg.composeUINT32(entryId);
	_msg.composeINT8(minigameEntryMode);
	_msg.composeUINT64(minigameEntryRefId);
	_msg.composeBOOL(autoPlay);
	sideGameEntryMetaData.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT64(ringSessionId);
	_msg.composeUINT64(subGameId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	_parser.parseINT8(gameType);
	_parser.parseUINT64(gameId);
	_parser.parseUINT32(entryId);
	_parser.parseINT8(minigameEntryMode);
	_parser.parseUINT64(minigameEntryRefId);
	_parser.parseBOOL(autoPlay);
	if(_parser.parseEnded()) return;
	sideGameEntryMetaData.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(ringSessionId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(subGameId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("minigameEntryMode", minigameEntryMode);
	_jsonstr.compose("minigameEntryRefId", minigameEntryRefId);
	_jsonstr.compose("autoPlay", autoPlay);
	_jsonstr.compose("sideGameEntryMetaData", sideGameEntryMetaData);
	_jsonstr.compose("ringSessionId", ringSessionId);
	_jsonstr.compose("subGameId", subGameId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("minigameEntryMode", minigameEntryMode);
	_jparser.parseByNameThrow("minigameEntryRefId", minigameEntryRefId);
	_jparser.parseByNameThrow("autoPlay", autoPlay);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("sideGameEntryMetaData", sideGameEntryMetaData);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("ringSessionId", ringSessionId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("subGameId", subGameId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_GAME_NEW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	INT8 minigameEntryMode; _jparser.validateByNameThrow("minigameEntryMode", minigameEntryMode);
	AtfValidator::validateIntRange(_descr, "minigameEntryMode", minigameEntryMode, sidegame::eSideGameEntryMode_Normal, sidegame::eSideGameEntryMode_Max, _checker, __FILE__, __LINE__);
	UINT64 minigameEntryRefId; _jparser.validateByNameThrow("minigameEntryRefId", minigameEntryRefId);
	AtfValidator::validateUint(_descr, "minigameEntryRefId", minigameEntryRefId, _checker, __FILE__, __LINE__);
	bool autoPlay; _jparser.validateByNameThrow("autoPlay", autoPlay);
	AtfValidator::validateInt(_descr, "autoPlay", autoPlay, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Atf::MsgBodyWithJSON sideGameEntryMetaData; _jparser.validateByNameThrow("sideGameEntryMetaData", sideGameEntryMetaData);
	AtfValidator::validateIntMax(_descr, "sideGameEntryMetaData", sideGameEntryMetaData.jsonLengthOrMsgBodySize(), 1048576, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 ringSessionId; _jparser.validateByNameThrow("ringSessionId", ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 subGameId; _jparser.validateByNameThrow("subGameId", subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_GAME_NEW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _parser.parseINT8(gameType);
	AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	INT8 minigameEntryMode; _parser.parseINT8(minigameEntryMode);
	AtfValidator::validateIntRange(_descr, "minigameEntryMode", minigameEntryMode, sidegame::eSideGameEntryMode_Normal, sidegame::eSideGameEntryMode_Max, _checker, __FILE__, __LINE__);
	UINT64 minigameEntryRefId; _parser.parseUINT64(minigameEntryRefId);
	AtfValidator::validateUint(_descr, "minigameEntryRefId", minigameEntryRefId, _checker, __FILE__, __LINE__);
	bool autoPlay; _parser.parseBOOL(autoPlay);
	AtfValidator::validateInt(_descr, "autoPlay", autoPlay, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	Atf::MsgBodyWithJSON sideGameEntryMetaData; sideGameEntryMetaData.parseMsg(_parser);
	AtfValidator::validateIntMax(_descr, "sideGameEntryMetaData", sideGameEntryMetaData.jsonLengthOrMsgBodySize(), 1048576, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 ringSessionId; _parser.parseUINT64(ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 subGameId; _parser.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_ACTIVE_GAMES
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::Protocol_SIDEGAME_MSG_ACTIVE_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::Protocol_SIDEGAME_MSG_ACTIVE_GAMES(Protocol_SIDEGAME_MSG_ACTIVE_GAMES&& _o)
	: requestId(std::move(_o.requestId))
	, useEntryFilter(std::move(_o.useEntryFilter))
	, gameType(std::move(_o.gameType))
	, gameId(std::move(_o.gameId))
	, entryId(std::move(_o.entryId))
	, ringSessionId(std::move(_o.ringSessionId))
	, subGameId(std::move(_o.subGameId))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::operator=(Protocol_SIDEGAME_MSG_ACTIVE_GAMES&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		useEntryFilter = std::move(_o.useEntryFilter);
		gameType = std::move(_o.gameType);
		gameId = std::move(_o.gameId);
		entryId = std::move(_o.entryId);
		ringSessionId = std::move(_o.ringSessionId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::clear()
{
	requestId = 0;
	useEntryFilter = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::equals(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES& _o) const
{
	return requestId == _o.requestId &&
		useEntryFilter == _o.useEntryFilter &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_ACTIVE_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_ACTIVE_GAMES*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_ACTIVE_GAMES).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("useEntryFilter=");
	_buf.appendUint(useEntryFilter);
	if( useEntryFilter)
	{
		_buf.append(',');
		_buf.append("gameType=");
		_buf.appendInt(gameType);
		_buf.append(',');
		_buf.append("gameId=");
		_buf.appendUint64(gameId);
		_buf.append(',');
		_buf.append("entryId=");
		_buf.appendUint(entryId);
		_buf.append(',');
		_buf.append("ringSessionId=");
		_buf.appendUint64(ringSessionId);
		_buf.append(',');
		_buf.append("subGameId=");
		_buf.appendUint64(subGameId);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_ACTIVE_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("useEntryFilter", useEntryFilter, _buf);
	if( useEntryFilter)
	{
		Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
		Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
		Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
		Atf::XmlElement::encodeAsXmlElement("ringSessionId", ringSessionId, _buf);
		Atf::XmlElement::encodeAsXmlElement("subGameId", subGameId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("useEntryFilter"))
			{
				useEntryFilter = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameType"))
			{
				gameType = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameId"))
			{
				gameId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ringSessionId"))
			{
				ringSessionId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("subGameId"))
			{
				subGameId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeBYTE(useEntryFilter);
	if( useEntryFilter)
	{
		_msg.composeINT8(gameType);
		_msg.composeUINT64(gameId);
		_msg.composeUINT32(entryId);
		_msg.composeUINT64(ringSessionId);
		_msg.composeUINT64(subGameId);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseBYTE(useEntryFilter);
	if( useEntryFilter)
	{
		_parser.parseINT8(gameType);
		_parser.parseUINT64(gameId);
		_parser.parseUINT32(entryId);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(ringSessionId);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(subGameId);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("useEntryFilter", useEntryFilter);
	if( useEntryFilter)
	{
		_jsonstr.compose("gameType", gameType);
		_jsonstr.compose("gameId", gameId);
		_jsonstr.compose("entryId", entryId);
		_jsonstr.compose("ringSessionId", ringSessionId);
		_jsonstr.compose("subGameId", subGameId);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("useEntryFilter", useEntryFilter);
	if( useEntryFilter)
	{
		_jparser.parseByNameThrow("gameType", gameType);
		_jparser.parseByNameThrow("gameId", gameId);
		_jparser.parseByNameThrow("entryId", entryId);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("ringSessionId", ringSessionId);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("subGameId", subGameId);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_ACTIVE_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE useEntryFilter = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("useEntryFilter", useEntryFilter);
	AtfValidator::validateIntRange(_descr, "useEntryFilter", useEntryFilter, 0, 1, _checker, __FILE__, __LINE__);
	if( useEntryFilter)
	{
		INT8 gameType; _jparser.validateByNameThrow("gameType", gameType);
		AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
		UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
		AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
		UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
		AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT64 ringSessionId; _jparser.validateByNameThrow("ringSessionId", ringSessionId);
		AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT64 subGameId; _jparser.validateByNameThrow("subGameId", subGameId);
		AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_ACTIVE_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE useEntryFilter = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(useEntryFilter);
	AtfValidator::validateIntRange(_descr, "useEntryFilter", useEntryFilter, 0, 1, _checker, __FILE__, __LINE__);
	if( useEntryFilter)
	{
		INT8 gameType; _parser.parseINT8(gameType);
		AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
		UINT64 gameId; _parser.parseUINT64(gameId);
		AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
		UINT32 entryId; _parser.parseUINT32(entryId);
		AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 ringSessionId; _parser.parseUINT64(ringSessionId);
		AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 subGameId; _parser.parseUINT64(subGameId);
		AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY(Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, states(std::move(_o.states))
	, maxGamesReached(std::move(_o.maxGamesReached))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::operator=(Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		states = std::move(_o.states);
		maxGamesReached = std::move(_o.maxGamesReached);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	states.clear();
	maxGamesReached.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::equals(const Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		states.equals(_o.states) &&
		maxGamesReached.equals(_o.maxGamesReached) &&
		hasHistoricGames == _o.hasHistoricGames;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_ACTIVE_GAMES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_ACTIVE_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("states=");
		states.toTraceString(_buf);
		_buf.append(',');
		_buf.append("maxGamesReached=");
		maxGamesReached.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_ACTIVE_GAMES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		states.toXmlString("states", _buf);
		maxGamesReached.toXmlString("maxGamesReached", _buf);
		Atf::XmlElement::encodeAsXmlElement("hasHistoricGames", hasHistoricGames, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("states"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SideGameState , 4 > >::FromXmlString(_value, states)) return false;
			}
			else if (_element.equals("maxGamesReached"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MaxGamesReachedEntry , 4 > >::FromXmlString(_value, maxGamesReached)) return false;
			}
			else if (_element.equals("hasHistoricGames"))
			{
				hasHistoricGames = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		CommMsgBody _msg0;
		states.composeMsg(_msg0, _ignoreJSON);
		_msg.composeMsgBody(_msg0);
		CommMsgBody _msg1;
		maxGamesReached.composeMsg(_msg1, _ignoreJSON);
		_msg.composeMsgBody(_msg1);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
		parseAnonymousMsgBody1(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseBOOL(hasHistoricGames);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("states", states);
		_jsonstr.compose("maxGamesReached", maxGamesReached);
		_jsonstr.compose("hasHistoricGames", hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("states", states);
		_jparser.parseByNameThrow("maxGamesReached", maxGamesReached);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("hasHistoricGames", hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_ACTIVE_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< SideGameState > states; _jparser.validateByNameThrow("states", states);
		AtfValidator::validateInt(_descr, "states", states.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< MaxGamesReachedEntry > maxGamesReached; _jparser.validateByNameThrow("maxGamesReached", maxGamesReached);
		AtfValidator::validateInt(_descr, "maxGamesReached", maxGamesReached.size(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		bool hasHistoricGames; _jparser.validateByNameThrow("hasHistoricGames", hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_ACTIVE_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	states.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szStates = Atf::LAtfVector< SideGameState , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("states"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "states", szStates, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	maxGamesReached.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szMaxGamesReached = Atf::LAtfVector< MaxGamesReachedEntry , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("maxGamesReached"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "maxGamesReached", szMaxGamesReached, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_STATE
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::Protocol_SIDEGAME_MSG_GAME_STATE()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::equals(const Protocol_SIDEGAME_MSG_GAME_STATE& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GAME_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GAME_STATE*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_STATE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GAME_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigamePlayId", minigamePlayId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigamePlayId"))
			{
				minigamePlayId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigamePlayId", minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigamePlayId", minigamePlayId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _jparser.validateByNameThrow("minigamePlayId", minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_STATE_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY(Protocol_SIDEGAME_MSG_GAME_STATE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::operator=(Protocol_SIDEGAME_MSG_GAME_STATE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::equals(const Protocol_SIDEGAME_MSG_GAME_STATE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		state.equals(_o.state) &&
		hasHistoricGames == _o.hasHistoricGames;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GAME_STATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GAME_STATE_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_STATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GAME_STATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		state.toXmlString("state", _buf);
		Atf::XmlElement::encodeAsXmlElement("hasHistoricGames", hasHistoricGames, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::AtfTempl< SideGameState >::FromXmlString(_value, state)) return false;
			}
			else if (_element.equals("hasHistoricGames"))
			{
				hasHistoricGames = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseBOOL(hasHistoricGames);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("state", state);
		_jsonstr.compose("hasHistoricGames", hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("state", state);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("hasHistoricGames", hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_STATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		SideGameState state; _jparser.validateByNameThrow("state", state);
		if(_jparser.parseEnded()) return;
		bool hasHistoricGames; _jparser.validateByNameThrow("hasHistoricGames", hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_STATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::clear()
{
	requestId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::equals(const Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED& _o) const
{
	return requestId == _o.requestId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_MAX_GAMES_REACHED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_MAX_GAMES_REACHED).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_MAX_GAMES_REACHED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_MAX_GAMES_REACHED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_MAX_GAMES_REACHED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY(Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, maxGamesReached(std::move(_o.maxGamesReached))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::operator=(Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		maxGamesReached = std::move(_o.maxGamesReached);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	maxGamesReached.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::equals(const Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		maxGamesReached.equals(_o.maxGamesReached);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("maxGamesReached=");
		maxGamesReached.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		maxGamesReached.toXmlString("maxGamesReached", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("maxGamesReached"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< MaxGamesReachedEntry , 4 > >::FromXmlString(_value, maxGamesReached)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		maxGamesReached.composeMsg(_msg, _ignoreJSON);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		maxGamesReached.parseMsg(_parser);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("maxGamesReached", maxGamesReached);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("maxGamesReached", maxGamesReached);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< MaxGamesReachedEntry > maxGamesReached; _jparser.validateByNameThrow("maxGamesReached", maxGamesReached);
		AtfValidator::validateInt(_descr, "maxGamesReached", maxGamesReached.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szMaxGamesReached = Atf::LAtfVector< MaxGamesReachedEntry , 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("maxGamesReached"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "maxGamesReached", szMaxGamesReached, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CLAIM_PRIZE
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::Protocol_SIDEGAME_MSG_CLAIM_PRIZE()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::clear()
{
	requestId = 0;
	minigamePlayId = 0;
	prizeIndex = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::equals(const Protocol_SIDEGAME_MSG_CLAIM_PRIZE& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId &&
		prizeIndex == _o.prizeIndex;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_CLAIM_PRIZE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_CLAIM_PRIZE*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CLAIM_PRIZE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	_buf.append(',');
	_buf.append("prizeIndex=");
	_buf.appendInt(prizeIndex);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_CLAIM_PRIZE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigamePlayId", minigamePlayId, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizeIndex", prizeIndex, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigamePlayId"))
			{
				minigamePlayId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("prizeIndex"))
			{
				prizeIndex = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
	_msg.composeINT32(prizeIndex);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
	_parser.parseINT32(prizeIndex);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigamePlayId", minigamePlayId);
	_jsonstr.compose("prizeIndex", prizeIndex);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigamePlayId", minigamePlayId);
	_jparser.parseByNameThrow("prizeIndex", prizeIndex);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CLAIM_PRIZE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _jparser.validateByNameThrow("minigamePlayId", minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	INT32 prizeIndex; _jparser.validateByNameThrow("prizeIndex", prizeIndex);
	AtfValidator::validateIntRange(_descr, "prizeIndex", prizeIndex, 0, 0, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CLAIM_PRIZE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	INT32 prizeIndex; _parser.parseINT32(prizeIndex);
	AtfValidator::validateIntRange(_descr, "prizeIndex", prizeIndex, 0, 0, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY(Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::operator=(Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::equals(const Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		state.equals(_o.state) &&
		hasHistoricGames == _o.hasHistoricGames;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_CLAIM_PRIZE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CLAIM_PRIZE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_CLAIM_PRIZE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		state.toXmlString("state", _buf);
		Atf::XmlElement::encodeAsXmlElement("hasHistoricGames", hasHistoricGames, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::AtfTempl< SideGameState >::FromXmlString(_value, state)) return false;
			}
			else if (_element.equals("hasHistoricGames"))
			{
				hasHistoricGames = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseBOOL(hasHistoricGames);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("state", state);
		_jsonstr.compose("hasHistoricGames", hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("state", state);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("hasHistoricGames", hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CLAIM_PRIZE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		SideGameState state; _jparser.validateByNameThrow("state", state);
		if(_jparser.parseEnded()) return;
		bool hasHistoricGames; _jparser.validateByNameThrow("hasHistoricGames", hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CLAIM_PRIZE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_DEF
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::Protocol_SIDEGAME_MSG_GAME_DEF()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::clear()
{
	requestId = 0;
	minigameId = 0;
	gameTicketTypeId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::equals(const Protocol_SIDEGAME_MSG_GAME_DEF& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameTicketTypeId == _o.gameTicketTypeId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GAME_DEF != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GAME_DEF*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_DEF).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint(gameTicketTypeId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GAME_DEF).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTicketTypeId", gameTicketTypeId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameId"))
			{
				minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameTicketTypeId"))
			{
				gameTicketTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeUINT32(gameTicketTypeId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(gameTicketTypeId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("gameTicketTypeId", gameTicketTypeId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigameId", minigameId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("gameTicketTypeId", gameTicketTypeId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 gameTicketTypeId; _jparser.validateByNameThrow("gameTicketTypeId", gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 gameTicketTypeId; _parser.parseUINT32(gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_DEF_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY(Protocol_SIDEGAME_MSG_GAME_DEF_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, def(std::move(_o.def))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::operator=(Protocol_SIDEGAME_MSG_GAME_DEF_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		def = std::move(_o.def);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	def.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::equals(const Protocol_SIDEGAME_MSG_GAME_DEF_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		def.equals(_o.def);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GAME_DEF_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GAME_DEF_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_DEF_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("def=");
		def.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GAME_DEF_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		def.toXmlString("def", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("def"))
			{
				if(!Atf::AtfTempl< MiniGameTypeLeaf >::FromXmlString(_value, def)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		def.composeMsg(_msg, _ignoreJSON);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		def.parseMsg(_parser);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("def", def);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("def", def);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		MiniGameTypeLeaf def; _jparser.validateByNameThrow("def", def);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		MiniGameTypeLeaf::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("def"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::clear()
{
	requestId = 0;
	minigameId = 0;
	gameTicketTypeId = 0;
	gameType = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::equals(const Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED& _o) const
{
	return requestId == _o.requestId &&
		minigameId == _o.minigameId &&
		gameTicketTypeId == _o.gameTicketTypeId &&
		gameType == _o.gameType;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GAME_DEF_LOCALIZED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_DEF_LOCALIZED).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint(gameTicketTypeId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GAME_DEF_LOCALIZED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTicketTypeId", gameTicketTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameId"))
			{
				minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameTicketTypeId"))
			{
				gameTicketTypeId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameType"))
			{
				gameType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(minigameId);
	_msg.composeUINT32(gameTicketTypeId);
	_msg.composeINT32(gameType);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(minigameId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(gameTicketTypeId);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(gameType);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("gameTicketTypeId", gameTicketTypeId);
	_jsonstr.compose("gameType", gameType);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigameId", minigameId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("gameTicketTypeId", gameTicketTypeId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("gameType", gameType);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF_LOCALIZED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 gameTicketTypeId; _jparser.validateByNameThrow("gameTicketTypeId", gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF_LOCALIZED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 gameTicketTypeId; _parser.parseUINT32(gameTicketTypeId);
	AtfValidator::validateInt(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 gameType; _parser.parseINT32(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY(Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, def(std::move(_o.def))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::operator=(Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		def = std::move(_o.def);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	def.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::equals(const Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		def.equals(_o.def);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("def=");
		def.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		def.toXmlString("def", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("def"))
			{
				if(!Atf::AtfTempl< MiniGameDefLocalized >::FromXmlString(_value, def)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		def.composeMsg(_msg, _ignoreJSON);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		def.parseMsg(_parser);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("def", def);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("def", def);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		MiniGameDefLocalized def; _jparser.validateByNameThrow("def", def);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		MiniGameDefLocalized::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("def"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_HISTORIC_GAMES
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::Protocol_SIDEGAME_MSG_HISTORIC_GAMES()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::Protocol_SIDEGAME_MSG_HISTORIC_GAMES(Protocol_SIDEGAME_MSG_HISTORIC_GAMES&& _o)
	: requestId(std::move(_o.requestId))
	, maxHistoricPlays(std::move(_o.maxHistoricPlays))
	, useEntryFilter(std::move(_o.useEntryFilter))
	, gameType(std::move(_o.gameType))
	, gameId(std::move(_o.gameId))
	, entryId(std::move(_o.entryId))
	, gameTicketTypeId(std::move(_o.gameTicketTypeId))
	, ringSessionId(std::move(_o.ringSessionId))
	, subGameId(std::move(_o.subGameId))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::operator=(Protocol_SIDEGAME_MSG_HISTORIC_GAMES&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		maxHistoricPlays = std::move(_o.maxHistoricPlays);
		useEntryFilter = std::move(_o.useEntryFilter);
		gameType = std::move(_o.gameType);
		gameId = std::move(_o.gameId);
		entryId = std::move(_o.entryId);
		gameTicketTypeId = std::move(_o.gameTicketTypeId);
		ringSessionId = std::move(_o.ringSessionId);
		subGameId = std::move(_o.subGameId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::clear()
{
	requestId = 0;
	maxHistoricPlays = 0;
	useEntryFilter = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	gameTicketTypeId = 0;
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::equals(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES& _o) const
{
	return requestId == _o.requestId &&
		maxHistoricPlays == _o.maxHistoricPlays &&
		useEntryFilter == _o.useEntryFilter &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		gameTicketTypeId == _o.gameTicketTypeId &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_HISTORIC_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_HISTORIC_GAMES*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_HISTORIC_GAMES).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("maxHistoricPlays=");
	_buf.appendUint(maxHistoricPlays);
	_buf.append(',');
	_buf.append("useEntryFilter=");
	_buf.appendUint(useEntryFilter);
	if( useEntryFilter )
	{
		_buf.append(',');
		_buf.append("gameType=");
		_buf.appendInt(gameType);
		_buf.append(',');
		_buf.append("gameId=");
		_buf.appendUint64(gameId);
		_buf.append(',');
		_buf.append("entryId=");
		_buf.appendUint(entryId);
	}
	_buf.append(',');
	_buf.append("gameTicketTypeId=");
	_buf.appendUint64(gameTicketTypeId);
	_buf.append(',');
	_buf.append("ringSessionId=");
	_buf.appendUint64(ringSessionId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_HISTORIC_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxHistoricPlays", maxHistoricPlays, _buf);
	Atf::XmlElement::encodeAsXmlElement("useEntryFilter", useEntryFilter, _buf);
	if( useEntryFilter )
	{
		Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
		Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
		Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("gameTicketTypeId", gameTicketTypeId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ringSessionId", ringSessionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("subGameId", subGameId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxHistoricPlays"))
			{
				maxHistoricPlays = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("useEntryFilter"))
			{
				useEntryFilter = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameType"))
			{
				gameType = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameId"))
			{
				gameId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("entryId"))
			{
				entryId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameTicketTypeId"))
			{
				gameTicketTypeId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ringSessionId"))
			{
				ringSessionId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("subGameId"))
			{
				subGameId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeBYTE(maxHistoricPlays);
	_msg.composeBYTE(useEntryFilter);
	if( useEntryFilter )
	{
		_msg.composeINT8(gameType);
		_msg.composeUINT64(gameId);
		_msg.composeUINT32(entryId);
	}
	_msg.composeUINT64(gameTicketTypeId);
	_msg.composeUINT64(ringSessionId);
	_msg.composeUINT64(subGameId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseBYTE(maxHistoricPlays);
	_parser.parseBYTE(useEntryFilter);
	if( useEntryFilter )
	{
		_parser.parseINT8(gameType);
		_parser.parseUINT64(gameId);
		_parser.parseUINT32(entryId);
	}
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(gameTicketTypeId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(ringSessionId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(subGameId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("maxHistoricPlays", maxHistoricPlays);
	_jsonstr.compose("useEntryFilter", useEntryFilter);
	if( useEntryFilter )
	{
		_jsonstr.compose("gameType", gameType);
		_jsonstr.compose("gameId", gameId);
		_jsonstr.compose("entryId", entryId);
	}
	_jsonstr.compose("gameTicketTypeId", gameTicketTypeId);
	_jsonstr.compose("ringSessionId", ringSessionId);
	_jsonstr.compose("subGameId", subGameId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("maxHistoricPlays", maxHistoricPlays);
	_jparser.parseByNameThrow("useEntryFilter", useEntryFilter);
	if( useEntryFilter )
	{
		_jparser.parseByNameThrow("gameType", gameType);
		_jparser.parseByNameThrow("gameId", gameId);
		_jparser.parseByNameThrow("entryId", entryId);
	}
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("gameTicketTypeId", gameTicketTypeId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("ringSessionId", ringSessionId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("subGameId", subGameId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_HISTORIC_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE useEntryFilter = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	BYTE maxHistoricPlays; _jparser.validateByNameThrow("maxHistoricPlays", maxHistoricPlays);
	AtfValidator::validateIntRange(_descr, "maxHistoricPlays", maxHistoricPlays, 0, 10, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("useEntryFilter", useEntryFilter);
	AtfValidator::validateIntRange(_descr, "useEntryFilter", useEntryFilter, 0, 1, _checker, __FILE__, __LINE__);
	if( useEntryFilter )
	{
		INT8 gameType; _jparser.validateByNameThrow("gameType", gameType);
		AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
		UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
		AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
		UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
		AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	}
	if(_jparser.parseEnded()) return;
	UINT64 gameTicketTypeId; _jparser.validateByNameThrow("gameTicketTypeId", gameTicketTypeId);
	AtfValidator::validateUint(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 ringSessionId; _jparser.validateByNameThrow("ringSessionId", ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 subGameId; _jparser.validateByNameThrow("subGameId", subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_HISTORIC_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE useEntryFilter = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	BYTE maxHistoricPlays; _parser.parseBYTE(maxHistoricPlays);
	AtfValidator::validateIntRange(_descr, "maxHistoricPlays", maxHistoricPlays, 0, 10, _checker, __FILE__, __LINE__);
	_parser.parseBYTE(useEntryFilter);
	AtfValidator::validateIntRange(_descr, "useEntryFilter", useEntryFilter, 0, 1, _checker, __FILE__, __LINE__);
	if( useEntryFilter )
	{
		INT8 gameType; _parser.parseINT8(gameType);
		AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
		UINT64 gameId; _parser.parseUINT64(gameId);
		AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
		UINT32 entryId; _parser.parseUINT32(entryId);
		AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	}
	if(_parser.parseEnded()) return;
	UINT64 gameTicketTypeId; _parser.parseUINT64(gameTicketTypeId);
	AtfValidator::validateUint(_descr, "gameTicketTypeId", gameTicketTypeId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 ringSessionId; _parser.parseUINT64(ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 subGameId; _parser.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY(Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, historicGames(std::move(_o.historicGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::operator=(Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		historicGames = std::move(_o.historicGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	historicGames.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::equals(const Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		historicGames.equals(_o.historicGames);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_HISTORIC_GAMES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_HISTORIC_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("historicGames=");
		historicGames.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_HISTORIC_GAMES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		historicGames.toXmlString("historicGames", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("historicGames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SideGameState , 4 > >::FromXmlString(_value, historicGames)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		CommMsgBody _msg0;
		historicGames.composeMsg(_msg0, _ignoreJSON);
		_msg.composeMsgBody(_msg0);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("historicGames", historicGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("historicGames", historicGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_HISTORIC_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< SideGameState > historicGames; _jparser.validateByNameThrow("historicGames", historicGames);
		AtfValidator::validateInt(_descr, "historicGames", historicGames.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_HISTORIC_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	historicGames.parseMsg(_parser0);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szHistoricGames = Atf::LAtfVector< SideGameState , 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("historicGames"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "historicGames", szHistoricGames, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_FORFEIT
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::Protocol_SIDEGAME_MSG_FORFEIT()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::equals(const Protocol_SIDEGAME_MSG_FORFEIT& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_FORFEIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_FORFEIT*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_FORFEIT).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_FORFEIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigamePlayId", minigamePlayId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigamePlayId"))
			{
				minigamePlayId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigamePlayId", minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigamePlayId", minigamePlayId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_FORFEIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _jparser.validateByNameThrow("minigamePlayId", minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_FORFEIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_FORFEIT_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::Protocol_SIDEGAME_MSG_FORFEIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::Protocol_SIDEGAME_MSG_FORFEIT_REPLY(Protocol_SIDEGAME_MSG_FORFEIT_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::operator=(Protocol_SIDEGAME_MSG_FORFEIT_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::equals(const Protocol_SIDEGAME_MSG_FORFEIT_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		state.equals(_o.state) &&
		hasHistoricGames == _o.hasHistoricGames;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_FORFEIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_FORFEIT_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_FORFEIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_FORFEIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		state.toXmlString("state", _buf);
		Atf::XmlElement::encodeAsXmlElement("hasHistoricGames", hasHistoricGames, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::AtfTempl< SideGameState >::FromXmlString(_value, state)) return false;
			}
			else if (_element.equals("hasHistoricGames"))
			{
				hasHistoricGames = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		_parser.parseBOOL(hasHistoricGames);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("state", state);
		_jsonstr.compose("hasHistoricGames", hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("state", state);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("hasHistoricGames", hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_FORFEIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		SideGameState state; _jparser.validateByNameThrow("state", state);
		if(_jparser.parseEnded()) return;
		bool hasHistoricGames; _jparser.validateByNameThrow("hasHistoricGames", hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_FORFEIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::clear()
{
	requestId = 0;
	gameTicketId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::equals(const Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE& _o) const
{
	return requestId == _o.requestId &&
		gameTicketId == _o.gameTicketId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GET_TICKET_BALANCE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_TICKET_BALANCE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("gameTicketId=");
	_buf.appendUint64(gameTicketId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GET_TICKET_BALANCE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameTicketId", gameTicketId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("gameTicketId"))
			{
				gameTicketId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(gameTicketId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(gameTicketId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("gameTicketId", gameTicketId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("gameTicketId", gameTicketId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_TICKET_BALANCE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 gameTicketId; _jparser.validateByNameThrow("gameTicketId", gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_TICKET_BALANCE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 gameTicketId; _parser.parseUINT64(gameTicketId);
	AtfValidator::validateUint(_descr, "gameTicketId", gameTicketId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY(Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, playsRemaining(std::move(_o.playsRemaining))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::operator=(Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		playsRemaining = std::move(_o.playsRemaining);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	playsRemaining = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::equals(const Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		playsRemaining == _o.playsRemaining;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("playsRemaining=");
		_buf.appendInt(playsRemaining);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("playsRemaining", playsRemaining, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("playsRemaining"))
			{
				playsRemaining = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeINT32(playsRemaining);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseINT32(playsRemaining);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("playsRemaining", playsRemaining);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("playsRemaining", playsRemaining);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 playsRemaining; _jparser.validateByNameThrow("playsRemaining", playsRemaining);
		AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 playsRemaining; _parser.parseINT32(playsRemaining);
		AtfValidator::validateInt(_descr, "playsRemaining", playsRemaining, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    MultiPurposeChestMetaData
//=================================================================

MiniGameClient::sidegame::MultiPurposeChestMetaData::MultiPurposeChestMetaData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::MultiPurposeChestMetaData::MultiPurposeChestMetaData(MultiPurposeChestMetaData&& _o)
	: logoName(std::move(_o.logoName))
	, chestSkin(std::move(_o.chestSkin))
	, customSkin(std::move(_o.customSkin))
{
}

MiniGameClient::sidegame::MultiPurposeChestMetaData& MiniGameClient::sidegame::MultiPurposeChestMetaData::operator=(MultiPurposeChestMetaData&& _o)
{
	if(this != &_o)
	{
		logoName = std::move(_o.logoName);
		chestSkin = std::move(_o.chestSkin);
		customSkin = std::move(_o.customSkin);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::MultiPurposeChestMetaData::clear()
{
	logoName.clear();
	chestSkin = 0;
	customSkin.clear();
}

bool MiniGameClient::sidegame::MultiPurposeChestMetaData::equals(const MultiPurposeChestMetaData& _o) const
{
	return Atf::atfPStringEquals(logoName, _o.logoName) &&
		chestSkin == _o.chestSkin &&
		Atf::atfPStringEquals(customSkin, _o.customSkin);
}

const char *MiniGameClient::sidegame::MultiPurposeChestMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("logoName=");
	_buf.append(logoName);
	_buf.append(',');
	_buf.append("chestSkin=");
	_buf.appendUint(chestSkin);
	_buf.append(',');
	_buf.append("customSkin=");
	_buf.append(customSkin);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::MultiPurposeChestMetaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("logoName", logoName, _buf);
	Atf::XmlElement::encodeAsXmlElement("chestSkin", chestSkin, _buf);
	Atf::XmlElement::encodeAsXmlElement("customSkin", customSkin, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::MultiPurposeChestMetaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("logoName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, logoName)) return false;
		}
		else if (_element.equals("chestSkin"))
		{
			chestSkin = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("customSkin"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, customSkin)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::MultiPurposeChestMetaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(MultiPurposeChestMetaData())) // not empty
	{
		_body.composeString(logoName);
		_body.composeBYTE(chestSkin);
		_body.composeString(customSkin);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::MultiPurposeChestMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(logoName);
	_parser0.parseBYTE(chestSkin);
	_parser0.parseStringP(customSkin);
}

const char *MiniGameClient::sidegame::MultiPurposeChestMetaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("logoName", logoName);
	_jsonstr.compose("chestSkin", chestSkin);
	_jsonstr.compose("customSkin", customSkin);
	return _buf.c_str();
}

void MiniGameClient::sidegame::MultiPurposeChestMetaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("logoName", logoName);
	_jparser.parseByNameThrow("chestSkin", chestSkin);
	_jparser.parseByNameThrow("customSkin", customSkin);
}

/* static */ void MiniGameClient::sidegame::MultiPurposeChestMetaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString logoName; _jparser.validateByNameThrow("logoName", logoName);
	AtfValidator::validateInt(_descr, "logoName", logoName.length(), _checker, __FILE__, __LINE__);
	BYTE chestSkin; _jparser.validateByNameThrow("chestSkin", chestSkin);
	AtfValidator::validateInt(_descr, "chestSkin", chestSkin, _checker, __FILE__, __LINE__);
	PString customSkin; _jparser.validateByNameThrow("customSkin", customSkin);
	AtfValidator::validateInt(_descr, "customSkin", customSkin.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::MultiPurposeChestMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "logoName"); size_t szLogoName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "logoName", szLogoName, _checker, __FILE__, __LINE__);
	BYTE chestSkin; _parser0.parseBYTE(chestSkin);
	AtfValidator::validateInt(_descr, "chestSkin", chestSkin, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "customSkin"); size_t szCustomSkin = strlen(_dummy);
	AtfValidator::validateInt(_descr, "customSkin", szCustomSkin, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    StarsRewardsChestMetaData
//=================================================================

MiniGameClient::sidegame::StarsRewardsChestMetaData::StarsRewardsChestMetaData()
{
	clear();
}

void MiniGameClient::sidegame::StarsRewardsChestMetaData::clear()
{
	version = 0;
}

bool MiniGameClient::sidegame::StarsRewardsChestMetaData::equals(const StarsRewardsChestMetaData& _o) const
{
	return version == _o.version;
}

const char *MiniGameClient::sidegame::StarsRewardsChestMetaData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("version=");
	_buf.appendInt(version);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::StarsRewardsChestMetaData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("version", version, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::StarsRewardsChestMetaData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("version"))
		{
			version = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::StarsRewardsChestMetaData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(StarsRewardsChestMetaData())) // not empty
	{
		_body.composeINT32(version);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::StarsRewardsChestMetaData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(version);
}

const char *MiniGameClient::sidegame::StarsRewardsChestMetaData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("version", version);
	return _buf.c_str();
}

void MiniGameClient::sidegame::StarsRewardsChestMetaData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("version", version);
}

/* static */ void MiniGameClient::sidegame::StarsRewardsChestMetaData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 version; _jparser.validateByNameThrow("version", version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::StarsRewardsChestMetaData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 version; _parser0.parseINT32(version);
	AtfValidator::validateInt(_descr, "version", version, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::clear()
{
	requestId = 0;
	barId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::equals(const Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR& _o) const
{
	return requestId == _o.requestId &&
		barId == _o.barId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GET_STARSREWARDS_BAR != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_STARSREWARDS_BAR).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("barId=");
	_buf.appendUint64(barId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GET_STARSREWARDS_BAR).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("barId", barId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("barId"))
			{
				barId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(barId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(barId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("barId", barId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("barId", barId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_STARSREWARDS_BAR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 barId; _jparser.validateByNameThrow("barId", barId);
	AtfValidator::validateUint(_descr, "barId", barId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_STARSREWARDS_BAR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 barId; _parser.parseUINT64(barId);
	AtfValidator::validateUint(_descr, "barId", barId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY(Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, barId(std::move(_o.barId))
	, barTier(std::move(_o.barTier))
	, barType(std::move(_o.barType))
	, metaData(std::move(_o.metaData))
	, assets(std::move(_o.assets))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::operator=(Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		barId = std::move(_o.barId);
		barTier = std::move(_o.barTier);
		barType = std::move(_o.barType);
		metaData = std::move(_o.metaData);
		assets = std::move(_o.assets);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	barId = 0;
	barTier = 0;
	barType = 0;
	metaData.clear();
	assets.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::equals(const Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		barId == _o.barId &&
		barTier == _o.barTier &&
		barType == _o.barType &&
		metaData.equals(_o.metaData) &&
		assets.equals(_o.assets);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("barId=");
		_buf.appendUint64(barId);
		_buf.append(',');
		_buf.append("barTier=");
		_buf.appendInt(barTier);
		_buf.append(',');
		_buf.append("barType=");
		_buf.appendInt(barType);
		_buf.append(',');
		_buf.append("metaData=");
		metaData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("assets=");
		assets.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("barId", barId, _buf);
		Atf::XmlElement::encodeAsXmlElement("barTier", barTier, _buf);
		Atf::XmlElement::encodeAsXmlElement("barType", barType, _buf);
		metaData.toXmlString("metaData", _buf);
		assets.toXmlString("assets", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("barId"))
			{
				barId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("barTier"))
			{
				barTier = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("barType"))
			{
				barType = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("metaData"))
			{
				if(!Atf::AtfTempl< Atf::MsgBodyWithJSON >::FromXmlString(_value, metaData)) return false;
			}
			else if (_element.equals("assets"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ChestAsset, 4 > >::FromXmlString(_value, assets)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT64(barId);
		_msg.composeINT32(barTier);
		_msg.composeINT8(barType);
		metaData.composeMsg(_msg, _ignoreJSON);
		assets.composeMsg(_msg, _ignoreJSON);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT64(barId);
		_parser.parseINT32(barTier);
		if(_parser.parseEnded()) return;
		_parser.parseINT8(barType);
		if(_parser.parseEnded()) return;
		metaData.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		assets.parseMsg(_parser);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("barId", barId);
		_jsonstr.compose("barTier", barTier);
		_jsonstr.compose("barType", barType);
		_jsonstr.compose("metaData", metaData);
		_jsonstr.compose("assets", assets);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("barId", barId);
		_jparser.parseByNameThrow("barTier", barTier);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("barType", barType);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("metaData", metaData);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("assets", assets);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 barId; _jparser.validateByNameThrow("barId", barId);
		AtfValidator::validateUint(_descr, "barId", barId, _checker, __FILE__, __LINE__);
		INT32 barTier; _jparser.validateByNameThrow("barTier", barTier);
		AtfValidator::validateInt(_descr, "barTier", barTier, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		INT8 barType; _jparser.validateByNameThrow("barType", barType);
		AtfValidator::validateInt(_descr, "barType", barType, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		Atf::MsgBodyWithJSON metaData; _jparser.validateByNameThrow("metaData", metaData);
		AtfValidator::validateInt(_descr, "metaData", metaData.jsonLengthOrMsgBodySize(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		Atf::AtfVectorBase< ChestAsset > assets; _jparser.validateByNameThrow("assets", assets);
		AtfValidator::validateInt(_descr, "assets", assets.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 barId; _parser.parseUINT64(barId);
		AtfValidator::validateUint(_descr, "barId", barId, _checker, __FILE__, __LINE__);
		INT32 barTier; _parser.parseINT32(barTier);
		AtfValidator::validateInt(_descr, "barTier", barTier, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		INT8 barType; _parser.parseINT8(barType);
		AtfValidator::validateInt(_descr, "barType", barType, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		Atf::MsgBodyWithJSON metaData; metaData.parseMsg(_parser);
		AtfValidator::validateInt(_descr, "metaData", metaData.jsonLengthOrMsgBodySize(), _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		PString _descbuf;
		int szAssets = Atf::LAtfVector< ChestAsset, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("assets"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "assets", szAssets, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_SKIP_DELAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::Protocol_SIDEGAME_MSG_SKIP_DELAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::equals(const Protocol_SIDEGAME_MSG_SKIP_DELAY& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_SKIP_DELAY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_SKIP_DELAY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_SKIP_DELAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendInt64(minigamePlayId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_SKIP_DELAY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigamePlayId", minigamePlayId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigamePlayId"))
			{
				minigamePlayId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT64(minigamePlayId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT64(minigamePlayId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigamePlayId", minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigamePlayId", minigamePlayId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_SKIP_DELAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	INT64 minigamePlayId; _jparser.validateByNameThrow("minigamePlayId", minigamePlayId);
	AtfValidator::validateInt(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_SKIP_DELAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	INT64 minigamePlayId; _parser.parseINT64(minigamePlayId);
	AtfValidator::validateInt(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_RING_SESSIONID
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::clear()
{
	requestId = 0;
	tableId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::equals(const Protocol_SIDEGAME_MSG_GET_RING_SESSIONID& _o) const
{
	return requestId == _o.requestId &&
		tableId == _o.tableId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GET_RING_SESSIONID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GET_RING_SESSIONID*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_RING_SESSIONID).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GET_RING_SESSIONID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(tableId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(tableId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("tableId", tableId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_RING_SESSIONID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_RING_SESSIONID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY(Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, ringSessionId(std::move(_o.ringSessionId))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::operator=(Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		ringSessionId = std::move(_o.ringSessionId);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	ringSessionId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::equals(const Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		ringSessionId == _o.ringSessionId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_GET_RING_SESSIONID_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_GET_RING_SESSIONID_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("ringSessionId=");
		_buf.appendUint64(ringSessionId);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_GET_RING_SESSIONID_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("ringSessionId", ringSessionId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("ringSessionId"))
			{
				ringSessionId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT64(ringSessionId);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT64(ringSessionId);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("ringSessionId", ringSessionId);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("ringSessionId", ringSessionId);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_RING_SESSIONID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 ringSessionId; _jparser.validateByNameThrow("ringSessionId", ringSessionId);
		AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_GET_RING_SESSIONID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 ringSessionId; _parser.parseUINT64(ringSessionId);
		AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CANCEL_PLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::Protocol_SIDEGAME_MSG_CANCEL_PLAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::clear()
{
	requestId = 0;
	minigamePlayId = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::equals(const Protocol_SIDEGAME_MSG_CANCEL_PLAY& _o) const
{
	return requestId == _o.requestId &&
		minigamePlayId == _o.minigamePlayId;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_CANCEL_PLAY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_CANCEL_PLAY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CANCEL_PLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("minigamePlayId=");
	_buf.appendUint64(minigamePlayId);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_CANCEL_PLAY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigamePlayId", minigamePlayId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigamePlayId"))
			{
				minigamePlayId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT64(minigamePlayId);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT64(minigamePlayId);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("minigamePlayId", minigamePlayId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("minigamePlayId", minigamePlayId);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_PLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _jparser.validateByNameThrow("minigamePlayId", minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_PLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT64 minigamePlayId; _parser.parseUINT64(minigamePlayId);
	AtfValidator::validateUint(_descr, "minigamePlayId", minigamePlayId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY(Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, state(std::move(_o.state))
	, hasHistoricGames(std::move(_o.hasHistoricGames))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		state = std::move(_o.state);
		hasHistoricGames = std::move(_o.hasHistoricGames);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	state.clear();
	hasHistoricGames = false;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		state.equals(_o.state) &&
		hasHistoricGames == _o.hasHistoricGames;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_CANCEL_PLAY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CANCEL_PLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state=");
		state.toTraceString(_buf);
		_buf.append(',');
		_buf.append("hasHistoricGames=");
		_buf.appendUint(hasHistoricGames);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_CANCEL_PLAY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		state.toXmlString("state", _buf);
		Atf::XmlElement::encodeAsXmlElement("hasHistoricGames", hasHistoricGames, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("state"))
			{
				if(!Atf::AtfTempl< SideGameState >::FromXmlString(_value, state)) return false;
			}
			else if (_element.equals("hasHistoricGames"))
			{
				hasHistoricGames = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		state.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(hasHistoricGames);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		state.parseMsg(_parser);
		_parser.parseBOOL(hasHistoricGames);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("state", state);
		_jsonstr.compose("hasHistoricGames", hasHistoricGames);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("state", state);
		_jparser.parseByNameThrow("hasHistoricGames", hasHistoricGames);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_PLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		SideGameState state; _jparser.validateByNameThrow("state", state);
		bool hasHistoricGames; _jparser.validateByNameThrow("hasHistoricGames", hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_PLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		SideGameState::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("state"), _fieldsWithUnparsedContent);
		bool hasHistoricGames; _parser.parseBOOL(hasHistoricGames);
		AtfValidator::validateInt(_descr, "hasHistoricGames", hasHistoricGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SideGameContext
//=================================================================

MiniGameClient::sidegame::SideGameContext::SideGameContext()
{
	clear();
}

void MiniGameClient::sidegame::SideGameContext::clear()
{
	minigameId = 0;
	gameType = 0;
	gameId = 0;
	entryId = 0;
	ringSessionId = 0;
	subGameId = 0;
}

bool MiniGameClient::sidegame::SideGameContext::equals(const SideGameContext& _o) const
{
	return minigameId == _o.minigameId &&
		gameType == _o.gameType &&
		gameId == _o.gameId &&
		entryId == _o.entryId &&
		ringSessionId == _o.ringSessionId &&
		subGameId == _o.subGameId;
}

const char *MiniGameClient::sidegame::SideGameContext::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendInt(gameType);
	_buf.append(',');
	_buf.append("gameId=");
	_buf.appendUint64(gameId);
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("ringSessionId=");
	_buf.appendUint64(ringSessionId);
	_buf.append(',');
	_buf.append("subGameId=");
	_buf.appendUint64(subGameId);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::SideGameContext::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameId", gameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("entryId", entryId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ringSessionId", ringSessionId, _buf);
	Atf::XmlElement::encodeAsXmlElement("subGameId", subGameId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::SideGameContext::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("minigameId"))
		{
			minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameType"))
		{
			gameType = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gameId"))
		{
			gameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("entryId"))
		{
			entryId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ringSessionId"))
		{
			ringSessionId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("subGameId"))
		{
			subGameId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::SideGameContext::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SideGameContext())) // not empty
	{
		_body.composeUINT32(minigameId);
		_body.composeINT8(gameType);
		_body.composeUINT64(gameId);
		_body.composeUINT32(entryId);
		_body.composeUINT64(ringSessionId);
		_body.composeUINT64(subGameId);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::SideGameContext::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(minigameId);
	_parser0.parseINT8(gameType);
	_parser0.parseUINT64(gameId);
	_parser0.parseUINT32(entryId);
	_parser0.parseUINT64(ringSessionId);
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT64(subGameId);
}

const char *MiniGameClient::sidegame::SideGameContext::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("gameId", gameId);
	_jsonstr.compose("entryId", entryId);
	_jsonstr.compose("ringSessionId", ringSessionId);
	_jsonstr.compose("subGameId", subGameId);
	return _buf.c_str();
}

void MiniGameClient::sidegame::SideGameContext::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("gameId", gameId);
	_jparser.parseByNameThrow("entryId", entryId);
	_jparser.parseByNameThrow("ringSessionId", ringSessionId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("subGameId", subGameId);
}

/* static */ void MiniGameClient::sidegame::SideGameContext::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
	UINT64 gameId; _jparser.validateByNameThrow("gameId", gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _jparser.validateByNameThrow("entryId", entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT64 ringSessionId; _jparser.validateByNameThrow("ringSessionId", ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 subGameId; _jparser.validateByNameThrow("subGameId", subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::SideGameContext::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 minigameId; _parser0.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	INT8 gameType; _parser0.parseINT8(gameType);
	AtfValidator::validateIntRange(_descr, "gameType", gameType, MiniGameCommon::EntryType_NotApplicable, MiniGameCommon::EntryType_Max, _checker, __FILE__, __LINE__);
	UINT64 gameId; _parser0.parseUINT64(gameId);
	AtfValidator::validateUint(_descr, "gameId", gameId, _checker, __FILE__, __LINE__);
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	UINT64 ringSessionId; _parser0.parseUINT64(ringSessionId);
	AtfValidator::validateUint(_descr, "ringSessionId", ringSessionId, _checker, __FILE__, __LINE__);
	if(_parser0.parseEnded()) return;
	UINT64 subGameId; _parser0.parseUINT64(subGameId);
	AtfValidator::validateUint(_descr, "subGameId", subGameId, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    AutoPlayContextData
//=================================================================

MiniGameClient::sidegame::AutoPlayContextData::AutoPlayContextData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::AutoPlayContextData::AutoPlayContextData(AutoPlayContextData&& _o)
	: numAutoPlaysRemainingToDisplay(std::move(_o.numAutoPlaysRemainingToDisplay))
	, numAutoPlays(std::move(_o.numAutoPlays))
	, singleWinThreshold(std::move(_o.singleWinThreshold))
	, totalLossesThreshold(std::move(_o.totalLossesThreshold))
	, flags(std::move(_o.flags))
	, sideGameEntryMetaData(std::move(_o.sideGameEntryMetaData))
	, pendingMGPlays(std::move(_o.pendingMGPlays))
	, startedMGPlays(std::move(_o.startedMGPlays))
	, resolvedMGPlays(std::move(_o.resolvedMGPlays))
{
}

MiniGameClient::sidegame::AutoPlayContextData& MiniGameClient::sidegame::AutoPlayContextData::operator=(AutoPlayContextData&& _o)
{
	if(this != &_o)
	{
		numAutoPlaysRemainingToDisplay = std::move(_o.numAutoPlaysRemainingToDisplay);
		numAutoPlays = std::move(_o.numAutoPlays);
		singleWinThreshold = std::move(_o.singleWinThreshold);
		totalLossesThreshold = std::move(_o.totalLossesThreshold);
		flags = std::move(_o.flags);
		sideGameEntryMetaData = std::move(_o.sideGameEntryMetaData);
		pendingMGPlays = std::move(_o.pendingMGPlays);
		startedMGPlays = std::move(_o.startedMGPlays);
		resolvedMGPlays = std::move(_o.resolvedMGPlays);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::AutoPlayContextData::clear()
{
	numAutoPlaysRemainingToDisplay = 0;
	numAutoPlays = 0;
	singleWinThreshold = 0;
	totalLossesThreshold = 0;
	flags = 0;
	sideGameEntryMetaData.clear();
	pendingMGPlays.clear();
	startedMGPlays.clear();
	resolvedMGPlays.clear();
}

bool MiniGameClient::sidegame::AutoPlayContextData::equals(const AutoPlayContextData& _o) const
{
	return numAutoPlaysRemainingToDisplay == _o.numAutoPlaysRemainingToDisplay &&
		numAutoPlays == _o.numAutoPlays &&
		singleWinThreshold == _o.singleWinThreshold &&
		totalLossesThreshold == _o.totalLossesThreshold &&
		flags == _o.flags &&
		sideGameEntryMetaData.equals(_o.sideGameEntryMetaData) &&
		pendingMGPlays.equals(_o.pendingMGPlays) &&
		startedMGPlays.equals(_o.startedMGPlays) &&
		resolvedMGPlays.equals(_o.resolvedMGPlays);
}

const char *MiniGameClient::sidegame::AutoPlayContextData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("numAutoPlaysRemainingToDisplay=");
	_buf.appendInt(numAutoPlaysRemainingToDisplay);
	_buf.append(',');
	_buf.append("numAutoPlays=");
	_buf.appendInt(numAutoPlays);
	_buf.append(',');
	_buf.append("singleWinThreshold=");
	_buf.appendInt64(singleWinThreshold);
	_buf.append(',');
	_buf.append("totalLossesThreshold=");
	_buf.appendInt64(totalLossesThreshold);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("sideGameEntryMetaData=");
	sideGameEntryMetaData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("pendingMGPlays=");
	pendingMGPlays.toTraceString(_buf);
	_buf.append(',');
	_buf.append("startedMGPlays=");
	startedMGPlays.toTraceString(_buf);
	_buf.append(',');
	_buf.append("resolvedMGPlays=");
	resolvedMGPlays.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::AutoPlayContextData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay, _buf);
	Atf::XmlElement::encodeAsXmlElement("numAutoPlays", numAutoPlays, _buf);
	Atf::XmlElement::encodeAsXmlElement("singleWinThreshold", singleWinThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalLossesThreshold", totalLossesThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	sideGameEntryMetaData.toXmlString("sideGameEntryMetaData", _buf);
	pendingMGPlays.toXmlString("pendingMGPlays", _buf);
	startedMGPlays.toXmlString("startedMGPlays", _buf);
	resolvedMGPlays.toXmlString("resolvedMGPlays", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool MiniGameClient::sidegame::AutoPlayContextData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("numAutoPlaysRemainingToDisplay"))
		{
			numAutoPlaysRemainingToDisplay = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numAutoPlays"))
		{
			numAutoPlays = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("singleWinThreshold"))
		{
			singleWinThreshold = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("totalLossesThreshold"))
		{
			totalLossesThreshold = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("sideGameEntryMetaData"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< Atf::MsgBodyWithJSON, 4 > >::FromXmlString(_value, sideGameEntryMetaData)) return false;
		}
		else if (_element.equals("pendingMGPlays"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, pendingMGPlays)) return false;
		}
		else if (_element.equals("startedMGPlays"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, startedMGPlays)) return false;
		}
		else if (_element.equals("resolvedMGPlays"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT64, 4 > >::FromXmlString(_value, resolvedMGPlays)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void MiniGameClient::sidegame::AutoPlayContextData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(AutoPlayContextData())) // not empty
	{
		_body.composeINT8(numAutoPlaysRemainingToDisplay);
		_body.composeINT8(numAutoPlays);
		_body.composeINT64(singleWinThreshold);
		_body.composeINT64(totalLossesThreshold);
		_body.composeUINT32(flags);
		sideGameEntryMetaData.composeMsg(_body, _ignoreJSON);
		pendingMGPlays.composeMsg(_body, _ignoreJSON);
		startedMGPlays.composeMsg(_body, _ignoreJSON);
		resolvedMGPlays.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void MiniGameClient::sidegame::AutoPlayContextData::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT8(numAutoPlaysRemainingToDisplay);
	_parser0.parseINT8(numAutoPlays);
	_parser0.parseINT64(singleWinThreshold);
	_parser0.parseINT64(totalLossesThreshold);
	_parser0.parseUINT32(flags);
	sideGameEntryMetaData.parseMsg(_parser0);
	pendingMGPlays.parseMsg(_parser0);
	startedMGPlays.parseMsg(_parser0);
	resolvedMGPlays.parseMsg(_parser0);
}

const char *MiniGameClient::sidegame::AutoPlayContextData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay);
	_jsonstr.compose("numAutoPlays", numAutoPlays);
	_jsonstr.compose("singleWinThreshold", singleWinThreshold);
	_jsonstr.compose("totalLossesThreshold", totalLossesThreshold);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("sideGameEntryMetaData", sideGameEntryMetaData);
	_jsonstr.compose("pendingMGPlays", pendingMGPlays);
	_jsonstr.compose("startedMGPlays", startedMGPlays);
	_jsonstr.compose("resolvedMGPlays", resolvedMGPlays);
	return _buf.c_str();
}

void MiniGameClient::sidegame::AutoPlayContextData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay);
	_jparser.parseByNameThrow("numAutoPlays", numAutoPlays);
	_jparser.parseByNameThrow("singleWinThreshold", singleWinThreshold);
	_jparser.parseByNameThrow("totalLossesThreshold", totalLossesThreshold);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("sideGameEntryMetaData", sideGameEntryMetaData);
	_jparser.parseByNameThrow("pendingMGPlays", pendingMGPlays);
	_jparser.parseByNameThrow("startedMGPlays", startedMGPlays);
	_jparser.parseByNameThrow("resolvedMGPlays", resolvedMGPlays);
}

/* static */ void MiniGameClient::sidegame::AutoPlayContextData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 numAutoPlaysRemainingToDisplay; _jparser.validateByNameThrow("numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay);
	AtfValidator::validateInt(_descr, "numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay, _checker, __FILE__, __LINE__);
	INT8 numAutoPlays; _jparser.validateByNameThrow("numAutoPlays", numAutoPlays);
	AtfValidator::validateInt(_descr, "numAutoPlays", numAutoPlays, _checker, __FILE__, __LINE__);
	INT64 singleWinThreshold; _jparser.validateByNameThrow("singleWinThreshold", singleWinThreshold);
	AtfValidator::validateInt(_descr, "singleWinThreshold", singleWinThreshold, _checker, __FILE__, __LINE__);
	INT64 totalLossesThreshold; _jparser.validateByNameThrow("totalLossesThreshold", totalLossesThreshold);
	AtfValidator::validateInt(_descr, "totalLossesThreshold", totalLossesThreshold, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Atf::MsgBodyWithJSON > sideGameEntryMetaData; _jparser.validateByNameThrow("sideGameEntryMetaData", sideGameEntryMetaData);
	AtfValidator::validateInt(_descr, "sideGameEntryMetaData", sideGameEntryMetaData.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT64 > pendingMGPlays; _jparser.validateByNameThrow("pendingMGPlays", pendingMGPlays);
	AtfValidator::validateInt(_descr, "pendingMGPlays", pendingMGPlays.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT64 > startedMGPlays; _jparser.validateByNameThrow("startedMGPlays", startedMGPlays);
	AtfValidator::validateInt(_descr, "startedMGPlays", startedMGPlays.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT64 > resolvedMGPlays; _jparser.validateByNameThrow("resolvedMGPlays", resolvedMGPlays);
	AtfValidator::validateInt(_descr, "resolvedMGPlays", resolvedMGPlays.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::AutoPlayContextData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT8 numAutoPlaysRemainingToDisplay; _parser0.parseINT8(numAutoPlaysRemainingToDisplay);
	AtfValidator::validateInt(_descr, "numAutoPlaysRemainingToDisplay", numAutoPlaysRemainingToDisplay, _checker, __FILE__, __LINE__);
	INT8 numAutoPlays; _parser0.parseINT8(numAutoPlays);
	AtfValidator::validateInt(_descr, "numAutoPlays", numAutoPlays, _checker, __FILE__, __LINE__);
	INT64 singleWinThreshold; _parser0.parseINT64(singleWinThreshold);
	AtfValidator::validateInt(_descr, "singleWinThreshold", singleWinThreshold, _checker, __FILE__, __LINE__);
	INT64 totalLossesThreshold; _parser0.parseINT64(totalLossesThreshold);
	AtfValidator::validateInt(_descr, "totalLossesThreshold", totalLossesThreshold, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szSideGameEntryMetaData = Atf::LAtfVector< Atf::MsgBodyWithJSON, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("sideGameEntryMetaData"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "sideGameEntryMetaData", szSideGameEntryMetaData, _checker, __FILE__, __LINE__);
	int szPendingMGPlays = Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("pendingMGPlays"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "pendingMGPlays", szPendingMGPlays, _checker, __FILE__, __LINE__);
	int szStartedMGPlays = Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("startedMGPlays"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "startedMGPlays", szStartedMGPlays, _checker, __FILE__, __LINE__);
	int szResolvedMGPlays = Atf::LAtfVector< UINT64, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("resolvedMGPlays"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "resolvedMGPlays", szResolvedMGPlays, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_AUTOPLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::Protocol_SIDEGAME_MSG_START_AUTOPLAY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::Protocol_SIDEGAME_MSG_START_AUTOPLAY(Protocol_SIDEGAME_MSG_START_AUTOPLAY&& _o)
	: requestId(std::move(_o.requestId))
	, sideGameContext(std::move(_o.sideGameContext))
	, minigameEntryMode(std::move(_o.minigameEntryMode))
	, minigameEntryRefId(std::move(_o.minigameEntryRefId))
	, numAutoPlays(std::move(_o.numAutoPlays))
	, singleWinThreshold(std::move(_o.singleWinThreshold))
	, totalLossesThreshold(std::move(_o.totalLossesThreshold))
	, flags(std::move(_o.flags))
	, sideGameEntryMetaData(std::move(_o.sideGameEntryMetaData))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::operator=(Protocol_SIDEGAME_MSG_START_AUTOPLAY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		sideGameContext = std::move(_o.sideGameContext);
		minigameEntryMode = std::move(_o.minigameEntryMode);
		minigameEntryRefId = std::move(_o.minigameEntryRefId);
		numAutoPlays = std::move(_o.numAutoPlays);
		singleWinThreshold = std::move(_o.singleWinThreshold);
		totalLossesThreshold = std::move(_o.totalLossesThreshold);
		flags = std::move(_o.flags);
		sideGameEntryMetaData = std::move(_o.sideGameEntryMetaData);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::clear()
{
	requestId = 0;
	sideGameContext.clear();
	minigameEntryMode = 0;
	minigameEntryRefId = 0;
	numAutoPlays = 0;
	singleWinThreshold = 0;
	totalLossesThreshold = 0;
	flags = 0;
	sideGameEntryMetaData.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::equals(const Protocol_SIDEGAME_MSG_START_AUTOPLAY& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext) &&
		minigameEntryMode == _o.minigameEntryMode &&
		minigameEntryRefId == _o.minigameEntryRefId &&
		numAutoPlays == _o.numAutoPlays &&
		singleWinThreshold == _o.singleWinThreshold &&
		totalLossesThreshold == _o.totalLossesThreshold &&
		flags == _o.flags &&
		sideGameEntryMetaData.equals(_o.sideGameEntryMetaData);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_START_AUTOPLAY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_START_AUTOPLAY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_AUTOPLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	_buf.append(',');
	_buf.append("minigameEntryMode=");
	_buf.appendInt(minigameEntryMode);
	_buf.append(',');
	_buf.append("minigameEntryRefId=");
	_buf.appendUint64(minigameEntryRefId);
	_buf.append(',');
	_buf.append("numAutoPlays=");
	_buf.appendInt(numAutoPlays);
	_buf.append(',');
	_buf.append("singleWinThreshold=");
	_buf.appendInt64(singleWinThreshold);
	_buf.append(',');
	_buf.append("totalLossesThreshold=");
	_buf.appendInt64(totalLossesThreshold);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("sideGameEntryMetaData=");
	sideGameEntryMetaData.toTraceString(_buf);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_START_AUTOPLAY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	sideGameContext.toXmlString("sideGameContext", _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameEntryMode", minigameEntryMode, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameEntryRefId", minigameEntryRefId, _buf);
	Atf::XmlElement::encodeAsXmlElement("numAutoPlays", numAutoPlays, _buf);
	Atf::XmlElement::encodeAsXmlElement("singleWinThreshold", singleWinThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("totalLossesThreshold", totalLossesThreshold, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	sideGameEntryMetaData.toXmlString("sideGameEntryMetaData", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sideGameContext"))
			{
				if(!Atf::AtfTempl< SideGameContext >::FromXmlString(_value, sideGameContext)) return false;
			}
			else if (_element.equals("minigameEntryMode"))
			{
				minigameEntryMode = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameEntryRefId"))
			{
				minigameEntryRefId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numAutoPlays"))
			{
				numAutoPlays = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("singleWinThreshold"))
			{
				singleWinThreshold = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("totalLossesThreshold"))
			{
				totalLossesThreshold = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sideGameEntryMetaData"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Atf::MsgBodyWithJSON, 4 > >::FromXmlString(_value, sideGameEntryMetaData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg, _ignoreJSON);
	_msg.composeINT8(minigameEntryMode);
	_msg.composeUINT64(minigameEntryRefId);
	_msg.composeINT8(numAutoPlays);
	_msg.composeINT64(singleWinThreshold);
	_msg.composeINT64(totalLossesThreshold);
	_msg.composeUINT32(flags);
	sideGameEntryMetaData.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
	_parser.parseINT8(minigameEntryMode);
	_parser.parseUINT64(minigameEntryRefId);
	_parser.parseINT8(numAutoPlays);
	_parser.parseINT64(singleWinThreshold);
	_parser.parseINT64(totalLossesThreshold);
	_parser.parseUINT32(flags);
	sideGameEntryMetaData.parseMsg(_parser);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("sideGameContext", sideGameContext);
	_jsonstr.compose("minigameEntryMode", minigameEntryMode);
	_jsonstr.compose("minigameEntryRefId", minigameEntryRefId);
	_jsonstr.compose("numAutoPlays", numAutoPlays);
	_jsonstr.compose("singleWinThreshold", singleWinThreshold);
	_jsonstr.compose("totalLossesThreshold", totalLossesThreshold);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("sideGameEntryMetaData", sideGameEntryMetaData);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("sideGameContext", sideGameContext);
	_jparser.parseByNameThrow("minigameEntryMode", minigameEntryMode);
	_jparser.parseByNameThrow("minigameEntryRefId", minigameEntryRefId);
	_jparser.parseByNameThrow("numAutoPlays", numAutoPlays);
	_jparser.parseByNameThrow("singleWinThreshold", singleWinThreshold);
	_jparser.parseByNameThrow("totalLossesThreshold", totalLossesThreshold);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("sideGameEntryMetaData", sideGameEntryMetaData);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	SideGameContext sideGameContext; _jparser.validateByNameThrow("sideGameContext", sideGameContext);
	INT8 minigameEntryMode; _jparser.validateByNameThrow("minigameEntryMode", minigameEntryMode);
	AtfValidator::validateIntRange(_descr, "minigameEntryMode", minigameEntryMode, sidegame::eSideGameEntryMode_Normal, sidegame::eSideGameEntryMode_Max, _checker, __FILE__, __LINE__);
	UINT64 minigameEntryRefId; _jparser.validateByNameThrow("minigameEntryRefId", minigameEntryRefId);
	AtfValidator::validateUint(_descr, "minigameEntryRefId", minigameEntryRefId, _checker, __FILE__, __LINE__);
	INT8 numAutoPlays; _jparser.validateByNameThrow("numAutoPlays", numAutoPlays);
	AtfValidator::validateInt(_descr, "numAutoPlays", numAutoPlays, _checker, __FILE__, __LINE__);
	INT64 singleWinThreshold; _jparser.validateByNameThrow("singleWinThreshold", singleWinThreshold);
	AtfValidator::validateInt(_descr, "singleWinThreshold", singleWinThreshold, _checker, __FILE__, __LINE__);
	INT64 totalLossesThreshold; _jparser.validateByNameThrow("totalLossesThreshold", totalLossesThreshold);
	AtfValidator::validateInt(_descr, "totalLossesThreshold", totalLossesThreshold, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< Atf::MsgBodyWithJSON > sideGameEntryMetaData; _jparser.validateByNameThrow("sideGameEntryMetaData", sideGameEntryMetaData);
	AtfValidator::validateIntMax(_descr, "sideGameEntryMetaData", sideGameEntryMetaData.size(), 1024, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	INT8 minigameEntryMode; _parser.parseINT8(minigameEntryMode);
	AtfValidator::validateIntRange(_descr, "minigameEntryMode", minigameEntryMode, sidegame::eSideGameEntryMode_Normal, sidegame::eSideGameEntryMode_Max, _checker, __FILE__, __LINE__);
	UINT64 minigameEntryRefId; _parser.parseUINT64(minigameEntryRefId);
	AtfValidator::validateUint(_descr, "minigameEntryRefId", minigameEntryRefId, _checker, __FILE__, __LINE__);
	INT8 numAutoPlays; _parser.parseINT8(numAutoPlays);
	AtfValidator::validateInt(_descr, "numAutoPlays", numAutoPlays, _checker, __FILE__, __LINE__);
	INT64 singleWinThreshold; _parser.parseINT64(singleWinThreshold);
	AtfValidator::validateInt(_descr, "singleWinThreshold", singleWinThreshold, _checker, __FILE__, __LINE__);
	INT64 totalLossesThreshold; _parser.parseINT64(totalLossesThreshold);
	AtfValidator::validateInt(_descr, "totalLossesThreshold", totalLossesThreshold, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	int szSideGameEntryMetaData = Atf::LAtfVector< Atf::MsgBodyWithJSON, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameEntryMetaData"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "sideGameEntryMetaData", szSideGameEntryMetaData, 1024, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, autoPlayContextData(std::move(_o.autoPlayContextData))
	, orphanedAutoPlayContextData(std::move(_o.orphanedAutoPlayContextData))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		autoPlayContextData = std::move(_o.autoPlayContextData);
		orphanedAutoPlayContextData = std::move(_o.orphanedAutoPlayContextData);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	autoPlayContextData.clear();
	orphanedAutoPlayContextData.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		autoPlayContextData.equals(_o.autoPlayContextData) &&
		orphanedAutoPlayContextData.equals(_o.orphanedAutoPlayContextData);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_START_AUTOPLAY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_START_AUTOPLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("autoPlayContextData=");
		autoPlayContextData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("orphanedAutoPlayContextData=");
		orphanedAutoPlayContextData.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_START_AUTOPLAY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		autoPlayContextData.toXmlString("autoPlayContextData", _buf);
		orphanedAutoPlayContextData.toXmlString("orphanedAutoPlayContextData", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("autoPlayContextData"))
			{
				if(!Atf::AtfTempl< AutoPlayContextData >::FromXmlString(_value, autoPlayContextData)) return false;
			}
			else if (_element.equals("orphanedAutoPlayContextData"))
			{
				if(!Atf::AtfTempl< AutoPlayContextData >::FromXmlString(_value, orphanedAutoPlayContextData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		autoPlayContextData.composeMsg(_msg, _ignoreJSON);
		orphanedAutoPlayContextData.composeMsg(_msg, _ignoreJSON);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		autoPlayContextData.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		orphanedAutoPlayContextData.parseMsg(_parser);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("autoPlayContextData", autoPlayContextData);
		_jsonstr.compose("orphanedAutoPlayContextData", orphanedAutoPlayContextData);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("autoPlayContextData", autoPlayContextData);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("orphanedAutoPlayContextData", orphanedAutoPlayContextData);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		AutoPlayContextData autoPlayContextData; _jparser.validateByNameThrow("autoPlayContextData", autoPlayContextData);
		if(_jparser.parseEnded()) return;
		AutoPlayContextData orphanedAutoPlayContextData; _jparser.validateByNameThrow("orphanedAutoPlayContextData", orphanedAutoPlayContextData);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_START_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		AutoPlayContextData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("autoPlayContextData"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		AutoPlayContextData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("orphanedAutoPlayContextData"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_STOP_AUTOPLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::clear()
{
	requestId = 0;
	sideGameContext.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::equals(const Protocol_SIDEGAME_MSG_STOP_AUTOPLAY& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_STOP_AUTOPLAY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_STOP_AUTOPLAY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_STOP_AUTOPLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_STOP_AUTOPLAY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	sideGameContext.toXmlString("sideGameContext", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sideGameContext"))
			{
				if(!Atf::AtfTempl< SideGameContext >::FromXmlString(_value, sideGameContext)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("sideGameContext", sideGameContext);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("sideGameContext", sideGameContext);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_STOP_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	SideGameContext sideGameContext; _jparser.validateByNameThrow("sideGameContext", sideGameContext);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_STOP_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, numPendingGamesCanceled(std::move(_o.numPendingGamesCanceled))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		numPendingGamesCanceled = std::move(_o.numPendingGamesCanceled);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	numPendingGamesCanceled = 0;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		numPendingGamesCanceled == _o.numPendingGamesCanceled;
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_STOP_AUTOPLAY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_STOP_AUTOPLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("numPendingGamesCanceled=");
		_buf.appendInt(numPendingGamesCanceled);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_STOP_AUTOPLAY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("numPendingGamesCanceled", numPendingGamesCanceled, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("numPendingGamesCanceled"))
			{
				numPendingGamesCanceled = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeINT8(numPendingGamesCanceled);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseINT8(numPendingGamesCanceled);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("numPendingGamesCanceled", numPendingGamesCanceled);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("numPendingGamesCanceled", numPendingGamesCanceled);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_STOP_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT8 numPendingGamesCanceled; _jparser.validateByNameThrow("numPendingGamesCanceled", numPendingGamesCanceled);
		AtfValidator::validateInt(_descr, "numPendingGamesCanceled", numPendingGamesCanceled, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_STOP_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT8 numPendingGamesCanceled; _parser.parseINT8(numPendingGamesCanceled);
		AtfValidator::validateInt(_descr, "numPendingGamesCanceled", numPendingGamesCanceled, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_AUTOPLAY_STATE
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::clear()
{
	requestId = 0;
	sideGameContext.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::equals(const Protocol_SIDEGAME_MSG_AUTOPLAY_STATE& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_AUTOPLAY_STATE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_AUTOPLAY_STATE*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_AUTOPLAY_STATE).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_AUTOPLAY_STATE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	sideGameContext.toXmlString("sideGameContext", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sideGameContext"))
			{
				if(!Atf::AtfTempl< SideGameContext >::FromXmlString(_value, sideGameContext)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("sideGameContext", sideGameContext);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("sideGameContext", sideGameContext);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_AUTOPLAY_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	SideGameContext sideGameContext; _jparser.validateByNameThrow("sideGameContext", sideGameContext);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_AUTOPLAY_STATE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY(Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, autoPlayContextData(std::move(_o.autoPlayContextData))
	, orphanedAutoPlayContextData(std::move(_o.orphanedAutoPlayContextData))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::operator=(Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		autoPlayContextData = std::move(_o.autoPlayContextData);
		orphanedAutoPlayContextData = std::move(_o.orphanedAutoPlayContextData);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	autoPlayContextData.clear();
	orphanedAutoPlayContextData.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::equals(const Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		autoPlayContextData.equals(_o.autoPlayContextData) &&
		orphanedAutoPlayContextData.equals(_o.orphanedAutoPlayContextData);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_AUTOPLAY_STATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_AUTOPLAY_STATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("autoPlayContextData=");
		autoPlayContextData.toTraceString(_buf);
		_buf.append(',');
		_buf.append("orphanedAutoPlayContextData=");
		orphanedAutoPlayContextData.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_AUTOPLAY_STATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		autoPlayContextData.toXmlString("autoPlayContextData", _buf);
		orphanedAutoPlayContextData.toXmlString("orphanedAutoPlayContextData", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("autoPlayContextData"))
			{
				if(!Atf::AtfTempl< AutoPlayContextData >::FromXmlString(_value, autoPlayContextData)) return false;
			}
			else if (_element.equals("orphanedAutoPlayContextData"))
			{
				if(!Atf::AtfTempl< AutoPlayContextData >::FromXmlString(_value, orphanedAutoPlayContextData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		autoPlayContextData.composeMsg(_msg, _ignoreJSON);
		orphanedAutoPlayContextData.composeMsg(_msg, _ignoreJSON);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		autoPlayContextData.parseMsg(_parser);
		if(_parser.parseEnded()) return;
		orphanedAutoPlayContextData.parseMsg(_parser);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("autoPlayContextData", autoPlayContextData);
		_jsonstr.compose("orphanedAutoPlayContextData", orphanedAutoPlayContextData);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("autoPlayContextData", autoPlayContextData);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("orphanedAutoPlayContextData", orphanedAutoPlayContextData);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_AUTOPLAY_STATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		AutoPlayContextData autoPlayContextData; _jparser.validateByNameThrow("autoPlayContextData", autoPlayContextData);
		if(_jparser.parseEnded()) return;
		AutoPlayContextData orphanedAutoPlayContextData; _jparser.validateByNameThrow("orphanedAutoPlayContextData", orphanedAutoPlayContextData);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_AUTOPLAY_STATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		AutoPlayContextData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("autoPlayContextData"), _fieldsWithUnparsedContent);
		if(_parser.parseEnded()) return;
		AutoPlayContextData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("orphanedAutoPlayContextData"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::clear()
{
	requestId = 0;
	sideGameContext.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::equals(const Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_REPLAY_AUTOPLAY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_REPLAY_AUTOPLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_REPLAY_AUTOPLAY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	sideGameContext.toXmlString("sideGameContext", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sideGameContext"))
			{
				if(!Atf::AtfTempl< SideGameContext >::FromXmlString(_value, sideGameContext)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("sideGameContext", sideGameContext);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("sideGameContext", sideGameContext);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_REPLAY_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	SideGameContext sideGameContext; _jparser.validateByNameThrow("sideGameContext", sideGameContext);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_REPLAY_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY()
{
	clear();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::clear()
{
	requestId = 0;
	sideGameContext.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::equals(const Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY& _o) const
{
	return requestId == _o.requestId &&
		sideGameContext.equals(_o.sideGameContext);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("sideGameContext=");
	sideGameContext.toTraceString(_buf);
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	sideGameContext.toXmlString("sideGameContext", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sideGameContext"))
			{
				if(!Atf::AtfTempl< SideGameContext >::FromXmlString(_value, sideGameContext)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	sideGameContext.composeMsg(_msg, _ignoreJSON);
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	sideGameContext.parseMsg(_parser);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("sideGameContext", sideGameContext);
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("sideGameContext", sideGameContext);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	SideGameContext sideGameContext; _jparser.validateByNameThrow("sideGameContext", sideGameContext);
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	SideGameContext::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("sideGameContext"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY
//=================================================================

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY(Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
{
}

MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY& MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::operator=(Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
	}
	return *this;
}

#endif

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::equals(const Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr);
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY*)_other));
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	return _buf.c_str();
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
}

const char *MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	return _buf.c_str();
}

void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW&& _o)
	: requestId(std::move(_o.requestId))
	, userIntId(std::move(_o.userIntId))
	, brandId(std::move(_o.brandId))
	, clientSiteId(std::move(_o.clientSiteId))
	, minigameId(std::move(_o.minigameId))
	, ticketId(std::move(_o.ticketId))
	, headerImageURL(std::move(_o.headerImageURL))
	, ticketTypeName(std::move(_o.ticketTypeName))
	, playsAvailable(std::move(_o.playsAvailable))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW& MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::operator=(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		userIntId = std::move(_o.userIntId);
		brandId = std::move(_o.brandId);
		clientSiteId = std::move(_o.clientSiteId);
		minigameId = std::move(_o.minigameId);
		ticketId = std::move(_o.ticketId);
		headerImageURL = std::move(_o.headerImageURL);
		ticketTypeName = std::move(_o.ticketTypeName);
		playsAvailable = std::move(_o.playsAvailable);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::clear()
{
	requestId = 0;
	userIntId = 0;
	brandId = 0;
	clientSiteId = 0;
	minigameId = 0;
	ticketId = 0;
	headerImageURL.clear();
	ticketTypeName.clear();
	playsAvailable = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::equals(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW& _o) const
{
	return requestId == _o.requestId &&
		userIntId == _o.userIntId &&
		brandId == _o.brandId &&
		clientSiteId == _o.clientSiteId &&
		minigameId == _o.minigameId &&
		ticketId == _o.ticketId &&
		Atf::atfPStringEquals(headerImageURL, _o.headerImageURL) &&
		Atf::atfPStringEquals(ticketTypeName, _o.ticketTypeName) &&
		playsAvailable == _o.playsAvailable;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("clientSiteId=");
	_buf.appendUint(clientSiteId);
	_buf.append(',');
	_buf.append("minigameId=");
	_buf.appendUint(minigameId);
	_buf.append(',');
	_buf.append("ticketId=");
	_buf.appendUint64(ticketId);
	_buf.append(',');
	_buf.append("headerImageURL=");
	_buf.append(headerImageURL);
	_buf.append(',');
	_buf.append("ticketTypeName=");
	_buf.append(ticketTypeName);
	_buf.append(',');
	_buf.append("playsAvailable=");
	_buf.appendInt(playsAvailable);
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientSiteId", clientSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("headerImageURL", headerImageURL, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketTypeName", ticketTypeName, _buf);
	Atf::XmlElement::encodeAsXmlElement("playsAvailable", playsAvailable, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("brandId"))
			{
				brandId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientSiteId"))
			{
				clientSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("minigameId"))
			{
				minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("ticketId"))
			{
				ticketId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("headerImageURL"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, headerImageURL)) return false;
			}
			else if (_element.equals("ticketTypeName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ticketTypeName)) return false;
			}
			else if (_element.equals("playsAvailable"))
			{
				playsAvailable = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeUINT32(userIntId);
	_msg.composeUINT32(brandId);
	_msg.composeUINT32(clientSiteId);
	_msg.composeUINT32(minigameId);
	_msg.composeUINT64(ticketId);
	_msg.composeString(headerImageURL);
	_msg.composeString(ticketTypeName);
	_msg.composeINT32(playsAvailable);
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseUINT32(userIntId);
	_parser.parseUINT32(brandId);
	_parser.parseUINT32(clientSiteId);
	_parser.parseUINT32(minigameId);
	_parser.parseUINT64(ticketId);
	_parser.parseStringP(headerImageURL);
	_parser.parseStringP(ticketTypeName);
	_parser.parseINT32(playsAvailable);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("clientSiteId", clientSiteId);
	_jsonstr.compose("minigameId", minigameId);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("headerImageURL", headerImageURL);
	_jsonstr.compose("ticketTypeName", ticketTypeName);
	_jsonstr.compose("playsAvailable", playsAvailable);
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("clientSiteId", clientSiteId);
	_jparser.parseByNameThrow("minigameId", minigameId);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("headerImageURL", headerImageURL);
	_jparser.parseByNameThrow("ticketTypeName", ticketTypeName);
	_jparser.parseByNameThrow("playsAvailable", playsAvailable);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _jparser.validateByNameThrow("clientSiteId", clientSiteId);
	AtfValidator::validateInt(_descr, "clientSiteId", clientSiteId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT64 ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateUint(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	PString headerImageURL; _jparser.validateByNameThrow("headerImageURL", headerImageURL);
	AtfValidator::validateInt(_descr, "headerImageURL", headerImageURL.length(), _checker, __FILE__, __LINE__);
	PString ticketTypeName; _jparser.validateByNameThrow("ticketTypeName", ticketTypeName);
	AtfValidator::validateInt(_descr, "ticketTypeName", ticketTypeName.length(), _checker, __FILE__, __LINE__);
	INT32 playsAvailable; _jparser.validateByNameThrow("playsAvailable", playsAvailable);
	AtfValidator::validateInt(_descr, "playsAvailable", playsAvailable, _checker, __FILE__, __LINE__);
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser.parseUINT32(brandId);
	AtfValidator::validateInt(_descr, "brandId", brandId, _checker, __FILE__, __LINE__);
	UINT32 clientSiteId; _parser.parseUINT32(clientSiteId);
	AtfValidator::validateInt(_descr, "clientSiteId", clientSiteId, _checker, __FILE__, __LINE__);
	UINT32 minigameId; _parser.parseUINT32(minigameId);
	AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
	UINT64 ticketId; _parser.parseUINT64(ticketId);
	AtfValidator::validateUint(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "headerImageURL"); size_t szHeaderImageURL = strlen(_dummy);
	AtfValidator::validateInt(_descr, "headerImageURL", szHeaderImageURL, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ticketTypeName"); size_t szTicketTypeName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketTypeName", szTicketTypeName, _checker, __FILE__, __LINE__);
	INT32 playsAvailable; _parser.parseINT32(playsAvailable);
	AtfValidator::validateInt(_descr, "playsAvailable", playsAvailable, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY
//=================================================================

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY&& _o)
	: requestId(std::move(_o.requestId))
	, errCode(std::move(_o.errCode))
	, errStr(std::move(_o.errStr))
	, minigameId(std::move(_o.minigameId))
	, drawTime(std::move(_o.drawTime))
	, userId(std::move(_o.userId))
	, userTimeZone(std::move(_o.userTimeZone))
	, userLocale(std::move(_o.userLocale))
	, playsAvailable(std::move(_o.playsAvailable))
{
}

MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY& MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::operator=(Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY&& _o)
{
	if(this != &_o)
	{
		requestId = std::move(_o.requestId);
		errCode = std::move(_o.errCode);
		errStr = std::move(_o.errStr);
		minigameId = std::move(_o.minigameId);
		drawTime = std::move(_o.drawTime);
		userId = std::move(_o.userId);
		userTimeZone = std::move(_o.userTimeZone);
		userLocale = std::move(_o.userLocale);
		playsAvailable = std::move(_o.playsAvailable);
	}
	return *this;
}

#endif

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::clear()
{
	requestId = 0;
	errCode = 0;
	errStr.clear();
	minigameId = 0;
	drawTime.setNull();
	userId.clear();
	userTimeZone = 0;
	userLocale = 0;
	playsAvailable = 0;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::equals(const Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY& _o) const
{
	return requestId == _o.requestId &&
		errCode == _o.errCode &&
		Atf::atfPStringEquals(errStr, _o.errStr) &&
		minigameId == _o.minigameId &&
		drawTime.equals(_o.drawTime) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		userTimeZone == _o.userTimeZone &&
		userLocale == _o.userLocale &&
		playsAvailable == _o.playsAvailable;
}

bool MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY*)_other));
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY).append(")");
	_buf.append(',');
	_buf.append("requestId=");
	_buf.appendInt64(requestId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("minigameId=");
		_buf.appendUint(minigameId);
		_buf.append(',');
		_buf.append("drawTime=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, drawTime);
		_buf.append(',');
		_buf.append("userId=");
		_buf.append(userId);
		_buf.append(',');
		_buf.append("userTimeZone=");
		_buf.appendUint(userTimeZone);
		_buf.append(',');
		_buf.append("userLocale=");
		_buf.appendUint(userLocale);
		_buf.append(',');
		_buf.append("playsAvailable=");
		_buf.appendInt(playsAvailable);
	}
	return _buf.c_str();
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("requestId", requestId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errStr", errStr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("minigameId", minigameId, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "drawTime", drawTime);
		Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
		Atf::XmlElement::encodeAsXmlElement("userTimeZone", userTimeZone, _buf);
		Atf::XmlElement::encodeAsXmlElement("userLocale", userLocale, _buf);
		Atf::XmlElement::encodeAsXmlElement("playsAvailable", playsAvailable, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("requestId"))
			{
				requestId = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errStr)) return false;
			}
			else if (_element.equals("minigameId"))
			{
				minigameId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("drawTime"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, drawTime);
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("userTimeZone"))
			{
				userTimeZone = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userLocale"))
			{
				userLocale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playsAvailable"))
			{
				playsAvailable = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT64(requestId);
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeUINT32(minigameId);
		_msg.composeSrvTime(drawTime);
		_msg.composeString(userId);
		_msg.composeUINT32(userTimeZone);
		_msg.composeUINT32(userLocale);
		_msg.composeINT32(playsAvailable);
	}
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT64(requestId);
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseUINT32(minigameId);
		_parser.parseSrvTime(drawTime);
		_parser.parseStringP(userId);
		_parser.parseUINT32(userTimeZone);
		_parser.parseUINT32(userLocale);
		_parser.parseINT32(playsAvailable);
	}
}

const char *MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("requestId", requestId);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errStr", errStr);
	}
	else
	{
		_jsonstr.compose("minigameId", minigameId);
		_jsonstr.compose("drawTime", drawTime);
		_jsonstr.compose("userId", userId);
		_jsonstr.compose("userTimeZone", userTimeZone);
		_jsonstr.compose("userLocale", userLocale);
		_jsonstr.compose("playsAvailable", playsAvailable);
	}
	return _buf.c_str();
}

void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("requestId", requestId);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errStr", errStr);
	}
	else
	{
		_jparser.parseByNameThrow("minigameId", minigameId);
		_jparser.parseByNameThrow("drawTime", drawTime);
		_jparser.parseByNameThrow("userId", userId);
		_jparser.parseByNameThrow("userTimeZone", userTimeZone);
		_jparser.parseByNameThrow("userLocale", userLocale);
		_jparser.parseByNameThrow("playsAvailable", playsAvailable);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	INT64 requestId; _jparser.validateByNameThrow("requestId", requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errStr; _jparser.validateByNameThrow("errStr", errStr);
		AtfValidator::validateInt(_descr, "errStr", errStr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 minigameId; _jparser.validateByNameThrow("minigameId", minigameId);
		AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
		SrvTime drawTime; _jparser.validateByNameThrow("drawTime", drawTime);
		AtfValidator::validateSrvDateTime(_descr, "drawTime", drawTime, _checker, __FILE__, __LINE__);
		PString userId; _jparser.validateByNameThrow("userId", userId);
		AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
		UINT32 userTimeZone; _jparser.validateByNameThrow("userTimeZone", userTimeZone);
		AtfValidator::validateInt(_descr, "userTimeZone", userTimeZone, _checker, __FILE__, __LINE__);
		UINT32 userLocale; _jparser.validateByNameThrow("userLocale", userLocale);
		AtfValidator::validateInt(_descr, "userLocale", userLocale, _checker, __FILE__, __LINE__);
		INT32 playsAvailable; _jparser.validateByNameThrow("playsAvailable", playsAvailable);
		AtfValidator::validateInt(_descr, "playsAvailable", playsAvailable, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void MiniGameClient::Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	INT64 requestId; _parser.parseINT64(requestId);
	AtfValidator::validateInt(_descr, "requestId", requestId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 minigameId; _parser.parseUINT32(minigameId);
		AtfValidator::validateInt(_descr, "minigameId", minigameId, _checker, __FILE__, __LINE__);
		SrvTime drawTime; _parser.parseSrvTime(drawTime);
		AtfValidator::validateSrvDateTime(_descr, "drawTime", drawTime, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
		UINT32 userTimeZone; _parser.parseUINT32(userTimeZone);
		AtfValidator::validateInt(_descr, "userTimeZone", userTimeZone, _checker, __FILE__, __LINE__);
		UINT32 userLocale; _parser.parseUINT32(userLocale);
		AtfValidator::validateInt(_descr, "userLocale", userLocale, _checker, __FILE__, __LINE__);
		INT32 playsAvailable; _parser.parseINT32(playsAvailable);
		AtfValidator::validateInt(_descr, "playsAvailable", playsAvailable, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* MiniGameClient::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MINIGAME_MSG_ACTIVE_GAMES: _obj = new Protocol_MINIGAME_MSG_ACTIVE_GAMES(); break;
			case MINIGAME_MSG_ACTIVE_GAMES_REPLY: _obj = new Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY(); break;
			case MINIGAME_MSG_GAME_STATE: _obj = new Protocol_MINIGAME_MSG_GAME_STATE(); break;
			case MINIGAME_MSG_GAME_STATE_REPLY: _obj = new Protocol_MINIGAME_MSG_GAME_STATE_REPLY(); break;
			case MINIGAME_MSG_GET_STACKED_TICKETS: _obj = new Protocol_MINIGAME_MSG_GET_STACKED_TICKETS(); break;
			case MINIGAME_MSG_GET_STACKED_TICKETS_REPLY: _obj = new Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY(); break;
			case MINIGAME_MSG_GET_TICKETS: _obj = new Protocol_MINIGAME_MSG_GET_TICKETS(); break;
			case MINIGAME_MSG_GET_TICKETS_REPLY: _obj = new Protocol_MINIGAME_MSG_GET_TICKETS_REPLY(); break;
			case MINIGAME_MSG_PLAY_NEXT_ROUND: _obj = new Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND(); break;
			case MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW: _obj = new Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW(); break;
			case MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY: _obj = new Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY(); break;
			case MINIGAME_MSG_SERVER_RESTARTING: _obj = new Protocol_MINIGAME_MSG_SERVER_RESTARTING(); break;
			case MINIGAME_MSG_START_GAME: _obj = new Protocol_MINIGAME_MSG_START_GAME(); break;
			case MINIGAME_MSG_START_GAME_REPLY: _obj = new Protocol_MINIGAME_MSG_START_GAME_REPLY(); break;
			case MINIGAME_MSG_TICKET_LOOKUP: _obj = new Protocol_MINIGAME_MSG_TICKET_LOOKUP(); break;
			case MINIGAME_MSG_TICKET_LOOKUP_REPLY: _obj = new Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "client"))
	{
		switch(_msgId)
		{
			case SIDEGAME_MSG_TRIGGER_ANIMATION: _obj = new client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION(); break;
			case SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER: _obj = new client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER(); break;
			case SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER: _obj = new client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER(); break;
		}
	}
	else if(!strcmp(_nameSpace, "sidegame"))
	{
		switch(_msgId)
		{
			case SIDEGAME_MSG_ACTIVE_GAMES: _obj = new sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES(); break;
			case SIDEGAME_MSG_ACTIVE_GAMES_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY(); break;
			case SIDEGAME_MSG_AUTOPLAY_STATE: _obj = new sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE(); break;
			case SIDEGAME_MSG_AUTOPLAY_STATE_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY(); break;
			case SIDEGAME_MSG_CANCEL_PLAY: _obj = new sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY(); break;
			case SIDEGAME_MSG_CANCEL_PLAY_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY(); break;
			case SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY: _obj = new sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY(); break;
			case SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY(); break;
			case SIDEGAME_MSG_CLAIM_PRIZE: _obj = new sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE(); break;
			case SIDEGAME_MSG_CLAIM_PRIZE_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY(); break;
			case SIDEGAME_MSG_FORFEIT: _obj = new sidegame::Protocol_SIDEGAME_MSG_FORFEIT(); break;
			case SIDEGAME_MSG_FORFEIT_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY(); break;
			case SIDEGAME_MSG_GAME_DEF: _obj = new sidegame::Protocol_SIDEGAME_MSG_GAME_DEF(); break;
			case SIDEGAME_MSG_GAME_DEF_LOCALIZED: _obj = new sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED(); break;
			case SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY(); break;
			case SIDEGAME_MSG_GAME_DEF_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY(); break;
			case SIDEGAME_MSG_GAME_STATE: _obj = new sidegame::Protocol_SIDEGAME_MSG_GAME_STATE(); break;
			case SIDEGAME_MSG_GAME_STATE_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY(); break;
			case SIDEGAME_MSG_GET_RING_SESSIONID: _obj = new sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID(); break;
			case SIDEGAME_MSG_GET_RING_SESSIONID_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY(); break;
			case SIDEGAME_MSG_GET_STARSREWARDS_BAR: _obj = new sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR(); break;
			case SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY(); break;
			case SIDEGAME_MSG_GET_TICKET_BALANCE: _obj = new sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE(); break;
			case SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY(); break;
			case SIDEGAME_MSG_HISTORIC_GAMES: _obj = new sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES(); break;
			case SIDEGAME_MSG_HISTORIC_GAMES_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY(); break;
			case SIDEGAME_MSG_MAX_GAMES_REACHED: _obj = new sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED(); break;
			case SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY(); break;
			case SIDEGAME_MSG_REPLAY_AUTOPLAY: _obj = new sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY(); break;
			case SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY(); break;
			case SIDEGAME_MSG_SKIP_DELAY: _obj = new sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY(); break;
			case SIDEGAME_MSG_START_AUTOPLAY: _obj = new sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY(); break;
			case SIDEGAME_MSG_START_AUTOPLAY_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY(); break;
			case SIDEGAME_MSG_START_GAME: _obj = new sidegame::Protocol_SIDEGAME_MSG_START_GAME(); break;
			case SIDEGAME_MSG_START_GAME_NEW: _obj = new sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW(); break;
			case SIDEGAME_MSG_START_GAME_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY(); break;
			case SIDEGAME_MSG_STOP_AUTOPLAY: _obj = new sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY(); break;
			case SIDEGAME_MSG_STOP_AUTOPLAY_REPLY: _obj = new sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool MiniGameClient::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MINIGAME_MSG_ACTIVE_GAMES: Protocol_MINIGAME_MSG_ACTIVE_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_ACTIVE_GAMES_REPLY: Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GAME_STATE: Protocol_MINIGAME_MSG_GAME_STATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GAME_STATE_REPLY: Protocol_MINIGAME_MSG_GAME_STATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_STACKED_TICKETS: Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_STACKED_TICKETS_REPLY: Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_TICKETS: Protocol_MINIGAME_MSG_GET_TICKETS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_TICKETS_REPLY: Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_PLAY_NEXT_ROUND: Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW: Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY: Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_SERVER_RESTARTING: Protocol_MINIGAME_MSG_SERVER_RESTARTING::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_START_GAME: Protocol_MINIGAME_MSG_START_GAME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_START_GAME_REPLY: Protocol_MINIGAME_MSG_START_GAME_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_TICKET_LOOKUP: Protocol_MINIGAME_MSG_TICKET_LOOKUP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_TICKET_LOOKUP_REPLY: Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "client"))
	{
		switch(_msgId)
		{
			case SIDEGAME_MSG_TRIGGER_ANIMATION: client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER: client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER: client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "sidegame"))
	{
		switch(_msgId)
		{
			case SIDEGAME_MSG_ACTIVE_GAMES: sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_ACTIVE_GAMES_REPLY: sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_AUTOPLAY_STATE: sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_AUTOPLAY_STATE_REPLY: sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_PLAY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_PLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CLAIM_PRIZE: sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CLAIM_PRIZE_REPLY: sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_FORFEIT: sidegame::Protocol_SIDEGAME_MSG_FORFEIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_FORFEIT_REPLY: sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF_LOCALIZED: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF_REPLY: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_STATE: sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_STATE_REPLY: sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_RING_SESSIONID: sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_RING_SESSIONID_REPLY: sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_STARSREWARDS_BAR: sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY: sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_TICKET_BALANCE: sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY: sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_HISTORIC_GAMES: sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_HISTORIC_GAMES_REPLY: sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_MAX_GAMES_REACHED: sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY: sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_REPLAY_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_SKIP_DELAY: sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_GAME: sidegame::Protocol_SIDEGAME_MSG_START_GAME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_GAME_NEW: sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_GAME_REPLY: sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_STOP_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_STOP_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool MiniGameClient::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, ""))
	{
		switch(_msgId)
		{
			case MINIGAME_MSG_ACTIVE_GAMES: Protocol_MINIGAME_MSG_ACTIVE_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_ACTIVE_GAMES_REPLY: Protocol_MINIGAME_MSG_ACTIVE_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GAME_STATE: Protocol_MINIGAME_MSG_GAME_STATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GAME_STATE_REPLY: Protocol_MINIGAME_MSG_GAME_STATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_STACKED_TICKETS: Protocol_MINIGAME_MSG_GET_STACKED_TICKETS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_STACKED_TICKETS_REPLY: Protocol_MINIGAME_MSG_GET_STACKED_TICKETS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_TICKETS: Protocol_MINIGAME_MSG_GET_TICKETS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_GET_TICKETS_REPLY: Protocol_MINIGAME_MSG_GET_TICKETS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_PLAY_NEXT_ROUND: Protocol_MINIGAME_MSG_PLAY_NEXT_ROUND::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW: Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY: Protocol_MINIGAME_MSG_REG_TO_FIXED_PRIZE_DRAW_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_SERVER_RESTARTING: Protocol_MINIGAME_MSG_SERVER_RESTARTING::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_START_GAME: Protocol_MINIGAME_MSG_START_GAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_START_GAME_REPLY: Protocol_MINIGAME_MSG_START_GAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_TICKET_LOOKUP: Protocol_MINIGAME_MSG_TICKET_LOOKUP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MINIGAME_MSG_TICKET_LOOKUP_REPLY: Protocol_MINIGAME_MSG_TICKET_LOOKUP_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "client"))
	{
		switch(_msgId)
		{
			case SIDEGAME_MSG_TRIGGER_ANIMATION: client::Protocol_SIDEGAME_MSG_TRIGGER_ANIMATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER: client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_PLAYER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER: client::Protocol_SIDEGAME_MSG_USER_GAME_MESSAGE_TO_SERVER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "sidegame"))
	{
		switch(_msgId)
		{
			case SIDEGAME_MSG_ACTIVE_GAMES: sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_ACTIVE_GAMES_REPLY: sidegame::Protocol_SIDEGAME_MSG_ACTIVE_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_AUTOPLAY_STATE: sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_AUTOPLAY_STATE_REPLY: sidegame::Protocol_SIDEGAME_MSG_AUTOPLAY_STATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_PLAY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_PLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_PLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_CANCEL_REPLAY_AUTOPLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CLAIM_PRIZE: sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_CLAIM_PRIZE_REPLY: sidegame::Protocol_SIDEGAME_MSG_CLAIM_PRIZE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_FORFEIT: sidegame::Protocol_SIDEGAME_MSG_FORFEIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_FORFEIT_REPLY: sidegame::Protocol_SIDEGAME_MSG_FORFEIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF_LOCALIZED: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_LOCALIZED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_DEF_REPLY: sidegame::Protocol_SIDEGAME_MSG_GAME_DEF_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_STATE: sidegame::Protocol_SIDEGAME_MSG_GAME_STATE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GAME_STATE_REPLY: sidegame::Protocol_SIDEGAME_MSG_GAME_STATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_RING_SESSIONID: sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_RING_SESSIONID_REPLY: sidegame::Protocol_SIDEGAME_MSG_GET_RING_SESSIONID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_STARSREWARDS_BAR: sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY: sidegame::Protocol_SIDEGAME_MSG_GET_STARSREWARDS_BAR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_TICKET_BALANCE: sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY: sidegame::Protocol_SIDEGAME_MSG_GET_TICKET_BALANCE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_HISTORIC_GAMES: sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_HISTORIC_GAMES_REPLY: sidegame::Protocol_SIDEGAME_MSG_HISTORIC_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_MAX_GAMES_REACHED: sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY: sidegame::Protocol_SIDEGAME_MSG_MAX_GAMES_REACHED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_REPLAY_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_REPLAY_AUTOPLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_SKIP_DELAY: sidegame::Protocol_SIDEGAME_MSG_SKIP_DELAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_START_AUTOPLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_GAME: sidegame::Protocol_SIDEGAME_MSG_START_GAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_GAME_NEW: sidegame::Protocol_SIDEGAME_MSG_START_GAME_NEW::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_START_GAME_REPLY: sidegame::Protocol_SIDEGAME_MSG_START_GAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_STOP_AUTOPLAY: sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case SIDEGAME_MSG_STOP_AUTOPLAY_REPLY: sidegame::Protocol_SIDEGAME_MSG_STOP_AUTOPLAY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

