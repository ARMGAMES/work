/**
 * lobbyetc_atf.cpp
 *
 * This file was auto-generated from lobbyetc_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor lobbyetc_atf.txt
 */
 
#include "lobbyetc_atf.h"

//=================================================================
//                    Publication
//=================================================================

LobbyEtc::cli_Unauth::Publication::Publication()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Publication::Publication(Publication&& _o)
	: name(std::move(_o.name))
{
}

LobbyEtc::cli_Unauth::Publication& LobbyEtc::cli_Unauth::Publication::operator=(Publication&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Publication::clear()
{
	name.clear();
}

bool LobbyEtc::cli_Unauth::Publication::equals(const Publication& _o) const
{
	return Atf::atfPStringEquals(name, _o.name);
}

const char *LobbyEtc::cli_Unauth::Publication::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("name=");
	_buf.append(name);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Publication::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("name", name, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Publication::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("name"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, name)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli_Unauth::Publication::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(name);
}

void LobbyEtc::cli_Unauth::Publication::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
}

const char *LobbyEtc::cli_Unauth::Publication::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("name", name);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Publication::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("name", name);
}

/* static */ void LobbyEtc::cli_Unauth::Publication::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString name; _jparser.validateByNameThrow("name", name);
	AtfValidator::validateIntMax(_descr, "name", name.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::Publication::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "name", szName, 1000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHECK_PUBLICATIONS
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS&& _o)
	: publications(std::move(_o.publications))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::operator=(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS&& _o)
{
	if(this != &_o)
	{
		publications = std::move(_o.publications);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::clear()
{
	publications.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::equals(const Protocol_MSG_LOBBY_CHECK_PUBLICATIONS& _o) const
{
	return publications.equals(_o.publications);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CHECK_PUBLICATIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CHECK_PUBLICATIONS*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS).append(")");
	_buf.append(',');
	_buf.append("publications=");
	publications.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	publications.toXmlString("publications", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("publications"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< Publication, 4 > >::FromXmlString(_value, publications)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	publications.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	publications.parseMsg(_parser);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("publications", publications);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("publications", publications);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	Atf::AtfVectorBase< Publication > publications; _jparser.validateByNameThrow("publications", publications);
	AtfValidator::validateIntMax(_descr, "publications", publications.size(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	PString _descbuf;
	int szPublications = Atf::LAtfVector< Publication, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("publications"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "publications", szPublications, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY&& _o)
	: publicationExist(std::move(_o.publicationExist))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::operator=(Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		publicationExist = std::move(_o.publicationExist);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::clear()
{
	publicationExist.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::equals(const Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY& _o) const
{
	return publicationExist.equals(_o.publicationExist);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_CHECK_PUBLICATIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("publicationExist=");
	publicationExist.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_CHECK_PUBLICATIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	publicationExist.toXmlString("publicationExist", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("publicationExist"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< bool, 4 > >::FromXmlString(_value, publicationExist)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	publicationExist.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	publicationExist.parseMsg(_parser);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("publicationExist", publicationExist);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("publicationExist", publicationExist);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< bool > publicationExist; _jparser.validateByNameThrow("publicationExist", publicationExist);
	AtfValidator::validateInt(_descr, "publicationExist", publicationExist.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_CHECK_PUBLICATIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szPublicationExist = Atf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("publicationExist"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "publicationExist", szPublicationExist, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserId
//=================================================================

LobbyEtc::cli_Unauth::UserId::UserId()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::UserId::UserId(UserId&& _o)
	: userId(std::move(_o.userId))
{
}

LobbyEtc::cli_Unauth::UserId& LobbyEtc::cli_Unauth::UserId::operator=(UserId&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::UserId::clear()
{
	userId.clear();
}

bool LobbyEtc::cli_Unauth::UserId::equals(const UserId& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

const char *LobbyEtc::cli_Unauth::UserId::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::UserId::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::UserId::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli_Unauth::UserId::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void LobbyEtc::cli_Unauth::UserId::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *LobbyEtc::cli_Unauth::UserId::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::UserId::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/* static */ void LobbyEtc::cli_Unauth::UserId::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::UserId::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_USER_IMAGE
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::Protocol_MSG_LOBBYETC_GET_USER_IMAGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::Protocol_MSG_LOBBYETC_GET_USER_IMAGE(Protocol_MSG_LOBBYETC_GET_USER_IMAGE&& _o)
	: userIds(std::move(_o.userIds))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::operator=(Protocol_MSG_LOBBYETC_GET_USER_IMAGE&& _o)
{
	if(this != &_o)
	{
		userIds = std::move(_o.userIds);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::clear()
{
	userIds.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::equals(const Protocol_MSG_LOBBYETC_GET_USER_IMAGE& _o) const
{
	return userIds.equals(_o.userIds);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_USER_IMAGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_USER_IMAGE*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_USER_IMAGE).append(")");
	_buf.append(',');
	_buf.append("userIds=");
	userIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_USER_IMAGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	userIds.toXmlString("userIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserId, 4 > >::FromXmlString(_value, userIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userIds.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::parseMsg(CommMsgParser& _parser)
{
	userIds.parseMsg(_parser);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIds", userIds);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIds", userIds);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UserId > userIds; _jparser.validateByNameThrow("userIds", userIds);
	AtfValidator::validateIntMax(_descr, "userIds", userIds.size(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIds = Atf::LAtfVector< UserId, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "userIds", szUserIds, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserImageData
//=================================================================

LobbyEtc::cli_Unauth::UserImageData::UserImageData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::UserImageData::UserImageData(UserImageData&& _o)
	: userId(std::move(_o.userId))
	, errCode(std::move(_o.errCode))
	, imageid(std::move(_o.imageid))
	, isTeamPro(std::move(_o.isTeamPro))
{
}

LobbyEtc::cli_Unauth::UserImageData& LobbyEtc::cli_Unauth::UserImageData::operator=(UserImageData&& _o)
{
	if(this != &_o)
	{
		userId = std::move(_o.userId);
		errCode = std::move(_o.errCode);
		imageid = std::move(_o.imageid);
		isTeamPro = std::move(_o.isTeamPro);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::UserImageData::clear()
{
	userId.clear();
	errCode = 0;
	imageid = 0;
	isTeamPro = false;
}

bool LobbyEtc::cli_Unauth::UserImageData::equals(const UserImageData& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		errCode == _o.errCode &&
		imageid == _o.imageid &&
		isTeamPro == _o.isTeamPro;
}

const char *LobbyEtc::cli_Unauth::UserImageData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("imageid=");
	_buf.appendUint(imageid);
	_buf.append(',');
	_buf.append("isTeamPro=");
	_buf.appendUint(isTeamPro);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::UserImageData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageid", imageid, _buf);
	Atf::XmlElement::encodeAsXmlElement("isTeamPro", isTeamPro, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::UserImageData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("imageid"))
		{
			imageid = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isTeamPro"))
		{
			isTeamPro = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli_Unauth::UserImageData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
	_msg.composeINT16(errCode);
	_msg.composeUINT32(imageid);
	_msg.composeBOOL(isTeamPro);
}

void LobbyEtc::cli_Unauth::UserImageData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
	_parser.parseINT16(errCode);
	_parser.parseUINT32(imageid);
	_parser.parseBOOL(isTeamPro);
}

const char *LobbyEtc::cli_Unauth::UserImageData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("imageid", imageid);
	_jsonstr.compose("isTeamPro", isTeamPro);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::UserImageData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("imageid", imageid);
	_jparser.parseByNameThrow("isTeamPro", isTeamPro);
}

/* static */ void LobbyEtc::cli_Unauth::UserImageData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	UINT32 imageid; _jparser.validateByNameThrow("imageid", imageid);
	AtfValidator::validateInt(_descr, "imageid", imageid, _checker, __FILE__, __LINE__);
	bool isTeamPro; _jparser.validateByNameThrow("isTeamPro", isTeamPro);
	AtfValidator::validateInt(_descr, "isTeamPro", isTeamPro, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::UserImageData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	UINT32 imageid; _parser.parseUINT32(imageid);
	AtfValidator::validateInt(_descr, "imageid", imageid, _checker, __FILE__, __LINE__);
	bool isTeamPro; _parser.parseBOOL(isTeamPro);
	AtfValidator::validateInt(_descr, "isTeamPro", isTeamPro, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY(Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, images(std::move(_o.images))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		images = std::move(_o.images);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	images.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		images.equals(_o.images);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_USER_IMAGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_USER_IMAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("images=");
		images.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_USER_IMAGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		images.toXmlString("images", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("images"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserImageData, 4 > >::FromXmlString(_value, images)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		images.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		images.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("images", images);
	}
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("images", images);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< UserImageData > images; _jparser.validateByNameThrow("images", images);
		AtfValidator::validateInt(_descr, "images", images.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szImages = Atf::LAtfVector< UserImageData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("images"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "images", szImages, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY()
{
	clear();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::clear()
{
	siteId = 0;
	brandId = 0;
	locale = 0;
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::equals(const Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY& _o) const
{
	return siteId == _o.siteId &&
		brandId == _o.brandId &&
		locale == _o.locale;
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY).append(")");
	_buf.append(',');
	_buf.append("siteId=");
	_buf.appendUint(siteId);
	_buf.append(',');
	_buf.append("brandId=");
	_buf.appendUint(brandId);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("siteId", siteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("brandId", brandId, _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("siteId"))
			{
				siteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("brandId"))
			{
				brandId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(siteId);
	_msg.composeUINT32(brandId);
	_msg.composeUINT32(locale);
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(siteId);
	_parser.parseUINT32(brandId);
	_parser.parseUINT32(locale);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("siteId", siteId);
	_jsonstr.compose("brandId", brandId);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("siteId", siteId);
	_jparser.parseByNameThrow("brandId", brandId);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 siteId; _jparser.validateByNameThrow("siteId", siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 brandId; _jparser.validateByNameThrow("brandId", brandId);
	AtfValidator::validateIntMax(_descr, "brandId", brandId, BrandType_Last, _checker, __FILE__, __LINE__);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 siteId; _parser.parseUINT32(siteId);
	AtfValidator::validateIntMax(_descr, "siteId", siteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 brandId; _parser.parseUINT32(brandId);
	AtfValidator::validateIntMax(_descr, "brandId", brandId, BrandType_Last, _checker, __FILE__, __LINE__);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ImageBody
//=================================================================

LobbyEtc::cli_Unauth::ImageBody::ImageBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::ImageBody::ImageBody(ImageBody&& _o)
	: imageId(std::move(_o.imageId))
	, imageDescr(std::move(_o.imageDescr))
{
}

LobbyEtc::cli_Unauth::ImageBody& LobbyEtc::cli_Unauth::ImageBody::operator=(ImageBody&& _o)
{
	if(this != &_o)
	{
		imageId = std::move(_o.imageId);
		imageDescr = std::move(_o.imageDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::ImageBody::clear()
{
	imageId = 0;
	imageDescr.clear();
}

bool LobbyEtc::cli_Unauth::ImageBody::equals(const ImageBody& _o) const
{
	return imageId == _o.imageId &&
		Atf::atfPStringEquals(imageDescr, _o.imageDescr);
}

const char *LobbyEtc::cli_Unauth::ImageBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	_buf.append(',');
	_buf.append("imageDescr=");
	_buf.append(imageDescr);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::ImageBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	Atf::XmlElement::encodeAsXmlElement("imageDescr", imageDescr, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::ImageBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("imageId"))
		{
			imageId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("imageDescr"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, imageDescr)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli_Unauth::ImageBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ImageBody())) // not empty
	{
		_body.composeUINT32(imageId);
		_body.composeString(imageDescr);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli_Unauth::ImageBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(imageId);
	_parser0.parseStringP(imageDescr);
}

const char *LobbyEtc::cli_Unauth::ImageBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("imageId", imageId);
	_jsonstr.compose("imageDescr", imageDescr);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::ImageBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("imageId", imageId);
	_jparser.parseByNameThrow("imageDescr", imageDescr);
}

/* static */ void LobbyEtc::cli_Unauth::ImageBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	PString imageDescr; _jparser.validateByNameThrow("imageDescr", imageDescr);
	AtfValidator::validateInt(_descr, "imageDescr", imageDescr.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::ImageBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 imageId; _parser0.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "imageDescr"); size_t szImageDescr = strlen(_dummy);
	AtfValidator::validateInt(_descr, "imageDescr", szImageDescr, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SubcatBody
//=================================================================

LobbyEtc::cli_Unauth::SubcatBody::SubcatBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::SubcatBody::SubcatBody(SubcatBody&& _o)
	: subCatName(std::move(_o.subCatName))
	, imageIds(std::move(_o.imageIds))
{
}

LobbyEtc::cli_Unauth::SubcatBody& LobbyEtc::cli_Unauth::SubcatBody::operator=(SubcatBody&& _o)
{
	if(this != &_o)
	{
		subCatName = std::move(_o.subCatName);
		imageIds = std::move(_o.imageIds);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::SubcatBody::clear()
{
	subCatName.clear();
	imageIds.clear();
}

bool LobbyEtc::cli_Unauth::SubcatBody::equals(const SubcatBody& _o) const
{
	return Atf::atfPStringEquals(subCatName, _o.subCatName) &&
		imageIds.equals(_o.imageIds);
}

const char *LobbyEtc::cli_Unauth::SubcatBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("subCatName=");
	_buf.append(subCatName);
	_buf.append(',');
	_buf.append("imageIds=");
	imageIds.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::SubcatBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("subCatName", subCatName, _buf);
	imageIds.toXmlString("imageIds", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::SubcatBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("subCatName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, subCatName)) return false;
		}
		else if (_element.equals("imageIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, imageIds)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli_Unauth::SubcatBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SubcatBody())) // not empty
	{
		_body.composeString(subCatName);
		imageIds.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli_Unauth::SubcatBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(subCatName);
	imageIds.parseMsg(_parser0);
}

const char *LobbyEtc::cli_Unauth::SubcatBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("subCatName", subCatName);
	_jsonstr.compose("imageIds", imageIds);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::SubcatBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("subCatName", subCatName);
	_jparser.parseByNameThrow("imageIds", imageIds);
}

/* static */ void LobbyEtc::cli_Unauth::SubcatBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString subCatName; _jparser.validateByNameThrow("subCatName", subCatName);
	AtfValidator::validateInt(_descr, "subCatName", subCatName.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > imageIds; _jparser.validateByNameThrow("imageIds", imageIds);
	AtfValidator::validateInt(_descr, "imageIds", imageIds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::SubcatBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "subCatName"); size_t szSubCatName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "subCatName", szSubCatName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szImageIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("imageIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "imageIds", szImageIds, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CatBody
//=================================================================

LobbyEtc::cli_Unauth::CatBody::CatBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::CatBody::CatBody(CatBody&& _o)
	: catName(std::move(_o.catName))
	, imageIds(std::move(_o.imageIds))
	, subCats(std::move(_o.subCats))
{
}

LobbyEtc::cli_Unauth::CatBody& LobbyEtc::cli_Unauth::CatBody::operator=(CatBody&& _o)
{
	if(this != &_o)
	{
		catName = std::move(_o.catName);
		imageIds = std::move(_o.imageIds);
		subCats = std::move(_o.subCats);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::CatBody::clear()
{
	catName.clear();
	imageIds.clear();
	subCats.clear();
}

bool LobbyEtc::cli_Unauth::CatBody::equals(const CatBody& _o) const
{
	return Atf::atfPStringEquals(catName, _o.catName) &&
		imageIds.equals(_o.imageIds) &&
		subCats.equals(_o.subCats);
}

const char *LobbyEtc::cli_Unauth::CatBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("catName=");
	_buf.append(catName);
	_buf.append(',');
	_buf.append("imageIds=");
	imageIds.toTraceString(_buf);
	_buf.append(',');
	_buf.append("subCats=");
	subCats.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::CatBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("catName", catName, _buf);
	imageIds.toXmlString("imageIds", _buf);
	subCats.toXmlString("subCats", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::CatBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("catName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, catName)) return false;
		}
		else if (_element.equals("imageIds"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, imageIds)) return false;
		}
		else if (_element.equals("subCats"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< SubcatBody, 4 > >::FromXmlString(_value, subCats)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli_Unauth::CatBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CatBody())) // not empty
	{
		_body.composeString(catName);
		imageIds.composeMsg(_body, _ignoreJSON);
		subCats.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli_Unauth::CatBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(catName);
	imageIds.parseMsg(_parser0);
	subCats.parseMsg(_parser0);
}

const char *LobbyEtc::cli_Unauth::CatBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("catName", catName);
	_jsonstr.compose("imageIds", imageIds);
	_jsonstr.compose("subCats", subCats);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::CatBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("catName", catName);
	_jparser.parseByNameThrow("imageIds", imageIds);
	_jparser.parseByNameThrow("subCats", subCats);
}

/* static */ void LobbyEtc::cli_Unauth::CatBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString catName; _jparser.validateByNameThrow("catName", catName);
	AtfValidator::validateInt(_descr, "catName", catName.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > imageIds; _jparser.validateByNameThrow("imageIds", imageIds);
	AtfValidator::validateInt(_descr, "imageIds", imageIds.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< SubcatBody > subCats; _jparser.validateByNameThrow("subCats", subCats);
	AtfValidator::validateInt(_descr, "subCats", subCats.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::CatBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "catName"); size_t szCatName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "catName", szCatName, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szImageIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("imageIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "imageIds", szImageIds, _checker, __FILE__, __LINE__);
	int szSubCats = Atf::LAtfVector< SubcatBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("subCats"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "subCats", szSubCats, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY(Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, images(std::move(_o.images))
	, cats(std::move(_o.cats))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		images = std::move(_o.images);
		cats = std::move(_o.cats);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	images.clear();
	cats.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		images.equals(_o.images) &&
		cats.equals(_o.cats);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("images=");
		images.toTraceString(_buf);
		_buf.append(',');
		_buf.append("cats=");
		cats.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		images.toXmlString("images", _buf);
		cats.toXmlString("cats", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("images"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ImageBody, 4 > >::FromXmlString(_value, images)) return false;
			}
			else if (_element.equals("cats"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< CatBody, 4 > >::FromXmlString(_value, cats)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		images.composeMsg(_msg, _ignoreJSON);
		cats.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		images.parseMsg(_parser);
		cats.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("images", images);
		_jsonstr.compose("cats", cats);
	}
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("images", images);
		_jparser.parseByNameThrow("cats", cats);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ImageBody > images; _jparser.validateByNameThrow("images", images);
		AtfValidator::validateInt(_descr, "images", images.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< CatBody > cats; _jparser.validateByNameThrow("cats", cats);
		AtfValidator::validateInt(_descr, "cats", cats.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szImages = Atf::LAtfVector< ImageBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("images"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "images", szImages, _checker, __FILE__, __LINE__);
		int szCats = Atf::LAtfVector< CatBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cats"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "cats", szCats, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID(Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID&& _o)
	: cliSiteId(std::move(_o.cliSiteId))
	, cliBody(std::move(_o.cliBody))
	, locale(std::move(_o.locale))
	, countryCode(std::move(_o.countryCode))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::operator=(Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID&& _o)
{
	if(this != &_o)
	{
		cliSiteId = std::move(_o.cliSiteId);
		cliBody = std::move(_o.cliBody);
		locale = std::move(_o.locale);
		countryCode = std::move(_o.countryCode);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::clear()
{
	cliSiteId = 0;
	cliBody.clear();
	locale = 0;
	countryCode.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::equals(const Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID& _o) const
{
	return cliSiteId == _o.cliSiteId &&
		cliBody.equals(_o.cliBody) &&
		locale == _o.locale &&
		Atf::atfPStringEquals(countryCode, _o.countryCode);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID).append(")");
	_buf.append(',');
	_buf.append("cliSiteId=");
	_buf.appendUint(cliSiteId);
	_buf.append(',');
	_buf.append("cliBody=");
	cliBody.toTraceString(_buf);
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("countryCode=");
	_buf.append(countryCode);
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("cliSiteId", cliSiteId, _buf);
	cliBody.toXmlString("cliBody", _buf);
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("countryCode", countryCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("cliSiteId"))
			{
				cliSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cliBody"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, cliBody)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("countryCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, countryCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(cliSiteId);
	cliBody.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(locale);
	_msg.composeString(countryCode);
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(cliSiteId);
	cliBody.parseMsg(_parser);
	_parser.parseUINT32(locale);
	_parser.parseStringP(countryCode);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("cliSiteId", cliSiteId);
	_jsonstr.compose("cliBody", cliBody);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("countryCode", countryCode);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("cliSiteId", cliSiteId);
	_jparser.parseByNameThrow("cliBody", cliBody);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("countryCode", countryCode);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 cliSiteId; _jparser.validateByNameThrow("cliSiteId", cliSiteId);
	AtfValidator::validateIntMax(_descr, "cliSiteId", cliSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	Common::AtfShared::LoginExtra cliBody; _jparser.validateByNameThrow("cliBody", cliBody);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	PString countryCode; _jparser.validateByNameThrow("countryCode", countryCode);
	AtfValidator::validateIntMax(_descr, "countryCode", countryCode.length(), COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 cliSiteId; _parser.parseUINT32(cliSiteId);
	AtfValidator::validateIntMax(_descr, "cliSiteId", cliSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("cliBody"), _fieldsWithUnparsedContent);
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "countryCode"); size_t szCountryCode = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "countryCode", szCountryCode, COUNTRY_CODE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY(Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, imageId(std::move(_o.imageId))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		imageId = std::move(_o.imageId);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	imageId = 0;
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		imageId == _o.imageId;
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("imageId=");
		_buf.appendUint(imageId);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("imageId"))
			{
				imageId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(imageId);
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(imageId);
	}
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("imageId", imageId);
	}
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("imageId", imageId);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
		AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 imageId; _parser.parseUINT32(imageId);
		AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    LoginExtraDataBody
//=================================================================

LobbyEtc::cli_Unauth::LoginExtraDataBody::LoginExtraDataBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::LoginExtraDataBody::LoginExtraDataBody(LoginExtraDataBody&& _o)
	: extraData(std::move(_o.extraData))
{
}

LobbyEtc::cli_Unauth::LoginExtraDataBody& LobbyEtc::cli_Unauth::LoginExtraDataBody::operator=(LoginExtraDataBody&& _o)
{
	if(this != &_o)
	{
		extraData = std::move(_o.extraData);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::LoginExtraDataBody::clear()
{
	extraData.clear();
}

bool LobbyEtc::cli_Unauth::LoginExtraDataBody::equals(const LoginExtraDataBody& _o) const
{
	return extraData.equals(_o.extraData);
}

const char *LobbyEtc::cli_Unauth::LoginExtraDataBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("extraData=");
	extraData.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::LoginExtraDataBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	extraData.toXmlString("extraData", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::LoginExtraDataBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("extraData"))
		{
			if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, extraData)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli_Unauth::LoginExtraDataBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(LoginExtraDataBody())) // not empty
	{
		extraData.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli_Unauth::LoginExtraDataBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	if(_parser0.parseEnded()) return;
	extraData.parseMsg(_parser0);
}

const char *LobbyEtc::cli_Unauth::LoginExtraDataBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("extraData", extraData);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::LoginExtraDataBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("extraData", extraData);
}

/* static */ void LobbyEtc::cli_Unauth::LoginExtraDataBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra extraData; _jparser.validateByNameThrow("extraData", extraData);
}

/*static*/ void LobbyEtc::cli_Unauth::LoginExtraDataBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	if(_parser0.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("extraData"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION(Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION&& _o)
	: installIdDeprecated(std::move(_o.installIdDeprecated))
	, promo(std::move(_o.promo))
	, cliSiteId(std::move(_o.cliSiteId))
	, platformId(std::move(_o.platformId))
	, clientVersion(std::move(_o.clientVersion))
	, tiVer(std::move(_o.tiVer))
	, tinfoText(std::move(_o.tinfoText))
	, refDomain(std::move(_o.refDomain))
	, mobileAppId(std::move(_o.mobileAppId))
	, extraData(std::move(_o.extraData))
	, lat(std::move(_o.lat))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::operator=(Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION&& _o)
{
	if(this != &_o)
	{
		installIdDeprecated = std::move(_o.installIdDeprecated);
		promo = std::move(_o.promo);
		cliSiteId = std::move(_o.cliSiteId);
		platformId = std::move(_o.platformId);
		clientVersion = std::move(_o.clientVersion);
		tiVer = std::move(_o.tiVer);
		tinfoText = std::move(_o.tinfoText);
		refDomain = std::move(_o.refDomain);
		mobileAppId = std::move(_o.mobileAppId);
		extraData = std::move(_o.extraData);
		lat = std::move(_o.lat);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::clear()
{
	installIdDeprecated.clear();
	promo.clear();
	cliSiteId = 0;
	platformId = 0;
	clientVersion = 0;
	tiVer.clear();
	tinfoText.clear();
	refDomain.clear();
	mobileAppId.clear();
	extraData.clear();
	lat = false;
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::equals(const Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION& _o) const
{
	return Atf::atfPStringEquals(installIdDeprecated, _o.installIdDeprecated) &&
		Atf::atfPStringEquals(promo, _o.promo) &&
		cliSiteId == _o.cliSiteId &&
		platformId == _o.platformId &&
		clientVersion == _o.clientVersion &&
		Atf::atfPStringEquals(tiVer, _o.tiVer) &&
		Atf::atfPStringEquals(tinfoText, _o.tinfoText) &&
		Atf::atfPStringEquals(refDomain, _o.refDomain) &&
		Atf::atfPStringEquals(mobileAppId, _o.mobileAppId) &&
		extraData.equals(_o.extraData) &&
		lat == _o.lat;
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION).append(")");
	_buf.append(',');
	_buf.append("installIdDeprecated=");
	_buf.append(installIdDeprecated);
	_buf.append(',');
	_buf.append("promo=");
	_buf.append(promo);
	_buf.append(',');
	_buf.append("cliSiteId=");
	_buf.appendUint(cliSiteId);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("clientVersion=");
	_buf.appendUint(clientVersion);
	_buf.append(',');
	_buf.append("tiVer=");
	_buf.append(tiVer);
	_buf.append(',');
	_buf.append("tinfoText=");
	_buf.append(tinfoText);
	_buf.append(',');
	_buf.append("refDomain=");
	_buf.append(refDomain);
	_buf.append(',');
	_buf.append("mobileAppId=");
	_buf.append(mobileAppId);
	_buf.append(',');
	_buf.append("extraData=");
	extraData.toTraceString(_buf);
	_buf.append(',');
	_buf.append("lat=");
	_buf.appendUint(lat);
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("installIdDeprecated", installIdDeprecated, _buf);
	Atf::XmlElement::encodeAsXmlElement("promo", promo, _buf);
	Atf::XmlElement::encodeAsXmlElement("cliSiteId", cliSiteId, _buf);
	Atf::XmlElement::encodeAsXmlElement("platformId", platformId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clientVersion", clientVersion, _buf);
	Atf::XmlElement::encodeAsXmlElement("tiVer", tiVer, _buf);
	Atf::XmlElement::encodeAsXmlElement("tinfoText", tinfoText, _buf);
	Atf::XmlElement::encodeAsXmlElement("refDomain", refDomain, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobileAppId", mobileAppId, _buf);
	extraData.toXmlString("extraData", _buf);
	Atf::XmlElement::encodeAsXmlElement("lat", lat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("installIdDeprecated"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, installIdDeprecated)) return false;
			}
			else if (_element.equals("promo"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, promo)) return false;
			}
			else if (_element.equals("cliSiteId"))
			{
				cliSiteId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("platformId"))
			{
				platformId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientVersion"))
			{
				clientVersion = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tiVer"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tiVer)) return false;
			}
			else if (_element.equals("tinfoText"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tinfoText)) return false;
			}
			else if (_element.equals("refDomain"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, refDomain)) return false;
			}
			else if (_element.equals("mobileAppId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobileAppId)) return false;
			}
			else if (_element.equals("extraData"))
			{
				if(!Atf::AtfTempl< Common::AtfShared::LoginExtra >::FromXmlString(_value, extraData)) return false;
			}
			else if (_element.equals("lat"))
			{
				lat = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(installIdDeprecated);
	_msg.composeString(promo);
	_msg.composeUINT32(cliSiteId);
	_msg.composeUINT32(platformId);
	_msg.composeUINT32(clientVersion);
	_msg.composeString(tiVer);
	_msg.composeString(tinfoText);
	_msg.composeString(refDomain);
	_msg.composeString(mobileAppId);
	extraData.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(lat);
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(installIdDeprecated);
	_parser.parseStringP(promo);
	_parser.parseUINT32(cliSiteId);
	_parser.parseUINT32(platformId);
	_parser.parseUINT32(clientVersion);
	_parser.parseStringP(tiVer);
	_parser.parseStringP(tinfoText);
	_parser.parseStringP(refDomain);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(mobileAppId);
	if(_parser.parseEnded()) return;
	extraData.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(lat);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("installIdDeprecated", installIdDeprecated);
	_jsonstr.compose("promo", promo);
	_jsonstr.compose("cliSiteId", cliSiteId);
	_jsonstr.compose("platformId", platformId);
	_jsonstr.compose("clientVersion", clientVersion);
	_jsonstr.compose("tiVer", tiVer);
	_jsonstr.compose("tinfoText", tinfoText);
	_jsonstr.compose("refDomain", refDomain);
	_jsonstr.compose("mobileAppId", mobileAppId);
	_jsonstr.compose("extraData", extraData);
	_jsonstr.compose("lat", lat);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("installIdDeprecated", installIdDeprecated);
	_jparser.parseByNameThrow("promo", promo);
	_jparser.parseByNameThrow("cliSiteId", cliSiteId);
	_jparser.parseByNameThrow("platformId", platformId);
	_jparser.parseByNameThrow("clientVersion", clientVersion);
	_jparser.parseByNameThrow("tiVer", tiVer);
	_jparser.parseByNameThrow("tinfoText", tinfoText);
	_jparser.parseByNameThrow("refDomain", refDomain);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("mobileAppId", mobileAppId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("extraData", extraData);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("lat", lat);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString installIdDeprecated; _jparser.validateByNameThrow("installIdDeprecated", installIdDeprecated);
	AtfValidator::validateIntMax(_descr, "installIdDeprecated", installIdDeprecated.length(), 1000, _checker, __FILE__, __LINE__);
	PString promo; _jparser.validateByNameThrow("promo", promo);
	AtfValidator::validateIntMax(_descr, "promo", promo.length(), 1000, _checker, __FILE__, __LINE__);
	UINT32 cliSiteId; _jparser.validateByNameThrow("cliSiteId", cliSiteId);
	AtfValidator::validateIntMax(_descr, "cliSiteId", cliSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _jparser.validateByNameThrow("platformId", platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 clientVersion; _jparser.validateByNameThrow("clientVersion", clientVersion);
	AtfValidator::validateInt(_descr, "clientVersion", clientVersion, _checker, __FILE__, __LINE__);
	PString tiVer; _jparser.validateByNameThrow("tiVer", tiVer);
	AtfValidator::validateIntMax(_descr, "tiVer", tiVer.length(), 1000, _checker, __FILE__, __LINE__);
	PString tinfoText; _jparser.validateByNameThrow("tinfoText", tinfoText);
	AtfValidator::validateIntMax(_descr, "tinfoText", tinfoText.length(), 1000, _checker, __FILE__, __LINE__);
	PString refDomain; _jparser.validateByNameThrow("refDomain", refDomain);
	AtfValidator::validateIntMax(_descr, "refDomain", refDomain.length(), 1000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString mobileAppId; _jparser.validateByNameThrow("mobileAppId", mobileAppId);
	AtfValidator::validateIntMax(_descr, "mobileAppId", mobileAppId.length(), 1000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	Common::AtfShared::LoginExtra extraData; _jparser.validateByNameThrow("extraData", extraData);
	if(_jparser.parseEnded()) return;
	bool lat; _jparser.validateByNameThrow("lat", lat);
	AtfValidator::validateInt(_descr, "lat", lat, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "installIdDeprecated"); size_t szInstallIdDeprecated = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "installIdDeprecated", szInstallIdDeprecated, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "promo"); size_t szPromo = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "promo", szPromo, 1000, _checker, __FILE__, __LINE__);
	UINT32 cliSiteId; _parser.parseUINT32(cliSiteId);
	AtfValidator::validateIntMax(_descr, "cliSiteId", cliSiteId, PokerStars_Last, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 clientVersion; _parser.parseUINT32(clientVersion);
	AtfValidator::validateInt(_descr, "clientVersion", clientVersion, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tiVer"); size_t szTiVer = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tiVer", szTiVer, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tinfoText"); size_t szTinfoText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tinfoText", szTinfoText, 1000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "refDomain"); size_t szRefDomain = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "refDomain", szRefDomain, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "mobileAppId"); size_t szMobileAppId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobileAppId", szMobileAppId, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	Common::AtfShared::LoginExtra::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("extraData"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	bool lat; _parser.parseBOOL(lat);
	AtfValidator::validateInt(_descr, "lat", lat, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY(Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::operator=(Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::equals(const Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_ADX_EVENT
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::Protocol_MSG_LOBBYETC_ADX_EVENT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::Protocol_MSG_LOBBYETC_ADX_EVENT(Protocol_MSG_LOBBYETC_ADX_EVENT&& _o)
	: userWebId(std::move(_o.userWebId))
	, when(std::move(_o.when))
	, eventType(std::move(_o.eventType))
	, license(std::move(_o.license))
	, platformId(std::move(_o.platformId))
	, device(std::move(_o.device))
	, deviceId(std::move(_o.deviceId))
	, network(std::move(_o.network))
	, reference(std::move(_o.reference))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::operator=(Protocol_MSG_LOBBYETC_ADX_EVENT&& _o)
{
	if(this != &_o)
	{
		userWebId = std::move(_o.userWebId);
		when = std::move(_o.when);
		eventType = std::move(_o.eventType);
		license = std::move(_o.license);
		platformId = std::move(_o.platformId);
		device = std::move(_o.device);
		deviceId = std::move(_o.deviceId);
		network = std::move(_o.network);
		reference = std::move(_o.reference);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::clear()
{
	userWebId.clear();
	when.setNull();
	eventType = 0;
	license = 0;
	platformId = 0;
	device = 0;
	deviceId.clear();
	network.clear();
	reference.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::equals(const Protocol_MSG_LOBBYETC_ADX_EVENT& _o) const
{
	return Atf::atfPStringEquals(userWebId, _o.userWebId) &&
		when.equals(_o.when) &&
		eventType == _o.eventType &&
		license == _o.license &&
		platformId == _o.platformId &&
		device == _o.device &&
		Atf::atfPStringEquals(deviceId, _o.deviceId) &&
		Atf::atfPStringEquals(network, _o.network) &&
		Atf::atfPStringEquals(reference, _o.reference);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_ADX_EVENT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_ADX_EVENT*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_ADX_EVENT).append(")");
	_buf.append(',');
	_buf.append("userWebId=");
	_buf.append(userWebId);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("eventType=");
	_buf.appendUint(eventType);
	_buf.append(',');
	_buf.append("license=");
	_buf.appendUint(license);
	_buf.append(',');
	_buf.append("platformId=");
	_buf.appendUint(platformId);
	_buf.append(',');
	_buf.append("device=");
	_buf.appendUint(device);
	_buf.append(',');
	_buf.append("deviceId=");
	_buf.append(deviceId);
	_buf.append(',');
	_buf.append("network=");
	_buf.append(network);
	_buf.append(',');
	_buf.append("reference=");
	_buf.append(reference);
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_ADX_EVENT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("userWebId", userWebId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("eventType", eventType, _buf);
	Atf::XmlElement::encodeAsXmlElement("license", license, _buf);
	Atf::XmlElement::encodeAsXmlElement("platformId", platformId, _buf);
	Atf::XmlElement::encodeAsXmlElement("device", device, _buf);
	Atf::XmlElement::encodeAsXmlElement("deviceId", deviceId, _buf);
	Atf::XmlElement::encodeAsXmlElement("network", network, _buf);
	Atf::XmlElement::encodeAsXmlElement("reference", reference, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userWebId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userWebId)) return false;
			}
			else if (_element.equals("when"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, when);
			}
			else if (_element.equals("eventType"))
			{
				eventType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("license"))
			{
				license = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("platformId"))
			{
				platformId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("device"))
			{
				device = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("deviceId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, deviceId)) return false;
			}
			else if (_element.equals("network"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, network)) return false;
			}
			else if (_element.equals("reference"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, reference)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userWebId);
	_msg.composeSrvTime(when);
	_msg.composeUINT32(eventType);
	_msg.composeUINT32(license);
	_msg.composeUINT32(platformId);
	_msg.composeUINT32(device);
	_msg.composeString(deviceId);
	_msg.composeString(network);
	_msg.composeString(reference);
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userWebId);
	_parser.parseSrvTime(when);
	_parser.parseUINT32(eventType);
	_parser.parseUINT32(license);
	_parser.parseUINT32(platformId);
	_parser.parseUINT32(device);
	_parser.parseStringP(deviceId);
	_parser.parseStringP(network);
	_parser.parseStringP(reference);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userWebId", userWebId);
	_jsonstr.compose("when", when);
	_jsonstr.compose("eventType", eventType);
	_jsonstr.compose("license", license);
	_jsonstr.compose("platformId", platformId);
	_jsonstr.compose("device", device);
	_jsonstr.compose("deviceId", deviceId);
	_jsonstr.compose("network", network);
	_jsonstr.compose("reference", reference);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userWebId", userWebId);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("eventType", eventType);
	_jparser.parseByNameThrow("license", license);
	_jparser.parseByNameThrow("platformId", platformId);
	_jparser.parseByNameThrow("device", device);
	_jparser.parseByNameThrow("deviceId", deviceId);
	_jparser.parseByNameThrow("network", network);
	_jparser.parseByNameThrow("reference", reference);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_ADX_EVENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userWebId; _jparser.validateByNameThrow("userWebId", userWebId);
	AtfValidator::validateIntMax(_descr, "userWebId", userWebId.length(), WEB_ID_LEN, _checker, __FILE__, __LINE__);
	SrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 eventType; _jparser.validateByNameThrow("eventType", eventType);
	AtfValidator::validateIntMax(_descr, "eventType", eventType, eMobileEventType_LAST, _checker, __FILE__, __LINE__);
	UINT32 license; _jparser.validateByNameThrow("license", license);
	AtfValidator::validateIntMax(_descr, "license", license, eLicenceLast, _checker, __FILE__, __LINE__);
	UINT32 platformId; _jparser.validateByNameThrow("platformId", platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 device; _jparser.validateByNameThrow("device", device);
	AtfValidator::validateIntMax(_descr, "device", device, ClientDevice_Last, _checker, __FILE__, __LINE__);
	PString deviceId; _jparser.validateByNameThrow("deviceId", deviceId);
	AtfValidator::validateIntMax(_descr, "deviceId", deviceId.length(), ADXEVENT_DEVICE_ID_LEN, _checker, __FILE__, __LINE__);
	PString network; _jparser.validateByNameThrow("network", network);
	AtfValidator::validateIntMax(_descr, "network", network.length(), ADXEVENT_NETWORK_LEN, _checker, __FILE__, __LINE__);
	PString reference; _jparser.validateByNameThrow("reference", reference);
	AtfValidator::validateIntMax(_descr, "reference", reference.length(), ADXEVENT_REFERENCE_LEN, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_ADX_EVENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userWebId"); size_t szUserWebId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userWebId", szUserWebId, WEB_ID_LEN, _checker, __FILE__, __LINE__);
	SrvTime when; _parser.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 eventType; _parser.parseUINT32(eventType);
	AtfValidator::validateIntMax(_descr, "eventType", eventType, eMobileEventType_LAST, _checker, __FILE__, __LINE__);
	UINT32 license; _parser.parseUINT32(license);
	AtfValidator::validateIntMax(_descr, "license", license, eLicenceLast, _checker, __FILE__, __LINE__);
	UINT32 platformId; _parser.parseUINT32(platformId);
	AtfValidator::validateIntMax(_descr, "platformId", platformId, Client_Last, _checker, __FILE__, __LINE__);
	UINT32 device; _parser.parseUINT32(device);
	AtfValidator::validateIntMax(_descr, "device", device, ClientDevice_Last, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "deviceId"); size_t szDeviceId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "deviceId", szDeviceId, ADXEVENT_DEVICE_ID_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "network"); size_t szNetwork = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "network", szNetwork, ADXEVENT_NETWORK_LEN, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "reference"); size_t szReference = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "reference", szReference, ADXEVENT_REFERENCE_LEN, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY(Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::operator=(Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::equals(const Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_ADX_EVENT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_ADX_EVENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_ADX_EVENT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_ADX_EVENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_ADX_EVENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS(Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS&& _o)
	: userIntIds(std::move(_o.userIntIds))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::operator=(Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS&& _o)
{
	if(this != &_o)
	{
		userIntIds = std::move(_o.userIntIds);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::clear()
{
	userIntIds.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::equals(const Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS& _o) const
{
	return userIntIds.equals(_o.userIntIds);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CONVERT_USERINTIDS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CONVERT_USERINTIDS).append(")");
	_buf.append(',');
	_buf.append("userIntIds=");
	userIntIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CONVERT_USERINTIDS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	userIntIds.toXmlString("userIntIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("userIntIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, userIntIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	userIntIds.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::parseMsg(CommMsgParser& _parser)
{
	userIntIds.parseMsg(_parser);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntIds", userIntIds);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntIds", userIntIds);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CONVERT_USERINTIDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT32 > userIntIds; _jparser.validateByNameThrow("userIntIds", userIntIds);
	AtfValidator::validateIntMax(_descr, "userIntIds", userIntIds.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CONVERT_USERINTIDS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szUserIntIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIntIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "userIntIds", szUserIntIds, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    UserData
//=================================================================

LobbyEtc::cli_Unauth::UserData::UserData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::UserData::UserData(UserData&& _o)
	: userIntId(std::move(_o.userIntId))
	, userId(std::move(_o.userId))
{
}

LobbyEtc::cli_Unauth::UserData& LobbyEtc::cli_Unauth::UserData::operator=(UserData&& _o)
{
	if(this != &_o)
	{
		userIntId = std::move(_o.userIntId);
		userId = std::move(_o.userId);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::UserData::clear()
{
	userIntId = 0;
	userId.clear();
}

bool LobbyEtc::cli_Unauth::UserData::equals(const UserData& _o) const
{
	return userIntId == _o.userIntId &&
		Atf::atfPStringEquals(userId, _o.userId);
}

const char *LobbyEtc::cli_Unauth::UserData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::UserData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::UserData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userIntId"))
		{
			userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli_Unauth::UserData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(userIntId);
	_msg.composeString(userId);
}

void LobbyEtc::cli_Unauth::UserData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(userIntId);
	_parser.parseStringP(userId);
}

const char *LobbyEtc::cli_Unauth::UserData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::UserData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("userId", userId);
}

/* static */ void LobbyEtc::cli_Unauth::UserData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli_Unauth::UserData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY
//=================================================================

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY(Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, users(std::move(_o.users))
{
}

LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY& LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::operator=(Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		users = std::move(_o.users);
	}
	return *this;
}

#endif

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	users.clear();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::equals(const Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		users.equals(_o.users);
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY*)_other));
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("users=");
		users.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		users.toXmlString("users", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("users"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserData, 4 > >::FromXmlString(_value, users)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		users.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		users.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("users", users);
	}
	return _buf.c_str();
}

void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("users", users);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< UserData > users; _jparser.validateByNameThrow("users", users);
		AtfValidator::validateInt(_descr, "users", users.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szUsers = Atf::LAtfVector< UserData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("users"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "users", szUsers, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_W2G_AUDIT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::Protocol_MSG_LOBBYETC_W2G_AUDIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::Protocol_MSG_LOBBYETC_W2G_AUDIT(Protocol_MSG_LOBBYETC_W2G_AUDIT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, password(std::move(_o.password))
	, year(std::move(_o.year))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT& LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::operator=(Protocol_MSG_LOBBYETC_W2G_AUDIT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		password = std::move(_o.password);
		year = std::move(_o.year);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::clear()
{
	notUsedStr.clear();
	password.clear();
	year = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::equals(const Protocol_MSG_LOBBYETC_W2G_AUDIT& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		Atf::atfPStringEquals(password, _o.password) &&
		year == _o.year;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_W2G_AUDIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_W2G_AUDIT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_W2G_AUDIT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("year=");
	_buf.appendInt(year);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_W2G_AUDIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("year", year, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("year"))
			{
				year = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeString(password);
	_msg.composeINT32(year);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseStringP(password);
	_parser.parseINT32(year);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("password", password);
	_jsonstr.compose("year", year);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("year", year);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_W2G_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 100, _checker, __FILE__, __LINE__);
	INT32 year; _jparser.validateByNameThrow("year", year);
	AtfValidator::validateIntMax(_descr, "year", year, 2099, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_W2G_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 100, _checker, __FILE__, __LINE__);
	INT32 year; _parser.parseINT32(year);
	AtfValidator::validateIntMax(_descr, "year", year, 2099, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY(Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::operator=(Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::equals(const Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_W2G_AUDIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_W2G_AUDIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_W2G_AUDIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_W2G_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_W2G_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT(Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, eReportFormat(std::move(_o.eReportFormat))
	, password(std::move(_o.password))
	, isHtmlForClient(std::move(_o.isHtmlForClient))
	, vipStepsOnly(std::move(_o.vipStepsOnly))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT& LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::operator=(Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		eReportFormat = std::move(_o.eReportFormat);
		password = std::move(_o.password);
		isHtmlForClient = std::move(_o.isHtmlForClient);
		vipStepsOnly = std::move(_o.vipStepsOnly);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::clear()
{
	notUsedStr.clear();
	startDate.setNull();
	endDate.setNull();
	eReportFormat = 0;
	password.clear();
	isHtmlForClient = false;
	vipStepsOnly = false;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::equals(const Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		eReportFormat == _o.eReportFormat &&
		Atf::atfPStringEquals(password, _o.password) &&
		isHtmlForClient == _o.isHtmlForClient &&
		vipStepsOnly == _o.vipStepsOnly;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_FPP_HISTORY_AUDIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_FPP_HISTORY_AUDIT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("startDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
	_buf.append(',');
	_buf.append("endDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	_buf.append(',');
	_buf.append("eReportFormat=");
	_buf.appendUint(eReportFormat);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append(',');
	_buf.append("isHtmlForClient=");
	_buf.appendUint(isHtmlForClient);
	_buf.append(',');
	_buf.append("vipStepsOnly=");
	_buf.appendUint(vipStepsOnly);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_FPP_HISTORY_AUDIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "startDate", startDate);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
	Atf::XmlElement::encodeAsXmlElement("eReportFormat", eReportFormat, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHtmlForClient", isHtmlForClient, _buf);
	Atf::XmlElement::encodeAsXmlElement("vipStepsOnly", vipStepsOnly, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("startDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, startDate);
			}
			else if (_element.equals("endDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
			}
			else if (_element.equals("eReportFormat"))
			{
				eReportFormat = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("isHtmlForClient"))
			{
				isHtmlForClient = (*_value.ptr() == '1');
			}
			else if (_element.equals("vipStepsOnly"))
			{
				vipStepsOnly = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeSrvDate(startDate);
	_msg.composeSrvDate(endDate);
	_msg.composeUINT32(eReportFormat);
	_msg.composeString(password);
	_msg.composeBOOL(isHtmlForClient);
	_msg.composeBOOL(vipStepsOnly);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseSrvDate(startDate);
	_parser.parseSrvDate(endDate);
	_parser.parseUINT32(eReportFormat);
	_parser.parseStringP(password);
	_parser.parseBOOL(isHtmlForClient);
	_parser.parseBOOL(vipStepsOnly);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("startDate", startDate);
	_jsonstr.compose("endDate", endDate);
	_jsonstr.compose("eReportFormat", eReportFormat);
	_jsonstr.compose("password", password);
	_jsonstr.compose("isHtmlForClient", isHtmlForClient);
	_jsonstr.compose("vipStepsOnly", vipStepsOnly);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("startDate", startDate);
	_jparser.parseByNameThrow("endDate", endDate);
	_jparser.parseByNameThrow("eReportFormat", eReportFormat);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("isHtmlForClient", isHtmlForClient);
	_jparser.parseByNameThrow("vipStepsOnly", vipStepsOnly);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_FPP_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _jparser.validateByNameThrow("startDate", startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	UINT32 eReportFormat; _jparser.validateByNameThrow("eReportFormat", eReportFormat);
	AtfValidator::validateIntMax(_descr, "eReportFormat", eReportFormat, 100, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _jparser.validateByNameThrow("isHtmlForClient", isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
	bool vipStepsOnly; _jparser.validateByNameThrow("vipStepsOnly", vipStepsOnly);
	AtfValidator::validateInt(_descr, "vipStepsOnly", vipStepsOnly, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_FPP_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _parser.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	UINT32 eReportFormat; _parser.parseUINT32(eReportFormat);
	AtfValidator::validateIntMax(_descr, "eReportFormat", eReportFormat, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _parser.parseBOOL(isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
	bool vipStepsOnly; _parser.parseBOOL(vipStepsOnly);
	AtfValidator::validateInt(_descr, "vipStepsOnly", vipStepsOnly, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY(Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::operator=(Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::equals(const Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::clear()
{
	eligible = false;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::equals(const Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF& _o) const
{
	return eligible == _o.eligible;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF).append(")");
	_buf.append(',');
	_buf.append("eligible=");
	_buf.appendUint(eligible);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("eligible", eligible, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("eligible"))
			{
				eligible = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(eligible);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(eligible);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("eligible", eligible);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("eligible", eligible);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool eligible; _jparser.validateByNameThrow("eligible", eligible);
	AtfValidator::validateInt(_descr, "eligible", eligible, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	bool eligible; _parser.parseBOOL(eligible);
	AtfValidator::validateInt(_descr, "eligible", eligible, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY(Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLIENT_REPORT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::Protocol_MSG_LOBBYETC_CLIENT_REPORT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::Protocol_MSG_LOBBYETC_CLIENT_REPORT(Protocol_MSG_LOBBYETC_CLIENT_REPORT&& _o)
	: reportType(std::move(_o.reportType))
	, startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, password(std::move(_o.password))
	, reportFormat(std::move(_o.reportFormat))
	, isHtmlForClient(std::move(_o.isHtmlForClient))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::operator=(Protocol_MSG_LOBBYETC_CLIENT_REPORT&& _o)
{
	if(this != &_o)
	{
		reportType = std::move(_o.reportType);
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		password = std::move(_o.password);
		reportFormat = std::move(_o.reportFormat);
		isHtmlForClient = std::move(_o.isHtmlForClient);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::clear()
{
	reportType = 0;
	startDate.setNull();
	endDate.setNull();
	password.clear();
	reportFormat = 0;
	isHtmlForClient = false;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::equals(const Protocol_MSG_LOBBYETC_CLIENT_REPORT& _o) const
{
	return reportType == _o.reportType &&
		startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		Atf::atfPStringEquals(password, _o.password) &&
		reportFormat == _o.reportFormat &&
		isHtmlForClient == _o.isHtmlForClient;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLIENT_REPORT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLIENT_REPORT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLIENT_REPORT).append(")");
	_buf.append(',');
	_buf.append("reportType=");
	_buf.appendUint(reportType);
	if( reportType == eClientReportType_EsAccountHistory )
	{
		_buf.append(',');
		_buf.append("startDate=");
		Atf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
		_buf.append(',');
		_buf.append("endDate=");
		Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
		_buf.append(',');
		_buf.append("password=");
		_buf.append(password);
		_buf.append(',');
		_buf.append("reportFormat=");
		_buf.appendUint(reportFormat);
		_buf.append(',');
		_buf.append("isHtmlForClient=");
		_buf.appendUint(isHtmlForClient);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLIENT_REPORT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reportType", reportType, _buf);
	if( reportType == eClientReportType_EsAccountHistory )
	{
		Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "startDate", startDate);
		Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
		Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
		Atf::XmlElement::encodeAsXmlElement("reportFormat", reportFormat, _buf);
		Atf::XmlElement::encodeAsXmlElement("isHtmlForClient", isHtmlForClient, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reportType"))
			{
				reportType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("startDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, startDate);
			}
			else if (_element.equals("endDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("reportFormat"))
			{
				reportFormat = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHtmlForClient"))
			{
				isHtmlForClient = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(reportType);
	if( reportType == eClientReportType_EsAccountHistory )
	{
		CommMsgBody _msg0;
		_msg0.composeSrvDate(startDate);
		_msg0.composeSrvDate(endDate);
		_msg0.composeString(password);
		_msg0.composeUINT32(reportFormat);
		_msg0.composeBOOL(isHtmlForClient);
		_msg.composeMsgBody(_msg0);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(reportType);
	if( reportType == eClientReportType_EsAccountHistory )
	{
		parseAnonymousMsgBody0(_parser);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reportType", reportType);
	if( reportType == eClientReportType_EsAccountHistory )
	{
		_jsonstr.compose("startDate", startDate);
		_jsonstr.compose("endDate", endDate);
		_jsonstr.compose("password", password);
		_jsonstr.compose("reportFormat", reportFormat);
		_jsonstr.compose("isHtmlForClient", isHtmlForClient);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reportType", reportType);
	if( reportType == eClientReportType_EsAccountHistory )
	{
		_jparser.parseByNameThrow("startDate", startDate);
		_jparser.parseByNameThrow("endDate", endDate);
		_jparser.parseByNameThrow("password", password);
		_jparser.parseByNameThrow("reportFormat", reportFormat);
		_jparser.parseByNameThrow("isHtmlForClient", isHtmlForClient);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 reportType = 0;
	_jparser.validateByNameThrow("reportType", reportType);
	AtfValidator::validateIntMax(_descr, "reportType", reportType, eClientReportType_Last, _checker, __FILE__, __LINE__);
	if( reportType == eClientReportType_EsAccountHistory )
	{
		SrvDate startDate; _jparser.validateByNameThrow("startDate", startDate);
		AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
		SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
		AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
		PString password; _jparser.validateByNameThrow("password", password);
		AtfValidator::validateIntMax(_descr, "password", password.length(), 100, _checker, __FILE__, __LINE__);
		UINT32 reportFormat; _jparser.validateByNameThrow("reportFormat", reportFormat);
		AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
		bool isHtmlForClient; _jparser.validateByNameThrow("isHtmlForClient", isHtmlForClient);
		AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 reportType = 0;
	_parser.parseUINT32(reportType);
	AtfValidator::validateIntMax(_descr, "reportType", reportType, eClientReportType_Last, _checker, __FILE__, __LINE__);
	if( reportType == eClientReportType_EsAccountHistory )
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseSrvDate(startDate);
	_parser0.parseSrvDate(endDate);
	_parser0.parseStringP(password);
	_parser0.parseUINT32(reportFormat);
	_parser0.parseBOOL(isHtmlForClient);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	SrvDate startDate; _parser0.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser0.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 100, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _parser0.parseUINT32(reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _parser0.parseBOOL(isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY(Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::operator=(Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::equals(const Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLIENT_REPORT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLIENT_REPORT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLIENT_REPORT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_LOCALE_SET
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::Protocol_MSG_LOBBYETC_LOCALE_SET()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::clear()
{
	locale = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::equals(const Protocol_MSG_LOBBYETC_LOCALE_SET& _o) const
{
	return locale == _o.locale;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_LOCALE_SET != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_LOCALE_SET*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_LOCALE_SET).append(")");
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_LOCALE_SET).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(locale);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(locale);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_LOCALE_SET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_LOCALE_SET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntMax(_descr, "locale", locale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY(Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, locale(std::move(_o.locale))
	, emLocale(std::move(_o.emLocale))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::operator=(Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		locale = std::move(_o.locale);
		emLocale = std::move(_o.emLocale);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	locale = 0;
	emLocale = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::equals(const Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		locale == _o.locale &&
		emLocale == _o.emLocale;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_LOCALE_SET_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_LOCALE_SET_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("locale=");
		_buf.appendUint(locale);
		_buf.append(',');
		_buf.append("emLocale=");
		_buf.appendUint(emLocale);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_LOCALE_SET_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
		Atf::XmlElement::encodeAsXmlElement("emLocale", emLocale, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("emLocale"))
			{
				emLocale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(locale);
		_msg.composeUINT32(emLocale);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(locale);
		_parser.parseUINT32(emLocale);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("locale", locale);
		_jsonstr.compose("emLocale", emLocale);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("locale", locale);
		_jparser.parseByNameThrow("emLocale", emLocale);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_LOCALE_SET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 locale; _jparser.validateByNameThrow("locale", locale);
		AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
		UINT32 emLocale; _jparser.validateByNameThrow("emLocale", emLocale);
		AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_LOCALE_SET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 locale; _parser.parseUINT32(locale);
		AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
		UINT32 emLocale; _parser.parseUINT32(emLocale);
		AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_EMLOCALE_SET
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::Protocol_MSG_LOBBYETC_EMLOCALE_SET()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::clear()
{
	emLocale = 0;
	emLocale2 = 0;
	emLocale3 = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::equals(const Protocol_MSG_LOBBYETC_EMLOCALE_SET& _o) const
{
	return emLocale == _o.emLocale &&
		emLocale2 == _o.emLocale2 &&
		emLocale3 == _o.emLocale3;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_EMLOCALE_SET != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_EMLOCALE_SET*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_EMLOCALE_SET).append(")");
	_buf.append(',');
	_buf.append("emLocale=");
	_buf.appendUint(emLocale);
	_buf.append(',');
	_buf.append("emLocale2=");
	_buf.appendUint(emLocale2);
	_buf.append(',');
	_buf.append("emLocale3=");
	_buf.appendUint(emLocale3);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_EMLOCALE_SET).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("emLocale", emLocale, _buf);
	Atf::XmlElement::encodeAsXmlElement("emLocale2", emLocale2, _buf);
	Atf::XmlElement::encodeAsXmlElement("emLocale3", emLocale3, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("emLocale"))
			{
				emLocale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("emLocale2"))
			{
				emLocale2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("emLocale3"))
			{
				emLocale3 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(emLocale);
	_msg.composeUINT32(emLocale2);
	_msg.composeUINT32(emLocale3);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(emLocale);
	_parser.parseUINT32(emLocale2);
	_parser.parseUINT32(emLocale3);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("emLocale", emLocale);
	_jsonstr.compose("emLocale2", emLocale2);
	_jsonstr.compose("emLocale3", emLocale3);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("emLocale", emLocale);
	_jparser.parseByNameThrow("emLocale2", emLocale2);
	_jparser.parseByNameThrow("emLocale3", emLocale3);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EMLOCALE_SET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 emLocale; _jparser.validateByNameThrow("emLocale", emLocale);
	AtfValidator::validateIntMax(_descr, "emLocale", emLocale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 emLocale2; _jparser.validateByNameThrow("emLocale2", emLocale2);
	AtfValidator::validateIntMax(_descr, "emLocale2", emLocale2, LOCALE_INVALID, _checker, __FILE__, __LINE__);
	UINT32 emLocale3; _jparser.validateByNameThrow("emLocale3", emLocale3);
	AtfValidator::validateIntMax(_descr, "emLocale3", emLocale3, LOCALE_INVALID, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EMLOCALE_SET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 emLocale; _parser.parseUINT32(emLocale);
	AtfValidator::validateIntMax(_descr, "emLocale", emLocale, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 emLocale2; _parser.parseUINT32(emLocale2);
	AtfValidator::validateIntMax(_descr, "emLocale2", emLocale2, LOCALE_INVALID, _checker, __FILE__, __LINE__);
	UINT32 emLocale3; _parser.parseUINT32(emLocale3);
	AtfValidator::validateIntMax(_descr, "emLocale3", emLocale3, LOCALE_INVALID, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY(Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, locale(std::move(_o.locale))
	, emLocale(std::move(_o.emLocale))
	, emLocale2(std::move(_o.emLocale2))
	, emLocale3(std::move(_o.emLocale3))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::operator=(Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		locale = std::move(_o.locale);
		emLocale = std::move(_o.emLocale);
		emLocale2 = std::move(_o.emLocale2);
		emLocale3 = std::move(_o.emLocale3);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	locale = 0;
	emLocale = 0;
	emLocale2 = 0;
	emLocale3 = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::equals(const Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		locale == _o.locale &&
		emLocale == _o.emLocale &&
		emLocale2 == _o.emLocale2 &&
		emLocale3 == _o.emLocale3;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_EMLOCALE_SET_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_EMLOCALE_SET_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("locale=");
		_buf.appendUint(locale);
		_buf.append(',');
		_buf.append("emLocale=");
		_buf.appendUint(emLocale);
		_buf.append(',');
		_buf.append("emLocale2=");
		_buf.appendUint(emLocale2);
		_buf.append(',');
		_buf.append("emLocale3=");
		_buf.appendUint(emLocale3);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_EMLOCALE_SET_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
		Atf::XmlElement::encodeAsXmlElement("emLocale", emLocale, _buf);
		Atf::XmlElement::encodeAsXmlElement("emLocale2", emLocale2, _buf);
		Atf::XmlElement::encodeAsXmlElement("emLocale3", emLocale3, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("emLocale"))
			{
				emLocale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("emLocale2"))
			{
				emLocale2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("emLocale3"))
			{
				emLocale3 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(locale);
		_msg.composeUINT32(emLocale);
		_msg.composeUINT32(emLocale2);
		_msg.composeUINT32(emLocale3);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(locale);
		_parser.parseUINT32(emLocale);
		_parser.parseUINT32(emLocale2);
		_parser.parseUINT32(emLocale3);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("locale", locale);
		_jsonstr.compose("emLocale", emLocale);
		_jsonstr.compose("emLocale2", emLocale2);
		_jsonstr.compose("emLocale3", emLocale3);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("locale", locale);
		_jparser.parseByNameThrow("emLocale", emLocale);
		_jparser.parseByNameThrow("emLocale2", emLocale2);
		_jparser.parseByNameThrow("emLocale3", emLocale3);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EMLOCALE_SET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 locale; _jparser.validateByNameThrow("locale", locale);
		AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
		UINT32 emLocale; _jparser.validateByNameThrow("emLocale", emLocale);
		AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
		UINT32 emLocale2; _jparser.validateByNameThrow("emLocale2", emLocale2);
		AtfValidator::validateInt(_descr, "emLocale2", emLocale2, _checker, __FILE__, __LINE__);
		UINT32 emLocale3; _jparser.validateByNameThrow("emLocale3", emLocale3);
		AtfValidator::validateInt(_descr, "emLocale3", emLocale3, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EMLOCALE_SET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 locale; _parser.parseUINT32(locale);
		AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
		UINT32 emLocale; _parser.parseUINT32(emLocale);
		AtfValidator::validateInt(_descr, "emLocale", emLocale, _checker, __FILE__, __LINE__);
		UINT32 emLocale2; _parser.parseUINT32(emLocale2);
		AtfValidator::validateInt(_descr, "emLocale2", emLocale2, _checker, __FILE__, __LINE__);
		UINT32 emLocale3; _parser.parseUINT32(emLocale3);
		AtfValidator::validateInt(_descr, "emLocale3", emLocale3, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_EMLOCALE_GET
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::Protocol_MSG_LOBBYETC_EMLOCALE_GET()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::equals(const Protocol_MSG_LOBBYETC_EMLOCALE_GET& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_EMLOCALE_GET != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_EMLOCALE_GET*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_EMLOCALE_GET).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_EMLOCALE_GET).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EMLOCALE_GET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EMLOCALE_GET";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY(Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, userLocale(std::move(_o.userLocale))
	, userEmLocale(std::move(_o.userEmLocale))
	, userEmLocale2(std::move(_o.userEmLocale2))
	, userEmLocale3(std::move(_o.userEmLocale3))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::operator=(Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		userLocale = std::move(_o.userLocale);
		userEmLocale = std::move(_o.userEmLocale);
		userEmLocale2 = std::move(_o.userEmLocale2);
		userEmLocale3 = std::move(_o.userEmLocale3);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	userLocale = 0;
	userEmLocale = 0;
	userEmLocale2 = 0;
	userEmLocale3 = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::equals(const Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		userLocale == _o.userLocale &&
		userEmLocale == _o.userEmLocale &&
		userEmLocale2 == _o.userEmLocale2 &&
		userEmLocale3 == _o.userEmLocale3;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_EMLOCALE_GET_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_EMLOCALE_GET_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("userLocale=");
		_buf.appendUint(userLocale);
		_buf.append(',');
		_buf.append("userEmLocale=");
		_buf.appendUint(userEmLocale);
		_buf.append(',');
		_buf.append("userEmLocale2=");
		_buf.appendUint(userEmLocale2);
		_buf.append(',');
		_buf.append("userEmLocale3=");
		_buf.appendUint(userEmLocale3);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_EMLOCALE_GET_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("userLocale", userLocale, _buf);
		Atf::XmlElement::encodeAsXmlElement("userEmLocale", userEmLocale, _buf);
		Atf::XmlElement::encodeAsXmlElement("userEmLocale2", userEmLocale2, _buf);
		Atf::XmlElement::encodeAsXmlElement("userEmLocale3", userEmLocale3, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("userLocale"))
			{
				userLocale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userEmLocale"))
			{
				userEmLocale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userEmLocale2"))
			{
				userEmLocale2 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userEmLocale3"))
			{
				userEmLocale3 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(userLocale);
		_msg.composeUINT32(userEmLocale);
		_msg.composeUINT32(userEmLocale2);
		_msg.composeUINT32(userEmLocale3);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(userLocale);
		_parser.parseUINT32(userEmLocale);
		_parser.parseUINT32(userEmLocale2);
		_parser.parseUINT32(userEmLocale3);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("userLocale", userLocale);
		_jsonstr.compose("userEmLocale", userEmLocale);
		_jsonstr.compose("userEmLocale2", userEmLocale2);
		_jsonstr.compose("userEmLocale3", userEmLocale3);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("userLocale", userLocale);
		_jparser.parseByNameThrow("userEmLocale", userEmLocale);
		_jparser.parseByNameThrow("userEmLocale2", userEmLocale2);
		_jparser.parseByNameThrow("userEmLocale3", userEmLocale3);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EMLOCALE_GET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userLocale; _jparser.validateByNameThrow("userLocale", userLocale);
		AtfValidator::validateInt(_descr, "userLocale", userLocale, _checker, __FILE__, __LINE__);
		UINT32 userEmLocale; _jparser.validateByNameThrow("userEmLocale", userEmLocale);
		AtfValidator::validateInt(_descr, "userEmLocale", userEmLocale, _checker, __FILE__, __LINE__);
		UINT32 userEmLocale2; _jparser.validateByNameThrow("userEmLocale2", userEmLocale2);
		AtfValidator::validateInt(_descr, "userEmLocale2", userEmLocale2, _checker, __FILE__, __LINE__);
		UINT32 userEmLocale3; _jparser.validateByNameThrow("userEmLocale3", userEmLocale3);
		AtfValidator::validateInt(_descr, "userEmLocale3", userEmLocale3, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_EMLOCALE_GET_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 userLocale; _parser.parseUINT32(userLocale);
		AtfValidator::validateInt(_descr, "userLocale", userLocale, _checker, __FILE__, __LINE__);
		UINT32 userEmLocale; _parser.parseUINT32(userEmLocale);
		AtfValidator::validateInt(_descr, "userEmLocale", userEmLocale, _checker, __FILE__, __LINE__);
		UINT32 userEmLocale2; _parser.parseUINT32(userEmLocale2);
		AtfValidator::validateInt(_descr, "userEmLocale2", userEmLocale2, _checker, __FILE__, __LINE__);
		UINT32 userEmLocale3; _parser.parseUINT32(userEmLocale3);
		AtfValidator::validateInt(_descr, "userEmLocale3", userEmLocale3, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneLimitBody
//=================================================================

LobbyEtc::cli::OneLimitBody::OneLimitBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::OneLimitBody::OneLimitBody(OneLimitBody&& _o)
	: limit(std::move(_o.limit))
	, limitCurrency(std::move(_o.limitCurrency))
	, lmitType(std::move(_o.lmitType))
	, hadPrevLimit(std::move(_o.hadPrevLimit))
{
}

LobbyEtc::cli::OneLimitBody& LobbyEtc::cli::OneLimitBody::operator=(OneLimitBody&& _o)
{
	if(this != &_o)
	{
		limit = std::move(_o.limit);
		limitCurrency = std::move(_o.limitCurrency);
		lmitType = std::move(_o.lmitType);
		hadPrevLimit = std::move(_o.hadPrevLimit);
	}
	return *this;
}

#endif

void LobbyEtc::cli::OneLimitBody::clear()
{
	limit = 0;
	limitCurrency.clear();
	lmitType = 0;
	hadPrevLimit = false;
}

bool LobbyEtc::cli::OneLimitBody::equals(const OneLimitBody& _o) const
{
	return limit == _o.limit &&
		Atf::atfPStringEquals(limitCurrency, _o.limitCurrency) &&
		lmitType == _o.lmitType &&
		hadPrevLimit == _o.hadPrevLimit;
}

const char *LobbyEtc::cli::OneLimitBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limit=");
	_buf.appendInt(limit);
	_buf.append(',');
	_buf.append("limitCurrency=");
	_buf.append(limitCurrency);
	_buf.append(',');
	_buf.append("lmitType=");
	_buf.appendUint(lmitType);
	_buf.append(',');
	_buf.append("hadPrevLimit=");
	_buf.appendUint(hadPrevLimit);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::OneLimitBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitCurrency", limitCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("lmitType", lmitType, _buf);
	Atf::XmlElement::encodeAsXmlElement("hadPrevLimit", hadPrevLimit, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::OneLimitBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limit"))
		{
			limit = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limitCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, limitCurrency)) return false;
		}
		else if (_element.equals("lmitType"))
		{
			lmitType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hadPrevLimit"))
		{
			hadPrevLimit = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::OneLimitBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(OneLimitBody())) // not empty
	{
		_body.composeINT32(limit);
		_body.composeString(limitCurrency);
		_body.composeBYTE(lmitType);
		_body.composeBOOL(hadPrevLimit);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::OneLimitBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(limit);
	_parser0.parseStringP(limitCurrency);
	_parser0.parseBYTE(lmitType);
	_parser0.parseBOOL(hadPrevLimit);
}

const char *LobbyEtc::cli::OneLimitBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("limitCurrency", limitCurrency);
	_jsonstr.compose("lmitType", lmitType);
	_jsonstr.compose("hadPrevLimit", hadPrevLimit);
	return _buf.c_str();
}

void LobbyEtc::cli::OneLimitBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("limitCurrency", limitCurrency);
	_jparser.parseByNameThrow("lmitType", lmitType);
	_jparser.parseByNameThrow("hadPrevLimit", hadPrevLimit);
}

/* static */ void LobbyEtc::cli::OneLimitBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	PString limitCurrency; _jparser.validateByNameThrow("limitCurrency", limitCurrency);
	AtfValidator::validateInt(_descr, "limitCurrency", limitCurrency.length(), _checker, __FILE__, __LINE__);
	BYTE lmitType; _jparser.validateByNameThrow("lmitType", lmitType);
	AtfValidator::validateInt(_descr, "lmitType", lmitType, _checker, __FILE__, __LINE__);
	bool hadPrevLimit; _jparser.validateByNameThrow("hadPrevLimit", hadPrevLimit);
	AtfValidator::validateInt(_descr, "hadPrevLimit", hadPrevLimit, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::OneLimitBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT32 limit; _parser0.parseINT32(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "limitCurrency"); size_t szLimitCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "limitCurrency", szLimitCurrency, _checker, __FILE__, __LINE__);
	BYTE lmitType; _parser0.parseBYTE(lmitType);
	AtfValidator::validateInt(_descr, "lmitType", lmitType, _checker, __FILE__, __LINE__);
	bool hadPrevLimit; _parser0.parseBOOL(hadPrevLimit);
	AtfValidator::validateInt(_descr, "hadPrevLimit", hadPrevLimit, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    oneCurrBody
//=================================================================

LobbyEtc::cli::oneCurrBody::oneCurrBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::oneCurrBody::oneCurrBody(oneCurrBody&& _o)
	: currency(std::move(_o.currency))
{
}

LobbyEtc::cli::oneCurrBody& LobbyEtc::cli::oneCurrBody::operator=(oneCurrBody&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void LobbyEtc::cli::oneCurrBody::clear()
{
	currency.clear();
}

bool LobbyEtc::cli::oneCurrBody::equals(const oneCurrBody& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency);
}

const char *LobbyEtc::cli::oneCurrBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::oneCurrBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::oneCurrBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::oneCurrBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(oneCurrBody())) // not empty
	{
		_body.composeString(currency);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::oneCurrBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
}

const char *LobbyEtc::cli::oneCurrBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void LobbyEtc::cli::oneCurrBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
}

/* static */ void LobbyEtc::cli::oneCurrBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::oneCurrBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TABLE_LIMITS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::Protocol_MSG_LOBBY_GET_TABLE_LIMITS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::Protocol_MSG_LOBBY_GET_TABLE_LIMITS(Protocol_MSG_LOBBY_GET_TABLE_LIMITS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS& LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::operator=(Protocol_MSG_LOBBY_GET_TABLE_LIMITS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::clear()
{
	notUsedStr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::equals(const Protocol_MSG_LOBBY_GET_TABLE_LIMITS& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_TABLE_LIMITS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_TABLE_LIMITS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TABLE_LIMITS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_TABLE_LIMITS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY(Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, obsoleteNLlimit(std::move(_o.obsoleteNLlimit))
	, limits(std::move(_o.limits))
	, currencies(std::move(_o.currencies))
	, autoLimitHour(std::move(_o.autoLimitHour))
	, waitingIncreaseNLLimitDays(std::move(_o.waitingIncreaseNLLimitDays))
	, waitingIncreaseFLLimitDays(std::move(_o.waitingIncreaseFLLimitDays))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::operator=(Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		obsoleteNLlimit = std::move(_o.obsoleteNLlimit);
		limits = std::move(_o.limits);
		currencies = std::move(_o.currencies);
		autoLimitHour = std::move(_o.autoLimitHour);
		waitingIncreaseNLLimitDays = std::move(_o.waitingIncreaseNLLimitDays);
		waitingIncreaseFLLimitDays = std::move(_o.waitingIncreaseFLLimitDays);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	obsoleteNLlimit = 0;
	limits.clear();
	currencies.clear();
	autoLimitHour = 0;
	waitingIncreaseNLLimitDays = 0;
	waitingIncreaseFLLimitDays = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::equals(const Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		obsoleteNLlimit == _o.obsoleteNLlimit &&
		limits.equals(_o.limits) &&
		currencies.equals(_o.currencies) &&
		autoLimitHour == _o.autoLimitHour &&
		waitingIncreaseNLLimitDays == _o.waitingIncreaseNLLimitDays &&
		waitingIncreaseFLLimitDays == _o.waitingIncreaseFLLimitDays;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_TABLE_LIMITS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TABLE_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("obsoleteNLlimit=");
		_buf.appendInt(obsoleteNLlimit);
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
		_buf.append(',');
		_buf.append("currencies=");
		currencies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("autoLimitHour=");
		_buf.appendInt(autoLimitHour);
		_buf.append(',');
		_buf.append("waitingIncreaseNLLimitDays=");
		_buf.appendInt(waitingIncreaseNLLimitDays);
		_buf.append(',');
		_buf.append("waitingIncreaseFLLimitDays=");
		_buf.appendInt(waitingIncreaseFLLimitDays);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_TABLE_LIMITS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("obsoleteNLlimit", obsoleteNLlimit, _buf);
		limits.toXmlString("limits", _buf);
		currencies.toXmlString("currencies", _buf);
		Atf::XmlElement::encodeAsXmlElement("autoLimitHour", autoLimitHour, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingIncreaseNLLimitDays", waitingIncreaseNLLimitDays, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingIncreaseFLLimitDays", waitingIncreaseFLLimitDays, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("obsoleteNLlimit"))
			{
				obsoleteNLlimit = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< OneLimitBody, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else if (_element.equals("currencies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< oneCurrBody, 4 > >::FromXmlString(_value, currencies)) return false;
			}
			else if (_element.equals("autoLimitHour"))
			{
				autoLimitHour = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseNLLimitDays"))
			{
				waitingIncreaseNLLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseFLLimitDays"))
			{
				waitingIncreaseFLLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeINT32(obsoleteNLlimit);
		limits.composeMsg(_msg, _ignoreJSON);
		currencies.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(autoLimitHour);
		_msg.composeINT32(waitingIncreaseNLLimitDays);
		_msg.composeINT32(waitingIncreaseFLLimitDays);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseINT32(obsoleteNLlimit);
		limits.parseMsg(_parser);
		currencies.parseMsg(_parser);
		_parser.parseINT32(autoLimitHour);
		_parser.parseINT32(waitingIncreaseNLLimitDays);
		_parser.parseINT32(waitingIncreaseFLLimitDays);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("obsoleteNLlimit", obsoleteNLlimit);
		_jsonstr.compose("limits", limits);
		_jsonstr.compose("currencies", currencies);
		_jsonstr.compose("autoLimitHour", autoLimitHour);
		_jsonstr.compose("waitingIncreaseNLLimitDays", waitingIncreaseNLLimitDays);
		_jsonstr.compose("waitingIncreaseFLLimitDays", waitingIncreaseFLLimitDays);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("obsoleteNLlimit", obsoleteNLlimit);
		_jparser.parseByNameThrow("limits", limits);
		_jparser.parseByNameThrow("currencies", currencies);
		_jparser.parseByNameThrow("autoLimitHour", autoLimitHour);
		_jparser.parseByNameThrow("waitingIncreaseNLLimitDays", waitingIncreaseNLLimitDays);
		_jparser.parseByNameThrow("waitingIncreaseFLLimitDays", waitingIncreaseFLLimitDays);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 obsoleteNLlimit; _jparser.validateByNameThrow("obsoleteNLlimit", obsoleteNLlimit);
		AtfValidator::validateInt(_descr, "obsoleteNLlimit", obsoleteNLlimit, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< OneLimitBody > limits; _jparser.validateByNameThrow("limits", limits);
		AtfValidator::validateInt(_descr, "limits", limits.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< oneCurrBody > currencies; _jparser.validateByNameThrow("currencies", currencies);
		AtfValidator::validateInt(_descr, "currencies", currencies.size(), _checker, __FILE__, __LINE__);
		INT32 autoLimitHour; _jparser.validateByNameThrow("autoLimitHour", autoLimitHour);
		AtfValidator::validateInt(_descr, "autoLimitHour", autoLimitHour, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseNLLimitDays; _jparser.validateByNameThrow("waitingIncreaseNLLimitDays", waitingIncreaseNLLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseNLLimitDays", waitingIncreaseNLLimitDays, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseFLLimitDays; _jparser.validateByNameThrow("waitingIncreaseFLLimitDays", waitingIncreaseFLLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseFLLimitDays", waitingIncreaseFLLimitDays, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TABLE_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 obsoleteNLlimit; _parser.parseINT32(obsoleteNLlimit);
		AtfValidator::validateInt(_descr, "obsoleteNLlimit", obsoleteNLlimit, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szLimits = Atf::LAtfVector< OneLimitBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
		int szCurrencies = Atf::LAtfVector< oneCurrBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "currencies", szCurrencies, _checker, __FILE__, __LINE__);
		INT32 autoLimitHour; _parser.parseINT32(autoLimitHour);
		AtfValidator::validateInt(_descr, "autoLimitHour", autoLimitHour, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseNLLimitDays; _parser.parseINT32(waitingIncreaseNLLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseNLLimitDays", waitingIncreaseNLLimitDays, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseFLLimitDays; _parser.parseINT32(waitingIncreaseFLLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseFLLimitDays", waitingIncreaseFLLimitDays, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TOURN_LIMITS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::Protocol_MSG_LOBBY_GET_TOURN_LIMITS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::Protocol_MSG_LOBBY_GET_TOURN_LIMITS(Protocol_MSG_LOBBY_GET_TOURN_LIMITS&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS& LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::operator=(Protocol_MSG_LOBBY_GET_TOURN_LIMITS&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::clear()
{
	notUsedStr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::equals(const Protocol_MSG_LOBBY_GET_TOURN_LIMITS& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_TOURN_LIMITS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_TOURN_LIMITS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TOURN_LIMITS).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_TOURN_LIMITS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TOURN_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TOURN_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY(Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, limits(std::move(_o.limits))
	, currencies(std::move(_o.currencies))
	, autoLimitHour(std::move(_o.autoLimitHour))
	, waitingIncreaseTournLimitDays(std::move(_o.waitingIncreaseTournLimitDays))
	, waitingIncreaseSNGLimitDays(std::move(_o.waitingIncreaseSNGLimitDays))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::operator=(Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		limits = std::move(_o.limits);
		currencies = std::move(_o.currencies);
		autoLimitHour = std::move(_o.autoLimitHour);
		waitingIncreaseTournLimitDays = std::move(_o.waitingIncreaseTournLimitDays);
		waitingIncreaseSNGLimitDays = std::move(_o.waitingIncreaseSNGLimitDays);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	limits.clear();
	currencies.clear();
	autoLimitHour = 0;
	waitingIncreaseTournLimitDays = 0;
	waitingIncreaseSNGLimitDays = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::equals(const Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		limits.equals(_o.limits) &&
		currencies.equals(_o.currencies) &&
		autoLimitHour == _o.autoLimitHour &&
		waitingIncreaseTournLimitDays == _o.waitingIncreaseTournLimitDays &&
		waitingIncreaseSNGLimitDays == _o.waitingIncreaseSNGLimitDays;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_TOURN_LIMITS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_TOURN_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
		_buf.append(',');
		_buf.append("currencies=");
		currencies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("autoLimitHour=");
		_buf.appendInt(autoLimitHour);
		_buf.append(',');
		_buf.append("waitingIncreaseTournLimitDays=");
		_buf.appendInt(waitingIncreaseTournLimitDays);
		_buf.append(',');
		_buf.append("waitingIncreaseSNGLimitDays=");
		_buf.appendInt(waitingIncreaseSNGLimitDays);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_TOURN_LIMITS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
		currencies.toXmlString("currencies", _buf);
		Atf::XmlElement::encodeAsXmlElement("autoLimitHour", autoLimitHour, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingIncreaseTournLimitDays", waitingIncreaseTournLimitDays, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingIncreaseSNGLimitDays", waitingIncreaseSNGLimitDays, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< OneLimitBody, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else if (_element.equals("currencies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< oneCurrBody, 4 > >::FromXmlString(_value, currencies)) return false;
			}
			else if (_element.equals("autoLimitHour"))
			{
				autoLimitHour = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseTournLimitDays"))
			{
				waitingIncreaseTournLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseSNGLimitDays"))
			{
				waitingIncreaseSNGLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		limits.composeMsg(_msg, _ignoreJSON);
		currencies.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(autoLimitHour);
		_msg.composeINT32(waitingIncreaseTournLimitDays);
		_msg.composeINT32(waitingIncreaseSNGLimitDays);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		limits.parseMsg(_parser);
		currencies.parseMsg(_parser);
		_parser.parseINT32(autoLimitHour);
		_parser.parseINT32(waitingIncreaseTournLimitDays);
		_parser.parseINT32(waitingIncreaseSNGLimitDays);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("limits", limits);
		_jsonstr.compose("currencies", currencies);
		_jsonstr.compose("autoLimitHour", autoLimitHour);
		_jsonstr.compose("waitingIncreaseTournLimitDays", waitingIncreaseTournLimitDays);
		_jsonstr.compose("waitingIncreaseSNGLimitDays", waitingIncreaseSNGLimitDays);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
		_jparser.parseByNameThrow("currencies", currencies);
		_jparser.parseByNameThrow("autoLimitHour", autoLimitHour);
		_jparser.parseByNameThrow("waitingIncreaseTournLimitDays", waitingIncreaseTournLimitDays);
		_jparser.parseByNameThrow("waitingIncreaseSNGLimitDays", waitingIncreaseSNGLimitDays);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TOURN_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< OneLimitBody > limits; _jparser.validateByNameThrow("limits", limits);
		AtfValidator::validateInt(_descr, "limits", limits.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< oneCurrBody > currencies; _jparser.validateByNameThrow("currencies", currencies);
		AtfValidator::validateInt(_descr, "currencies", currencies.size(), _checker, __FILE__, __LINE__);
		INT32 autoLimitHour; _jparser.validateByNameThrow("autoLimitHour", autoLimitHour);
		AtfValidator::validateInt(_descr, "autoLimitHour", autoLimitHour, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseTournLimitDays; _jparser.validateByNameThrow("waitingIncreaseTournLimitDays", waitingIncreaseTournLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseTournLimitDays", waitingIncreaseTournLimitDays, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseSNGLimitDays; _jparser.validateByNameThrow("waitingIncreaseSNGLimitDays", waitingIncreaseSNGLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseSNGLimitDays", waitingIncreaseSNGLimitDays, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_TOURN_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = Atf::LAtfVector< OneLimitBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
		int szCurrencies = Atf::LAtfVector< oneCurrBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "currencies", szCurrencies, _checker, __FILE__, __LINE__);
		INT32 autoLimitHour; _parser.parseINT32(autoLimitHour);
		AtfValidator::validateInt(_descr, "autoLimitHour", autoLimitHour, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseTournLimitDays; _parser.parseINT32(waitingIncreaseTournLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseTournLimitDays", waitingIncreaseTournLimitDays, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseSNGLimitDays; _parser.parseINT32(waitingIncreaseSNGLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseSNGLimitDays", waitingIncreaseSNGLimitDays, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneCasinoLimitBody
//=================================================================

LobbyEtc::cli::OneCasinoLimitBody::OneCasinoLimitBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::OneCasinoLimitBody::OneCasinoLimitBody(OneCasinoLimitBody&& _o)
	: limit(std::move(_o.limit))
	, limitCurrency(std::move(_o.limitCurrency))
	, lmitType(std::move(_o.lmitType))
{
}

LobbyEtc::cli::OneCasinoLimitBody& LobbyEtc::cli::OneCasinoLimitBody::operator=(OneCasinoLimitBody&& _o)
{
	if(this != &_o)
	{
		limit = std::move(_o.limit);
		limitCurrency = std::move(_o.limitCurrency);
		lmitType = std::move(_o.lmitType);
	}
	return *this;
}

#endif

void LobbyEtc::cli::OneCasinoLimitBody::clear()
{
	limit = 0;
	limitCurrency.clear();
	lmitType = 0;
}

bool LobbyEtc::cli::OneCasinoLimitBody::equals(const OneCasinoLimitBody& _o) const
{
	return limit == _o.limit &&
		Atf::atfPStringEquals(limitCurrency, _o.limitCurrency) &&
		lmitType == _o.lmitType;
}

const char *LobbyEtc::cli::OneCasinoLimitBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limit=");
	_buf.appendInt64(limit);
	_buf.append(',');
	_buf.append("limitCurrency=");
	_buf.append(limitCurrency);
	_buf.append(',');
	_buf.append("lmitType=");
	_buf.appendUint(lmitType);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::OneCasinoLimitBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("limitCurrency", limitCurrency, _buf);
	Atf::XmlElement::encodeAsXmlElement("lmitType", lmitType, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::OneCasinoLimitBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limit"))
		{
			limit = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("limitCurrency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, limitCurrency)) return false;
		}
		else if (_element.equals("lmitType"))
		{
			lmitType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::OneCasinoLimitBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(OneCasinoLimitBody())) // not empty
	{
		_body.composeINT64(limit);
		_body.composeString(limitCurrency);
		_body.composeBYTE(lmitType);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::OneCasinoLimitBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(limit);
	_parser0.parseStringP(limitCurrency);
	_parser0.parseBYTE(lmitType);
}

const char *LobbyEtc::cli::OneCasinoLimitBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("limitCurrency", limitCurrency);
	_jsonstr.compose("lmitType", lmitType);
	return _buf.c_str();
}

void LobbyEtc::cli::OneCasinoLimitBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("limitCurrency", limitCurrency);
	_jparser.parseByNameThrow("lmitType", lmitType);
}

/* static */ void LobbyEtc::cli::OneCasinoLimitBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	PString limitCurrency; _jparser.validateByNameThrow("limitCurrency", limitCurrency);
	AtfValidator::validateInt(_descr, "limitCurrency", limitCurrency.length(), _checker, __FILE__, __LINE__);
	BYTE lmitType; _jparser.validateByNameThrow("lmitType", lmitType);
	AtfValidator::validateInt(_descr, "lmitType", lmitType, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::OneCasinoLimitBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT64 limit; _parser0.parseINT64(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "limitCurrency"); size_t szLimitCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "limitCurrency", szLimitCurrency, _checker, __FILE__, __LINE__);
	BYTE lmitType; _parser0.parseBYTE(lmitType);
	AtfValidator::validateInt(_descr, "lmitType", lmitType, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::equals(const Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_CASINO_LIMITS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_CASINO_LIMITS).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_CASINO_LIMITS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_CASINO_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_CASINO_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY(Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limits(std::move(_o.limits))
	, currencies(std::move(_o.currencies))
	, autoApproveHours(std::move(_o.autoApproveHours))
	, waitingIncreaseBlackjackLimitDays(std::move(_o.waitingIncreaseBlackjackLimitDays))
	, hadPrevLimitUK(std::move(_o.hadPrevLimitUK))
	, waitingIncreaseRouletteLimitDays(std::move(_o.waitingIncreaseRouletteLimitDays))
	, waitingIncreaseSlotsLimitDays(std::move(_o.waitingIncreaseSlotsLimitDays))
	, waitingIncreaseOthersLimitDays(std::move(_o.waitingIncreaseOthersLimitDays))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limits = std::move(_o.limits);
		currencies = std::move(_o.currencies);
		autoApproveHours = std::move(_o.autoApproveHours);
		waitingIncreaseBlackjackLimitDays = std::move(_o.waitingIncreaseBlackjackLimitDays);
		hadPrevLimitUK = std::move(_o.hadPrevLimitUK);
		waitingIncreaseRouletteLimitDays = std::move(_o.waitingIncreaseRouletteLimitDays);
		waitingIncreaseSlotsLimitDays = std::move(_o.waitingIncreaseSlotsLimitDays);
		waitingIncreaseOthersLimitDays = std::move(_o.waitingIncreaseOthersLimitDays);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
	currencies.clear();
	autoApproveHours = 0;
	waitingIncreaseBlackjackLimitDays = 0;
	hadPrevLimitUK = false;
	waitingIncreaseRouletteLimitDays = 0;
	waitingIncreaseSlotsLimitDays = 0;
	waitingIncreaseOthersLimitDays = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limits.equals(_o.limits) &&
		currencies.equals(_o.currencies) &&
		autoApproveHours == _o.autoApproveHours &&
		waitingIncreaseBlackjackLimitDays == _o.waitingIncreaseBlackjackLimitDays &&
		hadPrevLimitUK == _o.hadPrevLimitUK &&
		waitingIncreaseRouletteLimitDays == _o.waitingIncreaseRouletteLimitDays &&
		waitingIncreaseSlotsLimitDays == _o.waitingIncreaseSlotsLimitDays &&
		waitingIncreaseOthersLimitDays == _o.waitingIncreaseOthersLimitDays;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
		_buf.append(',');
		_buf.append("currencies=");
		currencies.toTraceString(_buf);
		_buf.append(',');
		_buf.append("autoApproveHours=");
		_buf.appendInt(autoApproveHours);
		_buf.append(',');
		_buf.append("waitingIncreaseBlackjackLimitDays=");
		_buf.appendInt(waitingIncreaseBlackjackLimitDays);
		_buf.append(',');
		_buf.append("hadPrevLimitUK=");
		_buf.appendUint(hadPrevLimitUK);
		_buf.append(',');
		_buf.append("waitingIncreaseRouletteLimitDays=");
		_buf.appendInt(waitingIncreaseRouletteLimitDays);
		_buf.append(',');
		_buf.append("waitingIncreaseSlotsLimitDays=");
		_buf.appendInt(waitingIncreaseSlotsLimitDays);
		_buf.append(',');
		_buf.append("waitingIncreaseOthersLimitDays=");
		_buf.appendInt(waitingIncreaseOthersLimitDays);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
		currencies.toXmlString("currencies", _buf);
		Atf::XmlElement::encodeAsXmlElement("autoApproveHours", autoApproveHours, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingIncreaseBlackjackLimitDays", waitingIncreaseBlackjackLimitDays, _buf);
		Atf::XmlElement::encodeAsXmlElement("hadPrevLimitUK", hadPrevLimitUK, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingIncreaseRouletteLimitDays", waitingIncreaseRouletteLimitDays, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingIncreaseSlotsLimitDays", waitingIncreaseSlotsLimitDays, _buf);
		Atf::XmlElement::encodeAsXmlElement("waitingIncreaseOthersLimitDays", waitingIncreaseOthersLimitDays, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< OneCasinoLimitBody, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else if (_element.equals("currencies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< oneCurrBody, 4 > >::FromXmlString(_value, currencies)) return false;
			}
			else if (_element.equals("autoApproveHours"))
			{
				autoApproveHours = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseBlackjackLimitDays"))
			{
				waitingIncreaseBlackjackLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("hadPrevLimitUK"))
			{
				hadPrevLimitUK = (*_value.ptr() == '1');
			}
			else if (_element.equals("waitingIncreaseRouletteLimitDays"))
			{
				waitingIncreaseRouletteLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseSlotsLimitDays"))
			{
				waitingIncreaseSlotsLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("waitingIncreaseOthersLimitDays"))
			{
				waitingIncreaseOthersLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg, _ignoreJSON);
		currencies.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(autoApproveHours);
		_msg.composeINT32(waitingIncreaseBlackjackLimitDays);
		_msg.composeBOOL(hadPrevLimitUK);
		_msg.composeINT32(waitingIncreaseRouletteLimitDays);
		_msg.composeINT32(waitingIncreaseSlotsLimitDays);
		_msg.composeINT32(waitingIncreaseOthersLimitDays);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
		currencies.parseMsg(_parser);
		_parser.parseINT32(autoApproveHours);
		_parser.parseINT32(waitingIncreaseBlackjackLimitDays);
		_parser.parseBOOL(hadPrevLimitUK);
		_parser.parseINT32(waitingIncreaseRouletteLimitDays);
		_parser.parseINT32(waitingIncreaseSlotsLimitDays);
		_parser.parseINT32(waitingIncreaseOthersLimitDays);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limits", limits);
		_jsonstr.compose("currencies", currencies);
		_jsonstr.compose("autoApproveHours", autoApproveHours);
		_jsonstr.compose("waitingIncreaseBlackjackLimitDays", waitingIncreaseBlackjackLimitDays);
		_jsonstr.compose("hadPrevLimitUK", hadPrevLimitUK);
		_jsonstr.compose("waitingIncreaseRouletteLimitDays", waitingIncreaseRouletteLimitDays);
		_jsonstr.compose("waitingIncreaseSlotsLimitDays", waitingIncreaseSlotsLimitDays);
		_jsonstr.compose("waitingIncreaseOthersLimitDays", waitingIncreaseOthersLimitDays);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
		_jparser.parseByNameThrow("currencies", currencies);
		_jparser.parseByNameThrow("autoApproveHours", autoApproveHours);
		_jparser.parseByNameThrow("waitingIncreaseBlackjackLimitDays", waitingIncreaseBlackjackLimitDays);
		_jparser.parseByNameThrow("hadPrevLimitUK", hadPrevLimitUK);
		_jparser.parseByNameThrow("waitingIncreaseRouletteLimitDays", waitingIncreaseRouletteLimitDays);
		_jparser.parseByNameThrow("waitingIncreaseSlotsLimitDays", waitingIncreaseSlotsLimitDays);
		_jparser.parseByNameThrow("waitingIncreaseOthersLimitDays", waitingIncreaseOthersLimitDays);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< OneCasinoLimitBody > limits; _jparser.validateByNameThrow("limits", limits);
		AtfValidator::validateInt(_descr, "limits", limits.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< oneCurrBody > currencies; _jparser.validateByNameThrow("currencies", currencies);
		AtfValidator::validateInt(_descr, "currencies", currencies.size(), _checker, __FILE__, __LINE__);
		INT32 autoApproveHours; _jparser.validateByNameThrow("autoApproveHours", autoApproveHours);
		AtfValidator::validateInt(_descr, "autoApproveHours", autoApproveHours, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseBlackjackLimitDays; _jparser.validateByNameThrow("waitingIncreaseBlackjackLimitDays", waitingIncreaseBlackjackLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseBlackjackLimitDays", waitingIncreaseBlackjackLimitDays, _checker, __FILE__, __LINE__);
		bool hadPrevLimitUK; _jparser.validateByNameThrow("hadPrevLimitUK", hadPrevLimitUK);
		AtfValidator::validateInt(_descr, "hadPrevLimitUK", hadPrevLimitUK, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseRouletteLimitDays; _jparser.validateByNameThrow("waitingIncreaseRouletteLimitDays", waitingIncreaseRouletteLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseRouletteLimitDays", waitingIncreaseRouletteLimitDays, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseSlotsLimitDays; _jparser.validateByNameThrow("waitingIncreaseSlotsLimitDays", waitingIncreaseSlotsLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseSlotsLimitDays", waitingIncreaseSlotsLimitDays, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseOthersLimitDays; _jparser.validateByNameThrow("waitingIncreaseOthersLimitDays", waitingIncreaseOthersLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseOthersLimitDays", waitingIncreaseOthersLimitDays, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = Atf::LAtfVector< OneCasinoLimitBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
		int szCurrencies = Atf::LAtfVector< oneCurrBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "currencies", szCurrencies, _checker, __FILE__, __LINE__);
		INT32 autoApproveHours; _parser.parseINT32(autoApproveHours);
		AtfValidator::validateInt(_descr, "autoApproveHours", autoApproveHours, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseBlackjackLimitDays; _parser.parseINT32(waitingIncreaseBlackjackLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseBlackjackLimitDays", waitingIncreaseBlackjackLimitDays, _checker, __FILE__, __LINE__);
		bool hadPrevLimitUK; _parser.parseBOOL(hadPrevLimitUK);
		AtfValidator::validateInt(_descr, "hadPrevLimitUK", hadPrevLimitUK, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseRouletteLimitDays; _parser.parseINT32(waitingIncreaseRouletteLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseRouletteLimitDays", waitingIncreaseRouletteLimitDays, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseSlotsLimitDays; _parser.parseINT32(waitingIncreaseSlotsLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseSlotsLimitDays", waitingIncreaseSlotsLimitDays, _checker, __FILE__, __LINE__);
		INT32 waitingIncreaseOthersLimitDays; _parser.parseINT32(waitingIncreaseOthersLimitDays);
		AtfValidator::validateInt(_descr, "waitingIncreaseOthersLimitDays", waitingIncreaseOthersLimitDays, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneSportLimitBody
//=================================================================

LobbyEtc::cli::OneSportLimitBody::OneSportLimitBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::OneSportLimitBody::OneSportLimitBody(OneSportLimitBody&& _o)
	: eLimitType(std::move(_o.eLimitType))
	, amount(std::move(_o.amount))
	, currency(std::move(_o.currency))
	, autoApproveHours(std::move(_o.autoApproveHours))
	, waitingIncreaseLimitDays(std::move(_o.waitingIncreaseLimitDays))
	, hadPrevLimitUK(std::move(_o.hadPrevLimitUK))
{
}

LobbyEtc::cli::OneSportLimitBody& LobbyEtc::cli::OneSportLimitBody::operator=(OneSportLimitBody&& _o)
{
	if(this != &_o)
	{
		eLimitType = std::move(_o.eLimitType);
		amount = std::move(_o.amount);
		currency = std::move(_o.currency);
		autoApproveHours = std::move(_o.autoApproveHours);
		waitingIncreaseLimitDays = std::move(_o.waitingIncreaseLimitDays);
		hadPrevLimitUK = std::move(_o.hadPrevLimitUK);
	}
	return *this;
}

#endif

void LobbyEtc::cli::OneSportLimitBody::clear()
{
	eLimitType = 0;
	amount = 0;
	currency.clear();
	autoApproveHours = 0;
	waitingIncreaseLimitDays = 0;
	hadPrevLimitUK = false;
}

bool LobbyEtc::cli::OneSportLimitBody::equals(const OneSportLimitBody& _o) const
{
	return eLimitType == _o.eLimitType &&
		amount == _o.amount &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		autoApproveHours == _o.autoApproveHours &&
		waitingIncreaseLimitDays == _o.waitingIncreaseLimitDays &&
		hadPrevLimitUK == _o.hadPrevLimitUK;
}

const char *LobbyEtc::cli::OneSportLimitBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("eLimitType=");
	_buf.appendUint(eLimitType);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("autoApproveHours=");
	_buf.appendInt(autoApproveHours);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays=");
	_buf.appendInt(waitingIncreaseLimitDays);
	_buf.append(',');
	_buf.append("hadPrevLimitUK=");
	_buf.appendUint(hadPrevLimitUK);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::OneSportLimitBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("eLimitType", eLimitType, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoApproveHours", autoApproveHours, _buf);
	Atf::XmlElement::encodeAsXmlElement("waitingIncreaseLimitDays", waitingIncreaseLimitDays, _buf);
	Atf::XmlElement::encodeAsXmlElement("hadPrevLimitUK", hadPrevLimitUK, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::OneSportLimitBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("eLimitType"))
		{
			eLimitType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("autoApproveHours"))
		{
			autoApproveHours = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("waitingIncreaseLimitDays"))
		{
			waitingIncreaseLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hadPrevLimitUK"))
		{
			hadPrevLimitUK = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::OneSportLimitBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(OneSportLimitBody())) // not empty
	{
		_body.composeBYTE(eLimitType);
		_body.composeINT64(amount);
		_body.composeString(currency);
		_body.composeINT32(autoApproveHours);
		_body.composeINT32(waitingIncreaseLimitDays);
		_body.composeBOOL(hadPrevLimitUK);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::OneSportLimitBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(eLimitType);
	_parser0.parseINT64(amount);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(autoApproveHours);
	_parser0.parseINT32(waitingIncreaseLimitDays);
	_parser0.parseBOOL(hadPrevLimitUK);
}

const char *LobbyEtc::cli::OneSportLimitBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("eLimitType", eLimitType);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("autoApproveHours", autoApproveHours);
	_jsonstr.compose("waitingIncreaseLimitDays", waitingIncreaseLimitDays);
	_jsonstr.compose("hadPrevLimitUK", hadPrevLimitUK);
	return _buf.c_str();
}

void LobbyEtc::cli::OneSportLimitBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("eLimitType", eLimitType);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("autoApproveHours", autoApproveHours);
	_jparser.parseByNameThrow("waitingIncreaseLimitDays", waitingIncreaseLimitDays);
	_jparser.parseByNameThrow("hadPrevLimitUK", hadPrevLimitUK);
}

/* static */ void LobbyEtc::cli::OneSportLimitBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE eLimitType; _jparser.validateByNameThrow("eLimitType", eLimitType);
	AtfValidator::validateInt(_descr, "eLimitType", eLimitType, _checker, __FILE__, __LINE__);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 autoApproveHours; _jparser.validateByNameThrow("autoApproveHours", autoApproveHours);
	AtfValidator::validateInt(_descr, "autoApproveHours", autoApproveHours, _checker, __FILE__, __LINE__);
	INT32 waitingIncreaseLimitDays; _jparser.validateByNameThrow("waitingIncreaseLimitDays", waitingIncreaseLimitDays);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays", waitingIncreaseLimitDays, _checker, __FILE__, __LINE__);
	bool hadPrevLimitUK; _jparser.validateByNameThrow("hadPrevLimitUK", hadPrevLimitUK);
	AtfValidator::validateInt(_descr, "hadPrevLimitUK", hadPrevLimitUK, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::OneSportLimitBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE eLimitType; _parser0.parseBYTE(eLimitType);
	AtfValidator::validateInt(_descr, "eLimitType", eLimitType, _checker, __FILE__, __LINE__);
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 autoApproveHours; _parser0.parseINT32(autoApproveHours);
	AtfValidator::validateInt(_descr, "autoApproveHours", autoApproveHours, _checker, __FILE__, __LINE__);
	INT32 waitingIncreaseLimitDays; _parser0.parseINT32(waitingIncreaseLimitDays);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays", waitingIncreaseLimitDays, _checker, __FILE__, __LINE__);
	bool hadPrevLimitUK; _parser0.parseBOOL(hadPrevLimitUK);
	AtfValidator::validateInt(_descr, "hadPrevLimitUK", hadPrevLimitUK, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::equals(const Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_SPORT_LIMITS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_SPORT_LIMITS).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_SPORT_LIMITS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SPORT_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SPORT_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY(Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limits(std::move(_o.limits))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limits.equals(_o.limits);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< OneSportLimitBody, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limits", limits);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< OneSportLimitBody > limits; _jparser.validateByNameThrow("limits", limits);
		AtfValidator::validateInt(_descr, "limits", limits.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = Atf::LAtfVector< OneSportLimitBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneGameLimitBody
//=================================================================

LobbyEtc::cli::OneGameLimitBody::OneGameLimitBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::OneGameLimitBody::OneGameLimitBody(OneGameLimitBody&& _o)
	: limType(std::move(_o.limType))
	, amount(std::move(_o.amount))
	, currency(std::move(_o.currency))
	, autoApproveHours(std::move(_o.autoApproveHours))
	, waitingIncreaseLimitDays(std::move(_o.waitingIncreaseLimitDays))
	, hadPrevLimitUK(std::move(_o.hadPrevLimitUK))
	, scheduled(std::move(_o.scheduled))
	, remaining(std::move(_o.remaining))
{
}

LobbyEtc::cli::OneGameLimitBody& LobbyEtc::cli::OneGameLimitBody::operator=(OneGameLimitBody&& _o)
{
	if(this != &_o)
	{
		limType = std::move(_o.limType);
		amount = std::move(_o.amount);
		currency = std::move(_o.currency);
		autoApproveHours = std::move(_o.autoApproveHours);
		waitingIncreaseLimitDays = std::move(_o.waitingIncreaseLimitDays);
		hadPrevLimitUK = std::move(_o.hadPrevLimitUK);
		scheduled = std::move(_o.scheduled);
		remaining = std::move(_o.remaining);
	}
	return *this;
}

#endif

void LobbyEtc::cli::OneGameLimitBody::clear()
{
	limType = 0;
	amount = 0;
	currency.clear();
	autoApproveHours = 0;
	waitingIncreaseLimitDays = 0;
	hadPrevLimitUK = false;
	scheduled.setNull();
	remaining = 0;
}

bool LobbyEtc::cli::OneGameLimitBody::equals(const OneGameLimitBody& _o) const
{
	return limType == _o.limType &&
		amount == _o.amount &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		autoApproveHours == _o.autoApproveHours &&
		waitingIncreaseLimitDays == _o.waitingIncreaseLimitDays &&
		hadPrevLimitUK == _o.hadPrevLimitUK &&
		scheduled.equals(_o.scheduled) &&
		remaining == _o.remaining;
}

const char *LobbyEtc::cli::OneGameLimitBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limType=");
	_buf.appendUint(limType);
	_buf.append(',');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("autoApproveHours=");
	_buf.appendInt(autoApproveHours);
	_buf.append(',');
	_buf.append("waitingIncreaseLimitDays=");
	_buf.appendInt(waitingIncreaseLimitDays);
	_buf.append(',');
	_buf.append("hadPrevLimitUK=");
	_buf.appendUint(hadPrevLimitUK);
	_buf.append(',');
	_buf.append("scheduled=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, scheduled);
	_buf.append(',');
	_buf.append("remaining=");
	_buf.appendInt(remaining);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::OneGameLimitBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limType", limType, _buf);
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("autoApproveHours", autoApproveHours, _buf);
	Atf::XmlElement::encodeAsXmlElement("waitingIncreaseLimitDays", waitingIncreaseLimitDays, _buf);
	Atf::XmlElement::encodeAsXmlElement("hadPrevLimitUK", hadPrevLimitUK, _buf);
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "scheduled", scheduled);
	Atf::XmlElement::encodeAsXmlElement("remaining", remaining, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::OneGameLimitBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limType"))
		{
			limType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("autoApproveHours"))
		{
			autoApproveHours = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("waitingIncreaseLimitDays"))
		{
			waitingIncreaseLimitDays = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hadPrevLimitUK"))
		{
			hadPrevLimitUK = (*_value.ptr() == '1');
		}
		else if (_element.equals("scheduled"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, scheduled);
		}
		else if (_element.equals("remaining"))
		{
			remaining = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::OneGameLimitBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(OneGameLimitBody())) // not empty
	{
		_body.composeBYTE(limType);
		_body.composeINT64(amount);
		_body.composeString(currency);
		_body.composeINT32(autoApproveHours);
		_body.composeINT32(waitingIncreaseLimitDays);
		_body.composeBOOL(hadPrevLimitUK);
		_body.composeSrvTime(scheduled);
		_body.composeINT32(remaining);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::OneGameLimitBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(limType);
	_parser0.parseINT64(amount);
	_parser0.parseStringP(currency);
	_parser0.parseINT32(autoApproveHours);
	_parser0.parseINT32(waitingIncreaseLimitDays);
	_parser0.parseBOOL(hadPrevLimitUK);
	_parser0.parseSrvTime(scheduled);
	_parser0.parseINT32(remaining);
}

const char *LobbyEtc::cli::OneGameLimitBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limType", limType);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("autoApproveHours", autoApproveHours);
	_jsonstr.compose("waitingIncreaseLimitDays", waitingIncreaseLimitDays);
	_jsonstr.compose("hadPrevLimitUK", hadPrevLimitUK);
	_jsonstr.compose("scheduled", scheduled);
	_jsonstr.compose("remaining", remaining);
	return _buf.c_str();
}

void LobbyEtc::cli::OneGameLimitBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limType", limType);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("autoApproveHours", autoApproveHours);
	_jparser.parseByNameThrow("waitingIncreaseLimitDays", waitingIncreaseLimitDays);
	_jparser.parseByNameThrow("hadPrevLimitUK", hadPrevLimitUK);
	_jparser.parseByNameThrow("scheduled", scheduled);
	_jparser.parseByNameThrow("remaining", remaining);
}

/* static */ void LobbyEtc::cli::OneGameLimitBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE limType; _jparser.validateByNameThrow("limType", limType);
	AtfValidator::validateInt(_descr, "limType", limType, _checker, __FILE__, __LINE__);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	INT32 autoApproveHours; _jparser.validateByNameThrow("autoApproveHours", autoApproveHours);
	AtfValidator::validateInt(_descr, "autoApproveHours", autoApproveHours, _checker, __FILE__, __LINE__);
	INT32 waitingIncreaseLimitDays; _jparser.validateByNameThrow("waitingIncreaseLimitDays", waitingIncreaseLimitDays);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays", waitingIncreaseLimitDays, _checker, __FILE__, __LINE__);
	bool hadPrevLimitUK; _jparser.validateByNameThrow("hadPrevLimitUK", hadPrevLimitUK);
	AtfValidator::validateInt(_descr, "hadPrevLimitUK", hadPrevLimitUK, _checker, __FILE__, __LINE__);
	CommSrvTime scheduled; _jparser.validateByNameThrow("scheduled", scheduled);
	AtfValidator::validateSrvDateTime(_descr, "scheduled", scheduled, _checker, __FILE__, __LINE__);
	INT32 remaining; _jparser.validateByNameThrow("remaining", remaining);
	AtfValidator::validateInt(_descr, "remaining", remaining, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::OneGameLimitBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE limType; _parser0.parseBYTE(limType);
	AtfValidator::validateInt(_descr, "limType", limType, _checker, __FILE__, __LINE__);
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateInt(_descr, "amount", amount, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT32 autoApproveHours; _parser0.parseINT32(autoApproveHours);
	AtfValidator::validateInt(_descr, "autoApproveHours", autoApproveHours, _checker, __FILE__, __LINE__);
	INT32 waitingIncreaseLimitDays; _parser0.parseINT32(waitingIncreaseLimitDays);
	AtfValidator::validateInt(_descr, "waitingIncreaseLimitDays", waitingIncreaseLimitDays, _checker, __FILE__, __LINE__);
	bool hadPrevLimitUK; _parser0.parseBOOL(hadPrevLimitUK);
	AtfValidator::validateInt(_descr, "hadPrevLimitUK", hadPrevLimitUK, _checker, __FILE__, __LINE__);
	CommSrvTime scheduled; _parser0.parseSrvTime(scheduled);
	AtfValidator::validateSrvDateTime(_descr, "scheduled", scheduled, _checker, __FILE__, __LINE__);
	INT32 remaining; _parser0.parseINT32(remaining);
	AtfValidator::validateInt(_descr, "remaining", remaining, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::equals(const Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY(Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limits(std::move(_o.limits))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limits.equals(_o.limits);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< OneGameLimitBody, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limits", limits);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< OneGameLimitBody > limits; _jparser.validateByNameThrow("limits", limits);
		AtfValidator::validateInt(_descr, "limits", limits.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = Atf::LAtfVector< OneGameLimitBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_USER_PROPS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::Protocol_MSG_LOBBYETC_GET_USER_PROPS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::equals(const Protocol_MSG_LOBBYETC_GET_USER_PROPS& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_USER_PROPS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_USER_PROPS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_USER_PROPS).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_USER_PROPS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_PROPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_PROPS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY(Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, privileges(std::move(_o.privileges))
	, flags(std::move(_o.flags))
	, locale(std::move(_o.locale))
	, country(std::move(_o.country))
	, privileges2(std::move(_o.privileges2))
	, vipStatus(std::move(_o.vipStatus))
	, timeZone(std::move(_o.timeZone))
	, userIntId(std::move(_o.userIntId))
	, flags2(std::move(_o.flags2))
	, privileges3(std::move(_o.privileges3))
	, clientFeatureVisibilityOnMask(std::move(_o.clientFeatureVisibilityOnMask))
	, clientFeatureVisibilityOffMask(std::move(_o.clientFeatureVisibilityOffMask))
	, clientFeatureVisibilityOnMask2(std::move(_o.clientFeatureVisibilityOnMask2))
	, clientFeatureVisibilityOffMask2(std::move(_o.clientFeatureVisibilityOffMask2))
	, originalUserIntId(std::move(_o.originalUserIntId))
	, fiscalCode(std::move(_o.fiscalCode))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		privileges = std::move(_o.privileges);
		flags = std::move(_o.flags);
		locale = std::move(_o.locale);
		country = std::move(_o.country);
		privileges2 = std::move(_o.privileges2);
		vipStatus = std::move(_o.vipStatus);
		timeZone = std::move(_o.timeZone);
		userIntId = std::move(_o.userIntId);
		flags2 = std::move(_o.flags2);
		privileges3 = std::move(_o.privileges3);
		clientFeatureVisibilityOnMask = std::move(_o.clientFeatureVisibilityOnMask);
		clientFeatureVisibilityOffMask = std::move(_o.clientFeatureVisibilityOffMask);
		clientFeatureVisibilityOnMask2 = std::move(_o.clientFeatureVisibilityOnMask2);
		clientFeatureVisibilityOffMask2 = std::move(_o.clientFeatureVisibilityOffMask2);
		originalUserIntId = std::move(_o.originalUserIntId);
		fiscalCode = std::move(_o.fiscalCode);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	privileges = 0;
	flags = 0;
	locale = 0;
	country.clear();
	privileges2 = 0;
	vipStatus = 0;
	timeZone = 0;
	userIntId = 0;
	flags2 = 0;
	privileges3 = 0;
	clientFeatureVisibilityOnMask = 0;
	clientFeatureVisibilityOffMask = 0;
	clientFeatureVisibilityOnMask2 = 0;
	clientFeatureVisibilityOffMask2 = 0;
	originalUserIntId = 0;
	fiscalCode.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		privileges == _o.privileges &&
		flags == _o.flags &&
		locale == _o.locale &&
		Atf::atfPStringEquals(country, _o.country) &&
		privileges2 == _o.privileges2 &&
		vipStatus == _o.vipStatus &&
		timeZone == _o.timeZone &&
		userIntId == _o.userIntId &&
		flags2 == _o.flags2 &&
		privileges3 == _o.privileges3 &&
		clientFeatureVisibilityOnMask == _o.clientFeatureVisibilityOnMask &&
		clientFeatureVisibilityOffMask == _o.clientFeatureVisibilityOffMask &&
		clientFeatureVisibilityOnMask2 == _o.clientFeatureVisibilityOnMask2 &&
		clientFeatureVisibilityOffMask2 == _o.clientFeatureVisibilityOffMask2 &&
		originalUserIntId == _o.originalUserIntId &&
		Atf::atfPStringEquals(fiscalCode, _o.fiscalCode);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_USER_PROPS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_USER_PROPS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("privileges=");
		_buf.appendUint(privileges);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("locale=");
		_buf.appendUint(locale);
		_buf.append(',');
		_buf.append("country=");
		_buf.append(country);
		_buf.append(',');
		_buf.append("privileges2=");
		_buf.appendUint64(privileges2);
		_buf.append(',');
		_buf.append("vipStatus=");
		_buf.appendUint(vipStatus);
		_buf.append(',');
		_buf.append("timeZone=");
		_buf.appendUint(timeZone);
		_buf.append(',');
		_buf.append("userIntId=");
		_buf.appendUint(userIntId);
		_buf.append(',');
		_buf.append("flags2=");
		_buf.appendUint64(flags2);
		_buf.append(',');
		_buf.append("privileges3=");
		_buf.appendUint64(privileges3);
		_buf.append(',');
		_buf.append("clientFeatureVisibilityOnMask=");
		_buf.appendUint64(clientFeatureVisibilityOnMask);
		_buf.append(',');
		_buf.append("clientFeatureVisibilityOffMask=");
		_buf.appendUint64(clientFeatureVisibilityOffMask);
		_buf.append(',');
		_buf.append("clientFeatureVisibilityOnMask2=");
		_buf.appendUint64(clientFeatureVisibilityOnMask2);
		_buf.append(',');
		_buf.append("clientFeatureVisibilityOffMask2=");
		_buf.appendUint64(clientFeatureVisibilityOffMask2);
		_buf.append(',');
		_buf.append("originalUserIntId=");
		_buf.appendUint(originalUserIntId);
		_buf.append(',');
		_buf.append("fiscalCode=");
		_buf.append(fiscalCode);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_USER_PROPS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("privileges", privileges, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
		Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
		Atf::XmlElement::encodeAsXmlElement("country", country, _buf);
		Atf::XmlElement::encodeAsXmlElement("privileges2", privileges2, _buf);
		Atf::XmlElement::encodeAsXmlElement("vipStatus", vipStatus, _buf);
		Atf::XmlElement::encodeAsXmlElement("timeZone", timeZone, _buf);
		Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
		Atf::XmlElement::encodeAsXmlElement("privileges3", privileges3, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2, _buf);
		Atf::XmlElement::encodeAsXmlElement("clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2, _buf);
		Atf::XmlElement::encodeAsXmlElement("originalUserIntId", originalUserIntId, _buf);
		Atf::XmlElement::encodeAsXmlElement("fiscalCode", fiscalCode, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("privileges"))
			{
				privileges = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("country"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, country)) return false;
			}
			else if (_element.equals("privileges2"))
			{
				privileges2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipStatus"))
			{
				vipStatus = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeZone"))
			{
				timeZone = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIntId"))
			{
				userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags2"))
			{
				flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privileges3"))
			{
				privileges3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientFeatureVisibilityOnMask"))
			{
				clientFeatureVisibilityOnMask = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientFeatureVisibilityOffMask"))
			{
				clientFeatureVisibilityOffMask = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientFeatureVisibilityOnMask2"))
			{
				clientFeatureVisibilityOnMask2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clientFeatureVisibilityOffMask2"))
			{
				clientFeatureVisibilityOffMask2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("originalUserIntId"))
			{
				originalUserIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fiscalCode"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, fiscalCode)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT32(privileges);
		_msg.composeUINT32(flags);
		_msg.composeUINT32(locale);
		_msg.composeString(country);
		_msg.composeUINT64(privileges2);
		_msg.composeUINT32(vipStatus);
		_msg.composeUINT32(timeZone);
		_msg.composeUINT32(userIntId);
		_msg.composeUINT64(flags2);
		_msg.composeUINT64(privileges3);
		CommMsgBody _msg0;
		_msg0.composeUINT64(clientFeatureVisibilityOnMask);
		_msg0.composeUINT64(clientFeatureVisibilityOffMask);
		_msg0.composeUINT64(clientFeatureVisibilityOnMask2);
		_msg0.composeUINT64(clientFeatureVisibilityOffMask2);
		_msg.composeMsgBody(_msg0);
		_msg.composeUINT32(originalUserIntId);
		_msg.composeString(fiscalCode);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT32(privileges);
		_parser.parseUINT32(flags);
		_parser.parseUINT32(locale);
		_parser.parseStringP(country);
		_parser.parseUINT64(privileges2);
		_parser.parseUINT32(vipStatus);
		_parser.parseUINT32(timeZone);
		_parser.parseUINT32(userIntId);
		_parser.parseUINT64(flags2);
		_parser.parseUINT64(privileges3);
		parseAnonymousMsgBody0(_parser);
		_parser.parseUINT32(originalUserIntId);
		_parser.parseStringP(fiscalCode);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("privileges", privileges);
		_jsonstr.compose("flags", flags);
		_jsonstr.compose("locale", locale);
		_jsonstr.compose("country", country);
		_jsonstr.compose("privileges2", privileges2);
		_jsonstr.compose("vipStatus", vipStatus);
		_jsonstr.compose("timeZone", timeZone);
		_jsonstr.compose("userIntId", userIntId);
		_jsonstr.compose("flags2", flags2);
		_jsonstr.compose("privileges3", privileges3);
		_jsonstr.compose("clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask);
		_jsonstr.compose("clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask);
		_jsonstr.compose("clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2);
		_jsonstr.compose("clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2);
		_jsonstr.compose("originalUserIntId", originalUserIntId);
		_jsonstr.compose("fiscalCode", fiscalCode);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("privileges", privileges);
		_jparser.parseByNameThrow("flags", flags);
		_jparser.parseByNameThrow("locale", locale);
		_jparser.parseByNameThrow("country", country);
		_jparser.parseByNameThrow("privileges2", privileges2);
		_jparser.parseByNameThrow("vipStatus", vipStatus);
		_jparser.parseByNameThrow("timeZone", timeZone);
		_jparser.parseByNameThrow("userIntId", userIntId);
		_jparser.parseByNameThrow("flags2", flags2);
		_jparser.parseByNameThrow("privileges3", privileges3);
		_jparser.parseByNameThrow("clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask);
		_jparser.parseByNameThrow("clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask);
		_jparser.parseByNameThrow("clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2);
		_jparser.parseByNameThrow("clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2);
		_jparser.parseByNameThrow("originalUserIntId", originalUserIntId);
		_jparser.parseByNameThrow("fiscalCode", fiscalCode);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_PROPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 privileges; _jparser.validateByNameThrow("privileges", privileges);
		AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
		UINT32 flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 locale; _jparser.validateByNameThrow("locale", locale);
		AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
		PString country; _jparser.validateByNameThrow("country", country);
		AtfValidator::validateInt(_descr, "country", country.length(), _checker, __FILE__, __LINE__);
		UINT64 privileges2; _jparser.validateByNameThrow("privileges2", privileges2);
		AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
		UINT32 vipStatus; _jparser.validateByNameThrow("vipStatus", vipStatus);
		AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
		UINT32 timeZone; _jparser.validateByNameThrow("timeZone", timeZone);
		AtfValidator::validateInt(_descr, "timeZone", timeZone, _checker, __FILE__, __LINE__);
		UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
		UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _jparser.validateByNameThrow("privileges3", privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		UINT64 clientFeatureVisibilityOnMask; _jparser.validateByNameThrow("clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask);
		AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask, _checker, __FILE__, __LINE__);
		UINT64 clientFeatureVisibilityOffMask; _jparser.validateByNameThrow("clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask);
		AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask, _checker, __FILE__, __LINE__);
		UINT64 clientFeatureVisibilityOnMask2; _jparser.validateByNameThrow("clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2);
		AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2, _checker, __FILE__, __LINE__);
		UINT64 clientFeatureVisibilityOffMask2; _jparser.validateByNameThrow("clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2);
		AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2, _checker, __FILE__, __LINE__);
		UINT32 originalUserIntId; _jparser.validateByNameThrow("originalUserIntId", originalUserIntId);
		AtfValidator::validateInt(_descr, "originalUserIntId", originalUserIntId, _checker, __FILE__, __LINE__);
		PString fiscalCode; _jparser.validateByNameThrow("fiscalCode", fiscalCode);
		AtfValidator::validateInt(_descr, "fiscalCode", fiscalCode.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_PROPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 privileges; _parser.parseUINT32(privileges);
		AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		UINT32 locale; _parser.parseUINT32(locale);
		AtfValidator::validateInt(_descr, "locale", locale, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "country"); size_t szCountry = strlen(_dummy);
		AtfValidator::validateInt(_descr, "country", szCountry, _checker, __FILE__, __LINE__);
		UINT64 privileges2; _parser.parseUINT64(privileges2);
		AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
		UINT32 vipStatus; _parser.parseUINT32(vipStatus);
		AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
		UINT32 timeZone; _parser.parseUINT32(timeZone);
		AtfValidator::validateInt(_descr, "timeZone", timeZone, _checker, __FILE__, __LINE__);
		UINT32 userIntId; _parser.parseUINT32(userIntId);
		AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
		UINT64 flags2; _parser.parseUINT64(flags2);
		AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
		UINT64 privileges3; _parser.parseUINT64(privileges3);
		AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
		UINT32 originalUserIntId; _parser.parseUINT32(originalUserIntId);
		AtfValidator::validateInt(_descr, "originalUserIntId", originalUserIntId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "fiscalCode"); size_t szFiscalCode = strlen(_dummy);
		AtfValidator::validateInt(_descr, "fiscalCode", szFiscalCode, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT64(clientFeatureVisibilityOnMask);
	_parser0.parseUINT64(clientFeatureVisibilityOffMask);
	_parser0.parseUINT64(clientFeatureVisibilityOnMask2);
	_parser0.parseUINT64(clientFeatureVisibilityOffMask2);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT64 clientFeatureVisibilityOnMask; _parser0.parseUINT64(clientFeatureVisibilityOnMask);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask", clientFeatureVisibilityOnMask, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOffMask; _parser0.parseUINT64(clientFeatureVisibilityOffMask);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask", clientFeatureVisibilityOffMask, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOnMask2; _parser0.parseUINT64(clientFeatureVisibilityOnMask2);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOnMask2", clientFeatureVisibilityOnMask2, _checker, __FILE__, __LINE__);
	UINT64 clientFeatureVisibilityOffMask2; _parser0.parseUINT64(clientFeatureVisibilityOffMask2);
	AtfValidator::validateUint(_descr, "clientFeatureVisibilityOffMask2", clientFeatureVisibilityOffMask2, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    UserFppBundleSingleLevelBody
//=================================================================

LobbyEtc::cli::UserFppBundleSingleLevelBody::UserFppBundleSingleLevelBody()
{
	clear();
}

void LobbyEtc::cli::UserFppBundleSingleLevelBody::clear()
{
	accVpp = 0;
	fppReward = 0;
	targetType = 0;
	penalty = 0;
	vipOrd = 0;
}

bool LobbyEtc::cli::UserFppBundleSingleLevelBody::equals(const UserFppBundleSingleLevelBody& _o) const
{
	return accVpp == _o.accVpp &&
		fppReward == _o.fppReward &&
		targetType == _o.targetType &&
		penalty == _o.penalty &&
		vipOrd == _o.vipOrd;
}

const char *LobbyEtc::cli::UserFppBundleSingleLevelBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("accVpp=");
	_buf.appendInt(accVpp);
	_buf.append(',');
	_buf.append("fppReward=");
	_buf.appendInt(fppReward);
	_buf.append(',');
	_buf.append("targetType=");
	_buf.appendInt(targetType);
	_buf.append(',');
	_buf.append("penalty=");
	_buf.appendInt(penalty);
	_buf.append(',');
	_buf.append("vipOrd=");
	_buf.appendInt(vipOrd);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::UserFppBundleSingleLevelBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("accVpp", accVpp, _buf);
	Atf::XmlElement::encodeAsXmlElement("fppReward", fppReward, _buf);
	Atf::XmlElement::encodeAsXmlElement("targetType", targetType, _buf);
	Atf::XmlElement::encodeAsXmlElement("penalty", penalty, _buf);
	Atf::XmlElement::encodeAsXmlElement("vipOrd", vipOrd, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::UserFppBundleSingleLevelBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("accVpp"))
		{
			accVpp = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("fppReward"))
		{
			fppReward = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("targetType"))
		{
			targetType = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("penalty"))
		{
			penalty = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("vipOrd"))
		{
			vipOrd = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::UserFppBundleSingleLevelBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(UserFppBundleSingleLevelBody())) // not empty
	{
		_body.composeINT32(accVpp);
		_body.composeINT32(fppReward);
		_body.composeINT16(targetType);
		_body.composeINT16(penalty);
		_body.composeINT32(vipOrd);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::UserFppBundleSingleLevelBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT32(accVpp);
	_parser0.parseINT32(fppReward);
	_parser0.parseINT16(targetType);
	_parser0.parseINT16(penalty);
	_parser0.parseINT32(vipOrd);
}

const char *LobbyEtc::cli::UserFppBundleSingleLevelBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("accVpp", accVpp);
	_jsonstr.compose("fppReward", fppReward);
	_jsonstr.compose("targetType", targetType);
	_jsonstr.compose("penalty", penalty);
	_jsonstr.compose("vipOrd", vipOrd);
	return _buf.c_str();
}

void LobbyEtc::cli::UserFppBundleSingleLevelBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("accVpp", accVpp);
	_jparser.parseByNameThrow("fppReward", fppReward);
	_jparser.parseByNameThrow("targetType", targetType);
	_jparser.parseByNameThrow("penalty", penalty);
	_jparser.parseByNameThrow("vipOrd", vipOrd);
}

/* static */ void LobbyEtc::cli::UserFppBundleSingleLevelBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 accVpp; _jparser.validateByNameThrow("accVpp", accVpp);
	AtfValidator::validateInt(_descr, "accVpp", accVpp, _checker, __FILE__, __LINE__);
	INT32 fppReward; _jparser.validateByNameThrow("fppReward", fppReward);
	AtfValidator::validateInt(_descr, "fppReward", fppReward, _checker, __FILE__, __LINE__);
	INT16 targetType; _jparser.validateByNameThrow("targetType", targetType);
	AtfValidator::validateInt(_descr, "targetType", targetType, _checker, __FILE__, __LINE__);
	INT16 penalty; _jparser.validateByNameThrow("penalty", penalty);
	AtfValidator::validateInt(_descr, "penalty", penalty, _checker, __FILE__, __LINE__);
	INT32 vipOrd; _jparser.validateByNameThrow("vipOrd", vipOrd);
	AtfValidator::validateInt(_descr, "vipOrd", vipOrd, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::UserFppBundleSingleLevelBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT32 accVpp; _parser0.parseINT32(accVpp);
	AtfValidator::validateInt(_descr, "accVpp", accVpp, _checker, __FILE__, __LINE__);
	INT32 fppReward; _parser0.parseINT32(fppReward);
	AtfValidator::validateInt(_descr, "fppReward", fppReward, _checker, __FILE__, __LINE__);
	INT16 targetType; _parser0.parseINT16(targetType);
	AtfValidator::validateInt(_descr, "targetType", targetType, _checker, __FILE__, __LINE__);
	INT16 penalty; _parser0.parseINT16(penalty);
	AtfValidator::validateInt(_descr, "penalty", penalty, _checker, __FILE__, __LINE__);
	INT32 vipOrd; _parser0.parseINT32(vipOrd);
	AtfValidator::validateInt(_descr, "vipOrd", vipOrd, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::equals(const Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY(Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, vppMonthly(std::move(_o.vppMonthly))
	, vppYearly(std::move(_o.vppYearly))
	, vipStatus(std::move(_o.vipStatus))
	, fpp(std::move(_o.fpp))
	, warningDays(std::move(_o.warningDays))
	, rewardPercent(std::move(_o.rewardPercent))
	, notificationPercent(std::move(_o.notificationPercent))
	, vipLevelBundles(std::move(_o.vipLevelBundles))
	, nextLevelRewardPercent(std::move(_o.nextLevelRewardPercent))
	, vppMonthlyCentsOnly(std::move(_o.vppMonthlyCentsOnly))
	, vppYearlyCentsOnly(std::move(_o.vppYearlyCentsOnly))
	, supernovaFlags(std::move(_o.supernovaFlags))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		vppMonthly = std::move(_o.vppMonthly);
		vppYearly = std::move(_o.vppYearly);
		vipStatus = std::move(_o.vipStatus);
		fpp = std::move(_o.fpp);
		warningDays = std::move(_o.warningDays);
		rewardPercent = std::move(_o.rewardPercent);
		notificationPercent = std::move(_o.notificationPercent);
		vipLevelBundles = std::move(_o.vipLevelBundles);
		nextLevelRewardPercent = std::move(_o.nextLevelRewardPercent);
		vppMonthlyCentsOnly = std::move(_o.vppMonthlyCentsOnly);
		vppYearlyCentsOnly = std::move(_o.vppYearlyCentsOnly);
		supernovaFlags = std::move(_o.supernovaFlags);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	vppMonthly = 0;
	vppYearly = 0;
	vipStatus = 0;
	fpp = 0;
	warningDays = 0;
	rewardPercent = 0;
	notificationPercent = 0;
	vipLevelBundles.clear();
	nextLevelRewardPercent = 0;
	vppMonthlyCentsOnly = 0;
	vppYearlyCentsOnly = 0;
	supernovaFlags = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		vppMonthly == _o.vppMonthly &&
		vppYearly == _o.vppYearly &&
		vipStatus == _o.vipStatus &&
		fpp == _o.fpp &&
		warningDays == _o.warningDays &&
		rewardPercent == _o.rewardPercent &&
		notificationPercent == _o.notificationPercent &&
		vipLevelBundles.equals(_o.vipLevelBundles) &&
		nextLevelRewardPercent == _o.nextLevelRewardPercent &&
		vppMonthlyCentsOnly == _o.vppMonthlyCentsOnly &&
		vppYearlyCentsOnly == _o.vppYearlyCentsOnly &&
		supernovaFlags == _o.supernovaFlags;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("vppMonthly=");
		_buf.appendUint64(vppMonthly);
		_buf.append(',');
		_buf.append("vppYearly=");
		_buf.appendUint64(vppYearly);
		_buf.append(',');
		_buf.append("vipStatus=");
		_buf.appendInt(vipStatus);
		_buf.append(',');
		_buf.append("fpp=");
		_buf.appendUint(fpp);
		_buf.append(',');
		_buf.append("warningDays=");
		_buf.appendInt(warningDays);
		_buf.append(',');
		_buf.append("rewardPercent=");
		_buf.appendInt(rewardPercent);
		_buf.append(',');
		_buf.append("notificationPercent=");
		_buf.appendInt(notificationPercent);
		_buf.append(',');
		_buf.append("vipLevelBundles=");
		vipLevelBundles.toTraceString(_buf);
		_buf.append(',');
		_buf.append("nextLevelRewardPercent=");
		_buf.appendInt(nextLevelRewardPercent);
		_buf.append(',');
		_buf.append("vppMonthlyCentsOnly=");
		_buf.appendInt(vppMonthlyCentsOnly);
		_buf.append(',');
		_buf.append("vppYearlyCentsOnly=");
		_buf.appendInt(vppYearlyCentsOnly);
		_buf.append(',');
		_buf.append("supernovaFlags=");
		_buf.appendInt(supernovaFlags);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("vppMonthly", vppMonthly, _buf);
		Atf::XmlElement::encodeAsXmlElement("vppYearly", vppYearly, _buf);
		Atf::XmlElement::encodeAsXmlElement("vipStatus", vipStatus, _buf);
		Atf::XmlElement::encodeAsXmlElement("fpp", fpp, _buf);
		Atf::XmlElement::encodeAsXmlElement("warningDays", warningDays, _buf);
		Atf::XmlElement::encodeAsXmlElement("rewardPercent", rewardPercent, _buf);
		Atf::XmlElement::encodeAsXmlElement("notificationPercent", notificationPercent, _buf);
		vipLevelBundles.toXmlString("vipLevelBundles", _buf);
		Atf::XmlElement::encodeAsXmlElement("nextLevelRewardPercent", nextLevelRewardPercent, _buf);
		Atf::XmlElement::encodeAsXmlElement("vppMonthlyCentsOnly", vppMonthlyCentsOnly, _buf);
		Atf::XmlElement::encodeAsXmlElement("vppYearlyCentsOnly", vppYearlyCentsOnly, _buf);
		Atf::XmlElement::encodeAsXmlElement("supernovaFlags", supernovaFlags, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("vppMonthly"))
			{
				vppMonthly = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vppYearly"))
			{
				vppYearly = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipStatus"))
			{
				vipStatus = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("fpp"))
			{
				fpp = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("warningDays"))
			{
				warningDays = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("rewardPercent"))
			{
				rewardPercent = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notificationPercent"))
			{
				notificationPercent = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vipLevelBundles"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserFppBundleSingleLevelBody, 4 > >::FromXmlString(_value, vipLevelBundles)) return false;
			}
			else if (_element.equals("nextLevelRewardPercent"))
			{
				nextLevelRewardPercent = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vppMonthlyCentsOnly"))
			{
				vppMonthlyCentsOnly = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("vppYearlyCentsOnly"))
			{
				vppYearlyCentsOnly = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("supernovaFlags"))
			{
				supernovaFlags = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeUINT64(vppMonthly);
		_msg.composeUINT64(vppYearly);
		_msg.composeINT16(vipStatus);
		_msg.composeUINT32(fpp);
		_msg.composeINT32(warningDays);
		_msg.composeINT32(rewardPercent);
		_msg.composeINT32(notificationPercent);
		vipLevelBundles.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(nextLevelRewardPercent);
		_msg.composeINT32(vppMonthlyCentsOnly);
		_msg.composeINT32(vppYearlyCentsOnly);
		_msg.composeINT8(supernovaFlags);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseUINT64(vppMonthly);
		_parser.parseUINT64(vppYearly);
		_parser.parseINT16(vipStatus);
		_parser.parseUINT32(fpp);
		_parser.parseINT32(warningDays);
		_parser.parseINT32(rewardPercent);
		_parser.parseINT32(notificationPercent);
		vipLevelBundles.parseMsg(_parser);
		_parser.parseINT32(nextLevelRewardPercent);
		_parser.parseINT32(vppMonthlyCentsOnly);
		_parser.parseINT32(vppYearlyCentsOnly);
		_parser.parseINT8(supernovaFlags);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("vppMonthly", vppMonthly);
		_jsonstr.compose("vppYearly", vppYearly);
		_jsonstr.compose("vipStatus", vipStatus);
		_jsonstr.compose("fpp", fpp);
		_jsonstr.compose("warningDays", warningDays);
		_jsonstr.compose("rewardPercent", rewardPercent);
		_jsonstr.compose("notificationPercent", notificationPercent);
		_jsonstr.compose("vipLevelBundles", vipLevelBundles);
		_jsonstr.compose("nextLevelRewardPercent", nextLevelRewardPercent);
		_jsonstr.compose("vppMonthlyCentsOnly", vppMonthlyCentsOnly);
		_jsonstr.compose("vppYearlyCentsOnly", vppYearlyCentsOnly);
		_jsonstr.compose("supernovaFlags", supernovaFlags);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("vppMonthly", vppMonthly);
		_jparser.parseByNameThrow("vppYearly", vppYearly);
		_jparser.parseByNameThrow("vipStatus", vipStatus);
		_jparser.parseByNameThrow("fpp", fpp);
		_jparser.parseByNameThrow("warningDays", warningDays);
		_jparser.parseByNameThrow("rewardPercent", rewardPercent);
		_jparser.parseByNameThrow("notificationPercent", notificationPercent);
		_jparser.parseByNameThrow("vipLevelBundles", vipLevelBundles);
		_jparser.parseByNameThrow("nextLevelRewardPercent", nextLevelRewardPercent);
		_jparser.parseByNameThrow("vppMonthlyCentsOnly", vppMonthlyCentsOnly);
		_jparser.parseByNameThrow("vppYearlyCentsOnly", vppYearlyCentsOnly);
		_jparser.parseByNameThrow("supernovaFlags", supernovaFlags);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 vppMonthly; _jparser.validateByNameThrow("vppMonthly", vppMonthly);
		AtfValidator::validateUint(_descr, "vppMonthly", vppMonthly, _checker, __FILE__, __LINE__);
		UINT64 vppYearly; _jparser.validateByNameThrow("vppYearly", vppYearly);
		AtfValidator::validateUint(_descr, "vppYearly", vppYearly, _checker, __FILE__, __LINE__);
		INT16 vipStatus; _jparser.validateByNameThrow("vipStatus", vipStatus);
		AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
		UINT32 fpp; _jparser.validateByNameThrow("fpp", fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		INT32 warningDays; _jparser.validateByNameThrow("warningDays", warningDays);
		AtfValidator::validateInt(_descr, "warningDays", warningDays, _checker, __FILE__, __LINE__);
		INT32 rewardPercent; _jparser.validateByNameThrow("rewardPercent", rewardPercent);
		AtfValidator::validateInt(_descr, "rewardPercent", rewardPercent, _checker, __FILE__, __LINE__);
		INT32 notificationPercent; _jparser.validateByNameThrow("notificationPercent", notificationPercent);
		AtfValidator::validateInt(_descr, "notificationPercent", notificationPercent, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UserFppBundleSingleLevelBody > vipLevelBundles; _jparser.validateByNameThrow("vipLevelBundles", vipLevelBundles);
		AtfValidator::validateInt(_descr, "vipLevelBundles", vipLevelBundles.size(), _checker, __FILE__, __LINE__);
		INT32 nextLevelRewardPercent; _jparser.validateByNameThrow("nextLevelRewardPercent", nextLevelRewardPercent);
		AtfValidator::validateInt(_descr, "nextLevelRewardPercent", nextLevelRewardPercent, _checker, __FILE__, __LINE__);
		INT32 vppMonthlyCentsOnly; _jparser.validateByNameThrow("vppMonthlyCentsOnly", vppMonthlyCentsOnly);
		AtfValidator::validateInt(_descr, "vppMonthlyCentsOnly", vppMonthlyCentsOnly, _checker, __FILE__, __LINE__);
		INT32 vppYearlyCentsOnly; _jparser.validateByNameThrow("vppYearlyCentsOnly", vppYearlyCentsOnly);
		AtfValidator::validateInt(_descr, "vppYearlyCentsOnly", vppYearlyCentsOnly, _checker, __FILE__, __LINE__);
		INT8 supernovaFlags; _jparser.validateByNameThrow("supernovaFlags", supernovaFlags);
		AtfValidator::validateInt(_descr, "supernovaFlags", supernovaFlags, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT64 vppMonthly; _parser.parseUINT64(vppMonthly);
		AtfValidator::validateUint(_descr, "vppMonthly", vppMonthly, _checker, __FILE__, __LINE__);
		UINT64 vppYearly; _parser.parseUINT64(vppYearly);
		AtfValidator::validateUint(_descr, "vppYearly", vppYearly, _checker, __FILE__, __LINE__);
		INT16 vipStatus; _parser.parseINT16(vipStatus);
		AtfValidator::validateInt(_descr, "vipStatus", vipStatus, _checker, __FILE__, __LINE__);
		UINT32 fpp; _parser.parseUINT32(fpp);
		AtfValidator::validateInt(_descr, "fpp", fpp, _checker, __FILE__, __LINE__);
		INT32 warningDays; _parser.parseINT32(warningDays);
		AtfValidator::validateInt(_descr, "warningDays", warningDays, _checker, __FILE__, __LINE__);
		INT32 rewardPercent; _parser.parseINT32(rewardPercent);
		AtfValidator::validateInt(_descr, "rewardPercent", rewardPercent, _checker, __FILE__, __LINE__);
		INT32 notificationPercent; _parser.parseINT32(notificationPercent);
		AtfValidator::validateInt(_descr, "notificationPercent", notificationPercent, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szVipLevelBundles = Atf::LAtfVector< UserFppBundleSingleLevelBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("vipLevelBundles"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "vipLevelBundles", szVipLevelBundles, _checker, __FILE__, __LINE__);
		INT32 nextLevelRewardPercent; _parser.parseINT32(nextLevelRewardPercent);
		AtfValidator::validateInt(_descr, "nextLevelRewardPercent", nextLevelRewardPercent, _checker, __FILE__, __LINE__);
		INT32 vppMonthlyCentsOnly; _parser.parseINT32(vppMonthlyCentsOnly);
		AtfValidator::validateInt(_descr, "vppMonthlyCentsOnly", vppMonthlyCentsOnly, _checker, __FILE__, __LINE__);
		INT32 vppYearlyCentsOnly; _parser.parseINT32(vppYearlyCentsOnly);
		AtfValidator::validateInt(_descr, "vppYearlyCentsOnly", vppYearlyCentsOnly, _checker, __FILE__, __LINE__);
		INT8 supernovaFlags; _parser.parseINT8(supernovaFlags);
		AtfValidator::validateInt(_descr, "supernovaFlags", supernovaFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::equals(const Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY(Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, limits(std::move(_o.limits))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	limits.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		limits.equals(_o.limits);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("limits=");
		limits.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		limits.toXmlString("limits", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< OneSportLimitBody, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		limits.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		limits.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("limits", limits);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("limits", limits);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< OneSportLimitBody > limits; _jparser.validateByNameThrow("limits", limits);
		AtfValidator::validateInt(_descr, "limits", limits.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szLimits = Atf::LAtfVector< OneSportLimitBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "limits", szLimits, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    HistoryBody
//=================================================================

LobbyEtc::cli::HistoryBody::HistoryBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::HistoryBody::HistoryBody(HistoryBody&& _o)
	: loginTime(std::move(_o.loginTime))
	, isp(std::move(_o.isp))
	, ipCountry(std::move(_o.ipCountry))
	, ipAddress(std::move(_o.ipAddress))
{
}

LobbyEtc::cli::HistoryBody& LobbyEtc::cli::HistoryBody::operator=(HistoryBody&& _o)
{
	if(this != &_o)
	{
		loginTime = std::move(_o.loginTime);
		isp = std::move(_o.isp);
		ipCountry = std::move(_o.ipCountry);
		ipAddress = std::move(_o.ipAddress);
	}
	return *this;
}

#endif

void LobbyEtc::cli::HistoryBody::clear()
{
	loginTime.setNull();
	isp.clear();
	ipCountry.clear();
	ipAddress.clear();
}

bool LobbyEtc::cli::HistoryBody::equals(const HistoryBody& _o) const
{
	return loginTime.equals(_o.loginTime) &&
		Atf::atfPStringEquals(isp, _o.isp) &&
		Atf::atfPStringEquals(ipCountry, _o.ipCountry) &&
		Atf::atfPStringEquals(ipAddress, _o.ipAddress);
}

const char *LobbyEtc::cli::HistoryBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("loginTime=");
	Atf::AtfTempl<CommSrvTime>::ToTraceString(_buf, loginTime);
	_buf.append(',');
	_buf.append("isp=");
	_buf.append(isp);
	_buf.append(',');
	_buf.append("ipCountry=");
	_buf.append(ipCountry);
	_buf.append(',');
	_buf.append("ipAddress=");
	_buf.append(ipAddress);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::HistoryBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<CommSrvTime>::ToXmlString(_buf, "loginTime", loginTime);
	Atf::XmlElement::encodeAsXmlElement("isp", isp, _buf);
	Atf::XmlElement::encodeAsXmlElement("ipCountry", ipCountry, _buf);
	Atf::XmlElement::encodeAsXmlElement("ipAddress", ipAddress, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::HistoryBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("loginTime"))
		{
			Atf::AtfTempl<CommSrvTime>::FromXmlString(_value, loginTime);
		}
		else if (_element.equals("isp"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, isp)) return false;
		}
		else if (_element.equals("ipCountry"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ipCountry)) return false;
		}
		else if (_element.equals("ipAddress"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ipAddress)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::HistoryBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(loginTime);
	_msg.composeString(isp);
	_msg.composeString(ipCountry);
	_msg.composeString(ipAddress);
}

void LobbyEtc::cli::HistoryBody::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(loginTime);
	_parser.parseStringP(isp);
	_parser.parseStringP(ipCountry);
	_parser.parseStringP(ipAddress);
}

const char *LobbyEtc::cli::HistoryBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("loginTime", loginTime);
	_jsonstr.compose("isp", isp);
	_jsonstr.compose("ipCountry", ipCountry);
	_jsonstr.compose("ipAddress", ipAddress);
	return _buf.c_str();
}

void LobbyEtc::cli::HistoryBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("loginTime", loginTime);
	_jparser.parseByNameThrow("isp", isp);
	_jparser.parseByNameThrow("ipCountry", ipCountry);
	_jparser.parseByNameThrow("ipAddress", ipAddress);
}

/* static */ void LobbyEtc::cli::HistoryBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CommSrvTime loginTime; _jparser.validateByNameThrow("loginTime", loginTime);
	AtfValidator::validateSrvDateTime(_descr, "loginTime", loginTime, _checker, __FILE__, __LINE__);
	PString isp; _jparser.validateByNameThrow("isp", isp);
	AtfValidator::validateInt(_descr, "isp", isp.length(), _checker, __FILE__, __LINE__);
	PString ipCountry; _jparser.validateByNameThrow("ipCountry", ipCountry);
	AtfValidator::validateInt(_descr, "ipCountry", ipCountry.length(), _checker, __FILE__, __LINE__);
	PString ipAddress; _jparser.validateByNameThrow("ipAddress", ipAddress);
	AtfValidator::validateInt(_descr, "ipAddress", ipAddress.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::HistoryBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	CommSrvTime loginTime; _parser.parseSrvTime(loginTime);
	AtfValidator::validateSrvDateTime(_descr, "loginTime", loginTime, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "isp"); size_t szIsp = strlen(_dummy);
	AtfValidator::validateInt(_descr, "isp", szIsp, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ipCountry"); size_t szIpCountry = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ipCountry", szIpCountry, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "ipAddress"); size_t szIpAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ipAddress", szIpAddress, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY(Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::operator=(Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::clear()
{
	notUsedStr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::equals(const Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LOGIN_HISTORY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LOGIN_HISTORY).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LOGIN_HISTORY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LOGIN_HISTORY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LOGIN_HISTORY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY(Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, histories(std::move(_o.histories))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		histories = std::move(_o.histories);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	histories.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		histories.equals(_o.histories);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("histories=");
		histories.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		histories.toXmlString("histories", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("histories"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< HistoryBody, 4 > >::FromXmlString(_value, histories)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		histories.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		histories.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("histories", histories);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("histories", histories);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< HistoryBody > histories; _jparser.validateByNameThrow("histories", histories);
		AtfValidator::validateInt(_descr, "histories", histories.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szHistories = Atf::LAtfVector< HistoryBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("histories"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "histories", szHistories, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::equals(const Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_REALITY_CHECK_FREQ != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_REALITY_CHECK_FREQ).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_REALITY_CHECK_FREQ).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_REALITY_CHECK_FREQ";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_REALITY_CHECK_FREQ";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY(Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, found(std::move(_o.found))
	, propType(std::move(_o.propType))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		found = std::move(_o.found);
		propType = std::move(_o.propType);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	found = false;
	propType = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		found == _o.found &&
		propType == _o.propType;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("found=");
		_buf.appendUint(found);
		_buf.append(',');
		_buf.append("propType=");
		_buf.appendInt(propType);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("found", found, _buf);
		Atf::XmlElement::encodeAsXmlElement("propType", propType, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("found"))
			{
				found = (*_value.ptr() == '1');
			}
			else if (_element.equals("propType"))
			{
				propType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(found);
		_msg.composeINT32(propType);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(found);
		_parser.parseINT32(propType);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("found", found);
		_jsonstr.compose("propType", propType);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("found", found);
		_jparser.parseByNameThrow("propType", propType);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool found; _jparser.validateByNameThrow("found", found);
		AtfValidator::validateInt(_descr, "found", found, _checker, __FILE__, __LINE__);
		INT32 propType; _jparser.validateByNameThrow("propType", propType);
		AtfValidator::validateInt(_descr, "propType", propType, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool found; _parser.parseBOOL(found);
		AtfValidator::validateInt(_descr, "found", found, _checker, __FILE__, __LINE__);
		INT32 propType; _parser.parseINT32(propType);
		AtfValidator::validateInt(_descr, "propType", propType, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::clear()
{
	minutes = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::equals(const Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ& _o) const
{
	return minutes == _o.minutes;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_SET_REALITY_CHECK_FREQ != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_SET_REALITY_CHECK_FREQ).append(")");
	_buf.append(',');
	_buf.append("minutes=");
	_buf.appendInt(minutes);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_SET_REALITY_CHECK_FREQ).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("minutes", minutes, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("minutes"))
			{
				minutes = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(minutes);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(minutes);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("minutes", minutes);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("minutes", minutes);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SET_REALITY_CHECK_FREQ";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 minutes; _jparser.validateByNameThrow("minutes", minutes);
	AtfValidator::validateIntRange(_descr, "minutes", minutes, -1, 144000, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SET_REALITY_CHECK_FREQ";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 minutes; _parser.parseINT32(minutes);
	AtfValidator::validateIntRange(_descr, "minutes", minutes, -1, 144000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY(Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::operator=(Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::equals(const Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, password(std::move(_o.password))
	, includeFPP(std::move(_o.includeFPP))
	, reportFormat(std::move(_o.reportFormat))
	, isHtmlForClient(std::move(_o.isHtmlForClient))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT& LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::operator=(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		password = std::move(_o.password);
		includeFPP = std::move(_o.includeFPP);
		reportFormat = std::move(_o.reportFormat);
		isHtmlForClient = std::move(_o.isHtmlForClient);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::clear()
{
	notUsedStr.clear();
	startDate.setNull();
	endDate.setNull();
	password.clear();
	includeFPP = false;
	reportFormat = 0;
	isHtmlForClient = false;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::equals(const Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		Atf::atfPStringEquals(password, _o.password) &&
		includeFPP == _o.includeFPP &&
		reportFormat == _o.reportFormat &&
		isHtmlForClient == _o.isHtmlForClient;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PLAYING_HISTORY_AUDIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("startDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
	_buf.append(',');
	_buf.append("endDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	_buf.append(',');
	_buf.append("password=");
	_buf.append("...");
	_buf.append(',');
	_buf.append("includeFPP=");
	_buf.appendUint(includeFPP);
	_buf.append(',');
	_buf.append("reportFormat=");
	_buf.appendUint(reportFormat);
	_buf.append(',');
	_buf.append("isHtmlForClient=");
	_buf.appendUint(isHtmlForClient);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "startDate", startDate);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("includeFPP", includeFPP, _buf);
	Atf::XmlElement::encodeAsXmlElement("reportFormat", reportFormat, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHtmlForClient", isHtmlForClient, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("startDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, startDate);
			}
			else if (_element.equals("endDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("includeFPP"))
			{
				includeFPP = (*_value.ptr() == '1');
			}
			else if (_element.equals("reportFormat"))
			{
				reportFormat = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isHtmlForClient"))
			{
				isHtmlForClient = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeSrvDate(startDate);
	_msg.composeSrvDate(endDate);
	_msg.composeString(password);
	_msg.composeBOOL(includeFPP);
	_msg.composeUINT32(reportFormat);
	_msg.composeBOOL(isHtmlForClient);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseSrvDate(startDate);
	_parser.parseSrvDate(endDate);
	_parser.parseStringP(password);
	_parser.parseBOOL(includeFPP);
	_parser.parseUINT32(reportFormat);
	_parser.parseBOOL(isHtmlForClient);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("startDate", startDate);
	_jsonstr.compose("endDate", endDate);
	_jsonstr.compose("password", password);
	_jsonstr.compose("includeFPP", includeFPP);
	_jsonstr.compose("reportFormat", reportFormat);
	_jsonstr.compose("isHtmlForClient", isHtmlForClient);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("startDate", startDate);
	_jparser.parseByNameThrow("endDate", endDate);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("includeFPP", includeFPP);
	_jparser.parseByNameThrow("reportFormat", reportFormat);
	_jparser.parseByNameThrow("isHtmlForClient", isHtmlForClient);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _jparser.validateByNameThrow("startDate", startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
	bool includeFPP; _jparser.validateByNameThrow("includeFPP", includeFPP);
	AtfValidator::validateInt(_descr, "includeFPP", includeFPP, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _jparser.validateByNameThrow("reportFormat", reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _jparser.validateByNameThrow("isHtmlForClient", isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _parser.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	bool includeFPP; _parser.parseBOOL(includeFPP);
	AtfValidator::validateInt(_descr, "includeFPP", includeFPP, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _parser.parseUINT32(reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _parser.parseBOOL(isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::operator=(Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::equals(const Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION&& _o)
	: redirectorUrl(std::move(_o.redirectorUrl))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION& LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::operator=(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION&& _o)
{
	if(this != &_o)
	{
		redirectorUrl = std::move(_o.redirectorUrl);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::clear()
{
	redirectorUrl.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::equals(const Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION& _o) const
{
	return Atf::atfPStringEquals(redirectorUrl, _o.redirectorUrl);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_INIT_NETVERIFY_SESSION != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION).append(")");
	_buf.append(',');
	_buf.append("redirectorUrl=");
	_buf.append(redirectorUrl);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("redirectorUrl", redirectorUrl, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("redirectorUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, redirectorUrl)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(redirectorUrl);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(redirectorUrl);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("redirectorUrl", redirectorUrl);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("redirectorUrl", redirectorUrl);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString redirectorUrl; _jparser.validateByNameThrow("redirectorUrl", redirectorUrl);
	AtfValidator::validateIntMax(_descr, "redirectorUrl", redirectorUrl.length(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "redirectorUrl"); size_t szRedirectorUrl = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "redirectorUrl", szRedirectorUrl, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, url(std::move(_o.url))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::operator=(Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		url = std::move(_o.url);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	url.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::equals(const Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(url, _o.url);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("url=");
		_buf.append(url);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("url", url, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("url"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, url)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(url);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(url);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("url", url);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("url", url);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString url; _jparser.validateByNameThrow("url", url);
		AtfValidator::validateInt(_descr, "url", url.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "url"); size_t szUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "url", szUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::equals(const Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_ICE_GET_UPDATES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_ICE_GET_UPDATES).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_ICE_GET_UPDATES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_ICE_GET_UPDATES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_ICE_GET_UPDATES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY(Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, numChanges(std::move(_o.numChanges))
	, flags(std::move(_o.flags))
	, toolTip(std::move(_o.toolTip))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		numChanges = std::move(_o.numChanges);
		flags = std::move(_o.flags);
		toolTip = std::move(_o.toolTip);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	numChanges = 0;
	flags = 0;
	toolTip.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		numChanges == _o.numChanges &&
		flags == _o.flags &&
		Atf::atfPStringEquals(toolTip, _o.toolTip);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("numChanges=");
		_buf.appendInt(numChanges);
		_buf.append(',');
		_buf.append("flags=");
		_buf.appendUint(flags);
		_buf.append(',');
		_buf.append("toolTip=");
		_buf.append(toolTip);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("numChanges", numChanges, _buf);
		Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
		Atf::XmlElement::encodeAsXmlElement("toolTip", toolTip, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("numChanges"))
			{
				numChanges = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("toolTip"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, toolTip)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(numChanges);
		_msg.composeUINT32(flags);
		_msg.composeString(toolTip);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(numChanges);
		_parser.parseUINT32(flags);
		_parser.parseStringP(toolTip);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("numChanges", numChanges);
		_jsonstr.compose("flags", flags);
		_jsonstr.compose("toolTip", toolTip);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("numChanges", numChanges);
		_jparser.parseByNameThrow("flags", flags);
		_jparser.parseByNameThrow("toolTip", toolTip);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 numChanges; _jparser.validateByNameThrow("numChanges", numChanges);
		AtfValidator::validateInt(_descr, "numChanges", numChanges, _checker, __FILE__, __LINE__);
		UINT32 flags; _jparser.validateByNameThrow("flags", flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		PString toolTip; _jparser.validateByNameThrow("toolTip", toolTip);
		AtfValidator::validateInt(_descr, "toolTip", toolTip.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 numChanges; _parser.parseINT32(numChanges);
		AtfValidator::validateInt(_descr, "numChanges", numChanges, _checker, __FILE__, __LINE__);
		UINT32 flags; _parser.parseUINT32(flags);
		AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "toolTip"); size_t szToolTip = strlen(_dummy);
		AtfValidator::validateInt(_descr, "toolTip", szToolTip, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    SetLimitBody
//=================================================================

LobbyEtc::cli::SetLimitBody::SetLimitBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::SetLimitBody::SetLimitBody(SetLimitBody&& _o)
	: amount(std::move(_o.amount))
	, currency(std::move(_o.currency))
	, limType(std::move(_o.limType))
{
}

LobbyEtc::cli::SetLimitBody& LobbyEtc::cli::SetLimitBody::operator=(SetLimitBody&& _o)
{
	if(this != &_o)
	{
		amount = std::move(_o.amount);
		currency = std::move(_o.currency);
		limType = std::move(_o.limType);
	}
	return *this;
}

#endif

void LobbyEtc::cli::SetLimitBody::clear()
{
	amount = 0;
	currency.clear();
	limType = 0;
}

bool LobbyEtc::cli::SetLimitBody::equals(const SetLimitBody& _o) const
{
	return amount == _o.amount &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		limType == _o.limType;
}

const char *LobbyEtc::cli::SetLimitBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("amount=");
	_buf.appendInt64(amount);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("limType=");
	_buf.appendUint(limType);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::SetLimitBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("amount", amount, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("limType", limType, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::SetLimitBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("amount"))
		{
			amount = (INT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("limType"))
		{
			limType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::SetLimitBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SetLimitBody())) // not empty
	{
		_body.composeINT64(amount);
		_body.composeString(currency);
		_body.composeBYTE(limType);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::SetLimitBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(amount);
	_parser0.parseStringP(currency);
	_parser0.parseBYTE(limType);
}

const char *LobbyEtc::cli::SetLimitBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("amount", amount);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("limType", limType);
	return _buf.c_str();
}

void LobbyEtc::cli::SetLimitBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("amount", amount);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("limType", limType);
}

/* static */ void LobbyEtc::cli::SetLimitBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT64 amount; _jparser.validateByNameThrow("amount", amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 5, _checker, __FILE__, __LINE__);
	BYTE limType; _jparser.validateByNameThrow("limType", limType);
	AtfValidator::validateIntRange(_descr, "limType", limType, eTableLimitTypeAny, numLimitTypes, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::SetLimitBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	INT64 amount; _parser0.parseINT64(amount);
	AtfValidator::validateIntRange(_descr, "amount", amount, -1, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	BYTE limType; _parser0.parseBYTE(limType);
	AtfValidator::validateIntRange(_descr, "limType", limType, eTableLimitTypeAny, numLimitTypes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    SetLimitReplyBody
//=================================================================

LobbyEtc::cli::SetLimitReplyBody::SetLimitReplyBody()
{
	clear();
}

void LobbyEtc::cli::SetLimitReplyBody::clear()
{
	limType = 0;
	errCode = 0;
}

bool LobbyEtc::cli::SetLimitReplyBody::equals(const SetLimitReplyBody& _o) const
{
	return limType == _o.limType &&
		errCode == _o.errCode;
}

const char *LobbyEtc::cli::SetLimitReplyBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("limType=");
	_buf.appendUint(limType);
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::SetLimitReplyBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("limType", limType, _buf);
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::SetLimitReplyBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("limType"))
		{
			limType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("errCode"))
		{
			errCode = (INT16)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::SetLimitReplyBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(SetLimitReplyBody())) // not empty
	{
		_body.composeBYTE(limType);
		_body.composeINT16(errCode);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::SetLimitReplyBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(limType);
	_parser0.parseINT16(errCode);
}

const char *LobbyEtc::cli::SetLimitReplyBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limType", limType);
	_jsonstr.compose("errCode", errCode);
	return _buf.c_str();
}

void LobbyEtc::cli::SetLimitReplyBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limType", limType);
	_jparser.parseByNameThrow("errCode", errCode);
}

/* static */ void LobbyEtc::cli::SetLimitReplyBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE limType; _jparser.validateByNameThrow("limType", limType);
	AtfValidator::validateInt(_descr, "limType", limType, _checker, __FILE__, __LINE__);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::SetLimitReplyBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE limType; _parser0.parseBYTE(limType);
	AtfValidator::validateInt(_descr, "limType", limType, _checker, __FILE__, __LINE__);
	INT16 errCode; _parser0.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2(Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2&& _o)
	: limits(std::move(_o.limits))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2& LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::operator=(Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2&& _o)
{
	if(this != &_o)
	{
		limits = std::move(_o.limits);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::clear()
{
	limits.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::equals(const Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2& _o) const
{
	return limits.equals(_o.limits);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_SET_GAME_LIMITS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_SET_GAME_LIMITS2).append(")");
	_buf.append(',');
	_buf.append("limits=");
	limits.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_SET_GAME_LIMITS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	limits.toXmlString("limits", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("limits"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SetLimitBody, 4 > >::FromXmlString(_value, limits)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	limits.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::parseMsg(CommMsgParser& _parser)
{
	limits.parseMsg(_parser);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("limits", limits);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("limits", limits);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SET_GAME_LIMITS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< SetLimitBody > limits; _jparser.validateByNameThrow("limits", limits);
	AtfValidator::validateIntMax(_descr, "limits", limits.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SET_GAME_LIMITS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szLimits = Atf::LAtfVector< SetLimitBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("limits"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "limits", szLimits, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY(Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, setReplies(std::move(_o.setReplies))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::operator=(Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		setReplies = std::move(_o.setReplies);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	setReplies.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::equals(const Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		setReplies.equals(_o.setReplies);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("setReplies=");
		setReplies.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		setReplies.toXmlString("setReplies", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("setReplies"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< SetLimitReplyBody, 4 > >::FromXmlString(_value, setReplies)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		setReplies.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		setReplies.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("setReplies", setReplies);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("setReplies", setReplies);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< SetLimitReplyBody > setReplies; _jparser.validateByNameThrow("setReplies", setReplies);
		AtfValidator::validateInt(_descr, "setReplies", setReplies.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSetReplies = Atf::LAtfVector< SetLimitReplyBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("setReplies"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "setReplies", szSetReplies, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::equals(const Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_LOGOUT_USER_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_LOGOUT_USER_INFO).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_LOGOUT_USER_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_LOGOUT_USER_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_LOGOUT_USER_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    EmptyBody
//=================================================================

LobbyEtc::cli::EmptyBody::EmptyBody()
{
	clear();
}

void LobbyEtc::cli::EmptyBody::clear()
{
}

bool LobbyEtc::cli::EmptyBody::equals(const EmptyBody& _o) const
{
	return true;
}

const char *LobbyEtc::cli::EmptyBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::EmptyBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::EmptyBody::fromXmlString(const PString& _str)
{	return true;
}

void LobbyEtc::cli::EmptyBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(EmptyBody())) // not empty
	{
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::EmptyBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
}

const char *LobbyEtc::cli::EmptyBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::EmptyBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/* static */ void LobbyEtc::cli::EmptyBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::EmptyBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	size_t _sz; _parser.skipMsgBody(_sz);
	if(_sz > 0) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _sz);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY(Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, emptyBody(std::move(_o.emptyBody))
	, numOfRequests(std::move(_o.numOfRequests))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::operator=(Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		emptyBody = std::move(_o.emptyBody);
		numOfRequests = std::move(_o.numOfRequests);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	emptyBody.clear();
	numOfRequests = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::equals(const Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		emptyBody.equals(_o.emptyBody) &&
		numOfRequests == _o.numOfRequests;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("emptyBody=");
		emptyBody.toTraceString(_buf);
		_buf.append(',');
		_buf.append("numOfRequests=");
		_buf.appendInt(numOfRequests);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		emptyBody.toXmlString("emptyBody", _buf);
		Atf::XmlElement::encodeAsXmlElement("numOfRequests", numOfRequests, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("emptyBody"))
			{
				if(!Atf::AtfTempl< EmptyBody >::FromXmlString(_value, emptyBody)) return false;
			}
			else if (_element.equals("numOfRequests"))
			{
				numOfRequests = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		emptyBody.composeMsg(_msg, _ignoreJSON);
		_msg.composeINT32(numOfRequests);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		emptyBody.parseMsg(_parser);
		_parser.parseINT32(numOfRequests);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("emptyBody", emptyBody);
		_jsonstr.compose("numOfRequests", numOfRequests);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("emptyBody", emptyBody);
		_jparser.parseByNameThrow("numOfRequests", numOfRequests);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		EmptyBody emptyBody; _jparser.validateByNameThrow("emptyBody", emptyBody);
		INT32 numOfRequests; _jparser.validateByNameThrow("numOfRequests", numOfRequests);
		AtfValidator::validateInt(_descr, "numOfRequests", numOfRequests, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		EmptyBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("emptyBody"), _fieldsWithUnparsedContent);
		INT32 numOfRequests; _parser.parseINT32(numOfRequests);
		AtfValidator::validateInt(_descr, "numOfRequests", numOfRequests, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_FIND_TOURN_IT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::Protocol_MSG_LOBBYETC_FIND_TOURN_IT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::Protocol_MSG_LOBBYETC_FIND_TOURN_IT(Protocol_MSG_LOBBYETC_FIND_TOURN_IT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT& LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::operator=(Protocol_MSG_LOBBYETC_FIND_TOURN_IT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::clear()
{
	notUsedStr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::equals(const Protocol_MSG_LOBBYETC_FIND_TOURN_IT& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_FIND_TOURN_IT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_FIND_TOURN_IT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_FIND_TOURN_IT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_FIND_TOURN_IT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_FIND_TOURN_IT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_FIND_TOURN_IT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ReacquisitionBody
//=================================================================

LobbyEtc::cli::ReacquisitionBody::ReacquisitionBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::ReacquisitionBody::ReacquisitionBody(ReacquisitionBody&& _o)
	: aamsTicketId(std::move(_o.aamsTicketId))
	, when(std::move(_o.when))
	, reacquisition(std::move(_o.reacquisition))
	, cost(std::move(_o.cost))
{
}

LobbyEtc::cli::ReacquisitionBody& LobbyEtc::cli::ReacquisitionBody::operator=(ReacquisitionBody&& _o)
{
	if(this != &_o)
	{
		aamsTicketId = std::move(_o.aamsTicketId);
		when = std::move(_o.when);
		reacquisition = std::move(_o.reacquisition);
		cost = std::move(_o.cost);
	}
	return *this;
}

#endif

void LobbyEtc::cli::ReacquisitionBody::clear()
{
	aamsTicketId.clear();
	when.setNull();
	reacquisition = 0;
	cost = 0;
}

bool LobbyEtc::cli::ReacquisitionBody::equals(const ReacquisitionBody& _o) const
{
	return Atf::atfPStringEquals(aamsTicketId, _o.aamsTicketId) &&
		when.equals(_o.when) &&
		reacquisition == _o.reacquisition &&
		cost == _o.cost;
}

const char *LobbyEtc::cli::ReacquisitionBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("aamsTicketId=");
	_buf.append(aamsTicketId);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("reacquisition=");
	_buf.appendUint(reacquisition);
	_buf.append(',');
	_buf.append("cost=");
	_buf.appendUint(cost);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::ReacquisitionBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("aamsTicketId", aamsTicketId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("reacquisition", reacquisition, _buf);
	Atf::XmlElement::encodeAsXmlElement("cost", cost, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::ReacquisitionBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("aamsTicketId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, aamsTicketId)) return false;
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("reacquisition"))
		{
			reacquisition = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cost"))
		{
			cost = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::ReacquisitionBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ReacquisitionBody())) // not empty
	{
		_body.composeString(aamsTicketId);
		_body.composeSrvTime(when);
		_body.composeUINT32(reacquisition);
		_body.composeUINT32(cost);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::ReacquisitionBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(aamsTicketId);
	_parser0.parseSrvTime(when);
	_parser0.parseUINT32(reacquisition);
	_parser0.parseUINT32(cost);
}

const char *LobbyEtc::cli::ReacquisitionBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("aamsTicketId", aamsTicketId);
	_jsonstr.compose("when", when);
	_jsonstr.compose("reacquisition", reacquisition);
	_jsonstr.compose("cost", cost);
	return _buf.c_str();
}

void LobbyEtc::cli::ReacquisitionBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("aamsTicketId", aamsTicketId);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("reacquisition", reacquisition);
	_jparser.parseByNameThrow("cost", cost);
}

/* static */ void LobbyEtc::cli::ReacquisitionBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString aamsTicketId; _jparser.validateByNameThrow("aamsTicketId", aamsTicketId);
	AtfValidator::validateInt(_descr, "aamsTicketId", aamsTicketId.length(), _checker, __FILE__, __LINE__);
	SrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisition; _jparser.validateByNameThrow("reacquisition", reacquisition);
	AtfValidator::validateInt(_descr, "reacquisition", reacquisition, _checker, __FILE__, __LINE__);
	UINT32 cost; _jparser.validateByNameThrow("cost", cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::ReacquisitionBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "aamsTicketId"); size_t szAamsTicketId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "aamsTicketId", szAamsTicketId, _checker, __FILE__, __LINE__);
	SrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisition; _parser0.parseUINT32(reacquisition);
	AtfValidator::validateInt(_descr, "reacquisition", reacquisition, _checker, __FILE__, __LINE__);
	UINT32 cost; _parser0.parseUINT32(cost);
	AtfValidator::validateInt(_descr, "cost", cost, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ItTournBody
//=================================================================

LobbyEtc::cli::ItTournBody::ItTournBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::ItTournBody::ItTournBody(ItTournBody&& _o)
	: reacquisitions(std::move(_o.reacquisitions))
{
}

LobbyEtc::cli::ItTournBody& LobbyEtc::cli::ItTournBody::operator=(ItTournBody&& _o)
{
	if(this != &_o)
	{
		reacquisitions = std::move(_o.reacquisitions);
	}
	return *this;
}

#endif

void LobbyEtc::cli::ItTournBody::clear()
{
	reacquisitions.clear();
}

bool LobbyEtc::cli::ItTournBody::equals(const ItTournBody& _o) const
{
	return reacquisitions.equals(_o.reacquisitions);
}

const char *LobbyEtc::cli::ItTournBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("reacquisitions=");
	reacquisitions.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::ItTournBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	reacquisitions.toXmlString("reacquisitions", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::ItTournBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("reacquisitions"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< ReacquisitionBody, 4 > >::FromXmlString(_value, reacquisitions)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::ItTournBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ItTournBody())) // not empty
	{
		reacquisitions.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::ItTournBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	reacquisitions.parseMsg(_parser0);
}

const char *LobbyEtc::cli::ItTournBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reacquisitions", reacquisitions);
	return _buf.c_str();
}

void LobbyEtc::cli::ItTournBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reacquisitions", reacquisitions);
}

/* static */ void LobbyEtc::cli::ItTournBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< ReacquisitionBody > reacquisitions; _jparser.validateByNameThrow("reacquisitions", reacquisitions);
	AtfValidator::validateInt(_descr, "reacquisitions", reacquisitions.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::ItTournBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szReacquisitions = Atf::LAtfVector< ReacquisitionBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("reacquisitions"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "reacquisitions", szReacquisitions, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ItTournData
//=================================================================

LobbyEtc::cli::ItTournData::ItTournData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::ItTournData::ItTournData(ItTournData&& _o)
	: tournId(std::move(_o.tournId))
	, infoBody(std::move(_o.infoBody))
{
}

LobbyEtc::cli::ItTournData& LobbyEtc::cli::ItTournData::operator=(ItTournData&& _o)
{
	if(this != &_o)
	{
		tournId = std::move(_o.tournId);
		infoBody = std::move(_o.infoBody);
	}
	return *this;
}

#endif

void LobbyEtc::cli::ItTournData::clear()
{
	tournId = 0;
	infoBody.clear();
}

bool LobbyEtc::cli::ItTournData::equals(const ItTournData& _o) const
{
	return tournId == _o.tournId &&
		infoBody.equals(_o.infoBody);
}

const char *LobbyEtc::cli::ItTournData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("infoBody=");
	infoBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::ItTournData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	infoBody.toXmlString("infoBody", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::ItTournData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("infoBody"))
		{
			if(!Atf::AtfTempl< ItTournBody >::FromXmlString(_value, infoBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::ItTournData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
	infoBody.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::ItTournData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
	infoBody.parseMsg(_parser);
}

const char *LobbyEtc::cli::ItTournData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("infoBody", infoBody);
	return _buf.c_str();
}

void LobbyEtc::cli::ItTournData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("infoBody", infoBody);
}

/* static */ void LobbyEtc::cli::ItTournData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	ItTournBody infoBody; _jparser.validateByNameThrow("infoBody", infoBody);
}

/*static*/ void LobbyEtc::cli::ItTournData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ItTournBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("infoBody"), _fieldsWithUnparsedContent);
}

//=================================================================
//                    AddOnBody
//=================================================================

LobbyEtc::cli::AddOnBody::AddOnBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::AddOnBody::AddOnBody(AddOnBody&& _o)
	: ticketId(std::move(_o.ticketId))
	, when(std::move(_o.when))
	, reacquisitionType(std::move(_o.reacquisitionType))
	, addOn(std::move(_o.addOn))
{
}

LobbyEtc::cli::AddOnBody& LobbyEtc::cli::AddOnBody::operator=(AddOnBody&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		when = std::move(_o.when);
		reacquisitionType = std::move(_o.reacquisitionType);
		addOn = std::move(_o.addOn);
	}
	return *this;
}

#endif

void LobbyEtc::cli::AddOnBody::clear()
{
	ticketId.clear();
	when.setNull();
	reacquisitionType = 0;
	addOn = 0;
}

bool LobbyEtc::cli::AddOnBody::equals(const AddOnBody& _o) const
{
	return Atf::atfPStringEquals(ticketId, _o.ticketId) &&
		when.equals(_o.when) &&
		reacquisitionType == _o.reacquisitionType &&
		addOn == _o.addOn;
}

const char *LobbyEtc::cli::AddOnBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.append(ticketId);
	_buf.append(',');
	_buf.append("when=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, when);
	_buf.append(',');
	_buf.append("reacquisitionType=");
	_buf.appendUint(reacquisitionType);
	_buf.append(',');
	_buf.append("addOn=");
	_buf.appendUint(addOn);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::AddOnBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "when", when);
	Atf::XmlElement::encodeAsXmlElement("reacquisitionType", reacquisitionType, _buf);
	Atf::XmlElement::encodeAsXmlElement("addOn", addOn, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::AddOnBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, ticketId)) return false;
		}
		else if (_element.equals("when"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, when);
		}
		else if (_element.equals("reacquisitionType"))
		{
			reacquisitionType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("addOn"))
		{
			addOn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::AddOnBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(AddOnBody())) // not empty
	{
		_body.composeString(ticketId);
		_body.composeSrvTime(when);
		_body.composeUINT32(reacquisitionType);
		_body.composeUINT32(addOn);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::AddOnBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(ticketId);
	_parser0.parseSrvTime(when);
	_parser0.parseUINT32(reacquisitionType);
	_parser0.parseUINT32(addOn);
}

const char *LobbyEtc::cli::AddOnBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("when", when);
	_jsonstr.compose("reacquisitionType", reacquisitionType);
	_jsonstr.compose("addOn", addOn);
	return _buf.c_str();
}

void LobbyEtc::cli::AddOnBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("when", when);
	_jparser.parseByNameThrow("reacquisitionType", reacquisitionType);
	_jparser.parseByNameThrow("addOn", addOn);
}

/* static */ void LobbyEtc::cli::AddOnBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId.length(), _checker, __FILE__, __LINE__);
	SrvTime when; _jparser.validateByNameThrow("when", when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisitionType; _jparser.validateByNameThrow("reacquisitionType", reacquisitionType);
	AtfValidator::validateInt(_descr, "reacquisitionType", reacquisitionType, _checker, __FILE__, __LINE__);
	UINT32 addOn; _jparser.validateByNameThrow("addOn", addOn);
	AtfValidator::validateInt(_descr, "addOn", addOn, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::AddOnBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "ticketId"); size_t szTicketId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "ticketId", szTicketId, _checker, __FILE__, __LINE__);
	SrvTime when; _parser0.parseSrvTime(when);
	AtfValidator::validateSrvDateTime(_descr, "when", when, _checker, __FILE__, __LINE__);
	UINT32 reacquisitionType; _parser0.parseUINT32(reacquisitionType);
	AtfValidator::validateInt(_descr, "reacquisitionType", reacquisitionType, _checker, __FILE__, __LINE__);
	UINT32 addOn; _parser0.parseUINT32(addOn);
	AtfValidator::validateInt(_descr, "addOn", addOn, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ItRingGameBody
//=================================================================

LobbyEtc::cli::ItRingGameBody::ItRingGameBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::ItRingGameBody::ItRingGameBody(ItRingGameBody&& _o)
	: addOns(std::move(_o.addOns))
{
}

LobbyEtc::cli::ItRingGameBody& LobbyEtc::cli::ItRingGameBody::operator=(ItRingGameBody&& _o)
{
	if(this != &_o)
	{
		addOns = std::move(_o.addOns);
	}
	return *this;
}

#endif

void LobbyEtc::cli::ItRingGameBody::clear()
{
	addOns.clear();
}

bool LobbyEtc::cli::ItRingGameBody::equals(const ItRingGameBody& _o) const
{
	return addOns.equals(_o.addOns);
}

const char *LobbyEtc::cli::ItRingGameBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("addOns=");
	addOns.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::ItRingGameBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	addOns.toXmlString("addOns", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::ItRingGameBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("addOns"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< AddOnBody, 4 > >::FromXmlString(_value, addOns)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::ItRingGameBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ItRingGameBody())) // not empty
	{
		addOns.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::ItRingGameBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	addOns.parseMsg(_parser0);
}

const char *LobbyEtc::cli::ItRingGameBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("addOns", addOns);
	return _buf.c_str();
}

void LobbyEtc::cli::ItRingGameBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("addOns", addOns);
}

/* static */ void LobbyEtc::cli::ItRingGameBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< AddOnBody > addOns; _jparser.validateByNameThrow("addOns", addOns);
	AtfValidator::validateInt(_descr, "addOns", addOns.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::ItRingGameBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	int szAddOns = Atf::LAtfVector< AddOnBody, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("addOns"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "addOns", szAddOns, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ItRingGameData
//=================================================================

LobbyEtc::cli::ItRingGameData::ItRingGameData()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::ItRingGameData::ItRingGameData(ItRingGameData&& _o)
	: tableId(std::move(_o.tableId))
	, infoBody(std::move(_o.infoBody))
{
}

LobbyEtc::cli::ItRingGameData& LobbyEtc::cli::ItRingGameData::operator=(ItRingGameData&& _o)
{
	if(this != &_o)
	{
		tableId = std::move(_o.tableId);
		infoBody = std::move(_o.infoBody);
	}
	return *this;
}

#endif

void LobbyEtc::cli::ItRingGameData::clear()
{
	tableId = 0;
	infoBody.clear();
}

bool LobbyEtc::cli::ItRingGameData::equals(const ItRingGameData& _o) const
{
	return tableId == _o.tableId &&
		infoBody.equals(_o.infoBody);
}

const char *LobbyEtc::cli::ItRingGameData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableId=");
	_buf.appendUint(tableId);
	_buf.append(',');
	_buf.append("infoBody=");
	infoBody.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::ItRingGameData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	infoBody.toXmlString("infoBody", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::ItRingGameData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableId"))
		{
			tableId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("infoBody"))
		{
			if(!Atf::AtfTempl< ItRingGameBody >::FromXmlString(_value, infoBody)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::ItRingGameData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableId);
	infoBody.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::ItRingGameData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId);
	infoBody.parseMsg(_parser);
}

const char *LobbyEtc::cli::ItRingGameData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("infoBody", infoBody);
	return _buf.c_str();
}

void LobbyEtc::cli::ItRingGameData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("infoBody", infoBody);
}

/* static */ void LobbyEtc::cli::ItRingGameData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	ItRingGameBody infoBody; _jparser.validateByNameThrow("infoBody", infoBody);
}

/*static*/ void LobbyEtc::cli::ItRingGameData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 tableId; _parser.parseUINT32(tableId);
	AtfValidator::validateInt(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	ItRingGameBody::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("infoBody"), _fieldsWithUnparsedContent);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY(Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, tourns(std::move(_o.tourns))
	, ringGames(std::move(_o.ringGames))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::operator=(Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		tourns = std::move(_o.tourns);
		ringGames = std::move(_o.ringGames);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	tourns.clear();
	ringGames.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::equals(const Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		tourns.equals(_o.tourns) &&
		ringGames.equals(_o.ringGames);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_FIND_TOURN_IT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_FIND_TOURN_IT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ringGames=");
		ringGames.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_FIND_TOURN_IT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		tourns.toXmlString("tourns", _buf);
		ringGames.toXmlString("ringGames", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ItTournData, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("ringGames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ItRingGameData, 4 > >::FromXmlString(_value, ringGames)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		tourns.composeMsg(_msg, _ignoreJSON);
		ringGames.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		tourns.parseMsg(_parser);
		ringGames.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("tourns", tourns);
		_jsonstr.compose("ringGames", ringGames);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("tourns", tourns);
		_jparser.parseByNameThrow("ringGames", ringGames);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_FIND_TOURN_IT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ItTournData > tourns; _jparser.validateByNameThrow("tourns", tourns);
		AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ItRingGameData > ringGames; _jparser.validateByNameThrow("ringGames", ringGames);
		AtfValidator::validateInt(_descr, "ringGames", ringGames.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_FIND_TOURN_IT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTourns = Atf::LAtfVector< ItTournData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szRingGames = Atf::LAtfVector< ItRingGameData, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ringGames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ringGames", szRingGames, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST(Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST&& _o)
	: notUsed(std::move(_o.notUsed))
	, type(std::move(_o.type))
	, param(std::move(_o.param))
	, numRequested(std::move(_o.numRequested))
	, handId64(std::move(_o.handId64))
	, locale(std::move(_o.locale))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::operator=(Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST&& _o)
{
	if(this != &_o)
	{
		notUsed = std::move(_o.notUsed);
		type = std::move(_o.type);
		param = std::move(_o.param);
		numRequested = std::move(_o.numRequested);
		handId64 = std::move(_o.handId64);
		locale = std::move(_o.locale);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::clear()
{
	notUsed.clear();
	type = 0;
	param = 0;
	numRequested = 0;
	handId64 = 0;
	locale = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::equals(const Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST& _o) const
{
	return Atf::atfPStringEquals(notUsed, _o.notUsed) &&
		type == _o.type &&
		param == _o.param &&
		numRequested == _o.numRequested &&
		handId64 == _o.handId64 &&
		locale == _o.locale;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLIENT_HISTORY_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLIENT_HISTORY_REQUEST).append(")");
	_buf.append(',');
	_buf.append("notUsed=");
	_buf.append(notUsed);
	_buf.append(',');
	_buf.append("type=");
	_buf.appendInt(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_buf.append(',');
		_buf.append("param=");
		_buf.appendUint64(param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_buf.append(',');
		_buf.append("param=");
		_buf.appendUint64(param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_buf.append(',');
		_buf.append("param=");
		_buf.appendUint64(param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
		_buf.append(',');
		_buf.append("handId64=");
		_buf.appendUint64(handId64);
	}
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLIENT_HISTORY_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsed", notUsed, _buf);
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		Atf::XmlElement::encodeAsXmlElement("param", param, _buf);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		Atf::XmlElement::encodeAsXmlElement("param", param, _buf);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		Atf::XmlElement::encodeAsXmlElement("param", param, _buf);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		Atf::XmlElement::encodeAsXmlElement("numRequested", numRequested, _buf);
		Atf::XmlElement::encodeAsXmlElement("handId64", handId64, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsed"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsed)) return false;
			}
			else if (_element.equals("type"))
			{
				type = (INT8)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("param"))
			{
				param = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numRequested"))
			{
				numRequested = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("handId64"))
			{
				handId64 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("locale"))
			{
				locale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsed);
	_msg.composeINT8(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_msg.composeUINT64(param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_msg.composeUINT64(param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_msg.composeUINT64(param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_msg.composeUINT32(numRequested);
		_msg.composeUINT64(handId64);
	}
	_msg.composeUINT32(locale);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsed);
	_parser.parseINT8(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_parser.parseUINT64(param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_parser.parseUINT64(param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_parser.parseUINT64(param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_parser.parseUINT32(numRequested);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(handId64);
	}
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsed", notUsed);
	_jsonstr.compose("type", type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_jsonstr.compose("param", param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_jsonstr.compose("param", param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_jsonstr.compose("param", param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_jsonstr.compose("numRequested", numRequested);
		_jsonstr.compose("handId64", handId64);
	}
	_jsonstr.compose("locale", locale);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsed", notUsed);
	_jparser.parseByNameThrow("type", type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_jparser.parseByNameThrow("param", param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_jparser.parseByNameThrow("param", param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_jparser.parseByNameThrow("param", param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_jparser.parseByNameThrow("numRequested", numRequested);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("handId64", handId64);
	}
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("locale", locale);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_HISTORY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 type = 0;
	PString notUsed; _jparser.validateByNameThrow("notUsed", notUsed);
	AtfValidator::validateIntMax(_descr, "notUsed", notUsed.length(), 20, _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("type", type);
	AtfValidator::validateIntRange(_descr, "type", type, HAND_HISTORY_LAST_HANDS, HAND_HISTORY_TOURNAMENT, _checker, __FILE__, __LINE__);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		UINT64 param; _jparser.validateByNameThrow("param", param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, MAX_HANDS_ALLOWED, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		UINT64 param; _jparser.validateByNameThrow("param", param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, 604800, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		UINT64 param; _jparser.validateByNameThrow("param", param);
		AtfValidator::validateUint(_descr, "param", param, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		UINT32 numRequested; _jparser.validateByNameThrow("numRequested", numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 1, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT64 handId64; _jparser.validateByNameThrow("handId64", handId64);
		AtfValidator::validateUint(_descr, "handId64", handId64, _checker, __FILE__, __LINE__);
	}
	if(_jparser.parseEnded()) return;
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntRange(_descr, "locale", locale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_HISTORY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT8 type = 0;
	_parser.parseStringN(_dummy, 0, "notUsed"); size_t szNotUsed = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsed", szNotUsed, 20, _checker, __FILE__, __LINE__);
	_parser.parseINT8(type);
	AtfValidator::validateIntRange(_descr, "type", type, HAND_HISTORY_LAST_HANDS, HAND_HISTORY_TOURNAMENT, _checker, __FILE__, __LINE__);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		UINT64 param; _parser.parseUINT64(param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, MAX_HANDS_ALLOWED, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		UINT64 param; _parser.parseUINT64(param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, 604800, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		UINT64 param; _parser.parseUINT64(param);
		AtfValidator::validateUint(_descr, "param", param, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 1, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 handId64; _parser.parseUINT64(handId64);
		AtfValidator::validateUint(_descr, "handId64", handId64, _checker, __FILE__, __LINE__);
	}
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntRange(_descr, "locale", locale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY(Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::operator=(Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::equals(const Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(email, _o.email);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("email", email);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("email", email);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2(Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2& LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::operator=(Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::clear()
{
	notUsedStr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::equals(const Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_USER_TOURNTICKETS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_USER_TOURNTICKETS2).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_USER_TOURNTICKETS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_USER_TOURNTICKETS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_USER_TOURNTICKETS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TicketBody
//=================================================================

LobbyEtc::cli::TicketBody::TicketBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::TicketBody::TicketBody(TicketBody&& _o)
	: ticketId(std::move(_o.ticketId))
	, admissionCode(std::move(_o.admissionCode))
	, isMulti(std::move(_o.isMulti))
	, ticketTypeValue(std::move(_o.ticketTypeValue))
	, issued(std::move(_o.issued))
	, expTime(std::move(_o.expTime))
	, currency(std::move(_o.currency))
	, ticketTypeFlags(std::move(_o.ticketTypeFlags))
{
}

LobbyEtc::cli::TicketBody& LobbyEtc::cli::TicketBody::operator=(TicketBody&& _o)
{
	if(this != &_o)
	{
		ticketId = std::move(_o.ticketId);
		admissionCode = std::move(_o.admissionCode);
		isMulti = std::move(_o.isMulti);
		ticketTypeValue = std::move(_o.ticketTypeValue);
		issued = std::move(_o.issued);
		expTime = std::move(_o.expTime);
		currency = std::move(_o.currency);
		ticketTypeFlags = std::move(_o.ticketTypeFlags);
	}
	return *this;
}

#endif

void LobbyEtc::cli::TicketBody::clear()
{
	ticketId = 0;
	admissionCode.clear();
	isMulti = false;
	ticketTypeValue = 0;
	issued.setNull();
	expTime.setNull();
	currency.clear();
	ticketTypeFlags = 0;
}

bool LobbyEtc::cli::TicketBody::equals(const TicketBody& _o) const
{
	return ticketId == _o.ticketId &&
		Atf::atfPStringEquals(admissionCode, _o.admissionCode) &&
		isMulti == _o.isMulti &&
		ticketTypeValue == _o.ticketTypeValue &&
		issued.equals(_o.issued) &&
		expTime.equals(_o.expTime) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		ticketTypeFlags == _o.ticketTypeFlags;
}

const char *LobbyEtc::cli::TicketBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("ticketId=");
	_buf.appendUint(ticketId);
	_buf.append(',');
	_buf.append("admissionCode=");
	_buf.append(admissionCode);
	_buf.append(',');
	_buf.append("isMulti=");
	_buf.appendUint(isMulti);
	_buf.append(',');
	_buf.append("ticketTypeValue=");
	_buf.appendUint(ticketTypeValue);
	_buf.append(',');
	_buf.append("issued=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, issued);
	_buf.append(',');
	_buf.append("expTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, expTime);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("ticketTypeFlags=");
	_buf.appendUint(ticketTypeFlags);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::TicketBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("ticketId", ticketId, _buf);
	Atf::XmlElement::encodeAsXmlElement("admissionCode", admissionCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("isMulti", isMulti, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketTypeValue", ticketTypeValue, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "issued", issued);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "expTime", expTime);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("ticketTypeFlags", ticketTypeFlags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::TicketBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("ticketId"))
		{
			ticketId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("admissionCode"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, admissionCode)) return false;
		}
		else if (_element.equals("isMulti"))
		{
			isMulti = (*_value.ptr() == '1');
		}
		else if (_element.equals("ticketTypeValue"))
		{
			ticketTypeValue = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("issued"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, issued);
		}
		else if (_element.equals("expTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, expTime);
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("ticketTypeFlags"))
		{
			ticketTypeFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::TicketBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TicketBody())) // not empty
	{
		_body.composeUINT32(ticketId);
		_body.composeString(admissionCode);
		_body.composeBOOL(isMulti);
		_body.composeUINT32(ticketTypeValue);
		_body.composeSrvTime(issued);
		_body.composeSrvTime(expTime);
		_body.composeString(currency);
		_body.composeUINT32(ticketTypeFlags);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::TicketBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(ticketId);
	_parser0.parseStringP(admissionCode);
	_parser0.parseBOOL(isMulti);
	_parser0.parseUINT32(ticketTypeValue);
	_parser0.parseSrvTime(issued);
	_parser0.parseSrvTime(expTime);
	_parser0.parseStringP(currency);
	_parser0.parseUINT32(ticketTypeFlags);
}

const char *LobbyEtc::cli::TicketBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("ticketId", ticketId);
	_jsonstr.compose("admissionCode", admissionCode);
	_jsonstr.compose("isMulti", isMulti);
	_jsonstr.compose("ticketTypeValue", ticketTypeValue);
	_jsonstr.compose("issued", issued);
	_jsonstr.compose("expTime", expTime);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("ticketTypeFlags", ticketTypeFlags);
	return _buf.c_str();
}

void LobbyEtc::cli::TicketBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("ticketId", ticketId);
	_jparser.parseByNameThrow("admissionCode", admissionCode);
	_jparser.parseByNameThrow("isMulti", isMulti);
	_jparser.parseByNameThrow("ticketTypeValue", ticketTypeValue);
	_jparser.parseByNameThrow("issued", issued);
	_jparser.parseByNameThrow("expTime", expTime);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("ticketTypeFlags", ticketTypeFlags);
}

/* static */ void LobbyEtc::cli::TicketBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 ticketId; _jparser.validateByNameThrow("ticketId", ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	PString admissionCode; _jparser.validateByNameThrow("admissionCode", admissionCode);
	AtfValidator::validateInt(_descr, "admissionCode", admissionCode.length(), _checker, __FILE__, __LINE__);
	bool isMulti; _jparser.validateByNameThrow("isMulti", isMulti);
	AtfValidator::validateInt(_descr, "isMulti", isMulti, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeValue; _jparser.validateByNameThrow("ticketTypeValue", ticketTypeValue);
	AtfValidator::validateInt(_descr, "ticketTypeValue", ticketTypeValue, _checker, __FILE__, __LINE__);
	SrvTime issued; _jparser.validateByNameThrow("issued", issued);
	AtfValidator::validateSrvDateTime(_descr, "issued", issued, _checker, __FILE__, __LINE__);
	SrvTime expTime; _jparser.validateByNameThrow("expTime", expTime);
	AtfValidator::validateSrvDateTime(_descr, "expTime", expTime, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	UINT32 ticketTypeFlags; _jparser.validateByNameThrow("ticketTypeFlags", ticketTypeFlags);
	AtfValidator::validateInt(_descr, "ticketTypeFlags", ticketTypeFlags, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::TicketBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 ticketId; _parser0.parseUINT32(ticketId);
	AtfValidator::validateInt(_descr, "ticketId", ticketId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "admissionCode"); size_t szAdmissionCode = strlen(_dummy);
	AtfValidator::validateInt(_descr, "admissionCode", szAdmissionCode, _checker, __FILE__, __LINE__);
	bool isMulti; _parser0.parseBOOL(isMulti);
	AtfValidator::validateInt(_descr, "isMulti", isMulti, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeValue; _parser0.parseUINT32(ticketTypeValue);
	AtfValidator::validateInt(_descr, "ticketTypeValue", ticketTypeValue, _checker, __FILE__, __LINE__);
	SrvTime issued; _parser0.parseSrvTime(issued);
	AtfValidator::validateSrvDateTime(_descr, "issued", issued, _checker, __FILE__, __LINE__);
	SrvTime expTime; _parser0.parseSrvTime(expTime);
	AtfValidator::validateSrvDateTime(_descr, "expTime", expTime, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 ticketTypeFlags; _parser0.parseUINT32(ticketTypeFlags);
	AtfValidator::validateInt(_descr, "ticketTypeFlags", ticketTypeFlags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY(Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, tickets(std::move(_o.tickets))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::operator=(Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		tickets = std::move(_o.tickets);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	tickets.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::equals(const Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		tickets.equals(_o.tickets);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("tickets=");
		tickets.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		tickets.toXmlString("tickets", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("tickets"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TicketBody, 4 > >::FromXmlString(_value, tickets)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		tickets.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		tickets.parseMsg(_parser);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("tickets", tickets);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("tickets", tickets);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< TicketBody > tickets; _jparser.validateByNameThrow("tickets", tickets);
		AtfValidator::validateInt(_descr, "tickets", tickets.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTickets = Atf::LAtfVector< TicketBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tickets"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tickets", szTickets, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::clear()
{
	imageId = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::equals(const Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE& _o) const
{
	return imageId == _o.imageId;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE).append(")");
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("imageId"))
			{
				imageId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(imageId);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(imageId);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("imageId", imageId);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("imageId", imageId);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 imageId; _parser.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY(Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::equals(const Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY(Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, loginTotal(std::move(_o.loginTotal))
	, loginTotalLimit(std::move(_o.loginTotalLimit))
	, loginTimeTotalSec(std::move(_o.loginTimeTotalSec))
	, loginTimeLimitMin(std::move(_o.loginTimeLimitMin))
	, userSessionStartTime(std::move(_o.userSessionStartTime))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		loginTotal = std::move(_o.loginTotal);
		loginTotalLimit = std::move(_o.loginTotalLimit);
		loginTimeTotalSec = std::move(_o.loginTimeTotalSec);
		loginTimeLimitMin = std::move(_o.loginTimeLimitMin);
		userSessionStartTime = std::move(_o.userSessionStartTime);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	loginTotal = 0;
	loginTotalLimit = 0;
	loginTimeTotalSec = 0;
	loginTimeLimitMin = 0;
	userSessionStartTime.setNull();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		loginTotal == _o.loginTotal &&
		loginTotalLimit == _o.loginTotalLimit &&
		loginTimeTotalSec == _o.loginTimeTotalSec &&
		loginTimeLimitMin == _o.loginTimeLimitMin &&
		userSessionStartTime.equals(_o.userSessionStartTime);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("loginTotal=");
		_buf.appendUint(loginTotal);
		_buf.append(',');
		_buf.append("loginTotalLimit=");
		_buf.appendUint(loginTotalLimit);
		_buf.append(',');
		_buf.append("loginTimeTotalSec=");
		_buf.appendUint(loginTimeTotalSec);
		_buf.append(',');
		_buf.append("loginTimeLimitMin=");
		_buf.appendUint(loginTimeLimitMin);
		_buf.append(',');
		_buf.append("userSessionStartTime=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, userSessionStartTime);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("loginTotal", loginTotal, _buf);
		Atf::XmlElement::encodeAsXmlElement("loginTotalLimit", loginTotalLimit, _buf);
		Atf::XmlElement::encodeAsXmlElement("loginTimeTotalSec", loginTimeTotalSec, _buf);
		Atf::XmlElement::encodeAsXmlElement("loginTimeLimitMin", loginTimeLimitMin, _buf);
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "userSessionStartTime", userSessionStartTime);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("loginTotal"))
			{
				loginTotal = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("loginTotalLimit"))
			{
				loginTotalLimit = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("loginTimeTotalSec"))
			{
				loginTimeTotalSec = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("loginTimeLimitMin"))
			{
				loginTimeLimitMin = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userSessionStartTime"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, userSessionStartTime);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeUINT32(loginTotal);
		_msg.composeUINT32(loginTotalLimit);
		_msg.composeUINT32(loginTimeTotalSec);
		_msg.composeUINT32(loginTimeLimitMin);
		_msg.composeSrvTime(userSessionStartTime);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseUINT32(loginTotal);
		_parser.parseUINT32(loginTotalLimit);
		_parser.parseUINT32(loginTimeTotalSec);
		_parser.parseUINT32(loginTimeLimitMin);
		_parser.parseSrvTime(userSessionStartTime);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("loginTotal", loginTotal);
		_jsonstr.compose("loginTotalLimit", loginTotalLimit);
		_jsonstr.compose("loginTimeTotalSec", loginTimeTotalSec);
		_jsonstr.compose("loginTimeLimitMin", loginTimeLimitMin);
		_jsonstr.compose("userSessionStartTime", userSessionStartTime);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("loginTotal", loginTotal);
		_jparser.parseByNameThrow("loginTotalLimit", loginTotalLimit);
		_jparser.parseByNameThrow("loginTimeTotalSec", loginTimeTotalSec);
		_jparser.parseByNameThrow("loginTimeLimitMin", loginTimeLimitMin);
		_jparser.parseByNameThrow("userSessionStartTime", userSessionStartTime);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 loginTotal; _jparser.validateByNameThrow("loginTotal", loginTotal);
		AtfValidator::validateInt(_descr, "loginTotal", loginTotal, _checker, __FILE__, __LINE__);
		UINT32 loginTotalLimit; _jparser.validateByNameThrow("loginTotalLimit", loginTotalLimit);
		AtfValidator::validateInt(_descr, "loginTotalLimit", loginTotalLimit, _checker, __FILE__, __LINE__);
		UINT32 loginTimeTotalSec; _jparser.validateByNameThrow("loginTimeTotalSec", loginTimeTotalSec);
		AtfValidator::validateInt(_descr, "loginTimeTotalSec", loginTimeTotalSec, _checker, __FILE__, __LINE__);
		UINT32 loginTimeLimitMin; _jparser.validateByNameThrow("loginTimeLimitMin", loginTimeLimitMin);
		AtfValidator::validateInt(_descr, "loginTimeLimitMin", loginTimeLimitMin, _checker, __FILE__, __LINE__);
		SrvTime userSessionStartTime; _jparser.validateByNameThrow("userSessionStartTime", userSessionStartTime);
		AtfValidator::validateSrvDateTime(_descr, "userSessionStartTime", userSessionStartTime, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 loginTotal; _parser.parseUINT32(loginTotal);
		AtfValidator::validateInt(_descr, "loginTotal", loginTotal, _checker, __FILE__, __LINE__);
		UINT32 loginTotalLimit; _parser.parseUINT32(loginTotalLimit);
		AtfValidator::validateInt(_descr, "loginTotalLimit", loginTotalLimit, _checker, __FILE__, __LINE__);
		UINT32 loginTimeTotalSec; _parser.parseUINT32(loginTimeTotalSec);
		AtfValidator::validateInt(_descr, "loginTimeTotalSec", loginTimeTotalSec, _checker, __FILE__, __LINE__);
		UINT32 loginTimeLimitMin; _parser.parseUINT32(loginTimeLimitMin);
		AtfValidator::validateInt(_descr, "loginTimeLimitMin", loginTimeLimitMin, _checker, __FILE__, __LINE__);
		SrvTime userSessionStartTime; _parser.parseSrvTime(userSessionStartTime);
		AtfValidator::validateSrvDateTime(_descr, "userSessionStartTime", userSessionStartTime, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::equals(const Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ImageAprovalBody
//=================================================================

LobbyEtc::cli::ImageAprovalBody::ImageAprovalBody()
{
	clear();
}

void LobbyEtc::cli::ImageAprovalBody::clear()
{
	imgId = 0;
	userIntId = 0;
	flags = 0;
	whenApproved.setNull();
}

bool LobbyEtc::cli::ImageAprovalBody::equals(const ImageAprovalBody& _o) const
{
	return imgId == _o.imgId &&
		userIntId == _o.userIntId &&
		flags == _o.flags &&
		whenApproved.equals(_o.whenApproved);
}

const char *LobbyEtc::cli::ImageAprovalBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("imgId=");
	_buf.appendUint(imgId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("whenApproved=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, whenApproved);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::ImageAprovalBody::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("imgId", imgId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "whenApproved", whenApproved);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::ImageAprovalBody::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("imgId"))
		{
			imgId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userIntId"))
		{
			userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whenApproved"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, whenApproved);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::ImageAprovalBody::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ImageAprovalBody())) // not empty
	{
		_body.composeUINT32(imgId);
		_body.composeUINT32(userIntId);
		_body.composeUINT32(flags);
		_body.composeSrvTime(whenApproved);
	}

	_msg.composeMsgBody(_body);
}

void LobbyEtc::cli::ImageAprovalBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(imgId);
	_parser0.parseUINT32(userIntId);
	_parser0.parseUINT32(flags);
	_parser0.parseSrvTime(whenApproved);
}

const char *LobbyEtc::cli::ImageAprovalBody::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("imgId", imgId);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("whenApproved", whenApproved);
	return _buf.c_str();
}

void LobbyEtc::cli::ImageAprovalBody::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("imgId", imgId);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("whenApproved", whenApproved);
}

/* static */ void LobbyEtc::cli::ImageAprovalBody::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 imgId; _jparser.validateByNameThrow("imgId", imgId);
	AtfValidator::validateInt(_descr, "imgId", imgId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	SrvTime whenApproved; _jparser.validateByNameThrow("whenApproved", whenApproved);
	AtfValidator::validateSrvDateTime(_descr, "whenApproved", whenApproved, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::ImageAprovalBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 imgId; _parser0.parseUINT32(imgId);
	AtfValidator::validateInt(_descr, "imgId", imgId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser0.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	SrvTime whenApproved; _parser0.parseSrvTime(whenApproved);
	AtfValidator::validateSrvDateTime(_descr, "whenApproved", whenApproved, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY(Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, approvals(std::move(_o.approvals))
	, nRemaining(std::move(_o.nRemaining))
	, currentImageId(std::move(_o.currentImageId))
	, isGallery(std::move(_o.isGallery))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		approvals = std::move(_o.approvals);
		nRemaining = std::move(_o.nRemaining);
		currentImageId = std::move(_o.currentImageId);
		isGallery = std::move(_o.isGallery);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	approvals.clear();
	nRemaining = 0;
	currentImageId = 0;
	isGallery = false;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		approvals.equals(_o.approvals) &&
		nRemaining == _o.nRemaining &&
		currentImageId == _o.currentImageId &&
		isGallery == _o.isGallery;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("approvals=");
		approvals.toTraceString(_buf);
		_buf.append(',');
		_buf.append("nRemaining=");
		_buf.appendUint(nRemaining);
		_buf.append(',');
		_buf.append("currentImageId=");
		_buf.appendUint(currentImageId);
		_buf.append(',');
		_buf.append("isGallery=");
		_buf.appendUint(isGallery);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		approvals.toXmlString("approvals", _buf);
		Atf::XmlElement::encodeAsXmlElement("nRemaining", nRemaining, _buf);
		Atf::XmlElement::encodeAsXmlElement("currentImageId", currentImageId, _buf);
		Atf::XmlElement::encodeAsXmlElement("isGallery", isGallery, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("approvals"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ImageAprovalBody, 4 > >::FromXmlString(_value, approvals)) return false;
			}
			else if (_element.equals("nRemaining"))
			{
				nRemaining = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currentImageId"))
			{
				currentImageId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isGallery"))
			{
				isGallery = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		approvals.composeMsg(_msg, _ignoreJSON);
		_msg.composeUINT32(nRemaining);
		_msg.composeUINT32(currentImageId);
		_msg.composeBOOL(isGallery);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		approvals.parseMsg(_parser);
		_parser.parseUINT32(nRemaining);
		_parser.parseUINT32(currentImageId);
		_parser.parseBOOL(isGallery);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("approvals", approvals);
		_jsonstr.compose("nRemaining", nRemaining);
		_jsonstr.compose("currentImageId", currentImageId);
		_jsonstr.compose("isGallery", isGallery);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("approvals", approvals);
		_jparser.parseByNameThrow("nRemaining", nRemaining);
		_jparser.parseByNameThrow("currentImageId", currentImageId);
		_jparser.parseByNameThrow("isGallery", isGallery);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ImageAprovalBody > approvals; _jparser.validateByNameThrow("approvals", approvals);
		AtfValidator::validateInt(_descr, "approvals", approvals.size(), _checker, __FILE__, __LINE__);
		UINT32 nRemaining; _jparser.validateByNameThrow("nRemaining", nRemaining);
		AtfValidator::validateInt(_descr, "nRemaining", nRemaining, _checker, __FILE__, __LINE__);
		UINT32 currentImageId; _jparser.validateByNameThrow("currentImageId", currentImageId);
		AtfValidator::validateInt(_descr, "currentImageId", currentImageId, _checker, __FILE__, __LINE__);
		bool isGallery; _jparser.validateByNameThrow("isGallery", isGallery);
		AtfValidator::validateInt(_descr, "isGallery", isGallery, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szApprovals = Atf::LAtfVector< ImageAprovalBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("approvals"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "approvals", szApprovals, _checker, __FILE__, __LINE__);
		UINT32 nRemaining; _parser.parseUINT32(nRemaining);
		AtfValidator::validateInt(_descr, "nRemaining", nRemaining, _checker, __FILE__, __LINE__);
		UINT32 currentImageId; _parser.parseUINT32(currentImageId);
		AtfValidator::validateInt(_descr, "currentImageId", currentImageId, _checker, __FILE__, __LINE__);
		bool isGallery; _parser.parseBOOL(isGallery);
		AtfValidator::validateInt(_descr, "isGallery", isGallery, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::clear()
{
	imageId = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::equals(const Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL& _o) const
{
	return imageId == _o.imageId;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL).append(")");
	_buf.append(',');
	_buf.append("imageId=");
	_buf.appendUint(imageId);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("imageId", imageId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("imageId"))
			{
				imageId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(imageId);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(imageId);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("imageId", imageId);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("imageId", imageId);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 imageId; _jparser.validateByNameThrow("imageId", imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 imageId; _parser.parseUINT32(imageId);
	AtfValidator::validateInt(_descr, "imageId", imageId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY(Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::clear()
{
	optionType = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::equals(const Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS& _o) const
{
	return optionType == _o.optionType;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_CLIENT_OPTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("optionType=");
	_buf.appendUint(optionType);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("optionType", optionType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("optionType"))
			{
				optionType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(optionType);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(optionType);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("optionType", optionType);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("optionType", optionType);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	UINT32 optionType; _jparser.validateByNameThrow("optionType", optionType);
	AtfValidator::validateIntRange(_descr, "optionType", optionType, eUserPropertyVipBarOptions, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 optionType; _parser.parseUINT32(optionType);
	AtfValidator::validateIntRange(_descr, "optionType", optionType, eUserPropertyVipBarOptions, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY(Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
	, encodedPropStr(std::move(_o.encodedPropStr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::operator=(Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
		encodedPropStr = std::move(_o.encodedPropStr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	encodedPropStr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::equals(const Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		encodedPropStr.size() == _o.encodedPropStr.size() && memcmp(encodedPropStr.ptr(), _o.encodedPropStr.ptr(), encodedPropStr.size()) == 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("encodedPropStr=");
		Atf::AtfTempl<PBlock>::ToTraceString(_buf, encodedPropStr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("encodedPropStr", encodedPropStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("encodedPropStr"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, encodedPropStr);
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		CommMsgBody _msg0;
		_msg0._composeVarBlock(encodedPropStr.ptr(), encodedPropStr.size());
		_msg.composeMsgBody(_msg0);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		parseAnonymousMsgBody0(_parser);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("encodedPropStr", encodedPropStr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("encodedPropStr", encodedPropStr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PBlock encodedPropStr; _jparser.validateByNameThrow("encodedPropStr", encodedPropStr);
		AtfValidator::validateInt(_descr, "encodedPropStr", encodedPropStr.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parsePBlock(encodedPropStr);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const BYTE* encodedPropStr; size_t szEncodedPropStr; _parser0._parseVarBlock(encodedPropStr, szEncodedPropStr);  /*encodedPropStr*/
	AtfValidator::validateInt(_descr, "encodedPropStr", szEncodedPropStr, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS&& _o)
	: body(std::move(_o.body))
	, propType(std::move(_o.propType))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS& LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::operator=(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS&& _o)
{
	if(this != &_o)
	{
		body = std::move(_o.body);
		propType = std::move(_o.propType);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::clear()
{
	body.clear();
	propType = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::equals(const Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS& _o) const
{
	return body.equals(_o.body) &&
		propType == _o.propType;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_CLIENT_OPTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("body=");
	_buf.append('{'); Atf::XmlElement::encodeMsgBody(body, _buf); _buf.append('}');
	_buf.append(',');
	_buf.append("propType=");
	_buf.appendUint(propType);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("body", body, _buf);
	Atf::XmlElement::encodeAsXmlElement("propType", propType, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("body"))
			{
				if(!Atf::XmlElement::_movePBlock0ToMsgBody(_value, body)) return false;
			}
			else if (_element.equals("propType"))
			{
				propType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeMsgBody(body);
	_msg.composeUINT32(propType);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseMsgBody(body);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(propType);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("body", body);
	_jsonstr.compose("propType", propType);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("body", body);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("propType", propType);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::CopyableMsgBody body; _jparser.validateByNameThrow("body", body);
	AtfValidator::validateIntMax(_descr, "body", body._size(), USER_PROPERTYSTR_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 propType; _jparser.validateByNameThrow("propType", propType);
	AtfValidator::validateIntRange(_descr, "propType", propType, eUserPropertyVipBarOptions, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	size_t szBody; _parser.skipMsgBody(szBody);  /*body*/
	AtfValidator::validateIntMax(_descr, "body", szBody, USER_PROPERTYSTR_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 propType; _parser.parseUINT32(propType);
	AtfValidator::validateIntRange(_descr, "propType", propType, eUserPropertyVipBarOptions, eClientCustomOptionsEnd, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDesc(std::move(_o.errDesc))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::operator=(Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDesc = std::move(_o.errDesc);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::equals(const Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::equals(const Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_DISPLAY_ADS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_DISPLAY_ADS).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_DISPLAY_ADS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_DISPLAY_ADS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_DISPLAY_ADS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY(Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, displayAds(std::move(_o.displayAds))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		displayAds = std::move(_o.displayAds);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	displayAds = false;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		displayAds == _o.displayAds;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("displayAds=");
		_buf.appendUint(displayAds);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("displayAds", displayAds, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("displayAds"))
			{
				displayAds = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeBOOL(displayAds);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseBOOL(displayAds);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("displayAds", displayAds);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("displayAds", displayAds);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool displayAds; _jparser.validateByNameThrow("displayAds", displayAds);
		AtfValidator::validateInt(_descr, "displayAds", displayAds, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool displayAds; _parser.parseBOOL(displayAds);
		AtfValidator::validateInt(_descr, "displayAds", displayAds, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_ARJEL_EVENTS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS(Protocol_MSG_LOBBY_GET_ARJEL_EVENTS&& _o)
	: notUsedUserId(std::move(_o.notUsedUserId))
	, notUsedUserIntId(std::move(_o.notUsedUserIntId))
	, notUsedlocale(std::move(_o.notUsedlocale))
	, notUsedlicenseId(std::move(_o.notUsedlicenseId))
	, notUsedipAddr(std::move(_o.notUsedipAddr))
	, frArjelUserHash(std::move(_o.frArjelUserHash))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS& LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::operator=(Protocol_MSG_LOBBY_GET_ARJEL_EVENTS&& _o)
{
	if(this != &_o)
	{
		notUsedUserId = std::move(_o.notUsedUserId);
		notUsedUserIntId = std::move(_o.notUsedUserIntId);
		notUsedlocale = std::move(_o.notUsedlocale);
		notUsedlicenseId = std::move(_o.notUsedlicenseId);
		notUsedipAddr = std::move(_o.notUsedipAddr);
		frArjelUserHash = std::move(_o.frArjelUserHash);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::clear()
{
	notUsedUserId.clear();
	notUsedUserIntId = 0;
	notUsedlocale = 0;
	notUsedlicenseId = 0;
	notUsedipAddr.clear();
	frArjelUserHash.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::equals(const Protocol_MSG_LOBBY_GET_ARJEL_EVENTS& _o) const
{
	return Atf::atfPStringEquals(notUsedUserId, _o.notUsedUserId) &&
		notUsedUserIntId == _o.notUsedUserIntId &&
		notUsedlocale == _o.notUsedlocale &&
		notUsedlicenseId == _o.notUsedlicenseId &&
		Atf::atfPStringEquals(notUsedipAddr, _o.notUsedipAddr) &&
		Atf::atfPStringEquals(frArjelUserHash, _o.frArjelUserHash);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_ARJEL_EVENTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_ARJEL_EVENTS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_ARJEL_EVENTS).append(")");
	_buf.append(',');
	_buf.append("notUsedUserId=");
	_buf.append(notUsedUserId);
	_buf.append(',');
	_buf.append("notUsedUserIntId=");
	_buf.appendUint(notUsedUserIntId);
	_buf.append(',');
	_buf.append("notUsedlocale=");
	_buf.appendUint(notUsedlocale);
	_buf.append(',');
	_buf.append("notUsedlicenseId=");
	_buf.appendUint(notUsedlicenseId);
	_buf.append(',');
	_buf.append("notUsedipAddr=");
	_buf.append(notUsedipAddr);
	_buf.append(',');
	_buf.append("frArjelUserHash=");
	_buf.append(frArjelUserHash);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_ARJEL_EVENTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedUserId", notUsedUserId, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedUserIntId", notUsedUserIntId, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedlocale", notUsedlocale, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedlicenseId", notUsedlicenseId, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedipAddr", notUsedipAddr, _buf);
	Atf::XmlElement::encodeAsXmlElement("frArjelUserHash", frArjelUserHash, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedUserId)) return false;
			}
			else if (_element.equals("notUsedUserIntId"))
			{
				notUsedUserIntId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedlocale"))
			{
				notUsedlocale = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedlicenseId"))
			{
				notUsedlicenseId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("notUsedipAddr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedipAddr)) return false;
			}
			else if (_element.equals("frArjelUserHash"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, frArjelUserHash)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedUserId);
	_msg.composeUINT32(notUsedUserIntId);
	_msg.composeUINT32(notUsedlocale);
	_msg.composeUINT32(notUsedlicenseId);
	_msg.composeString(notUsedipAddr);
	_msg.composeString(frArjelUserHash);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseStringP(notUsedUserId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(notUsedUserIntId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(notUsedlocale);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(notUsedlicenseId);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(notUsedipAddr);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(frArjelUserHash);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedUserId", notUsedUserId);
	_jsonstr.compose("notUsedUserIntId", notUsedUserIntId);
	_jsonstr.compose("notUsedlocale", notUsedlocale);
	_jsonstr.compose("notUsedlicenseId", notUsedlicenseId);
	_jsonstr.compose("notUsedipAddr", notUsedipAddr);
	_jsonstr.compose("frArjelUserHash", frArjelUserHash);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedUserId", notUsedUserId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedUserIntId", notUsedUserIntId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedlocale", notUsedlocale);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedlicenseId", notUsedlicenseId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedipAddr", notUsedipAddr);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("frArjelUserHash", frArjelUserHash);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ARJEL_EVENTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	PString notUsedUserId; _jparser.validateByNameThrow("notUsedUserId", notUsedUserId);
	AtfValidator::validateIntMax(_descr, "notUsedUserId", notUsedUserId.length(), 20, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 notUsedUserIntId; _jparser.validateByNameThrow("notUsedUserIntId", notUsedUserIntId);
	AtfValidator::validateInt(_descr, "notUsedUserIntId", notUsedUserIntId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 notUsedlocale; _jparser.validateByNameThrow("notUsedlocale", notUsedlocale);
	AtfValidator::validateIntRange(_descr, "notUsedlocale", notUsedlocale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 notUsedlicenseId; _jparser.validateByNameThrow("notUsedlicenseId", notUsedlicenseId);
	AtfValidator::validateIntMax(_descr, "notUsedlicenseId", notUsedlicenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString notUsedipAddr; _jparser.validateByNameThrow("notUsedipAddr", notUsedipAddr);
	AtfValidator::validateIntMax(_descr, "notUsedipAddr", notUsedipAddr.length(), 1000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString frArjelUserHash; _jparser.validateByNameThrow("frArjelUserHash", frArjelUserHash);
	AtfValidator::validateIntMax(_descr, "frArjelUserHash", frArjelUserHash.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ARJEL_EVENTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "notUsedUserId"); size_t szNotUsedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedUserId", szNotUsedUserId, 20, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 notUsedUserIntId; _parser.parseUINT32(notUsedUserIntId);
	AtfValidator::validateInt(_descr, "notUsedUserIntId", notUsedUserIntId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 notUsedlocale; _parser.parseUINT32(notUsedlocale);
	AtfValidator::validateIntRange(_descr, "notUsedlocale", notUsedlocale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 notUsedlicenseId; _parser.parseUINT32(notUsedlicenseId);
	AtfValidator::validateIntMax(_descr, "notUsedlicenseId", notUsedlicenseId, eLicenceLast, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "notUsedipAddr"); size_t szNotUsedipAddr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedipAddr", szNotUsedipAddr, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "frArjelUserHash"); size_t szFrArjelUserHash = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "frArjelUserHash", szFrArjelUserHash, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY(Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::operator=(Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::equals(const Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_ARJEL_EVENTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_ARJEL_EVENTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_ARJEL_EVENTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ARJEL_EVENTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_ARJEL_EVENTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::clear()
{
	onlyTargetBanner = false;
	newsTypeMask = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::equals(const Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP& _o) const
{
	return onlyTargetBanner == _o.onlyTargetBanner &&
		newsTypeMask == _o.newsTypeMask;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TARGET_NEWS_DESKTOP != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TARGET_NEWS_DESKTOP).append(")");
	_buf.append(',');
	_buf.append("onlyTargetBanner=");
	_buf.appendUint(onlyTargetBanner);
	_buf.append(',');
	_buf.append("newsTypeMask=");
	_buf.appendUint(newsTypeMask);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TARGET_NEWS_DESKTOP).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("onlyTargetBanner", onlyTargetBanner, _buf);
	Atf::XmlElement::encodeAsXmlElement("newsTypeMask", newsTypeMask, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("onlyTargetBanner"))
			{
				onlyTargetBanner = (*_value.ptr() == '1');
			}
			else if (_element.equals("newsTypeMask"))
			{
				newsTypeMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(onlyTargetBanner);
	_msg.composeUINT32(newsTypeMask);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(onlyTargetBanner);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(newsTypeMask);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("onlyTargetBanner", onlyTargetBanner);
	_jsonstr.compose("newsTypeMask", newsTypeMask);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("onlyTargetBanner", onlyTargetBanner);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("newsTypeMask", newsTypeMask);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_DESKTOP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	bool onlyTargetBanner; _jparser.validateByNameThrow("onlyTargetBanner", onlyTargetBanner);
	AtfValidator::validateInt(_descr, "onlyTargetBanner", onlyTargetBanner, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 newsTypeMask; _jparser.validateByNameThrow("newsTypeMask", newsTypeMask);
	AtfValidator::validateIntRange(_descr, "newsTypeMask", newsTypeMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_DESKTOP";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool onlyTargetBanner; _parser.parseBOOL(onlyTargetBanner);
	AtfValidator::validateInt(_descr, "onlyTargetBanner", onlyTargetBanner, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 newsTypeMask; _parser.parseUINT32(newsTypeMask);
	AtfValidator::validateIntRange(_descr, "newsTypeMask", newsTypeMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::clear()
{
	clientDownloadSource = 0;
	newsProductMask = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::equals(const Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE& _o) const
{
	return clientDownloadSource == _o.clientDownloadSource &&
		newsProductMask == _o.newsProductMask;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_TARGET_NEWS_MOBILE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_TARGET_NEWS_MOBILE).append(")");
	_buf.append(',');
	_buf.append("clientDownloadSource=");
	_buf.appendUint(clientDownloadSource);
	_buf.append(',');
	_buf.append("newsProductMask=");
	_buf.appendUint(newsProductMask);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_TARGET_NEWS_MOBILE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clientDownloadSource", clientDownloadSource, _buf);
	Atf::XmlElement::encodeAsXmlElement("newsProductMask", newsProductMask, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clientDownloadSource"))
			{
				clientDownloadSource = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("newsProductMask"))
			{
				newsProductMask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clientDownloadSource);
	_msg.composeUINT32(newsProductMask);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clientDownloadSource);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(newsProductMask);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clientDownloadSource", clientDownloadSource);
	_jsonstr.compose("newsProductMask", newsProductMask);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clientDownloadSource", clientDownloadSource);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("newsProductMask", newsProductMask);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clientDownloadSource; _jparser.validateByNameThrow("clientDownloadSource", clientDownloadSource);
	AtfValidator::validateInt(_descr, "clientDownloadSource", clientDownloadSource, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 newsProductMask; _jparser.validateByNameThrow("newsProductMask", newsProductMask);
	AtfValidator::validateIntRange(_descr, "newsProductMask", newsProductMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_TARGET_NEWS_MOBILE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clientDownloadSource; _parser.parseUINT32(clientDownloadSource);
	AtfValidator::validateInt(_descr, "clientDownloadSource", clientDownloadSource, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 newsProductMask; _parser.parseUINT32(newsProductMask);
	AtfValidator::validateIntRange(_descr, "newsProductMask", newsProductMask, eTargetNewsGeneral, eTargetNewsAll, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::equals(const Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_GET_USER_CAPS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_GET_USER_CAPS_REPLY).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_GET_USER_CAPS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_CAPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_GET_USER_CAPS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::clear()
{
	flags = 0;
	flags2 = 0;
	flags3 = 0;
	privileges = 0;
	privileges2 = 0;
	privileges3 = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::equals(const Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV& _o) const
{
	return flags == _o.flags &&
		flags2 == _o.flags2 &&
		flags3 == _o.flags3 &&
		privileges == _o.privileges &&
		privileges2 == _o.privileges2 &&
		privileges3 == _o.privileges3;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV).append(")");
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("flags3=");
	_buf.appendUint64(flags3);
	_buf.append(',');
	_buf.append("privileges=");
	_buf.appendUint(privileges);
	_buf.append(',');
	_buf.append("privileges2=");
	_buf.appendUint64(privileges2);
	_buf.append(',');
	_buf.append("privileges3=");
	_buf.appendUint64(privileges3);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags2", flags2, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags3", flags3, _buf);
	Atf::XmlElement::encodeAsXmlElement("privileges", privileges, _buf);
	Atf::XmlElement::encodeAsXmlElement("privileges2", privileges2, _buf);
	Atf::XmlElement::encodeAsXmlElement("privileges3", privileges3, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags2"))
			{
				flags2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags3"))
			{
				flags3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privileges"))
			{
				privileges = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privileges2"))
			{
				privileges2 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("privileges3"))
			{
				privileges3 = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(flags);
	_msg.composeUINT64(flags2);
	_msg.composeUINT64(flags3);
	_msg.composeUINT32(privileges);
	_msg.composeUINT64(privileges2);
	_msg.composeUINT64(privileges3);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(flags);
	_parser.parseUINT64(flags2);
	_parser.parseUINT64(flags3);
	_parser.parseUINT32(privileges);
	_parser.parseUINT64(privileges2);
	_parser.parseUINT64(privileges3);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("flags2", flags2);
	_jsonstr.compose("flags3", flags3);
	_jsonstr.compose("privileges", privileges);
	_jsonstr.compose("privileges2", privileges2);
	_jsonstr.compose("privileges3", privileges3);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("flags2", flags2);
	_jparser.parseByNameThrow("flags3", flags3);
	_jparser.parseByNameThrow("privileges", privileges);
	_jparser.parseByNameThrow("privileges2", privileges2);
	_jparser.parseByNameThrow("privileges3", privileges3);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _jparser.validateByNameThrow("flags2", flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT64 flags3; _jparser.validateByNameThrow("flags3", flags3);
	AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
	UINT32 privileges; _jparser.validateByNameThrow("privileges", privileges);
	AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
	UINT64 privileges2; _jparser.validateByNameThrow("privileges2", privileges2);
	AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
	UINT64 privileges3; _jparser.validateByNameThrow("privileges3", privileges3);
	AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT64 flags3; _parser.parseUINT64(flags3);
	AtfValidator::validateUint(_descr, "flags3", flags3, _checker, __FILE__, __LINE__);
	UINT32 privileges; _parser.parseUINT32(privileges);
	AtfValidator::validateInt(_descr, "privileges", privileges, _checker, __FILE__, __LINE__);
	UINT64 privileges2; _parser.parseUINT64(privileges2);
	AtfValidator::validateUint(_descr, "privileges2", privileges2, _checker, __FILE__, __LINE__);
	UINT64 privileges3; _parser.parseUINT64(privileges3);
	AtfValidator::validateUint(_descr, "privileges3", privileges3, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR(Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR&& _o)
	: gameAvatar(std::move(_o.gameAvatar))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::operator=(Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR&& _o)
{
	if(this != &_o)
	{
		gameAvatar = std::move(_o.gameAvatar);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::clear()
{
	gameAvatar.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::equals(const Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR& _o) const
{
	return gameAvatar.equals(_o.gameAvatar);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_SET_GAME_AVATAR != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_SET_GAME_AVATAR).append(")");
	_buf.append(',');
	_buf.append("gameAvatar=");
	gameAvatar.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_SET_GAME_AVATAR).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	gameAvatar.toXmlString("gameAvatar", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("gameAvatar"))
			{
				if(!Atf::AtfTempl< BrandProt::AvatarImg >::FromXmlString(_value, gameAvatar)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	gameAvatar.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::parseMsg(CommMsgParser& _parser)
{
	gameAvatar.parseMsg(_parser);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("gameAvatar", gameAvatar);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("gameAvatar", gameAvatar);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_GAME_AVATAR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BrandProt::AvatarImg gameAvatar; _jparser.validateByNameThrow("gameAvatar", gameAvatar);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_GAME_AVATAR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	BrandProt::AvatarImg::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameAvatar"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY(Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_ADMIN_INFO_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::equals(const Protocol_MSG_LOBBY_ADMIN_INFO_REPLY& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_ADMIN_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_ADMIN_INFO_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_ADMIN_INFO_REPLY).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_ADMIN_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ADMIN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_ADMIN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::equals(const Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY(Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, freeBetCount(std::move(_o.freeBetCount))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		freeBetCount = std::move(_o.freeBetCount);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	freeBetCount = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		freeBetCount == _o.freeBetCount;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("freeBetCount=");
		_buf.appendUint(freeBetCount);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("freeBetCount", freeBetCount, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("freeBetCount"))
			{
				freeBetCount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeUINT32(freeBetCount);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseUINT32(freeBetCount);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("freeBetCount", freeBetCount);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("freeBetCount", freeBetCount);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 freeBetCount; _jparser.validateByNameThrow("freeBetCount", freeBetCount);
		AtfValidator::validateInt(_descr, "freeBetCount", freeBetCount, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 freeBetCount; _parser.parseUINT32(freeBetCount);
		AtfValidator::validateInt(_descr, "freeBetCount", freeBetCount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PlayingHistoryMetadata
//=================================================================

LobbyEtc::cli::PlayingHistoryMetadata::PlayingHistoryMetadata()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::PlayingHistoryMetadata::PlayingHistoryMetadata(PlayingHistoryMetadata&& _o)
	: startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, password(std::move(_o.password))
	, includeFPP(std::move(_o.includeFPP))
	, reportFormat(std::move(_o.reportFormat))
	, isHtmlForClient(std::move(_o.isHtmlForClient))
{
}

LobbyEtc::cli::PlayingHistoryMetadata& LobbyEtc::cli::PlayingHistoryMetadata::operator=(PlayingHistoryMetadata&& _o)
{
	if(this != &_o)
	{
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		password = std::move(_o.password);
		includeFPP = std::move(_o.includeFPP);
		reportFormat = std::move(_o.reportFormat);
		isHtmlForClient = std::move(_o.isHtmlForClient);
	}
	return *this;
}

#endif

void LobbyEtc::cli::PlayingHistoryMetadata::clear()
{
	startDate.setNull();
	endDate.setNull();
	password.clear();
	includeFPP = false;
	reportFormat = 0;
	isHtmlForClient = false;
}

bool LobbyEtc::cli::PlayingHistoryMetadata::equals(const PlayingHistoryMetadata& _o) const
{
	return startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		Atf::atfPStringEquals(password, _o.password) &&
		includeFPP == _o.includeFPP &&
		reportFormat == _o.reportFormat &&
		isHtmlForClient == _o.isHtmlForClient;
}

const char *LobbyEtc::cli::PlayingHistoryMetadata::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
	_buf.append(',');
	_buf.append("endDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	_buf.append(',');
	_buf.append("password=");
	_buf.append("...");
	_buf.append(',');
	_buf.append("includeFPP=");
	_buf.appendUint(includeFPP);
	_buf.append(',');
	_buf.append("reportFormat=");
	_buf.appendUint(reportFormat);
	_buf.append(',');
	_buf.append("isHtmlForClient=");
	_buf.appendUint(isHtmlForClient);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::PlayingHistoryMetadata::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "startDate", startDate);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("includeFPP", includeFPP, _buf);
	Atf::XmlElement::encodeAsXmlElement("reportFormat", reportFormat, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHtmlForClient", isHtmlForClient, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::PlayingHistoryMetadata::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("startDate"))
		{
			Atf::AtfTempl<SrvDate>::FromXmlString(_value, startDate);
		}
		else if (_element.equals("endDate"))
		{
			Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
		}
		else if (_element.equals("password"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
		}
		else if (_element.equals("includeFPP"))
		{
			includeFPP = (*_value.ptr() == '1');
		}
		else if (_element.equals("reportFormat"))
		{
			reportFormat = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHtmlForClient"))
		{
			isHtmlForClient = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::PlayingHistoryMetadata::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvDate(startDate);
	_msg.composeSrvDate(endDate);
	_msg.composeString(password);
	_msg.composeBOOL(includeFPP);
	_msg.composeUINT32(reportFormat);
	_msg.composeBOOL(isHtmlForClient);
}

void LobbyEtc::cli::PlayingHistoryMetadata::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvDate(startDate);
	_parser.parseSrvDate(endDate);
	_parser.parseStringP(password);
	_parser.parseBOOL(includeFPP);
	_parser.parseUINT32(reportFormat);
	_parser.parseBOOL(isHtmlForClient);
}

const char *LobbyEtc::cli::PlayingHistoryMetadata::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("startDate", startDate);
	_jsonstr.compose("endDate", endDate);
	_jsonstr.compose("password", password);
	_jsonstr.compose("includeFPP", includeFPP);
	_jsonstr.compose("reportFormat", reportFormat);
	_jsonstr.compose("isHtmlForClient", isHtmlForClient);
	return _buf.c_str();
}

void LobbyEtc::cli::PlayingHistoryMetadata::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("startDate", startDate);
	_jparser.parseByNameThrow("endDate", endDate);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("includeFPP", includeFPP);
	_jparser.parseByNameThrow("reportFormat", reportFormat);
	_jparser.parseByNameThrow("isHtmlForClient", isHtmlForClient);
}

/* static */ void LobbyEtc::cli::PlayingHistoryMetadata::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvDate startDate; _jparser.validateByNameThrow("startDate", startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
	bool includeFPP; _jparser.validateByNameThrow("includeFPP", includeFPP);
	AtfValidator::validateInt(_descr, "includeFPP", includeFPP, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _jparser.validateByNameThrow("reportFormat", reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _jparser.validateByNameThrow("isHtmlForClient", isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::PlayingHistoryMetadata::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	SrvDate startDate; _parser.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	bool includeFPP; _parser.parseBOOL(includeFPP);
	AtfValidator::validateInt(_descr, "includeFPP", includeFPP, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _parser.parseUINT32(reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	bool isHtmlForClient; _parser.parseBOOL(isHtmlForClient);
	AtfValidator::validateInt(_descr, "isHtmlForClient", isHtmlForClient, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    HandHistoryMetadata
//=================================================================

LobbyEtc::cli::HandHistoryMetadata::HandHistoryMetadata()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::HandHistoryMetadata::HandHistoryMetadata(HandHistoryMetadata&& _o)
	: type(std::move(_o.type))
	, param(std::move(_o.param))
	, numRequested(std::move(_o.numRequested))
	, handId64(std::move(_o.handId64))
	, locale(std::move(_o.locale))
	, password(std::move(_o.password))
{
}

LobbyEtc::cli::HandHistoryMetadata& LobbyEtc::cli::HandHistoryMetadata::operator=(HandHistoryMetadata&& _o)
{
	if(this != &_o)
	{
		type = std::move(_o.type);
		param = std::move(_o.param);
		numRequested = std::move(_o.numRequested);
		handId64 = std::move(_o.handId64);
		locale = std::move(_o.locale);
		password = std::move(_o.password);
	}
	return *this;
}

#endif

void LobbyEtc::cli::HandHistoryMetadata::clear()
{
	type = 0;
	param = 0;
	numRequested = 0;
	handId64 = 0;
	locale = 0;
	password.clear();
}

bool LobbyEtc::cli::HandHistoryMetadata::equals(const HandHistoryMetadata& _o) const
{
	return type == _o.type &&
		param == _o.param &&
		numRequested == _o.numRequested &&
		handId64 == _o.handId64 &&
		locale == _o.locale &&
		Atf::atfPStringEquals(password, _o.password);
}

const char *LobbyEtc::cli::HandHistoryMetadata::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendInt(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_buf.append(',');
		_buf.append("param=");
		_buf.appendUint64(param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_buf.append(',');
		_buf.append("param=");
		_buf.appendUint64(param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_buf.append(',');
		_buf.append("param=");
		_buf.appendUint64(param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
		_buf.append(',');
		_buf.append("handId64=");
		_buf.appendUint64(handId64);
	}
	_buf.append(',');
	_buf.append("locale=");
	_buf.appendUint(locale);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::HandHistoryMetadata::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		Atf::XmlElement::encodeAsXmlElement("param", param, _buf);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		Atf::XmlElement::encodeAsXmlElement("param", param, _buf);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		Atf::XmlElement::encodeAsXmlElement("param", param, _buf);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		Atf::XmlElement::encodeAsXmlElement("numRequested", numRequested, _buf);
		Atf::XmlElement::encodeAsXmlElement("handId64", handId64, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::HandHistoryMetadata::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			type = (INT8)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("param"))
		{
			param = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numRequested"))
		{
			numRequested = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handId64"))
		{
			handId64 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("locale"))
		{
			locale = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("password"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::HandHistoryMetadata::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT8(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_msg.composeUINT64(param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_msg.composeUINT64(param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_msg.composeUINT64(param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_msg.composeUINT32(numRequested);
		_msg.composeUINT64(handId64);
	}
	_msg.composeUINT32(locale);
	_msg.composeString(password);
}

void LobbyEtc::cli::HandHistoryMetadata::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT8(type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_parser.parseUINT64(param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_parser.parseUINT64(param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_parser.parseUINT64(param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_parser.parseUINT32(numRequested);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(handId64);
	}
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(locale);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(password);
}

const char *LobbyEtc::cli::HandHistoryMetadata::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_jsonstr.compose("param", param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_jsonstr.compose("param", param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_jsonstr.compose("param", param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_jsonstr.compose("numRequested", numRequested);
		_jsonstr.compose("handId64", handId64);
	}
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("password", password);
	return _buf.c_str();
}

void LobbyEtc::cli::HandHistoryMetadata::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		_jparser.parseByNameThrow("param", param);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		_jparser.parseByNameThrow("param", param);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		_jparser.parseByNameThrow("param", param);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		_jparser.parseByNameThrow("numRequested", numRequested);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("handId64", handId64);
	}
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("locale", locale);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("password", password);
}

/* static */ void LobbyEtc::cli::HandHistoryMetadata::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT8 type = 0;
	_jparser.validateByNameThrow("type", type);
	AtfValidator::validateIntRange(_descr, "type", type, HAND_HISTORY_LAST_HANDS, HAND_HISTORY_TOURNAMENT, _checker, __FILE__, __LINE__);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		UINT64 param; _jparser.validateByNameThrow("param", param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, MAX_HANDS_ALLOWED, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		UINT64 param; _jparser.validateByNameThrow("param", param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, 604800, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		UINT64 param; _jparser.validateByNameThrow("param", param);
		AtfValidator::validateUint(_descr, "param", param, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		UINT32 numRequested; _jparser.validateByNameThrow("numRequested", numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 1, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT64 handId64; _jparser.validateByNameThrow("handId64", handId64);
		AtfValidator::validateUint(_descr, "handId64", handId64, _checker, __FILE__, __LINE__);
	}
	if(_jparser.parseEnded()) return;
	UINT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntRange(_descr, "locale", locale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::HandHistoryMetadata::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	INT8 type = 0;
	_parser.parseINT8(type);
	AtfValidator::validateIntRange(_descr, "type", type, HAND_HISTORY_LAST_HANDS, HAND_HISTORY_TOURNAMENT, _checker, __FILE__, __LINE__);
	if(type == HAND_HISTORY_LAST_HANDS)
	{
		UINT64 param; _parser.parseUINT64(param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, MAX_HANDS_ALLOWED, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_LAST_SECONDS)
	{
		UINT64 param; _parser.parseUINT64(param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, 604800, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_TOURNAMENT)
	{
		UINT64 param; _parser.parseUINT64(param);
		AtfValidator::validateUint(_descr, "param", param, _checker, __FILE__, __LINE__);
	}
	else if (type == HAND_HISTORY_HAND_IDS)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 1, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 handId64; _parser.parseUINT64(handId64);
		AtfValidator::validateUint(_descr, "handId64", handId64, _checker, __FILE__, __LINE__);
	}
	if(_parser.parseEnded()) return;
	UINT32 locale; _parser.parseUINT32(locale);
	AtfValidator::validateIntRange(_descr, "locale", locale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    AuxHandHistoryMetadata
//=================================================================

LobbyEtc::cli::AuxHandHistoryMetadata::AuxHandHistoryMetadata()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::AuxHandHistoryMetadata::AuxHandHistoryMetadata(AuxHandHistoryMetadata&& _o)
	: locale(std::move(_o.locale))
	, timezone(std::move(_o.timezone))
	, criteriaType(std::move(_o.criteriaType))
	, param(std::move(_o.param))
	, numRequested(std::move(_o.numRequested))
	, handId64(std::move(_o.handId64))
	, password(std::move(_o.password))
{
}

LobbyEtc::cli::AuxHandHistoryMetadata& LobbyEtc::cli::AuxHandHistoryMetadata::operator=(AuxHandHistoryMetadata&& _o)
{
	if(this != &_o)
	{
		locale = std::move(_o.locale);
		timezone = std::move(_o.timezone);
		criteriaType = std::move(_o.criteriaType);
		param = std::move(_o.param);
		numRequested = std::move(_o.numRequested);
		handId64 = std::move(_o.handId64);
		password = std::move(_o.password);
	}
	return *this;
}

#endif

void LobbyEtc::cli::AuxHandHistoryMetadata::clear()
{
	locale = 0;
	timezone = 0;
	criteriaType = 0;
	param = 0;
	numRequested = 0;
	handId64 = 0;
	password.clear();
}

bool LobbyEtc::cli::AuxHandHistoryMetadata::equals(const AuxHandHistoryMetadata& _o) const
{
	return locale == _o.locale &&
		timezone == _o.timezone &&
		criteriaType == _o.criteriaType &&
		param == _o.param &&
		numRequested == _o.numRequested &&
		handId64 == _o.handId64 &&
		Atf::atfPStringEquals(password, _o.password);
}

const char *LobbyEtc::cli::AuxHandHistoryMetadata::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("locale=");
	_buf.appendInt(locale);
	_buf.append(',');
	_buf.append("timezone=");
	_buf.appendUint(timezone);
	_buf.append(',');
	_buf.append("criteriaType=");
	_buf.appendUint(criteriaType);
	if (criteriaType == aux::AUX_HH_BY_NUM_OF_HANDS)
	{
		_buf.append(',');
		_buf.append("param=");
		_buf.appendUint64(param);
	}
	else if (criteriaType == aux::AUX_HH_BY_TIME)
	{
		_buf.append(',');
		_buf.append("param=");
		_buf.appendUint64(param);
	}
	else if (criteriaType == aux::AUX_HH_BY_HANDID)
	{
		_buf.append(',');
		_buf.append("numRequested=");
		_buf.appendUint(numRequested);
		_buf.append(',');
		_buf.append("handId64=");
		_buf.appendUint64(handId64);
	}
	_buf.append(',');
	_buf.append("password=");
	_buf.append("...");
	_buf.append('}');
	return _buf.c_str();
}

const char *LobbyEtc::cli::AuxHandHistoryMetadata::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("locale", locale, _buf);
	Atf::XmlElement::encodeAsXmlElement("timezone", timezone, _buf);
	Atf::XmlElement::encodeAsXmlElement("criteriaType", criteriaType, _buf);
	if (criteriaType == aux::AUX_HH_BY_NUM_OF_HANDS)
	{
		Atf::XmlElement::encodeAsXmlElement("param", param, _buf);
	}
	else if (criteriaType == aux::AUX_HH_BY_TIME)
	{
		Atf::XmlElement::encodeAsXmlElement("param", param, _buf);
	}
	else if (criteriaType == aux::AUX_HH_BY_HANDID)
	{
		Atf::XmlElement::encodeAsXmlElement("numRequested", numRequested, _buf);
		Atf::XmlElement::encodeAsXmlElement("handId64", handId64, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool LobbyEtc::cli::AuxHandHistoryMetadata::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("locale"))
		{
			locale = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timezone"))
		{
			timezone = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("criteriaType"))
		{
			criteriaType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("param"))
		{
			param = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numRequested"))
		{
			numRequested = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("handId64"))
		{
			handId64 = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("password"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void LobbyEtc::cli::AuxHandHistoryMetadata::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(locale);
	_msg.composeUINT32(timezone);
	_msg.composeBYTE(criteriaType);
	if (criteriaType == aux::AUX_HH_BY_NUM_OF_HANDS)
	{
		_msg.composeUINT64(param);
	}
	else if (criteriaType == aux::AUX_HH_BY_TIME)
	{
		_msg.composeUINT64(param);
	}
	else if (criteriaType == aux::AUX_HH_BY_HANDID)
	{
		_msg.composeUINT32(numRequested);
		_msg.composeUINT64(handId64);
	}
	_msg.composeString(password);
}

void LobbyEtc::cli::AuxHandHistoryMetadata::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(locale);
	_parser.parseUINT32(timezone);
	_parser.parseBYTE(criteriaType);
	if (criteriaType == aux::AUX_HH_BY_NUM_OF_HANDS)
	{
		_parser.parseUINT64(param);
	}
	else if (criteriaType == aux::AUX_HH_BY_TIME)
	{
		_parser.parseUINT64(param);
	}
	else if (criteriaType == aux::AUX_HH_BY_HANDID)
	{
		_parser.parseUINT32(numRequested);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(handId64);
	}
	_parser.parseStringP(password);
}

const char *LobbyEtc::cli::AuxHandHistoryMetadata::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("locale", locale);
	_jsonstr.compose("timezone", timezone);
	_jsonstr.compose("criteriaType", criteriaType);
	if (criteriaType == aux::AUX_HH_BY_NUM_OF_HANDS)
	{
		_jsonstr.compose("param", param);
	}
	else if (criteriaType == aux::AUX_HH_BY_TIME)
	{
		_jsonstr.compose("param", param);
	}
	else if (criteriaType == aux::AUX_HH_BY_HANDID)
	{
		_jsonstr.compose("numRequested", numRequested);
		_jsonstr.compose("handId64", handId64);
	}
	_jsonstr.compose("password", password);
	return _buf.c_str();
}

void LobbyEtc::cli::AuxHandHistoryMetadata::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("locale", locale);
	_jparser.parseByNameThrow("timezone", timezone);
	_jparser.parseByNameThrow("criteriaType", criteriaType);
	if (criteriaType == aux::AUX_HH_BY_NUM_OF_HANDS)
	{
		_jparser.parseByNameThrow("param", param);
	}
	else if (criteriaType == aux::AUX_HH_BY_TIME)
	{
		_jparser.parseByNameThrow("param", param);
	}
	else if (criteriaType == aux::AUX_HH_BY_HANDID)
	{
		_jparser.parseByNameThrow("numRequested", numRequested);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("handId64", handId64);
	}
	_jparser.parseByNameThrow("password", password);
}

/* static */ void LobbyEtc::cli::AuxHandHistoryMetadata::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE criteriaType;
	INT32 locale; _jparser.validateByNameThrow("locale", locale);
	AtfValidator::validateIntRange(_descr, "locale", locale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 timezone; _jparser.validateByNameThrow("timezone", timezone);
	AtfValidator::validateIntRange(_descr, "timezone", timezone, eTzUTC, (eTzNumber-1), _checker, __FILE__, __LINE__);
	_jparser.validateByNameThrow("criteriaType", criteriaType);
	AtfValidator::validateIntRange(_descr, "criteriaType", criteriaType, aux::AUX_HH_BY_NUM_OF_HANDS, aux::AUX_HH_BY_HANDID, _checker, __FILE__, __LINE__);
	if (criteriaType == aux::AUX_HH_BY_NUM_OF_HANDS)
	{
		UINT64 param; _jparser.validateByNameThrow("param", param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, AUX_HH_MAX_HANDS_ALLOWED, _checker, __FILE__, __LINE__);
	}
	else if (criteriaType == aux::AUX_HH_BY_TIME)
	{
		UINT64 param; _jparser.validateByNameThrow("param", param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, 604800, _checker, __FILE__, __LINE__);
	}
	else if (criteriaType == aux::AUX_HH_BY_HANDID)
	{
		UINT32 numRequested; _jparser.validateByNameThrow("numRequested", numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 1, _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT64 handId64; _jparser.validateByNameThrow("handId64", handId64);
		AtfValidator::validateUint(_descr, "handId64", handId64, _checker, __FILE__, __LINE__);
	}
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::AuxHandHistoryMetadata::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	BYTE criteriaType;
	INT32 locale; _parser.parseINT32(locale);
	AtfValidator::validateIntRange(_descr, "locale", locale, LOCALE_DEFAULT, MAX_LOCALES, _checker, __FILE__, __LINE__);
	UINT32 timezone; _parser.parseUINT32(timezone);
	AtfValidator::validateIntRange(_descr, "timezone", timezone, eTzUTC, (eTzNumber-1), _checker, __FILE__, __LINE__);
	_parser.parseBYTE(criteriaType);
	AtfValidator::validateIntRange(_descr, "criteriaType", criteriaType, aux::AUX_HH_BY_NUM_OF_HANDS, aux::AUX_HH_BY_HANDID, _checker, __FILE__, __LINE__);
	if (criteriaType == aux::AUX_HH_BY_NUM_OF_HANDS)
	{
		UINT64 param; _parser.parseUINT64(param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, AUX_HH_MAX_HANDS_ALLOWED, _checker, __FILE__, __LINE__);
	}
	else if (criteriaType == aux::AUX_HH_BY_TIME)
	{
		UINT64 param; _parser.parseUINT64(param);
		AtfValidator::validateUintRange(_descr, "param", param, 1, 604800, _checker, __FILE__, __LINE__);
	}
	else if (criteriaType == aux::AUX_HH_BY_HANDID)
	{
		UINT32 numRequested; _parser.parseUINT32(numRequested);
		AtfValidator::validateIntRange(_descr, "numRequested", numRequested, 1, 1, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 handId64; _parser.parseUINT64(handId64);
		AtfValidator::validateUint(_descr, "handId64", handId64, _checker, __FILE__, __LINE__);
	}
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2(Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2&& _o)
	: metadata(std::move(_o.metadata))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2& LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::operator=(Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2&& _o)
{
	if(this != &_o)
	{
		metadata = std::move(_o.metadata);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::clear()
{
	metadata.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::equals(const Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2& _o) const
{
	return metadata.equals(_o.metadata);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2).append(")");
	_buf.append(',');
	_buf.append("metadata=");
	metadata.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	metadata.toXmlString("metadata", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< PlayingHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	metadata.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::parseMsg(CommMsgParser& _parser)
{
	metadata.parseMsg(_parser);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("metadata", metadata);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PlayingHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	PlayingHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY(Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::operator=(Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::equals(const Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT(Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT&& _o)
	: reqType(std::move(_o.reqType))
	, status(std::move(_o.status))
	, metadata(std::move(_o.metadata))
	, hhMetadata(std::move(_o.hhMetadata))
	, auxHhMetadata(std::move(_o.auxHhMetadata))
	, uri(std::move(_o.uri))
	, deliveryMethod(std::move(_o.deliveryMethod))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT& LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::operator=(Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT&& _o)
{
	if(this != &_o)
	{
		reqType = std::move(_o.reqType);
		status = std::move(_o.status);
		metadata = std::move(_o.metadata);
		hhMetadata = std::move(_o.hhMetadata);
		auxHhMetadata = std::move(_o.auxHhMetadata);
		uri = std::move(_o.uri);
		deliveryMethod = std::move(_o.deliveryMethod);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::clear()
{
	reqType = 0;
	status = 0;
	metadata.clear();
	hhMetadata.clear();
	auxHhMetadata.clear();
	uri.clear();
	deliveryMethod = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::equals(const Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT& _o) const
{
	return reqType == _o.reqType &&
		status == _o.status &&
		metadata.equals(_o.metadata) &&
		hhMetadata.equals(_o.hhMetadata) &&
		auxHhMetadata.equals(_o.auxHhMetadata) &&
		Atf::atfPStringEquals(uri, _o.uri) &&
		deliveryMethod == _o.deliveryMethod;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT).append(")");
	_buf.append(',');
	_buf.append("reqType=");
	_buf.appendInt(reqType);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendInt(status);
	if (reqType == 1)
	{
		_buf.append(',');
		_buf.append("metadata=");
		metadata.toTraceString(_buf);
	}
	else if (reqType == 2)
	{
		_buf.append(',');
		_buf.append("hhMetadata=");
		hhMetadata.toTraceString(_buf);
	}
	else if (reqType == 3)
	{
		_buf.append(',');
		_buf.append("auxHhMetadata=");
		auxHhMetadata.toTraceString(_buf);
	}
	_buf.append(',');
	_buf.append("uri=");
	_buf.append(uri);
	_buf.append(',');
	_buf.append("deliveryMethod=");
	_buf.appendInt(deliveryMethod);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("reqType", reqType, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	if (reqType == 1)
	{
		metadata.toXmlString("metadata", _buf);
	}
	else if (reqType == 2)
	{
		hhMetadata.toXmlString("hhMetadata", _buf);
	}
	else if (reqType == 3)
	{
		auxHhMetadata.toXmlString("auxHhMetadata", _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("uri", uri, _buf);
	Atf::XmlElement::encodeAsXmlElement("deliveryMethod", deliveryMethod, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("reqType"))
			{
				reqType = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("status"))
			{
				status = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< PlayingHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else if (_element.equals("hhMetadata"))
			{
				if(!Atf::AtfTempl< HandHistoryMetadata >::FromXmlString(_value, hhMetadata)) return false;
			}
			else if (_element.equals("auxHhMetadata"))
			{
				if(!Atf::AtfTempl< AuxHandHistoryMetadata >::FromXmlString(_value, auxHhMetadata)) return false;
			}
			else if (_element.equals("uri"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, uri)) return false;
			}
			else if (_element.equals("deliveryMethod"))
			{
				deliveryMethod = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(reqType);
	_msg.composeINT32(status);
	if (reqType == 1)
	{
		metadata.composeMsg(_msg, _ignoreJSON);
	}
	else if (reqType == 2)
	{
		hhMetadata.composeMsg(_msg, _ignoreJSON);
	}
	else if (reqType == 3)
	{
		auxHhMetadata.composeMsg(_msg, _ignoreJSON);
	}
	_msg.composeString(uri);
	_msg.composeINT32(deliveryMethod);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(reqType);
	_parser.parseINT32(status);
	if (reqType == 1)
	{
		metadata.parseMsg(_parser);
	}
	else if (reqType == 2)
	{
		hhMetadata.parseMsg(_parser);
	}
	else if (reqType == 3)
	{
		auxHhMetadata.parseMsg(_parser);
	}
	_parser.parseStringP(uri);
	_parser.parseINT32(deliveryMethod);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("reqType", reqType);
	_jsonstr.compose("status", status);
	if (reqType == 1)
	{
		_jsonstr.compose("metadata", metadata);
	}
	else if (reqType == 2)
	{
		_jsonstr.compose("hhMetadata", hhMetadata);
	}
	else if (reqType == 3)
	{
		_jsonstr.compose("auxHhMetadata", auxHhMetadata);
	}
	_jsonstr.compose("uri", uri);
	_jsonstr.compose("deliveryMethod", deliveryMethod);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("reqType", reqType);
	_jparser.parseByNameThrow("status", status);
	if (reqType == 1)
	{
		_jparser.parseByNameThrow("metadata", metadata);
	}
	else if (reqType == 2)
	{
		_jparser.parseByNameThrow("hhMetadata", hhMetadata);
	}
	else if (reqType == 3)
	{
		_jparser.parseByNameThrow("auxHhMetadata", auxHhMetadata);
	}
	_jparser.parseByNameThrow("uri", uri);
	_jparser.parseByNameThrow("deliveryMethod", deliveryMethod);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 reqType = 0;
	_jparser.validateByNameThrow("reqType", reqType);
	AtfValidator::validateInt(_descr, "reqType", reqType, _checker, __FILE__, __LINE__);
	INT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	if (reqType == 1)
	{
		PlayingHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
	}
	else if (reqType == 2)
	{
		HandHistoryMetadata hhMetadata; _jparser.validateByNameThrow("hhMetadata", hhMetadata);
	}
	else if (reqType == 3)
	{
		AuxHandHistoryMetadata auxHhMetadata; _jparser.validateByNameThrow("auxHhMetadata", auxHhMetadata);
	}
	PString uri; _jparser.validateByNameThrow("uri", uri);
	AtfValidator::validateInt(_descr, "uri", uri.length(), _checker, __FILE__, __LINE__);
	INT32 deliveryMethod; _jparser.validateByNameThrow("deliveryMethod", deliveryMethod);
	AtfValidator::validateInt(_descr, "deliveryMethod", deliveryMethod, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT32 reqType = 0;
	_parser.parseINT32(reqType);
	AtfValidator::validateInt(_descr, "reqType", reqType, _checker, __FILE__, __LINE__);
	INT32 status; _parser.parseINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	if (reqType == 1)
	{
		PString _descbuf;
		PlayingHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
	}
	else if (reqType == 2)
	{
		PString _descbuf;
		HandHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("hhMetadata"), _fieldsWithUnparsedContent);
	}
	else if (reqType == 3)
	{
		PString _descbuf;
		AuxHandHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("auxHhMetadata"), _fieldsWithUnparsedContent);
	}
	_parser.parseStringN(_dummy, 0, "uri"); size_t szUri = strlen(_dummy);
	AtfValidator::validateInt(_descr, "uri", szUri, _checker, __FILE__, __LINE__);
	INT32 deliveryMethod; _parser.parseINT32(deliveryMethod);
	AtfValidator::validateInt(_descr, "deliveryMethod", deliveryMethod, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::equals(const Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY(Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY&& _o)
	: err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
	, status(std::move(_o.status))
	, metadata(std::move(_o.metadata))
	, uri(std::move(_o.uri))
	, showNudge(std::move(_o.showNudge))
	, deliveryMethod(std::move(_o.deliveryMethod))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY&& _o)
{
	if(this != &_o)
	{
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
		status = std::move(_o.status);
		metadata = std::move(_o.metadata);
		uri = std::move(_o.uri);
		showNudge = std::move(_o.showNudge);
		deliveryMethod = std::move(_o.deliveryMethod);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::clear()
{
	err = 0;
	errDescr.clear();
	status = 0;
	metadata.clear();
	uri.clear();
	showNudge = false;
	deliveryMethod = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY& _o) const
{
	return err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		status == _o.status &&
		metadata.equals(_o.metadata) &&
		Atf::atfPStringEquals(uri, _o.uri) &&
		showNudge == _o.showNudge &&
		deliveryMethod == _o.deliveryMethod;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY).append(")");
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendInt(status);
		_buf.append(',');
		_buf.append("metadata=");
		metadata.toTraceString(_buf);
		_buf.append(',');
		_buf.append("uri=");
		_buf.append(uri);
		_buf.append(',');
		_buf.append("showNudge=");
		_buf.appendUint(showNudge);
		_buf.append(',');
		_buf.append("deliveryMethod=");
		_buf.appendInt(deliveryMethod);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		metadata.toXmlString("metadata", _buf);
		Atf::XmlElement::encodeAsXmlElement("uri", uri, _buf);
		Atf::XmlElement::encodeAsXmlElement("showNudge", showNudge, _buf);
		Atf::XmlElement::encodeAsXmlElement("deliveryMethod", deliveryMethod, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("status"))
			{
				status = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< PlayingHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else if (_element.equals("uri"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, uri)) return false;
			}
			else if (_element.equals("showNudge"))
			{
				showNudge = (*_value.ptr() == '1');
			}
			else if (_element.equals("deliveryMethod"))
			{
				deliveryMethod = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(status);
		metadata.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(uri);
		_msg.composeBOOL(showNudge);
		_msg.composeINT32(deliveryMethod);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(status);
		metadata.parseMsg(_parser);
		_parser.parseStringP(uri);
		_parser.parseBOOL(showNudge);
		_parser.parseINT32(deliveryMethod);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("status", status);
		_jsonstr.compose("metadata", metadata);
		_jsonstr.compose("uri", uri);
		_jsonstr.compose("showNudge", showNudge);
		_jsonstr.compose("deliveryMethod", deliveryMethod);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("metadata", metadata);
		_jparser.parseByNameThrow("uri", uri);
		_jparser.parseByNameThrow("showNudge", showNudge);
		_jparser.parseByNameThrow("deliveryMethod", deliveryMethod);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		PlayingHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
		PString uri; _jparser.validateByNameThrow("uri", uri);
		AtfValidator::validateInt(_descr, "uri", uri.length(), _checker, __FILE__, __LINE__);
		bool showNudge; _jparser.validateByNameThrow("showNudge", showNudge);
		AtfValidator::validateInt(_descr, "showNudge", showNudge, _checker, __FILE__, __LINE__);
		INT32 deliveryMethod; _jparser.validateByNameThrow("deliveryMethod", deliveryMethod);
		AtfValidator::validateInt(_descr, "deliveryMethod", deliveryMethod, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _parser.parseINT32(status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		PString _descbuf;
		PlayingHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "uri"); size_t szUri = strlen(_dummy);
		AtfValidator::validateInt(_descr, "uri", szUri, _checker, __FILE__, __LINE__);
		bool showNudge; _parser.parseBOOL(showNudge);
		AtfValidator::validateInt(_descr, "showNudge", showNudge, _checker, __FILE__, __LINE__);
		INT32 deliveryMethod; _parser.parseINT32(deliveryMethod);
		AtfValidator::validateInt(_descr, "deliveryMethod", deliveryMethod, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE(Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE&& _o)
	: metadata(std::move(_o.metadata))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE& LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::operator=(Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE&& _o)
{
	if(this != &_o)
	{
		metadata = std::move(_o.metadata);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::clear()
{
	metadata.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::equals(const Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE& _o) const
{
	return metadata.equals(_o.metadata);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE).append(")");
	_buf.append(',');
	_buf.append("metadata=");
	metadata.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	metadata.toXmlString("metadata", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< PlayingHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	metadata.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::parseMsg(CommMsgParser& _parser)
{
	metadata.parseMsg(_parser);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("metadata", metadata);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PlayingHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	PlayingHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY(Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY&& _o)
	: err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::operator=(Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY&& _o)
{
	if(this != &_o)
	{
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::clear()
{
	err = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::equals(const Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY& _o) const
{
	return err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST(Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST&& _o)
	: metadata(std::move(_o.metadata))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::operator=(Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST&& _o)
{
	if(this != &_o)
	{
		metadata = std::move(_o.metadata);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::clear()
{
	metadata.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::equals(const Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST& _o) const
{
	return metadata.equals(_o.metadata);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST).append(")");
	_buf.append(',');
	_buf.append("metadata=");
	metadata.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	metadata.toXmlString("metadata", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< HandHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	metadata.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::parseMsg(CommMsgParser& _parser)
{
	metadata.parseMsg(_parser);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("metadata", metadata);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	HandHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	HandHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY(Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::operator=(Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::equals(const Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::equals(const Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY(Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY&& _o)
	: err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
	, status(std::move(_o.status))
	, metadata(std::move(_o.metadata))
	, uri(std::move(_o.uri))
	, showNudge(std::move(_o.showNudge))
	, deliveryMethod(std::move(_o.deliveryMethod))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY&& _o)
{
	if(this != &_o)
	{
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
		status = std::move(_o.status);
		metadata = std::move(_o.metadata);
		uri = std::move(_o.uri);
		showNudge = std::move(_o.showNudge);
		deliveryMethod = std::move(_o.deliveryMethod);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::clear()
{
	err = 0;
	errDescr.clear();
	status = 0;
	metadata.clear();
	uri.clear();
	showNudge = false;
	deliveryMethod = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY& _o) const
{
	return err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		status == _o.status &&
		metadata.equals(_o.metadata) &&
		Atf::atfPStringEquals(uri, _o.uri) &&
		showNudge == _o.showNudge &&
		deliveryMethod == _o.deliveryMethod;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY).append(")");
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendInt(status);
		_buf.append(',');
		_buf.append("metadata=");
		metadata.toTraceString(_buf);
		_buf.append(',');
		_buf.append("uri=");
		_buf.append(uri);
		_buf.append(',');
		_buf.append("showNudge=");
		_buf.appendUint(showNudge);
		_buf.append(',');
		_buf.append("deliveryMethod=");
		_buf.appendInt(deliveryMethod);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		metadata.toXmlString("metadata", _buf);
		Atf::XmlElement::encodeAsXmlElement("uri", uri, _buf);
		Atf::XmlElement::encodeAsXmlElement("showNudge", showNudge, _buf);
		Atf::XmlElement::encodeAsXmlElement("deliveryMethod", deliveryMethod, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("status"))
			{
				status = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< HandHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else if (_element.equals("uri"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, uri)) return false;
			}
			else if (_element.equals("showNudge"))
			{
				showNudge = (*_value.ptr() == '1');
			}
			else if (_element.equals("deliveryMethod"))
			{
				deliveryMethod = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(status);
		metadata.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(uri);
		_msg.composeBOOL(showNudge);
		_msg.composeINT32(deliveryMethod);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(status);
		metadata.parseMsg(_parser);
		_parser.parseStringP(uri);
		_parser.parseBOOL(showNudge);
		_parser.parseINT32(deliveryMethod);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("status", status);
		_jsonstr.compose("metadata", metadata);
		_jsonstr.compose("uri", uri);
		_jsonstr.compose("showNudge", showNudge);
		_jsonstr.compose("deliveryMethod", deliveryMethod);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("metadata", metadata);
		_jparser.parseByNameThrow("uri", uri);
		_jparser.parseByNameThrow("showNudge", showNudge);
		_jparser.parseByNameThrow("deliveryMethod", deliveryMethod);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		HandHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
		PString uri; _jparser.validateByNameThrow("uri", uri);
		AtfValidator::validateInt(_descr, "uri", uri.length(), _checker, __FILE__, __LINE__);
		bool showNudge; _jparser.validateByNameThrow("showNudge", showNudge);
		AtfValidator::validateInt(_descr, "showNudge", showNudge, _checker, __FILE__, __LINE__);
		INT32 deliveryMethod; _jparser.validateByNameThrow("deliveryMethod", deliveryMethod);
		AtfValidator::validateInt(_descr, "deliveryMethod", deliveryMethod, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _parser.parseINT32(status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		PString _descbuf;
		HandHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "uri"); size_t szUri = strlen(_dummy);
		AtfValidator::validateInt(_descr, "uri", szUri, _checker, __FILE__, __LINE__);
		bool showNudge; _parser.parseBOOL(showNudge);
		AtfValidator::validateInt(_descr, "showNudge", showNudge, _checker, __FILE__, __LINE__);
		INT32 deliveryMethod; _parser.parseINT32(deliveryMethod);
		AtfValidator::validateInt(_descr, "deliveryMethod", deliveryMethod, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE(Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE&& _o)
	: metadata(std::move(_o.metadata))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE& LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::operator=(Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE&& _o)
{
	if(this != &_o)
	{
		metadata = std::move(_o.metadata);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::clear()
{
	metadata.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::equals(const Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE& _o) const
{
	return metadata.equals(_o.metadata);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE).append(")");
	_buf.append(',');
	_buf.append("metadata=");
	metadata.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	metadata.toXmlString("metadata", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< HandHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	metadata.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::parseMsg(CommMsgParser& _parser)
{
	metadata.parseMsg(_parser);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("metadata", metadata);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	HandHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	HandHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY(Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY&& _o)
	: err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::operator=(Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY&& _o)
{
	if(this != &_o)
	{
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::clear()
{
	err = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::equals(const Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY& _o) const
{
	return err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::equals(const Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_PREDICTOR_GET_TICKETS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_PREDICTOR_GET_TICKETS).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_PREDICTOR_GET_TICKETS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PREDICTOR_GET_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_PREDICTOR_GET_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS(Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS&& _o)
	: err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
	, hasNudge(std::move(_o.hasNudge))
	, newTicketCount(std::move(_o.newTicketCount))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS& LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::operator=(Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS&& _o)
{
	if(this != &_o)
	{
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
		hasNudge = std::move(_o.hasNudge);
		newTicketCount = std::move(_o.newTicketCount);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::clear()
{
	err = 0;
	errDescr.clear();
	hasNudge = false;
	newTicketCount = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::equals(const Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS& _o) const
{
	return err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		hasNudge == _o.hasNudge &&
		newTicketCount == _o.newTicketCount;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS).append(")");
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("hasNudge=");
		_buf.appendUint(hasNudge);
		_buf.append(',');
		_buf.append("newTicketCount=");
		_buf.appendInt(newTicketCount);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("hasNudge", hasNudge, _buf);
		Atf::XmlElement::encodeAsXmlElement("newTicketCount", newTicketCount, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("hasNudge"))
			{
				hasNudge = (*_value.ptr() == '1');
			}
			else if (_element.equals("newTicketCount"))
			{
				newTicketCount = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(hasNudge);
		_msg.composeINT32(newTicketCount);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(hasNudge);
		_parser.parseINT32(newTicketCount);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("hasNudge", hasNudge);
		_jsonstr.compose("newTicketCount", newTicketCount);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("hasNudge", hasNudge);
		_jparser.parseByNameThrow("newTicketCount", newTicketCount);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		bool hasNudge; _jparser.validateByNameThrow("hasNudge", hasNudge);
		AtfValidator::validateInt(_descr, "hasNudge", hasNudge, _checker, __FILE__, __LINE__);
		INT32 newTicketCount; _jparser.validateByNameThrow("newTicketCount", newTicketCount);
		AtfValidator::validateInt(_descr, "newTicketCount", newTicketCount, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool hasNudge; _parser.parseBOOL(hasNudge);
		AtfValidator::validateInt(_descr, "hasNudge", hasNudge, _checker, __FILE__, __LINE__);
		INT32 newTicketCount; _parser.parseINT32(newTicketCount);
		AtfValidator::validateInt(_descr, "newTicketCount", newTicketCount, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::equals(const Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY(Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY&& _o)
	: err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
	, status(std::move(_o.status))
	, metadata(std::move(_o.metadata))
	, uri(std::move(_o.uri))
	, showNudge(std::move(_o.showNudge))
	, deliveryMethod(std::move(_o.deliveryMethod))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY&& _o)
{
	if(this != &_o)
	{
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
		status = std::move(_o.status);
		metadata = std::move(_o.metadata);
		uri = std::move(_o.uri);
		showNudge = std::move(_o.showNudge);
		deliveryMethod = std::move(_o.deliveryMethod);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::clear()
{
	err = 0;
	errDescr.clear();
	status = 0;
	metadata.clear();
	uri.clear();
	showNudge = false;
	deliveryMethod = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY& _o) const
{
	return err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		status == _o.status &&
		metadata.equals(_o.metadata) &&
		Atf::atfPStringEquals(uri, _o.uri) &&
		showNudge == _o.showNudge &&
		deliveryMethod == _o.deliveryMethod;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY).append(")");
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("status=");
		_buf.appendInt(status);
		_buf.append(',');
		_buf.append("metadata=");
		metadata.toTraceString(_buf);
		_buf.append(',');
		_buf.append("uri=");
		_buf.append(uri);
		_buf.append(',');
		_buf.append("showNudge=");
		_buf.appendUint(showNudge);
		_buf.append(',');
		_buf.append("deliveryMethod=");
		_buf.appendInt(deliveryMethod);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
		metadata.toXmlString("metadata", _buf);
		Atf::XmlElement::encodeAsXmlElement("uri", uri, _buf);
		Atf::XmlElement::encodeAsXmlElement("showNudge", showNudge, _buf);
		Atf::XmlElement::encodeAsXmlElement("deliveryMethod", deliveryMethod, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("status"))
			{
				status = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< AuxHandHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else if (_element.equals("uri"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, uri)) return false;
			}
			else if (_element.equals("showNudge"))
			{
				showNudge = (*_value.ptr() == '1');
			}
			else if (_element.equals("deliveryMethod"))
			{
				deliveryMethod = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeINT32(status);
		metadata.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(uri);
		_msg.composeBOOL(showNudge);
		_msg.composeINT32(deliveryMethod);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseINT32(status);
		metadata.parseMsg(_parser);
		_parser.parseStringP(uri);
		_parser.parseBOOL(showNudge);
		_parser.parseINT32(deliveryMethod);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("status", status);
		_jsonstr.compose("metadata", metadata);
		_jsonstr.compose("uri", uri);
		_jsonstr.compose("showNudge", showNudge);
		_jsonstr.compose("deliveryMethod", deliveryMethod);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("status", status);
		_jparser.parseByNameThrow("metadata", metadata);
		_jparser.parseByNameThrow("uri", uri);
		_jparser.parseByNameThrow("showNudge", showNudge);
		_jparser.parseByNameThrow("deliveryMethod", deliveryMethod);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _jparser.validateByNameThrow("status", status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		AuxHandHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
		PString uri; _jparser.validateByNameThrow("uri", uri);
		AtfValidator::validateInt(_descr, "uri", uri.length(), _checker, __FILE__, __LINE__);
		bool showNudge; _jparser.validateByNameThrow("showNudge", showNudge);
		AtfValidator::validateInt(_descr, "showNudge", showNudge, _checker, __FILE__, __LINE__);
		INT32 deliveryMethod; _jparser.validateByNameThrow("deliveryMethod", deliveryMethod);
		AtfValidator::validateInt(_descr, "deliveryMethod", deliveryMethod, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 status; _parser.parseINT32(status);
		AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
		PString _descbuf;
		AuxHandHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
		_parser.parseStringN(_dummy, 0, "uri"); size_t szUri = strlen(_dummy);
		AtfValidator::validateInt(_descr, "uri", szUri, _checker, __FILE__, __LINE__);
		bool showNudge; _parser.parseBOOL(showNudge);
		AtfValidator::validateInt(_descr, "showNudge", showNudge, _checker, __FILE__, __LINE__);
		INT32 deliveryMethod; _parser.parseINT32(deliveryMethod);
		AtfValidator::validateInt(_descr, "deliveryMethod", deliveryMethod, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE(Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE&& _o)
	: metadata(std::move(_o.metadata))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE& LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::operator=(Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE&& _o)
{
	if(this != &_o)
	{
		metadata = std::move(_o.metadata);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::clear()
{
	metadata.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::equals(const Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE& _o) const
{
	return metadata.equals(_o.metadata);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE).append(")");
	_buf.append(',');
	_buf.append("metadata=");
	metadata.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	metadata.toXmlString("metadata", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< AuxHandHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	metadata.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::parseMsg(CommMsgParser& _parser)
{
	metadata.parseMsg(_parser);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("metadata", metadata);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	AuxHandHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	AuxHandHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY(Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY&& _o)
	: err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::operator=(Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY&& _o)
{
	if(this != &_o)
	{
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::clear()
{
	err = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::equals(const Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY& _o) const
{
	return err == _o.err &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("err", err, _buf);
	if (err)
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("err"))
			{
				err = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("err", err);
	if (err)
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("err", err);
	if (err)
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 err = 0;
	_jparser.validateByNameThrow("err", err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST(Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST&& _o)
	: metadata(std::move(_o.metadata))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::operator=(Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST&& _o)
{
	if(this != &_o)
	{
		metadata = std::move(_o.metadata);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::clear()
{
	metadata.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::equals(const Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST& _o) const
{
	return metadata.equals(_o.metadata);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST).append(")");
	_buf.append(',');
	_buf.append("metadata=");
	metadata.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	metadata.toXmlString("metadata", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("metadata"))
			{
				if(!Atf::AtfTempl< AuxHandHistoryMetadata >::FromXmlString(_value, metadata)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	metadata.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::parseMsg(CommMsgParser& _parser)
{
	metadata.parseMsg(_parser);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("metadata", metadata);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	AuxHandHistoryMetadata metadata; _jparser.validateByNameThrow("metadata", metadata);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	AuxHandHistoryMetadata::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("metadata"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY(Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::operator=(Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::equals(const Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_TOURN_STATS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::clear()
{
	type = 0;
	tournIdOrCount = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::equals(const Protocol_MSG_LOBBYETC_CLI_TOURN_STATS& _o) const
{
	return type == _o.type &&
		tournIdOrCount == _o.tournIdOrCount;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_TOURN_STATS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_TOURN_STATS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_TOURN_STATS).append(")");
	_buf.append(',');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("tournIdOrCount=");
	_buf.appendUint(tournIdOrCount);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_TOURN_STATS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournIdOrCount", tournIdOrCount, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("type"))
			{
				type = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournIdOrCount"))
			{
				tournIdOrCount = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBYTE(type);
	_msg.composeUINT32(tournIdOrCount);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBYTE(type);
	_parser.parseUINT32(tournIdOrCount);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("tournIdOrCount", tournIdOrCount);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("tournIdOrCount", tournIdOrCount);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TOURN_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateIntRange(_descr, "type", type, TOURN_STATS_TOURN_ID, TOURN_STATS_TOURN_ID_NOSTAT, _checker, __FILE__, __LINE__);
	UINT32 tournIdOrCount; _jparser.validateByNameThrow("tournIdOrCount", tournIdOrCount);
	AtfValidator::validateInt(_descr, "tournIdOrCount", tournIdOrCount, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TOURN_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	BYTE type; _parser.parseBYTE(type);
	AtfValidator::validateIntRange(_descr, "type", type, TOURN_STATS_TOURN_ID, TOURN_STATS_TOURN_ID_NOSTAT, _checker, __FILE__, __LINE__);
	UINT32 tournIdOrCount; _parser.parseUINT32(tournIdOrCount);
	AtfValidator::validateInt(_descr, "tournIdOrCount", tournIdOrCount, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY(Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
	, email(std::move(_o.email))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
		email = std::move(_o.email);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
	email.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr) &&
		Atf::atfPStringEquals(email, _o.email);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_TOURN_STATS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_TOURN_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("email=");
		_buf.append(email);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_TOURN_STATS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("email", email, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else if (_element.equals("email"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, email)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(email);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(email);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	else
	{
		_jsonstr.compose("email", email);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
	else
	{
		_jparser.parseByNameThrow("email", email);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TOURN_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString email; _jparser.validateByNameThrow("email", email);
		AtfValidator::validateInt(_descr, "email", email.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_TOURN_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "email"); size_t szEmail = strlen(_dummy);
		AtfValidator::validateInt(_descr, "email", szEmail, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_VERIFY_PWD
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::Protocol_MSG_LOBBYETC_VERIFY_PWD()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::Protocol_MSG_LOBBYETC_VERIFY_PWD(Protocol_MSG_LOBBYETC_VERIFY_PWD&& _o)
	: pwd(std::move(_o.pwd))
	, ssn4(std::move(_o.ssn4))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD& LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::operator=(Protocol_MSG_LOBBYETC_VERIFY_PWD&& _o)
{
	if(this != &_o)
	{
		pwd = std::move(_o.pwd);
		ssn4 = std::move(_o.ssn4);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::clear()
{
	pwd.clear();
	ssn4.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::equals(const Protocol_MSG_LOBBYETC_VERIFY_PWD& _o) const
{
	return Atf::atfPStringEquals(pwd, _o.pwd) &&
		Atf::atfPStringEquals(ssn4, _o.ssn4);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_VERIFY_PWD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_VERIFY_PWD*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_VERIFY_PWD).append(")");
	_buf.append(',');
	_buf.append("pwd=");
	_buf.append("...");
	_buf.append(',');
	_buf.append("ssn4=");
	_buf.append("...");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_VERIFY_PWD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("pwd", pwd, _buf);
	Atf::XmlElement::encodeAsXmlElement("ssn4", ssn4, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("pwd"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, pwd)) return false;
			}
			else if (_element.equals("ssn4"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, ssn4)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(pwd);
	_msg.composeString(ssn4);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(pwd);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(ssn4);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("pwd", pwd);
	_jsonstr.compose("ssn4", ssn4);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("pwd", pwd);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("ssn4", ssn4);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_VERIFY_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString pwd; _jparser.validateByNameThrow("pwd", pwd);
	AtfValidator::validateIntMax(_descr, "pwd", pwd.length(), 1000, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString ssn4; _jparser.validateByNameThrow("ssn4", ssn4);
	AtfValidator::validateIntMax(_descr, "ssn4", ssn4.length(), 4, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_VERIFY_PWD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "pwd"); size_t szPwd = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "pwd", szPwd, 1000, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "ssn4"); size_t szSsn4 = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "ssn4", szSsn4, 4, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY(Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescr(std::move(_o.errDescr))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::operator=(Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::clear()
{
	errCode = 0;
	errDescr.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::equals(const Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDescr, _o.errDescr);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_VERIFY_PWD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_VERIFY_PWD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode )
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_VERIFY_PWD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDescr", errDescr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDescr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDescr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode )
	{
		_msg.composeString(errDescr);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode )
	{
		_parser.parseStringP(errDescr);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode )
	{
		_jsonstr.compose("errDescr", errDescr);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode )
	{
		_jparser.parseByNameThrow("errDescr", errDescr);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_VERIFY_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		PString errDescr; _jparser.validateByNameThrow("errDescr", errDescr);
		AtfValidator::validateInt(_descr, "errDescr", errDescr.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_VERIFY_PWD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT&& _o)
	: notUsedStr(std::move(_o.notUsedStr))
	, startDate(std::move(_o.startDate))
	, endDate(std::move(_o.endDate))
	, password(std::move(_o.password))
	, reportFormat(std::move(_o.reportFormat))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT& LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::operator=(Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT&& _o)
{
	if(this != &_o)
	{
		notUsedStr = std::move(_o.notUsedStr);
		startDate = std::move(_o.startDate);
		endDate = std::move(_o.endDate);
		password = std::move(_o.password);
		reportFormat = std::move(_o.reportFormat);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::clear()
{
	notUsedStr.clear();
	startDate.setNull();
	endDate.setNull();
	password.clear();
	reportFormat = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::equals(const Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT& _o) const
{
	return Atf::atfPStringEquals(notUsedStr, _o.notUsedStr) &&
		startDate.equals(_o.startDate) &&
		endDate.equals(_o.endDate) &&
		Atf::atfPStringEquals(password, _o.password) &&
		reportFormat == _o.reportFormat;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT).append(")");
	_buf.append(',');
	_buf.append("notUsedStr=");
	_buf.append(notUsedStr);
	_buf.append(',');
	_buf.append("startDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, startDate);
	_buf.append(',');
	_buf.append("endDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	_buf.append(',');
	_buf.append("password=");
	_buf.append("...");
	_buf.append(',');
	_buf.append("reportFormat=");
	_buf.appendUint(reportFormat);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("notUsedStr", notUsedStr, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "startDate", startDate);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	Atf::XmlElement::encodeAsXmlElement("reportFormat", reportFormat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("notUsedStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedStr)) return false;
			}
			else if (_element.equals("startDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, startDate);
			}
			else if (_element.equals("endDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else if (_element.equals("reportFormat"))
			{
				reportFormat = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(notUsedStr);
	_msg.composeSrvDate(startDate);
	_msg.composeSrvDate(endDate);
	_msg.composeString(password);
	_msg.composeUINT32(reportFormat);
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(notUsedStr);
	_parser.parseSrvDate(startDate);
	_parser.parseSrvDate(endDate);
	_parser.parseStringP(password);
	_parser.parseUINT32(reportFormat);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("notUsedStr", notUsedStr);
	_jsonstr.compose("startDate", startDate);
	_jsonstr.compose("endDate", endDate);
	_jsonstr.compose("password", password);
	_jsonstr.compose("reportFormat", reportFormat);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("notUsedStr", notUsedStr);
	_jparser.parseByNameThrow("startDate", startDate);
	_jparser.parseByNameThrow("endDate", endDate);
	_jparser.parseByNameThrow("password", password);
	_jparser.parseByNameThrow("reportFormat", reportFormat);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString notUsedStr; _jparser.validateByNameThrow("notUsedStr", notUsedStr);
	AtfValidator::validateIntMax(_descr, "notUsedStr", notUsedStr.length(), 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _jparser.validateByNameThrow("startDate", startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 1000, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _jparser.validateByNameThrow("reportFormat", reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "notUsedStr"); size_t szNotUsedStr = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedStr", szNotUsedStr, 20, _checker, __FILE__, __LINE__);
	SrvDate startDate; _parser.parseSrvDate(startDate);
	AtfValidator::validateSrvDateTime(_descr, "startDate", startDate, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 1000, _checker, __FILE__, __LINE__);
	UINT32 reportFormat; _parser.parseUINT32(reportFormat);
	AtfValidator::validateIntMax(_descr, "reportFormat", reportFormat, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::clear()
{
	errCode = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::equals(const Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM& _o) const
{
	return errCode == _o.errCode;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF(Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF&& _o)
	: sessionDurationSec(std::move(_o.sessionDurationSec))
	, sessionWinLoss(std::move(_o.sessionWinLoss))
	, currency(std::move(_o.currency))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::operator=(Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF&& _o)
{
	if(this != &_o)
	{
		sessionDurationSec = std::move(_o.sessionDurationSec);
		sessionWinLoss = std::move(_o.sessionWinLoss);
		currency = std::move(_o.currency);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::clear()
{
	sessionDurationSec = 0;
	sessionWinLoss = 0;
	currency.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::equals(const Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF& _o) const
{
	return sessionDurationSec == _o.sessionDurationSec &&
		sessionWinLoss == _o.sessionWinLoss &&
		Atf::atfPStringEquals(currency, _o.currency);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_SE_SESSION_NOTIF != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_SE_SESSION_NOTIF).append(")");
	_buf.append(',');
	_buf.append("sessionDurationSec=");
	_buf.appendUint(sessionDurationSec);
	_buf.append(',');
	_buf.append("sessionWinLoss=");
	_buf.appendInt64(sessionWinLoss);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_SE_SESSION_NOTIF).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("sessionDurationSec", sessionDurationSec, _buf);
	Atf::XmlElement::encodeAsXmlElement("sessionWinLoss", sessionWinLoss, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("sessionDurationSec"))
			{
				sessionDurationSec = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("sessionWinLoss"))
			{
				sessionWinLoss = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(sessionDurationSec);
	_msg.composeINT64(sessionWinLoss);
	_msg.composeString(currency);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(sessionDurationSec);
	_parser.parseINT64(sessionWinLoss);
	_parser.parseStringP(currency);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("sessionDurationSec", sessionDurationSec);
	_jsonstr.compose("sessionWinLoss", sessionWinLoss);
	_jsonstr.compose("currency", currency);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("sessionDurationSec", sessionDurationSec);
	_jparser.parseByNameThrow("sessionWinLoss", sessionWinLoss);
	_jparser.parseByNameThrow("currency", currency);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SE_SESSION_NOTIF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 sessionDurationSec; _jparser.validateByNameThrow("sessionDurationSec", sessionDurationSec);
	AtfValidator::validateInt(_descr, "sessionDurationSec", sessionDurationSec, _checker, __FILE__, __LINE__);
	INT64 sessionWinLoss; _jparser.validateByNameThrow("sessionWinLoss", sessionWinLoss);
	AtfValidator::validateInt(_descr, "sessionWinLoss", sessionWinLoss, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SE_SESSION_NOTIF";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 sessionDurationSec; _parser.parseUINT32(sessionDurationSec);
	AtfValidator::validateInt(_descr, "sessionDurationSec", sessionDurationSec, _checker, __FILE__, __LINE__);
	INT64 sessionWinLoss; _parser.parseINT64(sessionWinLoss);
	AtfValidator::validateInt(_descr, "sessionWinLoss", sessionWinLoss, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::equals(const Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY(Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, intervalMin(std::move(_o.intervalMin))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		intervalMin = std::move(_o.intervalMin);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	intervalMin = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		intervalMin == _o.intervalMin;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("intervalMin=");
		_buf.appendInt(intervalMin);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("intervalMin", intervalMin, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("intervalMin"))
			{
				intervalMin = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeINT32(intervalMin);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseINT32(intervalMin);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("intervalMin", intervalMin);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("intervalMin", intervalMin);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 intervalMin; _jparser.validateByNameThrow("intervalMin", intervalMin);
		AtfValidator::validateInt(_descr, "intervalMin", intervalMin, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 intervalMin; _parser.parseINT32(intervalMin);
		AtfValidator::validateInt(_descr, "intervalMin", intervalMin, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::clear()
{
	intervalMin = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::equals(const Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL& _o) const
{
	return intervalMin == _o.intervalMin;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL).append(")");
	_buf.append(',');
	_buf.append("intervalMin=");
	_buf.appendInt(intervalMin);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("intervalMin", intervalMin, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("intervalMin"))
			{
				intervalMin = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT32(intervalMin);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(intervalMin);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("intervalMin", intervalMin);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("intervalMin", intervalMin);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT32 intervalMin; _jparser.validateByNameThrow("intervalMin", intervalMin);
	AtfValidator::validateIntRange(_descr, "intervalMin", intervalMin, 10, 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 intervalMin; _parser.parseINT32(intervalMin);
	AtfValidator::validateIntRange(_descr, "intervalMin", intervalMin, 10, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY(Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, intervalMin(std::move(_o.intervalMin))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		intervalMin = std::move(_o.intervalMin);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	intervalMin = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		intervalMin == _o.intervalMin;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("intervalMin=");
		_buf.appendInt(intervalMin);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("intervalMin", intervalMin, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("intervalMin"))
			{
				intervalMin = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeINT32(intervalMin);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseINT32(intervalMin);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("intervalMin", intervalMin);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("intervalMin", intervalMin);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 intervalMin; _jparser.validateByNameThrow("intervalMin", intervalMin);
		AtfValidator::validateInt(_descr, "intervalMin", intervalMin, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 intervalMin; _parser.parseINT32(intervalMin);
		AtfValidator::validateInt(_descr, "intervalMin", intervalMin, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::equals(const Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY(Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, prevLoginTime(std::move(_o.prevLoginTime))
	, winLoss(std::move(_o.winLoss))
	, currency(std::move(_o.currency))
	, isFirstLoginSession(std::move(_o.isFirstLoginSession))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		prevLoginTime = std::move(_o.prevLoginTime);
		winLoss = std::move(_o.winLoss);
		currency = std::move(_o.currency);
		isFirstLoginSession = std::move(_o.isFirstLoginSession);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	prevLoginTime.setNull();
	winLoss = 0;
	currency.clear();
	isFirstLoginSession = false;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		prevLoginTime.equals(_o.prevLoginTime) &&
		winLoss == _o.winLoss &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		isFirstLoginSession == _o.isFirstLoginSession;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("prevLoginTime=");
		Atf::AtfTempl<SrvTime>::ToTraceString(_buf, prevLoginTime);
		_buf.append(',');
		_buf.append("winLoss=");
		_buf.appendInt64(winLoss);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("isFirstLoginSession=");
		_buf.appendUint(isFirstLoginSession);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "prevLoginTime", prevLoginTime);
		Atf::XmlElement::encodeAsXmlElement("winLoss", winLoss, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("isFirstLoginSession", isFirstLoginSession, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("prevLoginTime"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, prevLoginTime);
			}
			else if (_element.equals("winLoss"))
			{
				winLoss = (INT64)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("isFirstLoginSession"))
			{
				isFirstLoginSession = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeSrvTime(prevLoginTime);
		_msg.composeINT64(winLoss);
		_msg.composeString(currency);
		_msg.composeBOOL(isFirstLoginSession);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseSrvTime(prevLoginTime);
		_parser.parseINT64(winLoss);
		_parser.parseStringP(currency);
		_parser.parseBOOL(isFirstLoginSession);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("prevLoginTime", prevLoginTime);
		_jsonstr.compose("winLoss", winLoss);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("isFirstLoginSession", isFirstLoginSession);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("prevLoginTime", prevLoginTime);
		_jparser.parseByNameThrow("winLoss", winLoss);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("isFirstLoginSession", isFirstLoginSession);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		SrvTime prevLoginTime; _jparser.validateByNameThrow("prevLoginTime", prevLoginTime);
		AtfValidator::validateSrvDateTime(_descr, "prevLoginTime", prevLoginTime, _checker, __FILE__, __LINE__);
		INT64 winLoss; _jparser.validateByNameThrow("winLoss", winLoss);
		AtfValidator::validateInt(_descr, "winLoss", winLoss, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		bool isFirstLoginSession; _jparser.validateByNameThrow("isFirstLoginSession", isFirstLoginSession);
		AtfValidator::validateInt(_descr, "isFirstLoginSession", isFirstLoginSession, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		SrvTime prevLoginTime; _parser.parseSrvTime(prevLoginTime);
		AtfValidator::validateSrvDateTime(_descr, "prevLoginTime", prevLoginTime, _checker, __FILE__, __LINE__);
		INT64 winLoss; _parser.parseINT64(winLoss);
		AtfValidator::validateInt(_descr, "winLoss", winLoss, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool isFirstLoginSession; _parser.parseBOOL(isFirstLoginSession);
		AtfValidator::validateInt(_descr, "isFirstLoginSession", isFirstLoginSession, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN(Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN&& _o)
	: appsFlyerId(std::move(_o.appsFlyerId))
	, mobileAppId(std::move(_o.mobileAppId))
	, lat(std::move(_o.lat))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN& LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::operator=(Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN&& _o)
{
	if(this != &_o)
	{
		appsFlyerId = std::move(_o.appsFlyerId);
		mobileAppId = std::move(_o.mobileAppId);
		lat = std::move(_o.lat);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::clear()
{
	appsFlyerId.clear();
	mobileAppId.clear();
	lat = false;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::equals(const Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN& _o) const
{
	return Atf::atfPStringEquals(appsFlyerId, _o.appsFlyerId) &&
		Atf::atfPStringEquals(mobileAppId, _o.mobileAppId) &&
		lat == _o.lat;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_SIGNAL_EVENT_LOGIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_SIGNAL_EVENT_LOGIN).append(")");
	_buf.append(',');
	_buf.append("appsFlyerId=");
	_buf.append(appsFlyerId);
	_buf.append(',');
	_buf.append("mobileAppId=");
	_buf.append(mobileAppId);
	_buf.append(',');
	_buf.append("lat=");
	_buf.appendUint(lat);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_SIGNAL_EVENT_LOGIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("appsFlyerId", appsFlyerId, _buf);
	Atf::XmlElement::encodeAsXmlElement("mobileAppId", mobileAppId, _buf);
	Atf::XmlElement::encodeAsXmlElement("lat", lat, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("appsFlyerId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, appsFlyerId)) return false;
			}
			else if (_element.equals("mobileAppId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, mobileAppId)) return false;
			}
			else if (_element.equals("lat"))
			{
				lat = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(appsFlyerId);
	_msg.composeString(mobileAppId);
	_msg.composeBOOL(lat);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(appsFlyerId);
	_parser.parseStringP(mobileAppId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(lat);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("appsFlyerId", appsFlyerId);
	_jsonstr.compose("mobileAppId", mobileAppId);
	_jsonstr.compose("lat", lat);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("appsFlyerId", appsFlyerId);
	_jparser.parseByNameThrow("mobileAppId", mobileAppId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("lat", lat);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SIGNAL_EVENT_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString appsFlyerId; _jparser.validateByNameThrow("appsFlyerId", appsFlyerId);
	AtfValidator::validateIntMax(_descr, "appsFlyerId", appsFlyerId.length(), 100, _checker, __FILE__, __LINE__);
	PString mobileAppId; _jparser.validateByNameThrow("mobileAppId", mobileAppId);
	AtfValidator::validateIntMax(_descr, "mobileAppId", mobileAppId.length(), 256, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool lat; _jparser.validateByNameThrow("lat", lat);
	AtfValidator::validateInt(_descr, "lat", lat, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SIGNAL_EVENT_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "appsFlyerId"); size_t szAppsFlyerId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "appsFlyerId", szAppsFlyerId, 100, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "mobileAppId"); size_t szMobileAppId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "mobileAppId", szMobileAppId, 256, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool lat; _parser.parseBOOL(lat);
	AtfValidator::validateInt(_descr, "lat", lat, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY(Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::operator=(Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::equals(const Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode != 0)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if (errCode != 0)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if (errCode != 0)
	{
		_msg.composeString(errString);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode != 0)
	{
		_parser.parseStringP(errString);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if (errCode != 0)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if (errCode != 0)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode != 0)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS()
{
	clear();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::clear()
{
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::equals(const Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS& _o) const
{
	return true;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_MY_STARS_COUNTERS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_MY_STARS_COUNTERS).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_MY_STARS_COUNTERS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_MY_STARS_COUNTERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_MY_STARS_COUNTERS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY(Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, freeSpinCounter(std::move(_o.freeSpinCounter))
	, instantBonusCounter(std::move(_o.instantBonusCounter))
	, freeBetCounter(std::move(_o.freeBetCounter))
	, prizeGameCounter(std::move(_o.prizeGameCounter))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY& LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::operator=(Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		freeSpinCounter = std::move(_o.freeSpinCounter);
		instantBonusCounter = std::move(_o.instantBonusCounter);
		freeBetCounter = std::move(_o.freeBetCounter);
		prizeGameCounter = std::move(_o.prizeGameCounter);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	freeSpinCounter = 0;
	instantBonusCounter = 0;
	freeBetCounter = 0;
	prizeGameCounter = 0;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::equals(const Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		freeSpinCounter == _o.freeSpinCounter &&
		instantBonusCounter == _o.instantBonusCounter &&
		freeBetCounter == _o.freeBetCounter &&
		prizeGameCounter == _o.prizeGameCounter;
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if( errCode != 0 )
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("freeSpinCounter=");
		_buf.appendInt(freeSpinCounter);
		_buf.append(',');
		_buf.append("instantBonusCounter=");
		_buf.appendInt(instantBonusCounter);
		_buf.append(',');
		_buf.append("freeBetCounter=");
		_buf.appendInt(freeBetCounter);
		_buf.append(',');
		_buf.append("prizeGameCounter=");
		_buf.appendInt(prizeGameCounter);
	}
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if( errCode != 0 )
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("freeSpinCounter", freeSpinCounter, _buf);
		Atf::XmlElement::encodeAsXmlElement("instantBonusCounter", instantBonusCounter, _buf);
		Atf::XmlElement::encodeAsXmlElement("freeBetCounter", freeBetCounter, _buf);
		Atf::XmlElement::encodeAsXmlElement("prizeGameCounter", prizeGameCounter, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("freeSpinCounter"))
			{
				freeSpinCounter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("instantBonusCounter"))
			{
				instantBonusCounter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("freeBetCounter"))
			{
				freeBetCounter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("prizeGameCounter"))
			{
				prizeGameCounter = (INT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if( errCode != 0 )
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeINT32(freeSpinCounter);
		_msg.composeINT32(instantBonusCounter);
		_msg.composeINT32(freeBetCounter);
		_msg.composeINT32(prizeGameCounter);
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if( errCode != 0 )
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseINT32(freeSpinCounter);
		_parser.parseINT32(instantBonusCounter);
		_parser.parseINT32(freeBetCounter);
		_parser.parseINT32(prizeGameCounter);
	}
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if( errCode != 0 )
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("freeSpinCounter", freeSpinCounter);
		_jsonstr.compose("instantBonusCounter", instantBonusCounter);
		_jsonstr.compose("freeBetCounter", freeBetCounter);
		_jsonstr.compose("prizeGameCounter", prizeGameCounter);
	}
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if( errCode != 0 )
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("freeSpinCounter", freeSpinCounter);
		_jparser.parseByNameThrow("instantBonusCounter", instantBonusCounter);
		_jparser.parseByNameThrow("freeBetCounter", freeBetCounter);
		_jparser.parseByNameThrow("prizeGameCounter", prizeGameCounter);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateInt(_descr, "errString", errString.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 freeSpinCounter; _jparser.validateByNameThrow("freeSpinCounter", freeSpinCounter);
		AtfValidator::validateInt(_descr, "freeSpinCounter", freeSpinCounter, _checker, __FILE__, __LINE__);
		INT32 instantBonusCounter; _jparser.validateByNameThrow("instantBonusCounter", instantBonusCounter);
		AtfValidator::validateInt(_descr, "instantBonusCounter", instantBonusCounter, _checker, __FILE__, __LINE__);
		INT32 freeBetCounter; _jparser.validateByNameThrow("freeBetCounter", freeBetCounter);
		AtfValidator::validateInt(_descr, "freeBetCounter", freeBetCounter, _checker, __FILE__, __LINE__);
		INT32 prizeGameCounter; _jparser.validateByNameThrow("prizeGameCounter", prizeGameCounter);
		AtfValidator::validateInt(_descr, "prizeGameCounter", prizeGameCounter, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if( errCode != 0 )
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errString", szErrString, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 freeSpinCounter; _parser.parseINT32(freeSpinCounter);
		AtfValidator::validateInt(_descr, "freeSpinCounter", freeSpinCounter, _checker, __FILE__, __LINE__);
		INT32 instantBonusCounter; _parser.parseINT32(instantBonusCounter);
		AtfValidator::validateInt(_descr, "instantBonusCounter", instantBonusCounter, _checker, __FILE__, __LINE__);
		INT32 freeBetCounter; _parser.parseINT32(freeBetCounter);
		AtfValidator::validateInt(_descr, "freeBetCounter", freeBetCounter, _checker, __FILE__, __LINE__);
		INT32 prizeGameCounter; _parser.parseINT32(prizeGameCounter);
		AtfValidator::validateInt(_descr, "prizeGameCounter", prizeGameCounter, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_GET_ASSETS
//=================================================================

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS(Protocol_MSG_LOBBYETC_CLI_GET_ASSETS&& _o)
	: assetTypes(std::move(_o.assetTypes))
{
}

LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS& LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::operator=(Protocol_MSG_LOBBYETC_CLI_GET_ASSETS&& _o)
{
	if(this != &_o)
	{
		assetTypes = std::move(_o.assetTypes);
	}
	return *this;
}

#endif

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::clear()
{
	assetTypes.clear();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::equals(const Protocol_MSG_LOBBYETC_CLI_GET_ASSETS& _o) const
{
	return assetTypes.equals(_o.assetTypes);
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_GET_ASSETS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_GET_ASSETS*)_other));
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_GET_ASSETS).append(")");
	_buf.append(',');
	_buf.append("assetTypes=");
	assetTypes.toTraceString(_buf);
	return _buf.c_str();
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_GET_ASSETS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	assetTypes.toXmlString("assetTypes", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("assetTypes"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, assetTypes)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	assetTypes.composeMsg(_msg, _ignoreJSON);
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::parseMsg(CommMsgParser& _parser)
{
	assetTypes.parseMsg(_parser);
}

const char *LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("assetTypes", assetTypes);
	return _buf.c_str();
}

void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("assetTypes", assetTypes);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_ASSETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< PString > assetTypes; _jparser.validateByNameThrow("assetTypes", assetTypes);
	AtfValidator::validateIntMax(_descr, "assetTypes", assetTypes.size(), 100, _checker, __FILE__, __LINE__);
}

/*static*/ void LobbyEtc::cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_GET_ASSETS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szAssetTypes = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("assetTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "assetTypes", szAssetTypes, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED
//=================================================================

LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED()
{
	clear();
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::clear()
{
}

bool LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::equals(const Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED& _o) const
{
	return true;
}

bool LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED*)_other));
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY
//=================================================================

LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY(Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, responseStr(std::move(_o.responseStr))
{
}

LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY& LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::operator=(Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		responseStr = std::move(_o.responseStr);
	}
	return *this;
}

#endif

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	responseStr.clear();
}

bool LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::equals(const Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		Atf::atfPStringEquals(responseStr, _o.responseStr);
}

bool LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY*)_other));
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("responseStr=");
		_buf.append(responseStr);
	}
	return _buf.c_str();
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("responseStr", responseStr, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("responseStr"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, responseStr)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		_msg.composeString(responseStr);
	}
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		_parser.parseStringP(responseStr);
	}
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("responseStr", responseStr);
	}
	return _buf.c_str();
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("responseStr", responseStr);
	}
}

/*static*/ void LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateIntMax(_descr, "errString", errString.length(), 1000, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString responseStr; _jparser.validateByNameThrow("responseStr", responseStr);
		AtfValidator::validateIntMax(_descr, "responseStr", responseStr.length(), 10000, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateIntMax(_descr, "errString", szErrString, 1000, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "responseStr"); size_t szResponseStr = strlen(_dummy);
		AtfValidator::validateIntMax(_descr, "responseStr", szResponseStr, 10000, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY
//=================================================================

LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY(Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
{
}

LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY& LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::operator=(Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
	}
	return *this;
}

#endif

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::clear()
{
	errCode = 0;
	errString.clear();
}

bool LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::equals(const Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString);
}

bool LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY*)_other));
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	return _buf.c_str();
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
}

const char *LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	return _buf.c_str();
}

void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
}

/*static*/ void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateIntMax(_descr, "errString", errString.length(), 1000, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateIntMax(_descr, "errString", szErrString, 1000, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES
//=================================================================

LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES()
{
	clear();
}

void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::clear()
{
}

bool LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::equals(const Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES& _o) const
{
	return true;
}

bool LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES*)_other));
}

const char *LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES).append(")");
	return _buf.c_str();
}

const char *LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::parseMsg(CommMsgParser& _parser)
{
}

const char *LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY
//=================================================================

LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY(Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errString(std::move(_o.errString))
	, rmBlockedCountriesStates(std::move(_o.rmBlockedCountriesStates))
{
}

LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY& LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::operator=(Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errString = std::move(_o.errString);
		rmBlockedCountriesStates = std::move(_o.rmBlockedCountriesStates);
	}
	return *this;
}

#endif

void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::clear()
{
	errCode = 0;
	errString.clear();
	rmBlockedCountriesStates.clear();
}

bool LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::equals(const Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errString, _o.errString) &&
		rmBlockedCountriesStates.equals(_o.rmBlockedCountriesStates);
}

bool LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY*)_other));
}

const char *LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if(errCode)
	{
		_buf.append(',');
		_buf.append("errString=");
		_buf.append(errString);
	}
	else
	{
		_buf.append(',');
		_buf.append("rmBlockedCountriesStates=");
		rmBlockedCountriesStates.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if(errCode)
	{
		Atf::XmlElement::encodeAsXmlElement("errString", errString, _buf);
	}
	else
	{
		rmBlockedCountriesStates.toXmlString("rmBlockedCountriesStates", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errString"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errString)) return false;
			}
			else if (_element.equals("rmBlockedCountriesStates"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PString, 4 > >::FromXmlString(_value, rmBlockedCountriesStates)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if(errCode)
	{
		_msg.composeString(errString);
	}
	else
	{
		rmBlockedCountriesStates.composeMsg(_msg, _ignoreJSON);
	}
}

void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if(errCode)
	{
		_parser.parseStringP(errString);
	}
	else
	{
		rmBlockedCountriesStates.parseMsg(_parser);
	}
}

const char *LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if(errCode)
	{
		_jsonstr.compose("errString", errString);
	}
	else
	{
		_jsonstr.compose("rmBlockedCountriesStates", rmBlockedCountriesStates);
	}
	return _buf.c_str();
}

void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if(errCode)
	{
		_jparser.parseByNameThrow("errString", errString);
	}
	else
	{
		_jparser.parseByNameThrow("rmBlockedCountriesStates", rmBlockedCountriesStates);
	}
}

/*static*/ void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		PString errString; _jparser.validateByNameThrow("errString", errString);
		AtfValidator::validateIntMax(_descr, "errString", errString.length(), 1000, _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< PString > rmBlockedCountriesStates; _jparser.validateByNameThrow("rmBlockedCountriesStates", rmBlockedCountriesStates);
		AtfValidator::validateInt(_descr, "rmBlockedCountriesStates", rmBlockedCountriesStates.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void LobbyEtc::starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if(errCode)
	{
		_parser.parseStringN(_dummy, 0, "errString"); size_t szErrString = strlen(_dummy);
		AtfValidator::validateIntMax(_descr, "errString", szErrString, 1000, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szRmBlockedCountriesStates = Atf::LAtfVector< PString, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("rmBlockedCountriesStates"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "rmBlockedCountriesStates", szRmBlockedCountriesStates, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* LobbyEtc::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE: _obj = new cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE(); break;
			case MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY(); break;
			case MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST: _obj = new cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST(); break;
			case MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY(); break;
			case MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST: _obj = new cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST(); break;
			case MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY(); break;
			case MSG_LOBBYETC_CLIENT_HISTORY_REQUEST: _obj = new cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST(); break;
			case MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY(); break;
			case MSG_LOBBYETC_CLIENT_REPORT: _obj = new cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT(); break;
			case MSG_LOBBYETC_CLIENT_REPORT_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY(); break;
			case MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL(); break;
			case MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY(); break;
			case MSG_LOBBYETC_CLI_DISPLAY_ADS: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS(); break;
			case MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY(); break;
			case MSG_LOBBYETC_CLI_GET_ASSETS: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS(); break;
			case MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS(); break;
			case MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY(); break;
			case MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL(); break;
			case MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY(); break;
			case MSG_LOBBYETC_CLI_ICE_GET_UPDATES: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES(); break;
			case MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY(); break;
			case MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF(); break;
			case MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY(); break;
			case MSG_LOBBYETC_CLI_SET_GAME_AVATAR: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR(); break;
			case MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY(); break;
			case MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL(); break;
			case MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY(); break;
			case MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE(); break;
			case MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY(); break;
			case MSG_LOBBYETC_CLI_SE_SESSION_NOTIF: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF(); break;
			case MSG_LOBBYETC_CLI_TOURN_STATS: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS(); break;
			case MSG_LOBBYETC_CLI_TOURN_STATS_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY(); break;
			case MSG_LOBBYETC_EMLOCALE_GET: _obj = new cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET(); break;
			case MSG_LOBBYETC_EMLOCALE_GET_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY(); break;
			case MSG_LOBBYETC_EMLOCALE_SET: _obj = new cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET(); break;
			case MSG_LOBBYETC_EMLOCALE_SET_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY(); break;
			case MSG_LOBBYETC_FIND_TOURN_IT: _obj = new cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT(); break;
			case MSG_LOBBYETC_FIND_TOURN_IT_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY(); break;
			case MSG_LOBBYETC_FPP_HISTORY_AUDIT: _obj = new cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT(); break;
			case MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY(); break;
			case MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM: _obj = new cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM(); break;
			case MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS: _obj = new cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS(); break;
			case MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY(); break;
			case MSG_LOBBYETC_GET_CASINO_LIMITS: _obj = new cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS(); break;
			case MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY(); break;
			case MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER: _obj = new cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER(); break;
			case MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY(); break;
			case MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT(); break;
			case MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY(); break;
			case MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT(); break;
			case MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY(); break;
			case MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT(); break;
			case MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY(); break;
			case MSG_LOBBYETC_GET_LOGIN_HISTORY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY(); break;
			case MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY(); break;
			case MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO(); break;
			case MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY(); break;
			case MSG_LOBBYETC_GET_MY_STARS_COUNTERS: _obj = new cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS(); break;
			case MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY(); break;
			case MSG_LOBBYETC_GET_REALITY_CHECK_FREQ: _obj = new cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ(); break;
			case MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY(); break;
			case MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA: _obj = new cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA(); break;
			case MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY(); break;
			case MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT: _obj = new cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT(); break;
			case MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY(); break;
			case MSG_LOBBYETC_GET_SPORT_LIMITS: _obj = new cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS(); break;
			case MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY(); break;
			case MSG_LOBBYETC_GET_USER_PROPS: _obj = new cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS(); break;
			case MSG_LOBBYETC_GET_USER_PROPS_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY(); break;
			case MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO: _obj = new cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO(); break;
			case MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY(); break;
			case MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE: _obj = new cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE(); break;
			case MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY(); break;
			case MSG_LOBBYETC_LOCALE_SET: _obj = new cli::Protocol_MSG_LOBBYETC_LOCALE_SET(); break;
			case MSG_LOBBYETC_LOCALE_SET_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY(); break;
			case MSG_LOBBYETC_LOGOUT_USER_INFO: _obj = new cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO(); break;
			case MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY(); break;
			case MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE: _obj = new cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE(); break;
			case MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY(); break;
			case MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2: _obj = new cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2(); break;
			case MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY(); break;
			case MSG_LOBBYETC_PREDICTOR_GET_TICKETS: _obj = new cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS(); break;
			case MSG_LOBBYETC_SET_GAME_LIMITS2: _obj = new cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2(); break;
			case MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY(); break;
			case MSG_LOBBYETC_SET_REALITY_CHECK_FREQ: _obj = new cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ(); break;
			case MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY(); break;
			case MSG_LOBBYETC_SIGNAL_EVENT_LOGIN: _obj = new cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN(); break;
			case MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY(); break;
			case MSG_LOBBYETC_USER_TOURNTICKETS2: _obj = new cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2(); break;
			case MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY(); break;
			case MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT: _obj = new cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT(); break;
			case MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS: _obj = new cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS(); break;
			case MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV: _obj = new cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV(); break;
			case MSG_LOBBYETC_VERIFY_PWD: _obj = new cli::Protocol_MSG_LOBBYETC_VERIFY_PWD(); break;
			case MSG_LOBBYETC_VERIFY_PWD_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY(); break;
			case MSG_LOBBYETC_W2G_AUDIT: _obj = new cli::Protocol_MSG_LOBBYETC_W2G_AUDIT(); break;
			case MSG_LOBBYETC_W2G_AUDIT_REPLY: _obj = new cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY(); break;
			case MSG_LOBBY_ADMIN_INFO_REPLY: _obj = new cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY(); break;
			case MSG_LOBBY_GET_ARJEL_EVENTS: _obj = new cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS(); break;
			case MSG_LOBBY_GET_ARJEL_EVENTS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY(); break;
			case MSG_LOBBY_GET_CLIENT_OPTIONS: _obj = new cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS(); break;
			case MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY(); break;
			case MSG_LOBBY_GET_TABLE_LIMITS: _obj = new cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS(); break;
			case MSG_LOBBY_GET_TABLE_LIMITS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY(); break;
			case MSG_LOBBY_GET_TOURN_LIMITS: _obj = new cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS(); break;
			case MSG_LOBBY_GET_TOURN_LIMITS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY(); break;
			case MSG_LOBBY_GET_USER_CAPS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY(); break;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION: _obj = new cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION(); break;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY: _obj = new cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY(); break;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT: _obj = new cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT(); break;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY: _obj = new cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY(); break;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT: _obj = new cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT(); break;
			case MSG_LOBBY_SET_CLIENT_OPTIONS: _obj = new cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS(); break;
			case MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY: _obj = new cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY(); break;
			case MSG_LOBBY_TARGET_NEWS_DESKTOP: _obj = new cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP(); break;
			case MSG_LOBBY_TARGET_NEWS_MOBILE: _obj = new cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE(); break;
		}
	}
	else if(!strcmp(_nameSpace, "cli_Unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_ADX_EVENT: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT(); break;
			case MSG_LOBBYETC_ADX_EVENT_REPLY: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY(); break;
			case MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID(); break;
			case MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY(); break;
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY(); break;
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY(); break;
			case MSG_LOBBYETC_CONVERT_USERINTIDS: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS(); break;
			case MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY(); break;
			case MSG_LOBBYETC_GET_USER_IMAGE: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE(); break;
			case MSG_LOBBYETC_GET_USER_IMAGE_REPLY: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY(); break;
			case MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION(); break;
			case MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY: _obj = new cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY(); break;
			case MSG_LOBBY_CHECK_PUBLICATIONS: _obj = new cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS(); break;
			case MSG_LOBBY_CHECK_PUBLICATIONS_REPLY: _obj = new cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "geo"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED: _obj = new geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED(); break;
			case MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY: _obj = new geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY(); break;
			case MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY: _obj = new geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY(); break;
		}
	}
	else if(!strcmp(_nameSpace, "starsCrm"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES: _obj = new starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES(); break;
			case MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY: _obj = new starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool LobbyEtc::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE: cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY: cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST: cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY: cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST: cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY: cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_HISTORY_REQUEST: cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY: cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_REPORT: cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_REPORT_REPLY: cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL: cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_DISPLAY_ADS: cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_ASSETS: cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS: cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL: cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_ICE_GET_UPDATES: cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF: cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_GAME_AVATAR: cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL: cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE: cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SE_SESSION_NOTIF: cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TOURN_STATS: cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TOURN_STATS_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EMLOCALE_GET: cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EMLOCALE_GET_REPLY: cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EMLOCALE_SET: cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EMLOCALE_SET_REPLY: cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_FIND_TOURN_IT: cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_FIND_TOURN_IT_REPLY: cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_FPP_HISTORY_AUDIT: cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM: cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS: cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_CASINO_LIMITS: cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER: cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY: cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT: cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT: cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT: cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LOGIN_HISTORY: cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO: cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_MY_STARS_COUNTERS: cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_REALITY_CHECK_FREQ: cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY: cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA: cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY: cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT: cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY: cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SPORT_LIMITS: cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_PROPS: cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_PROPS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO: cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY: cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE: cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY: cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_LOCALE_SET: cli::Protocol_MSG_LOBBYETC_LOCALE_SET::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_LOCALE_SET_REPLY: cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_LOGOUT_USER_INFO: cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY: cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE: cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY: cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2: cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY: cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PREDICTOR_GET_TICKETS: cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SET_GAME_LIMITS2: cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY: cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SET_REALITY_CHECK_FREQ: cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY: cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SIGNAL_EVENT_LOGIN: cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY: cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_USER_TOURNTICKETS2: cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY: cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT: cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS: cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV: cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_VERIFY_PWD: cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_VERIFY_PWD_REPLY: cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_W2G_AUDIT: cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_W2G_AUDIT_REPLY: cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ADMIN_INFO_REPLY: cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ARJEL_EVENTS: cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ARJEL_EVENTS_REPLY: cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_LIMITS: cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_LIMITS_REPLY: cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TOURN_LIMITS: cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TOURN_LIMITS_REPLY: cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_CAPS_REPLY: cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_DESKTOP: cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_MOBILE: cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_Unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_ADX_EVENT: cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_ADX_EVENT_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID: cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY: cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CONVERT_USERINTIDS: cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_IMAGE: cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_IMAGE_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION: cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS: cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS_REPLY: cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "geo"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED: geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY: geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY: geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "starsCrm"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES: starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY: starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool LobbyEtc::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE: cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY: cli::Protocol_MSG_LOBBYETC_AUX_HAND_HISTORY_CLEAR_NUDGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST: cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY: cli::Protocol_MSG_LOBBYETC_CLIENT_AUX_HAND_HISTORY_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST: cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY: cli::Protocol_MSG_LOBBYETC_CLIENT_HAND_HISTORY_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_HISTORY_REQUEST: cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY: cli::Protocol_MSG_LOBBYETC_CLIENT_HISTORY_REQUEST_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_REPORT: cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLIENT_REPORT_REPLY: cli::Protocol_MSG_LOBBYETC_CLIENT_REPORT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL: cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_DELETE_IMAGE_APPROVAL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_DISPLAY_ADS: cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_DISPLAY_ADS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_ASSETS: cli::Protocol_MSG_LOBBYETC_CLI_GET_ASSETS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS: cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_USER_APPROVALS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL: cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_GET_SESSION_POPUP_INTERVAL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_ICE_GET_UPDATES: cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_ICE_GET_UPDATES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF: cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_ICE_SET_ALL_USER_BOARD_PREF_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_GAME_AVATAR: cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_SET_GAME_AVATAR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL: cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_SET_SESSION_POPUP_INTERVAL_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE: cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_SET_USER_GALLERY_IMAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_SE_SESSION_NOTIF: cli::Protocol_MSG_LOBBYETC_CLI_SE_SESSION_NOTIF::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TOURN_STATS: cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_TOURN_STATS_REPLY: cli::Protocol_MSG_LOBBYETC_CLI_TOURN_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EMLOCALE_GET: cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EMLOCALE_GET_REPLY: cli::Protocol_MSG_LOBBYETC_EMLOCALE_GET_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EMLOCALE_SET: cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_EMLOCALE_SET_REPLY: cli::Protocol_MSG_LOBBYETC_EMLOCALE_SET_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_FIND_TOURN_IT: cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_FIND_TOURN_IT_REPLY: cli::Protocol_MSG_LOBBYETC_FIND_TOURN_IT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_FPP_HISTORY_AUDIT: cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBYETC_FPP_HISTORY_AUDIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM: cli::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY_CONFIRM::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS: cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_ALL_APPROVED_GAME_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_CASINO_LIMITS: cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_CASINO_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER: cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY: cli::Protocol_MSG_LOBBYETC_GET_FPP_BUNDLES_FOR_USER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT: cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LAST_AUX_HAND_HISTORY_REPORT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT: cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LAST_HAND_HISTORY_REPORT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT: cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LAST_PLAYING_AUDIT_REPORT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LOGIN_HISTORY: cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LOGIN_HISTORY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO: cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY: cli::Protocol_MSG_LOBBYETC_GET_LOGIN_LIMIT_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_MY_STARS_COUNTERS: cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_MY_STARS_COUNTERS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_REALITY_CHECK_FREQ: cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY: cli::Protocol_MSG_LOBBYETC_GET_REALITY_CHECK_FREQ_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA: cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY: cli::Protocol_MSG_LOBBYETC_GET_SESSION_WINLOSS_DATA_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT: cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY: cli::Protocol_MSG_LOBBYETC_GET_SPORT_ACCUMULATED_LIMIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SPORT_LIMITS: cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_SPORT_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_PROPS: cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_PROPS_REPLY: cli::Protocol_MSG_LOBBYETC_GET_USER_PROPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO: cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY: cli::Protocol_MSG_LOBBYETC_GET_USER_SPORT_BOOK_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE: cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY: cli::Protocol_MSG_LOBBYETC_HAND_HISTORY_CLEAR_NUDGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_LOCALE_SET: cli::Protocol_MSG_LOBBYETC_LOCALE_SET::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_LOCALE_SET_REPLY: cli::Protocol_MSG_LOBBYETC_LOCALE_SET_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_LOGOUT_USER_INFO: cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY: cli::Protocol_MSG_LOBBYETC_LOGOUT_USER_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE: cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY: cli::Protocol_MSG_LOBBYETC_PLAYING_AUDIT_CLEAR_NUDGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2: cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY: cli::Protocol_MSG_LOBBYETC_PLAYING_HISTORY_AUDIT2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_PREDICTOR_GET_TICKETS: cli::Protocol_MSG_LOBBYETC_PREDICTOR_GET_TICKETS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SET_GAME_LIMITS2: cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY: cli::Protocol_MSG_LOBBYETC_SET_GAME_LIMITS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SET_REALITY_CHECK_FREQ: cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY: cli::Protocol_MSG_LOBBYETC_SET_REALITY_CHECK_FREQ_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SIGNAL_EVENT_LOGIN: cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY: cli::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_LOGIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_USER_TOURNTICKETS2: cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY: cli::Protocol_MSG_LOBBYETC_USER_TOURNTICKETS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT: cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PLAY_HISTORY_REPORT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS: cli::Protocol_MSG_LOBBYETC_U_CLI_NOTIFY_PREDICTOR_TICKETS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV: cli::Protocol_MSG_LOBBYETC_U_UPDATE_FLAGS_PRIV::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_VERIFY_PWD: cli::Protocol_MSG_LOBBYETC_VERIFY_PWD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_VERIFY_PWD_REPLY: cli::Protocol_MSG_LOBBYETC_VERIFY_PWD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_W2G_AUDIT: cli::Protocol_MSG_LOBBYETC_W2G_AUDIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_W2G_AUDIT_REPLY: cli::Protocol_MSG_LOBBYETC_W2G_AUDIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_ADMIN_INFO_REPLY: cli::Protocol_MSG_LOBBY_ADMIN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ARJEL_EVENTS: cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_ARJEL_EVENTS_REPLY: cli::Protocol_MSG_LOBBY_GET_ARJEL_EVENTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_GET_CLIENT_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_LIMITS: cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TABLE_LIMITS_REPLY: cli::Protocol_MSG_LOBBY_GET_TABLE_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TOURN_LIMITS: cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_TOURN_LIMITS_REPLY: cli::Protocol_MSG_LOBBY_GET_TOURN_LIMITS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_GET_USER_CAPS_REPLY: cli::Protocol_MSG_LOBBY_GET_USER_CAPS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY: cli::Protocol_MSG_LOBBY_INIT_NETVERIFY_SESSION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY: cli::Protocol_MSG_LOBBY_PLAYING_HISTORY_AUDIT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT: cli::Protocol_MSG_LOBBY_RESPONSIBLE_GAMING_HISTORY_AUDIT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY: cli::Protocol_MSG_LOBBY_SET_CLIENT_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_DESKTOP: cli::Protocol_MSG_LOBBY_TARGET_NEWS_DESKTOP::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_TARGET_NEWS_MOBILE: cli::Protocol_MSG_LOBBY_TARGET_NEWS_MOBILE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "cli_Unauth"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_ADX_EVENT: cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_ADX_EVENT_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_ADX_EVENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID: cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_DEFAULT_GALLERY_IMAGEID_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY: cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_CLI_GET_IMAGE_GALLERY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CONVERT_USERINTIDS: cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_CONVERT_USERINTIDS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_IMAGE: cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GET_USER_IMAGE_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_GET_USER_IMAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION: cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY: cli_Unauth::Protocol_MSG_LOBBYETC_SIGNAL_EVENT_INSTALLATION_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS: cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBY_CHECK_PUBLICATIONS_REPLY: cli_Unauth::Protocol_MSG_LOBBY_CHECK_PUBLICATIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "geo"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED: geo::Protocol_MSG_LOBBYETC_CLI_NOTIF_MOBILE_VERIFIED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY: geo::Protocol_MSG_LOBBYETC_CLI_REQUEST_USER_LOCAID_CONSENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY: geo::Protocol_MSG_LOBBYETC_GEOCOMPLY_LOCATE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	else if(!strcmp(_nameSpace, "starsCrm"))
	{
		switch(_msgId)
		{
			case MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES: starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY: starsCrm::Protocol_MSG_LOBBYETC_REQ_RM_BLOCKED_COUNTRIES_STATES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

