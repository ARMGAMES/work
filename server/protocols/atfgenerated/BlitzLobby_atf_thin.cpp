/**
 * BlitzLobby_atf_thin.cpp
 *
 * This file was auto-generated from BlitzLobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: -genMoveConstructor -thin BlitzLobby_atf.txt
 */
 
#include "BlitzLobby_atf_thin.h"

//=================================================================
//                    Accounts
//=================================================================

BlitzLobby::cli::Accounts::Accounts()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Accounts::Accounts(Accounts&& _o)
	: currency(std::move(_o.currency))
	, convRate(std::move(_o.convRate))
	, chips(std::move(_o.chips))
	, tChips(std::move(_o.tChips))
	, chipsDst(std::move(_o.chipsDst))
	, tChipsDst(std::move(_o.tChipsDst))
{
}

BlitzLobby::cli::Accounts& BlitzLobby::cli::Accounts::operator=(Accounts&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		convRate = std::move(_o.convRate);
		chips = std::move(_o.chips);
		tChips = std::move(_o.tChips);
		chipsDst = std::move(_o.chipsDst);
		tChipsDst = std::move(_o.tChipsDst);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Accounts::clear()
{
	currency.clear();
	convRate = 0;
	chips = 0;
	tChips = 0;
	chipsDst = 0;
	tChipsDst = 0;
}

bool BlitzLobby::cli::Accounts::equals(const Accounts& _o) const
{
	return currency.equals(_o.currency) &&
		convRate == _o.convRate &&
		chips == _o.chips &&
		tChips == _o.tChips &&
		chipsDst == _o.chipsDst &&
		tChipsDst == _o.tChipsDst;
}

const char *BlitzLobby::cli::Accounts::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendInt64(convRate);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("chipsDst=");
	_buf.appendInt(chipsDst);
	_buf.append(',');
	_buf.append("tChipsDst=");
	_buf.appendInt(tChipsDst);
	_buf.append('}');
	return _buf.c_str();
}

void BlitzLobby::cli::Accounts::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(Accounts())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(convRate);
		_body.composeINT32(chips);
		_body.composeINT32(tChips);
		_body.composeINT32(chipsDst);
		_body.composeINT32(tChipsDst);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::Accounts::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(convRate);
	_parser0.parseINT32(chips);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(chipsDst);
	_parser0.parseINT32(tChipsDst);
}

/*static*/ void BlitzLobby::cli::Accounts::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, CURRENCY_LEN, _checker, __FILE__, __LINE__);
	INT64 convRate; _parser0.parseINT64(convRate);
	AtfValidator::validateIntRange(_descr, "convRate", convRate, 0, 1000000000000LL, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateIntRange(_descr, "chips", chips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateIntRange(_descr, "tChips", tChips, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _parser0.parseINT32(chipsDst);
	AtfValidator::validateIntRange(_descr, "chipsDst", chipsDst, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	INT32 tChipsDst; _parser0.parseINT32(tChipsDst);
	AtfValidator::validateIntRange(_descr, "tChipsDst", tChipsDst, 0, MAX_BANKROLL_SIZE, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_BL_USER_BUYIN
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_BUYIN::Protocol_BL_USER_BUYIN()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_BUYIN::Protocol_BL_USER_BUYIN(Protocol_BL_USER_BUYIN&& _o)
	: buyIn(std::move(_o.buyIn))
	, currencyContext(std::move(_o.currencyContext))
{
}

BlitzLobby::cli::Protocol_BL_USER_BUYIN& BlitzLobby::cli::Protocol_BL_USER_BUYIN::operator=(Protocol_BL_USER_BUYIN&& _o)
{
	if(this != &_o)
	{
		buyIn = std::move(_o.buyIn);
		currencyContext = std::move(_o.currencyContext);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_BUYIN::clear()
{
	buyIn = 0;
	currencyContext.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_BUYIN::equals(const Protocol_BL_USER_BUYIN& _o) const
{
	return buyIn == _o.buyIn &&
		currencyContext.equals(_o.currencyContext);
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_BUYIN).append(")");
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendInt(buyIn);
	_buf.append(',');
	_buf.append("currencyContext=");
	currencyContext.toTraceString(_buf);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT32(buyIn);
	_msg.composeMsgBody(currencyContext);
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT32(buyIn);
	_parser.parseMsgBody(currencyContext);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_BUYIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_BUYIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	INT32 buyIn; _parser.parseINT32(buyIn);
	AtfValidator::validateIntMax(_descr, "buyIn", buyIn, 2000000000, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateIntMax(_descr, "currencyContext", szCurrencyContext, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_BUYIN_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::Protocol_BL_USER_BUYIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::Protocol_BL_USER_BUYIN_REPLY(Protocol_BL_USER_BUYIN_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescrForUser(std::move(_o.errDescrForUser))
	, entry(std::move(_o.entry))
	, thisAddress(std::move(_o.thisAddress))
	, tableObjectName(std::move(_o.tableObjectName))
	, sittingOut(std::move(_o.sittingOut))
	, chips(std::move(_o.chips))
	, sitOutNextBlind(std::move(_o.sitOutNextBlind))
	, state3Plus(std::move(_o.state3Plus))
	, isTablePublicationOverConnection(std::move(_o.isTablePublicationOverConnection))
	, numPlayingEntries(std::move(_o.numPlayingEntries))
	, chipsAfter(std::move(_o.chipsAfter))
{
}

BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY& BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::operator=(Protocol_BL_USER_BUYIN_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescrForUser = std::move(_o.errDescrForUser);
		entry = std::move(_o.entry);
		thisAddress = std::move(_o.thisAddress);
		tableObjectName = std::move(_o.tableObjectName);
		sittingOut = std::move(_o.sittingOut);
		chips = std::move(_o.chips);
		sitOutNextBlind = std::move(_o.sitOutNextBlind);
		state3Plus = std::move(_o.state3Plus);
		isTablePublicationOverConnection = std::move(_o.isTablePublicationOverConnection);
		numPlayingEntries = std::move(_o.numPlayingEntries);
		chipsAfter = std::move(_o.chipsAfter);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::clear()
{
	errCode = 0;
	errDescrForUser.clear();
	entry = 0;
	thisAddress.clear();
	tableObjectName.clear();
	sittingOut = false;
	chips = 0;
	sitOutNextBlind = false;
	state3Plus = false;
	isTablePublicationOverConnection = false;
	numPlayingEntries = 0;
	chipsAfter = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::equals(const Protocol_BL_USER_BUYIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescrForUser.equals(_o.errDescrForUser) &&
		entry == _o.entry &&
		thisAddress.equals(_o.thisAddress) &&
		tableObjectName.equals(_o.tableObjectName) &&
		sittingOut == _o.sittingOut &&
		chips == _o.chips &&
		sitOutNextBlind == _o.sitOutNextBlind &&
		state3Plus == _o.state3Plus &&
		isTablePublicationOverConnection == _o.isTablePublicationOverConnection &&
		numPlayingEntries == _o.numPlayingEntries &&
		chipsAfter == _o.chipsAfter;
}

const char *BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_BUYIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescrForUser=");
		_buf.append(errDescrForUser);
	}
	else
	{
		_buf.append(',');
		_buf.append("entry=");
		_buf.appendUint(entry);
		_buf.append(',');
		_buf.append("thisAddress=");
		_buf.append(thisAddress);
		_buf.append(',');
		_buf.append("tableObjectName=");
		_buf.append(tableObjectName);
		_buf.append(',');
		_buf.append("sittingOut=");
		_buf.appendUint(sittingOut);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("sitOutNextBlind=");
		_buf.appendUint(sitOutNextBlind);
		_buf.append(',');
		_buf.append("state3Plus=");
		_buf.appendUint(state3Plus);
		_buf.append(',');
		_buf.append("isTablePublicationOverConnection=");
		_buf.appendUint(isTablePublicationOverConnection);
		_buf.append(',');
		_buf.append("numPlayingEntries=");
		_buf.appendUint(numPlayingEntries);
		_buf.append(',');
		_buf.append("chipsAfter=");
		_buf.appendInt(chipsAfter);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescrForUser);
	}
	else
	{
		_msg.composeUINT32(entry);
		_msg.composeString(thisAddress);
		_msg.composeString(tableObjectName);
		_msg.composeBOOL(sittingOut);
		_msg.composeUINT32(chips);
		_msg.composeBOOL(sitOutNextBlind);
		_msg.composeBOOL(state3Plus);
		_msg.composeBOOL(isTablePublicationOverConnection);
		_msg.composeBYTE(numPlayingEntries);
		_msg.composeINT32(chipsAfter);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescrForUser);
	}
	else
	{
		_parser.parseUINT32(entry);
		_parser.parseStringP(thisAddress);
		_parser.parseStringP(tableObjectName);
		_parser.parseBOOL(sittingOut);
		_parser.parseUINT32(chips);
		_parser.parseBOOL(sitOutNextBlind);
		_parser.parseBOOL(state3Plus);
		_parser.parseBOOL(isTablePublicationOverConnection);
		_parser.parseBYTE(numPlayingEntries);
		_parser.parseINT32(chipsAfter);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_BUYIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_BUYIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescrForUser"); size_t szErrDescrForUser = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescrForUser", szErrDescrForUser, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 entry; _parser.parseUINT32(entry);
		AtfValidator::validateInt(_descr, "entry", entry, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "thisAddress"); size_t szThisAddress = strlen(_dummy);
		AtfValidator::validateInt(_descr, "thisAddress", szThisAddress, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObjectName"); size_t szTableObjectName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObjectName", szTableObjectName, _checker, __FILE__, __LINE__);
		bool sittingOut; _parser.parseBOOL(sittingOut);
		AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sitOutNextBlind; _parser.parseBOOL(sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
		bool state3Plus; _parser.parseBOOL(state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
		bool isTablePublicationOverConnection; _parser.parseBOOL(isTablePublicationOverConnection);
		AtfValidator::validateInt(_descr, "isTablePublicationOverConnection", isTablePublicationOverConnection, _checker, __FILE__, __LINE__);
		BYTE numPlayingEntries; _parser.parseBYTE(numPlayingEntries);
		AtfValidator::validateInt(_descr, "numPlayingEntries", numPlayingEntries, _checker, __FILE__, __LINE__);
		INT32 chipsAfter; _parser.parseINT32(chipsAfter);
		AtfValidator::validateInt(_descr, "chipsAfter", chipsAfter, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_OUT
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_OUT::Protocol_BL_USER_OUT()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_OUT::clear()
{
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_OUT::equals(const Protocol_BL_USER_OUT& _o) const
{
	return entryId == _o.entryId;
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_OUT).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_OUT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_OUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_OUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_OUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    BetInfo
//=================================================================

BlitzLobby::cli::BetInfo::BetInfo()
{
	clear();
}

void BlitzLobby::cli::BetInfo::clear()
{
	sumOfBets = 0;
	wonAmount = 0;
}

bool BlitzLobby::cli::BetInfo::equals(const BetInfo& _o) const
{
	return sumOfBets == _o.sumOfBets &&
		wonAmount == _o.wonAmount;
}

const char *BlitzLobby::cli::BetInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("sumOfBets=");
	_buf.appendInt64(sumOfBets);
	_buf.append(',');
	_buf.append("wonAmount=");
	_buf.appendInt64(wonAmount);
	_buf.append('}');
	return _buf.c_str();
}

void BlitzLobby::cli::BetInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(BetInfo())) // not empty
	{
		_body.composeINT64(sumOfBets);
		_body.composeINT64(wonAmount);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::BetInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseINT64(sumOfBets);
	_parser0.parseINT64(wonAmount);
}

/*static*/ void BlitzLobby::cli::BetInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	INT64 sumOfBets; _parser0.parseINT64(sumOfBets);
	AtfValidator::validateInt(_descr, "sumOfBets", sumOfBets, _checker, __FILE__, __LINE__);
	INT64 wonAmount; _parser0.parseINT64(wonAmount);
	AtfValidator::validateInt(_descr, "wonAmount", wonAmount, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_BL_USER_OUT_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::Protocol_BL_USER_OUT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::Protocol_BL_USER_OUT_REPLY(Protocol_BL_USER_OUT_REPLY&& _o)
	: entryId(std::move(_o.entryId))
	, err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
	, betInfo(std::move(_o.betInfo))
{
}

BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY& BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::operator=(Protocol_BL_USER_OUT_REPLY&& _o)
{
	if(this != &_o)
	{
		entryId = std::move(_o.entryId);
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
		betInfo = std::move(_o.betInfo);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
	betInfo.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::equals(const Protocol_BL_USER_OUT_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		errDescr.equals(_o.errDescr) &&
		betInfo.equals(_o.betInfo);
}

const char *BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_OUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("betInfo=");
		betInfo.toTraceString(_buf);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		betInfo.composeMsg(_msg);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		betInfo.parseMsg(_parser);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_OUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_OUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		BetInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("betInfo"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_ADDON
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_ADDON::Protocol_BL_USER_ADDON()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_ADDON::Protocol_BL_USER_ADDON(Protocol_BL_USER_ADDON&& _o)
	: entryId(std::move(_o.entryId))
	, addOn(std::move(_o.addOn))
	, currencyContext(std::move(_o.currencyContext))
{
}

BlitzLobby::cli::Protocol_BL_USER_ADDON& BlitzLobby::cli::Protocol_BL_USER_ADDON::operator=(Protocol_BL_USER_ADDON&& _o)
{
	if(this != &_o)
	{
		entryId = std::move(_o.entryId);
		addOn = std::move(_o.addOn);
		currencyContext = std::move(_o.currencyContext);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_ADDON::clear()
{
	entryId = 0;
	addOn = 0;
	currencyContext.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_ADDON::equals(const Protocol_BL_USER_ADDON& _o) const
{
	return entryId == _o.entryId &&
		addOn == _o.addOn &&
		currencyContext.equals(_o.currencyContext);
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_ADDON).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("addOn=");
	_buf.appendInt(addOn);
	_buf.append(',');
	_buf.append("currencyContext=");
	currencyContext.toTraceString(_buf);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT32(addOn);
	_msg.composeMsgBody(currencyContext);
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT32(addOn);
	_parser.parseMsgBody(currencyContext);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_ADDON::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_ADDON";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	INT32 addOn; _parser.parseINT32(addOn);
	AtfValidator::validateIntMax(_descr, "addOn", addOn, 2000000000, _checker, __FILE__, __LINE__);
	size_t szCurrencyContext; _parser.skipMsgBody(szCurrencyContext);  /*currencyContext*/
	AtfValidator::validateInt(_descr, "currencyContext", szCurrencyContext, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_ADDON_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::Protocol_BL_USER_ADDON_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::Protocol_BL_USER_ADDON_REPLY(Protocol_BL_USER_ADDON_REPLY&& _o)
	: err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
	, entryId(std::move(_o.entryId))
{
}

BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY& BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::operator=(Protocol_BL_USER_ADDON_REPLY&& _o)
{
	if(this != &_o)
	{
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
		entryId = std::move(_o.entryId);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::clear()
{
	err = 0;
	errDescr.clear();
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::equals(const Protocol_BL_USER_ADDON_REPLY& _o) const
{
	return err == _o.err &&
		errDescr.equals(_o.errDescr) &&
		entryId == _o.entryId;
}

const char *BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_ADDON_REPLY).append(")");
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	_parser.parseUINT32(entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_ADDON_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_ADDON_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITIN
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITIN::Protocol_BL_USER_SITIN()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN::clear()
{
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITIN::equals(const Protocol_BL_USER_SITIN& _o) const
{
	return entryId == _o.entryId;
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITIN).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITIN_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::Protocol_BL_USER_SITIN_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::Protocol_BL_USER_SITIN_REPLY(Protocol_BL_USER_SITIN_REPLY&& _o)
	: entryId(std::move(_o.entryId))
	, err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
	, thisAddress(std::move(_o.thisAddress))
	, tableObjectName(std::move(_o.tableObjectName))
	, sittingOut(std::move(_o.sittingOut))
	, chips(std::move(_o.chips))
	, sitOutNextBlind(std::move(_o.sitOutNextBlind))
	, state3Plus(std::move(_o.state3Plus))
	, isTablePublicationOverConnection(std::move(_o.isTablePublicationOverConnection))
{
}

BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY& BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::operator=(Protocol_BL_USER_SITIN_REPLY&& _o)
{
	if(this != &_o)
	{
		entryId = std::move(_o.entryId);
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
		thisAddress = std::move(_o.thisAddress);
		tableObjectName = std::move(_o.tableObjectName);
		sittingOut = std::move(_o.sittingOut);
		chips = std::move(_o.chips);
		sitOutNextBlind = std::move(_o.sitOutNextBlind);
		state3Plus = std::move(_o.state3Plus);
		isTablePublicationOverConnection = std::move(_o.isTablePublicationOverConnection);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
	thisAddress.clear();
	tableObjectName.clear();
	sittingOut = false;
	chips = 0;
	sitOutNextBlind = false;
	state3Plus = false;
	isTablePublicationOverConnection = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::equals(const Protocol_BL_USER_SITIN_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		errDescr.equals(_o.errDescr) &&
		thisAddress.equals(_o.thisAddress) &&
		tableObjectName.equals(_o.tableObjectName) &&
		sittingOut == _o.sittingOut &&
		chips == _o.chips &&
		sitOutNextBlind == _o.sitOutNextBlind &&
		state3Plus == _o.state3Plus &&
		isTablePublicationOverConnection == _o.isTablePublicationOverConnection;
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("thisAddress=");
		_buf.append(thisAddress);
		_buf.append(',');
		_buf.append("tableObjectName=");
		_buf.append(tableObjectName);
		_buf.append(',');
		_buf.append("sittingOut=");
		_buf.appendUint(sittingOut);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("sitOutNextBlind=");
		_buf.appendUint(sitOutNextBlind);
		_buf.append(',');
		_buf.append("state3Plus=");
		_buf.appendUint(state3Plus);
		_buf.append(',');
		_buf.append("isTablePublicationOverConnection=");
		_buf.appendUint(isTablePublicationOverConnection);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeString(thisAddress);
		_msg.composeString(tableObjectName);
		_msg.composeBOOL(sittingOut);
		_msg.composeUINT32(chips);
		_msg.composeBOOL(sitOutNextBlind);
		_msg.composeBOOL(state3Plus);
		_msg.composeBOOL(isTablePublicationOverConnection);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseStringP(thisAddress);
		_parser.parseStringP(tableObjectName);
		_parser.parseBOOL(sittingOut);
		_parser.parseUINT32(chips);
		_parser.parseBOOL(sitOutNextBlind);
		_parser.parseBOOL(state3Plus);
		_parser.parseBOOL(isTablePublicationOverConnection);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "thisAddress"); size_t szThisAddress = strlen(_dummy);
		AtfValidator::validateInt(_descr, "thisAddress", szThisAddress, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObjectName"); size_t szTableObjectName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObjectName", szTableObjectName, _checker, __FILE__, __LINE__);
		bool sittingOut; _parser.parseBOOL(sittingOut);
		AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sitOutNextBlind; _parser.parseBOOL(sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
		bool state3Plus; _parser.parseBOOL(state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
		bool isTablePublicationOverConnection; _parser.parseBOOL(isTablePublicationOverConnection);
		AtfValidator::validateInt(_descr, "isTablePublicationOverConnection", isTablePublicationOverConnection, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_GET_ENTRIES
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::Protocol_BL_USER_GET_ENTRIES()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::clear()
{
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::equals(const Protocol_BL_USER_GET_ENTRIES& _o) const
{
	return true;
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_ENTRIES).append(")");
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::composeMsg(CommMsgBody& _msg) const
{
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_ENTRIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    EntryBody
//=================================================================

BlitzLobby::cli::EntryBody::EntryBody()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::EntryBody::EntryBody(EntryBody&& _o)
	: entryId(std::move(_o.entryId))
	, thisAddress(std::move(_o.thisAddress))
	, tableObjectName(std::move(_o.tableObjectName))
	, sittingOut(std::move(_o.sittingOut))
	, chips(std::move(_o.chips))
	, autoRebuyOpt(std::move(_o.autoRebuyOpt))
	, autoRebuyBigBets(std::move(_o.autoRebuyBigBets))
	, fallUnderBigBets(std::move(_o.fallUnderBigBets))
	, fallUnderPercents(std::move(_o.fallUnderPercents))
	, sitOutNextBlind(std::move(_o.sitOutNextBlind))
	, state3Plus(std::move(_o.state3Plus))
{
}

BlitzLobby::cli::EntryBody& BlitzLobby::cli::EntryBody::operator=(EntryBody&& _o)
{
	if(this != &_o)
	{
		entryId = std::move(_o.entryId);
		thisAddress = std::move(_o.thisAddress);
		tableObjectName = std::move(_o.tableObjectName);
		sittingOut = std::move(_o.sittingOut);
		chips = std::move(_o.chips);
		autoRebuyOpt = std::move(_o.autoRebuyOpt);
		autoRebuyBigBets = std::move(_o.autoRebuyBigBets);
		fallUnderBigBets = std::move(_o.fallUnderBigBets);
		fallUnderPercents = std::move(_o.fallUnderPercents);
		sitOutNextBlind = std::move(_o.sitOutNextBlind);
		state3Plus = std::move(_o.state3Plus);
	}
	return *this;
}

#endif

void BlitzLobby::cli::EntryBody::clear()
{
	entryId = 0;
	thisAddress.clear();
	tableObjectName.clear();
	sittingOut = false;
	chips = 0;
	autoRebuyOpt = 0;
	autoRebuyBigBets = 0;
	fallUnderBigBets = 0;
	fallUnderPercents = 0;
	sitOutNextBlind = false;
	state3Plus = false;
}

bool BlitzLobby::cli::EntryBody::equals(const EntryBody& _o) const
{
	return entryId == _o.entryId &&
		thisAddress.equals(_o.thisAddress) &&
		tableObjectName.equals(_o.tableObjectName) &&
		sittingOut == _o.sittingOut &&
		chips == _o.chips &&
		autoRebuyOpt == _o.autoRebuyOpt &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		fallUnderBigBets == _o.fallUnderBigBets &&
		fallUnderPercents == _o.fallUnderPercents &&
		sitOutNextBlind == _o.sitOutNextBlind &&
		state3Plus == _o.state3Plus;
}

const char *BlitzLobby::cli::EntryBody::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("thisAddress=");
	_buf.append(thisAddress);
	_buf.append(',');
	_buf.append("tableObjectName=");
	_buf.append(tableObjectName);
	_buf.append(',');
	_buf.append("sittingOut=");
	_buf.appendUint(sittingOut);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendUint(chips);
	_buf.append(',');
	_buf.append("autoRebuyOpt=");
	_buf.appendInt(autoRebuyOpt);
	_buf.append(',');
	_buf.append("autoRebuyBigBets=");
	_buf.appendUint(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("fallUnderBigBets=");
	_buf.appendUint(fallUnderBigBets);
	_buf.append(',');
	_buf.append("fallUnderPercents=");
	_buf.appendUint(fallUnderPercents);
	_buf.append(',');
	_buf.append("sitOutNextBlind=");
	_buf.appendUint(sitOutNextBlind);
	_buf.append(',');
	_buf.append("state3Plus=");
	_buf.appendUint(state3Plus);
	_buf.append('}');
	return _buf.c_str();
}

void BlitzLobby::cli::EntryBody::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(EntryBody())) // not empty
	{
		_body.composeUINT32(entryId);
		_body.composeString(thisAddress);
		_body.composeString(tableObjectName);
		_body.composeBOOL(sittingOut);
		_body.composeUINT32(chips);
		_body.composeINT8(autoRebuyOpt);
		_body.composeUINT16(autoRebuyBigBets);
		_body.composeUINT16(fallUnderBigBets);
		_body.composeUINT16(fallUnderPercents);
		_body.composeBOOL(sitOutNextBlind);
		_body.composeBOOL(state3Plus);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::EntryBody::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(entryId);
	_parser0.parseStringP(thisAddress);
	_parser0.parseStringP(tableObjectName);
	_parser0.parseBOOL(sittingOut);
	_parser0.parseUINT32(chips);
	_parser0.parseINT8(autoRebuyOpt);
	_parser0.parseUINT16(autoRebuyBigBets);
	_parser0.parseUINT16(fallUnderBigBets);
	_parser0.parseUINT16(fallUnderPercents);
	_parser0.parseBOOL(sitOutNextBlind);
	_parser0.parseBOOL(state3Plus);
}

/*static*/ void BlitzLobby::cli::EntryBody::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 entryId; _parser0.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "thisAddress"); size_t szThisAddress = strlen(_dummy);
	AtfValidator::validateInt(_descr, "thisAddress", szThisAddress, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableObjectName"); size_t szTableObjectName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableObjectName", szTableObjectName, _checker, __FILE__, __LINE__);
	bool sittingOut; _parser0.parseBOOL(sittingOut);
	AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
	UINT32 chips; _parser0.parseUINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _parser0.parseINT8(autoRebuyOpt);
	AtfValidator::validateInt(_descr, "autoRebuyOpt", autoRebuyOpt, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _parser0.parseUINT16(autoRebuyBigBets);
	AtfValidator::validateInt(_descr, "autoRebuyBigBets", autoRebuyBigBets, _checker, __FILE__, __LINE__);
	UINT16 fallUnderBigBets; _parser0.parseUINT16(fallUnderBigBets);
	AtfValidator::validateInt(_descr, "fallUnderBigBets", fallUnderBigBets, _checker, __FILE__, __LINE__);
	UINT16 fallUnderPercents; _parser0.parseUINT16(fallUnderPercents);
	AtfValidator::validateInt(_descr, "fallUnderPercents", fallUnderPercents, _checker, __FILE__, __LINE__);
	bool sitOutNextBlind; _parser0.parseBOOL(sitOutNextBlind);
	AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
	bool state3Plus; _parser0.parseBOOL(state3Plus);
	AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_BL_USER_GET_ENTRIES_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::Protocol_BL_USER_GET_ENTRIES_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::Protocol_BL_USER_GET_ENTRIES_REPLY(Protocol_BL_USER_GET_ENTRIES_REPLY&& _o)
	: entryBodies(std::move(_o.entryBodies))
{
}

BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY& BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::operator=(Protocol_BL_USER_GET_ENTRIES_REPLY&& _o)
{
	if(this != &_o)
	{
		entryBodies = std::move(_o.entryBodies);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::clear()
{
	entryBodies.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::equals(const Protocol_BL_USER_GET_ENTRIES_REPLY& _o) const
{
	return entryBodies.equals(_o.entryBodies);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_ENTRIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryBodies=");
	entryBodies.toTraceString(_buf);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::composeMsg(CommMsgBody& _msg) const
{
	entryBodies.composeMsg(_msg);
}

void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	entryBodies.parseMsg(_parser);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_ENTRIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_ENTRIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szEntryBodies = ThinAtf::LAtfVector< EntryBody, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("entryBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "entryBodies", szEntryBodies, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_WHERE_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::Protocol_BL_USER_WHERE_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::Protocol_BL_USER_WHERE_REPLY(Protocol_BL_USER_WHERE_REPLY&& _o)
	: entryId(std::move(_o.entryId))
	, err(std::move(_o.err))
	, errStr(std::move(_o.errStr))
	, thisAddress(std::move(_o.thisAddress))
	, tableObjectName(std::move(_o.tableObjectName))
	, sittingOut(std::move(_o.sittingOut))
	, chips(std::move(_o.chips))
	, sitOutNextBlind(std::move(_o.sitOutNextBlind))
	, italianSessionId(std::move(_o.italianSessionId))
	, state3Plus(std::move(_o.state3Plus))
	, scalePM(std::move(_o.scalePM))
	, privatePubl(std::move(_o.privatePubl))
{
}

BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY& BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::operator=(Protocol_BL_USER_WHERE_REPLY&& _o)
{
	if(this != &_o)
	{
		entryId = std::move(_o.entryId);
		err = std::move(_o.err);
		errStr = std::move(_o.errStr);
		thisAddress = std::move(_o.thisAddress);
		tableObjectName = std::move(_o.tableObjectName);
		sittingOut = std::move(_o.sittingOut);
		chips = std::move(_o.chips);
		sitOutNextBlind = std::move(_o.sitOutNextBlind);
		italianSessionId = std::move(_o.italianSessionId);
		state3Plus = std::move(_o.state3Plus);
		scalePM = std::move(_o.scalePM);
		privatePubl = std::move(_o.privatePubl);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errStr.clear();
	thisAddress.clear();
	tableObjectName.clear();
	sittingOut = false;
	chips = 0;
	sitOutNextBlind = false;
	italianSessionId.clear();
	state3Plus = false;
	scalePM = 0;
	privatePubl = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::equals(const Protocol_BL_USER_WHERE_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		errStr.equals(_o.errStr) &&
		thisAddress.equals(_o.thisAddress) &&
		tableObjectName.equals(_o.tableObjectName) &&
		sittingOut == _o.sittingOut &&
		chips == _o.chips &&
		sitOutNextBlind == _o.sitOutNextBlind &&
		italianSessionId.equals(_o.italianSessionId) &&
		state3Plus == _o.state3Plus &&
		scalePM == _o.scalePM &&
		privatePubl == _o.privatePubl;
}

const char *BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_WHERE_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if( err )
	{
		_buf.append(',');
		_buf.append("errStr=");
		_buf.append(errStr);
	}
	else
	{
		_buf.append(',');
		_buf.append("thisAddress=");
		_buf.append(thisAddress);
		_buf.append(',');
		_buf.append("tableObjectName=");
		_buf.append(tableObjectName);
		_buf.append(',');
		_buf.append("sittingOut=");
		_buf.appendUint(sittingOut);
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendUint(chips);
		_buf.append(',');
		_buf.append("sitOutNextBlind=");
		_buf.appendUint(sitOutNextBlind);
		_buf.append(',');
		_buf.append("italianSessionId=");
		_buf.append(italianSessionId);
		_buf.append(',');
		_buf.append("state3Plus=");
		_buf.appendUint(state3Plus);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendUint(scalePM);
		_buf.append(',');
		_buf.append("privatePubl=");
		_buf.appendUint(privatePubl);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if( err )
	{
		_msg.composeString(errStr);
	}
	else
	{
		_msg.composeString(thisAddress);
		_msg.composeString(tableObjectName);
		_msg.composeBOOL(sittingOut);
		_msg.composeUINT32(chips);
		_msg.composeBOOL(sitOutNextBlind);
		_msg.composeString(italianSessionId);
		_msg.composeBOOL(state3Plus);
		_msg.composeUINT32(scalePM);
		_msg.composeBOOL(privatePubl);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if( err )
	{
		_parser.parseStringP(errStr);
	}
	else
	{
		_parser.parseStringP(thisAddress);
		_parser.parseStringP(tableObjectName);
		_parser.parseBOOL(sittingOut);
		_parser.parseUINT32(chips);
		_parser.parseBOOL(sitOutNextBlind);
		_parser.parseStringP(italianSessionId);
		_parser.parseBOOL(state3Plus);
		_parser.parseUINT32(scalePM);
		_parser.parseBOOL(privatePubl);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_WHERE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_WHERE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if( err )
	{
		_parser.parseStringN(_dummy, 0, "errStr"); size_t szErrStr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errStr", szErrStr, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "thisAddress"); size_t szThisAddress = strlen(_dummy);
		AtfValidator::validateInt(_descr, "thisAddress", szThisAddress, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tableObjectName"); size_t szTableObjectName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tableObjectName", szTableObjectName, _checker, __FILE__, __LINE__);
		bool sittingOut; _parser.parseBOOL(sittingOut);
		AtfValidator::validateInt(_descr, "sittingOut", sittingOut, _checker, __FILE__, __LINE__);
		UINT32 chips; _parser.parseUINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		bool sitOutNextBlind; _parser.parseBOOL(sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "italianSessionId"); size_t szItalianSessionId = strlen(_dummy);
		AtfValidator::validateInt(_descr, "italianSessionId", szItalianSessionId, _checker, __FILE__, __LINE__);
		bool state3Plus; _parser.parseBOOL(state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
		UINT32 scalePM; _parser.parseUINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		bool privatePubl; _parser.parseBOOL(privatePubl);
		AtfValidator::validateInt(_descr, "privatePubl", privatePubl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_GET_BUYIN_INFO
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::Protocol_BL_USER_GET_BUYIN_INFO()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::clear()
{
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::equals(const Protocol_BL_USER_GET_BUYIN_INFO& _o) const
{
	return entryId == _o.entryId;
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_BUYIN_INFO).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_BUYIN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    OneAccount
//=================================================================

BlitzLobby::cli::OneAccount::OneAccount()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::OneAccount::OneAccount(OneAccount&& _o)
	: currency(std::move(_o.currency))
	, convRate(std::move(_o.convRate))
	, chips(std::move(_o.chips))
	, tChips(std::move(_o.tChips))
	, chipsDst(std::move(_o.chipsDst))
	, tChipsDst(std::move(_o.tChipsDst))
{
}

BlitzLobby::cli::OneAccount& BlitzLobby::cli::OneAccount::operator=(OneAccount&& _o)
{
	if(this != &_o)
	{
		currency = std::move(_o.currency);
		convRate = std::move(_o.convRate);
		chips = std::move(_o.chips);
		tChips = std::move(_o.tChips);
		chipsDst = std::move(_o.chipsDst);
		tChipsDst = std::move(_o.tChipsDst);
	}
	return *this;
}

#endif

void BlitzLobby::cli::OneAccount::clear()
{
	currency.clear();
	convRate = 0;
	chips = 0;
	tChips = 0;
	chipsDst = 0;
	tChipsDst = 0;
}

bool BlitzLobby::cli::OneAccount::equals(const OneAccount& _o) const
{
	return currency.equals(_o.currency) &&
		convRate == _o.convRate &&
		chips == _o.chips &&
		tChips == _o.tChips &&
		chipsDst == _o.chipsDst &&
		tChipsDst == _o.tChipsDst;
}

const char *BlitzLobby::cli::OneAccount::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("convRate=");
	_buf.appendInt64(convRate);
	_buf.append(',');
	_buf.append("chips=");
	_buf.appendInt(chips);
	_buf.append(',');
	_buf.append("tChips=");
	_buf.appendInt(tChips);
	_buf.append(',');
	_buf.append("chipsDst=");
	_buf.appendInt(chipsDst);
	_buf.append(',');
	_buf.append("tChipsDst=");
	_buf.appendInt(tChipsDst);
	_buf.append('}');
	return _buf.c_str();
}

void BlitzLobby::cli::OneAccount::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(OneAccount())) // not empty
	{
		_body.composeString(currency);
		_body.composeINT64(convRate);
		_body.composeINT32(chips);
		_body.composeINT32(tChips);
		_body.composeINT32(chipsDst);
		_body.composeINT32(tChipsDst);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::OneAccount::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currency);
	_parser0.parseINT64(convRate);
	_parser0.parseINT32(chips);
	_parser0.parseINT32(tChips);
	_parser0.parseINT32(chipsDst);
	_parser0.parseINT32(tChipsDst);
}

/*static*/ void BlitzLobby::cli::OneAccount::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	INT64 convRate; _parser0.parseINT64(convRate);
	AtfValidator::validateInt(_descr, "convRate", convRate, _checker, __FILE__, __LINE__);
	INT32 chips; _parser0.parseINT32(chips);
	AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
	INT32 tChips; _parser0.parseINT32(tChips);
	AtfValidator::validateInt(_descr, "tChips", tChips, _checker, __FILE__, __LINE__);
	INT32 chipsDst; _parser0.parseINT32(chipsDst);
	AtfValidator::validateInt(_descr, "chipsDst", chipsDst, _checker, __FILE__, __LINE__);
	INT32 tChipsDst; _parser0.parseINT32(tChipsDst);
	AtfValidator::validateInt(_descr, "tChipsDst", tChipsDst, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    MoneyAvailInfo
//=================================================================

BlitzLobby::cli::MoneyAvailInfo::MoneyAvailInfo()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::MoneyAvailInfo::MoneyAvailInfo(MoneyAvailInfo&& _o)
	: currencyDst(std::move(_o.currencyDst))
	, availForSpendingDst(std::move(_o.availForSpendingDst))
	, unclearedDst(std::move(_o.unclearedDst))
	, accounts(std::move(_o.accounts))
	, flags(std::move(_o.flags))
	, flags2(std::move(_o.flags2))
	, userRollId(std::move(_o.userRollId))
	, rollAmount(std::move(_o.rollAmount))
	, availWithoutConv(std::move(_o.availWithoutConv))
{
}

BlitzLobby::cli::MoneyAvailInfo& BlitzLobby::cli::MoneyAvailInfo::operator=(MoneyAvailInfo&& _o)
{
	if(this != &_o)
	{
		currencyDst = std::move(_o.currencyDst);
		availForSpendingDst = std::move(_o.availForSpendingDst);
		unclearedDst = std::move(_o.unclearedDst);
		accounts = std::move(_o.accounts);
		flags = std::move(_o.flags);
		flags2 = std::move(_o.flags2);
		userRollId = std::move(_o.userRollId);
		rollAmount = std::move(_o.rollAmount);
		availWithoutConv = std::move(_o.availWithoutConv);
	}
	return *this;
}

#endif

void BlitzLobby::cli::MoneyAvailInfo::clear()
{
	currencyDst.clear();
	availForSpendingDst = 0;
	unclearedDst = 0;
	accounts.clear();
	flags = 0;
	flags2 = 0;
	userRollId = 0;
	rollAmount = 0;
	availWithoutConv = 0;
}

bool BlitzLobby::cli::MoneyAvailInfo::equals(const MoneyAvailInfo& _o) const
{
	return currencyDst.equals(_o.currencyDst) &&
		availForSpendingDst == _o.availForSpendingDst &&
		unclearedDst == _o.unclearedDst &&
		accounts.equals(_o.accounts) &&
		flags == _o.flags &&
		flags2 == _o.flags2 &&
		userRollId == _o.userRollId &&
		rollAmount == _o.rollAmount &&
		availWithoutConv == _o.availWithoutConv;
}

const char *BlitzLobby::cli::MoneyAvailInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currencyDst=");
	_buf.append(currencyDst);
	_buf.append(',');
	_buf.append("availForSpendingDst=");
	_buf.appendInt(availForSpendingDst);
	_buf.append(',');
	_buf.append("unclearedDst=");
	_buf.appendInt(unclearedDst);
	_buf.append(',');
	_buf.append("accounts=");
	accounts.toTraceString(_buf);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("flags2=");
	_buf.appendUint64(flags2);
	_buf.append(',');
	_buf.append("userRollId=");
	_buf.appendUint(userRollId);
	_buf.append(',');
	_buf.append("rollAmount=");
	_buf.appendInt(rollAmount);
	_buf.append(',');
	_buf.append("availWithoutConv=");
	_buf.appendInt(availWithoutConv);
	_buf.append('}');
	return _buf.c_str();
}

void BlitzLobby::cli::MoneyAvailInfo::composeMsg(CommMsgBody& _msg) const
{
	CommMsgBody _body;
	//if (!equals(MoneyAvailInfo())) // not empty
	{
		_body.composeString(currencyDst);
		_body.composeINT32(availForSpendingDst);
		_body.composeINT32(unclearedDst);
		accounts.composeMsg(_body);
		_body.composeUINT32(flags);
		_body.composeUINT64(flags2);
		_body.composeUINT32(userRollId);
		_body.composeINT32(rollAmount);
		_body.composeINT32(availWithoutConv);
	}

	_msg.composeMsgBody(_body);
}

void BlitzLobby::cli::MoneyAvailInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(currencyDst);
	_parser0.parseINT32(availForSpendingDst);
	_parser0.parseINT32(unclearedDst);
	accounts.parseMsg(_parser0);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(flags2);
	_parser0.parseUINT32(userRollId);
	_parser0.parseINT32(rollAmount);
	_parser0.parseINT32(availWithoutConv);
}

/*static*/ void BlitzLobby::cli::MoneyAvailInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "currencyDst"); size_t szCurrencyDst = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currencyDst", szCurrencyDst, _checker, __FILE__, __LINE__);
	INT32 availForSpendingDst; _parser0.parseINT32(availForSpendingDst);
	AtfValidator::validateInt(_descr, "availForSpendingDst", availForSpendingDst, _checker, __FILE__, __LINE__);
	INT32 unclearedDst; _parser0.parseINT32(unclearedDst);
	AtfValidator::validateInt(_descr, "unclearedDst", unclearedDst, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szAccounts = ThinAtf::LAtfVector< OneAccount, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("accounts"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "accounts", szAccounts, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 flags2; _parser0.parseUINT64(flags2);
	AtfValidator::validateUint(_descr, "flags2", flags2, _checker, __FILE__, __LINE__);
	UINT32 userRollId; _parser0.parseUINT32(userRollId);
	AtfValidator::validateInt(_descr, "userRollId", userRollId, _checker, __FILE__, __LINE__);
	INT32 rollAmount; _parser0.parseINT32(rollAmount);
	AtfValidator::validateInt(_descr, "rollAmount", rollAmount, _checker, __FILE__, __LINE__);
	INT32 availWithoutConv; _parser0.parseINT32(availWithoutConv);
	AtfValidator::validateInt(_descr, "availWithoutConv", availWithoutConv, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_BL_USER_GET_BUYIN_INFO_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::Protocol_BL_USER_GET_BUYIN_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::Protocol_BL_USER_GET_BUYIN_INFO_REPLY(Protocol_BL_USER_GET_BUYIN_INFO_REPLY&& _o)
	: errCode(std::move(_o.errCode))
	, errDescrForUser(std::move(_o.errDescrForUser))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, enoughOnAllAccounts(std::move(_o.enoughOnAllAccounts))
	, chips(std::move(_o.chips))
	, chipsMin(std::move(_o.chipsMin))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, chipsQuantum(std::move(_o.chipsQuantum))
	, playAddB(std::move(_o.playAddB))
	, playAddU(std::move(_o.playAddU))
	, clientCurrencyContext(std::move(_o.clientCurrencyContext))
	, entriesLeft(std::move(_o.entriesLeft))
	, entryId(std::move(_o.entryId))
	, chipsInPlay(std::move(_o.chipsInPlay))
	, enoughMoneyInOtherCurrencies(std::move(_o.enoughMoneyInOtherCurrencies))
	, maxRebuyChips(std::move(_o.maxRebuyChips))
	, totalRebuyChips(std::move(_o.totalRebuyChips))
	, playChips64(std::move(_o.playChips64))
	, scalePM(std::move(_o.scalePM))
	, clientServiceFlag(std::move(_o.clientServiceFlag))
	, defaultBuyIn(std::move(_o.defaultBuyIn))
{
}

BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY& BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::operator=(Protocol_BL_USER_GET_BUYIN_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		errCode = std::move(_o.errCode);
		errDescrForUser = std::move(_o.errDescrForUser);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		enoughOnAllAccounts = std::move(_o.enoughOnAllAccounts);
		chips = std::move(_o.chips);
		chipsMin = std::move(_o.chipsMin);
		maxBuyIn = std::move(_o.maxBuyIn);
		chipsQuantum = std::move(_o.chipsQuantum);
		playAddB = std::move(_o.playAddB);
		playAddU = std::move(_o.playAddU);
		clientCurrencyContext = std::move(_o.clientCurrencyContext);
		entriesLeft = std::move(_o.entriesLeft);
		entryId = std::move(_o.entryId);
		chipsInPlay = std::move(_o.chipsInPlay);
		enoughMoneyInOtherCurrencies = std::move(_o.enoughMoneyInOtherCurrencies);
		maxRebuyChips = std::move(_o.maxRebuyChips);
		totalRebuyChips = std::move(_o.totalRebuyChips);
		playChips64 = std::move(_o.playChips64);
		scalePM = std::move(_o.scalePM);
		clientServiceFlag = std::move(_o.clientServiceFlag);
		defaultBuyIn = std::move(_o.defaultBuyIn);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::clear()
{
	errCode = 0;
	errDescrForUser.clear();
	currency.clear();
	minChipsLimit = 0;
	enoughOnAllAccounts = false;
	chips = 0;
	chipsMin = 0;
	maxBuyIn = 0;
	chipsQuantum = 0;
	playAddB = 0;
	playAddU = 0;
	clientCurrencyContext.clear();
	entriesLeft = 0;
	entryId = 0;
	chipsInPlay = 0;
	enoughMoneyInOtherCurrencies = false;
	maxRebuyChips = 0;
	totalRebuyChips = 0;
	playChips64 = 0;
	scalePM = 0;
	clientServiceFlag = 0;
	defaultBuyIn = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::equals(const Protocol_BL_USER_GET_BUYIN_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		errDescrForUser.equals(_o.errDescrForUser) &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		enoughOnAllAccounts == _o.enoughOnAllAccounts &&
		chips == _o.chips &&
		chipsMin == _o.chipsMin &&
		maxBuyIn == _o.maxBuyIn &&
		chipsQuantum == _o.chipsQuantum &&
		playAddB == _o.playAddB &&
		playAddU == _o.playAddU &&
		clientCurrencyContext.equals(_o.clientCurrencyContext) &&
		entriesLeft == _o.entriesLeft &&
		entryId == _o.entryId &&
		chipsInPlay == _o.chipsInPlay &&
		enoughMoneyInOtherCurrencies == _o.enoughMoneyInOtherCurrencies &&
		maxRebuyChips == _o.maxRebuyChips &&
		totalRebuyChips == _o.totalRebuyChips &&
		playChips64 == _o.playChips64 &&
		scalePM == _o.scalePM &&
		clientServiceFlag == _o.clientServiceFlag &&
		defaultBuyIn == _o.defaultBuyIn;
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_BUYIN_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if (errCode)
	{
		_buf.append(',');
		_buf.append("errDescrForUser=");
		_buf.append(errDescrForUser);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("minChipsLimit=");
		_buf.appendUint(minChipsLimit);
		_buf.append(',');
		_buf.append("enoughOnAllAccounts=");
		_buf.appendUint(enoughOnAllAccounts);
	}
	else
	{
		_buf.append(',');
		_buf.append("chips=");
		_buf.appendInt(chips);
		_buf.append(',');
		_buf.append("chipsMin=");
		_buf.appendInt(chipsMin);
		_buf.append(',');
		_buf.append("maxBuyIn=");
		_buf.appendInt(maxBuyIn);
		_buf.append(',');
		_buf.append("chipsQuantum=");
		_buf.appendInt(chipsQuantum);
		_buf.append(',');
		_buf.append("playAddB=");
		_buf.appendUint(playAddB);
		_buf.append(',');
		_buf.append("playAddU=");
		_buf.appendInt(playAddU);
		_buf.append(',');
		_buf.append("clientCurrencyContext=");
		clientCurrencyContext.toTraceString(_buf);
		_buf.append(',');
		_buf.append("entriesLeft=");
		_buf.appendInt(entriesLeft);
		_buf.append(',');
		_buf.append("entryId=");
		_buf.appendUint(entryId);
		_buf.append(',');
		_buf.append("chipsInPlay=");
		_buf.appendInt(chipsInPlay);
		_buf.append(',');
		_buf.append("enoughMoneyInOtherCurrencies=");
		_buf.appendUint(enoughMoneyInOtherCurrencies);
		_buf.append(',');
		_buf.append("maxRebuyChips=");
		_buf.appendInt(maxRebuyChips);
		_buf.append(',');
		_buf.append("totalRebuyChips=");
		_buf.appendInt(totalRebuyChips);
		_buf.append(',');
		_buf.append("playChips64=");
		_buf.appendInt64(playChips64);
		_buf.append(',');
		_buf.append("scalePM=");
		_buf.appendInt(scalePM);
		_buf.append(',');
		_buf.append("clientServiceFlag=");
		_buf.appendUint(clientServiceFlag);
		_buf.append(',');
		_buf.append("defaultBuyIn=");
		_buf.appendInt(defaultBuyIn);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeINT16(errCode);
	if (errCode)
	{
		_msg.composeString(errDescrForUser);
		_msg.composeString(currency);
		_msg.composeUINT32(minChipsLimit);
		_msg.composeBOOL(enoughOnAllAccounts);
	}
	else
	{
		_msg.composeINT32(chips);
		_msg.composeINT32(chipsMin);
		_msg.composeINT32(maxBuyIn);
		_msg.composeINT32(chipsQuantum);
		_msg.composeBYTE(playAddB);
		_msg.composeINT32(playAddU);
		clientCurrencyContext.composeMsg(_msg);
		_msg.composeINT8(entriesLeft);
		_msg.composeUINT32(entryId);
		_msg.composeINT32(chipsInPlay);
		_msg.composeBOOL(enoughMoneyInOtherCurrencies);
		_msg.composeINT32(maxRebuyChips);
		_msg.composeINT32(totalRebuyChips);
		_msg.composeINT64(playChips64);
		_msg.composeINT32(scalePM);
		_msg.composeBYTE(clientServiceFlag);
		_msg.composeINT32(defaultBuyIn);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if (errCode)
	{
		_parser.parseStringP(errDescrForUser);
		_parser.parseStringP(currency);
		_parser.parseUINT32(minChipsLimit);
		_parser.parseBOOL(enoughOnAllAccounts);
	}
	else
	{
		_parser.parseINT32(chips);
		_parser.parseINT32(chipsMin);
		_parser.parseINT32(maxBuyIn);
		_parser.parseINT32(chipsQuantum);
		_parser.parseBYTE(playAddB);
		_parser.parseINT32(playAddU);
		clientCurrencyContext.parseMsg(_parser);
		_parser.parseINT8(entriesLeft);
		_parser.parseUINT32(entryId);
		_parser.parseINT32(chipsInPlay);
		_parser.parseBOOL(enoughMoneyInOtherCurrencies);
		_parser.parseINT32(maxRebuyChips);
		_parser.parseINT32(totalRebuyChips);
		_parser.parseINT64(playChips64);
		_parser.parseINT32(scalePM);
		_parser.parseBYTE(clientServiceFlag);
		_parser.parseINT32(defaultBuyIn);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_BUYIN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if (errCode)
	{
		_parser.parseStringN(_dummy, 0, "errDescrForUser"); size_t szErrDescrForUser = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescrForUser", szErrDescrForUser, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
		AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
		bool enoughOnAllAccounts; _parser.parseBOOL(enoughOnAllAccounts);
		AtfValidator::validateInt(_descr, "enoughOnAllAccounts", enoughOnAllAccounts, _checker, __FILE__, __LINE__);
	}
	else
	{
		INT32 chips; _parser.parseINT32(chips);
		AtfValidator::validateInt(_descr, "chips", chips, _checker, __FILE__, __LINE__);
		INT32 chipsMin; _parser.parseINT32(chipsMin);
		AtfValidator::validateInt(_descr, "chipsMin", chipsMin, _checker, __FILE__, __LINE__);
		INT32 maxBuyIn; _parser.parseINT32(maxBuyIn);
		AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
		INT32 chipsQuantum; _parser.parseINT32(chipsQuantum);
		AtfValidator::validateInt(_descr, "chipsQuantum", chipsQuantum, _checker, __FILE__, __LINE__);
		BYTE playAddB; _parser.parseBYTE(playAddB);
		AtfValidator::validateInt(_descr, "playAddB", playAddB, _checker, __FILE__, __LINE__);
		INT32 playAddU; _parser.parseINT32(playAddU);
		AtfValidator::validateInt(_descr, "playAddU", playAddU, _checker, __FILE__, __LINE__);
		PString _descbuf;
		MoneyAvailInfo::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clientCurrencyContext"), _fieldsWithUnparsedContent);
		INT8 entriesLeft; _parser.parseINT8(entriesLeft);
		AtfValidator::validateInt(_descr, "entriesLeft", entriesLeft, _checker, __FILE__, __LINE__);
		UINT32 entryId; _parser.parseUINT32(entryId);
		AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
		INT32 chipsInPlay; _parser.parseINT32(chipsInPlay);
		AtfValidator::validateInt(_descr, "chipsInPlay", chipsInPlay, _checker, __FILE__, __LINE__);
		bool enoughMoneyInOtherCurrencies; _parser.parseBOOL(enoughMoneyInOtherCurrencies);
		AtfValidator::validateInt(_descr, "enoughMoneyInOtherCurrencies", enoughMoneyInOtherCurrencies, _checker, __FILE__, __LINE__);
		INT32 maxRebuyChips; _parser.parseINT32(maxRebuyChips);
		AtfValidator::validateInt(_descr, "maxRebuyChips", maxRebuyChips, _checker, __FILE__, __LINE__);
		INT32 totalRebuyChips; _parser.parseINT32(totalRebuyChips);
		AtfValidator::validateInt(_descr, "totalRebuyChips", totalRebuyChips, _checker, __FILE__, __LINE__);
		INT64 playChips64; _parser.parseINT64(playChips64);
		AtfValidator::validateInt(_descr, "playChips64", playChips64, _checker, __FILE__, __LINE__);
		INT32 scalePM; _parser.parseINT32(scalePM);
		AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
		BYTE clientServiceFlag; _parser.parseBYTE(clientServiceFlag);
		AtfValidator::validateInt(_descr, "clientServiceFlag", clientServiceFlag, _checker, __FILE__, __LINE__);
		INT32 defaultBuyIn; _parser.parseINT32(defaultBuyIn);
		AtfValidator::validateInt(_descr, "defaultBuyIn", defaultBuyIn, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_GET_INFO
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_INFO::Protocol_BL_USER_GET_INFO()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::clear()
{
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_INFO::equals(const Protocol_BL_USER_GET_INFO& _o) const
{
	return true;
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_INFO).append(")");
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::composeMsg(CommMsgBody& _msg) const
{
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::parseMsg(CommMsgParser& _parser)
{
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_GET_INFO_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::Protocol_BL_USER_GET_INFO_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::Protocol_BL_USER_GET_INFO_REPLY(Protocol_BL_USER_GET_INFO_REPLY&& _o)
	: name(std::move(_o.name))
	, isOneToOne(std::move(_o.isOneToOne))
	, isPlayMoney(std::move(_o.isPlayMoney))
	, nMaxPlayersPerTable(std::move(_o.nMaxPlayersPerTable))
	, game(std::move(_o.game))
	, hiLo(std::move(_o.hiLo))
	, smartLoBet(std::move(_o.smartLoBet))
	, highBet(std::move(_o.highBet))
	, structure(std::move(_o.structure))
	, cap(std::move(_o.cap))
	, tableFlags(std::move(_o.tableFlags))
	, chatLang(std::move(_o.chatLang))
	, currency(std::move(_o.currency))
	, minChipsLimit(std::move(_o.minChipsLimit))
	, maxBuyIn(std::move(_o.maxBuyIn))
	, ante(std::move(_o.ante))
	, itId(std::move(_o.itId))
	, shortHanded(std::move(_o.shortHanded))
	, scalePM(std::move(_o.scalePM))
	, noVppGainSites(std::move(_o.noVppGainSites))
	, tableStakes(std::move(_o.tableStakes))
{
}

BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY& BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::operator=(Protocol_BL_USER_GET_INFO_REPLY&& _o)
{
	if(this != &_o)
	{
		name = std::move(_o.name);
		isOneToOne = std::move(_o.isOneToOne);
		isPlayMoney = std::move(_o.isPlayMoney);
		nMaxPlayersPerTable = std::move(_o.nMaxPlayersPerTable);
		game = std::move(_o.game);
		hiLo = std::move(_o.hiLo);
		smartLoBet = std::move(_o.smartLoBet);
		highBet = std::move(_o.highBet);
		structure = std::move(_o.structure);
		cap = std::move(_o.cap);
		tableFlags = std::move(_o.tableFlags);
		chatLang = std::move(_o.chatLang);
		currency = std::move(_o.currency);
		minChipsLimit = std::move(_o.minChipsLimit);
		maxBuyIn = std::move(_o.maxBuyIn);
		ante = std::move(_o.ante);
		itId = std::move(_o.itId);
		shortHanded = std::move(_o.shortHanded);
		scalePM = std::move(_o.scalePM);
		noVppGainSites = std::move(_o.noVppGainSites);
		tableStakes = std::move(_o.tableStakes);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::clear()
{
	name.clear();
	isOneToOne = 0;
	isPlayMoney = 0;
	nMaxPlayersPerTable = 0;
	game = 0;
	hiLo = 0;
	smartLoBet = 0;
	highBet = 0;
	structure = 0;
	cap = 0;
	tableFlags = 0;
	chatLang = 0;
	currency.clear();
	minChipsLimit = 0;
	maxBuyIn = 0;
	ante = 0;
	itId.clear();
	shortHanded = false;
	scalePM = 0;
	noVppGainSites = 0;
	tableStakes.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::equals(const Protocol_BL_USER_GET_INFO_REPLY& _o) const
{
	return name.equals(_o.name) &&
		isOneToOne == _o.isOneToOne &&
		isPlayMoney == _o.isPlayMoney &&
		nMaxPlayersPerTable == _o.nMaxPlayersPerTable &&
		game == _o.game &&
		hiLo == _o.hiLo &&
		smartLoBet == _o.smartLoBet &&
		highBet == _o.highBet &&
		structure == _o.structure &&
		cap == _o.cap &&
		tableFlags == _o.tableFlags &&
		chatLang == _o.chatLang &&
		currency.equals(_o.currency) &&
		minChipsLimit == _o.minChipsLimit &&
		maxBuyIn == _o.maxBuyIn &&
		ante == _o.ante &&
		itId.equals(_o.itId) &&
		shortHanded == _o.shortHanded &&
		scalePM == _o.scalePM &&
		noVppGainSites == _o.noVppGainSites &&
		tableStakes.equals(_o.tableStakes);
}

const char *BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_GET_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("name=");
	_buf.append(name);
	_buf.append(',');
	_buf.append("isOneToOne=");
	_buf.appendUint(isOneToOne);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("nMaxPlayersPerTable=");
	_buf.appendUint(nMaxPlayersPerTable);
	_buf.append(',');
	_buf.append("game=");
	_buf.appendUint(game);
	_buf.append(',');
	_buf.append("hiLo=");
	_buf.appendUint(hiLo);
	_buf.append(',');
	_buf.append("smartLoBet=");
	_buf.appendUint(smartLoBet);
	_buf.append(',');
	_buf.append("highBet=");
	_buf.appendUint(highBet);
	_buf.append(',');
	_buf.append("structure=");
	_buf.appendUint(structure);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("tableFlags=");
	_buf.appendUint(tableFlags);
	_buf.append(',');
	_buf.append("chatLang=");
	_buf.appendUint(chatLang);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("minChipsLimit=");
	_buf.appendUint(minChipsLimit);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("itId=");
	_buf.append(itId);
	_buf.append(',');
	_buf.append("shortHanded=");
	_buf.appendUint(shortHanded);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append(',');
	_buf.append("noVppGainSites=");
	_buf.appendUint(noVppGainSites);
	_buf.append(',');
	_buf.append("tableStakes=");
	tableStakes.toTraceString(_buf);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeString(name);
	_msg.composeBYTE(isOneToOne);
	_msg.composeBYTE(isPlayMoney);
	_msg.composeBYTE(nMaxPlayersPerTable);
	_msg.composeBYTE(game);
	_msg.composeBYTE(hiLo);
	_msg.composeUINT32(smartLoBet);
	_msg.composeUINT32(highBet);
	_msg.composeBYTE(structure);
	_msg.composeUINT32(cap);
	_msg.composeUINT32(tableFlags);
	_msg.composeUINT16(chatLang);
	_msg.composeString(currency);
	_msg.composeUINT32(minChipsLimit);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeUINT32(ante);
	_msg.composeString(itId);
	_msg.composeBOOL(shortHanded);
	_msg.composeUINT32(scalePM);
	_msg.composeUINT32(noVppGainSites);
	tableStakes.composeMsg(_msg);
}

void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(name);
	_parser.parseBYTE(isOneToOne);
	_parser.parseBYTE(isPlayMoney);
	_parser.parseBYTE(nMaxPlayersPerTable);
	_parser.parseBYTE(game);
	_parser.parseBYTE(hiLo);
	_parser.parseUINT32(smartLoBet);
	_parser.parseUINT32(highBet);
	_parser.parseBYTE(structure);
	_parser.parseUINT32(cap);
	_parser.parseUINT32(tableFlags);
	_parser.parseUINT16(chatLang);
	_parser.parseStringP(currency);
	_parser.parseUINT32(minChipsLimit);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseUINT32(ante);
	_parser.parseStringP(itId);
	_parser.parseBOOL(shortHanded);
	_parser.parseUINT32(scalePM);
	_parser.parseUINT32(noVppGainSites);
	if(_parser.parseEnded()) return;
	tableStakes.parseMsg(_parser);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_GET_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_GET_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "name"); size_t szName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "name", szName, _checker, __FILE__, __LINE__);
	BYTE isOneToOne; _parser.parseBYTE(isOneToOne);
	AtfValidator::validateInt(_descr, "isOneToOne", isOneToOne, _checker, __FILE__, __LINE__);
	BYTE isPlayMoney; _parser.parseBYTE(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	BYTE nMaxPlayersPerTable; _parser.parseBYTE(nMaxPlayersPerTable);
	AtfValidator::validateInt(_descr, "nMaxPlayersPerTable", nMaxPlayersPerTable, _checker, __FILE__, __LINE__);
	BYTE game; _parser.parseBYTE(game);
	AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
	BYTE hiLo; _parser.parseBYTE(hiLo);
	AtfValidator::validateInt(_descr, "hiLo", hiLo, _checker, __FILE__, __LINE__);
	UINT32 smartLoBet; _parser.parseUINT32(smartLoBet);
	AtfValidator::validateInt(_descr, "smartLoBet", smartLoBet, _checker, __FILE__, __LINE__);
	UINT32 highBet; _parser.parseUINT32(highBet);
	AtfValidator::validateInt(_descr, "highBet", highBet, _checker, __FILE__, __LINE__);
	BYTE structure; _parser.parseBYTE(structure);
	AtfValidator::validateInt(_descr, "structure", structure, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateInt(_descr, "cap", cap, _checker, __FILE__, __LINE__);
	UINT32 tableFlags; _parser.parseUINT32(tableFlags);
	AtfValidator::validateInt(_descr, "tableFlags", tableFlags, _checker, __FILE__, __LINE__);
	UINT16 chatLang; _parser.parseUINT16(chatLang);
	AtfValidator::validateInt(_descr, "chatLang", chatLang, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	UINT32 minChipsLimit; _parser.parseUINT32(minChipsLimit);
	AtfValidator::validateInt(_descr, "minChipsLimit", minChipsLimit, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateInt(_descr, "maxBuyIn", maxBuyIn, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateInt(_descr, "ante", ante, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "itId"); size_t szItId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "itId", szItId, _checker, __FILE__, __LINE__);
	bool shortHanded; _parser.parseBOOL(shortHanded);
	AtfValidator::validateInt(_descr, "shortHanded", shortHanded, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	UINT32 noVppGainSites; _parser.parseUINT32(noVppGainSites);
	AtfValidator::validateInt(_descr, "noVppGainSites", noVppGainSites, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	PString _descbuf;
	TableCommonThin::TableStakes::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableStakes"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SET_AUTOREBUY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::Protocol_BL_USER_SET_AUTOREBUY()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::clear()
{
	entryId = 0;
	autoRebuyOpt = 0;
	autoRebuyBigBets = 0;
	fallUnderBigBets = 0;
	fallUnderPercents = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::equals(const Protocol_BL_USER_SET_AUTOREBUY& _o) const
{
	return entryId == _o.entryId &&
		autoRebuyOpt == _o.autoRebuyOpt &&
		autoRebuyBigBets == _o.autoRebuyBigBets &&
		fallUnderBigBets == _o.fallUnderBigBets &&
		fallUnderPercents == _o.fallUnderPercents;
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SET_AUTOREBUY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("autoRebuyOpt=");
	_buf.appendInt(autoRebuyOpt);
	_buf.append(',');
	_buf.append("autoRebuyBigBets=");
	_buf.appendUint(autoRebuyBigBets);
	_buf.append(',');
	_buf.append("fallUnderBigBets=");
	_buf.appendUint(fallUnderBigBets);
	_buf.append(',');
	_buf.append("fallUnderPercents=");
	_buf.appendUint(fallUnderPercents);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT8(autoRebuyOpt);
	_msg.composeUINT16(autoRebuyBigBets);
	_msg.composeUINT16(fallUnderBigBets);
	_msg.composeUINT16(fallUnderPercents);
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT8(autoRebuyOpt);
	_parser.parseUINT16(autoRebuyBigBets);
	_parser.parseUINT16(fallUnderBigBets);
	_parser.parseUINT16(fallUnderPercents);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_AUTOREBUY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	INT8 autoRebuyOpt; _parser.parseINT8(autoRebuyOpt);
	AtfValidator::validateIntRange(_descr, "autoRebuyOpt", autoRebuyOpt, 0, 100, _checker, __FILE__, __LINE__);
	UINT16 autoRebuyBigBets; _parser.parseUINT16(autoRebuyBigBets);
	AtfValidator::validateIntRange(_descr, "autoRebuyBigBets", autoRebuyBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	UINT16 fallUnderBigBets; _parser.parseUINT16(fallUnderBigBets);
	AtfValidator::validateIntRange(_descr, "fallUnderBigBets", fallUnderBigBets, 0, 1000, _checker, __FILE__, __LINE__);
	UINT16 fallUnderPercents; _parser.parseUINT16(fallUnderPercents);
	AtfValidator::validateIntRange(_descr, "fallUnderPercents", fallUnderPercents, 0, 100, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SET_AUTOREBUY_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::Protocol_BL_USER_SET_AUTOREBUY_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::Protocol_BL_USER_SET_AUTOREBUY_REPLY(Protocol_BL_USER_SET_AUTOREBUY_REPLY&& _o)
	: entryId(std::move(_o.entryId))
	, err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
{
}

BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY& BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::operator=(Protocol_BL_USER_SET_AUTOREBUY_REPLY&& _o)
{
	if(this != &_o)
	{
		entryId = std::move(_o.entryId);
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::equals(const Protocol_BL_USER_SET_AUTOREBUY_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		errDescr.equals(_o.errDescr);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SET_AUTOREBUY_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_AUTOREBUY_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITOUT
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITOUT::Protocol_BL_USER_SITOUT()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT::clear()
{
	entryId = 0;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT::equals(const Protocol_BL_USER_SITOUT& _o) const
{
	return entryId == _o.entryId;
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITOUT).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITOUT_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::Protocol_BL_USER_SITOUT_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::Protocol_BL_USER_SITOUT_REPLY(Protocol_BL_USER_SITOUT_REPLY&& _o)
	: entryId(std::move(_o.entryId))
	, err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
{
}

BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY& BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::operator=(Protocol_BL_USER_SITOUT_REPLY&& _o)
{
	if(this != &_o)
	{
		entryId = std::move(_o.entryId);
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::equals(const Protocol_BL_USER_SITOUT_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		errDescr.equals(_o.errDescr);
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITOUT_NEXTBB
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::Protocol_BL_USER_SITOUT_NEXTBB()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::clear()
{
	entryId = 0;
	sitoutBB = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::equals(const Protocol_BL_USER_SITOUT_NEXTBB& _o) const
{
	return entryId == _o.entryId &&
		sitoutBB == _o.sitoutBB;
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITOUT_NEXTBB).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("sitoutBB=");
	_buf.appendUint(sitoutBB);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeBOOL(sitoutBB);
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseBOOL(sitoutBB);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT_NEXTBB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	bool sitoutBB; _parser.parseBOOL(sitoutBB);
	AtfValidator::validateInt(_descr, "sitoutBB", sitoutBB, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SITOUT_NEXTBB_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::Protocol_BL_USER_SITOUT_NEXTBB_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::Protocol_BL_USER_SITOUT_NEXTBB_REPLY(Protocol_BL_USER_SITOUT_NEXTBB_REPLY&& _o)
	: entryId(std::move(_o.entryId))
	, err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
	, sitOutNextBlind(std::move(_o.sitOutNextBlind))
{
}

BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY& BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::operator=(Protocol_BL_USER_SITOUT_NEXTBB_REPLY&& _o)
{
	if(this != &_o)
	{
		entryId = std::move(_o.entryId);
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
		sitOutNextBlind = std::move(_o.sitOutNextBlind);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
	sitOutNextBlind = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::equals(const Protocol_BL_USER_SITOUT_NEXTBB_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		errDescr.equals(_o.errDescr) &&
		sitOutNextBlind == _o.sitOutNextBlind;
}

const char *BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SITOUT_NEXTBB_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("sitOutNextBlind=");
		_buf.appendUint(sitOutNextBlind);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(sitOutNextBlind);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(sitOutNextBlind);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SITOUT_NEXTBB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool sitOutNextBlind; _parser.parseBOOL(sitOutNextBlind);
		AtfValidator::validateInt(_descr, "sitOutNextBlind", sitOutNextBlind, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SET_3PLUS
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::Protocol_BL_USER_SET_3PLUS()
{
	clear();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::clear()
{
	entryId = 0;
	state3Plus = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::equals(const Protocol_BL_USER_SET_3PLUS& _o) const
{
	return entryId == _o.entryId &&
		state3Plus == _o.state3Plus;
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SET_3PLUS).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("state3Plus=");
	_buf.appendUint(state3Plus);
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeBOOL(state3Plus);
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseBOOL(state3Plus);
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_3PLUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	bool state3Plus; _parser.parseBOOL(state3Plus);
	AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_BL_USER_SET_3PLUS_REPLY
//=================================================================

BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::Protocol_BL_USER_SET_3PLUS_REPLY()
{
	clear();
}

#ifdef MOVE_CONSTRUCTOR_SUPPORTED

BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::Protocol_BL_USER_SET_3PLUS_REPLY(Protocol_BL_USER_SET_3PLUS_REPLY&& _o)
	: entryId(std::move(_o.entryId))
	, err(std::move(_o.err))
	, errDescr(std::move(_o.errDescr))
	, state3Plus(std::move(_o.state3Plus))
{
}

BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY& BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::operator=(Protocol_BL_USER_SET_3PLUS_REPLY&& _o)
{
	if(this != &_o)
	{
		entryId = std::move(_o.entryId);
		err = std::move(_o.err);
		errDescr = std::move(_o.errDescr);
		state3Plus = std::move(_o.state3Plus);
	}
	return *this;
}

#endif

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::clear()
{
	entryId = 0;
	err = 0;
	errDescr.clear();
	state3Plus = false;
}

bool BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::equals(const Protocol_BL_USER_SET_3PLUS_REPLY& _o) const
{
	return entryId == _o.entryId &&
		err == _o.err &&
		errDescr.equals(_o.errDescr) &&
		state3Plus == _o.state3Plus;
}

const char *BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(BL_USER_SET_3PLUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("entryId=");
	_buf.appendUint(entryId);
	_buf.append(',');
	_buf.append("err=");
	_buf.appendInt(err);
	if (err)
	{
		_buf.append(',');
		_buf.append("errDescr=");
		_buf.append(errDescr);
	}
	else
	{
		_buf.append(',');
		_buf.append("state3Plus=");
		_buf.appendUint(state3Plus);
	}
	return _buf.c_str();
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::composeMsg(CommMsgBody& _msg) const
{
	_msg.composeUINT32(entryId);
	_msg.composeINT16(err);
	if (err)
	{
		_msg.composeString(errDescr);
	}
	else
	{
		_msg.composeBOOL(state3Plus);
	}
}

void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(entryId);
	_parser.parseINT16(err);
	if (err)
	{
		_parser.parseStringP(errDescr);
	}
	else
	{
		_parser.parseBOOL(state3Plus);
	}
}

/*static*/ void BlitzLobby::cli::Protocol_BL_USER_SET_3PLUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "BL_USER_SET_3PLUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 err = 0;
	UINT32 entryId; _parser.parseUINT32(entryId);
	AtfValidator::validateInt(_descr, "entryId", entryId, _checker, __FILE__, __LINE__);
	_parser.parseINT16(err);
	AtfValidator::validateInt(_descr, "err", err, _checker, __FILE__, __LINE__);
	if (err)
	{
		_parser.parseStringN(_dummy, 0, "errDescr"); size_t szErrDescr = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDescr", szErrDescr, _checker, __FILE__, __LINE__);
	}
	else
	{
		bool state3Plus; _parser.parseBOOL(state3Plus);
		AtfValidator::validateInt(_descr, "state3Plus", state3Plus, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ bool BlitzLobby::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "cli"))
	{
		switch(_msgId)
		{
			case BL_USER_ADDON: cli::Protocol_BL_USER_ADDON::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_ADDON_REPLY: cli::Protocol_BL_USER_ADDON_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_BUYIN: cli::Protocol_BL_USER_BUYIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_BUYIN_REPLY: cli::Protocol_BL_USER_BUYIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_BUYIN_INFO: cli::Protocol_BL_USER_GET_BUYIN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_BUYIN_INFO_REPLY: cli::Protocol_BL_USER_GET_BUYIN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_ENTRIES: cli::Protocol_BL_USER_GET_ENTRIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_ENTRIES_REPLY: cli::Protocol_BL_USER_GET_ENTRIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_INFO: cli::Protocol_BL_USER_GET_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_GET_INFO_REPLY: cli::Protocol_BL_USER_GET_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_OUT: cli::Protocol_BL_USER_OUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_OUT_REPLY: cli::Protocol_BL_USER_OUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_3PLUS: cli::Protocol_BL_USER_SET_3PLUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_3PLUS_REPLY: cli::Protocol_BL_USER_SET_3PLUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_AUTOREBUY: cli::Protocol_BL_USER_SET_AUTOREBUY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SET_AUTOREBUY_REPLY: cli::Protocol_BL_USER_SET_AUTOREBUY_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITIN: cli::Protocol_BL_USER_SITIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITIN_REPLY: cli::Protocol_BL_USER_SITIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT: cli::Protocol_BL_USER_SITOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT_NEXTBB: cli::Protocol_BL_USER_SITOUT_NEXTBB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT_NEXTBB_REPLY: cli::Protocol_BL_USER_SITOUT_NEXTBB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_SITOUT_REPLY: cli::Protocol_BL_USER_SITOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case BL_USER_WHERE_REPLY: cli::Protocol_BL_USER_WHERE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

