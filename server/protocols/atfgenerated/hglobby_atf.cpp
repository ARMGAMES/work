/**
 * hglobby_atf.cpp
 *
 * This file was auto-generated from hglobby_atf.txt by ATF protocol generator. 
 * Do not edit this file directly!
 *
 * Generator used the following keys: hglobby_atf.txt
 */
 
#include "hglobby_atf.h"

//=================================================================
//                    UserId
//=================================================================

hglobby::lobby_client::UserId::UserId()
{
	clear();
}

void hglobby::lobby_client::UserId::clear()
{
	userId.clear();
}

bool hglobby::lobby_client::UserId::equals(const UserId& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId);
}

const char *hglobby::lobby_client::UserId::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::UserId::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::UserId::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::UserId::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(userId);
}

void hglobby::lobby_client::UserId::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(userId);
}

const char *hglobby::lobby_client::UserId::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void hglobby::lobby_client::UserId::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
}

/* static */ void hglobby::lobby_client::UserId::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::UserId::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB::Protocol_HG_CREATE_CLUB()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::clear()
{
	clubName.clear();
	password.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB::equals(const Protocol_HG_CREATE_CLUB& _o) const
{
	return Atf::atfPStringEquals(clubName, _o.clubName) &&
		Atf::atfPStringEquals(password, _o.password);
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB).append(")");
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(clubName);
	_msg.composeString(password);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(clubName);
	_parser.parseStringP(password);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubName", clubName);
	_jsonstr.compose("password", password);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubName", clubName);
	_jparser.parseByNameThrow("password", password);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString clubName; _jparser.validateByNameThrow("clubName", clubName);
	AtfValidator::validateIntMax(_descr, "clubName", clubName.length(), 128, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clubName", szClubName, 128, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::Protocol_HG_CREATE_CLUB_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubId = 0;
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::equals(const Protocol_HG_CREATE_CLUB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		clubId == _o.clubId &&
		Atf::atfPStringEquals(socialToken, _o.socialToken);
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubId=");
		_buf.appendUint(clubId);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(clubId);
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(clubId);
		_parser.parseStringP(socialToken);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("clubId", clubId);
		_jsonstr.compose("socialToken", socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("clubId", clubId);
		_jparser.parseByNameThrow("socialToken", socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 clubId; _parser.parseUINT32(clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    HgClubInfo
//=================================================================

hglobby::lobby_client::HgClubInfo::HgClubInfo()
{
	clear();
}

void hglobby::lobby_client::HgClubInfo::clear()
{
	clubId = 0;
	clubName.clear();
	nbMembers = 0;
	roleForUser = 0;
	memberFlags = 0;
	ordinal = 0;
	favoriteClub = false;
	clubNameColor = 0;
}

bool hglobby::lobby_client::HgClubInfo::equals(const HgClubInfo& _o) const
{
	return clubId == _o.clubId &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		nbMembers == _o.nbMembers &&
		roleForUser == _o.roleForUser &&
		memberFlags == _o.memberFlags &&
		ordinal == _o.ordinal &&
		favoriteClub == _o.favoriteClub &&
		clubNameColor == _o.clubNameColor;
}

const char *hglobby::lobby_client::HgClubInfo::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("nbMembers=");
	_buf.appendUint(nbMembers);
	_buf.append(',');
	_buf.append("roleForUser=");
	_buf.appendUint(roleForUser);
	_buf.append(',');
	_buf.append("memberFlags=");
	_buf.appendUint(memberFlags);
	_buf.append(',');
	_buf.append("ordinal=");
	_buf.appendUint(ordinal);
	_buf.append(',');
	_buf.append("favoriteClub=");
	_buf.appendUint(favoriteClub);
	_buf.append(',');
	_buf.append("clubNameColor=");
	_buf.appendUint(clubNameColor);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::HgClubInfo::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
	Atf::XmlElement::encodeAsXmlElement("nbMembers", nbMembers, _buf);
	Atf::XmlElement::encodeAsXmlElement("roleForUser", roleForUser, _buf);
	Atf::XmlElement::encodeAsXmlElement("memberFlags", memberFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("ordinal", ordinal, _buf);
	Atf::XmlElement::encodeAsXmlElement("favoriteClub", favoriteClub, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubNameColor", clubNameColor, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::HgClubInfo::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clubName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
		}
		else if (_element.equals("nbMembers"))
		{
			nbMembers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("roleForUser"))
		{
			roleForUser = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("memberFlags"))
		{
			memberFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ordinal"))
		{
			ordinal = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("favoriteClub"))
		{
			favoriteClub = (*_value.ptr() == '1');
		}
		else if (_element.equals("clubNameColor"))
		{
			clubNameColor = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::HgClubInfo::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(HgClubInfo())) // not empty
	{
		_body.composeUINT32(clubId);
		_body.composeString(clubName);
		_body.composeUINT32(nbMembers);
		_body.composeUINT32(roleForUser);
		_body.composeUINT32(memberFlags);
		_body.composeUINT32(ordinal);
		_body.composeBOOL(favoriteClub);
		_body.composeUINT32(clubNameColor);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::HgClubInfo::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(clubId);
	_parser0.parseStringP(clubName);
	_parser0.parseUINT32(nbMembers);
	_parser0.parseUINT32(roleForUser);
	_parser0.parseUINT32(memberFlags);
	_parser0.parseUINT32(ordinal);
	_parser0.parseBOOL(favoriteClub);
	_parser0.parseUINT32(clubNameColor);
}

const char *hglobby::lobby_client::HgClubInfo::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("clubName", clubName);
	_jsonstr.compose("nbMembers", nbMembers);
	_jsonstr.compose("roleForUser", roleForUser);
	_jsonstr.compose("memberFlags", memberFlags);
	_jsonstr.compose("ordinal", ordinal);
	_jsonstr.compose("favoriteClub", favoriteClub);
	_jsonstr.compose("clubNameColor", clubNameColor);
	return _buf.c_str();
}

void hglobby::lobby_client::HgClubInfo::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("clubName", clubName);
	_jparser.parseByNameThrow("nbMembers", nbMembers);
	_jparser.parseByNameThrow("roleForUser", roleForUser);
	_jparser.parseByNameThrow("memberFlags", memberFlags);
	_jparser.parseByNameThrow("ordinal", ordinal);
	_jparser.parseByNameThrow("favoriteClub", favoriteClub);
	_jparser.parseByNameThrow("clubNameColor", clubNameColor);
}

/* static */ void hglobby::lobby_client::HgClubInfo::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString clubName; _jparser.validateByNameThrow("clubName", clubName);
	AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
	UINT32 nbMembers; _jparser.validateByNameThrow("nbMembers", nbMembers);
	AtfValidator::validateInt(_descr, "nbMembers", nbMembers, _checker, __FILE__, __LINE__);
	UINT32 roleForUser; _jparser.validateByNameThrow("roleForUser", roleForUser);
	AtfValidator::validateInt(_descr, "roleForUser", roleForUser, _checker, __FILE__, __LINE__);
	UINT32 memberFlags; _jparser.validateByNameThrow("memberFlags", memberFlags);
	AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
	UINT32 ordinal; _jparser.validateByNameThrow("ordinal", ordinal);
	AtfValidator::validateInt(_descr, "ordinal", ordinal, _checker, __FILE__, __LINE__);
	bool favoriteClub; _jparser.validateByNameThrow("favoriteClub", favoriteClub);
	AtfValidator::validateInt(_descr, "favoriteClub", favoriteClub, _checker, __FILE__, __LINE__);
	UINT32 clubNameColor; _jparser.validateByNameThrow("clubNameColor", clubNameColor);
	AtfValidator::validateInt(_descr, "clubNameColor", clubNameColor, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::HgClubInfo::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
	UINT32 nbMembers; _parser0.parseUINT32(nbMembers);
	AtfValidator::validateInt(_descr, "nbMembers", nbMembers, _checker, __FILE__, __LINE__);
	UINT32 roleForUser; _parser0.parseUINT32(roleForUser);
	AtfValidator::validateInt(_descr, "roleForUser", roleForUser, _checker, __FILE__, __LINE__);
	UINT32 memberFlags; _parser0.parseUINT32(memberFlags);
	AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
	UINT32 ordinal; _parser0.parseUINT32(ordinal);
	AtfValidator::validateInt(_descr, "ordinal", ordinal, _checker, __FILE__, __LINE__);
	bool favoriteClub; _parser0.parseBOOL(favoriteClub);
	AtfValidator::validateInt(_descr, "favoriteClub", favoriteClub, _checker, __FILE__, __LINE__);
	UINT32 clubNameColor; _parser0.parseUINT32(clubNameColor);
	AtfValidator::validateInt(_descr, "clubNameColor", clubNameColor, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_USER_CLUBS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::Protocol_HG_GET_USER_CLUBS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::clear()
{
	isNewBehavior = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::equals(const Protocol_HG_GET_USER_CLUBS& _o) const
{
	return isNewBehavior == _o.isNewBehavior;
}

bool hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_USER_CLUBS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_USER_CLUBS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_USER_CLUBS).append(")");
	_buf.append(',');
	_buf.append("isNewBehavior=");
	_buf.appendUint(isNewBehavior);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_USER_CLUBS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("isNewBehavior", isNewBehavior, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("isNewBehavior"))
			{
				isNewBehavior = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(isNewBehavior);
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isNewBehavior);
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("isNewBehavior", isNewBehavior);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isNewBehavior", isNewBehavior);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_USER_CLUBS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	bool isNewBehavior; _jparser.validateByNameThrow("isNewBehavior", isNewBehavior);
	AtfValidator::validateInt(_descr, "isNewBehavior", isNewBehavior, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_USER_CLUBS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool isNewBehavior; _parser.parseBOOL(isNewBehavior);
	AtfValidator::validateInt(_descr, "isNewBehavior", isNewBehavior, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_USER_CLUBS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::Protocol_HG_GET_USER_CLUBS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubInfoListForClient.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::equals(const Protocol_HG_GET_USER_CLUBS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		clubInfoListForClient.equals(_o.clubInfoListForClient);
}

bool hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_USER_CLUBS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_USER_CLUBS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_USER_CLUBS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubInfoListForClient=");
		clubInfoListForClient.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_USER_CLUBS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		clubInfoListForClient.toXmlString("clubInfoListForClient", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("clubInfoListForClient"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< HgClubInfo, 4 > >::FromXmlString(_value, clubInfoListForClient)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		clubInfoListForClient.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		clubInfoListForClient.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("clubInfoListForClient", clubInfoListForClient);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("clubInfoListForClient", clubInfoListForClient);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_USER_CLUBS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< HgClubInfo > clubInfoListForClient; _jparser.validateByNameThrow("clubInfoListForClient", clubInfoListForClient);
		AtfValidator::validateInt(_descr, "clubInfoListForClient", clubInfoListForClient.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_USER_CLUBS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szClubInfoListForClient = Atf::LAtfVector< HgClubInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubInfoListForClient"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "clubInfoListForClient", szClubInfoListForClient, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_ADD_USER_CLUB
//=================================================================

hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::Protocol_HG_ADD_USER_CLUB()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::clear()
{
	clubId = 0;
	clubPassword.clear();
	comment.clear();
	notUsedUserId.clear();
}

bool hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::equals(const Protocol_HG_ADD_USER_CLUB& _o) const
{
	return clubId == _o.clubId &&
		Atf::atfPStringEquals(clubPassword, _o.clubPassword) &&
		Atf::atfPStringEquals(comment, _o.comment) &&
		Atf::atfPStringEquals(notUsedUserId, _o.notUsedUserId);
}

bool hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::equals(Atf::MessageProtocol* _other) const
{
	if (HG_ADD_USER_CLUB != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_ADD_USER_CLUB*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_ADD_USER_CLUB).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubPassword=");
	_buf.append(clubPassword);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("notUsedUserId=");
	_buf.append(notUsedUserId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_ADD_USER_CLUB).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubPassword", clubPassword, _buf);
	Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	Atf::XmlElement::encodeAsXmlElement("notUsedUserId", notUsedUserId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clubPassword"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clubPassword)) return false;
			}
			else if (_element.equals("comment"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
			}
			else if (_element.equals("notUsedUserId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, notUsedUserId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(clubPassword);
	_msg.composeString(comment);
	_msg.composeString(notUsedUserId);
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(clubPassword);
	_parser.parseStringP(comment);
	if(_parser.parseEnded()) return;
	_parser.parseStringP(notUsedUserId);
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("clubPassword", clubPassword);
	_jsonstr.compose("comment", comment);
	_jsonstr.compose("notUsedUserId", notUsedUserId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("clubPassword", clubPassword);
	_jparser.parseByNameThrow("comment", comment);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("notUsedUserId", notUsedUserId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ADD_USER_CLUB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString clubPassword; _jparser.validateByNameThrow("clubPassword", clubPassword);
	AtfValidator::validateIntMax(_descr, "clubPassword", clubPassword.length(), 128, _checker, __FILE__, __LINE__);
	PString comment; _jparser.validateByNameThrow("comment", comment);
	AtfValidator::validateIntMax(_descr, "comment", comment.length(), 4096, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	PString notUsedUserId; _jparser.validateByNameThrow("notUsedUserId", notUsedUserId);
	AtfValidator::validateIntMax(_descr, "notUsedUserId", notUsedUserId.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ADD_USER_CLUB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clubPassword"); size_t szClubPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clubPassword", szClubPassword, 128, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "comment", szComment, 4096, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	_parser.parseStringN(_dummy, 0, "notUsedUserId"); size_t szNotUsedUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "notUsedUserId", szNotUsedUserId, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_ADD_USER_CLUB_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::Protocol_HG_ADD_USER_CLUB_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubName.clear();
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::equals(const Protocol_HG_ADD_USER_CLUB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken);
}

bool hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_ADD_USER_CLUB_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_ADD_USER_CLUB_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_ADD_USER_CLUB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_ADD_USER_CLUB_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("clubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(clubName);
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(clubName);
		_parser.parseStringP(socialToken);
	}
}

const char *hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("clubName", clubName);
		_jsonstr.compose("socialToken", socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("clubName", clubName);
		_jparser.parseByNameThrow("socialToken", socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ADD_USER_CLUB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString clubName; _jparser.validateByNameThrow("clubName", clubName);
		AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ADD_USER_CLUB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    GamesMembershipStatus
//=================================================================

hglobby::lobby_client::GamesMembershipStatus::GamesMembershipStatus()
{
	clear();
}

void hglobby::lobby_client::GamesMembershipStatus::clear()
{
	status = 0;
}

bool hglobby::lobby_client::GamesMembershipStatus::equals(const GamesMembershipStatus& _o) const
{
	return status == _o.status;
}

const char *hglobby::lobby_client::GamesMembershipStatus::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::GamesMembershipStatus::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::GamesMembershipStatus::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::GamesMembershipStatus::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(status);
}

void hglobby::lobby_client::GamesMembershipStatus::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(status);
}

const char *hglobby::lobby_client::GamesMembershipStatus::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("status", status);
	return _buf.c_str();
}

void hglobby::lobby_client::GamesMembershipStatus::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("status", status);
}

/* static */ void hglobby::lobby_client::GamesMembershipStatus::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateIntRange(_descr, "status", status, eHgMembershipStatusApproved, eHgMembershipStatusLastAndInvalid, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::GamesMembershipStatus::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	UINT32 status; _parser.parseUINT32(status);
	AtfValidator::validateIntRange(_descr, "status", status, eHgMembershipStatusApproved, eHgMembershipStatusLastAndInvalid, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_GET_PLAYERS_BASED_ON_STATUS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::clear()
{
	clubId = 0;
	statuses.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::equals(const Protocol_HG_GET_PLAYERS_BASED_ON_STATUS& _o) const
{
	return clubId == _o.clubId &&
		statuses.equals(_o.statuses);
}

bool hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_PLAYERS_BASED_ON_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_PLAYERS_BASED_ON_STATUS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_PLAYERS_BASED_ON_STATUS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("statuses=");
	statuses.toTraceString(_buf);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_PLAYERS_BASED_ON_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	statuses.toXmlString("statuses", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("statuses"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GamesMembershipStatus, 4 > >::FromXmlString(_value, statuses)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	statuses.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	statuses.parseMsg(_parser);
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("statuses", statuses);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("statuses", statuses);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_PLAYERS_BASED_ON_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< GamesMembershipStatus > statuses; _jparser.validateByNameThrow("statuses", statuses);
	AtfValidator::validateIntMax(_descr, "statuses", statuses.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_PLAYERS_BASED_ON_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szStatuses = Atf::LAtfVector< GamesMembershipStatus, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("statuses"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "statuses", szStatuses, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    PlayerListElement
//=================================================================

hglobby::lobby_client::PlayerListElement::PlayerListElement()
{
	clear();
}

void hglobby::lobby_client::PlayerListElement::clear()
{
	userId.clear();
	city.clear();
	comment.clear();
	status = 0;
	role = 0;
	enrolled.setNull();
	flags = 0;
}

bool hglobby::lobby_client::PlayerListElement::equals(const PlayerListElement& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(city, _o.city) &&
		Atf::atfPStringEquals(comment, _o.comment) &&
		status == _o.status &&
		role == _o.role &&
		enrolled.equals(_o.enrolled) &&
		flags == _o.flags;
}

const char *hglobby::lobby_client::PlayerListElement::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("city=");
	_buf.append(city);
	_buf.append(',');
	_buf.append("comment=");
	_buf.append(comment);
	_buf.append(',');
	_buf.append("status=");
	_buf.appendUint(status);
	_buf.append(',');
	_buf.append("role=");
	_buf.appendUint(role);
	_buf.append(',');
	_buf.append("enrolled=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, enrolled);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::PlayerListElement::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("city", city, _buf);
	Atf::XmlElement::encodeAsXmlElement("comment", comment, _buf);
	Atf::XmlElement::encodeAsXmlElement("status", status, _buf);
	Atf::XmlElement::encodeAsXmlElement("role", role, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "enrolled", enrolled);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::PlayerListElement::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("city"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, city)) return false;
		}
		else if (_element.equals("comment"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, comment)) return false;
		}
		else if (_element.equals("status"))
		{
			status = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("role"))
		{
			role = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("enrolled"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, enrolled);
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::PlayerListElement::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(PlayerListElement())) // not empty
	{
		_body.composeString(userId);
		_body.composeString(city);
		_body.composeString(comment);
		_body.composeUINT32(status);
		_body.composeUINT32(role);
		_body.composeSrvTime(enrolled);
		_body.composeUINT32(flags);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::PlayerListElement::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseStringP(city);
	_parser0.parseStringP(comment);
	_parser0.parseUINT32(status);
	_parser0.parseUINT32(role);
	_parser0.parseSrvTime(enrolled);
	_parser0.parseUINT32(flags);
}

const char *hglobby::lobby_client::PlayerListElement::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("city", city);
	_jsonstr.compose("comment", comment);
	_jsonstr.compose("status", status);
	_jsonstr.compose("role", role);
	_jsonstr.compose("enrolled", enrolled);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void hglobby::lobby_client::PlayerListElement::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("city", city);
	_jparser.parseByNameThrow("comment", comment);
	_jparser.parseByNameThrow("status", status);
	_jparser.parseByNameThrow("role", role);
	_jparser.parseByNameThrow("enrolled", enrolled);
	_jparser.parseByNameThrow("flags", flags);
}

/* static */ void hglobby::lobby_client::PlayerListElement::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	PString city; _jparser.validateByNameThrow("city", city);
	AtfValidator::validateInt(_descr, "city", city.length(), _checker, __FILE__, __LINE__);
	PString comment; _jparser.validateByNameThrow("comment", comment);
	AtfValidator::validateInt(_descr, "comment", comment.length(), _checker, __FILE__, __LINE__);
	UINT32 status; _jparser.validateByNameThrow("status", status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 role; _jparser.validateByNameThrow("role", role);
	AtfValidator::validateInt(_descr, "role", role, _checker, __FILE__, __LINE__);
	SrvTime enrolled; _jparser.validateByNameThrow("enrolled", enrolled);
	AtfValidator::validateSrvDateTime(_descr, "enrolled", enrolled, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::PlayerListElement::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "city"); size_t szCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "city", szCity, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "comment"); size_t szComment = strlen(_dummy);
	AtfValidator::validateInt(_descr, "comment", szComment, _checker, __FILE__, __LINE__);
	UINT32 status; _parser0.parseUINT32(status);
	AtfValidator::validateInt(_descr, "status", status, _checker, __FILE__, __LINE__);
	UINT32 role; _parser0.parseUINT32(role);
	AtfValidator::validateInt(_descr, "role", role, _checker, __FILE__, __LINE__);
	SrvTime enrolled; _parser0.parseSrvTime(enrolled);
	AtfValidator::validateSrvDateTime(_descr, "enrolled", enrolled, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	playerList.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::equals(const Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		playerList.equals(_o.playerList);
}

bool hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_PLAYERS_BASED_ON_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_PLAYERS_BASED_ON_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("playerList=");
		playerList.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_PLAYERS_BASED_ON_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		playerList.toXmlString("playerList", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("playerList"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< PlayerListElement, 4 > >::FromXmlString(_value, playerList)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		playerList.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		playerList.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("playerList", playerList);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("playerList", playerList);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_PLAYERS_BASED_ON_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< PlayerListElement > playerList; _jparser.validateByNameThrow("playerList", playerList);
		AtfValidator::validateInt(_descr, "playerList", playerList.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_PLAYERS_BASED_ON_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szPlayerList = Atf::LAtfVector< PlayerListElement, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("playerList"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "playerList", szPlayerList, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_PLAYERS_STATUS
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::Protocol_HG_CHANGE_PLAYERS_STATUS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::clear()
{
	clubId = 0;
	action = 0;
	usersToChange.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::equals(const Protocol_HG_CHANGE_PLAYERS_STATUS& _o) const
{
	return clubId == _o.clubId &&
		action == _o.action &&
		usersToChange.equals(_o.usersToChange);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_PLAYERS_STATUS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_PLAYERS_STATUS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_PLAYERS_STATUS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("action=");
	_buf.appendUint(action);
	_buf.append(',');
	_buf.append("usersToChange=");
	usersToChange.toTraceString(_buf);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_PLAYERS_STATUS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("action", action, _buf);
	usersToChange.toXmlString("usersToChange", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("action"))
			{
				action = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("usersToChange"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserId, 4 > >::FromXmlString(_value, usersToChange)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(action);
	usersToChange.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(action);
	usersToChange.parseMsg(_parser);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("action", action);
	_jsonstr.compose("usersToChange", usersToChange);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("action", action);
	_jparser.parseByNameThrow("usersToChange", usersToChange);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_PLAYERS_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 action; _jparser.validateByNameThrow("action", action);
	AtfValidator::validateIntRange(_descr, "action", action, eHgAcceptPlayer, eHgRemoveApplication, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UserId > usersToChange; _jparser.validateByNameThrow("usersToChange", usersToChange);
	AtfValidator::validateIntMax(_descr, "usersToChange", usersToChange.size(), 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_PLAYERS_STATUS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 action; _parser.parseUINT32(action);
	AtfValidator::validateIntRange(_descr, "action", action, eHgAcceptPlayer, eHgRemoveApplication, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szUsersToChange = Atf::LAtfVector< UserId, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("usersToChange"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "usersToChange", szUsersToChange, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::equals(const Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_PLAYERS_STATUS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_PLAYERS_STATUS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_PLAYERS_STATUS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("socialToken", socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("socialToken", socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_PLAYERS_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_PLAYERS_STATUS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_PASSWORD
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::Protocol_HG_CHANGE_CLUB_PASSWORD()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::clear()
{
	clubId = 0;
	password.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::equals(const Protocol_HG_CHANGE_CLUB_PASSWORD& _o) const
{
	return clubId == _o.clubId &&
		Atf::atfPStringEquals(password, _o.password);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_CLUB_PASSWORD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_CLUB_PASSWORD*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_PASSWORD).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("password=");
	_buf.append(password);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_CLUB_PASSWORD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(password);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(password);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("password", password);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("password", password);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_PASSWORD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString password; _jparser.validateByNameThrow("password", password);
	AtfValidator::validateIntMax(_descr, "password", password.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_PASSWORD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "password", szPassword, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::equals(const Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_CLUB_PASSWORD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_PASSWORD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_CLUB_PASSWORD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_PASSWORD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_PASSWORD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_OPTIONS
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::Protocol_HG_CHANGE_CLUB_OPTIONS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::clear()
{
	clubId = 0;
	seasonLength = 0;
	showClubStandings = false;
	showPlayerStats = false;
	currency.clear();
	showFounderFullName = false;
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::equals(const Protocol_HG_CHANGE_CLUB_OPTIONS& _o) const
{
	return clubId == _o.clubId &&
		seasonLength == _o.seasonLength &&
		showClubStandings == _o.showClubStandings &&
		showPlayerStats == _o.showPlayerStats &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		showFounderFullName == _o.showFounderFullName;
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_CLUB_OPTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_CLUB_OPTIONS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("seasonLength=");
	_buf.appendUint(seasonLength);
	_buf.append(',');
	_buf.append("showClubStandings=");
	_buf.appendUint(showClubStandings);
	_buf.append(',');
	_buf.append("showPlayerStats=");
	_buf.appendUint(showPlayerStats);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("showFounderFullName=");
	_buf.appendUint(showFounderFullName);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_CLUB_OPTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonLength", seasonLength, _buf);
	Atf::XmlElement::encodeAsXmlElement("showClubStandings", showClubStandings, _buf);
	Atf::XmlElement::encodeAsXmlElement("showPlayerStats", showPlayerStats, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("showFounderFullName", showFounderFullName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seasonLength"))
			{
				seasonLength = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("showClubStandings"))
			{
				showClubStandings = (*_value.ptr() == '1');
			}
			else if (_element.equals("showPlayerStats"))
			{
				showPlayerStats = (*_value.ptr() == '1');
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("showFounderFullName"))
			{
				showFounderFullName = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(seasonLength);
	_msg.composeBOOL(showClubStandings);
	_msg.composeBOOL(showPlayerStats);
	_msg.composeString(currency);
	_msg.composeBOOL(showFounderFullName);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(seasonLength);
	_parser.parseBOOL(showClubStandings);
	_parser.parseBOOL(showPlayerStats);
	_parser.parseStringP(currency);
	_parser.parseBOOL(showFounderFullName);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("seasonLength", seasonLength);
	_jsonstr.compose("showClubStandings", showClubStandings);
	_jsonstr.compose("showPlayerStats", showPlayerStats);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("showFounderFullName", showFounderFullName);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("seasonLength", seasonLength);
	_jparser.parseByNameThrow("showClubStandings", showClubStandings);
	_jparser.parseByNameThrow("showPlayerStats", showPlayerStats);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("showFounderFullName", showFounderFullName);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonLength; _jparser.validateByNameThrow("seasonLength", seasonLength);
	AtfValidator::validateIntRange(_descr, "seasonLength", seasonLength, eHgClubSeasonsYearly, eHgClubSeasonsMonthly, _checker, __FILE__, __LINE__);
	bool showClubStandings; _jparser.validateByNameThrow("showClubStandings", showClubStandings);
	AtfValidator::validateInt(_descr, "showClubStandings", showClubStandings, _checker, __FILE__, __LINE__);
	bool showPlayerStats; _jparser.validateByNameThrow("showPlayerStats", showPlayerStats);
	AtfValidator::validateInt(_descr, "showPlayerStats", showPlayerStats, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 5, _checker, __FILE__, __LINE__);
	bool showFounderFullName; _jparser.validateByNameThrow("showFounderFullName", showFounderFullName);
	AtfValidator::validateInt(_descr, "showFounderFullName", showFounderFullName, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonLength; _parser.parseUINT32(seasonLength);
	AtfValidator::validateIntRange(_descr, "seasonLength", seasonLength, eHgClubSeasonsYearly, eHgClubSeasonsMonthly, _checker, __FILE__, __LINE__);
	bool showClubStandings; _parser.parseBOOL(showClubStandings);
	AtfValidator::validateInt(_descr, "showClubStandings", showClubStandings, _checker, __FILE__, __LINE__);
	bool showPlayerStats; _parser.parseBOOL(showPlayerStats);
	AtfValidator::validateInt(_descr, "showPlayerStats", showPlayerStats, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	bool showFounderFullName; _parser.parseBOOL(showFounderFullName);
	AtfValidator::validateInt(_descr, "showFounderFullName", showFounderFullName, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::equals(const Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_CLUB_OPTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_CLUB_OPTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_IMAGE
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::Protocol_HG_CHANGE_CLUB_IMAGE()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::clear()
{
	clubId = 0;
	image.clear();
	isHeader = false;
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::equals(const Protocol_HG_CHANGE_CLUB_IMAGE& _o) const
{
	return clubId == _o.clubId &&
		image.size() == _o.image.size() && memcmp(image.ptr(), _o.image.ptr(), image.size()) == 0 &&
		isHeader == _o.isHeader;
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_CLUB_IMAGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_CLUB_IMAGE*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_IMAGE).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("image=");
	Atf::AtfTempl<PBlock>::ToTraceString(_buf, image);
	_buf.append(',');
	_buf.append("isHeader=");
	_buf.appendUint(isHeader);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_CLUB_IMAGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("image", image, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHeader", isHeader, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("image"))
			{
				Atf::XmlElement::_movePBlockWithNullStrip(_value, image);
			}
			else if (_element.equals("isHeader"))
			{
				isHeader = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg._composeVarBlock(image.ptr(), image.size());
	_msg.composeBOOL(isHeader);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parsePBlock(image);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isHeader);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("image", image);
	_jsonstr.compose("isHeader", isHeader);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("image", image);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isHeader", isHeader);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PBlock image; _jparser.validateByNameThrow("image", image);
	AtfValidator::validateIntMax(_descr, "image", image.size(), 10485760, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool isHeader; _jparser.validateByNameThrow("isHeader", isHeader);
	AtfValidator::validateInt(_descr, "isHeader", isHeader, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_IMAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	const BYTE* image; size_t szImage; _parser._parseVarBlock(image, szImage);  /*image*/
	AtfValidator::validateIntMax(_descr, "image", szImage, 10485760, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool isHeader; _parser.parseBOOL(isHeader);
	AtfValidator::validateInt(_descr, "isHeader", isHeader, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_IMAGE_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::equals(const Protocol_HG_CHANGE_CLUB_IMAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_CLUB_IMAGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_CLUB_IMAGE_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_IMAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_CLUB_IMAGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_IMAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASONS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::Protocol_HG_GET_CLUB_SEASONS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::equals(const Protocol_HG_GET_CLUB_SEASONS& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_SEASONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_SEASONS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASONS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_SEASONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubSeason
//=================================================================

hglobby::lobby_client::ClubSeason::ClubSeason()
{
	clear();
}

void hglobby::lobby_client::ClubSeason::clear()
{
	seasonId = 0;
	timeFrom.setNull();
	timeTo.setNull();
	closed = false;
	seasonType = 0;
	seasonName.clear();
}

bool hglobby::lobby_client::ClubSeason::equals(const ClubSeason& _o) const
{
	return seasonId == _o.seasonId &&
		timeFrom.equals(_o.timeFrom) &&
		timeTo.equals(_o.timeTo) &&
		closed == _o.closed &&
		seasonType == _o.seasonType &&
		Atf::atfPStringEquals(seasonName, _o.seasonName);
}

const char *hglobby::lobby_client::ClubSeason::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("timeFrom=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, timeFrom);
	_buf.append(',');
	_buf.append("timeTo=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, timeTo);
	_buf.append(',');
	_buf.append("closed=");
	_buf.appendUint(closed);
	_buf.append(',');
	_buf.append("seasonType=");
	_buf.appendUint(seasonType);
	_buf.append(',');
	_buf.append("seasonName=");
	_buf.append(seasonName);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::ClubSeason::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("seasonId", seasonId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "timeFrom", timeFrom);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "timeTo", timeTo);
	Atf::XmlElement::encodeAsXmlElement("closed", closed, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonType", seasonType, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonName", seasonName, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::ClubSeason::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("seasonId"))
		{
			seasonId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("timeFrom"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, timeFrom);
		}
		else if (_element.equals("timeTo"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, timeTo);
		}
		else if (_element.equals("closed"))
		{
			closed = (*_value.ptr() == '1');
		}
		else if (_element.equals("seasonType"))
		{
			seasonType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("seasonName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, seasonName)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::ClubSeason::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClubSeason())) // not empty
	{
		_body.composeUINT32(seasonId);
		_body.composeSrvTime(timeFrom);
		_body.composeSrvTime(timeTo);
		_body.composeBOOL(closed);
		_body.composeUINT32(seasonType);
		_body.composeString(seasonName);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubSeason::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(seasonId);
	_parser0.parseSrvTime(timeFrom);
	_parser0.parseSrvTime(timeTo);
	_parser0.parseBOOL(closed);
	_parser0.parseUINT32(seasonType);
	_parser0.parseStringP(seasonName);
}

const char *hglobby::lobby_client::ClubSeason::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("seasonId", seasonId);
	_jsonstr.compose("timeFrom", timeFrom);
	_jsonstr.compose("timeTo", timeTo);
	_jsonstr.compose("closed", closed);
	_jsonstr.compose("seasonType", seasonType);
	_jsonstr.compose("seasonName", seasonName);
	return _buf.c_str();
}

void hglobby::lobby_client::ClubSeason::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("seasonId", seasonId);
	_jparser.parseByNameThrow("timeFrom", timeFrom);
	_jparser.parseByNameThrow("timeTo", timeTo);
	_jparser.parseByNameThrow("closed", closed);
	_jparser.parseByNameThrow("seasonType", seasonType);
	_jparser.parseByNameThrow("seasonName", seasonName);
}

/* static */ void hglobby::lobby_client::ClubSeason::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seasonId; _jparser.validateByNameThrow("seasonId", seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _jparser.validateByNameThrow("timeFrom", timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeTo; _jparser.validateByNameThrow("timeTo", timeTo);
	AtfValidator::validateSrvDateTime(_descr, "timeTo", timeTo, _checker, __FILE__, __LINE__);
	bool closed; _jparser.validateByNameThrow("closed", closed);
	AtfValidator::validateInt(_descr, "closed", closed, _checker, __FILE__, __LINE__);
	UINT32 seasonType; _jparser.validateByNameThrow("seasonType", seasonType);
	AtfValidator::validateInt(_descr, "seasonType", seasonType, _checker, __FILE__, __LINE__);
	PString seasonName; _jparser.validateByNameThrow("seasonName", seasonName);
	AtfValidator::validateInt(_descr, "seasonName", seasonName.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::ClubSeason::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 seasonId; _parser0.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _parser0.parseSrvTime(timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeTo; _parser0.parseSrvTime(timeTo);
	AtfValidator::validateSrvDateTime(_descr, "timeTo", timeTo, _checker, __FILE__, __LINE__);
	bool closed; _parser0.parseBOOL(closed);
	AtfValidator::validateInt(_descr, "closed", closed, _checker, __FILE__, __LINE__);
	UINT32 seasonType; _parser0.parseUINT32(seasonType);
	AtfValidator::validateInt(_descr, "seasonType", seasonType, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "seasonName"); size_t szSeasonName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "seasonName", szSeasonName, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASONS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::Protocol_HG_GET_CLUB_SEASONS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	seasons.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::equals(const Protocol_HG_GET_CLUB_SEASONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		seasons.equals(_o.seasons);
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_SEASONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_SEASONS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("seasons=");
		seasons.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_SEASONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		seasons.toXmlString("seasons", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("seasons"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClubSeason, 4 > >::FromXmlString(_value, seasons)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		seasons.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		seasons.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("seasons", seasons);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("seasons", seasons);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ClubSeason > seasons; _jparser.validateByNameThrow("seasons", seasons);
		AtfValidator::validateInt(_descr, "seasons", seasons.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSeasons = Atf::LAtfVector< ClubSeason, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("seasons"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "seasons", szSeasons, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASON_RANKS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::Protocol_HG_GET_CLUB_SEASON_RANKS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::clear()
{
	clubId = 0;
	seasonId = 0;
	isPlayMoney = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::equals(const Protocol_HG_GET_CLUB_SEASON_RANKS& _o) const
{
	return clubId == _o.clubId &&
		seasonId == _o.seasonId &&
		isPlayMoney == _o.isPlayMoney;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_SEASON_RANKS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_SEASON_RANKS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASON_RANKS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_SEASON_RANKS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonId", seasonId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seasonId"))
			{
				seasonId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(seasonId);
	_msg.composeBOOL(isPlayMoney);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(seasonId);
	_parser.parseBOOL(isPlayMoney);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("seasonId", seasonId);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("seasonId", seasonId);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_RANKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _jparser.validateByNameThrow("seasonId", seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_RANKS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _parser.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubSeasonUserRank
//=================================================================

hglobby::lobby_client::ClubSeasonUserRank::ClubSeasonUserRank()
{
	clear();
}

void hglobby::lobby_client::ClubSeasonUserRank::clear()
{
	userId.clear();
	pointsTotal = 0;
	gamesPlayed = 0;
	rank = 0;
}

bool hglobby::lobby_client::ClubSeasonUserRank::equals(const ClubSeasonUserRank& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		pointsTotal == _o.pointsTotal &&
		gamesPlayed == _o.gamesPlayed &&
		rank == _o.rank;
}

const char *hglobby::lobby_client::ClubSeasonUserRank::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("pointsTotal=");
	_buf.appendUint64(pointsTotal);
	_buf.append(',');
	_buf.append("gamesPlayed=");
	_buf.appendUint(gamesPlayed);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::ClubSeasonUserRank::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pointsTotal", pointsTotal, _buf);
	Atf::XmlElement::encodeAsXmlElement("gamesPlayed", gamesPlayed, _buf);
	Atf::XmlElement::encodeAsXmlElement("rank", rank, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::ClubSeasonUserRank::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("pointsTotal"))
		{
			pointsTotal = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("gamesPlayed"))
		{
			gamesPlayed = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rank"))
		{
			rank = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::ClubSeasonUserRank::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClubSeasonUserRank())) // not empty
	{
		_body.composeString(userId);
		_body.composeUINT64(pointsTotal);
		_body.composeUINT32(gamesPlayed);
		_body.composeUINT32(rank);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubSeasonUserRank::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseUINT64(pointsTotal);
	_parser0.parseUINT32(gamesPlayed);
	_parser0.parseUINT32(rank);
}

const char *hglobby::lobby_client::ClubSeasonUserRank::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("pointsTotal", pointsTotal);
	_jsonstr.compose("gamesPlayed", gamesPlayed);
	_jsonstr.compose("rank", rank);
	return _buf.c_str();
}

void hglobby::lobby_client::ClubSeasonUserRank::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("pointsTotal", pointsTotal);
	_jparser.parseByNameThrow("gamesPlayed", gamesPlayed);
	_jparser.parseByNameThrow("rank", rank);
}

/* static */ void hglobby::lobby_client::ClubSeasonUserRank::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	UINT64 pointsTotal; _jparser.validateByNameThrow("pointsTotal", pointsTotal);
	AtfValidator::validateUint(_descr, "pointsTotal", pointsTotal, _checker, __FILE__, __LINE__);
	UINT32 gamesPlayed; _jparser.validateByNameThrow("gamesPlayed", gamesPlayed);
	AtfValidator::validateInt(_descr, "gamesPlayed", gamesPlayed, _checker, __FILE__, __LINE__);
	UINT32 rank; _jparser.validateByNameThrow("rank", rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::ClubSeasonUserRank::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT64 pointsTotal; _parser0.parseUINT64(pointsTotal);
	AtfValidator::validateUint(_descr, "pointsTotal", pointsTotal, _checker, __FILE__, __LINE__);
	UINT32 gamesPlayed; _parser0.parseUINT32(gamesPlayed);
	AtfValidator::validateInt(_descr, "gamesPlayed", gamesPlayed, _checker, __FILE__, __LINE__);
	UINT32 rank; _parser0.parseUINT32(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	ranks.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::equals(const Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		ranks.equals(_o.ranks);
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_SEASON_RANKS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASON_RANKS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("ranks=");
		ranks.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_SEASON_RANKS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		ranks.toXmlString("ranks", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("ranks"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClubSeasonUserRank, 4 > >::FromXmlString(_value, ranks)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		ranks.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		ranks.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("ranks", ranks);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("ranks", ranks);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_RANKS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ClubSeasonUserRank > ranks; _jparser.validateByNameThrow("ranks", ranks);
		AtfValidator::validateInt(_descr, "ranks", ranks.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_RANKS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szRanks = Atf::LAtfVector< ClubSeasonUserRank, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ranks"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ranks", szRanks, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASON_STATS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::Protocol_HG_GET_CLUB_SEASON_STATS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::clear()
{
	clubId = 0;
	seasonId = 0;
	isPlayMoney = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::equals(const Protocol_HG_GET_CLUB_SEASON_STATS& _o) const
{
	return clubId == _o.clubId &&
		seasonId == _o.seasonId &&
		isPlayMoney == _o.isPlayMoney;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_SEASON_STATS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_SEASON_STATS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASON_STATS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_SEASON_STATS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonId", seasonId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seasonId"))
			{
				seasonId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isPlayMoney"))
			{
				isPlayMoney = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(seasonId);
	_msg.composeBOOL(isPlayMoney);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(seasonId);
	_parser.parseBOOL(isPlayMoney);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("seasonId", seasonId);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("seasonId", seasonId);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _jparser.validateByNameThrow("seasonId", seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_STATS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _parser.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubSeasonUserStats
//=================================================================

hglobby::lobby_client::ClubSeasonUserStats::ClubSeasonUserStats()
{
	clear();
}

void hglobby::lobby_client::ClubSeasonUserStats::clear()
{
	userId.clear();
	userCity.clear();
	userAvatar = 0;
	qualifiedGames = 0;
	bestTournPlace = 0;
	bestTournPlaceTo = 0;
	playersInbestTourn = 0;
	worstTournPlace = 0;
	worstTournPlaceTo = 0;
	playersInWorstTourn = 0;
	inTheMoney = 0;
	points = 0;
	goldFinishes = 0;
	silverFinishes = 0;
	bronzeFinishes = 0;
	averagePlace = 0;
	rank = 0;
	knockouts = 0;
	memberFrom.setNull();
}

bool hglobby::lobby_client::ClubSeasonUserStats::equals(const ClubSeasonUserStats& _o) const
{
	return Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(userCity, _o.userCity) &&
		userAvatar == _o.userAvatar &&
		qualifiedGames == _o.qualifiedGames &&
		bestTournPlace == _o.bestTournPlace &&
		bestTournPlaceTo == _o.bestTournPlaceTo &&
		playersInbestTourn == _o.playersInbestTourn &&
		worstTournPlace == _o.worstTournPlace &&
		worstTournPlaceTo == _o.worstTournPlaceTo &&
		playersInWorstTourn == _o.playersInWorstTourn &&
		inTheMoney == _o.inTheMoney &&
		points == _o.points &&
		goldFinishes == _o.goldFinishes &&
		silverFinishes == _o.silverFinishes &&
		bronzeFinishes == _o.bronzeFinishes &&
		averagePlace == _o.averagePlace &&
		rank == _o.rank &&
		knockouts == _o.knockouts &&
		memberFrom.equals(_o.memberFrom);
}

const char *hglobby::lobby_client::ClubSeasonUserStats::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("userCity=");
	_buf.append(userCity);
	_buf.append(',');
	_buf.append("userAvatar=");
	_buf.appendUint(userAvatar);
	_buf.append(',');
	_buf.append("qualifiedGames=");
	_buf.appendUint(qualifiedGames);
	_buf.append(',');
	_buf.append("bestTournPlace=");
	_buf.appendUint(bestTournPlace);
	_buf.append(',');
	_buf.append("bestTournPlaceTo=");
	_buf.appendUint(bestTournPlaceTo);
	_buf.append(',');
	_buf.append("playersInbestTourn=");
	_buf.appendUint(playersInbestTourn);
	_buf.append(',');
	_buf.append("worstTournPlace=");
	_buf.appendUint(worstTournPlace);
	_buf.append(',');
	_buf.append("worstTournPlaceTo=");
	_buf.appendUint(worstTournPlaceTo);
	_buf.append(',');
	_buf.append("playersInWorstTourn=");
	_buf.appendUint(playersInWorstTourn);
	_buf.append(',');
	_buf.append("inTheMoney=");
	_buf.appendUint(inTheMoney);
	_buf.append(',');
	_buf.append("points=");
	_buf.appendUint64(points);
	_buf.append(',');
	_buf.append("goldFinishes=");
	_buf.appendUint(goldFinishes);
	_buf.append(',');
	_buf.append("silverFinishes=");
	_buf.appendUint(silverFinishes);
	_buf.append(',');
	_buf.append("bronzeFinishes=");
	_buf.appendUint(bronzeFinishes);
	_buf.append(',');
	_buf.append("averagePlace=");
	_buf.appendUint(averagePlace);
	_buf.append(',');
	_buf.append("rank=");
	_buf.appendUint(rank);
	_buf.append(',');
	_buf.append("knockouts=");
	_buf.appendUint(knockouts);
	_buf.append(',');
	_buf.append("memberFrom=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, memberFrom);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::ClubSeasonUserStats::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userCity", userCity, _buf);
	Atf::XmlElement::encodeAsXmlElement("userAvatar", userAvatar, _buf);
	Atf::XmlElement::encodeAsXmlElement("qualifiedGames", qualifiedGames, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestTournPlace", bestTournPlace, _buf);
	Atf::XmlElement::encodeAsXmlElement("bestTournPlaceTo", bestTournPlaceTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("playersInbestTourn", playersInbestTourn, _buf);
	Atf::XmlElement::encodeAsXmlElement("worstTournPlace", worstTournPlace, _buf);
	Atf::XmlElement::encodeAsXmlElement("worstTournPlaceTo", worstTournPlaceTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("playersInWorstTourn", playersInWorstTourn, _buf);
	Atf::XmlElement::encodeAsXmlElement("inTheMoney", inTheMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("points", points, _buf);
	Atf::XmlElement::encodeAsXmlElement("goldFinishes", goldFinishes, _buf);
	Atf::XmlElement::encodeAsXmlElement("silverFinishes", silverFinishes, _buf);
	Atf::XmlElement::encodeAsXmlElement("bronzeFinishes", bronzeFinishes, _buf);
	Atf::XmlElement::encodeAsXmlElement("averagePlace", averagePlace, _buf);
	Atf::XmlElement::encodeAsXmlElement("rank", rank, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockouts", knockouts, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "memberFrom", memberFrom);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::ClubSeasonUserStats::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("userCity"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userCity)) return false;
		}
		else if (_element.equals("userAvatar"))
		{
			userAvatar = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("qualifiedGames"))
		{
			qualifiedGames = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bestTournPlace"))
		{
			bestTournPlace = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bestTournPlaceTo"))
		{
			bestTournPlaceTo = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playersInbestTourn"))
		{
			playersInbestTourn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("worstTournPlace"))
		{
			worstTournPlace = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("worstTournPlaceTo"))
		{
			worstTournPlaceTo = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playersInWorstTourn"))
		{
			playersInWorstTourn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("inTheMoney"))
		{
			inTheMoney = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("points"))
		{
			points = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("goldFinishes"))
		{
			goldFinishes = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("silverFinishes"))
		{
			silverFinishes = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bronzeFinishes"))
		{
			bronzeFinishes = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("averagePlace"))
		{
			averagePlace = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rank"))
		{
			rank = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockouts"))
		{
			knockouts = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("memberFrom"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, memberFrom);
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::ClubSeasonUserStats::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClubSeasonUserStats())) // not empty
	{
		_body.composeString(userId);
		_body.composeString(userCity);
		_body.composeUINT32(userAvatar);
		_body.composeUINT32(qualifiedGames);
		_body.composeUINT32(bestTournPlace);
		_body.composeUINT32(bestTournPlaceTo);
		_body.composeUINT32(playersInbestTourn);
		_body.composeUINT32(worstTournPlace);
		_body.composeUINT32(worstTournPlaceTo);
		_body.composeUINT32(playersInWorstTourn);
		_body.composeUINT32(inTheMoney);
		_body.composeUINT64(points);
		_body.composeUINT32(goldFinishes);
		_body.composeUINT32(silverFinishes);
		_body.composeUINT32(bronzeFinishes);
		_body.composeUINT32(averagePlace);
		_body.composeUINT32(rank);
		_body.composeUINT32(knockouts);
		_body.composeSrvTime(memberFrom);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubSeasonUserStats::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseStringP(userId);
	_parser0.parseStringP(userCity);
	_parser0.parseUINT32(userAvatar);
	_parser0.parseUINT32(qualifiedGames);
	_parser0.parseUINT32(bestTournPlace);
	_parser0.parseUINT32(bestTournPlaceTo);
	_parser0.parseUINT32(playersInbestTourn);
	_parser0.parseUINT32(worstTournPlace);
	_parser0.parseUINT32(worstTournPlaceTo);
	_parser0.parseUINT32(playersInWorstTourn);
	_parser0.parseUINT32(inTheMoney);
	_parser0.parseUINT64(points);
	_parser0.parseUINT32(goldFinishes);
	_parser0.parseUINT32(silverFinishes);
	_parser0.parseUINT32(bronzeFinishes);
	_parser0.parseUINT32(averagePlace);
	_parser0.parseUINT32(rank);
	_parser0.parseUINT32(knockouts);
	_parser0.parseSrvTime(memberFrom);
}

const char *hglobby::lobby_client::ClubSeasonUserStats::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("userCity", userCity);
	_jsonstr.compose("userAvatar", userAvatar);
	_jsonstr.compose("qualifiedGames", qualifiedGames);
	_jsonstr.compose("bestTournPlace", bestTournPlace);
	_jsonstr.compose("bestTournPlaceTo", bestTournPlaceTo);
	_jsonstr.compose("playersInbestTourn", playersInbestTourn);
	_jsonstr.compose("worstTournPlace", worstTournPlace);
	_jsonstr.compose("worstTournPlaceTo", worstTournPlaceTo);
	_jsonstr.compose("playersInWorstTourn", playersInWorstTourn);
	_jsonstr.compose("inTheMoney", inTheMoney);
	_jsonstr.compose("points", points);
	_jsonstr.compose("goldFinishes", goldFinishes);
	_jsonstr.compose("silverFinishes", silverFinishes);
	_jsonstr.compose("bronzeFinishes", bronzeFinishes);
	_jsonstr.compose("averagePlace", averagePlace);
	_jsonstr.compose("rank", rank);
	_jsonstr.compose("knockouts", knockouts);
	_jsonstr.compose("memberFrom", memberFrom);
	return _buf.c_str();
}

void hglobby::lobby_client::ClubSeasonUserStats::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("userCity", userCity);
	_jparser.parseByNameThrow("userAvatar", userAvatar);
	_jparser.parseByNameThrow("qualifiedGames", qualifiedGames);
	_jparser.parseByNameThrow("bestTournPlace", bestTournPlace);
	_jparser.parseByNameThrow("bestTournPlaceTo", bestTournPlaceTo);
	_jparser.parseByNameThrow("playersInbestTourn", playersInbestTourn);
	_jparser.parseByNameThrow("worstTournPlace", worstTournPlace);
	_jparser.parseByNameThrow("worstTournPlaceTo", worstTournPlaceTo);
	_jparser.parseByNameThrow("playersInWorstTourn", playersInWorstTourn);
	_jparser.parseByNameThrow("inTheMoney", inTheMoney);
	_jparser.parseByNameThrow("points", points);
	_jparser.parseByNameThrow("goldFinishes", goldFinishes);
	_jparser.parseByNameThrow("silverFinishes", silverFinishes);
	_jparser.parseByNameThrow("bronzeFinishes", bronzeFinishes);
	_jparser.parseByNameThrow("averagePlace", averagePlace);
	_jparser.parseByNameThrow("rank", rank);
	_jparser.parseByNameThrow("knockouts", knockouts);
	_jparser.parseByNameThrow("memberFrom", memberFrom);
}

/* static */ void hglobby::lobby_client::ClubSeasonUserStats::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	PString userCity; _jparser.validateByNameThrow("userCity", userCity);
	AtfValidator::validateInt(_descr, "userCity", userCity.length(), _checker, __FILE__, __LINE__);
	UINT32 userAvatar; _jparser.validateByNameThrow("userAvatar", userAvatar);
	AtfValidator::validateInt(_descr, "userAvatar", userAvatar, _checker, __FILE__, __LINE__);
	UINT32 qualifiedGames; _jparser.validateByNameThrow("qualifiedGames", qualifiedGames);
	AtfValidator::validateInt(_descr, "qualifiedGames", qualifiedGames, _checker, __FILE__, __LINE__);
	UINT32 bestTournPlace; _jparser.validateByNameThrow("bestTournPlace", bestTournPlace);
	AtfValidator::validateInt(_descr, "bestTournPlace", bestTournPlace, _checker, __FILE__, __LINE__);
	UINT32 bestTournPlaceTo; _jparser.validateByNameThrow("bestTournPlaceTo", bestTournPlaceTo);
	AtfValidator::validateInt(_descr, "bestTournPlaceTo", bestTournPlaceTo, _checker, __FILE__, __LINE__);
	UINT32 playersInbestTourn; _jparser.validateByNameThrow("playersInbestTourn", playersInbestTourn);
	AtfValidator::validateInt(_descr, "playersInbestTourn", playersInbestTourn, _checker, __FILE__, __LINE__);
	UINT32 worstTournPlace; _jparser.validateByNameThrow("worstTournPlace", worstTournPlace);
	AtfValidator::validateInt(_descr, "worstTournPlace", worstTournPlace, _checker, __FILE__, __LINE__);
	UINT32 worstTournPlaceTo; _jparser.validateByNameThrow("worstTournPlaceTo", worstTournPlaceTo);
	AtfValidator::validateInt(_descr, "worstTournPlaceTo", worstTournPlaceTo, _checker, __FILE__, __LINE__);
	UINT32 playersInWorstTourn; _jparser.validateByNameThrow("playersInWorstTourn", playersInWorstTourn);
	AtfValidator::validateInt(_descr, "playersInWorstTourn", playersInWorstTourn, _checker, __FILE__, __LINE__);
	UINT32 inTheMoney; _jparser.validateByNameThrow("inTheMoney", inTheMoney);
	AtfValidator::validateInt(_descr, "inTheMoney", inTheMoney, _checker, __FILE__, __LINE__);
	UINT64 points; _jparser.validateByNameThrow("points", points);
	AtfValidator::validateUint(_descr, "points", points, _checker, __FILE__, __LINE__);
	UINT32 goldFinishes; _jparser.validateByNameThrow("goldFinishes", goldFinishes);
	AtfValidator::validateInt(_descr, "goldFinishes", goldFinishes, _checker, __FILE__, __LINE__);
	UINT32 silverFinishes; _jparser.validateByNameThrow("silverFinishes", silverFinishes);
	AtfValidator::validateInt(_descr, "silverFinishes", silverFinishes, _checker, __FILE__, __LINE__);
	UINT32 bronzeFinishes; _jparser.validateByNameThrow("bronzeFinishes", bronzeFinishes);
	AtfValidator::validateInt(_descr, "bronzeFinishes", bronzeFinishes, _checker, __FILE__, __LINE__);
	UINT32 averagePlace; _jparser.validateByNameThrow("averagePlace", averagePlace);
	AtfValidator::validateInt(_descr, "averagePlace", averagePlace, _checker, __FILE__, __LINE__);
	UINT32 rank; _jparser.validateByNameThrow("rank", rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	UINT32 knockouts; _jparser.validateByNameThrow("knockouts", knockouts);
	AtfValidator::validateInt(_descr, "knockouts", knockouts, _checker, __FILE__, __LINE__);
	SrvTime memberFrom; _jparser.validateByNameThrow("memberFrom", memberFrom);
	AtfValidator::validateSrvDateTime(_descr, "memberFrom", memberFrom, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::ClubSeasonUserStats::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userCity"); size_t szUserCity = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userCity", szUserCity, _checker, __FILE__, __LINE__);
	UINT32 userAvatar; _parser0.parseUINT32(userAvatar);
	AtfValidator::validateInt(_descr, "userAvatar", userAvatar, _checker, __FILE__, __LINE__);
	UINT32 qualifiedGames; _parser0.parseUINT32(qualifiedGames);
	AtfValidator::validateInt(_descr, "qualifiedGames", qualifiedGames, _checker, __FILE__, __LINE__);
	UINT32 bestTournPlace; _parser0.parseUINT32(bestTournPlace);
	AtfValidator::validateInt(_descr, "bestTournPlace", bestTournPlace, _checker, __FILE__, __LINE__);
	UINT32 bestTournPlaceTo; _parser0.parseUINT32(bestTournPlaceTo);
	AtfValidator::validateInt(_descr, "bestTournPlaceTo", bestTournPlaceTo, _checker, __FILE__, __LINE__);
	UINT32 playersInbestTourn; _parser0.parseUINT32(playersInbestTourn);
	AtfValidator::validateInt(_descr, "playersInbestTourn", playersInbestTourn, _checker, __FILE__, __LINE__);
	UINT32 worstTournPlace; _parser0.parseUINT32(worstTournPlace);
	AtfValidator::validateInt(_descr, "worstTournPlace", worstTournPlace, _checker, __FILE__, __LINE__);
	UINT32 worstTournPlaceTo; _parser0.parseUINT32(worstTournPlaceTo);
	AtfValidator::validateInt(_descr, "worstTournPlaceTo", worstTournPlaceTo, _checker, __FILE__, __LINE__);
	UINT32 playersInWorstTourn; _parser0.parseUINT32(playersInWorstTourn);
	AtfValidator::validateInt(_descr, "playersInWorstTourn", playersInWorstTourn, _checker, __FILE__, __LINE__);
	UINT32 inTheMoney; _parser0.parseUINT32(inTheMoney);
	AtfValidator::validateInt(_descr, "inTheMoney", inTheMoney, _checker, __FILE__, __LINE__);
	UINT64 points; _parser0.parseUINT64(points);
	AtfValidator::validateUint(_descr, "points", points, _checker, __FILE__, __LINE__);
	UINT32 goldFinishes; _parser0.parseUINT32(goldFinishes);
	AtfValidator::validateInt(_descr, "goldFinishes", goldFinishes, _checker, __FILE__, __LINE__);
	UINT32 silverFinishes; _parser0.parseUINT32(silverFinishes);
	AtfValidator::validateInt(_descr, "silverFinishes", silverFinishes, _checker, __FILE__, __LINE__);
	UINT32 bronzeFinishes; _parser0.parseUINT32(bronzeFinishes);
	AtfValidator::validateInt(_descr, "bronzeFinishes", bronzeFinishes, _checker, __FILE__, __LINE__);
	UINT32 averagePlace; _parser0.parseUINT32(averagePlace);
	AtfValidator::validateInt(_descr, "averagePlace", averagePlace, _checker, __FILE__, __LINE__);
	UINT32 rank; _parser0.parseUINT32(rank);
	AtfValidator::validateInt(_descr, "rank", rank, _checker, __FILE__, __LINE__);
	UINT32 knockouts; _parser0.parseUINT32(knockouts);
	AtfValidator::validateInt(_descr, "knockouts", knockouts, _checker, __FILE__, __LINE__);
	SrvTime memberFrom; _parser0.parseSrvTime(memberFrom);
	AtfValidator::validateSrvDateTime(_descr, "memberFrom", memberFrom, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_CLUB_SEASON_STATS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	stats.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::equals(const Protocol_HG_GET_CLUB_SEASON_STATS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		stats.equals(_o.stats);
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_SEASON_STATS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_SEASON_STATS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_SEASON_STATS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("stats=");
		stats.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_SEASON_STATS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		stats.toXmlString("stats", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("stats"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClubSeasonUserStats, 4 > >::FromXmlString(_value, stats)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		stats.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		stats.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("stats", stats);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("stats", stats);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ClubSeasonUserStats > stats; _jparser.validateByNameThrow("stats", stats);
		AtfValidator::validateInt(_descr, "stats", stats.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_SEASON_STATS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szStats = Atf::LAtfVector< ClubSeasonUserStats, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("stats"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "stats", szStats, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_SUMMARIES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::Protocol_HG_GET_RECENT_TOURN_SUMMARIES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::equals(const Protocol_HG_GET_RECENT_TOURN_SUMMARIES& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECENT_TOURN_SUMMARIES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECENT_TOURN_SUMMARIES*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_SUMMARIES).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECENT_TOURN_SUMMARIES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubRecentTournamentSummary
//=================================================================

hglobby::lobby_client::ClubRecentTournamentSummary::ClubRecentTournamentSummary()
{
	clear();
}

void hglobby::lobby_client::ClubRecentTournamentSummary::clear()
{
	tournId = 0;
	tournName.clear();
	currency.clear();
	started.setNull();
	closed.setNull();
	numPlayers = 0;
	prizePool = 0;
	seasonId = 0;
	playMoney = false;
	rebuys = 0;
	rebuyRake = 0;
	countingToStats = false;
	scalePM = 0;
}

bool hglobby::lobby_client::ClubRecentTournamentSummary::equals(const ClubRecentTournamentSummary& _o) const
{
	return tournId == _o.tournId &&
		Atf::atfPStringEquals(tournName, _o.tournName) &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		started.equals(_o.started) &&
		closed.equals(_o.closed) &&
		numPlayers == _o.numPlayers &&
		prizePool == _o.prizePool &&
		seasonId == _o.seasonId &&
		playMoney == _o.playMoney &&
		rebuys == _o.rebuys &&
		rebuyRake == _o.rebuyRake &&
		countingToStats == _o.countingToStats &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::ClubRecentTournamentSummary::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("started=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, started);
	_buf.append(',');
	_buf.append("closed=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, closed);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("prizePool=");
	_buf.appendUint64(prizePool);
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("playMoney=");
	_buf.appendUint(playMoney);
	_buf.append(',');
	_buf.append("rebuys=");
	_buf.appendUint(rebuys);
	_buf.append(',');
	_buf.append("rebuyRake=");
	_buf.appendUint(rebuyRake);
	_buf.append(',');
	_buf.append("countingToStats=");
	_buf.appendUint(countingToStats);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::ClubRecentTournamentSummary::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournName", tournName, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "started", started);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "closed", closed);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("prizePool", prizePool, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonId", seasonId, _buf);
	Atf::XmlElement::encodeAsXmlElement("playMoney", playMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuys", rebuys, _buf);
	Atf::XmlElement::encodeAsXmlElement("rebuyRake", rebuyRake, _buf);
	Atf::XmlElement::encodeAsXmlElement("countingToStats", countingToStats, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::ClubRecentTournamentSummary::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournName)) return false;
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("started"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, started);
		}
		else if (_element.equals("closed"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, closed);
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prizePool"))
		{
			prizePool = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("seasonId"))
		{
			seasonId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playMoney"))
		{
			playMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("rebuys"))
		{
			rebuys = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rebuyRake"))
		{
			rebuyRake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("countingToStats"))
		{
			countingToStats = (*_value.ptr() == '1');
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::ClubRecentTournamentSummary::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClubRecentTournamentSummary())) // not empty
	{
		_body.composeUINT32(tournId);
		_body.composeString(tournName);
		_body.composeString(currency);
		_body.composeSrvTime(started);
		_body.composeSrvTime(closed);
		_body.composeUINT32(numPlayers);
		_body.composeUINT64(prizePool);
		_body.composeUINT32(seasonId);
		_body.composeBOOL(playMoney);
		_body.composeUINT32(rebuys);
		_body.composeUINT32(rebuyRake);
		_body.composeBOOL(countingToStats);
		_body.composeINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubRecentTournamentSummary::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(tournName);
	_parser0.parseStringP(currency);
	_parser0.parseSrvTime(started);
	_parser0.parseSrvTime(closed);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseUINT64(prizePool);
	_parser0.parseUINT32(seasonId);
	_parser0.parseBOOL(playMoney);
	_parser0.parseUINT32(rebuys);
	_parser0.parseUINT32(rebuyRake);
	_parser0.parseBOOL(countingToStats);
	_parser0.parseINT32(scalePM);
}

const char *hglobby::lobby_client::ClubRecentTournamentSummary::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("tournName", tournName);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("started", started);
	_jsonstr.compose("closed", closed);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("prizePool", prizePool);
	_jsonstr.compose("seasonId", seasonId);
	_jsonstr.compose("playMoney", playMoney);
	_jsonstr.compose("rebuys", rebuys);
	_jsonstr.compose("rebuyRake", rebuyRake);
	_jsonstr.compose("countingToStats", countingToStats);
	_jsonstr.compose("scalePM", scalePM);
	return _buf.c_str();
}

void hglobby::lobby_client::ClubRecentTournamentSummary::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("tournName", tournName);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("started", started);
	_jparser.parseByNameThrow("closed", closed);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("prizePool", prizePool);
	_jparser.parseByNameThrow("seasonId", seasonId);
	_jparser.parseByNameThrow("playMoney", playMoney);
	_jparser.parseByNameThrow("rebuys", rebuys);
	_jparser.parseByNameThrow("rebuyRake", rebuyRake);
	_jparser.parseByNameThrow("countingToStats", countingToStats);
	_jparser.parseByNameThrow("scalePM", scalePM);
}

/* static */ void hglobby::lobby_client::ClubRecentTournamentSummary::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString tournName; _jparser.validateByNameThrow("tournName", tournName);
	AtfValidator::validateInt(_descr, "tournName", tournName.length(), _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	SrvTime started; _jparser.validateByNameThrow("started", started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	SrvTime closed; _jparser.validateByNameThrow("closed", closed);
	AtfValidator::validateSrvDateTime(_descr, "closed", closed, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	UINT64 prizePool; _jparser.validateByNameThrow("prizePool", prizePool);
	AtfValidator::validateUint(_descr, "prizePool", prizePool, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _jparser.validateByNameThrow("seasonId", seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	bool playMoney; _jparser.validateByNameThrow("playMoney", playMoney);
	AtfValidator::validateInt(_descr, "playMoney", playMoney, _checker, __FILE__, __LINE__);
	UINT32 rebuys; _jparser.validateByNameThrow("rebuys", rebuys);
	AtfValidator::validateInt(_descr, "rebuys", rebuys, _checker, __FILE__, __LINE__);
	UINT32 rebuyRake; _jparser.validateByNameThrow("rebuyRake", rebuyRake);
	AtfValidator::validateInt(_descr, "rebuyRake", rebuyRake, _checker, __FILE__, __LINE__);
	bool countingToStats; _jparser.validateByNameThrow("countingToStats", countingToStats);
	AtfValidator::validateInt(_descr, "countingToStats", countingToStats, _checker, __FILE__, __LINE__);
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::ClubRecentTournamentSummary::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	SrvTime started; _parser0.parseSrvTime(started);
	AtfValidator::validateSrvDateTime(_descr, "started", started, _checker, __FILE__, __LINE__);
	SrvTime closed; _parser0.parseSrvTime(closed);
	AtfValidator::validateSrvDateTime(_descr, "closed", closed, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	UINT64 prizePool; _parser0.parseUINT64(prizePool);
	AtfValidator::validateUint(_descr, "prizePool", prizePool, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _parser0.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	bool playMoney; _parser0.parseBOOL(playMoney);
	AtfValidator::validateInt(_descr, "playMoney", playMoney, _checker, __FILE__, __LINE__);
	UINT32 rebuys; _parser0.parseUINT32(rebuys);
	AtfValidator::validateInt(_descr, "rebuys", rebuys, _checker, __FILE__, __LINE__);
	UINT32 rebuyRake; _parser0.parseUINT32(rebuyRake);
	AtfValidator::validateInt(_descr, "rebuyRake", rebuyRake, _checker, __FILE__, __LINE__);
	bool countingToStats; _parser0.parseBOOL(countingToStats);
	AtfValidator::validateInt(_descr, "countingToStats", countingToStats, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	summaries.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::equals(const Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		summaries.equals(_o.summaries);
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECENT_TOURN_SUMMARIES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_SUMMARIES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("summaries=");
		summaries.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECENT_TOURN_SUMMARIES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		summaries.toXmlString("summaries", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("summaries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClubRecentTournamentSummary, 4 > >::FromXmlString(_value, summaries)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		summaries.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		summaries.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("summaries", summaries);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("summaries", summaries);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ClubRecentTournamentSummary > summaries; _jparser.validateByNameThrow("summaries", summaries);
		AtfValidator::validateInt(_descr, "summaries", summaries.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSummaries = Atf::LAtfVector< ClubRecentTournamentSummary, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("summaries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "summaries", szSummaries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_RESULTS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::Protocol_HG_GET_RECENT_TOURN_RESULTS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::clear()
{
	tournId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::equals(const Protocol_HG_GET_RECENT_TOURN_RESULTS& _o) const
{
	return tournId == _o.tournId;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECENT_TOURN_RESULTS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECENT_TOURN_RESULTS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_RESULTS).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECENT_TOURN_RESULTS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubRecentTournPlayerResult
//=================================================================

hglobby::lobby_client::ClubRecentTournPlayerResult::ClubRecentTournPlayerResult()
{
	clear();
}

void hglobby::lobby_client::ClubRecentTournPlayerResult::clear()
{
	tournRank = 0;
	userId.clear();
	place = 0;
	placeTo = 0;
	prize = 0;
	pointsEarned = 0;
	knockouts = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::ClubRecentTournPlayerResult::equals(const ClubRecentTournPlayerResult& _o) const
{
	return tournRank == _o.tournRank &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		place == _o.place &&
		placeTo == _o.placeTo &&
		prize == _o.prize &&
		pointsEarned == _o.pointsEarned &&
		knockouts == _o.knockouts &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::ClubRecentTournPlayerResult::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tournRank=");
	_buf.appendUint(tournRank);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("place=");
	_buf.appendUint(place);
	_buf.append(',');
	_buf.append("placeTo=");
	_buf.appendUint(placeTo);
	_buf.append(',');
	_buf.append("prize=");
	_buf.appendUint(prize);
	_buf.append(',');
	_buf.append("pointsEarned=");
	_buf.appendUint(pointsEarned);
	_buf.append(',');
	_buf.append("knockouts=");
	_buf.appendUint(knockouts);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::ClubRecentTournPlayerResult::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("tournRank", tournRank, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("place", place, _buf);
	Atf::XmlElement::encodeAsXmlElement("placeTo", placeTo, _buf);
	Atf::XmlElement::encodeAsXmlElement("prize", prize, _buf);
	Atf::XmlElement::encodeAsXmlElement("pointsEarned", pointsEarned, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockouts", knockouts, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::ClubRecentTournPlayerResult::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tournRank"))
		{
			tournRank = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("place"))
		{
			place = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("placeTo"))
		{
			placeTo = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("prize"))
		{
			prize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("pointsEarned"))
		{
			pointsEarned = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockouts"))
		{
			knockouts = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::ClubRecentTournPlayerResult::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ClubRecentTournPlayerResult())) // not empty
	{
		_body.composeUINT32(tournRank);
		_body.composeString(userId);
		_body.composeUINT32(place);
		_body.composeUINT32(placeTo);
		_body.composeUINT32(prize);
		_body.composeUINT32(pointsEarned);
		_body.composeUINT32(knockouts);
		_body.composeINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ClubRecentTournPlayerResult::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(tournRank);
	_parser0.parseStringP(userId);
	_parser0.parseUINT32(place);
	_parser0.parseUINT32(placeTo);
	_parser0.parseUINT32(prize);
	_parser0.parseUINT32(pointsEarned);
	_parser0.parseUINT32(knockouts);
	_parser0.parseINT32(scalePM);
}

const char *hglobby::lobby_client::ClubRecentTournPlayerResult::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournRank", tournRank);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("place", place);
	_jsonstr.compose("placeTo", placeTo);
	_jsonstr.compose("prize", prize);
	_jsonstr.compose("pointsEarned", pointsEarned);
	_jsonstr.compose("knockouts", knockouts);
	_jsonstr.compose("scalePM", scalePM);
	return _buf.c_str();
}

void hglobby::lobby_client::ClubRecentTournPlayerResult::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournRank", tournRank);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("place", place);
	_jparser.parseByNameThrow("placeTo", placeTo);
	_jparser.parseByNameThrow("prize", prize);
	_jparser.parseByNameThrow("pointsEarned", pointsEarned);
	_jparser.parseByNameThrow("knockouts", knockouts);
	_jparser.parseByNameThrow("scalePM", scalePM);
}

/* static */ void hglobby::lobby_client::ClubRecentTournPlayerResult::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournRank; _jparser.validateByNameThrow("tournRank", tournRank);
	AtfValidator::validateInt(_descr, "tournRank", tournRank, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateInt(_descr, "userId", userId.length(), _checker, __FILE__, __LINE__);
	UINT32 place; _jparser.validateByNameThrow("place", place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	UINT32 placeTo; _jparser.validateByNameThrow("placeTo", placeTo);
	AtfValidator::validateInt(_descr, "placeTo", placeTo, _checker, __FILE__, __LINE__);
	UINT32 prize; _jparser.validateByNameThrow("prize", prize);
	AtfValidator::validateInt(_descr, "prize", prize, _checker, __FILE__, __LINE__);
	UINT32 pointsEarned; _jparser.validateByNameThrow("pointsEarned", pointsEarned);
	AtfValidator::validateInt(_descr, "pointsEarned", pointsEarned, _checker, __FILE__, __LINE__);
	UINT32 knockouts; _jparser.validateByNameThrow("knockouts", knockouts);
	AtfValidator::validateInt(_descr, "knockouts", knockouts, _checker, __FILE__, __LINE__);
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::ClubRecentTournPlayerResult::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 tournRank; _parser0.parseUINT32(tournRank);
	AtfValidator::validateInt(_descr, "tournRank", tournRank, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateInt(_descr, "userId", szUserId, _checker, __FILE__, __LINE__);
	UINT32 place; _parser0.parseUINT32(place);
	AtfValidator::validateInt(_descr, "place", place, _checker, __FILE__, __LINE__);
	UINT32 placeTo; _parser0.parseUINT32(placeTo);
	AtfValidator::validateInt(_descr, "placeTo", placeTo, _checker, __FILE__, __LINE__);
	UINT32 prize; _parser0.parseUINT32(prize);
	AtfValidator::validateInt(_descr, "prize", prize, _checker, __FILE__, __LINE__);
	UINT32 pointsEarned; _parser0.parseUINT32(pointsEarned);
	AtfValidator::validateInt(_descr, "pointsEarned", pointsEarned, _checker, __FILE__, __LINE__);
	UINT32 knockouts; _parser0.parseUINT32(knockouts);
	AtfValidator::validateInt(_descr, "knockouts", knockouts, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournResults.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::equals(const Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournResults.equals(_o.tournResults);
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECENT_TOURN_RESULTS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_RESULTS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournResults=");
		tournResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECENT_TOURN_RESULTS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		tournResults.toXmlString("tournResults", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournResults"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClubRecentTournPlayerResult, 4 > >::FromXmlString(_value, tournResults)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tournResults.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tournResults.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournResults", tournResults);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournResults", tournResults);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ClubRecentTournPlayerResult > tournResults; _jparser.validateByNameThrow("tournResults", tournResults);
		AtfValidator::validateInt(_descr, "tournResults", tournResults.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTournResults = Atf::LAtfVector< ClubRecentTournPlayerResult, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournResults", szTournResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_CLUB_COLOR
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::Protocol_HG_SET_CLUB_COLOR()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::clear()
{
	clubId = 0;
	color = 0;
}

bool hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::equals(const Protocol_HG_SET_CLUB_COLOR& _o) const
{
	return clubId == _o.clubId &&
		color == _o.color;
}

bool hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::equals(Atf::MessageProtocol* _other) const
{
	if (HG_SET_CLUB_COLOR != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_SET_CLUB_COLOR*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_CLUB_COLOR).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("color=");
	_buf.appendUint(color);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_SET_CLUB_COLOR).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("color", color, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("color"))
			{
				color = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(color);
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(color);
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("color", color);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("color", color);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_CLUB_COLOR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 color; _jparser.validateByNameThrow("color", color);
	AtfValidator::validateInt(_descr, "color", color, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_CLUB_COLOR";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 color; _parser.parseUINT32(color);
	AtfValidator::validateInt(_descr, "color", color, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_CLUB_COLOR_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::Protocol_HG_SET_CLUB_COLOR_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::equals(const Protocol_HG_SET_CLUB_COLOR_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_SET_CLUB_COLOR_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_SET_CLUB_COLOR_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_CLUB_COLOR_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_SET_CLUB_COLOR_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_CLUB_COLOR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_CLUB_COLOR_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_NAME
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::Protocol_HG_CHANGE_CLUB_NAME()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::clear()
{
	clubId = 0;
	clubName.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::equals(const Protocol_HG_CHANGE_CLUB_NAME& _o) const
{
	return clubId == _o.clubId &&
		Atf::atfPStringEquals(clubName, _o.clubName);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_CLUB_NAME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_CLUB_NAME*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_NAME).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_CLUB_NAME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(clubName);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(clubName);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("clubName", clubName);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("clubName", clubName);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString clubName; _jparser.validateByNameThrow("clubName", clubName);
	AtfValidator::validateIntMax(_descr, "clubName", clubName.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "clubName", szClubName, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_CLUB_NAME_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::Protocol_HG_CHANGE_CLUB_NAME_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::equals(const Protocol_HG_CHANGE_CLUB_NAME_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_CLUB_NAME_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_CLUB_NAME_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_CLUB_NAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_CLUB_NAME_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_NAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_CLUB_NAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_OPTIONS
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::Protocol_HG_GET_CLUB_OPTIONS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::equals(const Protocol_HG_GET_CLUB_OPTIONS& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_OPTIONS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_OPTIONS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_OPTIONS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_OPTIONS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_OPTIONS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_OPTIONS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::Protocol_HG_GET_CLUB_OPTIONS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubId = 0;
	seasonType = 0;
	showClubStandings = false;
	showPlayerStats = false;
	currency.clear();
	showFounderFullName = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::equals(const Protocol_HG_GET_CLUB_OPTIONS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		clubId == _o.clubId &&
		seasonType == _o.seasonType &&
		showClubStandings == _o.showClubStandings &&
		showPlayerStats == _o.showPlayerStats &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		showFounderFullName == _o.showFounderFullName;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_OPTIONS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_OPTIONS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_OPTIONS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubId=");
		_buf.appendUint(clubId);
		_buf.append(',');
		_buf.append("seasonType=");
		_buf.appendUint(seasonType);
		_buf.append(',');
		_buf.append("showClubStandings=");
		_buf.appendUint(showClubStandings);
		_buf.append(',');
		_buf.append("showPlayerStats=");
		_buf.appendUint(showPlayerStats);
		_buf.append(',');
		_buf.append("currency=");
		_buf.append(currency);
		_buf.append(',');
		_buf.append("showFounderFullName=");
		_buf.appendUint(showFounderFullName);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_OPTIONS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
		Atf::XmlElement::encodeAsXmlElement("seasonType", seasonType, _buf);
		Atf::XmlElement::encodeAsXmlElement("showClubStandings", showClubStandings, _buf);
		Atf::XmlElement::encodeAsXmlElement("showPlayerStats", showPlayerStats, _buf);
		Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
		Atf::XmlElement::encodeAsXmlElement("showFounderFullName", showFounderFullName, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seasonType"))
			{
				seasonType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("showClubStandings"))
			{
				showClubStandings = (*_value.ptr() == '1');
			}
			else if (_element.equals("showPlayerStats"))
			{
				showPlayerStats = (*_value.ptr() == '1');
			}
			else if (_element.equals("currency"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
			}
			else if (_element.equals("showFounderFullName"))
			{
				showFounderFullName = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(clubId);
		_msg.composeUINT32(seasonType);
		_msg.composeBOOL(showClubStandings);
		_msg.composeBOOL(showPlayerStats);
		_msg.composeString(currency);
		_msg.composeBOOL(showFounderFullName);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(clubId);
		_parser.parseUINT32(seasonType);
		_parser.parseBOOL(showClubStandings);
		_parser.parseBOOL(showPlayerStats);
		_parser.parseStringP(currency);
		_parser.parseBOOL(showFounderFullName);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("clubId", clubId);
		_jsonstr.compose("seasonType", seasonType);
		_jsonstr.compose("showClubStandings", showClubStandings);
		_jsonstr.compose("showPlayerStats", showPlayerStats);
		_jsonstr.compose("currency", currency);
		_jsonstr.compose("showFounderFullName", showFounderFullName);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("clubId", clubId);
		_jparser.parseByNameThrow("seasonType", seasonType);
		_jparser.parseByNameThrow("showClubStandings", showClubStandings);
		_jparser.parseByNameThrow("showPlayerStats", showPlayerStats);
		_jparser.parseByNameThrow("currency", currency);
		_jparser.parseByNameThrow("showFounderFullName", showFounderFullName);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		UINT32 seasonType; _jparser.validateByNameThrow("seasonType", seasonType);
		AtfValidator::validateInt(_descr, "seasonType", seasonType, _checker, __FILE__, __LINE__);
		bool showClubStandings; _jparser.validateByNameThrow("showClubStandings", showClubStandings);
		AtfValidator::validateInt(_descr, "showClubStandings", showClubStandings, _checker, __FILE__, __LINE__);
		bool showPlayerStats; _jparser.validateByNameThrow("showPlayerStats", showPlayerStats);
		AtfValidator::validateInt(_descr, "showPlayerStats", showPlayerStats, _checker, __FILE__, __LINE__);
		PString currency; _jparser.validateByNameThrow("currency", currency);
		AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
		bool showFounderFullName; _jparser.validateByNameThrow("showFounderFullName", showFounderFullName);
		AtfValidator::validateInt(_descr, "showFounderFullName", showFounderFullName, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_OPTIONS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 clubId; _parser.parseUINT32(clubId);
		AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
		UINT32 seasonType; _parser.parseUINT32(seasonType);
		AtfValidator::validateInt(_descr, "seasonType", seasonType, _checker, __FILE__, __LINE__);
		bool showClubStandings; _parser.parseBOOL(showClubStandings);
		AtfValidator::validateInt(_descr, "showClubStandings", showClubStandings, _checker, __FILE__, __LINE__);
		bool showPlayerStats; _parser.parseBOOL(showPlayerStats);
		AtfValidator::validateInt(_descr, "showPlayerStats", showPlayerStats, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
		AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
		bool showFounderFullName; _parser.parseBOOL(showFounderFullName);
		AtfValidator::validateInt(_descr, "showFounderFullName", showFounderFullName, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_STRUCTURES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::Protocol_HG_GET_CLUB_TOURN_STRUCTURES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::equals(const Protocol_HG_GET_CLUB_TOURN_STRUCTURES& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TOURN_STRUCTURES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TOURN_STRUCTURES*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_STRUCTURES).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TOURN_STRUCTURES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    GameStructure
//=================================================================

hglobby::lobby_client::GameStructure::GameStructure()
{
	clear();
}

void hglobby::lobby_client::GameStructure::clear()
{
	handType = 0;
	isHiLo = false;
	description.clear();
	potTypes.clear();
	tableSizes.clear();
	moneyTypes.clear();
}

bool hglobby::lobby_client::GameStructure::equals(const GameStructure& _o) const
{
	return handType == _o.handType &&
		isHiLo == _o.isHiLo &&
		Atf::atfPStringEquals(description, _o.description) &&
		potTypes.equals(_o.potTypes) &&
		tableSizes.equals(_o.tableSizes) &&
		moneyTypes.equals(_o.moneyTypes);
}

const char *hglobby::lobby_client::GameStructure::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("description=");
	_buf.append(description);
	_buf.append(',');
	_buf.append("potTypes=");
	potTypes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("tableSizes=");
	tableSizes.toTraceString(_buf);
	_buf.append(',');
	_buf.append("moneyTypes=");
	moneyTypes.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::GameStructure::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("description", description, _buf);
	potTypes.toXmlString("potTypes", _buf);
	tableSizes.toXmlString("tableSizes", _buf);
	moneyTypes.toXmlString("moneyTypes", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::GameStructure::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("description"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, description)) return false;
		}
		else if (_element.equals("potTypes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< BYTE, 4 > >::FromXmlString(_value, potTypes)) return false;
		}
		else if (_element.equals("tableSizes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tableSizes)) return false;
		}
		else if (_element.equals("moneyTypes"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< bool, 4 > >::FromXmlString(_value, moneyTypes)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::GameStructure::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(GameStructure())) // not empty
	{
		_body.composeBYTE(handType);
		_body.composeBOOL(isHiLo);
		_body.composeString(description);
		potTypes.composeMsg(_body, _ignoreJSON);
		tableSizes.composeMsg(_body, _ignoreJSON);
		moneyTypes.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::GameStructure::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(handType);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseStringP(description);
	potTypes.parseMsg(_parser0);
	tableSizes.parseMsg(_parser0);
	moneyTypes.parseMsg(_parser0);
}

const char *hglobby::lobby_client::GameStructure::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("description", description);
	_jsonstr.compose("potTypes", potTypes);
	_jsonstr.compose("tableSizes", tableSizes);
	_jsonstr.compose("moneyTypes", moneyTypes);
	return _buf.c_str();
}

void hglobby::lobby_client::GameStructure::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("description", description);
	_jparser.parseByNameThrow("potTypes", potTypes);
	_jparser.parseByNameThrow("tableSizes", tableSizes);
	_jparser.parseByNameThrow("moneyTypes", moneyTypes);
}

/* static */ void hglobby::lobby_client::GameStructure::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	PString description; _jparser.validateByNameThrow("description", description);
	AtfValidator::validateInt(_descr, "description", description.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< BYTE > potTypes; _jparser.validateByNameThrow("potTypes", potTypes);
	AtfValidator::validateInt(_descr, "potTypes", potTypes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > tableSizes; _jparser.validateByNameThrow("tableSizes", tableSizes);
	AtfValidator::validateInt(_descr, "tableSizes", tableSizes.size(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< bool > moneyTypes; _jparser.validateByNameThrow("moneyTypes", moneyTypes);
	AtfValidator::validateInt(_descr, "moneyTypes", moneyTypes.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::GameStructure::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	BYTE handType; _parser0.parseBYTE(handType);
	AtfValidator::validateInt(_descr, "handType", handType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "description"); size_t szDescription = strlen(_dummy);
	AtfValidator::validateInt(_descr, "description", szDescription, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szPotTypes = Atf::LAtfVector< BYTE, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("potTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "potTypes", szPotTypes, _checker, __FILE__, __LINE__);
	int szTableSizes = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableSizes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tableSizes", szTableSizes, _checker, __FILE__, __LINE__);
	int szMoneyTypes = Atf::LAtfVector< bool, 4 >::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("moneyTypes"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "moneyTypes", szMoneyTypes, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournBuyIn
//=================================================================

hglobby::lobby_client::TournBuyIn::TournBuyIn()
{
	clear();
}

void hglobby::lobby_client::TournBuyIn::clear()
{
	buyIn = 0;
	rake = 0;
	bounty = 0;
}

bool hglobby::lobby_client::TournBuyIn::equals(const TournBuyIn& _o) const
{
	return buyIn == _o.buyIn &&
		rake == _o.rake &&
		bounty == _o.bounty;
}

const char *hglobby::lobby_client::TournBuyIn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendUint(bounty);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::TournBuyIn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::TournBuyIn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::TournBuyIn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournBuyIn())) // not empty
	{
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(bounty);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::TournBuyIn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(bounty);
}

const char *hglobby::lobby_client::TournBuyIn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("bounty", bounty);
	return _buf.c_str();
}

void hglobby::lobby_client::TournBuyIn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("bounty", bounty);
}

/* static */ void hglobby::lobby_client::TournBuyIn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 bounty; _jparser.validateByNameThrow("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::TournBuyIn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 bounty; _parser0.parseUINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournBuyIn2
//=================================================================

hglobby::lobby_client::TournBuyIn2::TournBuyIn2()
{
	clear();
}

void hglobby::lobby_client::TournBuyIn2::clear()
{
	buyIn = 0;
	rake = 0;
	bounty = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::TournBuyIn2::equals(const TournBuyIn2& _o) const
{
	return buyIn == _o.buyIn &&
		rake == _o.rake &&
		bounty == _o.bounty &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::TournBuyIn2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("bounty=");
	_buf.appendUint(bounty);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::TournBuyIn2::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("bounty", bounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::TournBuyIn2::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("bounty"))
		{
			bounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::TournBuyIn2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TournBuyIn2())) // not empty
	{
		_body.composeUINT32(buyIn);
		_body.composeUINT32(rake);
		_body.composeUINT32(bounty);
		_body.composeUINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::TournBuyIn2::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(buyIn);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(bounty);
	_parser0.parseUINT32(scalePM);
}

const char *hglobby::lobby_client::TournBuyIn2::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("bounty", bounty);
	_jsonstr.compose("scalePM", scalePM);
	return _buf.c_str();
}

void hglobby::lobby_client::TournBuyIn2::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("bounty", bounty);
	_jparser.parseByNameThrow("scalePM", scalePM);
}

/* static */ void hglobby::lobby_client::TournBuyIn2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 bounty; _jparser.validateByNameThrow("bounty", bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::TournBuyIn2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 buyIn; _parser0.parseUINT32(buyIn);
	AtfValidator::validateInt(_descr, "buyIn", buyIn, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 bounty; _parser0.parseUINT32(bounty);
	AtfValidator::validateInt(_descr, "bounty", bounty, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    TournCurrencyBuyIns
//=================================================================

hglobby::lobby_client::TournCurrencyBuyIns::TournCurrencyBuyIns()
{
	clear();
}

void hglobby::lobby_client::TournCurrencyBuyIns::clear()
{
	currency.clear();
	tournBuyInBodies.clear();
}

bool hglobby::lobby_client::TournCurrencyBuyIns::equals(const TournCurrencyBuyIns& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		tournBuyInBodies.equals(_o.tournBuyInBodies);
}

const char *hglobby::lobby_client::TournCurrencyBuyIns::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournBuyInBodies=");
	tournBuyInBodies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::TournCurrencyBuyIns::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	tournBuyInBodies.toXmlString("tournBuyInBodies", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::TournCurrencyBuyIns::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("tournBuyInBodies"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournBuyIn, 4 > >::FromXmlString(_value, tournBuyInBodies)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::TournCurrencyBuyIns::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(currency);
	tournBuyInBodies.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::TournCurrencyBuyIns::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currency);
	tournBuyInBodies.parseMsg(_parser);
}

const char *hglobby::lobby_client::TournCurrencyBuyIns::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("tournBuyInBodies", tournBuyInBodies);
	return _buf.c_str();
}

void hglobby::lobby_client::TournCurrencyBuyIns::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("tournBuyInBodies", tournBuyInBodies);
}

/* static */ void hglobby::lobby_client::TournCurrencyBuyIns::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournBuyIn > tournBuyInBodies; _jparser.validateByNameThrow("tournBuyInBodies", tournBuyInBodies);
	AtfValidator::validateInt(_descr, "tournBuyInBodies", tournBuyInBodies.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::TournCurrencyBuyIns::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournBuyInBodies = Atf::LAtfVector< TournBuyIn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournBuyInBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournBuyInBodies", szTournBuyInBodies, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TournCurrencyBuyIns2
//=================================================================

hglobby::lobby_client::TournCurrencyBuyIns2::TournCurrencyBuyIns2()
{
	clear();
}

void hglobby::lobby_client::TournCurrencyBuyIns2::clear()
{
	currency.clear();
	tournBuyInBodies.clear();
}

bool hglobby::lobby_client::TournCurrencyBuyIns2::equals(const TournCurrencyBuyIns2& _o) const
{
	return Atf::atfPStringEquals(currency, _o.currency) &&
		tournBuyInBodies.equals(_o.tournBuyInBodies);
}

const char *hglobby::lobby_client::TournCurrencyBuyIns2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("tournBuyInBodies=");
	tournBuyInBodies.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::TournCurrencyBuyIns2::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	tournBuyInBodies.toXmlString("tournBuyInBodies", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::TournCurrencyBuyIns2::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("tournBuyInBodies"))
		{
			if(!Atf::AtfTempl< Atf::LAtfVector< TournBuyIn2, 4 > >::FromXmlString(_value, tournBuyInBodies)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::TournCurrencyBuyIns2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(currency);
	tournBuyInBodies.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::TournCurrencyBuyIns2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(currency);
	tournBuyInBodies.parseMsg(_parser);
}

const char *hglobby::lobby_client::TournCurrencyBuyIns2::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("tournBuyInBodies", tournBuyInBodies);
	return _buf.c_str();
}

void hglobby::lobby_client::TournCurrencyBuyIns2::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("tournBuyInBodies", tournBuyInBodies);
}

/* static */ void hglobby::lobby_client::TournCurrencyBuyIns2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< TournBuyIn2 > tournBuyInBodies; _jparser.validateByNameThrow("tournBuyInBodies", tournBuyInBodies);
	AtfValidator::validateInt(_descr, "tournBuyInBodies", tournBuyInBodies.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::TournCurrencyBuyIns2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szTournBuyInBodies = Atf::LAtfVector< TournBuyIn2, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournBuyInBodies"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "tournBuyInBodies", szTournBuyInBodies, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tournKnockoutPrize = 0;
	tournMaxPlayers = 0;
	tournFastDealing.clear();
	tournSyncBreaks.clear();
	tournPayouts.clear();
	tournStartingChips.clear();
	tournLevelLengths.clear();
	tournFormats.clear();
	gameStructures.clear();
	tournBuyInsPM.clear();
	currencyBuyIns.clear();
	isVoiceEnabled = false;
	numMaxDaysForTournCreation = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::equals(const Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournKnockoutPrize == _o.tournKnockoutPrize &&
		tournMaxPlayers == _o.tournMaxPlayers &&
		tournFastDealing.equals(_o.tournFastDealing) &&
		tournSyncBreaks.equals(_o.tournSyncBreaks) &&
		tournPayouts.equals(_o.tournPayouts) &&
		tournStartingChips.equals(_o.tournStartingChips) &&
		tournLevelLengths.equals(_o.tournLevelLengths) &&
		tournFormats.equals(_o.tournFormats) &&
		gameStructures.equals(_o.gameStructures) &&
		tournBuyInsPM.equals(_o.tournBuyInsPM) &&
		currencyBuyIns.equals(_o.currencyBuyIns) &&
		isVoiceEnabled == _o.isVoiceEnabled &&
		numMaxDaysForTournCreation == _o.numMaxDaysForTournCreation;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TOURN_STRUCTURES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_STRUCTURES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournKnockoutPrize=");
		_buf.appendUint(tournKnockoutPrize);
		_buf.append(',');
		_buf.append("tournMaxPlayers=");
		_buf.appendUint(tournMaxPlayers);
		_buf.append(',');
		_buf.append("tournFastDealing=");
		tournFastDealing.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournSyncBreaks=");
		tournSyncBreaks.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournPayouts=");
		tournPayouts.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournStartingChips=");
		tournStartingChips.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournLevelLengths=");
		tournLevelLengths.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFormats=");
		tournFormats.toTraceString(_buf);
		_buf.append(',');
		_buf.append("gameStructures=");
		gameStructures.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournBuyInsPM=");
		tournBuyInsPM.toTraceString(_buf);
		_buf.append(',');
		_buf.append("currencyBuyIns=");
		currencyBuyIns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isVoiceEnabled=");
		_buf.appendUint(isVoiceEnabled);
		_buf.append(',');
		_buf.append("numMaxDaysForTournCreation=");
		_buf.appendUint(numMaxDaysForTournCreation);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TOURN_STRUCTURES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tournKnockoutPrize", tournKnockoutPrize, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournMaxPlayers", tournMaxPlayers, _buf);
		tournFastDealing.toXmlString("tournFastDealing", _buf);
		tournSyncBreaks.toXmlString("tournSyncBreaks", _buf);
		tournPayouts.toXmlString("tournPayouts", _buf);
		tournStartingChips.toXmlString("tournStartingChips", _buf);
		tournLevelLengths.toXmlString("tournLevelLengths", _buf);
		tournFormats.toXmlString("tournFormats", _buf);
		gameStructures.toXmlString("gameStructures", _buf);
		tournBuyInsPM.toXmlString("tournBuyInsPM", _buf);
		currencyBuyIns.toXmlString("currencyBuyIns", _buf);
		Atf::XmlElement::encodeAsXmlElement("isVoiceEnabled", isVoiceEnabled, _buf);
		Atf::XmlElement::encodeAsXmlElement("numMaxDaysForTournCreation", numMaxDaysForTournCreation, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournKnockoutPrize"))
			{
				tournKnockoutPrize = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMaxPlayers"))
			{
				tournMaxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFastDealing"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< bool, 4 > >::FromXmlString(_value, tournFastDealing)) return false;
			}
			else if (_element.equals("tournSyncBreaks"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< bool, 4 > >::FromXmlString(_value, tournSyncBreaks)) return false;
			}
			else if (_element.equals("tournPayouts"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournPayouts)) return false;
			}
			else if (_element.equals("tournStartingChips"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournStartingChips)) return false;
			}
			else if (_element.equals("tournLevelLengths"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournLevelLengths)) return false;
			}
			else if (_element.equals("tournFormats"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournFormats)) return false;
			}
			else if (_element.equals("gameStructures"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameStructure, 4 > >::FromXmlString(_value, gameStructures)) return false;
			}
			else if (_element.equals("tournBuyInsPM"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournBuyIn, 4 > >::FromXmlString(_value, tournBuyInsPM)) return false;
			}
			else if (_element.equals("currencyBuyIns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournCurrencyBuyIns, 4 > >::FromXmlString(_value, currencyBuyIns)) return false;
			}
			else if (_element.equals("isVoiceEnabled"))
			{
				isVoiceEnabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("numMaxDaysForTournCreation"))
			{
				numMaxDaysForTournCreation = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournKnockoutPrize);
		_msg.composeUINT32(tournMaxPlayers);
		tournFastDealing.composeMsg(_msg, _ignoreJSON);
		tournSyncBreaks.composeMsg(_msg, _ignoreJSON);
		tournPayouts.composeMsg(_msg, _ignoreJSON);
		tournStartingChips.composeMsg(_msg, _ignoreJSON);
		tournLevelLengths.composeMsg(_msg, _ignoreJSON);
		tournFormats.composeMsg(_msg, _ignoreJSON);
		gameStructures.composeMsg(_msg, _ignoreJSON);
		tournBuyInsPM.composeMsg(_msg, _ignoreJSON);
		currencyBuyIns.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(isVoiceEnabled);
		_msg.composeUINT32(numMaxDaysForTournCreation);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournKnockoutPrize);
		_parser.parseUINT32(tournMaxPlayers);
		tournFastDealing.parseMsg(_parser);
		tournSyncBreaks.parseMsg(_parser);
		tournPayouts.parseMsg(_parser);
		tournStartingChips.parseMsg(_parser);
		tournLevelLengths.parseMsg(_parser);
		tournFormats.parseMsg(_parser);
		gameStructures.parseMsg(_parser);
		tournBuyInsPM.parseMsg(_parser);
		currencyBuyIns.parseMsg(_parser);
		_parser.parseBOOL(isVoiceEnabled);
		_parser.parseUINT32(numMaxDaysForTournCreation);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournKnockoutPrize", tournKnockoutPrize);
		_jsonstr.compose("tournMaxPlayers", tournMaxPlayers);
		_jsonstr.compose("tournFastDealing", tournFastDealing);
		_jsonstr.compose("tournSyncBreaks", tournSyncBreaks);
		_jsonstr.compose("tournPayouts", tournPayouts);
		_jsonstr.compose("tournStartingChips", tournStartingChips);
		_jsonstr.compose("tournLevelLengths", tournLevelLengths);
		_jsonstr.compose("tournFormats", tournFormats);
		_jsonstr.compose("gameStructures", gameStructures);
		_jsonstr.compose("tournBuyInsPM", tournBuyInsPM);
		_jsonstr.compose("currencyBuyIns", currencyBuyIns);
		_jsonstr.compose("isVoiceEnabled", isVoiceEnabled);
		_jsonstr.compose("numMaxDaysForTournCreation", numMaxDaysForTournCreation);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournKnockoutPrize", tournKnockoutPrize);
		_jparser.parseByNameThrow("tournMaxPlayers", tournMaxPlayers);
		_jparser.parseByNameThrow("tournFastDealing", tournFastDealing);
		_jparser.parseByNameThrow("tournSyncBreaks", tournSyncBreaks);
		_jparser.parseByNameThrow("tournPayouts", tournPayouts);
		_jparser.parseByNameThrow("tournStartingChips", tournStartingChips);
		_jparser.parseByNameThrow("tournLevelLengths", tournLevelLengths);
		_jparser.parseByNameThrow("tournFormats", tournFormats);
		_jparser.parseByNameThrow("gameStructures", gameStructures);
		_jparser.parseByNameThrow("tournBuyInsPM", tournBuyInsPM);
		_jparser.parseByNameThrow("currencyBuyIns", currencyBuyIns);
		_jparser.parseByNameThrow("isVoiceEnabled", isVoiceEnabled);
		_jparser.parseByNameThrow("numMaxDaysForTournCreation", numMaxDaysForTournCreation);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournKnockoutPrize; _jparser.validateByNameThrow("tournKnockoutPrize", tournKnockoutPrize);
		AtfValidator::validateInt(_descr, "tournKnockoutPrize", tournKnockoutPrize, _checker, __FILE__, __LINE__);
		UINT32 tournMaxPlayers; _jparser.validateByNameThrow("tournMaxPlayers", tournMaxPlayers);
		AtfValidator::validateInt(_descr, "tournMaxPlayers", tournMaxPlayers, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< bool > tournFastDealing; _jparser.validateByNameThrow("tournFastDealing", tournFastDealing);
		AtfValidator::validateInt(_descr, "tournFastDealing", tournFastDealing.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< bool > tournSyncBreaks; _jparser.validateByNameThrow("tournSyncBreaks", tournSyncBreaks);
		AtfValidator::validateInt(_descr, "tournSyncBreaks", tournSyncBreaks.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tournPayouts; _jparser.validateByNameThrow("tournPayouts", tournPayouts);
		AtfValidator::validateInt(_descr, "tournPayouts", tournPayouts.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tournStartingChips; _jparser.validateByNameThrow("tournStartingChips", tournStartingChips);
		AtfValidator::validateInt(_descr, "tournStartingChips", tournStartingChips.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tournLevelLengths; _jparser.validateByNameThrow("tournLevelLengths", tournLevelLengths);
		AtfValidator::validateInt(_descr, "tournLevelLengths", tournLevelLengths.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tournFormats; _jparser.validateByNameThrow("tournFormats", tournFormats);
		AtfValidator::validateInt(_descr, "tournFormats", tournFormats.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< GameStructure > gameStructures; _jparser.validateByNameThrow("gameStructures", gameStructures);
		AtfValidator::validateInt(_descr, "gameStructures", gameStructures.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< TournBuyIn > tournBuyInsPM; _jparser.validateByNameThrow("tournBuyInsPM", tournBuyInsPM);
		AtfValidator::validateInt(_descr, "tournBuyInsPM", tournBuyInsPM.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< TournCurrencyBuyIns > currencyBuyIns; _jparser.validateByNameThrow("currencyBuyIns", currencyBuyIns);
		AtfValidator::validateInt(_descr, "currencyBuyIns", currencyBuyIns.size(), _checker, __FILE__, __LINE__);
		bool isVoiceEnabled; _jparser.validateByNameThrow("isVoiceEnabled", isVoiceEnabled);
		AtfValidator::validateInt(_descr, "isVoiceEnabled", isVoiceEnabled, _checker, __FILE__, __LINE__);
		UINT32 numMaxDaysForTournCreation; _jparser.validateByNameThrow("numMaxDaysForTournCreation", numMaxDaysForTournCreation);
		AtfValidator::validateInt(_descr, "numMaxDaysForTournCreation", numMaxDaysForTournCreation, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournKnockoutPrize; _parser.parseUINT32(tournKnockoutPrize);
		AtfValidator::validateInt(_descr, "tournKnockoutPrize", tournKnockoutPrize, _checker, __FILE__, __LINE__);
		UINT32 tournMaxPlayers; _parser.parseUINT32(tournMaxPlayers);
		AtfValidator::validateInt(_descr, "tournMaxPlayers", tournMaxPlayers, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szTournFastDealing = Atf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournFastDealing"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournFastDealing", szTournFastDealing, _checker, __FILE__, __LINE__);
		int szTournSyncBreaks = Atf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSyncBreaks"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournSyncBreaks", szTournSyncBreaks, _checker, __FILE__, __LINE__);
		int szTournPayouts = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournPayouts"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournPayouts", szTournPayouts, _checker, __FILE__, __LINE__);
		int szTournStartingChips = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournStartingChips"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournStartingChips", szTournStartingChips, _checker, __FILE__, __LINE__);
		int szTournLevelLengths = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournLevelLengths"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournLevelLengths", szTournLevelLengths, _checker, __FILE__, __LINE__);
		int szTournFormats = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournFormats"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournFormats", szTournFormats, _checker, __FILE__, __LINE__);
		int szGameStructures = Atf::LAtfVector< GameStructure, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameStructures"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "gameStructures", szGameStructures, _checker, __FILE__, __LINE__);
		int szTournBuyInsPM = Atf::LAtfVector< TournBuyIn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournBuyInsPM"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournBuyInsPM", szTournBuyInsPM, _checker, __FILE__, __LINE__);
		int szCurrencyBuyIns = Atf::LAtfVector< TournCurrencyBuyIns, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencyBuyIns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "currencyBuyIns", szCurrencyBuyIns, _checker, __FILE__, __LINE__);
		bool isVoiceEnabled; _parser.parseBOOL(isVoiceEnabled);
		AtfValidator::validateInt(_descr, "isVoiceEnabled", isVoiceEnabled, _checker, __FILE__, __LINE__);
		UINT32 numMaxDaysForTournCreation; _parser.parseUINT32(numMaxDaysForTournCreation);
		AtfValidator::validateInt(_descr, "numMaxDaysForTournCreation", numMaxDaysForTournCreation, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_STRUCTURES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::Protocol_HG_GET_CLUB_TABLE_STRUCTURES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::equals(const Protocol_HG_GET_CLUB_TABLE_STRUCTURES& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TABLE_STRUCTURES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TABLE_STRUCTURES*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_STRUCTURES).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TABLE_STRUCTURES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    TableParamsStruct
//=================================================================

hglobby::lobby_client::TableParamsStruct::TableParamsStruct()
{
	clear();
}

void hglobby::lobby_client::TableParamsStruct::clear()
{
	isHiLo = false;
	tableSize = 0;
	isFastDealing = false;
	isPlayMoney = false;
	currency.clear();
	handType = 0;
	potStruct = 0;
	ante = 0;
	cap = 0;
	minBuyIn = 0;
	maxBuyIn = 0;
	stakesLow = 0;
	stakesHigh = 0;
	tableName.clear();
	scalePM = 0;
}

bool hglobby::lobby_client::TableParamsStruct::equals(const TableParamsStruct& _o) const
{
	return isHiLo == _o.isHiLo &&
		tableSize == _o.tableSize &&
		isFastDealing == _o.isFastDealing &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		handType == _o.handType &&
		potStruct == _o.potStruct &&
		ante == _o.ante &&
		cap == _o.cap &&
		minBuyIn == _o.minBuyIn &&
		maxBuyIn == _o.maxBuyIn &&
		stakesLow == _o.stakesLow &&
		stakesHigh == _o.stakesHigh &&
		Atf::atfPStringEquals(tableName, _o.tableName) &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::TableParamsStruct::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("tableSize=");
	_buf.appendUint(tableSize);
	_buf.append(',');
	_buf.append("isFastDealing=");
	_buf.appendUint(isFastDealing);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("potStruct=");
	_buf.appendUint(potStruct);
	_buf.append(',');
	_buf.append("ante=");
	_buf.appendUint(ante);
	_buf.append(',');
	_buf.append("cap=");
	_buf.appendUint(cap);
	_buf.append(',');
	_buf.append("minBuyIn=");
	_buf.appendUint(minBuyIn);
	_buf.append(',');
	_buf.append("maxBuyIn=");
	_buf.appendUint(maxBuyIn);
	_buf.append(',');
	_buf.append("stakesLow=");
	_buf.appendUint(stakesLow);
	_buf.append(',');
	_buf.append("stakesHigh=");
	_buf.appendUint(stakesHigh);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::TableParamsStruct::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableSize", tableSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("isFastDealing", isFastDealing, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("potStruct", potStruct, _buf);
	Atf::XmlElement::encodeAsXmlElement("ante", ante, _buf);
	Atf::XmlElement::encodeAsXmlElement("cap", cap, _buf);
	Atf::XmlElement::encodeAsXmlElement("minBuyIn", minBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxBuyIn", maxBuyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakesLow", stakesLow, _buf);
	Atf::XmlElement::encodeAsXmlElement("stakesHigh", stakesHigh, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableName", tableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::TableParamsStruct::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("tableSize"))
		{
			tableSize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isFastDealing"))
		{
			isFastDealing = (*_value.ptr() == '1');
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("potStruct"))
		{
			potStruct = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("ante"))
		{
			ante = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("cap"))
		{
			cap = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minBuyIn"))
		{
			minBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("maxBuyIn"))
		{
			maxBuyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakesLow"))
		{
			stakesLow = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("stakesHigh"))
		{
			stakesHigh = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableName)) return false;
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::TableParamsStruct::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(isHiLo);
	_msg.composeUINT32(tableSize);
	_msg.composeBOOL(isFastDealing);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(potStruct);
	_msg.composeUINT32(ante);
	_msg.composeUINT32(cap);
	_msg.composeUINT32(minBuyIn);
	_msg.composeUINT32(maxBuyIn);
	_msg.composeUINT32(stakesLow);
	_msg.composeUINT32(stakesHigh);
	_msg.composeString(tableName);
	_msg.composeINT32(scalePM);
}

void hglobby::lobby_client::TableParamsStruct::parseMsg(CommMsgParser& _parser)
{
	_parser.parseBOOL(isHiLo);
	_parser.parseUINT32(tableSize);
	_parser.parseBOOL(isFastDealing);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(potStruct);
	_parser.parseUINT32(ante);
	_parser.parseUINT32(cap);
	_parser.parseUINT32(minBuyIn);
	_parser.parseUINT32(maxBuyIn);
	_parser.parseUINT32(stakesLow);
	_parser.parseUINT32(stakesHigh);
	_parser.parseStringP(tableName);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(scalePM);
}

const char *hglobby::lobby_client::TableParamsStruct::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("tableSize", tableSize);
	_jsonstr.compose("isFastDealing", isFastDealing);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("potStruct", potStruct);
	_jsonstr.compose("ante", ante);
	_jsonstr.compose("cap", cap);
	_jsonstr.compose("minBuyIn", minBuyIn);
	_jsonstr.compose("maxBuyIn", maxBuyIn);
	_jsonstr.compose("stakesLow", stakesLow);
	_jsonstr.compose("stakesHigh", stakesHigh);
	_jsonstr.compose("tableName", tableName);
	_jsonstr.compose("scalePM", scalePM);
	return _buf.c_str();
}

void hglobby::lobby_client::TableParamsStruct::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("tableSize", tableSize);
	_jparser.parseByNameThrow("isFastDealing", isFastDealing);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("potStruct", potStruct);
	_jparser.parseByNameThrow("ante", ante);
	_jparser.parseByNameThrow("cap", cap);
	_jparser.parseByNameThrow("minBuyIn", minBuyIn);
	_jparser.parseByNameThrow("maxBuyIn", maxBuyIn);
	_jparser.parseByNameThrow("stakesLow", stakesLow);
	_jparser.parseByNameThrow("stakesHigh", stakesHigh);
	_jparser.parseByNameThrow("tableName", tableName);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("scalePM", scalePM);
}

/* static */ void hglobby::lobby_client::TableParamsStruct::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 tableSize; _jparser.validateByNameThrow("tableSize", tableSize);
	AtfValidator::validateIntRange(_descr, "tableSize", tableSize, 2, MAX_TABLE_PLAYERS, _checker, __FILE__, __LINE__);
	bool isFastDealing; _jparser.validateByNameThrow("isFastDealing", isFastDealing);
	AtfValidator::validateInt(_descr, "isFastDealing", isFastDealing, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 5, _checker, __FILE__, __LINE__);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateIntRange(_descr, "handType", handType, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE potStruct; _jparser.validateByNameThrow("potStruct", potStruct);
	AtfValidator::validateIntRange(_descr, "potStruct", potStruct, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 ante; _jparser.validateByNameThrow("ante", ante);
	AtfValidator::validateIntMax(_descr, "ante", ante, 1000000, _checker, __FILE__, __LINE__);
	UINT32 cap; _jparser.validateByNameThrow("cap", cap);
	AtfValidator::validateIntMax(_descr, "cap", cap, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minBuyIn; _jparser.validateByNameThrow("minBuyIn", minBuyIn);
	AtfValidator::validateIntMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _jparser.validateByNameThrow("maxBuyIn", maxBuyIn);
	AtfValidator::validateIntMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 stakesLow; _jparser.validateByNameThrow("stakesLow", stakesLow);
	AtfValidator::validateIntMax(_descr, "stakesLow", stakesLow, 100000000, _checker, __FILE__, __LINE__);
	UINT32 stakesHigh; _jparser.validateByNameThrow("stakesHigh", stakesHigh);
	AtfValidator::validateIntMax(_descr, "stakesHigh", stakesHigh, 100000000, _checker, __FILE__, __LINE__);
	PString tableName; _jparser.validateByNameThrow("tableName", tableName);
	AtfValidator::validateIntMax(_descr, "tableName", tableName.length(), TABLE_NAME_LEN, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateIntRange(_descr, "scalePM", scalePM, 1, 1000000, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::TableParamsStruct::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 tableSize; _parser.parseUINT32(tableSize);
	AtfValidator::validateIntRange(_descr, "tableSize", tableSize, 2, MAX_TABLE_PLAYERS, _checker, __FILE__, __LINE__);
	bool isFastDealing; _parser.parseBOOL(isFastDealing);
	AtfValidator::validateInt(_descr, "isFastDealing", isFastDealing, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateIntRange(_descr, "handType", handType, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateIntRange(_descr, "potStruct", potStruct, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 ante; _parser.parseUINT32(ante);
	AtfValidator::validateIntMax(_descr, "ante", ante, 1000000, _checker, __FILE__, __LINE__);
	UINT32 cap; _parser.parseUINT32(cap);
	AtfValidator::validateIntMax(_descr, "cap", cap, 1000000, _checker, __FILE__, __LINE__);
	UINT32 minBuyIn; _parser.parseUINT32(minBuyIn);
	AtfValidator::validateIntMax(_descr, "minBuyIn", minBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 maxBuyIn; _parser.parseUINT32(maxBuyIn);
	AtfValidator::validateIntMax(_descr, "maxBuyIn", maxBuyIn, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 stakesLow; _parser.parseUINT32(stakesLow);
	AtfValidator::validateIntMax(_descr, "stakesLow", stakesLow, 100000000, _checker, __FILE__, __LINE__);
	UINT32 stakesHigh; _parser.parseUINT32(stakesHigh);
	AtfValidator::validateIntMax(_descr, "stakesHigh", stakesHigh, 100000000, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tableName", szTableName, TABLE_NAME_LEN, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateIntRange(_descr, "scalePM", scalePM, 1, 1000000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                    TableParams
//=================================================================

hglobby::lobby_client::TableParams::TableParams()
{
	clear();
}

void hglobby::lobby_client::TableParams::clear()
{
	tableParamsStruct.clear();
}

bool hglobby::lobby_client::TableParams::equals(const TableParams& _o) const
{
	return tableParamsStruct.equals(_o.tableParamsStruct);
}

const char *hglobby::lobby_client::TableParams::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("tableParamsStruct=");
	tableParamsStruct.toTraceString(_buf);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::TableParams::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	tableParamsStruct.toXmlString("tableParamsStruct", _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::TableParams::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("tableParamsStruct"))
		{
			if(!Atf::AtfTempl< TableParamsStruct >::FromXmlString(_value, tableParamsStruct)) return false;
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::TableParams::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(TableParams())) // not empty
	{
		tableParamsStruct.composeMsg(_body, _ignoreJSON);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::TableParams::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	tableParamsStruct.parseMsg(_parser0);
}

const char *hglobby::lobby_client::TableParams::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableParamsStruct", tableParamsStruct);
	return _buf.c_str();
}

void hglobby::lobby_client::TableParams::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableParamsStruct", tableParamsStruct);
}

/* static */ void hglobby::lobby_client::TableParams::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	TableParamsStruct tableParamsStruct; _jparser.validateByNameThrow("tableParamsStruct", tableParamsStruct);
}

/*static*/ void hglobby::lobby_client::TableParams::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	TableParamsStruct::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("tableParamsStruct"), _fieldsWithUnparsedContent);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tableParams.clear();
	isVoceEnabled = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::equals(const Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tableParams.equals(_o.tableParams) &&
		isVoceEnabled == _o.isVoceEnabled;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TABLE_STRUCTURES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_STRUCTURES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableParams=");
		tableParams.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isVoceEnabled=");
		_buf.appendUint(isVoceEnabled);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TABLE_STRUCTURES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		tableParams.toXmlString("tableParams", _buf);
		Atf::XmlElement::encodeAsXmlElement("isVoceEnabled", isVoceEnabled, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tableParams"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableParams, 4 > >::FromXmlString(_value, tableParams)) return false;
			}
			else if (_element.equals("isVoceEnabled"))
			{
				isVoceEnabled = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tableParams.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(isVoceEnabled);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tableParams.parseMsg(_parser);
		_parser.parseBOOL(isVoceEnabled);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tableParams", tableParams);
		_jsonstr.compose("isVoceEnabled", isVoceEnabled);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tableParams", tableParams);
		_jparser.parseByNameThrow("isVoceEnabled", isVoceEnabled);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< TableParams > tableParams; _jparser.validateByNameThrow("tableParams", tableParams);
		AtfValidator::validateInt(_descr, "tableParams", tableParams.size(), _checker, __FILE__, __LINE__);
		bool isVoceEnabled; _jparser.validateByNameThrow("isVoceEnabled", isVoceEnabled);
		AtfValidator::validateInt(_descr, "isVoceEnabled", isVoceEnabled, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTableParams = Atf::LAtfVector< TableParams, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableParams"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tableParams", szTableParams, _checker, __FILE__, __LINE__);
		bool isVoceEnabled; _parser.parseBOOL(isVoceEnabled);
		AtfValidator::validateInt(_descr, "isVoceEnabled", isVoceEnabled, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    CreateTournParams
//=================================================================

hglobby::lobby_client::CreateTournParams::CreateTournParams()
{
	clear();
}

void hglobby::lobby_client::CreateTournParams::clear()
{
	clubId = 0;
	tournamentLobbyText.clear();
	gameName.clear();
	countTowardsClubStandings = false;
	isHiLo = false;
	tableSize = 0;
	isFastDealing = false;
	isPlayMoney = false;
	currency.clear();
	handType = 0;
	potStruct = 0;
	buyIn = 0;
	isSyncBreaksOn = false;
	tournFormat = 0;
	payout = 0;
	startingChips = 0;
	levelLength = 0;
	tournKnockoutPrize = 0;
	tournMaxPlayers = 0;
	year = 0;
	month = 0;
	day = 0;
	hour = 0;
	minute = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::CreateTournParams::equals(const CreateTournParams& _o) const
{
	return clubId == _o.clubId &&
		Atf::atfPStringEquals(tournamentLobbyText, _o.tournamentLobbyText) &&
		Atf::atfPStringEquals(gameName, _o.gameName) &&
		countTowardsClubStandings == _o.countTowardsClubStandings &&
		isHiLo == _o.isHiLo &&
		tableSize == _o.tableSize &&
		isFastDealing == _o.isFastDealing &&
		isPlayMoney == _o.isPlayMoney &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		handType == _o.handType &&
		potStruct == _o.potStruct &&
		buyIn == _o.buyIn &&
		isSyncBreaksOn == _o.isSyncBreaksOn &&
		tournFormat == _o.tournFormat &&
		payout == _o.payout &&
		startingChips == _o.startingChips &&
		levelLength == _o.levelLength &&
		tournKnockoutPrize == _o.tournKnockoutPrize &&
		tournMaxPlayers == _o.tournMaxPlayers &&
		year == _o.year &&
		month == _o.month &&
		day == _o.day &&
		hour == _o.hour &&
		minute == _o.minute &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::CreateTournParams::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tournamentLobbyText=");
	_buf.append(tournamentLobbyText);
	_buf.append(',');
	_buf.append("gameName=");
	_buf.append(gameName);
	_buf.append(',');
	_buf.append("countTowardsClubStandings=");
	_buf.appendUint(countTowardsClubStandings);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("tableSize=");
	_buf.appendUint(tableSize);
	_buf.append(',');
	_buf.append("isFastDealing=");
	_buf.appendUint(isFastDealing);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("handType=");
	_buf.appendUint(handType);
	_buf.append(',');
	_buf.append("potStruct=");
	_buf.appendUint(potStruct);
	_buf.append(',');
	_buf.append("buyIn=");
	_buf.appendUint(buyIn);
	_buf.append(',');
	_buf.append("isSyncBreaksOn=");
	_buf.appendUint(isSyncBreaksOn);
	_buf.append(',');
	_buf.append("tournFormat=");
	_buf.appendUint(tournFormat);
	_buf.append(',');
	_buf.append("payout=");
	_buf.appendUint(payout);
	_buf.append(',');
	_buf.append("startingChips=");
	_buf.appendUint(startingChips);
	_buf.append(',');
	_buf.append("levelLength=");
	_buf.appendUint(levelLength);
	_buf.append(',');
	_buf.append("tournKnockoutPrize=");
	_buf.appendUint(tournKnockoutPrize);
	_buf.append(',');
	_buf.append("tournMaxPlayers=");
	_buf.appendUint(tournMaxPlayers);
	_buf.append(',');
	_buf.append("year=");
	_buf.appendUint(year);
	_buf.append(',');
	_buf.append("month=");
	_buf.appendUint(month);
	_buf.append(',');
	_buf.append("day=");
	_buf.appendUint(day);
	_buf.append(',');
	_buf.append("hour=");
	_buf.appendUint(hour);
	_buf.append(',');
	_buf.append("minute=");
	_buf.appendUint(minute);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::CreateTournParams::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournamentLobbyText", tournamentLobbyText, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameName", gameName, _buf);
	Atf::XmlElement::encodeAsXmlElement("countTowardsClubStandings", countTowardsClubStandings, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableSize", tableSize, _buf);
	Atf::XmlElement::encodeAsXmlElement("isFastDealing", isFastDealing, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("handType", handType, _buf);
	Atf::XmlElement::encodeAsXmlElement("potStruct", potStruct, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyIn", buyIn, _buf);
	Atf::XmlElement::encodeAsXmlElement("isSyncBreaksOn", isSyncBreaksOn, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournFormat", tournFormat, _buf);
	Atf::XmlElement::encodeAsXmlElement("payout", payout, _buf);
	Atf::XmlElement::encodeAsXmlElement("startingChips", startingChips, _buf);
	Atf::XmlElement::encodeAsXmlElement("levelLength", levelLength, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournKnockoutPrize", tournKnockoutPrize, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournMaxPlayers", tournMaxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("year", year, _buf);
	Atf::XmlElement::encodeAsXmlElement("month", month, _buf);
	Atf::XmlElement::encodeAsXmlElement("day", day, _buf);
	Atf::XmlElement::encodeAsXmlElement("hour", hour, _buf);
	Atf::XmlElement::encodeAsXmlElement("minute", minute, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::CreateTournParams::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournamentLobbyText"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournamentLobbyText)) return false;
		}
		else if (_element.equals("gameName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, gameName)) return false;
		}
		else if (_element.equals("countTowardsClubStandings"))
		{
			countTowardsClubStandings = (*_value.ptr() == '1');
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("tableSize"))
		{
			tableSize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isFastDealing"))
		{
			isFastDealing = (*_value.ptr() == '1');
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("handType"))
		{
			handType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("potStruct"))
		{
			potStruct = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("buyIn"))
		{
			buyIn = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isSyncBreaksOn"))
		{
			isSyncBreaksOn = (*_value.ptr() == '1');
		}
		else if (_element.equals("tournFormat"))
		{
			tournFormat = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("payout"))
		{
			payout = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("startingChips"))
		{
			startingChips = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("levelLength"))
		{
			levelLength = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournKnockoutPrize"))
		{
			tournKnockoutPrize = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournMaxPlayers"))
		{
			tournMaxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("year"))
		{
			year = (UINT16)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("month"))
		{
			month = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("day"))
		{
			day = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("hour"))
		{
			hour = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("minute"))
		{
			minute = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::CreateTournParams::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(tournamentLobbyText);
	_msg.composeString(gameName);
	_msg.composeBOOL(countTowardsClubStandings);
	_msg.composeBOOL(isHiLo);
	_msg.composeUINT32(tableSize);
	_msg.composeBOOL(isFastDealing);
	_msg.composeBOOL(isPlayMoney);
	_msg.composeString(currency);
	_msg.composeBYTE(handType);
	_msg.composeBYTE(potStruct);
	_msg.composeUINT32(buyIn);
	_msg.composeBOOL(isSyncBreaksOn);
	_msg.composeUINT32(tournFormat);
	_msg.composeUINT32(payout);
	_msg.composeUINT32(startingChips);
	_msg.composeUINT32(levelLength);
	_msg.composeUINT32(tournKnockoutPrize);
	_msg.composeUINT32(tournMaxPlayers);
	_msg.composeUINT16(year);
	_msg.composeBYTE(month);
	_msg.composeBYTE(day);
	_msg.composeBYTE(hour);
	_msg.composeBYTE(minute);
	_msg.composeINT32(scalePM);
}

void hglobby::lobby_client::CreateTournParams::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(tournamentLobbyText);
	_parser.parseStringP(gameName);
	_parser.parseBOOL(countTowardsClubStandings);
	_parser.parseBOOL(isHiLo);
	_parser.parseUINT32(tableSize);
	_parser.parseBOOL(isFastDealing);
	_parser.parseBOOL(isPlayMoney);
	_parser.parseStringP(currency);
	_parser.parseBYTE(handType);
	_parser.parseBYTE(potStruct);
	_parser.parseUINT32(buyIn);
	_parser.parseBOOL(isSyncBreaksOn);
	_parser.parseUINT32(tournFormat);
	_parser.parseUINT32(payout);
	_parser.parseUINT32(startingChips);
	_parser.parseUINT32(levelLength);
	_parser.parseUINT32(tournKnockoutPrize);
	_parser.parseUINT32(tournMaxPlayers);
	_parser.parseUINT16(year);
	_parser.parseBYTE(month);
	_parser.parseBYTE(day);
	_parser.parseBYTE(hour);
	_parser.parseBYTE(minute);
	if(_parser.parseEnded()) return;
	_parser.parseINT32(scalePM);
}

const char *hglobby::lobby_client::CreateTournParams::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("tournamentLobbyText", tournamentLobbyText);
	_jsonstr.compose("gameName", gameName);
	_jsonstr.compose("countTowardsClubStandings", countTowardsClubStandings);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("tableSize", tableSize);
	_jsonstr.compose("isFastDealing", isFastDealing);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("handType", handType);
	_jsonstr.compose("potStruct", potStruct);
	_jsonstr.compose("buyIn", buyIn);
	_jsonstr.compose("isSyncBreaksOn", isSyncBreaksOn);
	_jsonstr.compose("tournFormat", tournFormat);
	_jsonstr.compose("payout", payout);
	_jsonstr.compose("startingChips", startingChips);
	_jsonstr.compose("levelLength", levelLength);
	_jsonstr.compose("tournKnockoutPrize", tournKnockoutPrize);
	_jsonstr.compose("tournMaxPlayers", tournMaxPlayers);
	_jsonstr.compose("year", year);
	_jsonstr.compose("month", month);
	_jsonstr.compose("day", day);
	_jsonstr.compose("hour", hour);
	_jsonstr.compose("minute", minute);
	_jsonstr.compose("scalePM", scalePM);
	return _buf.c_str();
}

void hglobby::lobby_client::CreateTournParams::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("tournamentLobbyText", tournamentLobbyText);
	_jparser.parseByNameThrow("gameName", gameName);
	_jparser.parseByNameThrow("countTowardsClubStandings", countTowardsClubStandings);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("tableSize", tableSize);
	_jparser.parseByNameThrow("isFastDealing", isFastDealing);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("handType", handType);
	_jparser.parseByNameThrow("potStruct", potStruct);
	_jparser.parseByNameThrow("buyIn", buyIn);
	_jparser.parseByNameThrow("isSyncBreaksOn", isSyncBreaksOn);
	_jparser.parseByNameThrow("tournFormat", tournFormat);
	_jparser.parseByNameThrow("payout", payout);
	_jparser.parseByNameThrow("startingChips", startingChips);
	_jparser.parseByNameThrow("levelLength", levelLength);
	_jparser.parseByNameThrow("tournKnockoutPrize", tournKnockoutPrize);
	_jparser.parseByNameThrow("tournMaxPlayers", tournMaxPlayers);
	_jparser.parseByNameThrow("year", year);
	_jparser.parseByNameThrow("month", month);
	_jparser.parseByNameThrow("day", day);
	_jparser.parseByNameThrow("hour", hour);
	_jparser.parseByNameThrow("minute", minute);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("scalePM", scalePM);
}

/* static */ void hglobby::lobby_client::CreateTournParams::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString tournamentLobbyText; _jparser.validateByNameThrow("tournamentLobbyText", tournamentLobbyText);
	AtfValidator::validateIntMax(_descr, "tournamentLobbyText", tournamentLobbyText.length(), 1024, _checker, __FILE__, __LINE__);
	PString gameName; _jparser.validateByNameThrow("gameName", gameName);
	AtfValidator::validateIntMax(_descr, "gameName", gameName.length(), 128, _checker, __FILE__, __LINE__);
	bool countTowardsClubStandings; _jparser.validateByNameThrow("countTowardsClubStandings", countTowardsClubStandings);
	AtfValidator::validateInt(_descr, "countTowardsClubStandings", countTowardsClubStandings, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 tableSize; _jparser.validateByNameThrow("tableSize", tableSize);
	AtfValidator::validateIntRange(_descr, "tableSize", tableSize, 2, 10, _checker, __FILE__, __LINE__);
	bool isFastDealing; _jparser.validateByNameThrow("isFastDealing", isFastDealing);
	AtfValidator::validateInt(_descr, "isFastDealing", isFastDealing, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateIntMax(_descr, "currency", currency.length(), 5, _checker, __FILE__, __LINE__);
	BYTE handType; _jparser.validateByNameThrow("handType", handType);
	AtfValidator::validateIntRange(_descr, "handType", handType, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE potStruct; _jparser.validateByNameThrow("potStruct", potStruct);
	AtfValidator::validateIntRange(_descr, "potStruct", potStruct, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _jparser.validateByNameThrow("buyIn", buyIn);
	AtfValidator::validateIntMax(_descr, "buyIn", buyIn, 2000000000, _checker, __FILE__, __LINE__);
	bool isSyncBreaksOn; _jparser.validateByNameThrow("isSyncBreaksOn", isSyncBreaksOn);
	AtfValidator::validateInt(_descr, "isSyncBreaksOn", isSyncBreaksOn, _checker, __FILE__, __LINE__);
	UINT32 tournFormat; _jparser.validateByNameThrow("tournFormat", tournFormat);
	AtfValidator::validateIntMax(_descr, "tournFormat", tournFormat, eHgTournFormatRebuy2RnoA, _checker, __FILE__, __LINE__);
	UINT32 payout; _jparser.validateByNameThrow("payout", payout);
	AtfValidator::validateIntMax(_descr, "payout", payout, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 startingChips; _jparser.validateByNameThrow("startingChips", startingChips);
	AtfValidator::validateIntMax(_descr, "startingChips", startingChips, 100000, _checker, __FILE__, __LINE__);
	UINT32 levelLength; _jparser.validateByNameThrow("levelLength", levelLength);
	AtfValidator::validateIntMax(_descr, "levelLength", levelLength, 10000, _checker, __FILE__, __LINE__);
	UINT32 tournKnockoutPrize; _jparser.validateByNameThrow("tournKnockoutPrize", tournKnockoutPrize);
	AtfValidator::validateIntMax(_descr, "tournKnockoutPrize", tournKnockoutPrize, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 tournMaxPlayers; _jparser.validateByNameThrow("tournMaxPlayers", tournMaxPlayers);
	AtfValidator::validateIntMax(_descr, "tournMaxPlayers", tournMaxPlayers, 1000000, _checker, __FILE__, __LINE__);
	UINT16 year; _jparser.validateByNameThrow("year", year);
	AtfValidator::validateIntRange(_descr, "year", year, 2016, 3000, _checker, __FILE__, __LINE__);
	BYTE month; _jparser.validateByNameThrow("month", month);
	AtfValidator::validateIntRange(_descr, "month", month, 1, 12, _checker, __FILE__, __LINE__);
	BYTE day; _jparser.validateByNameThrow("day", day);
	AtfValidator::validateIntRange(_descr, "day", day, 1, 31, _checker, __FILE__, __LINE__);
	BYTE hour; _jparser.validateByNameThrow("hour", hour);
	AtfValidator::validateIntMax(_descr, "hour", hour, 23, _checker, __FILE__, __LINE__);
	BYTE minute; _jparser.validateByNameThrow("minute", minute);
	AtfValidator::validateIntMax(_descr, "minute", minute, 59, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateIntRange(_descr, "scalePM", scalePM, 1, 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::CreateTournParams::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "tournamentLobbyText"); size_t szTournamentLobbyText = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "tournamentLobbyText", szTournamentLobbyText, 1024, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "gameName"); size_t szGameName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "gameName", szGameName, 128, _checker, __FILE__, __LINE__);
	bool countTowardsClubStandings; _parser.parseBOOL(countTowardsClubStandings);
	AtfValidator::validateInt(_descr, "countTowardsClubStandings", countTowardsClubStandings, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 tableSize; _parser.parseUINT32(tableSize);
	AtfValidator::validateIntRange(_descr, "tableSize", tableSize, 2, 10, _checker, __FILE__, __LINE__);
	bool isFastDealing; _parser.parseBOOL(isFastDealing);
	AtfValidator::validateInt(_descr, "isFastDealing", isFastDealing, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "currency", szCurrency, 5, _checker, __FILE__, __LINE__);
	BYTE handType; _parser.parseBYTE(handType);
	AtfValidator::validateIntRange(_descr, "handType", handType, 1, HandType_Last, _checker, __FILE__, __LINE__);
	BYTE potStruct; _parser.parseBYTE(potStruct);
	AtfValidator::validateIntRange(_descr, "potStruct", potStruct, StructLimit, PotStruct_Last, _checker, __FILE__, __LINE__);
	UINT32 buyIn; _parser.parseUINT32(buyIn);
	AtfValidator::validateIntMax(_descr, "buyIn", buyIn, 2000000000, _checker, __FILE__, __LINE__);
	bool isSyncBreaksOn; _parser.parseBOOL(isSyncBreaksOn);
	AtfValidator::validateInt(_descr, "isSyncBreaksOn", isSyncBreaksOn, _checker, __FILE__, __LINE__);
	UINT32 tournFormat; _parser.parseUINT32(tournFormat);
	AtfValidator::validateIntMax(_descr, "tournFormat", tournFormat, eHgTournFormatRebuy2RnoA, _checker, __FILE__, __LINE__);
	UINT32 payout; _parser.parseUINT32(payout);
	AtfValidator::validateIntMax(_descr, "payout", payout, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 startingChips; _parser.parseUINT32(startingChips);
	AtfValidator::validateIntMax(_descr, "startingChips", startingChips, 100000, _checker, __FILE__, __LINE__);
	UINT32 levelLength; _parser.parseUINT32(levelLength);
	AtfValidator::validateIntMax(_descr, "levelLength", levelLength, 10000, _checker, __FILE__, __LINE__);
	UINT32 tournKnockoutPrize; _parser.parseUINT32(tournKnockoutPrize);
	AtfValidator::validateIntMax(_descr, "tournKnockoutPrize", tournKnockoutPrize, 2000000000, _checker, __FILE__, __LINE__);
	UINT32 tournMaxPlayers; _parser.parseUINT32(tournMaxPlayers);
	AtfValidator::validateIntMax(_descr, "tournMaxPlayers", tournMaxPlayers, 1000000, _checker, __FILE__, __LINE__);
	UINT16 year; _parser.parseUINT16(year);
	AtfValidator::validateIntRange(_descr, "year", year, 2016, 3000, _checker, __FILE__, __LINE__);
	BYTE month; _parser.parseBYTE(month);
	AtfValidator::validateIntRange(_descr, "month", month, 1, 12, _checker, __FILE__, __LINE__);
	BYTE day; _parser.parseBYTE(day);
	AtfValidator::validateIntRange(_descr, "day", day, 1, 31, _checker, __FILE__, __LINE__);
	BYTE hour; _parser.parseBYTE(hour);
	AtfValidator::validateIntMax(_descr, "hour", hour, 23, _checker, __FILE__, __LINE__);
	BYTE minute; _parser.parseBYTE(minute);
	AtfValidator::validateIntMax(_descr, "minute", minute, 59, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	INT32 scalePM; _parser.parseINT32(scalePM);
	AtfValidator::validateIntRange(_descr, "scalePM", scalePM, 1, 10000, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::Protocol_HG_CREATE_CLUB_TOURN()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::clear()
{
	createTournParams.clear();
	recurringPatternType = 0;
	nbOccurences = 0;
	endDate.setNull();
	numberOfDays = 0;
	everyWeekday = false;
	numberOfWeeks = 0;
	recurringDays = 0;
	dayOfMonth = 0;
	numberMonths = 0;
	whichRecurringDay = 0;
	recurringDay = 0;
	nbConsecutiveCancellation = 0;
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::equals(const Protocol_HG_CREATE_CLUB_TOURN& _o) const
{
	return createTournParams.equals(_o.createTournParams) &&
		recurringPatternType == _o.recurringPatternType &&
		nbOccurences == _o.nbOccurences &&
		endDate.equals(_o.endDate) &&
		numberOfDays == _o.numberOfDays &&
		everyWeekday == _o.everyWeekday &&
		numberOfWeeks == _o.numberOfWeeks &&
		recurringDays == _o.recurringDays &&
		dayOfMonth == _o.dayOfMonth &&
		numberMonths == _o.numberMonths &&
		whichRecurringDay == _o.whichRecurringDay &&
		recurringDay == _o.recurringDay &&
		nbConsecutiveCancellation == _o.nbConsecutiveCancellation;
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB_TOURN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB_TOURN*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN).append(")");
	_buf.append(',');
	_buf.append("createTournParams=");
	createTournParams.toTraceString(_buf);
	_buf.append(',');
	_buf.append("recurringPatternType=");
	_buf.appendUint(recurringPatternType);
	_buf.append(',');
	_buf.append("nbOccurences=");
	_buf.appendUint(nbOccurences);
	_buf.append(',');
	_buf.append("endDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		_buf.append(',');
		_buf.append("numberOfDays=");
		_buf.appendUint(numberOfDays);
		_buf.append(',');
		_buf.append("everyWeekday=");
		_buf.appendUint(everyWeekday);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		_buf.append(',');
		_buf.append("numberOfWeeks=");
		_buf.appendUint(numberOfWeeks);
		_buf.append(',');
		_buf.append("recurringDays=");
		_buf.appendUint(recurringDays);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		_buf.append(',');
		_buf.append("dayOfMonth=");
		_buf.appendUint(dayOfMonth);
		_buf.append(',');
		_buf.append("numberMonths=");
		_buf.appendUint(numberMonths);
		_buf.append(',');
		_buf.append("whichRecurringDay=");
		_buf.appendUint(whichRecurringDay);
		_buf.append(',');
		_buf.append("recurringDay=");
		_buf.appendUint(recurringDay);
	}
	_buf.append(',');
	_buf.append("nbConsecutiveCancellation=");
	_buf.appendUint(nbConsecutiveCancellation);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB_TOURN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	createTournParams.toXmlString("createTournParams", _buf);
	Atf::XmlElement::encodeAsXmlElement("recurringPatternType", recurringPatternType, _buf);
	Atf::XmlElement::encodeAsXmlElement("nbOccurences", nbOccurences, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		Atf::XmlElement::encodeAsXmlElement("numberOfDays", numberOfDays, _buf);
		Atf::XmlElement::encodeAsXmlElement("everyWeekday", everyWeekday, _buf);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		Atf::XmlElement::encodeAsXmlElement("numberOfWeeks", numberOfWeeks, _buf);
		Atf::XmlElement::encodeAsXmlElement("recurringDays", recurringDays, _buf);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		Atf::XmlElement::encodeAsXmlElement("dayOfMonth", dayOfMonth, _buf);
		Atf::XmlElement::encodeAsXmlElement("numberMonths", numberMonths, _buf);
		Atf::XmlElement::encodeAsXmlElement("whichRecurringDay", whichRecurringDay, _buf);
		Atf::XmlElement::encodeAsXmlElement("recurringDay", recurringDay, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("nbConsecutiveCancellation", nbConsecutiveCancellation, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("createTournParams"))
			{
				if(!Atf::AtfTempl< CreateTournParams >::FromXmlString(_value, createTournParams)) return false;
			}
			else if (_element.equals("recurringPatternType"))
			{
				recurringPatternType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nbOccurences"))
			{
				nbOccurences = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("endDate"))
			{
				Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
			}
			else if (_element.equals("numberOfDays"))
			{
				numberOfDays = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("everyWeekday"))
			{
				everyWeekday = (*_value.ptr() == '1');
			}
			else if (_element.equals("numberOfWeeks"))
			{
				numberOfWeeks = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("recurringDays"))
			{
				recurringDays = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dayOfMonth"))
			{
				dayOfMonth = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("numberMonths"))
			{
				numberMonths = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("whichRecurringDay"))
			{
				whichRecurringDay = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("recurringDay"))
			{
				recurringDay = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("nbConsecutiveCancellation"))
			{
				nbConsecutiveCancellation = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	createTournParams.composeMsg(_msg, _ignoreJSON);
	_msg.composeUINT32(recurringPatternType);
	_msg.composeUINT32(nbOccurences);
	_msg.composeSrvDate(endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		CommMsgBody _msg0;
		_msg0.composeUINT32(numberOfDays);
		_msg0.composeBOOL(everyWeekday);
		_msg.composeMsgBody(_msg0);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		CommMsgBody _msg1;
		_msg1.composeUINT32(numberOfWeeks);
		_msg1.composeUINT32(recurringDays);
		_msg.composeMsgBody(_msg1);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		CommMsgBody _msg2;
		_msg2.composeBYTE(dayOfMonth);
		_msg2.composeBYTE(numberMonths);
		_msg2.composeUINT32(whichRecurringDay);
		_msg2.composeUINT32(recurringDay);
		_msg.composeMsgBody(_msg2);
	}
	_msg.composeUINT32(nbConsecutiveCancellation);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::parseMsg(CommMsgParser& _parser)
{
	createTournParams.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(recurringPatternType);
	_parser.parseUINT32(nbOccurences);
	_parser.parseSrvDate(endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		parseAnonymousMsgBody0(_parser);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		parseAnonymousMsgBody1(_parser);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		parseAnonymousMsgBody2(_parser);
	}
	_parser.parseUINT32(nbConsecutiveCancellation);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("createTournParams", createTournParams);
	_jsonstr.compose("recurringPatternType", recurringPatternType);
	_jsonstr.compose("nbOccurences", nbOccurences);
	_jsonstr.compose("endDate", endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		_jsonstr.compose("numberOfDays", numberOfDays);
		_jsonstr.compose("everyWeekday", everyWeekday);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		_jsonstr.compose("numberOfWeeks", numberOfWeeks);
		_jsonstr.compose("recurringDays", recurringDays);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		_jsonstr.compose("dayOfMonth", dayOfMonth);
		_jsonstr.compose("numberMonths", numberMonths);
		_jsonstr.compose("whichRecurringDay", whichRecurringDay);
		_jsonstr.compose("recurringDay", recurringDay);
	}
	_jsonstr.compose("nbConsecutiveCancellation", nbConsecutiveCancellation);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("createTournParams", createTournParams);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("recurringPatternType", recurringPatternType);
	_jparser.parseByNameThrow("nbOccurences", nbOccurences);
	_jparser.parseByNameThrow("endDate", endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		_jparser.parseByNameThrow("numberOfDays", numberOfDays);
		_jparser.parseByNameThrow("everyWeekday", everyWeekday);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		_jparser.parseByNameThrow("numberOfWeeks", numberOfWeeks);
		_jparser.parseByNameThrow("recurringDays", recurringDays);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		_jparser.parseByNameThrow("dayOfMonth", dayOfMonth);
		_jparser.parseByNameThrow("numberMonths", numberMonths);
		_jparser.parseByNameThrow("whichRecurringDay", whichRecurringDay);
		_jparser.parseByNameThrow("recurringDay", recurringDay);
	}
	_jparser.parseByNameThrow("nbConsecutiveCancellation", nbConsecutiveCancellation);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 recurringPatternType = 0;
	CreateTournParams createTournParams; _jparser.validateByNameThrow("createTournParams", createTournParams);
	if(_jparser.parseEnded()) return;
	_jparser.validateByNameThrow("recurringPatternType", recurringPatternType);
	AtfValidator::validateIntMax(_descr, "recurringPatternType", recurringPatternType, eHgRecurringMonthly, _checker, __FILE__, __LINE__);
	UINT32 nbOccurences; _jparser.validateByNameThrow("nbOccurences", nbOccurences);
	AtfValidator::validateIntMax(_descr, "nbOccurences", nbOccurences, 10000, _checker, __FILE__, __LINE__);
	SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	if (recurringPatternType == eHgRecurringDaily)
	{
		UINT32 numberOfDays; _jparser.validateByNameThrow("numberOfDays", numberOfDays);
		AtfValidator::validateIntMax(_descr, "numberOfDays", numberOfDays, 10000, _checker, __FILE__, __LINE__);
		bool everyWeekday; _jparser.validateByNameThrow("everyWeekday", everyWeekday);
		AtfValidator::validateInt(_descr, "everyWeekday", everyWeekday, _checker, __FILE__, __LINE__);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		UINT32 numberOfWeeks; _jparser.validateByNameThrow("numberOfWeeks", numberOfWeeks);
		AtfValidator::validateIntMax(_descr, "numberOfWeeks", numberOfWeeks, 1000, _checker, __FILE__, __LINE__);
		UINT32 recurringDays; _jparser.validateByNameThrow("recurringDays", recurringDays);
		AtfValidator::validateIntRange(_descr, "recurringDays", recurringDays, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		BYTE dayOfMonth; _jparser.validateByNameThrow("dayOfMonth", dayOfMonth);
		AtfValidator::validateIntMax(_descr, "dayOfMonth", dayOfMonth, 31, _checker, __FILE__, __LINE__);
		BYTE numberMonths; _jparser.validateByNameThrow("numberMonths", numberMonths);
		AtfValidator::validateIntMax(_descr, "numberMonths", numberMonths, 100, _checker, __FILE__, __LINE__);
		UINT32 whichRecurringDay; _jparser.validateByNameThrow("whichRecurringDay", whichRecurringDay);
		AtfValidator::validateIntRange(_descr, "whichRecurringDay", whichRecurringDay, eHgWrdNone, eHgWrdLast, _checker, __FILE__, __LINE__);
		UINT32 recurringDay; _jparser.validateByNameThrow("recurringDay", recurringDay);
		AtfValidator::validateIntRange(_descr, "recurringDay", recurringDay, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	}
	UINT32 nbConsecutiveCancellation; _jparser.validateByNameThrow("nbConsecutiveCancellation", nbConsecutiveCancellation);
	AtfValidator::validateIntMax(_descr, "nbConsecutiveCancellation", nbConsecutiveCancellation, 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 recurringPatternType = 0;
	PString _descbuf;
	CreateTournParams::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("createTournParams"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(recurringPatternType);
	AtfValidator::validateIntMax(_descr, "recurringPatternType", recurringPatternType, eHgRecurringMonthly, _checker, __FILE__, __LINE__);
	UINT32 nbOccurences; _parser.parseUINT32(nbOccurences);
	AtfValidator::validateIntMax(_descr, "nbOccurences", nbOccurences, 10000, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	if (recurringPatternType == eHgRecurringDaily)
	{
		validateAnonymousMsgBody0(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		validateAnonymousMsgBody1(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		validateAnonymousMsgBody2(_parser, _checker, _descr, _fieldsWithUnparsedContent);
	}
	UINT32 nbConsecutiveCancellation; _parser.parseUINT32(nbConsecutiveCancellation);
	AtfValidator::validateIntMax(_descr, "nbConsecutiveCancellation", nbConsecutiveCancellation, 10000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numberOfDays);
	_parser0.parseBOOL(everyWeekday);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numberOfDays; _parser0.parseUINT32(numberOfDays);
	AtfValidator::validateIntMax(_descr, "numberOfDays", numberOfDays, 10000, _checker, __FILE__, __LINE__);
	bool everyWeekday; _parser0.parseBOOL(everyWeekday);
	AtfValidator::validateInt(_descr, "everyWeekday", everyWeekday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numberOfWeeks);
	_parser0.parseUINT32(recurringDays);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numberOfWeeks; _parser0.parseUINT32(numberOfWeeks);
	AtfValidator::validateIntMax(_descr, "numberOfWeeks", numberOfWeeks, 1000, _checker, __FILE__, __LINE__);
	UINT32 recurringDays; _parser0.parseUINT32(recurringDays);
	AtfValidator::validateIntRange(_descr, "recurringDays", recurringDays, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(dayOfMonth);
	_parser0.parseBYTE(numberMonths);
	_parser0.parseUINT32(whichRecurringDay);
	_parser0.parseUINT32(recurringDay);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE dayOfMonth; _parser0.parseBYTE(dayOfMonth);
	AtfValidator::validateIntMax(_descr, "dayOfMonth", dayOfMonth, 31, _checker, __FILE__, __LINE__);
	BYTE numberMonths; _parser0.parseBYTE(numberMonths);
	AtfValidator::validateIntMax(_descr, "numberMonths", numberMonths, 100, _checker, __FILE__, __LINE__);
	UINT32 whichRecurringDay; _parser0.parseUINT32(whichRecurringDay);
	AtfValidator::validateIntRange(_descr, "whichRecurringDay", whichRecurringDay, eHgWrdNone, eHgWrdLast, _checker, __FILE__, __LINE__);
	UINT32 recurringDay; _parser0.parseUINT32(recurringDay);
	AtfValidator::validateIntRange(_descr, "recurringDay", recurringDay, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::Protocol_HG_CREATE_CLUB_TOURN_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
	tournId = 0;
	restartWarning.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::equals(const Protocol_HG_CREATE_CLUB_TOURN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(restartWarning, _o.restartWarning);
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB_TOURN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB_TOURN_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB_TOURN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("restartWarning", restartWarning, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("restartWarning"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, restartWarning)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
		_msg.composeUINT32(tournId);
		_msg.composeString(restartWarning);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(restartWarning);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("socialToken", socialToken);
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("restartWarning", restartWarning);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("socialToken", socialToken);
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("restartWarning", restartWarning);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString restartWarning; _jparser.validateByNameThrow("restartWarning", restartWarning);
		AtfValidator::validateInt(_descr, "restartWarning", restartWarning.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TABLE
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::Protocol_HG_CREATE_CLUB_TABLE()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::clear()
{
	clubId = 0;
	tableParamsStruct.clear();
	voiceEnabled = false;
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::equals(const Protocol_HG_CREATE_CLUB_TABLE& _o) const
{
	return clubId == _o.clubId &&
		tableParamsStruct.equals(_o.tableParamsStruct) &&
		voiceEnabled == _o.voiceEnabled;
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB_TABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB_TABLE*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TABLE).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tableParamsStruct=");
	tableParamsStruct.toTraceString(_buf);
	_buf.append(',');
	_buf.append("voiceEnabled=");
	_buf.appendUint(voiceEnabled);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB_TABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	tableParamsStruct.toXmlString("tableParamsStruct", _buf);
	Atf::XmlElement::encodeAsXmlElement("voiceEnabled", voiceEnabled, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableParamsStruct"))
			{
				if(!Atf::AtfTempl< TableParamsStruct >::FromXmlString(_value, tableParamsStruct)) return false;
			}
			else if (_element.equals("voiceEnabled"))
			{
				voiceEnabled = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	tableParamsStruct.composeMsg(_msg, _ignoreJSON);
	_msg.composeBOOL(voiceEnabled);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	tableParamsStruct.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(voiceEnabled);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("tableParamsStruct", tableParamsStruct);
	_jsonstr.compose("voiceEnabled", voiceEnabled);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("tableParamsStruct", tableParamsStruct);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("voiceEnabled", voiceEnabled);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	TableParamsStruct tableParamsStruct; _jparser.validateByNameThrow("tableParamsStruct", tableParamsStruct);
	if(_jparser.parseEnded()) return;
	bool voiceEnabled; _jparser.validateByNameThrow("voiceEnabled", voiceEnabled);
	AtfValidator::validateInt(_descr, "voiceEnabled", voiceEnabled, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString _descbuf;
	TableParamsStruct::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableParamsStruct"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	bool voiceEnabled; _parser.parseBOOL(voiceEnabled);
	AtfValidator::validateInt(_descr, "voiceEnabled", voiceEnabled, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TABLE_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::Protocol_HG_CREATE_CLUB_TABLE_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
	tableId32 = 0;
	restartWarning.clear();
	tableId = 0;
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::equals(const Protocol_HG_CREATE_CLUB_TABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		tableId32 == _o.tableId32 &&
		Atf::atfPStringEquals(restartWarning, _o.restartWarning) &&
		tableId == _o.tableId;
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB_TABLE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB_TABLE_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("tableId32=");
		_buf.appendUint(tableId32);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
		_buf.append(',');
		_buf.append("tableId=");
		_buf.appendUint64(tableId);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB_TABLE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
		Atf::XmlElement::encodeAsXmlElement("restartWarning", restartWarning, _buf);
		Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("restartWarning"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, restartWarning)) return false;
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
		_msg.composeUINT32(tableId32);
		_msg.composeString(restartWarning);
		_msg.composeUINT64(tableId);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
		_parser.parseUINT32(tableId32);
		_parser.parseStringP(restartWarning);
		if(_parser.parseEnded()) return;
		_parser.parseUINT64(tableId);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("socialToken", socialToken);
		_jsonstr.compose("tableId32", tableId32);
		_jsonstr.compose("restartWarning", restartWarning);
		_jsonstr.compose("tableId", tableId);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("socialToken", socialToken);
		_jparser.parseByNameThrow("tableId32", tableId32);
		_jparser.parseByNameThrow("restartWarning", restartWarning);
		if(_jparser.parseEnded()) return;
		_jparser.parseByNameThrow("tableId", tableId);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
		UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
		AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
		PString restartWarning; _jparser.validateByNameThrow("restartWarning", restartWarning);
		AtfValidator::validateInt(_descr, "restartWarning", restartWarning.length(), _checker, __FILE__, __LINE__);
		if(_jparser.parseEnded()) return;
		UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
		AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		UINT32 tableId32; _parser.parseUINT32(tableId32);
		AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
		if(_parser.parseEnded()) return;
		UINT64 tableId; _parser.parseUINT64(tableId);
		AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_UPDATE_MEMBERSHIP_FLAGS
//=================================================================

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::clear()
{
	clubId = 0;
	userId.clear();
	flags = 0;
	mask = 0;
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::equals(const Protocol_HG_UPDATE_MEMBERSHIP_FLAGS& _o) const
{
	return clubId == _o.clubId &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		flags == _o.flags &&
		mask == _o.mask;
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_UPDATE_MEMBERSHIP_FLAGS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_UPDATE_MEMBERSHIP_FLAGS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("mask=");
	_buf.appendUint(mask);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("mask", mask, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mask"))
			{
				mask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeString(userId);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(mask);
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseStringP(userId);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(mask);
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("mask", mask);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("mask", mask);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, HgMemberFlags_Last, _checker, __FILE__, __LINE__);
	UINT32 mask; _jparser.validateByNameThrow("mask", mask);
	AtfValidator::validateIntMax(_descr, "mask", mask, (2*HgMemberFlags_Last-1), _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, HgMemberFlags_Last, _checker, __FILE__, __LINE__);
	UINT32 mask; _parser.parseUINT32(mask);
	AtfValidator::validateIntMax(_descr, "mask", mask, (2*HgMemberFlags_Last-1), _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::equals(const Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_UPDATE_MEMBERSHIP_FLAGS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CANCEL_CLUB_TOURNAMENT
//=================================================================

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::Protocol_HG_CANCEL_CLUB_TOURNAMENT()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::clear()
{
	clubId = 0;
	tournId = 0;
	cancelRecurrence = false;
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::equals(const Protocol_HG_CANCEL_CLUB_TOURNAMENT& _o) const
{
	return clubId == _o.clubId &&
		tournId == _o.tournId &&
		cancelRecurrence == _o.cancelRecurrence;
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CANCEL_CLUB_TOURNAMENT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CANCEL_CLUB_TOURNAMENT*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CANCEL_CLUB_TOURNAMENT).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("cancelRecurrence=");
	_buf.appendUint(cancelRecurrence);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CANCEL_CLUB_TOURNAMENT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("cancelRecurrence", cancelRecurrence, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("cancelRecurrence"))
			{
				cancelRecurrence = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(tournId);
	_msg.composeBOOL(cancelRecurrence);
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(tournId);
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(cancelRecurrence);
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("cancelRecurrence", cancelRecurrence);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("tournId", tournId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("cancelRecurrence", cancelRecurrence);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TOURNAMENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	bool cancelRecurrence; _jparser.validateByNameThrow("cancelRecurrence", cancelRecurrence);
	AtfValidator::validateInt(_descr, "cancelRecurrence", cancelRecurrence, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TOURNAMENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	bool cancelRecurrence; _parser.parseBOOL(cancelRecurrence);
	AtfValidator::validateInt(_descr, "cancelRecurrence", cancelRecurrence, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::equals(const Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CANCEL_CLUB_TOURNAMENT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CANCEL_CLUB_TOURNAMENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CANCEL_CLUB_TOURNAMENT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TOURNAMENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TOURNAMENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CANCEL_CLUB_TABLE
//=================================================================

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::Protocol_HG_CANCEL_CLUB_TABLE()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::clear()
{
	clubId = 0;
	tableId32 = 0;
	tableId = 0;
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::equals(const Protocol_HG_CANCEL_CLUB_TABLE& _o) const
{
	return clubId == _o.clubId &&
		tableId32 == _o.tableId32 &&
		tableId == _o.tableId;
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CANCEL_CLUB_TABLE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CANCEL_CLUB_TABLE*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CANCEL_CLUB_TABLE).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CANCEL_CLUB_TABLE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(tableId32);
	_msg.composeUINT64(tableId);
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(tableId32);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("tableId32", tableId32);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableId", tableId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TABLE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CANCEL_CLUB_TABLE_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::Protocol_HG_CANCEL_CLUB_TABLE_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::equals(const Protocol_HG_CANCEL_CLUB_TABLE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CANCEL_CLUB_TABLE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CANCEL_CLUB_TABLE_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CANCEL_CLUB_TABLE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CANCEL_CLUB_TABLE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CANCEL_CLUB_TABLE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TRANSLATE_SOCIAL_EVENT
//=================================================================

hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::Protocol_HG_TRANSLATE_SOCIAL_EVENT()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::clear()
{
	socialEventToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::equals(const Protocol_HG_TRANSLATE_SOCIAL_EVENT& _o) const
{
	return Atf::atfPStringEquals(socialEventToken, _o.socialEventToken);
}

bool hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::equals(Atf::MessageProtocol* _other) const
{
	if (HG_TRANSLATE_SOCIAL_EVENT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_TRANSLATE_SOCIAL_EVENT*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TRANSLATE_SOCIAL_EVENT).append(")");
	_buf.append(',');
	_buf.append("socialEventToken=");
	_buf.append(socialEventToken);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_TRANSLATE_SOCIAL_EVENT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("socialEventToken", socialEventToken, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("socialEventToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialEventToken)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeString(socialEventToken);
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseStringP(socialEventToken);
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("socialEventToken", socialEventToken);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("socialEventToken", socialEventToken);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TRANSLATE_SOCIAL_EVENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	PString socialEventToken; _jparser.validateByNameThrow("socialEventToken", socialEventToken);
	AtfValidator::validateIntMax(_descr, "socialEventToken", socialEventToken.length(), 1000, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TRANSLATE_SOCIAL_EVENT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	_parser.parseStringN(_dummy, 0, "socialEventToken"); size_t szSocialEventToken = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "socialEventToken", szSocialEventToken, 1000, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	encUrl.clear();
}

bool hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::equals(const Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(encUrl, _o.encUrl);
}

bool hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_TRANSLATE_SOCIAL_EVENT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TRANSLATE_SOCIAL_EVENT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("encUrl=");
		_buf.append(encUrl);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_TRANSLATE_SOCIAL_EVENT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("encUrl", encUrl, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("encUrl"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, encUrl)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(encUrl);
	}
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(encUrl);
	}
}

const char *hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("encUrl", encUrl);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("encUrl", encUrl);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TRANSLATE_SOCIAL_EVENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString encUrl; _jparser.validateByNameThrow("encUrl", encUrl);
		AtfValidator::validateInt(_descr, "encUrl", encUrl.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TRANSLATE_SOCIAL_EVENT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "encUrl"); size_t szEncUrl = strlen(_dummy);
		AtfValidator::validateInt(_descr, "encUrl", szEncUrl, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_INFO
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::Protocol_HG_GET_CLUB_TABLE_INFO()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::clear()
{
	tableId32 = 0;
	tournId = 0;
	clubId = 0;
	tableId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::equals(const Protocol_HG_GET_CLUB_TABLE_INFO& _o) const
{
	return tableId32 == _o.tableId32 &&
		tournId == _o.tournId &&
		clubId == _o.clubId &&
		tableId == _o.tableId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TABLE_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TABLE_INFO*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_INFO).append(")");
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TABLE_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tableId32);
	_msg.composeUINT32(tournId);
	_msg.composeUINT32(clubId);
	_msg.composeUINT64(tableId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tableId32);
	_parser.parseUINT32(tournId);
	_parser.parseUINT32(clubId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tableId32", tableId32);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("clubId", clubId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableId", tableId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_INFO_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	server.clear();
	serverObject.clear();
	clubName.clear();
	game = 0;
	maxPlayers = 0;
	memberRole = 0;
	memberFlags = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::equals(const Protocol_HG_GET_CLUB_TABLE_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		game == _o.game &&
		maxPlayers == _o.maxPlayers &&
		memberRole == _o.memberRole &&
		memberFlags == _o.memberFlags;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TABLE_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TABLE_INFO_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("game=");
		_buf.appendUint(game);
		_buf.append(',');
		_buf.append("maxPlayers=");
		_buf.appendUint(maxPlayers);
		_buf.append(',');
		_buf.append("memberRole=");
		_buf.appendUint(memberRole);
		_buf.append(',');
		_buf.append("memberFlags=");
		_buf.appendUint(memberFlags);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TABLE_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
		Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("game", game, _buf);
		Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
		Atf::XmlElement::encodeAsXmlElement("memberRole", memberRole, _buf);
		Atf::XmlElement::encodeAsXmlElement("memberFlags", memberFlags, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("serverObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
			}
			else if (_element.equals("clubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
			}
			else if (_element.equals("game"))
			{
				game = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("maxPlayers"))
			{
				maxPlayers = (BYTE)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("memberRole"))
			{
				memberRole = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("memberFlags"))
			{
				memberFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeString(serverObject);
		_msg.composeString(clubName);
		_msg.composeBYTE(game);
		_msg.composeBYTE(maxPlayers);
		_msg.composeUINT32(memberRole);
		_msg.composeUINT32(memberFlags);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseStringP(serverObject);
		_parser.parseStringP(clubName);
		_parser.parseBYTE(game);
		_parser.parseBYTE(maxPlayers);
		_parser.parseUINT32(memberRole);
		_parser.parseUINT32(memberFlags);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("server", server);
		_jsonstr.compose("serverObject", serverObject);
		_jsonstr.compose("clubName", clubName);
		_jsonstr.compose("game", game);
		_jsonstr.compose("maxPlayers", maxPlayers);
		_jsonstr.compose("memberRole", memberRole);
		_jsonstr.compose("memberFlags", memberFlags);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("serverObject", serverObject);
		_jparser.parseByNameThrow("clubName", clubName);
		_jparser.parseByNameThrow("game", game);
		_jparser.parseByNameThrow("maxPlayers", maxPlayers);
		_jparser.parseByNameThrow("memberRole", memberRole);
		_jparser.parseByNameThrow("memberFlags", memberFlags);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
		AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
		PString clubName; _jparser.validateByNameThrow("clubName", clubName);
		AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
		BYTE game; _jparser.validateByNameThrow("game", game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		UINT32 memberRole; _jparser.validateByNameThrow("memberRole", memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _jparser.validateByNameThrow("memberFlags", memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		BYTE game; _parser.parseBYTE(game);
		AtfValidator::validateInt(_descr, "game", game, _checker, __FILE__, __LINE__);
		BYTE maxPlayers; _parser.parseBYTE(maxPlayers);
		AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
		UINT32 memberRole; _parser.parseUINT32(memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _parser.parseUINT32(memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_INFO
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::Protocol_HG_GET_CLUB_TOURN_INFO()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::clear()
{
	tourId = 0;
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::equals(const Protocol_HG_GET_CLUB_TOURN_INFO& _o) const
{
	return tourId == _o.tourId &&
		clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TOURN_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TOURN_INFO*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_INFO).append(")");
	_buf.append(',');
	_buf.append("tourId=");
	_buf.appendUint(tourId);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TOURN_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tourId", tourId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tourId"))
			{
				tourId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tourId);
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tourId);
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tourId", tourId);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tourId", tourId);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tourId; _jparser.validateByNameThrow("tourId", tourId);
	AtfValidator::validateInt(_descr, "tourId", tourId, _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tourId; _parser.parseUINT32(tourId);
	AtfValidator::validateInt(_descr, "tourId", tourId, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_INFO_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	server.clear();
	serverObject.clear();
	clubName.clear();
	memberRole = 0;
	memberFlags = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::equals(const Protocol_HG_GET_CLUB_TOURN_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		memberRole == _o.memberRole &&
		memberFlags == _o.memberFlags;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TOURN_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TOURN_INFO_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("server=");
		_buf.append(server);
		_buf.append(',');
		_buf.append("serverObject=");
		_buf.append(serverObject);
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("memberRole=");
		_buf.appendUint(memberRole);
		_buf.append(',');
		_buf.append("memberFlags=");
		_buf.appendUint(memberFlags);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TOURN_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
		Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
		Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("memberRole", memberRole, _buf);
		Atf::XmlElement::encodeAsXmlElement("memberFlags", memberFlags, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("server"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
			}
			else if (_element.equals("serverObject"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
			}
			else if (_element.equals("clubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
			}
			else if (_element.equals("memberRole"))
			{
				memberRole = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("memberFlags"))
			{
				memberFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(server);
		_msg.composeString(serverObject);
		_msg.composeString(clubName);
		_msg.composeUINT32(memberRole);
		_msg.composeUINT32(memberFlags);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(server);
		_parser.parseStringP(serverObject);
		_parser.parseStringP(clubName);
		_parser.parseUINT32(memberRole);
		_parser.parseUINT32(memberFlags);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("server", server);
		_jsonstr.compose("serverObject", serverObject);
		_jsonstr.compose("clubName", clubName);
		_jsonstr.compose("memberRole", memberRole);
		_jsonstr.compose("memberFlags", memberFlags);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("server", server);
		_jparser.parseByNameThrow("serverObject", serverObject);
		_jparser.parseByNameThrow("clubName", clubName);
		_jparser.parseByNameThrow("memberRole", memberRole);
		_jparser.parseByNameThrow("memberFlags", memberFlags);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString server; _jparser.validateByNameThrow("server", server);
		AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
		PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
		AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
		PString clubName; _jparser.validateByNameThrow("clubName", clubName);
		AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
		UINT32 memberRole; _jparser.validateByNameThrow("memberRole", memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _jparser.validateByNameThrow("memberFlags", memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
		AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
		AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		UINT32 memberRole; _parser.parseUINT32(memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _parser.parseUINT32(memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_INFO
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::Protocol_HG_GET_CLUB_INFO()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::equals(const Protocol_HG_GET_CLUB_INFO& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_INFO != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_INFO*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_INFO).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_INFO).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_INFO_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::Protocol_HG_GET_CLUB_INFO_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubName.clear();
	tablePubName.clear();
	tournPubName.clear();
	memberRole = 0;
	memberFlags = 0;
	wallPubName.clear();
	announcePubName.clear();
	membershipPubName.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::equals(const Protocol_HG_GET_CLUB_INFO_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		Atf::atfPStringEquals(tablePubName, _o.tablePubName) &&
		Atf::atfPStringEquals(tournPubName, _o.tournPubName) &&
		memberRole == _o.memberRole &&
		memberFlags == _o.memberFlags &&
		Atf::atfPStringEquals(wallPubName, _o.wallPubName) &&
		Atf::atfPStringEquals(announcePubName, _o.announcePubName) &&
		Atf::atfPStringEquals(membershipPubName, _o.membershipPubName);
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_INFO_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_INFO_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_INFO_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("tablePubName=");
		_buf.append(tablePubName);
		_buf.append(',');
		_buf.append("tournPubName=");
		_buf.append(tournPubName);
		_buf.append(',');
		_buf.append("memberRole=");
		_buf.appendUint(memberRole);
		_buf.append(',');
		_buf.append("memberFlags=");
		_buf.appendUint(memberFlags);
		_buf.append(',');
		_buf.append("wallPubName=");
		_buf.append(wallPubName);
		_buf.append(',');
		_buf.append("announcePubName=");
		_buf.append(announcePubName);
		_buf.append(',');
		_buf.append("membershipPubName=");
		_buf.append(membershipPubName);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_INFO_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("tablePubName", tablePubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournPubName", tournPubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("memberRole", memberRole, _buf);
		Atf::XmlElement::encodeAsXmlElement("memberFlags", memberFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("wallPubName", wallPubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("announcePubName", announcePubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("membershipPubName", membershipPubName, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("clubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
			}
			else if (_element.equals("tablePubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tablePubName)) return false;
			}
			else if (_element.equals("tournPubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournPubName)) return false;
			}
			else if (_element.equals("memberRole"))
			{
				memberRole = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("memberFlags"))
			{
				memberFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wallPubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, wallPubName)) return false;
			}
			else if (_element.equals("announcePubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, announcePubName)) return false;
			}
			else if (_element.equals("membershipPubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, membershipPubName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(clubName);
		_msg.composeString(tablePubName);
		_msg.composeString(tournPubName);
		_msg.composeUINT32(memberRole);
		_msg.composeUINT32(memberFlags);
		_msg.composeString(wallPubName);
		_msg.composeString(announcePubName);
		_msg.composeString(membershipPubName);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(clubName);
		_parser.parseStringP(tablePubName);
		_parser.parseStringP(tournPubName);
		_parser.parseUINT32(memberRole);
		_parser.parseUINT32(memberFlags);
		_parser.parseStringP(wallPubName);
		_parser.parseStringP(announcePubName);
		_parser.parseStringP(membershipPubName);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("clubName", clubName);
		_jsonstr.compose("tablePubName", tablePubName);
		_jsonstr.compose("tournPubName", tournPubName);
		_jsonstr.compose("memberRole", memberRole);
		_jsonstr.compose("memberFlags", memberFlags);
		_jsonstr.compose("wallPubName", wallPubName);
		_jsonstr.compose("announcePubName", announcePubName);
		_jsonstr.compose("membershipPubName", membershipPubName);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("clubName", clubName);
		_jparser.parseByNameThrow("tablePubName", tablePubName);
		_jparser.parseByNameThrow("tournPubName", tournPubName);
		_jparser.parseByNameThrow("memberRole", memberRole);
		_jparser.parseByNameThrow("memberFlags", memberFlags);
		_jparser.parseByNameThrow("wallPubName", wallPubName);
		_jparser.parseByNameThrow("announcePubName", announcePubName);
		_jparser.parseByNameThrow("membershipPubName", membershipPubName);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString clubName; _jparser.validateByNameThrow("clubName", clubName);
		AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
		PString tablePubName; _jparser.validateByNameThrow("tablePubName", tablePubName);
		AtfValidator::validateInt(_descr, "tablePubName", tablePubName.length(), _checker, __FILE__, __LINE__);
		PString tournPubName; _jparser.validateByNameThrow("tournPubName", tournPubName);
		AtfValidator::validateInt(_descr, "tournPubName", tournPubName.length(), _checker, __FILE__, __LINE__);
		UINT32 memberRole; _jparser.validateByNameThrow("memberRole", memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _jparser.validateByNameThrow("memberFlags", memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
		PString wallPubName; _jparser.validateByNameThrow("wallPubName", wallPubName);
		AtfValidator::validateInt(_descr, "wallPubName", wallPubName.length(), _checker, __FILE__, __LINE__);
		PString announcePubName; _jparser.validateByNameThrow("announcePubName", announcePubName);
		AtfValidator::validateInt(_descr, "announcePubName", announcePubName.length(), _checker, __FILE__, __LINE__);
		PString membershipPubName; _jparser.validateByNameThrow("membershipPubName", membershipPubName);
		AtfValidator::validateInt(_descr, "membershipPubName", membershipPubName.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tablePubName"); size_t szTablePubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tablePubName", szTablePubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournPubName"); size_t szTournPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournPubName", szTournPubName, _checker, __FILE__, __LINE__);
		UINT32 memberRole; _parser.parseUINT32(memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _parser.parseUINT32(memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "wallPubName"); size_t szWallPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "wallPubName", szWallPubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "announcePubName"); size_t szAnnouncePubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "announcePubName", szAnnouncePubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "membershipPubName"); size_t szMembershipPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "membershipPubName", szMembershipPubName, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_SCHEDULED_GAMES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::Protocol_HG_GET_SCHEDULED_GAMES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::clear()
{
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::equals(const Protocol_HG_GET_SCHEDULED_GAMES& _o) const
{
	return true;
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_SCHEDULED_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_SCHEDULED_GAMES*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_SCHEDULED_GAMES).append(")");
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_SCHEDULED_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::parseMsg(CommMsgParser& _parser)
{
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ScheduledTourn
//=================================================================

hglobby::lobby_client::ScheduledTourn::ScheduledTourn()
{
	clear();
}

void hglobby::lobby_client::ScheduledTourn::clear()
{
	startTime.setNull();
	clubId = 0;
	clubName.clear();
	tournId = 0;
	tournName.clear();
	gameType = 0;
	isHiLo = false;
	buyin = 0;
	rake = 0;
	knockoutBounty = 0;
	numPlayers = 0;
	isRegistered = false;
	limit = 0;
	currency.clear();
	isPlayMoney = false;
	maxPlayers = 0;
	tournState = 0;
	server.clear();
	serverObject.clear();
	flags = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::ScheduledTourn::equals(const ScheduledTourn& _o) const
{
	return startTime.equals(_o.startTime) &&
		clubId == _o.clubId &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(tournName, _o.tournName) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyin == _o.buyin &&
		rake == _o.rake &&
		knockoutBounty == _o.knockoutBounty &&
		numPlayers == _o.numPlayers &&
		isRegistered == _o.isRegistered &&
		limit == _o.limit &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		maxPlayers == _o.maxPlayers &&
		tournState == _o.tournState &&
		Atf::atfPStringEquals(server, _o.server) &&
		Atf::atfPStringEquals(serverObject, _o.serverObject) &&
		flags == _o.flags &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::ScheduledTourn::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("startTime=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, startTime);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	_buf.append(',');
	_buf.append("tournName=");
	_buf.append(tournName);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("buyin=");
	_buf.appendUint(buyin);
	_buf.append(',');
	_buf.append("rake=");
	_buf.appendUint(rake);
	_buf.append(',');
	_buf.append("knockoutBounty=");
	_buf.appendUint(knockoutBounty);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("isRegistered=");
	_buf.appendUint(isRegistered);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("maxPlayers=");
	_buf.appendUint(maxPlayers);
	_buf.append(',');
	_buf.append("tournState=");
	_buf.appendUint(tournState);
	_buf.append(',');
	_buf.append("server=");
	_buf.append(server);
	_buf.append(',');
	_buf.append("serverObject=");
	_buf.append(serverObject);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendUint(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::ScheduledTourn::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "startTime", startTime);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournName", tournName, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyin", buyin, _buf);
	Atf::XmlElement::encodeAsXmlElement("rake", rake, _buf);
	Atf::XmlElement::encodeAsXmlElement("knockoutBounty", knockoutBounty, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("isRegistered", isRegistered, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxPlayers", maxPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournState", tournState, _buf);
	Atf::XmlElement::encodeAsXmlElement("server", server, _buf);
	Atf::XmlElement::encodeAsXmlElement("serverObject", serverObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::ScheduledTourn::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("startTime"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, startTime);
		}
		else if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clubName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
		}
		else if (_element.equals("tournId"))
		{
			tournId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tournName)) return false;
		}
		else if (_element.equals("gameType"))
		{
			gameType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("buyin"))
		{
			buyin = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("rake"))
		{
			rake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("knockoutBounty"))
		{
			knockoutBounty = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isRegistered"))
		{
			isRegistered = (*_value.ptr() == '1');
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("maxPlayers"))
		{
			maxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tournState"))
		{
			tournState = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("server"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, server)) return false;
		}
		else if (_element.equals("serverObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, serverObject)) return false;
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::ScheduledTourn::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ScheduledTourn())) // not empty
	{
		_body.composeSrvTime(startTime);
		_body.composeUINT32(clubId);
		_body.composeString(clubName);
		_body.composeUINT32(tournId);
		_body.composeString(tournName);
		_body.composeBYTE(gameType);
		_body.composeBOOL(isHiLo);
		_body.composeUINT32(buyin);
		_body.composeUINT32(rake);
		_body.composeUINT32(knockoutBounty);
		_body.composeUINT32(numPlayers);
		_body.composeBOOL(isRegistered);
		_body.composeBYTE(limit);
		_body.composeString(currency);
		_body.composeBOOL(isPlayMoney);
		_body.composeUINT32(maxPlayers);
		_body.composeUINT32(tournState);
		_body.composeString(server);
		_body.composeString(serverObject);
		_body.composeUINT32(flags);
		_body.composeUINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ScheduledTourn::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseSrvTime(startTime);
	_parser0.parseUINT32(clubId);
	_parser0.parseStringP(clubName);
	_parser0.parseUINT32(tournId);
	_parser0.parseStringP(tournName);
	_parser0.parseBYTE(gameType);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseUINT32(buyin);
	_parser0.parseUINT32(rake);
	_parser0.parseUINT32(knockoutBounty);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseBOOL(isRegistered);
	_parser0.parseBYTE(limit);
	_parser0.parseStringP(currency);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseUINT32(maxPlayers);
	_parser0.parseUINT32(tournState);
	_parser0.parseStringP(server);
	_parser0.parseStringP(serverObject);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT32(scalePM);
}

const char *hglobby::lobby_client::ScheduledTourn::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("startTime", startTime);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("clubName", clubName);
	_jsonstr.compose("tournId", tournId);
	_jsonstr.compose("tournName", tournName);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("buyin", buyin);
	_jsonstr.compose("rake", rake);
	_jsonstr.compose("knockoutBounty", knockoutBounty);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("isRegistered", isRegistered);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("maxPlayers", maxPlayers);
	_jsonstr.compose("tournState", tournState);
	_jsonstr.compose("server", server);
	_jsonstr.compose("serverObject", serverObject);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("scalePM", scalePM);
	return _buf.c_str();
}

void hglobby::lobby_client::ScheduledTourn::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("startTime", startTime);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("clubName", clubName);
	_jparser.parseByNameThrow("tournId", tournId);
	_jparser.parseByNameThrow("tournName", tournName);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("buyin", buyin);
	_jparser.parseByNameThrow("rake", rake);
	_jparser.parseByNameThrow("knockoutBounty", knockoutBounty);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("isRegistered", isRegistered);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("maxPlayers", maxPlayers);
	_jparser.parseByNameThrow("tournState", tournState);
	_jparser.parseByNameThrow("server", server);
	_jparser.parseByNameThrow("serverObject", serverObject);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("scalePM", scalePM);
}

/* static */ void hglobby::lobby_client::ScheduledTourn::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime startTime; _jparser.validateByNameThrow("startTime", startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString clubName; _jparser.validateByNameThrow("clubName", clubName);
	AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	PString tournName; _jparser.validateByNameThrow("tournName", tournName);
	AtfValidator::validateInt(_descr, "tournName", tournName.length(), _checker, __FILE__, __LINE__);
	BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 buyin; _jparser.validateByNameThrow("buyin", buyin);
	AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
	UINT32 rake; _jparser.validateByNameThrow("rake", rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockoutBounty; _jparser.validateByNameThrow("knockoutBounty", knockoutBounty);
	AtfValidator::validateInt(_descr, "knockoutBounty", knockoutBounty, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	bool isRegistered; _jparser.validateByNameThrow("isRegistered", isRegistered);
	AtfValidator::validateInt(_descr, "isRegistered", isRegistered, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _jparser.validateByNameThrow("maxPlayers", maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournState; _jparser.validateByNameThrow("tournState", tournState);
	AtfValidator::validateInt(_descr, "tournState", tournState, _checker, __FILE__, __LINE__);
	PString server; _jparser.validateByNameThrow("server", server);
	AtfValidator::validateInt(_descr, "server", server.length(), _checker, __FILE__, __LINE__);
	PString serverObject; _jparser.validateByNameThrow("serverObject", serverObject);
	AtfValidator::validateInt(_descr, "serverObject", serverObject.length(), _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::ScheduledTourn::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	SrvTime startTime; _parser0.parseSrvTime(startTime);
	AtfValidator::validateSrvDateTime(_descr, "startTime", startTime, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser0.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tournName"); size_t szTournName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tournName", szTournName, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser0.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 buyin; _parser0.parseUINT32(buyin);
	AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
	UINT32 rake; _parser0.parseUINT32(rake);
	AtfValidator::validateInt(_descr, "rake", rake, _checker, __FILE__, __LINE__);
	UINT32 knockoutBounty; _parser0.parseUINT32(knockoutBounty);
	AtfValidator::validateInt(_descr, "knockoutBounty", knockoutBounty, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	bool isRegistered; _parser0.parseBOOL(isRegistered);
	AtfValidator::validateInt(_descr, "isRegistered", isRegistered, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 maxPlayers; _parser0.parseUINT32(maxPlayers);
	AtfValidator::validateInt(_descr, "maxPlayers", maxPlayers, _checker, __FILE__, __LINE__);
	UINT32 tournState; _parser0.parseUINT32(tournState);
	AtfValidator::validateInt(_descr, "tournState", tournState, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "server"); size_t szServer = strlen(_dummy);
	AtfValidator::validateInt(_descr, "server", szServer, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "serverObject"); size_t szServerObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "serverObject", szServerObject, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT32 scalePM; _parser0.parseUINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    ScheduledRingGame
//=================================================================

hglobby::lobby_client::ScheduledRingGame::ScheduledRingGame()
{
	clear();
}

void hglobby::lobby_client::ScheduledRingGame::clear()
{
	clubId = 0;
	clubName.clear();
	tableId32 = 0;
	tableName.clear();
	gameType = 0;
	isHiLo = false;
	buyin = 0;
	numPlayers = 0;
	isSeated = false;
	limit = 0;
	currency.clear();
	isPlayMoney = false;
	lowStake = 0;
	highStake = 0;
	tableObject.clear();
	maxNumPlayers = 0;
	playersSeated = 0;
	flags = 0;
	tableId = 0;
	scalePM = 0;
}

bool hglobby::lobby_client::ScheduledRingGame::equals(const ScheduledRingGame& _o) const
{
	return clubId == _o.clubId &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		tableId32 == _o.tableId32 &&
		Atf::atfPStringEquals(tableName, _o.tableName) &&
		gameType == _o.gameType &&
		isHiLo == _o.isHiLo &&
		buyin == _o.buyin &&
		numPlayers == _o.numPlayers &&
		isSeated == _o.isSeated &&
		limit == _o.limit &&
		Atf::atfPStringEquals(currency, _o.currency) &&
		isPlayMoney == _o.isPlayMoney &&
		lowStake == _o.lowStake &&
		highStake == _o.highStake &&
		Atf::atfPStringEquals(tableObject, _o.tableObject) &&
		maxNumPlayers == _o.maxNumPlayers &&
		playersSeated == _o.playersSeated &&
		flags == _o.flags &&
		tableId == _o.tableId &&
		scalePM == _o.scalePM;
}

const char *hglobby::lobby_client::ScheduledRingGame::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("clubName=");
	_buf.append(clubName);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableName=");
	_buf.append(tableName);
	_buf.append(',');
	_buf.append("gameType=");
	_buf.appendUint(gameType);
	_buf.append(',');
	_buf.append("isHiLo=");
	_buf.appendUint(isHiLo);
	_buf.append(',');
	_buf.append("buyin=");
	_buf.appendUint(buyin);
	_buf.append(',');
	_buf.append("numPlayers=");
	_buf.appendUint(numPlayers);
	_buf.append(',');
	_buf.append("isSeated=");
	_buf.appendUint(isSeated);
	_buf.append(',');
	_buf.append("limit=");
	_buf.appendUint(limit);
	_buf.append(',');
	_buf.append("currency=");
	_buf.append(currency);
	_buf.append(',');
	_buf.append("isPlayMoney=");
	_buf.appendUint(isPlayMoney);
	_buf.append(',');
	_buf.append("lowStake=");
	_buf.appendUint(lowStake);
	_buf.append(',');
	_buf.append("highStake=");
	_buf.appendUint(highStake);
	_buf.append(',');
	_buf.append("tableObject=");
	_buf.append(tableObject);
	_buf.append(',');
	_buf.append("maxNumPlayers=");
	_buf.appendUint(maxNumPlayers);
	_buf.append(',');
	_buf.append("playersSeated=");
	_buf.appendUint(playersSeated);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	_buf.append(',');
	_buf.append("scalePM=");
	_buf.appendInt(scalePM);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::ScheduledRingGame::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableName", tableName, _buf);
	Atf::XmlElement::encodeAsXmlElement("gameType", gameType, _buf);
	Atf::XmlElement::encodeAsXmlElement("isHiLo", isHiLo, _buf);
	Atf::XmlElement::encodeAsXmlElement("buyin", buyin, _buf);
	Atf::XmlElement::encodeAsXmlElement("numPlayers", numPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("isSeated", isSeated, _buf);
	Atf::XmlElement::encodeAsXmlElement("limit", limit, _buf);
	Atf::XmlElement::encodeAsXmlElement("currency", currency, _buf);
	Atf::XmlElement::encodeAsXmlElement("isPlayMoney", isPlayMoney, _buf);
	Atf::XmlElement::encodeAsXmlElement("lowStake", lowStake, _buf);
	Atf::XmlElement::encodeAsXmlElement("highStake", highStake, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableObject", tableObject, _buf);
	Atf::XmlElement::encodeAsXmlElement("maxNumPlayers", maxNumPlayers, _buf);
	Atf::XmlElement::encodeAsXmlElement("playersSeated", playersSeated, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	Atf::XmlElement::encodeAsXmlElement("scalePM", scalePM, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::ScheduledRingGame::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clubName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
		}
		else if (_element.equals("tableId32"))
		{
			tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableName"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableName)) return false;
		}
		else if (_element.equals("gameType"))
		{
			gameType = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isHiLo"))
		{
			isHiLo = (*_value.ptr() == '1');
		}
		else if (_element.equals("buyin"))
		{
			buyin = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numPlayers"))
		{
			numPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("isSeated"))
		{
			isSeated = (*_value.ptr() == '1');
		}
		else if (_element.equals("limit"))
		{
			limit = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("currency"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, currency)) return false;
		}
		else if (_element.equals("isPlayMoney"))
		{
			isPlayMoney = (*_value.ptr() == '1');
		}
		else if (_element.equals("lowStake"))
		{
			lowStake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("highStake"))
		{
			highStake = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableObject"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, tableObject)) return false;
		}
		else if (_element.equals("maxNumPlayers"))
		{
			maxNumPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("playersSeated"))
		{
			playersSeated = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("tableId"))
		{
			tableId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("scalePM"))
		{
			scalePM = (INT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::ScheduledRingGame::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(ScheduledRingGame())) // not empty
	{
		_body.composeUINT32(clubId);
		_body.composeString(clubName);
		_body.composeUINT32(tableId32);
		_body.composeString(tableName);
		_body.composeBYTE(gameType);
		_body.composeBOOL(isHiLo);
		_body.composeUINT32(buyin);
		_body.composeUINT32(numPlayers);
		_body.composeBOOL(isSeated);
		_body.composeBYTE(limit);
		_body.composeString(currency);
		_body.composeBOOL(isPlayMoney);
		_body.composeUINT32(lowStake);
		_body.composeUINT32(highStake);
		_body.composeString(tableObject);
		_body.composeUINT32(maxNumPlayers);
		_body.composeUINT32(playersSeated);
		_body.composeUINT32(flags);
		_body.composeUINT64(tableId);
		_body.composeINT32(scalePM);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::ScheduledRingGame::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(clubId);
	_parser0.parseStringP(clubName);
	_parser0.parseUINT32(tableId32);
	_parser0.parseStringP(tableName);
	_parser0.parseBYTE(gameType);
	_parser0.parseBOOL(isHiLo);
	_parser0.parseUINT32(buyin);
	_parser0.parseUINT32(numPlayers);
	_parser0.parseBOOL(isSeated);
	_parser0.parseBYTE(limit);
	_parser0.parseStringP(currency);
	_parser0.parseBOOL(isPlayMoney);
	_parser0.parseUINT32(lowStake);
	_parser0.parseUINT32(highStake);
	_parser0.parseStringP(tableObject);
	_parser0.parseUINT32(maxNumPlayers);
	_parser0.parseUINT32(playersSeated);
	_parser0.parseUINT32(flags);
	_parser0.parseUINT64(tableId);
	_parser0.parseINT32(scalePM);
}

const char *hglobby::lobby_client::ScheduledRingGame::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("clubName", clubName);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("tableName", tableName);
	_jsonstr.compose("gameType", gameType);
	_jsonstr.compose("isHiLo", isHiLo);
	_jsonstr.compose("buyin", buyin);
	_jsonstr.compose("numPlayers", numPlayers);
	_jsonstr.compose("isSeated", isSeated);
	_jsonstr.compose("limit", limit);
	_jsonstr.compose("currency", currency);
	_jsonstr.compose("isPlayMoney", isPlayMoney);
	_jsonstr.compose("lowStake", lowStake);
	_jsonstr.compose("highStake", highStake);
	_jsonstr.compose("tableObject", tableObject);
	_jsonstr.compose("maxNumPlayers", maxNumPlayers);
	_jsonstr.compose("playersSeated", playersSeated);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("tableId", tableId);
	_jsonstr.compose("scalePM", scalePM);
	return _buf.c_str();
}

void hglobby::lobby_client::ScheduledRingGame::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("clubName", clubName);
	_jparser.parseByNameThrow("tableId32", tableId32);
	_jparser.parseByNameThrow("tableName", tableName);
	_jparser.parseByNameThrow("gameType", gameType);
	_jparser.parseByNameThrow("isHiLo", isHiLo);
	_jparser.parseByNameThrow("buyin", buyin);
	_jparser.parseByNameThrow("numPlayers", numPlayers);
	_jparser.parseByNameThrow("isSeated", isSeated);
	_jparser.parseByNameThrow("limit", limit);
	_jparser.parseByNameThrow("currency", currency);
	_jparser.parseByNameThrow("isPlayMoney", isPlayMoney);
	_jparser.parseByNameThrow("lowStake", lowStake);
	_jparser.parseByNameThrow("highStake", highStake);
	_jparser.parseByNameThrow("tableObject", tableObject);
	_jparser.parseByNameThrow("maxNumPlayers", maxNumPlayers);
	_jparser.parseByNameThrow("playersSeated", playersSeated);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("tableId", tableId);
	_jparser.parseByNameThrow("scalePM", scalePM);
}

/* static */ void hglobby::lobby_client::ScheduledRingGame::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	PString clubName; _jparser.validateByNameThrow("clubName", clubName);
	AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	PString tableName; _jparser.validateByNameThrow("tableName", tableName);
	AtfValidator::validateInt(_descr, "tableName", tableName.length(), _checker, __FILE__, __LINE__);
	BYTE gameType; _jparser.validateByNameThrow("gameType", gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _jparser.validateByNameThrow("isHiLo", isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 buyin; _jparser.validateByNameThrow("buyin", buyin);
	AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _jparser.validateByNameThrow("numPlayers", numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	bool isSeated; _jparser.validateByNameThrow("isSeated", isSeated);
	AtfValidator::validateInt(_descr, "isSeated", isSeated, _checker, __FILE__, __LINE__);
	BYTE limit; _jparser.validateByNameThrow("limit", limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	PString currency; _jparser.validateByNameThrow("currency", currency);
	AtfValidator::validateInt(_descr, "currency", currency.length(), _checker, __FILE__, __LINE__);
	bool isPlayMoney; _jparser.validateByNameThrow("isPlayMoney", isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 lowStake; _jparser.validateByNameThrow("lowStake", lowStake);
	AtfValidator::validateInt(_descr, "lowStake", lowStake, _checker, __FILE__, __LINE__);
	UINT32 highStake; _jparser.validateByNameThrow("highStake", highStake);
	AtfValidator::validateInt(_descr, "highStake", highStake, _checker, __FILE__, __LINE__);
	PString tableObject; _jparser.validateByNameThrow("tableObject", tableObject);
	AtfValidator::validateInt(_descr, "tableObject", tableObject.length(), _checker, __FILE__, __LINE__);
	UINT32 maxNumPlayers; _jparser.validateByNameThrow("maxNumPlayers", maxNumPlayers);
	AtfValidator::validateInt(_descr, "maxNumPlayers", maxNumPlayers, _checker, __FILE__, __LINE__);
	UINT32 playersSeated; _jparser.validateByNameThrow("playersSeated", playersSeated);
	AtfValidator::validateInt(_descr, "playersSeated", playersSeated, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	INT32 scalePM; _jparser.validateByNameThrow("scalePM", scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::ScheduledRingGame::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	const char *_dummy = "";
	UINT32 clubId; _parser0.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser0.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableName"); size_t szTableName = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableName", szTableName, _checker, __FILE__, __LINE__);
	BYTE gameType; _parser0.parseBYTE(gameType);
	AtfValidator::validateInt(_descr, "gameType", gameType, _checker, __FILE__, __LINE__);
	bool isHiLo; _parser0.parseBOOL(isHiLo);
	AtfValidator::validateInt(_descr, "isHiLo", isHiLo, _checker, __FILE__, __LINE__);
	UINT32 buyin; _parser0.parseUINT32(buyin);
	AtfValidator::validateInt(_descr, "buyin", buyin, _checker, __FILE__, __LINE__);
	UINT32 numPlayers; _parser0.parseUINT32(numPlayers);
	AtfValidator::validateInt(_descr, "numPlayers", numPlayers, _checker, __FILE__, __LINE__);
	bool isSeated; _parser0.parseBOOL(isSeated);
	AtfValidator::validateInt(_descr, "isSeated", isSeated, _checker, __FILE__, __LINE__);
	BYTE limit; _parser0.parseBYTE(limit);
	AtfValidator::validateInt(_descr, "limit", limit, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "currency"); size_t szCurrency = strlen(_dummy);
	AtfValidator::validateInt(_descr, "currency", szCurrency, _checker, __FILE__, __LINE__);
	bool isPlayMoney; _parser0.parseBOOL(isPlayMoney);
	AtfValidator::validateInt(_descr, "isPlayMoney", isPlayMoney, _checker, __FILE__, __LINE__);
	UINT32 lowStake; _parser0.parseUINT32(lowStake);
	AtfValidator::validateInt(_descr, "lowStake", lowStake, _checker, __FILE__, __LINE__);
	UINT32 highStake; _parser0.parseUINT32(highStake);
	AtfValidator::validateInt(_descr, "highStake", highStake, _checker, __FILE__, __LINE__);
	_parser0.parseStringN(_dummy, 0, "tableObject"); size_t szTableObject = strlen(_dummy);
	AtfValidator::validateInt(_descr, "tableObject", szTableObject, _checker, __FILE__, __LINE__);
	UINT32 maxNumPlayers; _parser0.parseUINT32(maxNumPlayers);
	AtfValidator::validateInt(_descr, "maxNumPlayers", maxNumPlayers, _checker, __FILE__, __LINE__);
	UINT32 playersSeated; _parser0.parseUINT32(playersSeated);
	AtfValidator::validateInt(_descr, "playersSeated", playersSeated, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser0.parseUINT32(flags);
	AtfValidator::validateInt(_descr, "flags", flags, _checker, __FILE__, __LINE__);
	UINT64 tableId; _parser0.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	INT32 scalePM; _parser0.parseINT32(scalePM);
	AtfValidator::validateInt(_descr, "scalePM", scalePM, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_GET_SCHEDULED_GAMES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::Protocol_HG_GET_SCHEDULED_GAMES_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	tourns.clear();
	ringGames.clear();
	msgBoard.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::equals(const Protocol_HG_GET_SCHEDULED_GAMES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tourns.equals(_o.tourns) &&
		ringGames.equals(_o.ringGames) &&
		Atf::atfPStringEquals(msgBoard, _o.msgBoard);
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_SCHEDULED_GAMES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_SCHEDULED_GAMES_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_SCHEDULED_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ringGames=");
		ringGames.toTraceString(_buf);
		_buf.append(',');
		_buf.append("msgBoard=");
		_buf.append(msgBoard);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_SCHEDULED_GAMES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		tourns.toXmlString("tourns", _buf);
		ringGames.toXmlString("ringGames", _buf);
		Atf::XmlElement::encodeAsXmlElement("msgBoard", msgBoard, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ScheduledTourn, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("ringGames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ScheduledRingGame, 4 > >::FromXmlString(_value, ringGames)) return false;
			}
			else if (_element.equals("msgBoard"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, msgBoard)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tourns.composeMsg(_msg, _ignoreJSON);
		ringGames.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(msgBoard);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tourns.parseMsg(_parser);
		ringGames.parseMsg(_parser);
		_parser.parseStringP(msgBoard);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tourns", tourns);
		_jsonstr.compose("ringGames", ringGames);
		_jsonstr.compose("msgBoard", msgBoard);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tourns", tourns);
		_jparser.parseByNameThrow("ringGames", ringGames);
		_jparser.parseByNameThrow("msgBoard", msgBoard);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ScheduledTourn > tourns; _jparser.validateByNameThrow("tourns", tourns);
		AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ScheduledRingGame > ringGames; _jparser.validateByNameThrow("ringGames", ringGames);
		AtfValidator::validateInt(_descr, "ringGames", ringGames.size(), _checker, __FILE__, __LINE__);
		PString msgBoard; _jparser.validateByNameThrow("msgBoard", msgBoard);
		AtfValidator::validateInt(_descr, "msgBoard", msgBoard.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTourns = Atf::LAtfVector< ScheduledTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szRingGames = Atf::LAtfVector< ScheduledRingGame, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ringGames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ringGames", szRingGames, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "msgBoard"); size_t szMsgBoard = strlen(_dummy);
		AtfValidator::validateInt(_descr, "msgBoard", szMsgBoard, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_FOUNDER_GET_CLUB_PASSWORD
//=================================================================

hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::equals(const Protocol_HG_FOUNDER_GET_CLUB_PASSWORD& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::equals(Atf::MessageProtocol* _other) const
{
	if (HG_FOUNDER_GET_CLUB_PASSWORD != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_FOUNDER_GET_CLUB_PASSWORD*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_FOUNDER_GET_CLUB_PASSWORD).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_FOUNDER_GET_CLUB_PASSWORD).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_FOUNDER_GET_CLUB_PASSWORD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_FOUNDER_GET_CLUB_PASSWORD";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	password.clear();
}

bool hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::equals(const Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(password, _o.password);
}

bool hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_FOUNDER_GET_CLUB_PASSWORD_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_FOUNDER_GET_CLUB_PASSWORD_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("password=");
		_buf.append(password);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_FOUNDER_GET_CLUB_PASSWORD_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("password", password, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("password"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, password)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(password);
	}
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(password);
	}
}

const char *hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("password", password);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("password", password);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_FOUNDER_GET_CLUB_PASSWORD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString password; _jparser.validateByNameThrow("password", password);
		AtfValidator::validateInt(_descr, "password", password.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_FOUNDER_GET_CLUB_PASSWORD_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "password"); size_t szPassword = strlen(_dummy);
		AtfValidator::validateInt(_descr, "password", szPassword, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::equals(const Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECRUIT_SOCIAL_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECRUIT_SOCIAL_TOKEN).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECRUIT_SOCIAL_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECRUIT_SOCIAL_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECRUIT_SOCIAL_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	sotialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::equals(const Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(sotialToken, _o.sotialToken);
}

bool hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("sotialToken=");
		_buf.append(sotialToken);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("sotialToken", sotialToken, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("sotialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, sotialToken)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(sotialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(sotialToken);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("sotialToken", sotialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("sotialToken", sotialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString sotialToken; _jparser.validateByNameThrow("sotialToken", sotialToken);
		AtfValidator::validateInt(_descr, "sotialToken", sotialToken.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "sotialToken"); size_t szSotialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "sotialToken", szSotialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLOSE_CLUB_BY_FOUNDER
//=================================================================

hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::Protocol_HG_CLOSE_CLUB_BY_FOUNDER()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::clear()
{
	clubId = 0;
	playerStatus = 0;
	dummy = 0;
	userId.clear();
}

bool hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::equals(const Protocol_HG_CLOSE_CLUB_BY_FOUNDER& _o) const
{
	return clubId == _o.clubId &&
		playerStatus == _o.playerStatus &&
		dummy == _o.dummy &&
		Atf::atfPStringEquals(userId, _o.userId);
}

bool hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CLOSE_CLUB_BY_FOUNDER != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CLOSE_CLUB_BY_FOUNDER*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLOSE_CLUB_BY_FOUNDER).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("playerStatus=");
	_buf.appendUint(playerStatus);
	_buf.append(',');
	_buf.append("dummy=");
	_buf.appendUint(dummy);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CLOSE_CLUB_BY_FOUNDER).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("playerStatus", playerStatus, _buf);
	Atf::XmlElement::encodeAsXmlElement("dummy", dummy, _buf);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("playerStatus"))
			{
				playerStatus = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("dummy"))
			{
				dummy = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userId"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(playerStatus);
	_msg.composeUINT32(dummy);
	_msg.composeString(userId);
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	if(_parser.parseEnded()) return;
	_parser.parseUINT32(playerStatus);
	_parser.parseUINT32(dummy);
	_parser.parseStringP(userId);
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("playerStatus", playerStatus);
	_jsonstr.compose("dummy", dummy);
	_jsonstr.compose("userId", userId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("playerStatus", playerStatus);
	_jparser.parseByNameThrow("dummy", dummy);
	_jparser.parseByNameThrow("userId", userId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLOSE_CLUB_BY_FOUNDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT32 playerStatus; _jparser.validateByNameThrow("playerStatus", playerStatus);
	AtfValidator::validateIntMax(_descr, "playerStatus", playerStatus, HgChangePlayerStatusAction_Last, _checker, __FILE__, __LINE__);
	UINT32 dummy; _jparser.validateByNameThrow("dummy", dummy);
	AtfValidator::validateInt(_descr, "dummy", dummy, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLOSE_CLUB_BY_FOUNDER";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT32 playerStatus; _parser.parseUINT32(playerStatus);
	AtfValidator::validateIntMax(_descr, "playerStatus", playerStatus, HgChangePlayerStatusAction_Last, _checker, __FILE__, __LINE__);
	UINT32 dummy; _parser.parseUINT32(dummy);
	AtfValidator::validateInt(_descr, "dummy", dummy, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::equals(const Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CLOSE_CLUB_BY_FOUNDER_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLOSE_CLUB_BY_FOUNDER_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CLOSE_CLUB_BY_FOUNDER_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDesc", errDesc);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDesc", errDesc);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLOSE_CLUB_BY_FOUNDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
	AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLOSE_CLUB_BY_FOUNDER_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_SEASON_NAME
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::Protocol_HG_CHANGE_SEASON_NAME()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::clear()
{
	clubId = 0;
	seasonId = 0;
	seasonName.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::equals(const Protocol_HG_CHANGE_SEASON_NAME& _o) const
{
	return clubId == _o.clubId &&
		seasonId == _o.seasonId &&
		Atf::atfPStringEquals(seasonName, _o.seasonName);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_SEASON_NAME != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_SEASON_NAME*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_SEASON_NAME).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("seasonName=");
	_buf.append(seasonName);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_SEASON_NAME).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonId", seasonId, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonName", seasonName, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seasonId"))
			{
				seasonId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seasonName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, seasonName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(seasonId);
	_msg.composeString(seasonName);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(seasonId);
	_parser.parseStringP(seasonName);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("seasonId", seasonId);
	_jsonstr.compose("seasonName", seasonName);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("seasonId", seasonId);
	_jparser.parseByNameThrow("seasonName", seasonName);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_SEASON_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _jparser.validateByNameThrow("seasonId", seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	PString seasonName; _jparser.validateByNameThrow("seasonName", seasonName);
	AtfValidator::validateIntMax(_descr, "seasonName", seasonName.length(), 128, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_SEASON_NAME";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 seasonId; _parser.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "seasonName"); size_t szSeasonName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "seasonName", szSeasonName, 128, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CHANGE_SEASON_NAME_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::Protocol_HG_CHANGE_SEASON_NAME_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::equals(const Protocol_HG_CHANGE_SEASON_NAME_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CHANGE_SEASON_NAME_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CHANGE_SEASON_NAME_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CHANGE_SEASON_NAME_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	_buf.append(',');
	_buf.append("errDesc=");
	_buf.append(errDesc);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CHANGE_SEASON_NAME_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	_msg.composeString(errDesc);
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	_parser.parseStringP(errDesc);
}

const char *hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	_jsonstr.compose("errDesc", errDesc);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	_jparser.parseByNameThrow("errDesc", errDesc);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_SEASON_NAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode; _jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
	AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CHANGE_SEASON_NAME_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode; _parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
	AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_PROCESS_SEASON_CLOSED
//=================================================================

hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::Protocol_HG_PROCESS_SEASON_CLOSED()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::clear()
{
	seasonId = 0;
	timeFrom.setNull();
	timeTo.setNull();
	closed = false;
	seasonType = 0;
	seasonName.clear();
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::equals(const Protocol_HG_PROCESS_SEASON_CLOSED& _o) const
{
	return seasonId == _o.seasonId &&
		timeFrom.equals(_o.timeFrom) &&
		timeTo.equals(_o.timeTo) &&
		closed == _o.closed &&
		seasonType == _o.seasonType &&
		Atf::atfPStringEquals(seasonName, _o.seasonName) &&
		clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::equals(Atf::MessageProtocol* _other) const
{
	if (HG_PROCESS_SEASON_CLOSED != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_PROCESS_SEASON_CLOSED*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_PROCESS_SEASON_CLOSED).append(")");
	_buf.append(',');
	_buf.append("seasonId=");
	_buf.appendUint(seasonId);
	_buf.append(',');
	_buf.append("timeFrom=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, timeFrom);
	_buf.append(',');
	_buf.append("timeTo=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, timeTo);
	_buf.append(',');
	_buf.append("closed=");
	_buf.appendUint(closed);
	_buf.append(',');
	_buf.append("seasonType=");
	_buf.appendUint(seasonType);
	_buf.append(',');
	_buf.append("seasonName=");
	_buf.append(seasonName);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_PROCESS_SEASON_CLOSED).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("seasonId", seasonId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "timeFrom", timeFrom);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "timeTo", timeTo);
	Atf::XmlElement::encodeAsXmlElement("closed", closed, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonType", seasonType, _buf);
	Atf::XmlElement::encodeAsXmlElement("seasonName", seasonName, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("seasonId"))
			{
				seasonId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("timeFrom"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, timeFrom);
			}
			else if (_element.equals("timeTo"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, timeTo);
			}
			else if (_element.equals("closed"))
			{
				closed = (*_value.ptr() == '1');
			}
			else if (_element.equals("seasonType"))
			{
				seasonType = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("seasonName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, seasonName)) return false;
			}
			else if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(seasonId);
	_msg.composeSrvTime(timeFrom);
	_msg.composeSrvTime(timeTo);
	_msg.composeBOOL(closed);
	_msg.composeUINT32(seasonType);
	_msg.composeString(seasonName);
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(seasonId);
	_parser.parseSrvTime(timeFrom);
	_parser.parseSrvTime(timeTo);
	_parser.parseBOOL(closed);
	_parser.parseUINT32(seasonType);
	_parser.parseStringP(seasonName);
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("seasonId", seasonId);
	_jsonstr.compose("timeFrom", timeFrom);
	_jsonstr.compose("timeTo", timeTo);
	_jsonstr.compose("closed", closed);
	_jsonstr.compose("seasonType", seasonType);
	_jsonstr.compose("seasonName", seasonName);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("seasonId", seasonId);
	_jparser.parseByNameThrow("timeFrom", timeFrom);
	_jparser.parseByNameThrow("timeTo", timeTo);
	_jparser.parseByNameThrow("closed", closed);
	_jparser.parseByNameThrow("seasonType", seasonType);
	_jparser.parseByNameThrow("seasonName", seasonName);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_PROCESS_SEASON_CLOSED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 seasonId; _jparser.validateByNameThrow("seasonId", seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _jparser.validateByNameThrow("timeFrom", timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeTo; _jparser.validateByNameThrow("timeTo", timeTo);
	AtfValidator::validateSrvDateTime(_descr, "timeTo", timeTo, _checker, __FILE__, __LINE__);
	bool closed; _jparser.validateByNameThrow("closed", closed);
	AtfValidator::validateInt(_descr, "closed", closed, _checker, __FILE__, __LINE__);
	UINT32 seasonType; _jparser.validateByNameThrow("seasonType", seasonType);
	AtfValidator::validateIntRange(_descr, "seasonType", seasonType, eHgClubSeasonsYearly, eHgClubSeasonsMonthly, _checker, __FILE__, __LINE__);
	PString seasonName; _jparser.validateByNameThrow("seasonName", seasonName);
	AtfValidator::validateIntMax(_descr, "seasonName", seasonName.length(), 128, _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_PROCESS_SEASON_CLOSED";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	UINT32 seasonId; _parser.parseUINT32(seasonId);
	AtfValidator::validateInt(_descr, "seasonId", seasonId, _checker, __FILE__, __LINE__);
	SrvTime timeFrom; _parser.parseSrvTime(timeFrom);
	AtfValidator::validateSrvDateTime(_descr, "timeFrom", timeFrom, _checker, __FILE__, __LINE__);
	SrvTime timeTo; _parser.parseSrvTime(timeTo);
	AtfValidator::validateSrvDateTime(_descr, "timeTo", timeTo, _checker, __FILE__, __LINE__);
	bool closed; _parser.parseBOOL(closed);
	AtfValidator::validateInt(_descr, "closed", closed, _checker, __FILE__, __LINE__);
	UINT32 seasonType; _parser.parseUINT32(seasonType);
	AtfValidator::validateIntRange(_descr, "seasonType", seasonType, eHgClubSeasonsYearly, eHgClubSeasonsMonthly, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "seasonName"); size_t szSeasonName = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "seasonName", szSeasonName, 128, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_PROCESS_SEASON_CLOSED_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::equals(const Protocol_HG_PROCESS_SEASON_CLOSED_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_PROCESS_SEASON_CLOSED_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_PROCESS_SEASON_CLOSED_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_PROCESS_SEASON_CLOSED_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_PROCESS_SEASON_CLOSED_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_PROCESS_SEASON_CLOSED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_PROCESS_SEASON_CLOSED_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_MODIFY_MEMBERSHIP_FLAGS
//=================================================================

hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::clear()
{
	clubId = 0;
	flags = 0;
}

bool hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::equals(const Protocol_HG_MODIFY_MEMBERSHIP_FLAGS& _o) const
{
	return clubId == _o.clubId &&
		flags == _o.flags;
}

bool hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_MODIFY_MEMBERSHIP_FLAGS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_MODIFY_MEMBERSHIP_FLAGS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_MODIFY_MEMBERSHIP_FLAGS).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_MODIFY_MEMBERSHIP_FLAGS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(flags);
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(flags);
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("flags", flags);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_MODIFY_MEMBERSHIP_FLAGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateIntRange(_descr, "flags", flags, eHgTournFormatRegular, eHgTournFormatRebuy2RnoA, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_MODIFY_MEMBERSHIP_FLAGS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntRange(_descr, "flags", flags, eHgTournFormatRegular, eHgTournFormatRebuy2RnoA, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::equals(const Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_MODIFY_MEMBERSHIP_FLAGS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_MODIFY_MEMBERSHIP_FLAGS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_MODIFY_MEMBERSHIP_FLAGS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_MODIFY_MEMBERSHIP_FLAGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_MODIFY_MEMBERSHIP_FLAGS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_FAVORITE_CLUB
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::Protocol_HG_SET_FAVORITE_CLUB()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::clear()
{
	clubId = 0;
	isFavoriteClub = false;
}

bool hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::equals(const Protocol_HG_SET_FAVORITE_CLUB& _o) const
{
	return clubId == _o.clubId &&
		isFavoriteClub == _o.isFavoriteClub;
}

bool hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::equals(Atf::MessageProtocol* _other) const
{
	if (HG_SET_FAVORITE_CLUB != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_SET_FAVORITE_CLUB*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_FAVORITE_CLUB).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("isFavoriteClub=");
	_buf.appendUint(isFavoriteClub);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_SET_FAVORITE_CLUB).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("isFavoriteClub", isFavoriteClub, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("isFavoriteClub"))
			{
				isFavoriteClub = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeBOOL(isFavoriteClub);
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseBOOL(isFavoriteClub);
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("isFavoriteClub", isFavoriteClub);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("isFavoriteClub", isFavoriteClub);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_FAVORITE_CLUB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	bool isFavoriteClub; _jparser.validateByNameThrow("isFavoriteClub", isFavoriteClub);
	AtfValidator::validateInt(_descr, "isFavoriteClub", isFavoriteClub, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_FAVORITE_CLUB";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	bool isFavoriteClub; _parser.parseBOOL(isFavoriteClub);
	AtfValidator::validateInt(_descr, "isFavoriteClub", isFavoriteClub, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_FAVORITE_CLUB_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::Protocol_HG_SET_FAVORITE_CLUB_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::equals(const Protocol_HG_SET_FAVORITE_CLUB_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_SET_FAVORITE_CLUB_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_SET_FAVORITE_CLUB_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_FAVORITE_CLUB_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_SET_FAVORITE_CLUB_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_FAVORITE_CLUB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_FAVORITE_CLUB_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TABLE_SOCIAL_TOKEN
//=================================================================

hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::Protocol_HG_TABLE_SOCIAL_TOKEN()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::clear()
{
	clubId = 0;
	tableId32 = 0;
	tableId = 0;
}

bool hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::equals(const Protocol_HG_TABLE_SOCIAL_TOKEN& _o) const
{
	return clubId == _o.clubId &&
		tableId32 == _o.tableId32 &&
		tableId == _o.tableId;
}

bool hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (HG_TABLE_SOCIAL_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_TABLE_SOCIAL_TOKEN*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TABLE_SOCIAL_TOKEN).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tableId32=");
	_buf.appendUint(tableId32);
	_buf.append(',');
	_buf.append("tableId=");
	_buf.appendUint64(tableId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_TABLE_SOCIAL_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId32", tableId32, _buf);
	Atf::XmlElement::encodeAsXmlElement("tableId", tableId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId32"))
			{
				tableId32 = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tableId"))
			{
				tableId = (UINT64)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(tableId32);
	_msg.composeUINT64(tableId);
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(tableId32);
	if(_parser.parseEnded()) return;
	_parser.parseUINT64(tableId);
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("tableId32", tableId32);
	_jsonstr.compose("tableId", tableId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("tableId32", tableId32);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("tableId", tableId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TABLE_SOCIAL_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _jparser.validateByNameThrow("tableId32", tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_jparser.parseEnded()) return;
	UINT64 tableId; _jparser.validateByNameThrow("tableId", tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TABLE_SOCIAL_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tableId32; _parser.parseUINT32(tableId32);
	AtfValidator::validateInt(_descr, "tableId32", tableId32, _checker, __FILE__, __LINE__);
	if(_parser.parseEnded()) return;
	UINT64 tableId; _parser.parseUINT64(tableId);
	AtfValidator::validateUint(_descr, "tableId", tableId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::equals(const Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken);
}

bool hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_TABLE_SOCIAL_TOKEN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TABLE_SOCIAL_TOKEN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_TABLE_SOCIAL_TOKEN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
	}
}

const char *hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("socialToken", socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("socialToken", socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TABLE_SOCIAL_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TABLE_SOCIAL_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TOURN_SOCIAL_TOKEN
//=================================================================

hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::Protocol_HG_TOURN_SOCIAL_TOKEN()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::clear()
{
	clubId = 0;
	tournId = 0;
}

bool hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::equals(const Protocol_HG_TOURN_SOCIAL_TOKEN& _o) const
{
	return clubId == _o.clubId &&
		tournId == _o.tournId;
}

bool hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::equals(Atf::MessageProtocol* _other) const
{
	if (HG_TOURN_SOCIAL_TOKEN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_TOURN_SOCIAL_TOKEN*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TOURN_SOCIAL_TOKEN).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_TOURN_SOCIAL_TOKEN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(tournId);
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(tournId);
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("tournId", tournId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("tournId", tournId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TOURN_SOCIAL_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TOURN_SOCIAL_TOKEN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
}

bool hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::equals(const Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken);
}

bool hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_TOURN_SOCIAL_TOKEN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_TOURN_SOCIAL_TOKEN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_TOURN_SOCIAL_TOKEN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
	}
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
	}
}

const char *hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("socialToken", socialToken);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("socialToken", socialToken);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TOURN_SOCIAL_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_TOURN_SOCIAL_TOKEN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    ClubMessageData
//=================================================================

hglobby::lobby_client::ClubMessageData::ClubMessageData()
{
	clear();
}

void hglobby::lobby_client::ClubMessageData::clear()
{
	type = 0;
	id = 0;
	clubId = 0;
	pinnedPos = 0;
	parentId = 0;
	userIntId = 0;
	created.setNull();
	userId.clear();
	content.clear();
	obsolete = false;
	roleFlags = 0;
	flags = 0;
}

bool hglobby::lobby_client::ClubMessageData::equals(const ClubMessageData& _o) const
{
	return type == _o.type &&
		id == _o.id &&
		clubId == _o.clubId &&
		pinnedPos == _o.pinnedPos &&
		parentId == _o.parentId &&
		userIntId == _o.userIntId &&
		created.equals(_o.created) &&
		Atf::atfPStringEquals(userId, _o.userId) &&
		Atf::atfPStringEquals(content, _o.content) &&
		obsolete == _o.obsolete &&
		roleFlags == _o.roleFlags &&
		flags == _o.flags;
}

const char *hglobby::lobby_client::ClubMessageData::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("type=");
	_buf.appendUint(type);
	_buf.append(',');
	_buf.append("id=");
	_buf.appendUint64(id);
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("pinnedPos=");
	_buf.appendUint(pinnedPos);
	_buf.append(',');
	_buf.append("parentId=");
	_buf.appendUint64(parentId);
	_buf.append(',');
	_buf.append("userIntId=");
	_buf.appendUint(userIntId);
	_buf.append(',');
	_buf.append("created=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, created);
	_buf.append(',');
	_buf.append("userId=");
	_buf.append(userId);
	_buf.append(',');
	_buf.append("content=");
	_buf.append(content);
	_buf.append(',');
	_buf.append("obsolete=");
	_buf.appendUint(obsolete);
	_buf.append(',');
	_buf.append("roleFlags=");
	_buf.appendUint(roleFlags);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::ClubMessageData::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("type", type, _buf);
	Atf::XmlElement::encodeAsXmlElement("id", id, _buf);
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("pinnedPos", pinnedPos, _buf);
	Atf::XmlElement::encodeAsXmlElement("parentId", parentId, _buf);
	Atf::XmlElement::encodeAsXmlElement("userIntId", userIntId, _buf);
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "created", created);
	Atf::XmlElement::encodeAsXmlElement("userId", userId, _buf);
	Atf::XmlElement::encodeAsXmlElement("content", content, _buf);
	Atf::XmlElement::encodeAsXmlElement("obsolete", obsolete, _buf);
	Atf::XmlElement::encodeAsXmlElement("roleFlags", roleFlags, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::ClubMessageData::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("type"))
		{
			type = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("id"))
		{
			id = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("clubId"))
		{
			clubId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("pinnedPos"))
		{
			pinnedPos = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("parentId"))
		{
			parentId = (UINT64)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("userIntId"))
		{
			userIntId = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("created"))
		{
			Atf::AtfTempl<SrvTime>::FromXmlString(_value, created);
		}
		else if (_element.equals("userId"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, userId)) return false;
		}
		else if (_element.equals("content"))
		{
			if(!Atf::XmlElement::movePBlockToPString(_value, content)) return false;
		}
		else if (_element.equals("obsolete"))
		{
			obsolete = (*_value.ptr() == '1');
		}
		else if (_element.equals("roleFlags"))
		{
			roleFlags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("flags"))
		{
			flags = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::ClubMessageData::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(type);
	_msg.composeUINT64(id);
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(pinnedPos);
	_msg.composeUINT64(parentId);
	_msg.composeUINT32(userIntId);
	_msg.composeSrvTime(created);
	_msg.composeString(userId);
	_msg.composeString(content);
	_msg.composeBOOL(obsolete);
	_msg.composeUINT32(roleFlags);
	_msg.composeUINT32(flags);
}

void hglobby::lobby_client::ClubMessageData::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(type);
	_parser.parseUINT64(id);
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(pinnedPos);
	_parser.parseUINT64(parentId);
	_parser.parseUINT32(userIntId);
	_parser.parseSrvTime(created);
	_parser.parseStringP(userId);
	_parser.parseStringP(content);
	_parser.parseBOOL(obsolete);
	_parser.parseUINT32(roleFlags);
	_parser.parseUINT32(flags);
}

const char *hglobby::lobby_client::ClubMessageData::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("type", type);
	_jsonstr.compose("id", id);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("pinnedPos", pinnedPos);
	_jsonstr.compose("parentId", parentId);
	_jsonstr.compose("userIntId", userIntId);
	_jsonstr.compose("created", created);
	_jsonstr.compose("userId", userId);
	_jsonstr.compose("content", content);
	_jsonstr.compose("obsolete", obsolete);
	_jsonstr.compose("roleFlags", roleFlags);
	_jsonstr.compose("flags", flags);
	return _buf.c_str();
}

void hglobby::lobby_client::ClubMessageData::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("type", type);
	_jparser.parseByNameThrow("id", id);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("pinnedPos", pinnedPos);
	_jparser.parseByNameThrow("parentId", parentId);
	_jparser.parseByNameThrow("userIntId", userIntId);
	_jparser.parseByNameThrow("created", created);
	_jparser.parseByNameThrow("userId", userId);
	_jparser.parseByNameThrow("content", content);
	_jparser.parseByNameThrow("obsolete", obsolete);
	_jparser.parseByNameThrow("roleFlags", roleFlags);
	_jparser.parseByNameThrow("flags", flags);
}

/* static */ void hglobby::lobby_client::ClubMessageData::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 type; _jparser.validateByNameThrow("type", type);
	AtfValidator::validateIntRange(_descr, "type", type, eHgMessageTypeWall, eHgMessageTypeLast, _checker, __FILE__, __LINE__);
	UINT64 id; _jparser.validateByNameThrow("id", id);
	AtfValidator::validateUint(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 pinnedPos; _jparser.validateByNameThrow("pinnedPos", pinnedPos);
	AtfValidator::validateInt(_descr, "pinnedPos", pinnedPos, _checker, __FILE__, __LINE__);
	UINT64 parentId; _jparser.validateByNameThrow("parentId", parentId);
	AtfValidator::validateUint(_descr, "parentId", parentId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _jparser.validateByNameThrow("userIntId", userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	SrvTime created; _jparser.validateByNameThrow("created", created);
	AtfValidator::validateSrvDateTime(_descr, "created", created, _checker, __FILE__, __LINE__);
	PString userId; _jparser.validateByNameThrow("userId", userId);
	AtfValidator::validateIntMax(_descr, "userId", userId.length(), 20, _checker, __FILE__, __LINE__);
	PString content; _jparser.validateByNameThrow("content", content);
	AtfValidator::validateIntMax(_descr, "content", content.length(), 10000, _checker, __FILE__, __LINE__);
	bool obsolete; _jparser.validateByNameThrow("obsolete", obsolete);
	AtfValidator::validateInt(_descr, "obsolete", obsolete, _checker, __FILE__, __LINE__);
	UINT32 roleFlags; _jparser.validateByNameThrow("roleFlags", roleFlags);
	AtfValidator::validateIntRange(_descr, "roleFlags", roleFlags, eHrMemberRoleMember, eHrMemberRoleSuspended, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateIntRange(_descr, "flags", flags, eHgTournFormatRegular, eHgTournFormatRebuy2RnoA, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::ClubMessageData::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	const char *_dummy = "";
	UINT32 type; _parser.parseUINT32(type);
	AtfValidator::validateIntRange(_descr, "type", type, eHgMessageTypeWall, eHgMessageTypeLast, _checker, __FILE__, __LINE__);
	UINT64 id; _parser.parseUINT64(id);
	AtfValidator::validateUint(_descr, "id", id, _checker, __FILE__, __LINE__);
	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 pinnedPos; _parser.parseUINT32(pinnedPos);
	AtfValidator::validateInt(_descr, "pinnedPos", pinnedPos, _checker, __FILE__, __LINE__);
	UINT64 parentId; _parser.parseUINT64(parentId);
	AtfValidator::validateUint(_descr, "parentId", parentId, _checker, __FILE__, __LINE__);
	UINT32 userIntId; _parser.parseUINT32(userIntId);
	AtfValidator::validateInt(_descr, "userIntId", userIntId, _checker, __FILE__, __LINE__);
	SrvTime created; _parser.parseSrvTime(created);
	AtfValidator::validateSrvDateTime(_descr, "created", created, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "userId"); size_t szUserId = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "userId", szUserId, 20, _checker, __FILE__, __LINE__);
	_parser.parseStringN(_dummy, 0, "content"); size_t szContent = strlen(_dummy);
	AtfValidator::validateIntMax(_descr, "content", szContent, 10000, _checker, __FILE__, __LINE__);
	bool obsolete; _parser.parseBOOL(obsolete);
	AtfValidator::validateInt(_descr, "obsolete", obsolete, _checker, __FILE__, __LINE__);
	UINT32 roleFlags; _parser.parseUINT32(roleFlags);
	AtfValidator::validateIntRange(_descr, "roleFlags", roleFlags, eHrMemberRoleMember, eHrMemberRoleSuspended, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntRange(_descr, "flags", flags, eHgTournFormatRegular, eHgTournFormatRebuy2RnoA, _checker, __FILE__, __LINE__);
}

//=================================================================
//                Protocol_HG_SAVE_CLUB_MESSAGE
//=================================================================

hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::Protocol_HG_SAVE_CLUB_MESSAGE()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::clear()
{
	clubMessageData.clear();
}

bool hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::equals(const Protocol_HG_SAVE_CLUB_MESSAGE& _o) const
{
	return clubMessageData.equals(_o.clubMessageData);
}

bool hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::equals(Atf::MessageProtocol* _other) const
{
	if (HG_SAVE_CLUB_MESSAGE != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_SAVE_CLUB_MESSAGE*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SAVE_CLUB_MESSAGE).append(")");
	_buf.append(',');
	_buf.append("clubMessageData=");
	clubMessageData.toTraceString(_buf);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_SAVE_CLUB_MESSAGE).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	clubMessageData.toXmlString("clubMessageData", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubMessageData"))
			{
				if(!Atf::AtfTempl< ClubMessageData >::FromXmlString(_value, clubMessageData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	clubMessageData.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::parseMsg(CommMsgParser& _parser)
{
	clubMessageData.parseMsg(_parser);
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubMessageData", clubMessageData);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubMessageData", clubMessageData);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SAVE_CLUB_MESSAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	ClubMessageData clubMessageData; _jparser.validateByNameThrow("clubMessageData", clubMessageData);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SAVE_CLUB_MESSAGE";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	ClubMessageData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubMessageData"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SAVE_CLUB_MESSAGE_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubMessageData.clear();
}

bool hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::equals(const Protocol_HG_SAVE_CLUB_MESSAGE_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		clubMessageData.equals(_o.clubMessageData);
}

bool hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_SAVE_CLUB_MESSAGE_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_SAVE_CLUB_MESSAGE_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SAVE_CLUB_MESSAGE_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubMessageData=");
		clubMessageData.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_SAVE_CLUB_MESSAGE_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		clubMessageData.toXmlString("clubMessageData", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("clubMessageData"))
			{
				if(!Atf::AtfTempl< ClubMessageData >::FromXmlString(_value, clubMessageData)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		clubMessageData.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		clubMessageData.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("clubMessageData", clubMessageData);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("clubMessageData", clubMessageData);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SAVE_CLUB_MESSAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		ClubMessageData clubMessageData; _jparser.validateByNameThrow("clubMessageData", clubMessageData);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SAVE_CLUB_MESSAGE_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		ClubMessageData::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubMessageData"), _fieldsWithUnparsedContent);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLUB_LOGIN
//=================================================================

hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::Protocol_HG_CLUB_LOGIN()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::equals(const Protocol_HG_CLUB_LOGIN& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CLUB_LOGIN != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CLUB_LOGIN*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLUB_LOGIN).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CLUB_LOGIN).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGIN";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLUB_LOGIN_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::Protocol_HG_CLUB_LOGIN_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::equals(const Protocol_HG_CLUB_LOGIN_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CLUB_LOGIN_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CLUB_LOGIN_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLUB_LOGIN_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CLUB_LOGIN_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGIN_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLUB_LOGOUT
//=================================================================

hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::Protocol_HG_CLUB_LOGOUT()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::equals(const Protocol_HG_CLUB_LOGOUT& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CLUB_LOGOUT != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CLUB_LOGOUT*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLUB_LOGOUT).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CLUB_LOGOUT).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGOUT";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CLUB_LOGOUT_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::Protocol_HG_CLUB_LOGOUT_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::equals(const Protocol_HG_CLUB_LOGOUT_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CLUB_LOGOUT_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CLUB_LOGOUT_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CLUB_LOGOUT_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CLUB_LOGOUT_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CLUB_LOGOUT_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2
//=================================================================

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::clear()
{
	clubId = 0;
	flags = 0;
	mask = 0;
	userIds.clear();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::equals(const Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2& _o) const
{
	return clubId == _o.clubId &&
		flags == _o.flags &&
		mask == _o.mask &&
		userIds.equals(_o.userIds);
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_UPDATE_MEMBERSHIP_FLAGS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	_buf.append(',');
	_buf.append("flags=");
	_buf.appendUint(flags);
	_buf.append(',');
	_buf.append("mask=");
	_buf.appendUint(mask);
	_buf.append(',');
	_buf.append("userIds=");
	userIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	Atf::XmlElement::encodeAsXmlElement("flags", flags, _buf);
	Atf::XmlElement::encodeAsXmlElement("mask", mask, _buf);
	userIds.toXmlString("userIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("flags"))
			{
				flags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("mask"))
			{
				mask = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("userIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UserId, 4 > >::FromXmlString(_value, userIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
	_msg.composeUINT32(flags);
	_msg.composeUINT32(mask);
	userIds.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
	_parser.parseUINT32(flags);
	_parser.parseUINT32(mask);
	userIds.parseMsg(_parser);
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	_jsonstr.compose("flags", flags);
	_jsonstr.compose("mask", mask);
	_jsonstr.compose("userIds", userIds);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
	_jparser.parseByNameThrow("flags", flags);
	_jparser.parseByNameThrow("mask", mask);
	_jparser.parseByNameThrow("userIds", userIds);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 flags; _jparser.validateByNameThrow("flags", flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, HgMemberFlags_Last, _checker, __FILE__, __LINE__);
	UINT32 mask; _jparser.validateByNameThrow("mask", mask);
	AtfValidator::validateIntMax(_descr, "mask", mask, (2*HgMemberFlags_Last-1), _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UserId > userIds; _jparser.validateByNameThrow("userIds", userIds);
	AtfValidator::validateIntMax(_descr, "userIds", userIds.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	UINT32 flags; _parser.parseUINT32(flags);
	AtfValidator::validateIntMax(_descr, "flags", flags, HgMemberFlags_Last, _checker, __FILE__, __LINE__);
	UINT32 mask; _parser.parseUINT32(mask);
	AtfValidator::validateIntMax(_descr, "mask", mask, (2*HgMemberFlags_Last-1), _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szUserIds = Atf::LAtfVector< UserId, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("userIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "userIds", szUserIds, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::equals(const Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                    RecurringTournament
//=================================================================

hglobby::lobby_client::RecurringTournament::RecurringTournament()
{
	clear();
}

void hglobby::lobby_client::RecurringTournament::clear()
{
	recurringPatternType = 0;
	nbOccurences = 0;
	endDate.setNull();
	numberOfDays = 0;
	everyWeekday = false;
	numberOfWeeks = 0;
	recurringDays = 0;
	dayOfMonth = 0;
	numberMonths = 0;
	whichRecurringDay = 0;
	recurringDay = 0;
	nbConsecutiveCancellation = 0;
}

bool hglobby::lobby_client::RecurringTournament::equals(const RecurringTournament& _o) const
{
	return recurringPatternType == _o.recurringPatternType &&
		nbOccurences == _o.nbOccurences &&
		endDate.equals(_o.endDate) &&
		numberOfDays == _o.numberOfDays &&
		everyWeekday == _o.everyWeekday &&
		numberOfWeeks == _o.numberOfWeeks &&
		recurringDays == _o.recurringDays &&
		dayOfMonth == _o.dayOfMonth &&
		numberMonths == _o.numberMonths &&
		whichRecurringDay == _o.whichRecurringDay &&
		recurringDay == _o.recurringDay &&
		nbConsecutiveCancellation == _o.nbConsecutiveCancellation;
}

const char *hglobby::lobby_client::RecurringTournament::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("recurringPatternType=");
	_buf.appendUint(recurringPatternType);
	_buf.append(',');
	_buf.append("nbOccurences=");
	_buf.appendUint(nbOccurences);
	_buf.append(',');
	_buf.append("endDate=");
	Atf::AtfTempl<SrvDate>::ToTraceString(_buf, endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		_buf.append(',');
		_buf.append("numberOfDays=");
		_buf.appendUint(numberOfDays);
		_buf.append(',');
		_buf.append("everyWeekday=");
		_buf.appendUint(everyWeekday);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		_buf.append(',');
		_buf.append("numberOfWeeks=");
		_buf.appendUint(numberOfWeeks);
		_buf.append(',');
		_buf.append("recurringDays=");
		_buf.appendUint(recurringDays);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		_buf.append(',');
		_buf.append("dayOfMonth=");
		_buf.appendUint(dayOfMonth);
		_buf.append(',');
		_buf.append("numberMonths=");
		_buf.appendUint(numberMonths);
		_buf.append(',');
		_buf.append("whichRecurringDay=");
		_buf.appendUint(whichRecurringDay);
		_buf.append(',');
		_buf.append("recurringDay=");
		_buf.appendUint(recurringDay);
	}
	_buf.append(',');
	_buf.append("nbConsecutiveCancellation=");
	_buf.appendUint(nbConsecutiveCancellation);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::RecurringTournament::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	Atf::XmlElement::encodeAsXmlElement("recurringPatternType", recurringPatternType, _buf);
	Atf::XmlElement::encodeAsXmlElement("nbOccurences", nbOccurences, _buf);
	Atf::AtfTempl<SrvDate>::ToXmlString(_buf, "endDate", endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		Atf::XmlElement::encodeAsXmlElement("numberOfDays", numberOfDays, _buf);
		Atf::XmlElement::encodeAsXmlElement("everyWeekday", everyWeekday, _buf);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		Atf::XmlElement::encodeAsXmlElement("numberOfWeeks", numberOfWeeks, _buf);
		Atf::XmlElement::encodeAsXmlElement("recurringDays", recurringDays, _buf);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		Atf::XmlElement::encodeAsXmlElement("dayOfMonth", dayOfMonth, _buf);
		Atf::XmlElement::encodeAsXmlElement("numberMonths", numberMonths, _buf);
		Atf::XmlElement::encodeAsXmlElement("whichRecurringDay", whichRecurringDay, _buf);
		Atf::XmlElement::encodeAsXmlElement("recurringDay", recurringDay, _buf);
	}
	Atf::XmlElement::encodeAsXmlElement("nbConsecutiveCancellation", nbConsecutiveCancellation, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::RecurringTournament::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("recurringPatternType"))
		{
			recurringPatternType = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nbOccurences"))
		{
			nbOccurences = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("endDate"))
		{
			Atf::AtfTempl<SrvDate>::FromXmlString(_value, endDate);
		}
		else if (_element.equals("numberOfDays"))
		{
			numberOfDays = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("everyWeekday"))
		{
			everyWeekday = (*_value.ptr() == '1');
		}
		else if (_element.equals("numberOfWeeks"))
		{
			numberOfWeeks = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("recurringDays"))
		{
			recurringDays = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("dayOfMonth"))
		{
			dayOfMonth = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("numberMonths"))
		{
			numberMonths = (BYTE)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("whichRecurringDay"))
		{
			whichRecurringDay = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("recurringDay"))
		{
			recurringDay = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else if (_element.equals("nbConsecutiveCancellation"))
		{
			nbConsecutiveCancellation = (UINT32)p_atoi64((const char *)_value.ptr());
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::RecurringTournament::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(RecurringTournament())) // not empty
	{
		_body.composeUINT32(recurringPatternType);
		_body.composeUINT32(nbOccurences);
		_body.composeSrvDate(endDate);
		if (recurringPatternType == eHgRecurringDaily)
		{
			CommMsgBody _body0;
			_body0.composeUINT32(numberOfDays);
			_body0.composeBOOL(everyWeekday);
			_body.composeMsgBody(_body0);
		}
		else if (recurringPatternType == eHgRecurringWeekly)
		{
			CommMsgBody _body1;
			_body1.composeUINT32(numberOfWeeks);
			_body1.composeUINT32(recurringDays);
			_body.composeMsgBody(_body1);
		}
		else if (recurringPatternType == eHgRecurringMonthly)
		{
			CommMsgBody _body2;
			_body2.composeBYTE(dayOfMonth);
			_body2.composeBYTE(numberMonths);
			_body2.composeUINT32(whichRecurringDay);
			_body2.composeUINT32(recurringDay);
			_body.composeMsgBody(_body2);
		}
		_body.composeUINT32(nbConsecutiveCancellation);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::RecurringTournament::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(recurringPatternType);
	_parser0.parseUINT32(nbOccurences);
	_parser0.parseSrvDate(endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		parseAnonymousMsgBody0(_parser0);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		parseAnonymousMsgBody1(_parser0);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		parseAnonymousMsgBody2(_parser0);
	}
	if(_parser0.parseEnded()) return;
	_parser0.parseUINT32(nbConsecutiveCancellation);
}

const char *hglobby::lobby_client::RecurringTournament::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("recurringPatternType", recurringPatternType);
	_jsonstr.compose("nbOccurences", nbOccurences);
	_jsonstr.compose("endDate", endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		_jsonstr.compose("numberOfDays", numberOfDays);
		_jsonstr.compose("everyWeekday", everyWeekday);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		_jsonstr.compose("numberOfWeeks", numberOfWeeks);
		_jsonstr.compose("recurringDays", recurringDays);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		_jsonstr.compose("dayOfMonth", dayOfMonth);
		_jsonstr.compose("numberMonths", numberMonths);
		_jsonstr.compose("whichRecurringDay", whichRecurringDay);
		_jsonstr.compose("recurringDay", recurringDay);
	}
	_jsonstr.compose("nbConsecutiveCancellation", nbConsecutiveCancellation);
	return _buf.c_str();
}

void hglobby::lobby_client::RecurringTournament::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("recurringPatternType", recurringPatternType);
	_jparser.parseByNameThrow("nbOccurences", nbOccurences);
	_jparser.parseByNameThrow("endDate", endDate);
	if (recurringPatternType == eHgRecurringDaily)
	{
		_jparser.parseByNameThrow("numberOfDays", numberOfDays);
		_jparser.parseByNameThrow("everyWeekday", everyWeekday);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		_jparser.parseByNameThrow("numberOfWeeks", numberOfWeeks);
		_jparser.parseByNameThrow("recurringDays", recurringDays);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		_jparser.parseByNameThrow("dayOfMonth", dayOfMonth);
		_jparser.parseByNameThrow("numberMonths", numberMonths);
		_jparser.parseByNameThrow("whichRecurringDay", whichRecurringDay);
		_jparser.parseByNameThrow("recurringDay", recurringDay);
	}
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("nbConsecutiveCancellation", nbConsecutiveCancellation);
}

/* static */ void hglobby::lobby_client::RecurringTournament::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 recurringPatternType = 0;
	_jparser.validateByNameThrow("recurringPatternType", recurringPatternType);
	AtfValidator::validateIntRange(_descr, "recurringPatternType", recurringPatternType, eHgNotRecurring, eHgRecurringMonthly, _checker, __FILE__, __LINE__);
	UINT32 nbOccurences; _jparser.validateByNameThrow("nbOccurences", nbOccurences);
	AtfValidator::validateIntMax(_descr, "nbOccurences", nbOccurences, 10000, _checker, __FILE__, __LINE__);
	SrvDate endDate; _jparser.validateByNameThrow("endDate", endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	if (recurringPatternType == eHgRecurringDaily)
	{
		UINT32 numberOfDays; _jparser.validateByNameThrow("numberOfDays", numberOfDays);
		AtfValidator::validateIntMax(_descr, "numberOfDays", numberOfDays, 10000, _checker, __FILE__, __LINE__);
		bool everyWeekday; _jparser.validateByNameThrow("everyWeekday", everyWeekday);
		AtfValidator::validateInt(_descr, "everyWeekday", everyWeekday, _checker, __FILE__, __LINE__);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		UINT32 numberOfWeeks; _jparser.validateByNameThrow("numberOfWeeks", numberOfWeeks);
		AtfValidator::validateIntMax(_descr, "numberOfWeeks", numberOfWeeks, 1000, _checker, __FILE__, __LINE__);
		UINT32 recurringDays; _jparser.validateByNameThrow("recurringDays", recurringDays);
		AtfValidator::validateIntRange(_descr, "recurringDays", recurringDays, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		BYTE dayOfMonth; _jparser.validateByNameThrow("dayOfMonth", dayOfMonth);
		AtfValidator::validateIntMax(_descr, "dayOfMonth", dayOfMonth, 31, _checker, __FILE__, __LINE__);
		BYTE numberMonths; _jparser.validateByNameThrow("numberMonths", numberMonths);
		AtfValidator::validateIntMax(_descr, "numberMonths", numberMonths, 100, _checker, __FILE__, __LINE__);
		UINT32 whichRecurringDay; _jparser.validateByNameThrow("whichRecurringDay", whichRecurringDay);
		AtfValidator::validateIntRange(_descr, "whichRecurringDay", whichRecurringDay, eHgWrdNone, eHgWrdLast, _checker, __FILE__, __LINE__);
		UINT32 recurringDay; _jparser.validateByNameThrow("recurringDay", recurringDay);
		AtfValidator::validateIntRange(_descr, "recurringDay", recurringDay, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	}
	if(_jparser.parseEnded()) return;
	UINT32 nbConsecutiveCancellation; _jparser.validateByNameThrow("nbConsecutiveCancellation", nbConsecutiveCancellation);
	AtfValidator::validateIntMax(_descr, "nbConsecutiveCancellation", nbConsecutiveCancellation, 10000, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::RecurringTournament::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 recurringPatternType = 0;
	_parser0.parseUINT32(recurringPatternType);
	AtfValidator::validateIntRange(_descr, "recurringPatternType", recurringPatternType, eHgNotRecurring, eHgRecurringMonthly, _checker, __FILE__, __LINE__);
	UINT32 nbOccurences; _parser0.parseUINT32(nbOccurences);
	AtfValidator::validateIntMax(_descr, "nbOccurences", nbOccurences, 10000, _checker, __FILE__, __LINE__);
	SrvDate endDate; _parser0.parseSrvDate(endDate);
	AtfValidator::validateSrvDateTime(_descr, "endDate", endDate, _checker, __FILE__, __LINE__);
	if (recurringPatternType == eHgRecurringDaily)
	{
		validateAnonymousMsgBody0(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (recurringPatternType == eHgRecurringWeekly)
	{
		validateAnonymousMsgBody1(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	}
	else if (recurringPatternType == eHgRecurringMonthly)
	{
		validateAnonymousMsgBody2(_parser0, _checker, _descr, _fieldsWithUnparsedContent);
	}
	if(_parser0.parseEnded()) return;
	UINT32 nbConsecutiveCancellation; _parser0.parseUINT32(nbConsecutiveCancellation);
	AtfValidator::validateIntMax(_descr, "nbConsecutiveCancellation", nbConsecutiveCancellation, 10000, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::RecurringTournament::parseAnonymousMsgBody0(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numberOfDays);
	_parser0.parseBOOL(everyWeekday);
}

/*static*/ void hglobby::lobby_client::RecurringTournament::validateAnonymousMsgBody0(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numberOfDays; _parser0.parseUINT32(numberOfDays);
	AtfValidator::validateIntMax(_descr, "numberOfDays", numberOfDays, 10000, _checker, __FILE__, __LINE__);
	bool everyWeekday; _parser0.parseBOOL(everyWeekday);
	AtfValidator::validateInt(_descr, "everyWeekday", everyWeekday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::RecurringTournament::parseAnonymousMsgBody1(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseUINT32(numberOfWeeks);
	_parser0.parseUINT32(recurringDays);
}

/*static*/ void hglobby::lobby_client::RecurringTournament::validateAnonymousMsgBody1(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	UINT32 numberOfWeeks; _parser0.parseUINT32(numberOfWeeks);
	AtfValidator::validateIntMax(_descr, "numberOfWeeks", numberOfWeeks, 1000, _checker, __FILE__, __LINE__);
	UINT32 recurringDays; _parser0.parseUINT32(recurringDays);
	AtfValidator::validateIntRange(_descr, "recurringDays", recurringDays, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

void hglobby::lobby_client::RecurringTournament::parseAnonymousMsgBody2(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);
	CommMsgParser _parser0(_body);
	_parser0.parseBYTE(dayOfMonth);
	_parser0.parseBYTE(numberMonths);
	_parser0.parseUINT32(whichRecurringDay);
	_parser0.parseUINT32(recurringDay);
}

/*static*/ void hglobby::lobby_client::RecurringTournament::validateAnonymousMsgBody2(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	BYTE dayOfMonth; _parser0.parseBYTE(dayOfMonth);
	AtfValidator::validateIntMax(_descr, "dayOfMonth", dayOfMonth, 31, _checker, __FILE__, __LINE__);
	BYTE numberMonths; _parser0.parseBYTE(numberMonths);
	AtfValidator::validateIntMax(_descr, "numberMonths", numberMonths, 100, _checker, __FILE__, __LINE__);
	UINT32 whichRecurringDay; _parser0.parseUINT32(whichRecurringDay);
	AtfValidator::validateIntRange(_descr, "whichRecurringDay", whichRecurringDay, eHgWrdNone, eHgWrdLast, _checker, __FILE__, __LINE__);
	UINT32 recurringDay; _parser0.parseUINT32(recurringDay);
	AtfValidator::validateIntRange(_descr, "recurringDay", recurringDay, eHgRdNone, eHgRdEveryday, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                    CreateTournParams2
//=================================================================

hglobby::lobby_client::CreateTournParams2::CreateTournParams2()
{
	clear();
}

void hglobby::lobby_client::CreateTournParams2::clear()
{
	createTournParams.clear();
	voiceEnabled = false;
}

bool hglobby::lobby_client::CreateTournParams2::equals(const CreateTournParams2& _o) const
{
	return createTournParams.equals(_o.createTournParams) &&
		voiceEnabled == _o.voiceEnabled;
}

const char *hglobby::lobby_client::CreateTournParams2::toTraceString(PString& _buf) const
{
	_buf.append('{');
	_buf.append("createTournParams=");
	createTournParams.toTraceString(_buf);
	_buf.append(',');
	_buf.append("voiceEnabled=");
	_buf.appendUint(voiceEnabled);
	_buf.append('}');
	return _buf.c_str();
}

const char *hglobby::lobby_client::CreateTournParams2::toXmlString(const char *_element, PString& _buf) const
{
	_buf.append('<').append(_element).append('>');
	createTournParams.toXmlString("createTournParams", _buf);
	Atf::XmlElement::encodeAsXmlElement("voiceEnabled", voiceEnabled, _buf);
	Atf::XmlElement::appendElementCloseTag(_element, _buf);
	return _buf.c_str();
}

bool hglobby::lobby_client::CreateTournParams2::fromXmlString(const PString& _str)
{
	PString _element;
	PBlock _value;
	PString _type;
	const char* _xml = _str.c_str();
	
	while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
	{
		if (_element.equals("createTournParams"))
		{
			if(!Atf::AtfTempl< CreateTournParams >::FromXmlString(_value, createTournParams)) return false;
		}
		else if (_element.equals("voiceEnabled"))
		{
			voiceEnabled = (*_value.ptr() == '1');
		}
		else
		{
			return false;  // unknown instance variable name
		}
	}
	return true;
}

void hglobby::lobby_client::CreateTournParams2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	CommMsgBody _body;
	//if (!equals(CreateTournParams2())) // not empty
	{
		createTournParams.composeMsg(_body, _ignoreJSON);
		_body.composeBOOL(voiceEnabled);
	}

	_msg.composeMsgBody(_body);
}

void hglobby::lobby_client::CreateTournParams2::parseMsg(CommMsgParser& _parser)
{
	CommMsgBody _body;
	_parser.parseMsgBody(_body);

	CommMsgParser _parser0(_body);
	createTournParams.parseMsg(_parser0);
	_parser0.parseBOOL(voiceEnabled);
}

const char *hglobby::lobby_client::CreateTournParams2::toJSONString(PString& _buf) const
{
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("createTournParams", createTournParams);
	_jsonstr.compose("voiceEnabled", voiceEnabled);
	return _buf.c_str();
}

void hglobby::lobby_client::CreateTournParams2::fromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("createTournParams", createTournParams);
	_jparser.parseByNameThrow("voiceEnabled", voiceEnabled);
}

/* static */ void hglobby::lobby_client::CreateTournParams2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CreateTournParams createTournParams; _jparser.validateByNameThrow("createTournParams", createTournParams);
	bool voiceEnabled; _jparser.validateByNameThrow("voiceEnabled", voiceEnabled);
	AtfValidator::validateInt(_descr, "voiceEnabled", voiceEnabled, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::CreateTournParams2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, const char* _descr, PString& _fieldsWithUnparsedContent)
{
	AtfMsgBodyParserView _parser0(_parser);
	_parser.skipMsgBody();
	PString _descbuf;
	CreateTournParams::validateMsg(_parser0, _checker, _descbuf.assign(_descr).append('.').append("createTournParams"), _fieldsWithUnparsedContent);
	bool voiceEnabled; _parser0.parseBOOL(voiceEnabled);
	AtfValidator::validateInt(_descr, "voiceEnabled", voiceEnabled, _checker, __FILE__, __LINE__);
	AtfValidator::validateEmbeddedMsgbodyParser(_descr, _parser0, _parser._shift(), __FILE__, __LINE__);
	if(!_parser0.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser0);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN2
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::Protocol_HG_CREATE_CLUB_TOURN2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::clear()
{
	createTournParams2.clear();
	recurringTournament.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::equals(const Protocol_HG_CREATE_CLUB_TOURN2& _o) const
{
	return createTournParams2.equals(_o.createTournParams2) &&
		recurringTournament.equals(_o.recurringTournament);
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB_TOURN2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB_TOURN2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN2).append(")");
	_buf.append(',');
	_buf.append("createTournParams2=");
	createTournParams2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("recurringTournament=");
	recurringTournament.toTraceString(_buf);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB_TOURN2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	createTournParams2.toXmlString("createTournParams2", _buf);
	recurringTournament.toXmlString("recurringTournament", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("createTournParams2"))
			{
				if(!Atf::AtfTempl< CreateTournParams2 >::FromXmlString(_value, createTournParams2)) return false;
			}
			else if (_element.equals("recurringTournament"))
			{
				if(!Atf::AtfTempl< RecurringTournament >::FromXmlString(_value, recurringTournament)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	createTournParams2.composeMsg(_msg, _ignoreJSON);
	recurringTournament.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::parseMsg(CommMsgParser& _parser)
{
	createTournParams2.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	recurringTournament.parseMsg(_parser);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("createTournParams2", createTournParams2);
	_jsonstr.compose("recurringTournament", recurringTournament);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("createTournParams2", createTournParams2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("recurringTournament", recurringTournament);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CreateTournParams2 createTournParams2; _jparser.validateByNameThrow("createTournParams2", createTournParams2);
	if(_jparser.parseEnded()) return;
	RecurringTournament recurringTournament; _jparser.validateByNameThrow("recurringTournament", recurringTournament);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CreateTournParams2::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("createTournParams2"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	RecurringTournament::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("recurringTournament"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::Protocol_HG_CREATE_CLUB_TOURN_REPLY2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
	tournId = 0;
	restartWarning.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::equals(const Protocol_HG_CREATE_CLUB_TOURN_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(restartWarning, _o.restartWarning);
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB_TOURN_REPLY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB_TOURN_REPLY2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB_TOURN_REPLY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("restartWarning", restartWarning, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("restartWarning"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, restartWarning)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
		_msg.composeUINT32(tournId);
		_msg.composeString(restartWarning);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(restartWarning);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("socialToken", socialToken);
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("restartWarning", restartWarning);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("socialToken", socialToken);
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("restartWarning", restartWarning);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString restartWarning; _jparser.validateByNameThrow("restartWarning", restartWarning);
		AtfValidator::validateInt(_descr, "restartWarning", restartWarning.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::clear()
{
	isNewBehavior = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::equals(const Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES& _o) const
{
	return isNewBehavior == _o.isNewBehavior;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUBS_AND_SCHEDULED_GAMES != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES).append(")");
	_buf.append(',');
	_buf.append("isNewBehavior=");
	_buf.appendUint(isNewBehavior);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("isNewBehavior", isNewBehavior, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("isNewBehavior"))
			{
				isNewBehavior = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(isNewBehavior);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isNewBehavior);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("isNewBehavior", isNewBehavior);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isNewBehavior", isNewBehavior);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	bool isNewBehavior; _jparser.validateByNameThrow("isNewBehavior", isNewBehavior);
	AtfValidator::validateInt(_descr, "isNewBehavior", isNewBehavior, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool isNewBehavior; _parser.parseBOOL(isNewBehavior);
	AtfValidator::validateInt(_descr, "isNewBehavior", isNewBehavior, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
	clubInfoListForClient.clear();
	tourns.clear();
	ringGames.clear();
	msgBoard.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::equals(const Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		clubInfoListForClient.equals(_o.clubInfoListForClient) &&
		tourns.equals(_o.tourns) &&
		ringGames.equals(_o.ringGames) &&
		Atf::atfPStringEquals(msgBoard, _o.msgBoard);
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubInfoListForClient=");
		clubInfoListForClient.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ringGames=");
		ringGames.toTraceString(_buf);
		_buf.append(',');
		_buf.append("msgBoard=");
		_buf.append(msgBoard);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		clubInfoListForClient.toXmlString("clubInfoListForClient", _buf);
		tourns.toXmlString("tourns", _buf);
		ringGames.toXmlString("ringGames", _buf);
		Atf::XmlElement::encodeAsXmlElement("msgBoard", msgBoard, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("clubInfoListForClient"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< HgClubInfo, 4 > >::FromXmlString(_value, clubInfoListForClient)) return false;
			}
			else if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ScheduledTourn, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("ringGames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ScheduledRingGame, 4 > >::FromXmlString(_value, ringGames)) return false;
			}
			else if (_element.equals("msgBoard"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, msgBoard)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		clubInfoListForClient.composeMsg(_msg, _ignoreJSON);
		tourns.composeMsg(_msg, _ignoreJSON);
		ringGames.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(msgBoard);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		clubInfoListForClient.parseMsg(_parser);
		tourns.parseMsg(_parser);
		ringGames.parseMsg(_parser);
		_parser.parseStringP(msgBoard);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("clubInfoListForClient", clubInfoListForClient);
		_jsonstr.compose("tourns", tourns);
		_jsonstr.compose("ringGames", ringGames);
		_jsonstr.compose("msgBoard", msgBoard);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("clubInfoListForClient", clubInfoListForClient);
		_jparser.parseByNameThrow("tourns", tourns);
		_jparser.parseByNameThrow("ringGames", ringGames);
		_jparser.parseByNameThrow("msgBoard", msgBoard);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< HgClubInfo > clubInfoListForClient; _jparser.validateByNameThrow("clubInfoListForClient", clubInfoListForClient);
		AtfValidator::validateInt(_descr, "clubInfoListForClient", clubInfoListForClient.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ScheduledTourn > tourns; _jparser.validateByNameThrow("tourns", tourns);
		AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ScheduledRingGame > ringGames; _jparser.validateByNameThrow("ringGames", ringGames);
		AtfValidator::validateInt(_descr, "ringGames", ringGames.size(), _checker, __FILE__, __LINE__);
		PString msgBoard; _jparser.validateByNameThrow("msgBoard", msgBoard);
		AtfValidator::validateInt(_descr, "msgBoard", msgBoard.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szClubInfoListForClient = Atf::LAtfVector< HgClubInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubInfoListForClient"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "clubInfoListForClient", szClubInfoListForClient, _checker, __FILE__, __LINE__);
		int szTourns = Atf::LAtfVector< ScheduledTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szRingGames = Atf::LAtfVector< ScheduledRingGame, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ringGames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ringGames", szRingGames, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "msgBoard"); size_t szMsgBoard = strlen(_dummy);
		AtfValidator::validateInt(_descr, "msgBoard", szMsgBoard, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_ARCHIVE_PENDING
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::Protocol_HG_SET_ARCHIVE_PENDING()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::clear()
{
	archiveDate.setNull();
	clubIds.clear();
}

bool hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::equals(const Protocol_HG_SET_ARCHIVE_PENDING& _o) const
{
	return archiveDate.equals(_o.archiveDate) &&
		clubIds.equals(_o.clubIds);
}

bool hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::equals(Atf::MessageProtocol* _other) const
{
	if (HG_SET_ARCHIVE_PENDING != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_SET_ARCHIVE_PENDING*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_ARCHIVE_PENDING).append(")");
	_buf.append(',');
	_buf.append("archiveDate=");
	Atf::AtfTempl<SrvTime>::ToTraceString(_buf, archiveDate);
	_buf.append(',');
	_buf.append("clubIds=");
	clubIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_SET_ARCHIVE_PENDING).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::AtfTempl<SrvTime>::ToXmlString(_buf, "archiveDate", archiveDate);
	clubIds.toXmlString("clubIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("archiveDate"))
			{
				Atf::AtfTempl<SrvTime>::FromXmlString(_value, archiveDate);
			}
			else if (_element.equals("clubIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, clubIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeSrvTime(archiveDate);
	clubIds.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::parseMsg(CommMsgParser& _parser)
{
	_parser.parseSrvTime(archiveDate);
	clubIds.parseMsg(_parser);
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("archiveDate", archiveDate);
	_jsonstr.compose("clubIds", clubIds);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("archiveDate", archiveDate);
	_jparser.parseByNameThrow("clubIds", clubIds);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_ARCHIVE_PENDING";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	SrvTime archiveDate; _jparser.validateByNameThrow("archiveDate", archiveDate);
	AtfValidator::validateSrvDateTime(_descr, "archiveDate", archiveDate, _checker, __FILE__, __LINE__);
	Atf::AtfVectorBase< UINT32 > clubIds; _jparser.validateByNameThrow("clubIds", clubIds);
	AtfValidator::validateIntMax(_descr, "clubIds", clubIds.size(), 10240, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_ARCHIVE_PENDING";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	SrvTime archiveDate; _parser.parseSrvTime(archiveDate);
	AtfValidator::validateSrvDateTime(_descr, "archiveDate", archiveDate, _checker, __FILE__, __LINE__);
	PString _descbuf;
	int szClubIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateIntMax(_descr, "clubIds", szClubIds, 10240, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_SET_ARCHIVE_PENDING_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::Protocol_HG_SET_ARCHIVE_PENDING_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::equals(const Protocol_HG_SET_ARCHIVE_PENDING_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_SET_ARCHIVE_PENDING_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_SET_ARCHIVE_PENDING_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_SET_ARCHIVE_PENDING_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_SET_ARCHIVE_PENDING_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_ARCHIVE_PENDING_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_SET_ARCHIVE_PENDING_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_ARCHIVE_CLUBS
//=================================================================

hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::Protocol_HG_ARCHIVE_CLUBS()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::clear()
{
	clubIds.clear();
}

bool hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::equals(const Protocol_HG_ARCHIVE_CLUBS& _o) const
{
	return clubIds.equals(_o.clubIds);
}

bool hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::equals(Atf::MessageProtocol* _other) const
{
	if (HG_ARCHIVE_CLUBS != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_ARCHIVE_CLUBS*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_ARCHIVE_CLUBS).append(")");
	_buf.append(',');
	_buf.append("clubIds=");
	clubIds.toTraceString(_buf);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_ARCHIVE_CLUBS).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	clubIds.toXmlString("clubIds", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubIds"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, clubIds)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	clubIds.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::parseMsg(CommMsgParser& _parser)
{
	clubIds.parseMsg(_parser);
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubIds", clubIds);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubIds", clubIds);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ARCHIVE_CLUBS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	Atf::AtfVectorBase< UINT32 > clubIds; _jparser.validateByNameThrow("clubIds", clubIds);
	AtfValidator::validateInt(_descr, "clubIds", clubIds.size(), _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ARCHIVE_CLUBS";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	int szClubIds = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubIds"), _fieldsWithUnparsedContent);
	AtfValidator::validateInt(_descr, "clubIds", szClubIds, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_ARCHIVE_CLUBS_REPLY
//=================================================================

hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::Protocol_HG_ARCHIVE_CLUBS_REPLY()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::clear()
{
	errCode = 0;
	errDesc.clear();
}

bool hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::equals(const Protocol_HG_ARCHIVE_CLUBS_REPLY& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc);
}

bool hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::equals(Atf::MessageProtocol* _other) const
{
	if (HG_ARCHIVE_CLUBS_REPLY != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_ARCHIVE_CLUBS_REPLY*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_ARCHIVE_CLUBS_REPLY).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_ARCHIVE_CLUBS_REPLY).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
}

const char *hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ARCHIVE_CLUBS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_ARCHIVE_CLUBS_REPLY";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_STRUCTURES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::equals(const Protocol_HG_GET_CLUB_TABLE_STRUCTURES2& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TABLE_STRUCTURES2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TABLE_STRUCTURES2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_STRUCTURES2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TABLE_STRUCTURES2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	tableParams.clear();
	isVoceEnabled = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::equals(const Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tableParams.equals(_o.tableParams) &&
		isVoceEnabled == _o.isVoceEnabled;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TABLE_STRUCTURES_REPLY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TABLE_STRUCTURES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tableParams=");
		tableParams.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isVoceEnabled=");
		_buf.appendUint(isVoceEnabled);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TABLE_STRUCTURES_REPLY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		tableParams.toXmlString("tableParams", _buf);
		Atf::XmlElement::encodeAsXmlElement("isVoceEnabled", isVoceEnabled, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tableParams"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TableParams, 4 > >::FromXmlString(_value, tableParams)) return false;
			}
			else if (_element.equals("isVoceEnabled"))
			{
				isVoceEnabled = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tableParams.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(isVoceEnabled);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tableParams.parseMsg(_parser);
		_parser.parseBOOL(isVoceEnabled);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tableParams", tableParams);
		_jsonstr.compose("isVoceEnabled", isVoceEnabled);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tableParams", tableParams);
		_jparser.parseByNameThrow("isVoceEnabled", isVoceEnabled);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< TableParams > tableParams; _jparser.validateByNameThrow("tableParams", tableParams);
		AtfValidator::validateInt(_descr, "tableParams", tableParams.size(), _checker, __FILE__, __LINE__);
		bool isVoceEnabled; _jparser.validateByNameThrow("isVoceEnabled", isVoceEnabled);
		AtfValidator::validateInt(_descr, "isVoceEnabled", isVoceEnabled, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TABLE_STRUCTURES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTableParams = Atf::LAtfVector< TableParams, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tableParams"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tableParams", szTableParams, _checker, __FILE__, __LINE__);
		bool isVoceEnabled; _parser.parseBOOL(isVoceEnabled);
		AtfValidator::validateInt(_descr, "isVoceEnabled", isVoceEnabled, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::clear()
{
	isNewBehavior = false;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::equals(const Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2& _o) const
{
	return isNewBehavior == _o.isNewBehavior;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUBS_AND_SCHEDULED_GAMES2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES2).append(")");
	_buf.append(',');
	_buf.append("isNewBehavior=");
	_buf.appendUint(isNewBehavior);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("isNewBehavior", isNewBehavior, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("isNewBehavior"))
			{
				isNewBehavior = (*_value.ptr() == '1');
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeBOOL(isNewBehavior);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::parseMsg(CommMsgParser& _parser)
{
	if(_parser.parseEnded()) return;
	_parser.parseBOOL(isNewBehavior);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("isNewBehavior", isNewBehavior);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("isNewBehavior", isNewBehavior);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	if(_jparser.parseEnded()) return;
	bool isNewBehavior; _jparser.validateByNameThrow("isNewBehavior", isNewBehavior);
	AtfValidator::validateInt(_descr, "isNewBehavior", isNewBehavior, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(_parser.parseEnded()) return;
	bool isNewBehavior; _parser.parseBOOL(isNewBehavior);
	AtfValidator::validateInt(_descr, "isNewBehavior", isNewBehavior, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	clubInfoListForClient.clear();
	tourns.clear();
	ringGames.clear();
	msgBoard.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::equals(const Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		clubInfoListForClient.equals(_o.clubInfoListForClient) &&
		tourns.equals(_o.tourns) &&
		ringGames.equals(_o.ringGames) &&
		Atf::atfPStringEquals(msgBoard, _o.msgBoard);
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubInfoListForClient=");
		clubInfoListForClient.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ringGames=");
		ringGames.toTraceString(_buf);
		_buf.append(',');
		_buf.append("msgBoard=");
		_buf.append(msgBoard);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		clubInfoListForClient.toXmlString("clubInfoListForClient", _buf);
		tourns.toXmlString("tourns", _buf);
		ringGames.toXmlString("ringGames", _buf);
		Atf::XmlElement::encodeAsXmlElement("msgBoard", msgBoard, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("clubInfoListForClient"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< HgClubInfo, 4 > >::FromXmlString(_value, clubInfoListForClient)) return false;
			}
			else if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ScheduledTourn, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("ringGames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ScheduledRingGame, 4 > >::FromXmlString(_value, ringGames)) return false;
			}
			else if (_element.equals("msgBoard"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, msgBoard)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		clubInfoListForClient.composeMsg(_msg, _ignoreJSON);
		tourns.composeMsg(_msg, _ignoreJSON);
		ringGames.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(msgBoard);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		clubInfoListForClient.parseMsg(_parser);
		tourns.parseMsg(_parser);
		ringGames.parseMsg(_parser);
		_parser.parseStringP(msgBoard);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("clubInfoListForClient", clubInfoListForClient);
		_jsonstr.compose("tourns", tourns);
		_jsonstr.compose("ringGames", ringGames);
		_jsonstr.compose("msgBoard", msgBoard);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("clubInfoListForClient", clubInfoListForClient);
		_jparser.parseByNameThrow("tourns", tourns);
		_jparser.parseByNameThrow("ringGames", ringGames);
		_jparser.parseByNameThrow("msgBoard", msgBoard);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< HgClubInfo > clubInfoListForClient; _jparser.validateByNameThrow("clubInfoListForClient", clubInfoListForClient);
		AtfValidator::validateInt(_descr, "clubInfoListForClient", clubInfoListForClient.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ScheduledTourn > tourns; _jparser.validateByNameThrow("tourns", tourns);
		AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ScheduledRingGame > ringGames; _jparser.validateByNameThrow("ringGames", ringGames);
		AtfValidator::validateInt(_descr, "ringGames", ringGames.size(), _checker, __FILE__, __LINE__);
		PString msgBoard; _jparser.validateByNameThrow("msgBoard", msgBoard);
		AtfValidator::validateInt(_descr, "msgBoard", msgBoard.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szClubInfoListForClient = Atf::LAtfVector< HgClubInfo, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("clubInfoListForClient"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "clubInfoListForClient", szClubInfoListForClient, _checker, __FILE__, __LINE__);
		int szTourns = Atf::LAtfVector< ScheduledTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szRingGames = Atf::LAtfVector< ScheduledRingGame, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ringGames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ringGames", szRingGames, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "msgBoard"); size_t szMsgBoard = strlen(_dummy);
		AtfValidator::validateInt(_descr, "msgBoard", szMsgBoard, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_SCHEDULED_GAMES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::Protocol_HG_GET_SCHEDULED_GAMES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::clear()
{
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::equals(const Protocol_HG_GET_SCHEDULED_GAMES2& _o) const
{
	return true;
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_SCHEDULED_GAMES2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_SCHEDULED_GAMES2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_SCHEDULED_GAMES2).append(")");
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_SCHEDULED_GAMES2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::parseMsg(CommMsgParser& _parser)
{
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_SCHEDULED_GAMES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	tourns.clear();
	ringGames.clear();
	msgBoard.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::equals(const Protocol_HG_GET_SCHEDULED_GAMES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tourns.equals(_o.tourns) &&
		ringGames.equals(_o.ringGames) &&
		Atf::atfPStringEquals(msgBoard, _o.msgBoard);
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_SCHEDULED_GAMES_REPLY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_SCHEDULED_GAMES_REPLY2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_SCHEDULED_GAMES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tourns=");
		tourns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("ringGames=");
		ringGames.toTraceString(_buf);
		_buf.append(',');
		_buf.append("msgBoard=");
		_buf.append(msgBoard);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_SCHEDULED_GAMES_REPLY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		tourns.toXmlString("tourns", _buf);
		ringGames.toXmlString("ringGames", _buf);
		Atf::XmlElement::encodeAsXmlElement("msgBoard", msgBoard, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tourns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ScheduledTourn, 4 > >::FromXmlString(_value, tourns)) return false;
			}
			else if (_element.equals("ringGames"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ScheduledRingGame, 4 > >::FromXmlString(_value, ringGames)) return false;
			}
			else if (_element.equals("msgBoard"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, msgBoard)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tourns.composeMsg(_msg, _ignoreJSON);
		ringGames.composeMsg(_msg, _ignoreJSON);
		_msg.composeString(msgBoard);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tourns.parseMsg(_parser);
		ringGames.parseMsg(_parser);
		_parser.parseStringP(msgBoard);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tourns", tourns);
		_jsonstr.compose("ringGames", ringGames);
		_jsonstr.compose("msgBoard", msgBoard);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tourns", tourns);
		_jparser.parseByNameThrow("ringGames", ringGames);
		_jparser.parseByNameThrow("msgBoard", msgBoard);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ScheduledTourn > tourns; _jparser.validateByNameThrow("tourns", tourns);
		AtfValidator::validateInt(_descr, "tourns", tourns.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< ScheduledRingGame > ringGames; _jparser.validateByNameThrow("ringGames", ringGames);
		AtfValidator::validateInt(_descr, "ringGames", ringGames.size(), _checker, __FILE__, __LINE__);
		PString msgBoard; _jparser.validateByNameThrow("msgBoard", msgBoard);
		AtfValidator::validateInt(_descr, "msgBoard", msgBoard.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_SCHEDULED_GAMES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTourns = Atf::LAtfVector< ScheduledTourn, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tourns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tourns", szTourns, _checker, __FILE__, __LINE__);
		int szRingGames = Atf::LAtfVector< ScheduledRingGame, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("ringGames"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "ringGames", szRingGames, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "msgBoard"); size_t szMsgBoard = strlen(_dummy);
		AtfValidator::validateInt(_descr, "msgBoard", szMsgBoard, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_STRUCTURES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::equals(const Protocol_HG_GET_CLUB_TOURN_STRUCTURES2& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TOURN_STRUCTURES2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TOURN_STRUCTURES2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_STRUCTURES2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TOURN_STRUCTURES2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	tournKnockoutPrize = 0;
	tournMaxPlayers = 0;
	tournFastDealing.clear();
	tournSyncBreaks.clear();
	tournPayouts.clear();
	tournStartingChips.clear();
	tournLevelLengths.clear();
	tournFormats.clear();
	gameStructures.clear();
	tournBuyInsPM.clear();
	currencyBuyIns.clear();
	isVoiceEnabled = false;
	numMaxDaysForTournCreation = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::equals(const Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournKnockoutPrize == _o.tournKnockoutPrize &&
		tournMaxPlayers == _o.tournMaxPlayers &&
		tournFastDealing.equals(_o.tournFastDealing) &&
		tournSyncBreaks.equals(_o.tournSyncBreaks) &&
		tournPayouts.equals(_o.tournPayouts) &&
		tournStartingChips.equals(_o.tournStartingChips) &&
		tournLevelLengths.equals(_o.tournLevelLengths) &&
		tournFormats.equals(_o.tournFormats) &&
		gameStructures.equals(_o.gameStructures) &&
		tournBuyInsPM.equals(_o.tournBuyInsPM) &&
		currencyBuyIns.equals(_o.currencyBuyIns) &&
		isVoiceEnabled == _o.isVoiceEnabled &&
		numMaxDaysForTournCreation == _o.numMaxDaysForTournCreation;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_TOURN_STRUCTURES_REPLY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_TOURN_STRUCTURES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournKnockoutPrize=");
		_buf.appendUint(tournKnockoutPrize);
		_buf.append(',');
		_buf.append("tournMaxPlayers=");
		_buf.appendUint(tournMaxPlayers);
		_buf.append(',');
		_buf.append("tournFastDealing=");
		tournFastDealing.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournSyncBreaks=");
		tournSyncBreaks.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournPayouts=");
		tournPayouts.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournStartingChips=");
		tournStartingChips.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournLevelLengths=");
		tournLevelLengths.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournFormats=");
		tournFormats.toTraceString(_buf);
		_buf.append(',');
		_buf.append("gameStructures=");
		gameStructures.toTraceString(_buf);
		_buf.append(',');
		_buf.append("tournBuyInsPM=");
		tournBuyInsPM.toTraceString(_buf);
		_buf.append(',');
		_buf.append("currencyBuyIns=");
		currencyBuyIns.toTraceString(_buf);
		_buf.append(',');
		_buf.append("isVoiceEnabled=");
		_buf.appendUint(isVoiceEnabled);
		_buf.append(',');
		_buf.append("numMaxDaysForTournCreation=");
		_buf.appendUint(numMaxDaysForTournCreation);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_TOURN_STRUCTURES_REPLY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("tournKnockoutPrize", tournKnockoutPrize, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournMaxPlayers", tournMaxPlayers, _buf);
		tournFastDealing.toXmlString("tournFastDealing", _buf);
		tournSyncBreaks.toXmlString("tournSyncBreaks", _buf);
		tournPayouts.toXmlString("tournPayouts", _buf);
		tournStartingChips.toXmlString("tournStartingChips", _buf);
		tournLevelLengths.toXmlString("tournLevelLengths", _buf);
		tournFormats.toXmlString("tournFormats", _buf);
		gameStructures.toXmlString("gameStructures", _buf);
		tournBuyInsPM.toXmlString("tournBuyInsPM", _buf);
		currencyBuyIns.toXmlString("currencyBuyIns", _buf);
		Atf::XmlElement::encodeAsXmlElement("isVoiceEnabled", isVoiceEnabled, _buf);
		Atf::XmlElement::encodeAsXmlElement("numMaxDaysForTournCreation", numMaxDaysForTournCreation, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournKnockoutPrize"))
			{
				tournKnockoutPrize = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournMaxPlayers"))
			{
				tournMaxPlayers = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("tournFastDealing"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< bool, 4 > >::FromXmlString(_value, tournFastDealing)) return false;
			}
			else if (_element.equals("tournSyncBreaks"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< bool, 4 > >::FromXmlString(_value, tournSyncBreaks)) return false;
			}
			else if (_element.equals("tournPayouts"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournPayouts)) return false;
			}
			else if (_element.equals("tournStartingChips"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournStartingChips)) return false;
			}
			else if (_element.equals("tournLevelLengths"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournLevelLengths)) return false;
			}
			else if (_element.equals("tournFormats"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< UINT32, 4 > >::FromXmlString(_value, tournFormats)) return false;
			}
			else if (_element.equals("gameStructures"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< GameStructure, 4 > >::FromXmlString(_value, gameStructures)) return false;
			}
			else if (_element.equals("tournBuyInsPM"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournBuyIn2, 4 > >::FromXmlString(_value, tournBuyInsPM)) return false;
			}
			else if (_element.equals("currencyBuyIns"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< TournCurrencyBuyIns2, 4 > >::FromXmlString(_value, currencyBuyIns)) return false;
			}
			else if (_element.equals("isVoiceEnabled"))
			{
				isVoiceEnabled = (*_value.ptr() == '1');
			}
			else if (_element.equals("numMaxDaysForTournCreation"))
			{
				numMaxDaysForTournCreation = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeUINT32(tournKnockoutPrize);
		_msg.composeUINT32(tournMaxPlayers);
		tournFastDealing.composeMsg(_msg, _ignoreJSON);
		tournSyncBreaks.composeMsg(_msg, _ignoreJSON);
		tournPayouts.composeMsg(_msg, _ignoreJSON);
		tournStartingChips.composeMsg(_msg, _ignoreJSON);
		tournLevelLengths.composeMsg(_msg, _ignoreJSON);
		tournFormats.composeMsg(_msg, _ignoreJSON);
		gameStructures.composeMsg(_msg, _ignoreJSON);
		tournBuyInsPM.composeMsg(_msg, _ignoreJSON);
		currencyBuyIns.composeMsg(_msg, _ignoreJSON);
		_msg.composeBOOL(isVoiceEnabled);
		_msg.composeUINT32(numMaxDaysForTournCreation);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseUINT32(tournKnockoutPrize);
		_parser.parseUINT32(tournMaxPlayers);
		tournFastDealing.parseMsg(_parser);
		tournSyncBreaks.parseMsg(_parser);
		tournPayouts.parseMsg(_parser);
		tournStartingChips.parseMsg(_parser);
		tournLevelLengths.parseMsg(_parser);
		tournFormats.parseMsg(_parser);
		gameStructures.parseMsg(_parser);
		tournBuyInsPM.parseMsg(_parser);
		currencyBuyIns.parseMsg(_parser);
		_parser.parseBOOL(isVoiceEnabled);
		_parser.parseUINT32(numMaxDaysForTournCreation);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournKnockoutPrize", tournKnockoutPrize);
		_jsonstr.compose("tournMaxPlayers", tournMaxPlayers);
		_jsonstr.compose("tournFastDealing", tournFastDealing);
		_jsonstr.compose("tournSyncBreaks", tournSyncBreaks);
		_jsonstr.compose("tournPayouts", tournPayouts);
		_jsonstr.compose("tournStartingChips", tournStartingChips);
		_jsonstr.compose("tournLevelLengths", tournLevelLengths);
		_jsonstr.compose("tournFormats", tournFormats);
		_jsonstr.compose("gameStructures", gameStructures);
		_jsonstr.compose("tournBuyInsPM", tournBuyInsPM);
		_jsonstr.compose("currencyBuyIns", currencyBuyIns);
		_jsonstr.compose("isVoiceEnabled", isVoiceEnabled);
		_jsonstr.compose("numMaxDaysForTournCreation", numMaxDaysForTournCreation);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournKnockoutPrize", tournKnockoutPrize);
		_jparser.parseByNameThrow("tournMaxPlayers", tournMaxPlayers);
		_jparser.parseByNameThrow("tournFastDealing", tournFastDealing);
		_jparser.parseByNameThrow("tournSyncBreaks", tournSyncBreaks);
		_jparser.parseByNameThrow("tournPayouts", tournPayouts);
		_jparser.parseByNameThrow("tournStartingChips", tournStartingChips);
		_jparser.parseByNameThrow("tournLevelLengths", tournLevelLengths);
		_jparser.parseByNameThrow("tournFormats", tournFormats);
		_jparser.parseByNameThrow("gameStructures", gameStructures);
		_jparser.parseByNameThrow("tournBuyInsPM", tournBuyInsPM);
		_jparser.parseByNameThrow("currencyBuyIns", currencyBuyIns);
		_jparser.parseByNameThrow("isVoiceEnabled", isVoiceEnabled);
		_jparser.parseByNameThrow("numMaxDaysForTournCreation", numMaxDaysForTournCreation);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournKnockoutPrize; _jparser.validateByNameThrow("tournKnockoutPrize", tournKnockoutPrize);
		AtfValidator::validateInt(_descr, "tournKnockoutPrize", tournKnockoutPrize, _checker, __FILE__, __LINE__);
		UINT32 tournMaxPlayers; _jparser.validateByNameThrow("tournMaxPlayers", tournMaxPlayers);
		AtfValidator::validateInt(_descr, "tournMaxPlayers", tournMaxPlayers, _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< bool > tournFastDealing; _jparser.validateByNameThrow("tournFastDealing", tournFastDealing);
		AtfValidator::validateInt(_descr, "tournFastDealing", tournFastDealing.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< bool > tournSyncBreaks; _jparser.validateByNameThrow("tournSyncBreaks", tournSyncBreaks);
		AtfValidator::validateInt(_descr, "tournSyncBreaks", tournSyncBreaks.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tournPayouts; _jparser.validateByNameThrow("tournPayouts", tournPayouts);
		AtfValidator::validateInt(_descr, "tournPayouts", tournPayouts.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tournStartingChips; _jparser.validateByNameThrow("tournStartingChips", tournStartingChips);
		AtfValidator::validateInt(_descr, "tournStartingChips", tournStartingChips.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tournLevelLengths; _jparser.validateByNameThrow("tournLevelLengths", tournLevelLengths);
		AtfValidator::validateInt(_descr, "tournLevelLengths", tournLevelLengths.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< UINT32 > tournFormats; _jparser.validateByNameThrow("tournFormats", tournFormats);
		AtfValidator::validateInt(_descr, "tournFormats", tournFormats.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< GameStructure > gameStructures; _jparser.validateByNameThrow("gameStructures", gameStructures);
		AtfValidator::validateInt(_descr, "gameStructures", gameStructures.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< TournBuyIn2 > tournBuyInsPM; _jparser.validateByNameThrow("tournBuyInsPM", tournBuyInsPM);
		AtfValidator::validateInt(_descr, "tournBuyInsPM", tournBuyInsPM.size(), _checker, __FILE__, __LINE__);
		Atf::AtfVectorBase< TournCurrencyBuyIns2 > currencyBuyIns; _jparser.validateByNameThrow("currencyBuyIns", currencyBuyIns);
		AtfValidator::validateInt(_descr, "currencyBuyIns", currencyBuyIns.size(), _checker, __FILE__, __LINE__);
		bool isVoiceEnabled; _jparser.validateByNameThrow("isVoiceEnabled", isVoiceEnabled);
		AtfValidator::validateInt(_descr, "isVoiceEnabled", isVoiceEnabled, _checker, __FILE__, __LINE__);
		UINT32 numMaxDaysForTournCreation; _jparser.validateByNameThrow("numMaxDaysForTournCreation", numMaxDaysForTournCreation);
		AtfValidator::validateInt(_descr, "numMaxDaysForTournCreation", numMaxDaysForTournCreation, _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_TOURN_STRUCTURES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		UINT32 tournKnockoutPrize; _parser.parseUINT32(tournKnockoutPrize);
		AtfValidator::validateInt(_descr, "tournKnockoutPrize", tournKnockoutPrize, _checker, __FILE__, __LINE__);
		UINT32 tournMaxPlayers; _parser.parseUINT32(tournMaxPlayers);
		AtfValidator::validateInt(_descr, "tournMaxPlayers", tournMaxPlayers, _checker, __FILE__, __LINE__);
		PString _descbuf;
		int szTournFastDealing = Atf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournFastDealing"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournFastDealing", szTournFastDealing, _checker, __FILE__, __LINE__);
		int szTournSyncBreaks = Atf::LAtfVector< bool, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournSyncBreaks"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournSyncBreaks", szTournSyncBreaks, _checker, __FILE__, __LINE__);
		int szTournPayouts = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournPayouts"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournPayouts", szTournPayouts, _checker, __FILE__, __LINE__);
		int szTournStartingChips = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournStartingChips"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournStartingChips", szTournStartingChips, _checker, __FILE__, __LINE__);
		int szTournLevelLengths = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournLevelLengths"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournLevelLengths", szTournLevelLengths, _checker, __FILE__, __LINE__);
		int szTournFormats = Atf::LAtfVector< UINT32, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournFormats"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournFormats", szTournFormats, _checker, __FILE__, __LINE__);
		int szGameStructures = Atf::LAtfVector< GameStructure, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("gameStructures"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "gameStructures", szGameStructures, _checker, __FILE__, __LINE__);
		int szTournBuyInsPM = Atf::LAtfVector< TournBuyIn2, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournBuyInsPM"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournBuyInsPM", szTournBuyInsPM, _checker, __FILE__, __LINE__);
		int szCurrencyBuyIns = Atf::LAtfVector< TournCurrencyBuyIns2, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("currencyBuyIns"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "currencyBuyIns", szCurrencyBuyIns, _checker, __FILE__, __LINE__);
		bool isVoiceEnabled; _parser.parseBOOL(isVoiceEnabled);
		AtfValidator::validateInt(_descr, "isVoiceEnabled", isVoiceEnabled, _checker, __FILE__, __LINE__);
		UINT32 numMaxDaysForTournCreation; _parser.parseUINT32(numMaxDaysForTournCreation);
		AtfValidator::validateInt(_descr, "numMaxDaysForTournCreation", numMaxDaysForTournCreation, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN3
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::Protocol_HG_CREATE_CLUB_TOURN3()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::clear()
{
	createTournParams2.clear();
	recurringTournament.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::equals(const Protocol_HG_CREATE_CLUB_TOURN3& _o) const
{
	return createTournParams2.equals(_o.createTournParams2) &&
		recurringTournament.equals(_o.recurringTournament);
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB_TOURN3 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB_TOURN3*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN3).append(")");
	_buf.append(',');
	_buf.append("createTournParams2=");
	createTournParams2.toTraceString(_buf);
	_buf.append(',');
	_buf.append("recurringTournament=");
	recurringTournament.toTraceString(_buf);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB_TOURN3).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	createTournParams2.toXmlString("createTournParams2", _buf);
	recurringTournament.toXmlString("recurringTournament", _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("createTournParams2"))
			{
				if(!Atf::AtfTempl< CreateTournParams2 >::FromXmlString(_value, createTournParams2)) return false;
			}
			else if (_element.equals("recurringTournament"))
			{
				if(!Atf::AtfTempl< RecurringTournament >::FromXmlString(_value, recurringTournament)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	createTournParams2.composeMsg(_msg, _ignoreJSON);
	recurringTournament.composeMsg(_msg, _ignoreJSON);
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::parseMsg(CommMsgParser& _parser)
{
	createTournParams2.parseMsg(_parser);
	if(_parser.parseEnded()) return;
	recurringTournament.parseMsg(_parser);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("createTournParams2", createTournParams2);
	_jsonstr.compose("recurringTournament", recurringTournament);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("createTournParams2", createTournParams2);
	if(_jparser.parseEnded()) return;
	_jparser.parseByNameThrow("recurringTournament", recurringTournament);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	CreateTournParams2 createTournParams2; _jparser.validateByNameThrow("createTournParams2", createTournParams2);
	if(_jparser.parseEnded()) return;
	RecurringTournament recurringTournament; _jparser.validateByNameThrow("recurringTournament", recurringTournament);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	PString _descbuf;
	CreateTournParams2::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("createTournParams2"), _fieldsWithUnparsedContent);
	if(_parser.parseEnded()) return;
	RecurringTournament::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("recurringTournament"), _fieldsWithUnparsedContent);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_CREATE_CLUB_TOURN_REPLY3
//=================================================================

hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::Protocol_HG_CREATE_CLUB_TOURN_REPLY3()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::clear()
{
	errCode = 0;
	errDesc.clear();
	socialToken.clear();
	tournId = 0;
	restartWarning.clear();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::equals(const Protocol_HG_CREATE_CLUB_TOURN_REPLY3& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(socialToken, _o.socialToken) &&
		tournId == _o.tournId &&
		Atf::atfPStringEquals(restartWarning, _o.restartWarning);
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::equals(Atf::MessageProtocol* _other) const
{
	if (HG_CREATE_CLUB_TOURN_REPLY3 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_CREATE_CLUB_TOURN_REPLY3*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_CREATE_CLUB_TOURN_REPLY3).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("socialToken=");
		_buf.append(socialToken);
		_buf.append(',');
		_buf.append("tournId=");
		_buf.appendUint(tournId);
		_buf.append(',');
		_buf.append("restartWarning=");
		_buf.append(restartWarning);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_CREATE_CLUB_TOURN_REPLY3).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("socialToken", socialToken, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
		Atf::XmlElement::encodeAsXmlElement("restartWarning", restartWarning, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("socialToken"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, socialToken)) return false;
			}
			else if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("restartWarning"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, restartWarning)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(socialToken);
		_msg.composeUINT32(tournId);
		_msg.composeString(restartWarning);
	}
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(socialToken);
		_parser.parseUINT32(tournId);
		_parser.parseStringP(restartWarning);
	}
}

const char *hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("socialToken", socialToken);
		_jsonstr.compose("tournId", tournId);
		_jsonstr.compose("restartWarning", restartWarning);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("socialToken", socialToken);
		_jparser.parseByNameThrow("tournId", tournId);
		_jparser.parseByNameThrow("restartWarning", restartWarning);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN_REPLY3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString socialToken; _jparser.validateByNameThrow("socialToken", socialToken);
		AtfValidator::validateInt(_descr, "socialToken", socialToken.length(), _checker, __FILE__, __LINE__);
		UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		PString restartWarning; _jparser.validateByNameThrow("restartWarning", restartWarning);
		AtfValidator::validateInt(_descr, "restartWarning", restartWarning.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_CREATE_CLUB_TOURN_REPLY3";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "socialToken"); size_t szSocialToken = strlen(_dummy);
		AtfValidator::validateInt(_descr, "socialToken", szSocialToken, _checker, __FILE__, __LINE__);
		UINT32 tournId; _parser.parseUINT32(tournId);
		AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "restartWarning"); size_t szRestartWarning = strlen(_dummy);
		AtfValidator::validateInt(_descr, "restartWarning", szRestartWarning, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_SUMMARIES2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::equals(const Protocol_HG_GET_RECENT_TOURN_SUMMARIES2& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECENT_TOURN_SUMMARIES2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECENT_TOURN_SUMMARIES2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_SUMMARIES2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECENT_TOURN_SUMMARIES2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	summaries.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::equals(const Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		summaries.equals(_o.summaries);
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECENT_TOURN_SUMMARIES_REPLY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_SUMMARIES_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("summaries=");
		summaries.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECENT_TOURN_SUMMARIES_REPLY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		summaries.toXmlString("summaries", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("summaries"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClubRecentTournamentSummary, 4 > >::FromXmlString(_value, summaries)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		summaries.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		summaries.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("summaries", summaries);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("summaries", summaries);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ClubRecentTournamentSummary > summaries; _jparser.validateByNameThrow("summaries", summaries);
		AtfValidator::validateInt(_descr, "summaries", summaries.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_SUMMARIES_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szSummaries = Atf::LAtfVector< ClubRecentTournamentSummary, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("summaries"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "summaries", szSummaries, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_RESULTS2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::Protocol_HG_GET_RECENT_TOURN_RESULTS2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::clear()
{
	tournId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::equals(const Protocol_HG_GET_RECENT_TOURN_RESULTS2& _o) const
{
	return tournId == _o.tournId;
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECENT_TOURN_RESULTS2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECENT_TOURN_RESULTS2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_RESULTS2).append(")");
	_buf.append(',');
	_buf.append("tournId=");
	_buf.appendUint(tournId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECENT_TOURN_RESULTS2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("tournId", tournId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("tournId"))
			{
				tournId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(tournId);
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(tournId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("tournId", tournId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("tournId", tournId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 tournId; _jparser.validateByNameThrow("tournId", tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 tournId; _parser.parseUINT32(tournId);
	AtfValidator::validateInt(_descr, "tournId", tournId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	tournResults.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::equals(const Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		tournResults.equals(_o.tournResults);
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_RECENT_TOURN_RESULTS_REPLY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_RECENT_TOURN_RESULTS_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("tournResults=");
		tournResults.toTraceString(_buf);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_RECENT_TOURN_RESULTS_REPLY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		tournResults.toXmlString("tournResults", _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("tournResults"))
			{
				if(!Atf::AtfTempl< Atf::LAtfVector< ClubRecentTournPlayerResult, 4 > >::FromXmlString(_value, tournResults)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		tournResults.composeMsg(_msg, _ignoreJSON);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		tournResults.parseMsg(_parser);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("tournResults", tournResults);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("tournResults", tournResults);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		Atf::AtfVectorBase< ClubRecentTournPlayerResult > tournResults; _jparser.validateByNameThrow("tournResults", tournResults);
		AtfValidator::validateInt(_descr, "tournResults", tournResults.size(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_RECENT_TOURN_RESULTS_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		PString _descbuf;
		int szTournResults = Atf::LAtfVector< ClubRecentTournPlayerResult, 4 >::validateMsg(_parser, _checker, _descbuf.assign(_descr).append('.').append("tournResults"), _fieldsWithUnparsedContent);
		AtfValidator::validateInt(_descr, "tournResults", szTournResults, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_INFO2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::Protocol_HG_GET_CLUB_INFO2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::clear()
{
	clubId = 0;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::equals(const Protocol_HG_GET_CLUB_INFO2& _o) const
{
	return clubId == _o.clubId;
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_INFO2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_INFO2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_INFO2).append(")");
	_buf.append(',');
	_buf.append("clubId=");
	_buf.appendUint(clubId);
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_INFO2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("clubId", clubId, _buf);
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("clubId"))
			{
				clubId = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeUINT32(clubId);
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseUINT32(clubId);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("clubId", clubId);
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("clubId", clubId);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	UINT32 clubId; _jparser.validateByNameThrow("clubId", clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	UINT32 clubId; _parser.parseUINT32(clubId);
	AtfValidator::validateInt(_descr, "clubId", clubId, _checker, __FILE__, __LINE__);
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                Protocol_HG_GET_CLUB_INFO_REPLY2
//=================================================================

hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::Protocol_HG_GET_CLUB_INFO_REPLY2()
{
	clear();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::clear()
{
	errCode = 0;
	errDesc.clear();
	clubName.clear();
	tablePubName.clear();
	tournPubName.clear();
	memberRole = 0;
	memberFlags = 0;
	wallPubName.clear();
	announcePubName.clear();
	membershipPubName.clear();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::equals(const Protocol_HG_GET_CLUB_INFO_REPLY2& _o) const
{
	return errCode == _o.errCode &&
		Atf::atfPStringEquals(errDesc, _o.errDesc) &&
		Atf::atfPStringEquals(clubName, _o.clubName) &&
		Atf::atfPStringEquals(tablePubName, _o.tablePubName) &&
		Atf::atfPStringEquals(tournPubName, _o.tournPubName) &&
		memberRole == _o.memberRole &&
		memberFlags == _o.memberFlags &&
		Atf::atfPStringEquals(wallPubName, _o.wallPubName) &&
		Atf::atfPStringEquals(announcePubName, _o.announcePubName) &&
		Atf::atfPStringEquals(membershipPubName, _o.membershipPubName);
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::equals(Atf::MessageProtocol* _other) const
{
	if (HG_GET_CLUB_INFO_REPLY2 != _other->getMsgId() || strcmp(getMsgIdString(), _other->getMsgIdString()))
	{
		return false;
	}
   
 	return equals(*((Protocol_HG_GET_CLUB_INFO_REPLY2*)_other));
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::asTraceString(PString& _buf) const
{
	_buf.cut(0);
	_buf.append("msgid=").append(getMsgIdString()).append("(").appendUint(HG_GET_CLUB_INFO_REPLY2).append(")");
	_buf.append(',');
	_buf.append("errCode=");
	_buf.appendInt(errCode);
	if ( errCode )
	{
		_buf.append(',');
		_buf.append("errDesc=");
		_buf.append(errDesc);
	}
	else
	{
		_buf.append(',');
		_buf.append("clubName=");
		_buf.append(clubName);
		_buf.append(',');
		_buf.append("tablePubName=");
		_buf.append(tablePubName);
		_buf.append(',');
		_buf.append("tournPubName=");
		_buf.append(tournPubName);
		_buf.append(',');
		_buf.append("memberRole=");
		_buf.appendUint(memberRole);
		_buf.append(',');
		_buf.append("memberFlags=");
		_buf.appendUint(memberFlags);
		_buf.append(',');
		_buf.append("wallPubName=");
		_buf.append(wallPubName);
		_buf.append(',');
		_buf.append("announcePubName=");
		_buf.append(announcePubName);
		_buf.append(',');
		_buf.append("membershipPubName=");
		_buf.append(membershipPubName);
	}
	return _buf.c_str();
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::asXmlString(PString& _buf, bool _logTimeStamp) const
{
	UINT64 _timeTicks64 = 0;
	UINT32 _msgTime = 0;
		
	if(_logTimeStamp)
	{
		INT32 _msec;
		UINT32 _sec = LONGSYSTEMTICKS(&_msec);
		_timeTicks64 = (UINT64)_sec * 1000 + _msec;
		_msgTime = (UINT32)plib_time(0);
	}
		
	return asXmlString(_buf, _timeTicks64, _msgTime);
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::asXmlString(PString& _buf, UINT64 _timestampTicks, UINT32 _msgTime) const
{	
	_buf.cut(0);
	_buf.append("<message>");
	_buf.append("<msgid name='").append(getMsgIdString()).append("'>").appendUint(HG_GET_CLUB_INFO_REPLY2).append("</msgid>");
	if(_timestampTicks)
		_buf.append("<ticks>").appendUint64(_timestampTicks).append("</ticks>");
	if(_msgTime)	
		_buf.append("<mtime>").appendUint(_msgTime).append("</mtime>");
	_buf.append("<struct>");
	Atf::XmlElement::encodeAsXmlElement("errCode", errCode, _buf);
	if ( errCode )
	{
		Atf::XmlElement::encodeAsXmlElement("errDesc", errDesc, _buf);
	}
	else
	{
		Atf::XmlElement::encodeAsXmlElement("clubName", clubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("tablePubName", tablePubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("tournPubName", tournPubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("memberRole", memberRole, _buf);
		Atf::XmlElement::encodeAsXmlElement("memberFlags", memberFlags, _buf);
		Atf::XmlElement::encodeAsXmlElement("wallPubName", wallPubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("announcePubName", announcePubName, _buf);
		Atf::XmlElement::encodeAsXmlElement("membershipPubName", membershipPubName, _buf);
	}
	_buf.append("</struct>");
	_buf.append("</message>");
	return _buf.c_str();
}

bool hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::loadFromXmlString(const PString& _xmlString)
{
	const char *_xml = _xmlString.c_str();
	PString _str;
   
	if (Atf::XmlElement::getElementValueAsString("/message/struct", _xml, _str))
	{
		_xml = _str.c_str();

		PString _element;
		PBlock _value;
		PString _type;     
		
        while (Atf::XmlElement::decodeNextXmlElement(_xml, _str.length(), _element, _value, _type))
        {
			if (_element.equals("errCode"))
			{
				errCode = (INT16)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("errDesc"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, errDesc)) return false;
			}
			else if (_element.equals("clubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, clubName)) return false;
			}
			else if (_element.equals("tablePubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tablePubName)) return false;
			}
			else if (_element.equals("tournPubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, tournPubName)) return false;
			}
			else if (_element.equals("memberRole"))
			{
				memberRole = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("memberFlags"))
			{
				memberFlags = (UINT32)p_atoi64((const char *)_value.ptr());
			}
			else if (_element.equals("wallPubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, wallPubName)) return false;
			}
			else if (_element.equals("announcePubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, announcePubName)) return false;
			}
			else if (_element.equals("membershipPubName"))
			{
				if(!Atf::XmlElement::movePBlockToPString(_value, membershipPubName)) return false;
			}
			else
			{
				return false;  // unknown instance variable name
			}
		}

		Atf::XmlElement::skipSpaces(_xml);
		return (*_xml == 0);  // reach the end of string, nothing unknown!
	}
	else 
	{
		CommMsgBody _body;
		if (Atf::XmlElement::getLeafElementAsMsgBody("/message/body", _xml, _body))
		{
			parseMessage(_body);
			return true;
		}
		else
		{
			return false;
		}
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::composeMsg(CommMsgBody& _msg, bool _ignoreJSON) const
{
	_msg.composeINT16(errCode);
	if ( errCode )
	{
		_msg.composeString(errDesc);
	}
	else
	{
		_msg.composeString(clubName);
		_msg.composeString(tablePubName);
		_msg.composeString(tournPubName);
		_msg.composeUINT32(memberRole);
		_msg.composeUINT32(memberFlags);
		_msg.composeString(wallPubName);
		_msg.composeString(announcePubName);
		_msg.composeString(membershipPubName);
	}
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::parseMsg(CommMsgParser& _parser)
{
	_parser.parseINT16(errCode);
	if ( errCode )
	{
		_parser.parseStringP(errDesc);
	}
	else
	{
		_parser.parseStringP(clubName);
		_parser.parseStringP(tablePubName);
		_parser.parseStringP(tournPubName);
		_parser.parseUINT32(memberRole);
		_parser.parseUINT32(memberFlags);
		_parser.parseStringP(wallPubName);
		_parser.parseStringP(announcePubName);
		_parser.parseStringP(membershipPubName);
	}
}

const char *hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::asJSONString(PString& _buf) const
{
	_buf.cut(0);
	Atf::JSONStringComposer _jsonstr(_buf);
	_jsonstr.compose("errCode", errCode);
	if ( errCode )
	{
		_jsonstr.compose("errDesc", errDesc);
	}
	else
	{
		_jsonstr.compose("clubName", clubName);
		_jsonstr.compose("tablePubName", tablePubName);
		_jsonstr.compose("tournPubName", tournPubName);
		_jsonstr.compose("memberRole", memberRole);
		_jsonstr.compose("memberFlags", memberFlags);
		_jsonstr.compose("wallPubName", wallPubName);
		_jsonstr.compose("announcePubName", announcePubName);
		_jsonstr.compose("membershipPubName", membershipPubName);
	}
	return _buf.c_str();
}

void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::loadFromJSONString(const PString& _jsonString)
{
	Atf::JSONStringParser _jparser(_jsonString);
	_jparser.parseByNameThrow("errCode", errCode);
	if ( errCode )
	{
		_jparser.parseByNameThrow("errDesc", errDesc);
	}
	else
	{
		_jparser.parseByNameThrow("clubName", clubName);
		_jparser.parseByNameThrow("tablePubName", tablePubName);
		_jparser.parseByNameThrow("tournPubName", tournPubName);
		_jparser.parseByNameThrow("memberRole", memberRole);
		_jparser.parseByNameThrow("memberFlags", memberFlags);
		_jparser.parseByNameThrow("wallPubName", wallPubName);
		_jparser.parseByNameThrow("announcePubName", announcePubName);
		_jparser.parseByNameThrow("membershipPubName", membershipPubName);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::validateJSONString(const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	Atf::JSONStringValidatorWithChecker _jparser(_jsonString, _checker, _descr, _fieldsWithUnparsedContent);
	INT16 errCode = 0;
	_jparser.validateByNameThrow("errCode", errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		PString errDesc; _jparser.validateByNameThrow("errDesc", errDesc);
		AtfValidator::validateInt(_descr, "errDesc", errDesc.length(), _checker, __FILE__, __LINE__);
	}
	else
	{
		PString clubName; _jparser.validateByNameThrow("clubName", clubName);
		AtfValidator::validateInt(_descr, "clubName", clubName.length(), _checker, __FILE__, __LINE__);
		PString tablePubName; _jparser.validateByNameThrow("tablePubName", tablePubName);
		AtfValidator::validateInt(_descr, "tablePubName", tablePubName.length(), _checker, __FILE__, __LINE__);
		PString tournPubName; _jparser.validateByNameThrow("tournPubName", tournPubName);
		AtfValidator::validateInt(_descr, "tournPubName", tournPubName.length(), _checker, __FILE__, __LINE__);
		UINT32 memberRole; _jparser.validateByNameThrow("memberRole", memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _jparser.validateByNameThrow("memberFlags", memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
		PString wallPubName; _jparser.validateByNameThrow("wallPubName", wallPubName);
		AtfValidator::validateInt(_descr, "wallPubName", wallPubName.length(), _checker, __FILE__, __LINE__);
		PString announcePubName; _jparser.validateByNameThrow("announcePubName", announcePubName);
		AtfValidator::validateInt(_descr, "announcePubName", announcePubName.length(), _checker, __FILE__, __LINE__);
		PString membershipPubName; _jparser.validateByNameThrow("membershipPubName", membershipPubName);
		AtfValidator::validateInt(_descr, "membershipPubName", membershipPubName.length(), _checker, __FILE__, __LINE__);
	}
}

/*static*/ void hglobby::lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::validateMsg(CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsWithUnparsedContent)
{
	const char *_descr = "HG_GET_CLUB_INFO_REPLY2";
	if(_checker)
	{
		if(!_checker->isValidationEnabled(_descr)) return;
		if(!_checker->hasLimitDefined(_descr)) _checker = nullptr;
	}

	const char *_dummy = "";
	INT16 errCode = 0;
	_parser.parseINT16(errCode);
	AtfValidator::validateInt(_descr, "errCode", errCode, _checker, __FILE__, __LINE__);
	if ( errCode )
	{
		_parser.parseStringN(_dummy, 0, "errDesc"); size_t szErrDesc = strlen(_dummy);
		AtfValidator::validateInt(_descr, "errDesc", szErrDesc, _checker, __FILE__, __LINE__);
	}
	else
	{
		_parser.parseStringN(_dummy, 0, "clubName"); size_t szClubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "clubName", szClubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tablePubName"); size_t szTablePubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tablePubName", szTablePubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "tournPubName"); size_t szTournPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "tournPubName", szTournPubName, _checker, __FILE__, __LINE__);
		UINT32 memberRole; _parser.parseUINT32(memberRole);
		AtfValidator::validateInt(_descr, "memberRole", memberRole, _checker, __FILE__, __LINE__);
		UINT32 memberFlags; _parser.parseUINT32(memberFlags);
		AtfValidator::validateInt(_descr, "memberFlags", memberFlags, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "wallPubName"); size_t szWallPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "wallPubName", szWallPubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "announcePubName"); size_t szAnnouncePubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "announcePubName", szAnnouncePubName, _checker, __FILE__, __LINE__);
		_parser.parseStringN(_dummy, 0, "membershipPubName"); size_t szMembershipPubName = strlen(_dummy);
		AtfValidator::validateInt(_descr, "membershipPubName", szMembershipPubName, _checker, __FILE__, __LINE__);
	}
	if(!_parser.parseEnded()) AtfValidator::logUnparsedInfo(_fieldsWithUnparsedContent, _descr, _parser);
}

//=================================================================
//                ProtocolFactory
//=================================================================

/* static */ Atf::MessageProtocol* hglobby::ProtocolFactory::createMessageProtocolObject(const char *_nameSpace, UINT32 _msgId)
{
	Atf::MessageProtocol *_obj = NULL;

	if(!strcmp(_nameSpace, "lobby_client"))
	{
		switch(_msgId)
		{
			case HG_ADD_USER_CLUB: _obj = new lobby_client::Protocol_HG_ADD_USER_CLUB(); break;
			case HG_ADD_USER_CLUB_REPLY: _obj = new lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY(); break;
			case HG_ARCHIVE_CLUBS: _obj = new lobby_client::Protocol_HG_ARCHIVE_CLUBS(); break;
			case HG_ARCHIVE_CLUBS_REPLY: _obj = new lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY(); break;
			case HG_CANCEL_CLUB_TABLE: _obj = new lobby_client::Protocol_HG_CANCEL_CLUB_TABLE(); break;
			case HG_CANCEL_CLUB_TABLE_REPLY: _obj = new lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY(); break;
			case HG_CANCEL_CLUB_TOURNAMENT: _obj = new lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT(); break;
			case HG_CANCEL_CLUB_TOURNAMENT_REPLY: _obj = new lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY(); break;
			case HG_CHANGE_CLUB_IMAGE: _obj = new lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE(); break;
			case HG_CHANGE_CLUB_IMAGE_REPLY: _obj = new lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY(); break;
			case HG_CHANGE_CLUB_NAME: _obj = new lobby_client::Protocol_HG_CHANGE_CLUB_NAME(); break;
			case HG_CHANGE_CLUB_NAME_REPLY: _obj = new lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY(); break;
			case HG_CHANGE_CLUB_OPTIONS: _obj = new lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS(); break;
			case HG_CHANGE_CLUB_OPTIONS_REPLY: _obj = new lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY(); break;
			case HG_CHANGE_CLUB_PASSWORD: _obj = new lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD(); break;
			case HG_CHANGE_CLUB_PASSWORD_REPLY: _obj = new lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY(); break;
			case HG_CHANGE_PLAYERS_STATUS: _obj = new lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS(); break;
			case HG_CHANGE_PLAYERS_STATUS_REPLY: _obj = new lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY(); break;
			case HG_CHANGE_SEASON_NAME: _obj = new lobby_client::Protocol_HG_CHANGE_SEASON_NAME(); break;
			case HG_CHANGE_SEASON_NAME_REPLY: _obj = new lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY(); break;
			case HG_CLOSE_CLUB_BY_FOUNDER: _obj = new lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER(); break;
			case HG_CLOSE_CLUB_BY_FOUNDER_REPLY: _obj = new lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY(); break;
			case HG_CLUB_LOGIN: _obj = new lobby_client::Protocol_HG_CLUB_LOGIN(); break;
			case HG_CLUB_LOGIN_REPLY: _obj = new lobby_client::Protocol_HG_CLUB_LOGIN_REPLY(); break;
			case HG_CLUB_LOGOUT: _obj = new lobby_client::Protocol_HG_CLUB_LOGOUT(); break;
			case HG_CLUB_LOGOUT_REPLY: _obj = new lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY(); break;
			case HG_CREATE_CLUB: _obj = new lobby_client::Protocol_HG_CREATE_CLUB(); break;
			case HG_CREATE_CLUB_REPLY: _obj = new lobby_client::Protocol_HG_CREATE_CLUB_REPLY(); break;
			case HG_CREATE_CLUB_TABLE: _obj = new lobby_client::Protocol_HG_CREATE_CLUB_TABLE(); break;
			case HG_CREATE_CLUB_TABLE_REPLY: _obj = new lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY(); break;
			case HG_CREATE_CLUB_TOURN: _obj = new lobby_client::Protocol_HG_CREATE_CLUB_TOURN(); break;
			case HG_CREATE_CLUB_TOURN2: _obj = new lobby_client::Protocol_HG_CREATE_CLUB_TOURN2(); break;
			case HG_CREATE_CLUB_TOURN3: _obj = new lobby_client::Protocol_HG_CREATE_CLUB_TOURN3(); break;
			case HG_CREATE_CLUB_TOURN_REPLY: _obj = new lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY(); break;
			case HG_CREATE_CLUB_TOURN_REPLY2: _obj = new lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2(); break;
			case HG_CREATE_CLUB_TOURN_REPLY3: _obj = new lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3(); break;
			case HG_FOUNDER_GET_CLUB_PASSWORD: _obj = new lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD(); break;
			case HG_FOUNDER_GET_CLUB_PASSWORD_REPLY: _obj = new lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY(); break;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES: _obj = new lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES(); break;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES2: _obj = new lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2(); break;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY(); break;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2: _obj = new lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2(); break;
			case HG_GET_CLUB_INFO: _obj = new lobby_client::Protocol_HG_GET_CLUB_INFO(); break;
			case HG_GET_CLUB_INFO2: _obj = new lobby_client::Protocol_HG_GET_CLUB_INFO2(); break;
			case HG_GET_CLUB_INFO_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY(); break;
			case HG_GET_CLUB_INFO_REPLY2: _obj = new lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2(); break;
			case HG_GET_CLUB_OPTIONS: _obj = new lobby_client::Protocol_HG_GET_CLUB_OPTIONS(); break;
			case HG_GET_CLUB_OPTIONS_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY(); break;
			case HG_GET_CLUB_SEASONS: _obj = new lobby_client::Protocol_HG_GET_CLUB_SEASONS(); break;
			case HG_GET_CLUB_SEASONS_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY(); break;
			case HG_GET_CLUB_SEASON_RANKS: _obj = new lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS(); break;
			case HG_GET_CLUB_SEASON_RANKS_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY(); break;
			case HG_GET_CLUB_SEASON_STATS: _obj = new lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS(); break;
			case HG_GET_CLUB_SEASON_STATS_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY(); break;
			case HG_GET_CLUB_TABLE_INFO: _obj = new lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO(); break;
			case HG_GET_CLUB_TABLE_INFO_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY(); break;
			case HG_GET_CLUB_TABLE_STRUCTURES: _obj = new lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES(); break;
			case HG_GET_CLUB_TABLE_STRUCTURES2: _obj = new lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2(); break;
			case HG_GET_CLUB_TABLE_STRUCTURES_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY(); break;
			case HG_GET_CLUB_TABLE_STRUCTURES_REPLY2: _obj = new lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2(); break;
			case HG_GET_CLUB_TOURN_INFO: _obj = new lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO(); break;
			case HG_GET_CLUB_TOURN_INFO_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY(); break;
			case HG_GET_CLUB_TOURN_STRUCTURES: _obj = new lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES(); break;
			case HG_GET_CLUB_TOURN_STRUCTURES2: _obj = new lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2(); break;
			case HG_GET_CLUB_TOURN_STRUCTURES_REPLY: _obj = new lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY(); break;
			case HG_GET_CLUB_TOURN_STRUCTURES_REPLY2: _obj = new lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2(); break;
			case HG_GET_PLAYERS_BASED_ON_STATUS: _obj = new lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS(); break;
			case HG_GET_PLAYERS_BASED_ON_STATUS_REPLY: _obj = new lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY(); break;
			case HG_GET_RECENT_TOURN_RESULTS: _obj = new lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS(); break;
			case HG_GET_RECENT_TOURN_RESULTS2: _obj = new lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2(); break;
			case HG_GET_RECENT_TOURN_RESULTS_REPLY: _obj = new lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY(); break;
			case HG_GET_RECENT_TOURN_RESULTS_REPLY2: _obj = new lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2(); break;
			case HG_GET_RECENT_TOURN_SUMMARIES: _obj = new lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES(); break;
			case HG_GET_RECENT_TOURN_SUMMARIES2: _obj = new lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2(); break;
			case HG_GET_RECENT_TOURN_SUMMARIES_REPLY: _obj = new lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY(); break;
			case HG_GET_RECENT_TOURN_SUMMARIES_REPLY2: _obj = new lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2(); break;
			case HG_GET_RECRUIT_SOCIAL_TOKEN: _obj = new lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN(); break;
			case HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY: _obj = new lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY(); break;
			case HG_GET_SCHEDULED_GAMES: _obj = new lobby_client::Protocol_HG_GET_SCHEDULED_GAMES(); break;
			case HG_GET_SCHEDULED_GAMES2: _obj = new lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2(); break;
			case HG_GET_SCHEDULED_GAMES_REPLY: _obj = new lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY(); break;
			case HG_GET_SCHEDULED_GAMES_REPLY2: _obj = new lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2(); break;
			case HG_GET_USER_CLUBS: _obj = new lobby_client::Protocol_HG_GET_USER_CLUBS(); break;
			case HG_GET_USER_CLUBS_REPLY: _obj = new lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY(); break;
			case HG_MODIFY_MEMBERSHIP_FLAGS: _obj = new lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS(); break;
			case HG_MODIFY_MEMBERSHIP_FLAGS_REPLY: _obj = new lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY(); break;
			case HG_PROCESS_SEASON_CLOSED: _obj = new lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED(); break;
			case HG_PROCESS_SEASON_CLOSED_REPLY: _obj = new lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY(); break;
			case HG_SAVE_CLUB_MESSAGE: _obj = new lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE(); break;
			case HG_SAVE_CLUB_MESSAGE_REPLY: _obj = new lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY(); break;
			case HG_SET_ARCHIVE_PENDING: _obj = new lobby_client::Protocol_HG_SET_ARCHIVE_PENDING(); break;
			case HG_SET_ARCHIVE_PENDING_REPLY: _obj = new lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY(); break;
			case HG_SET_CLUB_COLOR: _obj = new lobby_client::Protocol_HG_SET_CLUB_COLOR(); break;
			case HG_SET_CLUB_COLOR_REPLY: _obj = new lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY(); break;
			case HG_SET_FAVORITE_CLUB: _obj = new lobby_client::Protocol_HG_SET_FAVORITE_CLUB(); break;
			case HG_SET_FAVORITE_CLUB_REPLY: _obj = new lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY(); break;
			case HG_TABLE_SOCIAL_TOKEN: _obj = new lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN(); break;
			case HG_TABLE_SOCIAL_TOKEN_REPLY: _obj = new lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY(); break;
			case HG_TOURN_SOCIAL_TOKEN: _obj = new lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN(); break;
			case HG_TOURN_SOCIAL_TOKEN_REPLY: _obj = new lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY(); break;
			case HG_TRANSLATE_SOCIAL_EVENT: _obj = new lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT(); break;
			case HG_TRANSLATE_SOCIAL_EVENT_REPLY: _obj = new lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY(); break;
			case HG_UPDATE_MEMBERSHIP_FLAGS: _obj = new lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS(); break;
			case HG_UPDATE_MEMBERSHIP_FLAGS2: _obj = new lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2(); break;
			case HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY: _obj = new lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY(); break;
			case HG_UPDATE_MEMBERSHIP_FLAGS_REPLY: _obj = new lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY(); break;
		}
	}
	
	return _obj;
}

/* static */ bool hglobby::ProtocolFactory::validateProtocolMessageFromJSONString(const char *_nameSpace, UINT32 _msgId, const PString& _jsonString, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "lobby_client"))
	{
		switch(_msgId)
		{
			case HG_ADD_USER_CLUB: lobby_client::Protocol_HG_ADD_USER_CLUB::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_ADD_USER_CLUB_REPLY: lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_ARCHIVE_CLUBS: lobby_client::Protocol_HG_ARCHIVE_CLUBS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_ARCHIVE_CLUBS_REPLY: lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TABLE: lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TABLE_REPLY: lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TOURNAMENT: lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TOURNAMENT_REPLY: lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_IMAGE: lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_IMAGE_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_NAME: lobby_client::Protocol_HG_CHANGE_CLUB_NAME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_NAME_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_OPTIONS: lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_OPTIONS_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_PASSWORD: lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_PASSWORD_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_PLAYERS_STATUS: lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_PLAYERS_STATUS_REPLY: lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_SEASON_NAME: lobby_client::Protocol_HG_CHANGE_SEASON_NAME::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_SEASON_NAME_REPLY: lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CLOSE_CLUB_BY_FOUNDER: lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CLOSE_CLUB_BY_FOUNDER_REPLY: lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGIN: lobby_client::Protocol_HG_CLUB_LOGIN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGIN_REPLY: lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGOUT: lobby_client::Protocol_HG_CLUB_LOGOUT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGOUT_REPLY: lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB: lobby_client::Protocol_HG_CREATE_CLUB::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_REPLY: lobby_client::Protocol_HG_CREATE_CLUB_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TABLE: lobby_client::Protocol_HG_CREATE_CLUB_TABLE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TABLE_REPLY: lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN: lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN2: lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN3: lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN_REPLY: lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN_REPLY2: lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN_REPLY3: lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_FOUNDER_GET_CLUB_PASSWORD: lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_FOUNDER_GET_CLUB_PASSWORD_REPLY: lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES2: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO: lobby_client::Protocol_HG_GET_CLUB_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO2: lobby_client::Protocol_HG_GET_CLUB_INFO2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO_REPLY: lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO_REPLY2: lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_OPTIONS: lobby_client::Protocol_HG_GET_CLUB_OPTIONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_OPTIONS_REPLY: lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASONS: lobby_client::Protocol_HG_GET_CLUB_SEASONS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASONS_REPLY: lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_RANKS: lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_RANKS_REPLY: lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_STATS: lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_STATS_REPLY: lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_INFO: lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_INFO_REPLY: lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES2: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES_REPLY: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES_REPLY2: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_INFO: lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_INFO_REPLY: lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES2: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES_REPLY: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES_REPLY2: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_PLAYERS_BASED_ON_STATUS: lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_PLAYERS_BASED_ON_STATUS_REPLY: lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS2: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS_REPLY: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS_REPLY2: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES2: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES_REPLY: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES_REPLY2: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECRUIT_SOCIAL_TOKEN: lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY: lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES2: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES_REPLY: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES_REPLY2: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_USER_CLUBS: lobby_client::Protocol_HG_GET_USER_CLUBS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_USER_CLUBS_REPLY: lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_MODIFY_MEMBERSHIP_FLAGS: lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_MODIFY_MEMBERSHIP_FLAGS_REPLY: lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_PROCESS_SEASON_CLOSED: lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_PROCESS_SEASON_CLOSED_REPLY: lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_SAVE_CLUB_MESSAGE: lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_SAVE_CLUB_MESSAGE_REPLY: lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_ARCHIVE_PENDING: lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_ARCHIVE_PENDING_REPLY: lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_CLUB_COLOR: lobby_client::Protocol_HG_SET_CLUB_COLOR::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_CLUB_COLOR_REPLY: lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_FAVORITE_CLUB: lobby_client::Protocol_HG_SET_FAVORITE_CLUB::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_FAVORITE_CLUB_REPLY: lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_TABLE_SOCIAL_TOKEN: lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_TABLE_SOCIAL_TOKEN_REPLY: lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_TOURN_SOCIAL_TOKEN: lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_TOURN_SOCIAL_TOKEN_REPLY: lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_TRANSLATE_SOCIAL_EVENT: lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_TRANSLATE_SOCIAL_EVENT_REPLY: lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS2: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS_REPLY: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::validateJSONString(_jsonString, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

/* static */ bool hglobby::ProtocolFactory::validateProtocolMessage(const char *_nameSpace, UINT32 _msgId, CommMsgParser& _parser, const AtfMsgChecker* _checker, PString& _fieldsNotParseEnded)
{
	if(!strcmp(_nameSpace, "lobby_client"))
	{
		switch(_msgId)
		{
			case HG_ADD_USER_CLUB: lobby_client::Protocol_HG_ADD_USER_CLUB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_ADD_USER_CLUB_REPLY: lobby_client::Protocol_HG_ADD_USER_CLUB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_ARCHIVE_CLUBS: lobby_client::Protocol_HG_ARCHIVE_CLUBS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_ARCHIVE_CLUBS_REPLY: lobby_client::Protocol_HG_ARCHIVE_CLUBS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TABLE: lobby_client::Protocol_HG_CANCEL_CLUB_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TABLE_REPLY: lobby_client::Protocol_HG_CANCEL_CLUB_TABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TOURNAMENT: lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CANCEL_CLUB_TOURNAMENT_REPLY: lobby_client::Protocol_HG_CANCEL_CLUB_TOURNAMENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_IMAGE: lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_IMAGE_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_IMAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_NAME: lobby_client::Protocol_HG_CHANGE_CLUB_NAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_NAME_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_NAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_OPTIONS: lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_OPTIONS_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_PASSWORD: lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_CLUB_PASSWORD_REPLY: lobby_client::Protocol_HG_CHANGE_CLUB_PASSWORD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_PLAYERS_STATUS: lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_PLAYERS_STATUS_REPLY: lobby_client::Protocol_HG_CHANGE_PLAYERS_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_SEASON_NAME: lobby_client::Protocol_HG_CHANGE_SEASON_NAME::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CHANGE_SEASON_NAME_REPLY: lobby_client::Protocol_HG_CHANGE_SEASON_NAME_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLOSE_CLUB_BY_FOUNDER: lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLOSE_CLUB_BY_FOUNDER_REPLY: lobby_client::Protocol_HG_CLOSE_CLUB_BY_FOUNDER_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGIN: lobby_client::Protocol_HG_CLUB_LOGIN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGIN_REPLY: lobby_client::Protocol_HG_CLUB_LOGIN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGOUT: lobby_client::Protocol_HG_CLUB_LOGOUT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CLUB_LOGOUT_REPLY: lobby_client::Protocol_HG_CLUB_LOGOUT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB: lobby_client::Protocol_HG_CREATE_CLUB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_REPLY: lobby_client::Protocol_HG_CREATE_CLUB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TABLE: lobby_client::Protocol_HG_CREATE_CLUB_TABLE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TABLE_REPLY: lobby_client::Protocol_HG_CREATE_CLUB_TABLE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN: lobby_client::Protocol_HG_CREATE_CLUB_TOURN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN2: lobby_client::Protocol_HG_CREATE_CLUB_TOURN2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN3: lobby_client::Protocol_HG_CREATE_CLUB_TOURN3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN_REPLY: lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN_REPLY2: lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_CREATE_CLUB_TOURN_REPLY3: lobby_client::Protocol_HG_CREATE_CLUB_TOURN_REPLY3::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_FOUNDER_GET_CLUB_PASSWORD: lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_FOUNDER_GET_CLUB_PASSWORD_REPLY: lobby_client::Protocol_HG_FOUNDER_GET_CLUB_PASSWORD_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES2: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2: lobby_client::Protocol_HG_GET_CLUBS_AND_SCHEDULED_GAMES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO: lobby_client::Protocol_HG_GET_CLUB_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO2: lobby_client::Protocol_HG_GET_CLUB_INFO2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO_REPLY: lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_INFO_REPLY2: lobby_client::Protocol_HG_GET_CLUB_INFO_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_OPTIONS: lobby_client::Protocol_HG_GET_CLUB_OPTIONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_OPTIONS_REPLY: lobby_client::Protocol_HG_GET_CLUB_OPTIONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASONS: lobby_client::Protocol_HG_GET_CLUB_SEASONS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASONS_REPLY: lobby_client::Protocol_HG_GET_CLUB_SEASONS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_RANKS: lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_RANKS_REPLY: lobby_client::Protocol_HG_GET_CLUB_SEASON_RANKS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_STATS: lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_SEASON_STATS_REPLY: lobby_client::Protocol_HG_GET_CLUB_SEASON_STATS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_INFO: lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_INFO_REPLY: lobby_client::Protocol_HG_GET_CLUB_TABLE_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES2: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES_REPLY: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TABLE_STRUCTURES_REPLY2: lobby_client::Protocol_HG_GET_CLUB_TABLE_STRUCTURES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_INFO: lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_INFO_REPLY: lobby_client::Protocol_HG_GET_CLUB_TOURN_INFO_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES2: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES_REPLY: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_CLUB_TOURN_STRUCTURES_REPLY2: lobby_client::Protocol_HG_GET_CLUB_TOURN_STRUCTURES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_PLAYERS_BASED_ON_STATUS: lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_PLAYERS_BASED_ON_STATUS_REPLY: lobby_client::Protocol_HG_GET_PLAYERS_BASED_ON_STATUS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS2: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS_REPLY: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_RESULTS_REPLY2: lobby_client::Protocol_HG_GET_RECENT_TOURN_RESULTS_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES2: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES_REPLY: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECENT_TOURN_SUMMARIES_REPLY2: lobby_client::Protocol_HG_GET_RECENT_TOURN_SUMMARIES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECRUIT_SOCIAL_TOKEN: lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY: lobby_client::Protocol_HG_GET_RECRUIT_SOCIAL_TOKEN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES2: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES_REPLY: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_SCHEDULED_GAMES_REPLY2: lobby_client::Protocol_HG_GET_SCHEDULED_GAMES_REPLY2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_USER_CLUBS: lobby_client::Protocol_HG_GET_USER_CLUBS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_GET_USER_CLUBS_REPLY: lobby_client::Protocol_HG_GET_USER_CLUBS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_MODIFY_MEMBERSHIP_FLAGS: lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_MODIFY_MEMBERSHIP_FLAGS_REPLY: lobby_client::Protocol_HG_MODIFY_MEMBERSHIP_FLAGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_PROCESS_SEASON_CLOSED: lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_PROCESS_SEASON_CLOSED_REPLY: lobby_client::Protocol_HG_PROCESS_SEASON_CLOSED_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SAVE_CLUB_MESSAGE: lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SAVE_CLUB_MESSAGE_REPLY: lobby_client::Protocol_HG_SAVE_CLUB_MESSAGE_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_ARCHIVE_PENDING: lobby_client::Protocol_HG_SET_ARCHIVE_PENDING::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_ARCHIVE_PENDING_REPLY: lobby_client::Protocol_HG_SET_ARCHIVE_PENDING_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_CLUB_COLOR: lobby_client::Protocol_HG_SET_CLUB_COLOR::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_CLUB_COLOR_REPLY: lobby_client::Protocol_HG_SET_CLUB_COLOR_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_FAVORITE_CLUB: lobby_client::Protocol_HG_SET_FAVORITE_CLUB::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_SET_FAVORITE_CLUB_REPLY: lobby_client::Protocol_HG_SET_FAVORITE_CLUB_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TABLE_SOCIAL_TOKEN: lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TABLE_SOCIAL_TOKEN_REPLY: lobby_client::Protocol_HG_TABLE_SOCIAL_TOKEN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TOURN_SOCIAL_TOKEN: lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TOURN_SOCIAL_TOKEN_REPLY: lobby_client::Protocol_HG_TOURN_SOCIAL_TOKEN_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TRANSLATE_SOCIAL_EVENT: lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_TRANSLATE_SOCIAL_EVENT_REPLY: lobby_client::Protocol_HG_TRANSLATE_SOCIAL_EVENT_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS2: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS2_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
			case HG_UPDATE_MEMBERSHIP_FLAGS_REPLY: lobby_client::Protocol_HG_UPDATE_MEMBERSHIP_FLAGS_REPLY::validateMsg(_parser, _checker, _fieldsNotParseEnded); return true;
		}
	}
	
	return false;
}

